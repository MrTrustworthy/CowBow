(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

var GameObject = require("../common/gameobject");
var THREE = require("../../lib/three");
var Point = require("../common/point");
var Tween = require("../common/tween");
var Deferred = require("../../lib/mt-promise");

class Actor extends GameObject {

    /**
     *
     * @param node MapNode
     */
    constructor(node) {
        super();

        node.lock();
        this.node = node; // mapnode

        this.mesh = this.generate_model();
        this.mesh.userData = this;


        this.busy = false; // will be "true" if moving
        this.busy_with = null; // promise of movement that resolves/rejects

        // call this.abort() this to force cancelling the current moving after next field
        this.__abort_request = false;

    }

    /**
     * Aborts the current movement after the next step and returns a promise
     * that resolves when the movement has ended.
     *
     * Also resolves if the movement hasn't been force-ended if it coincidentally ends on the next step
     *
     * @returns {null|*}
     */
    abort() {
        let def = new Deferred();
        this.__abort_request = true;

        this.busy_with.then(
            () => def.resolve(),
            () => def.resolve()
        );
        return def.promise;
    }


    /**
     * Moves to a neighbouring node
     * @param target MAKE SURE ITS A NEIGHBOUR OR IT'LL LOOK WEIRD
     * @returns promise that resolves when target is reaches and rejects if it's impossible
     */
    move_to(target) {
        let def = new Deferred();

        // guard statements
        if (this.__abort_request || this.busy || target.locked) {

            let reasons = {
                aborted: this.__abort_request,
                busy: this.busy,
                locked: target.locked
            };

            // reset abortion flag
            this.__abort_request = false;

            def.reject(reasons);
            return def.promise;
        }

        //if not, proceed
        this.busy = true;
        this.busy_with = def.promise;

        // lock target so nobody else tries to walk there
        target.lock();

        // get the tweening points
        let points = new Tween(this.node.point, target.point, 10);
        points = Array.from(points);

        // put the move-function into the current hooks
        var update_func = function () {

            let current = points.shift();

            this.mesh.position.x = current.x;
            this.mesh.position.y = current.y;
            this.mesh.position.z = current.z;

            if (points.length === 0) {

                // stop moving
                this.removeEventListener("scene_updated", update_func);

                // unlock the old node and set the current node to the new position
                this.node.unlock();
                this.node = target;

                // not busy anymore
                this.busy = false;
                this.busy_with = null;

                def.resolve();
            }
        }.bind(this);


        this.addEventListener("scene_updated", update_func);

        return def.promise;
    }


    /**
     *
     * @returns {THREE.Mesh}
     */
    generate_model() {
        let geometry = new THREE.BoxGeometry(1, 1, 1);
        let material = new THREE.MeshLambertMaterial({color: 0xff0000});
        let mesh = new THREE.Mesh(geometry, material);
        mesh.position.x = this.node.point.x;
        mesh.position.y = this.node.point.y;
        mesh.position.z = this.node.point.z;
        return mesh;
    }

}


module.exports = Actor;

},{"../../lib/mt-promise":19,"../../lib/three":20,"../common/gameobject":4,"../common/point":6,"../common/tween":7}],2:[function(require,module,exports){
"use strict";

/**
 * Helper class for actor movement
 */
class Transporter {


    /**
     * Singletons are evil
     *
     * @param actor
     * @param target
     * @param map
     */
    static move(actor, target, map) {

        let nodes;

        try {
            // get the path
            nodes = map.get_path(actor.node.point, target.point);
            nodes = Array.from(nodes).slice(1);

        } catch (e) {

            // abort if the target field is already locked or generally unpassable
            // because honestly, this will happen often
            if (e instanceof EvalError || e instanceof RangeError) {
                console.info("#Transporter: Can't find path", e);
                return;
            } else {
                // something unexpected happened, in that case
                throw e;
            }
        }


        var handle_move_error = function (error) {
            if (error.aborted) {
                // do nothing if aborted except not moving any further
                console.info("#Transporter: Actor movement was aborted:", error);
            } else if (error.busy) {
                // if busy, abort current movement then try again
                actor.abort().then(() => Transporter.move(actor, target, map));
            } else if (error.locked) {
                // if locked, try again
                Transporter.move(actor, target, map);
            }
        };


        var move_func = function () {
            let next = nodes.shift();
            if (!next) return;

            actor.move_to(next).then(
                move_func,
                handle_move_error
            );
        };

        move_func();
    }

}

module.exports = Transporter;

},{}],3:[function(require,module,exports){
"use strict";

var THREE = require("../lib/three");
var GameObject = require("./common/gameobject");
/**
 * This class is responsible for the renderer, scene etc.
 * It basically handles all the animation-related stuff
 *
 * TODO: Handle window resize here
 */
class Animation {

    /**
     * Creates new Animation-Object and sets up the surrounding (everything but the bodies themselves)
     */
    constructor() {

        THREE.EventDispatcher.prototype.apply(this);
        this.canvas = document.getElementById("main_canvas");


        this.context = this.canvas.getContext("webgl");

        this.renderer = new THREE.WebGLRenderer({
            canvas: this.canvas,
            context: this.context,
            antialias: true
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);

        this.scene = new THREE.Scene();


        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.camera.position.x = 50;
        this.camera.position.y = 25;
        this.camera.position.z = 50;
        this.camera.rotation.x = 0.3;


        var directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(0, 6, 12);
        this.scene.add(directionalLight);

        this.actors = [];

    }


    /**
     * Loads the map
     * @param map
     */
    load_map(map) {
        this.scene.add(map.mesh);
        map.resources.forEach(res => this.scene.add(res.mesh));
    }

    /**
     * Adds an element to the scene
     *
     * @param obj
     */
    add_element(obj) {
        if (!(obj instanceof GameObject)) throw new TypeError("#Animation: Can only add gameobjects to the scene");
        this.actors.push(obj);
        this.scene.add(obj.mesh);
    }


    /**
     * Starts the animation
     */
    start() {
        // recursive call
        requestAnimationFrame(this.start.bind(this));
        // this way we can hook tweens and stuff like that on each frame
        this.actors.forEach(x => x.dispatchEvent({type: "scene_updated"}));
        this.dispatchEvent({type: "scene_updated"});
        this.renderer.render(this.scene, this.camera);
    }


}

module.exports = Animation;

},{"../lib/three":20,"./common/gameobject":4}],4:[function(require,module,exports){
"use strict";

var THREE = require("../../lib/three");

// just for fun; need a git-hook or something that throws errors if it sees "getownpropertysymbols"
var meshSymbol = Symbol();

/**
 * Parent class for all Gameobjects which guarantees availability of common gameobject-properties like meshes
 */
class GameObject {

    /**
     * we __NEED__ to call this in all subclasses!
     */
    constructor(){
        THREE.EventDispatcher.prototype.apply(this);

    }

    /**
     * Overwrite!
     */
    progress(){

    }

    /**
     * returns the mesh if asked for it
     * @returns {*}
     */
    get mesh(){
        if (this[meshSymbol]) return this[meshSymbol];
        else{
            let geometry = new THREE.BoxGeometry(1, 1, 1);
            let material = new THREE.MeshLambertMaterial({color: 0xffffff});
            return new THREE.Mesh(geometry, material);
        }
    }

    /**
     * make sure we can not overwrite the mesh
     * @param mesh
     */
    set mesh(mesh){
        if (this[meshSymbol]) throw new ReferenceError("Can't overwrite existing meshes!");
        this[meshSymbol] = mesh;
    }

}

module.exports = GameObject;

},{"../../lib/three":20}],5:[function(require,module,exports){
"use strict";

var listSymbol = Symbol();

/**
 * A simple 2d-list class
 *
 * TODO: maybe invert rows/cols in the data structure because we have to query rows more often
 * and it's currently more expensive
 */
class List2D {

    /**
     * initializes an empty 2d list with null-values
     * @param width: first value, akin to X in a screen coordinate system
     * @param length: second value, akin to Y in a screen coordinate system
     */
    constructor(width, length) {

        this.width = this.columns = width || 1;
        this.length = this.rows = length || this.width;

        let col_array = new Array(this.length);
        col_array.fill(null);

        this[listSymbol] = [];
        for (let i = 0; i < this.width; i++) {
            this[listSymbol][i] = col_array.slice(0);
        }

    }

    get(x, y) {

        return this[listSymbol][x][y];
    }

    /**
     * returns all surrounding points of a point x:y
     * @param x
     * @param y
     */
    get_surrounding(x, y) {

        let list = [];

        for (let xi = x - 1; xi <= x + 1; xi++) {
            for (let yi = y - 1; yi <= y + 1; yi++) {

                if (xi === x && yi === y) continue;
                if (xi < 0 || xi >= this.width || yi < 0 || yi >= this.length) continue;

                let elem = this.get(xi, yi);
                if(!elem) debugger;
                list.push(elem);

            }
        }
        return list;
    }

    set(x, y, value) {
        return this[listSymbol][x][y] = value;
    }

    /**
     * foreach goes from top-left to bottom-right
     * @param callback
     */
    for_each(callback) {
        for (let i = 0; i < this.rows; i++) {
            this.get_row(i).forEach((elem, j) => callback(elem, j, i));
        }
    }


    get_row(index) {
        return this[listSymbol].map(sublist => sublist[index]);
    }

    get_col(index) {
        return this[listSymbol][index].slice(0);
    }


    /**
     * prints the list from top-left to bottom-right;
     */
    print() {
        let output = "";
        let current_row = 0;
        this.for_each(function (elem, x, y) {
            if (y > current_row) output += "\n";
            output += " | " + String(elem) + " | ";
            current_row = y;
        });
        console.log(output);
    }


}

module.exports = List2D;
},{}],6:[function(require,module,exports){
"use strict";

var THREE = require("../../lib/three");

class Point {

    constructor(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z || 0;
    }

    to_vector(){
        return new THREE.Vector3(this.x, this.y, this.z);
    }

    /**
     * Calculates the distance between two points
     * @param other
     * @param include_z
     * @returns {number}
     */
    distance_to(other, include_z){

        include_z = include_z || false;
        if(include_z) throw new ReferenceError("#Point: Distance based on Z not implemented!");

        return Math.sqrt(Math.pow(other.x - this.x, 2) + Math.pow(other.y - this.y, 2));

    };

    equals(other){
        return this.x === other.x && this.y === other.y;
    }

    /**
     * Pretty prints
     * @returns {*}
     */
    toString(){
        return `(${this.x}:${this.y}:${this.z})`;
    }

}

module.exports = Point;

},{"../../lib/three":20}],7:[function(require,module,exports){
"use strict";


/**
 * Usage:
 *
 * let a = new Tween({x: 0}, {x: 10}, 4);
 * for(var i of a){
 *   console.log(i);
 * }
 *
 */
class Tween {

    constructor(from, to, steps) {

        let keys = Object.keys(from);

        let current_step = 0;
        let current_val = {};
        let step_size = {};

        keys.forEach(function (key) {
            current_val[key] = from[key];
            step_size[key] = (to[key] - from[key]) / steps;
        });


        this[Symbol.iterator] = function* () {

            while (current_step < steps) {
                current_step++;
                keys.forEach(key => current_val[key] += step_size[key]);

                // clone and return object
                let clone = {};
                keys.forEach(key=> clone[key] = current_val[key]);

                yield clone;
            }
        }


    }

}


module.exports = Tween;

},{}],8:[function(require,module,exports){
"use strict";

var THREE = require("../../lib/three");

class InputHandler {

    constructor(camera, scene){

        THREE.EventDispatcher.call(this);

        this.camera = camera;
        this.scene = scene;

        window.onkeydown = this.handle_keydown.bind(this);
        window.onmousewheel = this.handle_mousewheel.bind(this);
    }




    handle_mousewheel(evt){
        this.camera.position.z += evt.wheelDelta > 0 ? -1 : 1;
    }

    handle_keydown(evt){
        let keybinds = {
            D: [1, 0],
            S: [0, -1],
            A:  [-1, 0],
            W: [0, 1]
        };

        let key = evt.code.substring(3);

        if(!keybinds[key]){
            return;
        }

        let delta = keybinds[key];

        this.camera.position.x += delta[0] * 4;
        this.camera.position.y += delta[1] * 4;

    }





}

module.exports = InputHandler;

},{"../../lib/three":20}],9:[function(require,module,exports){
"use strict";

var InputHandler = require("./inputhandler");
var THREE = require("../../lib/three");
var Map = require("../map/map");
var MapNode = require("../map/mapnode");
var Actor = require("../actor/actor");
var Transporter = require("../actor/transporter");
var GameObject = require("../common/gameobject");
var Path = require("../map/path");
var MouseHandler = require("./mousehandler");


class MainController {

    constructor(animation, map, actors) {
        this.animation = animation;
        this.map = map;
        this.actors = actors;

        this.selection = [];

        this.input_handler = new InputHandler(animation.camera, animation.scene);
        this.mouse_handler = new MouseHandler(animation, map, actors);

        this.mouse_handler.on("click", this.handle_click.bind(this));
        this.mouse_handler.on("selection", this.handle_select.bind(this));
        this.mouse_handler.on("rightclick", this.handle_rightclick.bind(this));


    }

    /**
     *
     * @param clicked Object{object, face, point, ...)
     */
    handle_click(clicked) {
        console.log("#MC: click", clicked);

        let obj = clicked.object;

        if (obj.userData instanceof Actor) this.selection = [obj.userData];
        else this.selection.length = 0;

    }

    /**
     *
     * @param selections Array<Actor>
     */
    handle_select(selections) {
        console.log("#MC: select", selections);
        this.selection.length = 0;
        this.selection.push.apply(this.selection, selections);
    }

    /**
     * If actors are selected, will send them to the target field
     *
     * @param clicked Object{object, face, point, ...)
     */
    handle_rightclick(clicked) {
        console.log("#MC: rightclick", clicked);

        if(this.selection.length === 0) return;

        let geo_verts = clicked.object.geometry.vertices;

        this.selection.forEach( actor => {

            // determine the vertices based on the clicked face
            let verts = [
                geo_verts[clicked.face.a],
                geo_verts[clicked.face.b],
                geo_verts[clicked.face.c]
            ];
            // get the corresponding map-nodes
            let map_nodes = verts.map(v => this.map.structure.get(v.x, v.y));

            // check for passable nodes only
            let valid = map_nodes.filter(n => n.passable);

            if (valid.length === 0) throw new RangeError("#MainController: can't work with unpassable map nodes!");

            let target = valid.pop();

            // transporter will handle all other stuff
            Transporter.move(actor, target, this.map)

        });

    }


}

module.exports = MainController;

},{"../../lib/three":20,"../actor/actor":1,"../actor/transporter":2,"../common/gameobject":4,"../map/map":12,"../map/mapnode":13,"../map/path":15,"./inputhandler":8,"./mousehandler":10}],10:[function(require,module,exports){
"use strict";

let THREE = require("../../lib/three");
let Evented = require("../../lib/mt-event");


class MouseHandler {


    /**
     *
     * @param animation
     * @param map
     */
    constructor(animation, map, actors) {

        Evented.makeEvented(this);

        this.click_delay = 0.2 * 1000;

        this.animation = animation;
        this.map = map;
        this.actors = actors;

        this.mousedown = false;
        this.mousedown_evt = null;
        this.mousedown_obj_buffer = null;
        this.mousedown_time = null;


        // special three js mesh that we use to display selection
        this.selection_model = this.load_selection_model();
        this.animation.scene.add(this.selection_model);

        this.load_hooks();

    }

    /**
     *
     */
    load_hooks() {

        window.onmousedown = this.onmousedown.bind(this);
        window.onmouseup = this.onmouseup.bind(this);
        window.oncontextmenu = this.oncontextmenu.bind(this);
        window.onmousemove = this.onmousemove.bind(this);

    }


    /**
     *
     * @param evt
     */
    onmousedown(evt) {
        // in the case of rightclicks:
        if (evt.button !== 0) return;

        this.mousedown = true;
        this.mousedown_evt = evt;
        this.mousedown_time = Date.now();
    }

    /**
     *
     * @param evt
     */
    onmousemove(evt) {

        if (!this.mousedown || this.mousedown_time + this.click_delay > Date.now()) return;

        let geometry = this.selection_model.geometry;

        if (!this.mousedown_obj_buffer) this.mousedown_obj_buffer = this._get_object(this.mousedown_evt);


        let p1 = this.mousedown_obj_buffer.point;
        let p4 = this._get_object(evt).point;
        var p2, p3;

        // need to switch vertices in top-right and bottom-left quadrants
        // so we can make sure that faces always face upwards

        // if in top-left or bottom-right quadrant:
        if ((p4.x > p1.x && p4.y < p1.y) || (p4.x < p1.x && p4.y > p1.y)) {
            p2 = p1.clone();
            p2.x = p4.x;
            p3 = p1.clone();
            p3.y = p4.y;
        } else {
            p3 = p1.clone();
            p3.x = p4.x;
            p2 = p1.clone();
            p2.y = p4.y;
        }

        [p1, p2, p3, p4].forEach((p, i) => {
            geometry.vertices[i].x = p.x;
            geometry.vertices[i].y = p.y;
            geometry.vertices[i].z = 5;
        });

        geometry.verticesNeedUpdate = true;

        this.selection_model.visible = true;


    }


    /**
     *
     * @param evt
     */
    onmouseup(evt) {

        // in the case of rightclicks:
        if (evt.button !== 0) return;

        if (this.mousedown_time + this.click_delay > Date.now()) {
            this.emit("click", this._get_object(evt));
        } else {
            this._calculate_selection();
        }

        // cleanup the mess
        this.mousedown = false;
        this.mousedown_evt = null;
        this.mousedown_time = null;
        this.mousedown_obj_buffer = null;
        this.selection_model.visible = false;

    }


    /**
     *
     * @param evt
     * @returns {boolean}
     */
    oncontextmenu(evt) {
        this.emit("rightclick", this._get_object(evt));
        return false;
    }


    /**
     *
     * @param evt
     * @returns {*}
     * @private
     */
    _get_object(evt) {
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();

        mouse.x = ( evt.clientX / this.animation.renderer.domElement.width ) * 2 - 1;
        mouse.y = -( evt.clientY / this.animation.renderer.domElement.height ) * 2 + 1;
        raycaster.setFromCamera(mouse, this.animation.camera);

        return raycaster.intersectObjects(this.animation.scene.children)[0];
    }


    /**
     * Calculates all gameobjects inside of the current selection
     * @private
     */
    _calculate_selection() {

        this.selection_model.geometry.vertices.forEach(v => v.z = 0);

        let bounding_box_height = 100; // FIXME: should be safe
        let bbox = new THREE.Box3().setFromObject(this.selection_model);

        // calculate all intersecting actors
        let hits = this.actors.filter(x => {
            let b = new THREE.Box3().setFromObject(x.mesh);
            // change the actors bounding boxes to go pretty high in the Z-axis
            // so the selection model will definitely intersect it
            b.expandByVector(new THREE.Vector3(0, 0, bounding_box_height));

            return bbox.isIntersectionBox(b);
        });

        this.emit("selection", hits);

    }


    /**
     *
     * @returns {THREE.Mesh}
     */
    load_selection_model() {

        let geometry = new THREE.Geometry();
        geometry.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0));
        geometry.faces.push(new THREE.Face3(0, 2, 1), new THREE.Face3(2, 3, 1));


        let material = new THREE.MeshLambertMaterial({color: 0xff0000});
        material.transparent = true;
        material.opacity = 0.5;

        let mesh = new THREE.Mesh(geometry, material);
        mesh.visible = false;

        window.m = mesh;
        return mesh;
    }
}

module.exports = MouseHandler;

},{"../../lib/mt-event":18,"../../lib/three":20}],11:[function(require,module,exports){
"use strict";

let Animation = require("./animation");
let Map = require("./map/map");
let MainController = require("./controllers/maincontroller");
let Actor = require("./actor/actor");
let Resource = require("./resource/resource");




let animation = new Animation();

let map = new Map();

let resource = new Resource();
map.add_resource(resource);





animation.load_map(map);



let actors = [new Actor(map.structure.get(20, 20)), new Actor(map.structure.get(30, 20))];
animation.add_element(actors[0]);
animation.add_element(actors[1]);



let c = new MainController(animation, map, actors);
animation.start();




console.log("loaded");

},{"./actor/actor":1,"./animation":3,"./controllers/maincontroller":9,"./map/map":12,"./resource/resource":17}],12:[function(require,module,exports){
"use strict";

var GameObject = require("../common/gameobject");
var THREE = require("../../lib/three");
var List2D = require("../common/list2d");
var Point = require("../common/point");
var Structure = require("./structure");
var Model = require("./model");
var Path = require("./path");


class Map extends GameObject {

    /**
     *
     * @param properties: Map with keys: size_x, size_y
     */
    constructor(properties) {

        super();

        this.properties = properties || Map._get_default_properties();
        // structure is a List2D filled with MapNodes
        this.structure = Structure.create_random(this.properties);

        this.mesh = Model.generate_model(this.properties, this.structure);
        this.mesh.userData = this;


        this.resources = [];
    }


    /**
     * Adds a resource to this map
     * @param resource
     */
    add_resource(resource){
        this.resources.push(resource);
    }


    /**
     * Determines the best possible path between two points
     * @param from
     * @param to
     * @returns {Path|exports|module.exports}
     */
    get_path(from, to){

        if(!from.x || !from.y || !to.x || !to.y) throw new TypeError("#Map: Need to pass two points with x/y val!");

        return new Path(from, to, this.structure);
    };


    /**
     * Returns default properties for when none have been provided
     * @private
     */
    static _get_default_properties() {
        return {
            size_x: 100,
            size_y: 100,
            structure: null,
            groundwater: -0.8,
            mountain: 1,
            highlight_chance: 300 // 1000 means 1 in 1000
        };
    }


}

module.exports = Map;

},{"../../lib/three":20,"../common/gameobject":4,"../common/list2d":5,"../common/point":6,"./model":14,"./path":15,"./structure":16}],13:[function(require,module,exports){
"use strict";

class MapNode {

    constructor(point, passable) {
        this.point = point;
        this.passable = passable || false;

        this.__locked = false;
    }

    lock() {
        if (this.__locked) throw new RangeError("#Mapnode: Node is already locked!");
        this.__locked = true;
    }

    unlock() {
        this.__locked = false;
    }

    get locked() {
        return this.__locked;
    }

    toString() {
        return `(${this.point.x}:${this.point.y}) ${this.point.z.toString().substring(0, 3)} ${this.passable ? "o" : "x"}`;
    }

}

module.exports = MapNode;

},{}],14:[function(require,module,exports){
"use strict";

var THREE = require("../../lib/three");

class Model {


    /**
     * Creates the rather complex map-mesh including textures
     *
     * @returns {THREE.Mesh}
     * @private
     */
    static generate_model(properties, structure) {


        let geometry = new THREE.Geometry();

        let width = structure.width;
        let length = structure.length;

        // determine which faces are water and mountains
        let water = properties.groundwater;
        let mountain = properties.mountain;


        let material = new THREE.MeshLambertMaterial({vertexColors: THREE.VertexColors});


        // 0: water, 1: earth, 2: mountaintop
        let vertice_colors = [
            new THREE.Color(0x229CE4),
            new THREE.Color(0x006400),
            new THREE.Color(0xf4a460)
        ];




        // create vertices based on the structure
        structure.for_each(function (node, x, y) {
            // add the vertices for each point
            let vert = new THREE.Vector3(node.point.x, node.point.y, node.point.z);
            geometry.vertices.push(vert);
        });


        // create 2 faces for each point, excluding the points at the corners
        structure.for_each(function (node, x, y) {

            // no faces if we are at the right or bottom/top(?) border
            if (x === width - 1 || y === length - 1) return;


            // calculate the index of the corresponding vertices/vertix/vertixes??
            let face1_coords = {
                a: x + y * width,
                b: x + 1 + y * width,
                c: x + (y + 1) * width
            };

            // determine the vertice colors by cross-checking their values with the threshholds
            let face1_colors = ["a", "b", "c"].map(mat_coord => {
                let vert = geometry.vertices[face1_coords[mat_coord]];
                let i = vert.z <= water ? 0 : vert.z >= mountain ? 2: 1;
                return vertice_colors[i];
            });

            let face1 = new THREE.Face3(
                face1_coords.a,
                face1_coords.b,
                face1_coords.c,
                null,
                face1_colors
            );

            //++++++++++++++

            // calculate the index of the corresponding vertices/vertix/vertixes??
            let face2_coords = {
                a: x + (y + 1) * width,
                b: x + 1 + y * width,
                c: x + 1 + (y + 1) * width
            };

            // determine the vertice colors by cross-checking their values with the threshholds
            let face2_colors = ["a", "b", "c"].map(mat_coord => {
                let vert = geometry.vertices[face2_coords[mat_coord]];
                let i = vert.z <= water ? 0 : vert.z >= mountain ? 2: 1;
                return vertice_colors[i];
            });


            let face2 = new THREE.Face3(
                face2_coords.a,
                face2_coords.b,
                face2_coords.c,
                null,
                face2_colors
            );

            geometry.faces.push(face1, face2);


        });


        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        geometry.computeBoundingSphere();
        //geometry.colorsNeedUpdate = true;

        return new THREE.Mesh(geometry, material);
    }

}

module.exports = Model;

},{"../../lib/three":20}],15:[function(require,module,exports){
"use strict";


/**
 * Helper class to encapsulate the distance/heuristics values
 */
class PathNode {

    constructor(node, distance, heuristics, parent) {
        this.node = node;
        this.d = distance;
        this.h = heuristics;
        this.parent = parent;
    }
}


/**
 * Creates a path between two points based on a given structure
 */
class Path {

    /**
     * Creates a path between two points and makes the path-instance an iterable
     *
     * @param from
     * @param to
     * @param structure
     */
    constructor(from, to, structure) {

        // sanitize input
        from = structure.get(from.x, from.y);
        to = structure.get(to.x, to.y);


        // throw error if impossible
        if(!from.passable || !to.passable || to.locked){
            throw new EvalError("#Path: Can't determine a path because either origin or target isn't passable");
        }

        let current,
            surrounding = [],
            candidates = [],
            path = [],
            known = [];


        // before the first iteration, we'll set the current point to the start node
        current = new PathNode(from, 0, from.point.distance_to(to.point), null);

        while (!current.node.point.equals(to.point)) {

            // determine surrounding nodes
            surrounding = structure.get_surrounding(current.node.point.x, current.node.point.y);

            // filter alread known ones
            surrounding = surrounding.filter(elem => known.indexOf(elem) === -1);
            // add the new ones to the known-list
            known = known.concat(surrounding);
            // filter blocked ones
            surrounding = surrounding.filter(elem => elem.passable && !elem.locked);

            // determine distances and turn them into PathNodes
            // concat with previous candidates to we'll more easily be able to switch paths if needed
            candidates = candidates.concat(
                surrounding.map(elem => new PathNode(
                    elem,
                    current.d + current.node.point.distance_to(elem.point),
                    elem.point.distance_to(to.point),
                    current
                ))
            );

            // sort list so the lowest index has the best expected value
            candidates.sort((a, b) => (a.d + a.h) - (b.d + b.h));

            current = candidates.shift();

            if(!current) throw new EvalError("#Path: Can't find a path to the target!");
        }


        // go back to collect the chosen nodes
        while(current !== null){
            path.unshift(current.node);
            current = current.parent;
        }


        // make it iterable
        this[Symbol.iterator] = function* () {
            while (path.length > 0){
                yield path.shift();
            }
        }


    }


}


module.exports = Path;

},{}],16:[function(require,module,exports){
"use strict";

var List2D = require("../common/list2d");
var MapNode = require("./mapnode");
var Point = require("../common/point");

/**
 * Helper class for map structures
 */
class Structure {

    /**
     * Create random structure
     * @param properties
     * @returns {List2D|exports|module.exports}
     */
    static create_random(properties) {

        let l2d = new List2D(properties.size_x, properties.size_y);

        // fill each point with a random height
        l2d.for_each(function (elem, x, y) {

            let height = Math.random() * 10 - 5;

            // chance for highlight:
            if(Math.random()* properties.highlight_chance < 1) height *= 10;
            let point = new Point(x, y, height);
            let node = new MapNode(point, true);
            l2d.set(x, y, node);

        });


        // smooth the heights to get a natural looking map
        let clean_runs = 20;
        for(let i = 0; i < clean_runs; i++){

            // harmonize each node with the surrounding nodes
            l2d.for_each(function (elem, x, y) {

                let surrounding = l2d.get_surrounding(x, y);
                let avg = surrounding.reduce((val, elem) => val + elem.point.z, 0) / surrounding.length;

                // change the.point.z to be 20% closer to the average
                elem.point.z = ( elem.point.z * 4 + avg ) / 5

            });
        }

        // block water/mountain fields
        l2d.for_each(function (elem) {
            if(elem.point.z <= properties.groundwater || elem.point.z >= properties.mountain) elem.passable = false;
        });


        return l2d;
    }

}


module.exports = Structure;

},{"../common/list2d":5,"../common/point":6,"./mapnode":13}],17:[function(require,module,exports){
"use strict";

let GameObject = require("../common/gameobject");
let THREE = require("../../lib/three");

let RES = {
    "WOOD": 1,
    "STONE": 2
};

let default_properties = {
    res: "WOOD",
    amount: 10,
    fields: [
        {x: 20, y: 40},
        {x: 20, y: 41},
        {x: 21, y: 40},
        {x: 21, y: 41}
    ]
};


class Resource extends GameObject {

    constructor(properties) {

        super();

        properties = properties || default_properties;

        this.type = RES[properties.res];
        this.amount = properties.amount;
        this.fields = properties.fields;

        this.mesh = this.generate_mesh();
        //this.model = this.generate_models();

    }


    generate_mesh() {

        // generate the geometry
        let geometry = this.fields.map(field => {

            // create a geometry object for each field this resource is on
            let geo = new THREE.BoxGeometry(0.25, 0.25, 5);
            geo.vertices.forEach(vert => {
                vert.x += field.x;
                vert.y += field.y;
            });
            return geo;

            // merge all those geometries into one
        }).reduce((prev, curr) => {
            if (prev) curr.merge(prev);
            return curr;
        });

        let material = new THREE.MeshLambertMaterial({color: 0xffffff});
        return new THREE.Mesh(geometry, material);

    }


    /**
     *
     * @param tool
     */
    work(tool) {

    }

}

module.exports = Resource;

},{"../../lib/three":20,"../common/gameobject":4}],18:[function(require,module,exports){
var MtEventHandler = function MtEventHandler(){

    this.__channels = {};

    //DO NOT CHANGE DURING RUNTIME!!!
    this.__eventlistPropertyName = "__mt_evts__";


    this.__defineProperty = function(obj, val, func){
        Object.defineProperty(obj, val, {
          value: func,
          writable: false,
          enumerable: false,
          configurable: false
        });
    };

    /*
     * This initializes while loading and sets the property-name of the eventlist for all objects
     */
    this.__eventFunctions = {
        "on": (function(propertyName){
            return function(eventName, func){
                var eventMap = this[propertyName];
                if(!eventMap) throw TypeError("This is not an mt-Evented Object!");
                if(!(func instanceof Function)) throw TypeError("Need to provide Function Object to \"ON\"");
                // if this is the first event with this name, create new array for this event type
                if(!eventMap[eventName]) eventMap[eventName] = [];
                var identifier = eventMap[eventName].length;
                eventMap[eventName].push(func);
                return identifier;
            };
        })(this.__eventlistPropertyName),

        "emit": (function(propertyName){
            return function(eventName, infoObj){
                var eventMap = this[propertyName];
                if(!eventMap || !(eventMap instanceof Object)) throw TypeError("This is not an mt-Evented Object!");
                // abort if there are no subscriptions on this event
                if(!eventMap[eventName]) return;
                // call all subscriptions
                eventMap[eventName].forEach(function(func){
                    !!func && func(infoObj);
                });
            };
        })(this.__eventlistPropertyName),

        "ignore": (function(propertyName){
            return function(eventName, identifier){
                var eventMap = this[propertyName];
                if(!eventMap ) throw TypeError("This is not an mt-Evented Object!");
                if(!eventMap[eventName] || !eventMap[eventName][identifier]) throw RangeError("Don't have this event!");

                var eventFunc = eventMap[eventName][identifier];
                eventMap[eventName][identifier] = undefined;
                return eventFunc;
            };
        })(this.__eventlistPropertyName)
    };

    this.makeEvented = function(obj){
        this.__defineProperty(obj, this.__eventlistPropertyName, {});
        this.__defineProperty(obj, "on", this.__eventFunctions.on);
        this.__defineProperty(obj, "emit", this.__eventFunctions.emit);
        this.__defineProperty(obj, "ignore", this.__eventFunctions.ignore);
    };

};

if(typeof module !== "undefined" && typeof module.exports !== "undefined") module.exports = new MtEventHandler();

},{}],19:[function(require,module,exports){
var Deferred = function() {
	this.promise = new Promise();
	this.state = Deferred.PENDING;
};

Deferred.FULFILLED = 0;
Deferred.REJECTED = 1;
Deferred.PENDING = 2;

Deferred.debug = false;

/**
 * This is a utility-function that returns a single promise for an array of promises.
 * It updates the promise for every resolved deferred in the same order as the original error.
 * It resolves once all promises have been resolved.
 */
Deferred.when = function() {
	var __deferred = new Deferred();

	// exclude non-promise values and convert arguments to array in one go
	var promises = Array.prototype.filter.call(arguments, function(arg) {
		return (arg instanceof Promise);
	});

	var toGo = promises.length;

	if (toGo < 1) throw RangeError("No Promises have been submitted to Deferred.when, need at least one.");

	// save the solved values for the promises in the same order
	var solveValues = [];
	solveValues.length = toGo;

	promises.forEach(function(promise, index) {

		// after the promise is fulfilled
		promise.then(function(value) {

			solveValues[index] = value;
			__deferred.update(solveValues);

			// decrement counter and resolve if we're done
			if (--toGo === 0) __deferred.resolve(solveValues);
		});
	});

	return __deferred.promise;
};

Deferred.prototype.resolve = function(value, strict) {

	// If the deferred is already closed, we check for the debug-flag and the strict-parameter
	// and give feedback to the caller accordingly
	if(this.state !== Deferred.PENDING){
		Deferred.debug && console.warn("Promise already", this.state, ", can't resolve again");
		if(strict) throw new Error("Promise already", this.state);
		return false;
	}

	// If everything is normal (what is normal anyways?), we mark the deferred and its promise as resolved
	this.state = Deferred.FULFILLED;
	this.promise.state = Deferred.FULFILLED;
	this.promise.endValue = value;

	// last thing to do is execute all cached "then"-calls with the given value
	// NOTE: chaining of promises gets handled by the promises "then" function
	this.promise._resolveFunctions.forEach(function(func) {
		func(value);
	});

	// the reason for returning a boolean depending on whether resolving was successful is
	// that you can strip out the "strict = true" parameter and improve performance
	// for production code by just checking for the return value of "resolve"
	return true;

};

Deferred.prototype.reject = function(errorValue, strict) {

	if(this.state !== Deferred.PENDING){
		Deferred.debug && console.warn("Promise already", this.state, ", can't resolve again");
		if(strict) throw new Error("Promise already", this.state);
		return false;
	}

	this.state = Deferred.REJECTED;
	this.promise.state = Deferred.REJECTED;
	this.promise.endValue = errorValue;
	this.promise._rejectFunctions.forEach(function(func) {
		func(errorValue);
	});

	return true;
};

Deferred.prototype.update = function(value, strict) {

	if(this.state !== Deferred.PENDING){
		Deferred.debug && console.warn("Promise already", this.state, ", can't resolve again");
		if(strict) throw new Error("Promise already", this.state);
		return false;
	}

	this.promise._updateFunctions.forEach(function(func) {
		func(value);
	});
	return true;
};



var Promise = function() {

	this.state = Deferred.PENDING;

	this.endValue = null;

	this._resolveFunctions = [];

	this._rejectFunctions = [];

	this._updateFunctions = [];

};

Promise.prototype.then = function(onResolve, onError, onUpdate) {

	// we need to return a promise at the end of the "then"-call to allow chaining
	var deferred = new Deferred();

	if (onResolve) {
		//if the deferred is already resolved, trigger the function right now
		if (this.state === Deferred.FULFILLED) {
			Deferred.debug && console.info("Promise already resolved, executing \"then\" immediately")
			// execute the function and use its return value as derived value...
			var derivedValue = onResolve(this.endValue);
			// .. for the promise of the current "then"-call to allow promise-chaining
			deferred.resolve(derivedValue);
		} else {
			// if the deferred is still pending, put the resolve function in queue
			// so it can be executed later by the parenting deferred
			this._resolveFunctions.push(function(value) {
				// as above, save the return-value of the function call for the
				// deferred/promise of the current "then"-call
				var derivedValue = onResolve(value);
				deferred.resolve(derivedValue);
			}.bind(this));
		}
	}

	// Same as above for onResolve, so no comments here
	if (onError) {
		if (this.state === Deferred.REJECTED) {
			Deferred.debug && console.info("Promise already rejected, executing \"then\" immediately")
			var derivedErrorValue = onError(this.endValue);
			deferred.reject(derivedErrorValue);
		} else{
			this._rejectFunctions.push(function(errorValue) {
				var derivedErrorValue = onError(errorValue);
				deferred.reject(derivedErrorValue);
			}.bind(this));
		}
	}

	if (onUpdate) {
		// when updating we DON'T pass values to the derived promise because
		// we can't do that in a way that makes sense for the user
		if(this.state !== Deferred.PENDING){
			Deferred.debug && console.warn("Trying to add onUpdate function to already fulfilled promise");
		} else {
			this._updateFunctions.push(function(value) {
				deferred.update(onUpdate(value));
			}.bind(this));
		}
	}

	return deferred.promise;

};

if(typeof module === "object") module.exports = Deferred;

},{}],20:[function(require,module,exports){
// File:src/Three.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

var THREE = { REVISION: '73' };

//

if ( typeof define === 'function' && define.amd ) {

    define( 'three', THREE );

} else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {

    module.exports = THREE;

}


// polyfills

if ( self.requestAnimationFrame === undefined || self.cancelAnimationFrame === undefined ) {

    // Missing in Android stock browser.

    ( function () {

        var lastTime = 0;
        var vendors = [ 'ms', 'moz', 'webkit', 'o' ];

        for ( var x = 0; x < vendors.length && ! self.requestAnimationFrame; ++ x ) {

            self.requestAnimationFrame = self[ vendors[ x ] + 'RequestAnimationFrame' ];
            self.cancelAnimationFrame = self[ vendors[ x ] + 'CancelAnimationFrame' ] || self[ vendors[ x ] + 'CancelRequestAnimationFrame' ];

        }

        if ( self.requestAnimationFrame === undefined && self.setTimeout !== undefined ) {

            self.requestAnimationFrame = function ( callback ) {

                var currTime = Date.now(), timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
                var id = self.setTimeout( function () {

                    callback( currTime + timeToCall );

                }, timeToCall );
                lastTime = currTime + timeToCall;
                return id;

            };

        }

        if ( self.cancelAnimationFrame === undefined && self.clearTimeout !== undefined ) {

            self.cancelAnimationFrame = function ( id ) {

                self.clearTimeout( id );

            };

        }

    } )();

}

//

if ( self.performance === undefined ) {

    self.performance = {};

}

if ( self.performance.now === undefined ) {

    ( function () {

        var start = Date.now();

        self.performance.now = function () {

            return Date.now() - start;

        }

    } )();

}

//

if ( Number.EPSILON === undefined ) {

    Number.EPSILON = Math.pow( 2, -52 );

}

//

if ( Math.sign === undefined ) {

    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

    Math.sign = function ( x ) {

        return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

    };

}

if ( Function.prototype.name === undefined && Object.defineProperty !== undefined ) {

    // Missing in IE9-11.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

    Object.defineProperty( Function.prototype, 'name', {

        get: function () {

            return this.toString().match( /^\s*function\s*(\S*)\s*\(/ )[ 1 ];

        }

    } );

}

// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button

THREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };

// GL STATE CONSTANTS

THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;

THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;

// SHADOWING TYPES

THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;

// MATERIAL CONSTANTS

// side

THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;

// shading

THREE.FlatShading = 1;
THREE.SmoothShading = 2;

// colors

THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;

// blending modes

THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;

// custom blending equations
// (numbers start from 100 not to clash with other
// mappings to OpenGL constants defined in Texture.js)

THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;
THREE.MinEquation = 103;
THREE.MaxEquation = 104;

// custom blending destination factors

THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;

// custom blending source factors

//THREE.ZeroFactor = 200;
//THREE.OneFactor = 201;
//THREE.SrcAlphaFactor = 204;
//THREE.OneMinusSrcAlphaFactor = 205;
//THREE.DstAlphaFactor = 206;
//THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;

// depth modes

THREE.NeverDepth = 0;
THREE.AlwaysDepth = 1;
THREE.LessDepth = 2;
THREE.LessEqualDepth = 3;
THREE.EqualDepth = 4;
THREE.GreaterEqualDepth = 5;
THREE.GreaterDepth = 6;
THREE.NotEqualDepth = 7;


// TEXTURE CONSTANTS

THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;

// Mapping modes

THREE.UVMapping = 300;

THREE.CubeReflectionMapping = 301;
THREE.CubeRefractionMapping = 302;

THREE.EquirectangularReflectionMapping = 303;
THREE.EquirectangularRefractionMapping = 304;

THREE.SphericalReflectionMapping = 305;

// Wrapping modes

THREE.RepeatWrapping = 1000;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;

// Filters

THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;

// Data types

THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;
THREE.HalfFloatType = 1025;

// Pixel types

//THREE.UnsignedByteType = 1009;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;

// Pixel formats

THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;
// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders
THREE.RGBEFormat = THREE.RGBAFormat; //1024;

// DDS / ST3C Compressed texture formats

THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;


// PVRTC compressed texture formats

THREE.RGB_PVRTC_4BPPV1_Format = 2100;
THREE.RGB_PVRTC_2BPPV1_Format = 2101;
THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
THREE.RGBA_PVRTC_2BPPV1_Format = 2103;

// Loop styles for AnimationAction

THREE.LoopOnce = 2200;
THREE.LoopRepeat = 2201;
THREE.LoopPingPong = 2202;

// DEPRECATED

THREE.Projector = function () {

    console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

    this.projectVector = function ( vector, camera ) {

        console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
        vector.project( camera );

    };

    this.unprojectVector = function ( vector, camera ) {

        console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
        vector.unproject( camera );

    };

    this.pickingRay = function ( vector, camera ) {

        console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

    };

};

THREE.CanvasRenderer = function () {

    console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

    this.domElement = document.createElement( 'canvas' );
    this.clear = function () {};
    this.render = function () {};
    this.setClearColor = function () {};
    this.setSize = function () {};

};

// File:src/math/Color.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Color = function ( color ) {

    if ( arguments.length === 3 ) {

        return this.fromArray( arguments );

    }

    return this.set( color );

};

THREE.Color.prototype = {

    constructor: THREE.Color,

    r: 1, g: 1, b: 1,

    set: function ( value ) {

        if ( value instanceof THREE.Color ) {

            this.copy( value );

        } else if ( typeof value === 'number' ) {

            this.setHex( value );

        } else if ( typeof value === 'string' ) {

            this.setStyle( value );

        }

        return this;

    },

    setHex: function ( hex ) {

        hex = Math.floor( hex );

        this.r = ( hex >> 16 & 255 ) / 255;
        this.g = ( hex >> 8 & 255 ) / 255;
        this.b = ( hex & 255 ) / 255;

        return this;

    },

    setRGB: function ( r, g, b ) {

        this.r = r;
        this.g = g;
        this.b = b;

        return this;

    },

    setHSL: function () {

        function hue2rgb( p, q, t ) {

            if ( t < 0 ) t += 1;
            if ( t > 1 ) t -= 1;
            if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
            if ( t < 1 / 2 ) return q;
            if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
            return p;

        }

        return function ( h, s, l ) {

            // h,s,l ranges are in 0.0 - 1.0
            h = THREE.Math.euclideanModulo( h, 1 );
            s = THREE.Math.clamp( s, 0, 1 );
            l = THREE.Math.clamp( l, 0, 1 );

            if ( s === 0 ) {

                this.r = this.g = this.b = l;

            } else {

                var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
                var q = ( 2 * l ) - p;

                this.r = hue2rgb( q, p, h + 1 / 3 );
                this.g = hue2rgb( q, p, h );
                this.b = hue2rgb( q, p, h - 1 / 3 );

            }

            return this;

        };

    }(),

    setStyle: function ( style ) {

        function handleAlpha( string ) {

            if ( string === undefined ) return;

            if ( parseFloat( string ) < 1 ) {

                console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

            }

        }


        var m;

        if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

            // rgb / hsl

            var color;
            var name = m[ 1 ];
            var components = m[ 2 ];

            switch ( name ) {

                case 'rgb':
                case 'rgba':

                    if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

                        // rgb(255,0,0) rgba(255,0,0,0.5)
                        this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
                        this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
                        this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

                        handleAlpha( color[ 5 ] );

                        return this;

                    }

                    if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

                        // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
                        this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
                        this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
                        this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

                        handleAlpha( color[ 5 ] );

                        return this;

                    }

                    break;

                case 'hsl':
                case 'hsla':

                    if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

                        // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
                        var h = parseFloat( color[ 1 ] ) / 360;
                        var s = parseInt( color[ 2 ], 10 ) / 100;
                        var l = parseInt( color[ 3 ], 10 ) / 100;

                        handleAlpha( color[ 5 ] );

                        return this.setHSL( h, s, l );

                    }

                    break;

            }

        } else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

            // hex color

            var hex = m[ 1 ];
            var size = hex.length;

            if ( size === 3 ) {

                // #ff0
                this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
                this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
                this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

                return this;

            } else if ( size === 6 ) {

                // #ff0000
                this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
                this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
                this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

                return this;

            }

        }

        if ( style && style.length > 0 ) {

            // color keywords
            var hex = THREE.ColorKeywords[ style ];

            if ( hex !== undefined ) {

                // red
                this.setHex( hex );

            } else {

                // unknown color
                console.warn( 'THREE.Color: Unknown color ' + style );

            }

        }

        return this;

    },

    clone: function () {

        return new this.constructor( this.r, this.g, this.b );

    },

    copy: function ( color ) {

        this.r = color.r;
        this.g = color.g;
        this.b = color.b;

        return this;

    },

    copyGammaToLinear: function ( color, gammaFactor ) {

        if ( gammaFactor === undefined ) gammaFactor = 2.0;

        this.r = Math.pow( color.r, gammaFactor );
        this.g = Math.pow( color.g, gammaFactor );
        this.b = Math.pow( color.b, gammaFactor );

        return this;

    },

    copyLinearToGamma: function ( color, gammaFactor ) {

        if ( gammaFactor === undefined ) gammaFactor = 2.0;

        var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

        this.r = Math.pow( color.r, safeInverse );
        this.g = Math.pow( color.g, safeInverse );
        this.b = Math.pow( color.b, safeInverse );

        return this;

    },

    convertGammaToLinear: function () {

        var r = this.r, g = this.g, b = this.b;

        this.r = r * r;
        this.g = g * g;
        this.b = b * b;

        return this;

    },

    convertLinearToGamma: function () {

        this.r = Math.sqrt( this.r );
        this.g = Math.sqrt( this.g );
        this.b = Math.sqrt( this.b );

        return this;

    },

    getHex: function () {

        return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

    },

    getHexString: function () {

        return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

    },

    getHSL: function ( optionalTarget ) {

        // h,s,l ranges are in 0.0 - 1.0

        var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

        var r = this.r, g = this.g, b = this.b;

        var max = Math.max( r, g, b );
        var min = Math.min( r, g, b );

        var hue, saturation;
        var lightness = ( min + max ) / 2.0;

        if ( min === max ) {

            hue = 0;
            saturation = 0;

        } else {

            var delta = max - min;

            saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

            switch ( max ) {

                case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
                case g: hue = ( b - r ) / delta + 2; break;
                case b: hue = ( r - g ) / delta + 4; break;

            }

            hue /= 6;

        }

        hsl.h = hue;
        hsl.s = saturation;
        hsl.l = lightness;

        return hsl;

    },

    getStyle: function () {

        return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

    },

    offsetHSL: function ( h, s, l ) {

        var hsl = this.getHSL();

        hsl.h += h; hsl.s += s; hsl.l += l;

        this.setHSL( hsl.h, hsl.s, hsl.l );

        return this;

    },

    add: function ( color ) {

        this.r += color.r;
        this.g += color.g;
        this.b += color.b;

        return this;

    },

    addColors: function ( color1, color2 ) {

        this.r = color1.r + color2.r;
        this.g = color1.g + color2.g;
        this.b = color1.b + color2.b;

        return this;

    },

    addScalar: function ( s ) {

        this.r += s;
        this.g += s;
        this.b += s;

        return this;

    },

    multiply: function ( color ) {

        this.r *= color.r;
        this.g *= color.g;
        this.b *= color.b;

        return this;

    },

    multiplyScalar: function ( s ) {

        this.r *= s;
        this.g *= s;
        this.b *= s;

        return this;

    },

    lerp: function ( color, alpha ) {

        this.r += ( color.r - this.r ) * alpha;
        this.g += ( color.g - this.g ) * alpha;
        this.b += ( color.b - this.b ) * alpha;

        return this;

    },

    equals: function ( c ) {

        return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

    },

    fromArray: function ( array, offset ) {

        if ( offset === undefined ) offset = 0;

        this.r = array[ offset ];
        this.g = array[ offset + 1 ];
        this.b = array[ offset + 2 ];

        return this;

    },

    toArray: function ( array, offset ) {

        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this.r;
        array[ offset + 1 ] = this.g;
        array[ offset + 2 ] = this.b;

        return array;

    }

};

THREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
    'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
    'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
    'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
    'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
    'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
    'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
    'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
    'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
    'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
    'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
    'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
    'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
    'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
    'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
    'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
    'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
    'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
    'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
    'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
    'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
    'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
    'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
    'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

// File:src/math/Quaternion.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

THREE.Quaternion = function ( x, y, z, w ) {

    this._x = x || 0;
    this._y = y || 0;
    this._z = z || 0;
    this._w = ( w !== undefined ) ? w : 1;

};

THREE.Quaternion.prototype = {

    constructor: THREE.Quaternion,

    get x () {

        return this._x;

    },

    set x ( value ) {

        this._x = value;
        this.onChangeCallback();

    },

    get y () {

        return this._y;

    },

    set y ( value ) {

        this._y = value;
        this.onChangeCallback();

    },

    get z () {

        return this._z;

    },

    set z ( value ) {

        this._z = value;
        this.onChangeCallback();

    },

    get w () {

        return this._w;

    },

    set w ( value ) {

        this._w = value;
        this.onChangeCallback();

    },

    set: function ( x, y, z, w ) {

        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;

        this.onChangeCallback();

        return this;

    },

    clone: function () {

        return new this.constructor( this._x, this._y, this._z, this._w );

    },

    copy: function ( quaternion ) {

        this._x = quaternion.x;
        this._y = quaternion.y;
        this._z = quaternion.z;
        this._w = quaternion.w;

        this.onChangeCallback();

        return this;

    },

    setFromEuler: function ( euler, update ) {

        if ( euler instanceof THREE.Euler === false ) {

            throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

        }

        // http://www.mathworks.com/matlabcentral/fileexchange/
        // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
        //	content/SpinCalc.m

        var c1 = Math.cos( euler._x / 2 );
        var c2 = Math.cos( euler._y / 2 );
        var c3 = Math.cos( euler._z / 2 );
        var s1 = Math.sin( euler._x / 2 );
        var s2 = Math.sin( euler._y / 2 );
        var s3 = Math.sin( euler._z / 2 );

        var order = euler.order;

        if ( order === 'XYZ' ) {

            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;

        } else if ( order === 'YXZ' ) {

            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;

        } else if ( order === 'ZXY' ) {

            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;

        } else if ( order === 'ZYX' ) {

            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;

        } else if ( order === 'YZX' ) {

            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;

        } else if ( order === 'XZY' ) {

            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;

        }

        if ( update !== false ) this.onChangeCallback();

        return this;

    },

    setFromAxisAngle: function ( axis, angle ) {

        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

        // assumes axis is normalized

        var halfAngle = angle / 2, s = Math.sin( halfAngle );

        this._x = axis.x * s;
        this._y = axis.y * s;
        this._z = axis.z * s;
        this._w = Math.cos( halfAngle );

        this.onChangeCallback();

        return this;

    },

    setFromRotationMatrix: function ( m ) {

        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

        var te = m.elements,

            m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
            m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
            m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

            trace = m11 + m22 + m33,
            s;

        if ( trace > 0 ) {

            s = 0.5 / Math.sqrt( trace + 1.0 );

            this._w = 0.25 / s;
            this._x = ( m32 - m23 ) * s;
            this._y = ( m13 - m31 ) * s;
            this._z = ( m21 - m12 ) * s;

        } else if ( m11 > m22 && m11 > m33 ) {

            s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

            this._w = ( m32 - m23 ) / s;
            this._x = 0.25 * s;
            this._y = ( m12 + m21 ) / s;
            this._z = ( m13 + m31 ) / s;

        } else if ( m22 > m33 ) {

            s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

            this._w = ( m13 - m31 ) / s;
            this._x = ( m12 + m21 ) / s;
            this._y = 0.25 * s;
            this._z = ( m23 + m32 ) / s;

        } else {

            s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

            this._w = ( m21 - m12 ) / s;
            this._x = ( m13 + m31 ) / s;
            this._y = ( m23 + m32 ) / s;
            this._z = 0.25 * s;

        }

        this.onChangeCallback();

        return this;

    },

    setFromUnitVectors: function () {

        // http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

        // assumes direction vectors vFrom and vTo are normalized

        var v1, r;

        var EPS = 0.000001;

        return function ( vFrom, vTo ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();

            r = vFrom.dot( vTo ) + 1;

            if ( r < EPS ) {

                r = 0;

                if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

                    v1.set( - vFrom.y, vFrom.x, 0 );

                } else {

                    v1.set( 0, - vFrom.z, vFrom.y );

                }

            } else {

                v1.crossVectors( vFrom, vTo );

            }

            this._x = v1.x;
            this._y = v1.y;
            this._z = v1.z;
            this._w = r;

            this.normalize();

            return this;

        }

    }(),

    inverse: function () {

        this.conjugate().normalize();

        return this;

    },

    conjugate: function () {

        this._x *= - 1;
        this._y *= - 1;
        this._z *= - 1;

        this.onChangeCallback();

        return this;

    },

    dot: function ( v ) {

        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

    },

    lengthSq: function () {

        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

    },

    length: function () {

        return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

    },

    normalize: function () {

        var l = this.length();

        if ( l === 0 ) {

            this._x = 0;
            this._y = 0;
            this._z = 0;
            this._w = 1;

        } else {

            l = 1 / l;

            this._x = this._x * l;
            this._y = this._y * l;
            this._z = this._z * l;
            this._w = this._w * l;

        }

        this.onChangeCallback();

        return this;

    },

    multiply: function ( q, p ) {

        if ( p !== undefined ) {

            console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
            return this.multiplyQuaternions( q, p );

        }

        return this.multiplyQuaternions( this, q );

    },

    multiplyQuaternions: function ( a, b ) {

        // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

        var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
        var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

        this.onChangeCallback();

        return this;

    },

    multiplyVector3: function ( vector ) {

        console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
        return vector.applyQuaternion( this );

    },

    slerp: function ( qb, t ) {

        if ( t === 0 ) return this;
        if ( t === 1 ) return this.copy( qb );

        var x = this._x, y = this._y, z = this._z, w = this._w;

        // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

        var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

        if ( cosHalfTheta < 0 ) {

            this._w = - qb._w;
            this._x = - qb._x;
            this._y = - qb._y;
            this._z = - qb._z;

            cosHalfTheta = - cosHalfTheta;

        } else {

            this.copy( qb );

        }

        if ( cosHalfTheta >= 1.0 ) {

            this._w = w;
            this._x = x;
            this._y = y;
            this._z = z;

            return this;

        }

        var halfTheta = Math.acos( cosHalfTheta );
        var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

        if ( Math.abs( sinHalfTheta ) < 0.001 ) {

            this._w = 0.5 * ( w + this._w );
            this._x = 0.5 * ( x + this._x );
            this._y = 0.5 * ( y + this._y );
            this._z = 0.5 * ( z + this._z );

            return this;

        }

        var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
            ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

        this._w = ( w * ratioA + this._w * ratioB );
        this._x = ( x * ratioA + this._x * ratioB );
        this._y = ( y * ratioA + this._y * ratioB );
        this._z = ( z * ratioA + this._z * ratioB );

        this.onChangeCallback();

        return this;

    },

    equals: function ( quaternion ) {

        return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

    },

    fromArray: function ( array, offset ) {

        if ( offset === undefined ) offset = 0;

        this._x = array[ offset ];
        this._y = array[ offset + 1 ];
        this._z = array[ offset + 2 ];
        this._w = array[ offset + 3 ];

        this.onChangeCallback();

        return this;

    },

    toArray: function ( array, offset ) {

        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this._x;
        array[ offset + 1 ] = this._y;
        array[ offset + 2 ] = this._z;
        array[ offset + 3 ] = this._w;

        return array;

    },

    onChange: function ( callback ) {

        this.onChangeCallback = callback;

        return this;

    },

    onChangeCallback: function () {}

};

THREE.Quaternion.slerp = function ( qa, qb, qm, t ) {

    return qm.copy( qa ).slerp( qb, t );

};

// File:src/math/Vector2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.Vector2 = function ( x, y ) {

    this.x = x || 0;
    this.y = y || 0;

};

THREE.Vector2.prototype = {

    constructor: THREE.Vector2,

    get width() { return this.x },
    set width( value ) { this.x = value },

    get height() { return this.y },
    set height( value ) { this.y = value },

    //

    set: function ( x, y ) {

        this.x = x;
        this.y = y;

        return this;

    },

    setX: function ( x ) {

        this.x = x;

        return this;

    },

    setY: function ( y ) {

        this.y = y;

        return this;

    },

    setComponent: function ( index, value ) {

        switch ( index ) {

            case 0: this.x = value; break;
            case 1: this.y = value; break;
            default: throw new Error( 'index is out of range: ' + index );

        }

    },

    getComponent: function ( index ) {

        switch ( index ) {

            case 0: return this.x;
            case 1: return this.y;
            default: throw new Error( 'index is out of range: ' + index );

        }

    },

    clone: function () {

        return new this.constructor( this.x, this.y );

    },

    copy: function ( v ) {

        this.x = v.x;
        this.y = v.y;

        return this;

    },

    add: function ( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
            return this.addVectors( v, w );

        }

        this.x += v.x;
        this.y += v.y;

        return this;

    },

    addScalar: function ( s ) {

        this.x += s;
        this.y += s;

        return this;

    },

    addVectors: function ( a, b ) {

        this.x = a.x + b.x;
        this.y = a.y + b.y;

        return this;

    },

    addScaledVector: function ( v, s ) {

        this.x += v.x * s;
        this.y += v.y * s;

        return this;

    },

    sub: function ( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
            return this.subVectors( v, w );

        }

        this.x -= v.x;
        this.y -= v.y;

        return this;

    },

    subScalar: function ( s ) {

        this.x -= s;
        this.y -= s;

        return this;

    },

    subVectors: function ( a, b ) {

        this.x = a.x - b.x;
        this.y = a.y - b.y;

        return this;

    },

    multiply: function ( v ) {

        this.x *= v.x;
        this.y *= v.y;

        return this;

    },

    multiplyScalar: function ( scalar ) {

        if ( isFinite( scalar ) ) {
            this.x *= scalar;
            this.y *= scalar;
        } else {
            this.x = 0;
            this.y = 0;
        }

        return this;

    },

    divide: function ( v ) {

        this.x /= v.x;
        this.y /= v.y;

        return this;

    },

    divideScalar: function ( scalar ) {

        return this.multiplyScalar( 1 / scalar );

    },

    min: function ( v ) {

        this.x = Math.min( this.x, v.x );
        this.y = Math.min( this.y, v.y );

        return this;

    },

    max: function ( v ) {

        this.x = Math.max( this.x, v.x );
        this.y = Math.max( this.y, v.y );

        return this;

    },

    clamp: function ( min, max ) {

        // This function assumes min < max, if this assumption isn't true it will not operate correctly

        this.x = Math.max( min.x, Math.min( max.x, this.x ) );
        this.y = Math.max( min.y, Math.min( max.y, this.y ) );

        return this;

    },

    clampScalar: function () {

        var min, max;

        return function clampScalar( minVal, maxVal ) {

            if ( min === undefined ) {

                min = new THREE.Vector2();
                max = new THREE.Vector2();

            }

            min.set( minVal, minVal );
            max.set( maxVal, maxVal );

            return this.clamp( min, max );

        };

    }(),

    clampLength: function ( min, max ) {

        var length = this.length();

        this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

        return this;

    },

    floor: function () {

        this.x = Math.floor( this.x );
        this.y = Math.floor( this.y );

        return this;

    },

    ceil: function () {

        this.x = Math.ceil( this.x );
        this.y = Math.ceil( this.y );

        return this;

    },

    round: function () {

        this.x = Math.round( this.x );
        this.y = Math.round( this.y );

        return this;

    },

    roundToZero: function () {

        this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
        this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

        return this;

    },

    negate: function () {

        this.x = - this.x;
        this.y = - this.y;

        return this;

    },

    dot: function ( v ) {

        return this.x * v.x + this.y * v.y;

    },

    lengthSq: function () {

        return this.x * this.x + this.y * this.y;

    },

    length: function () {

        return Math.sqrt( this.x * this.x + this.y * this.y );

    },

    lengthManhattan: function() {

        return Math.abs( this.x ) + Math.abs( this.y );

    },

    normalize: function () {

        return this.divideScalar( this.length() );

    },

    distanceTo: function ( v ) {

        return Math.sqrt( this.distanceToSquared( v ) );

    },

    distanceToSquared: function ( v ) {

        var dx = this.x - v.x, dy = this.y - v.y;
        return dx * dx + dy * dy;

    },

    setLength: function ( length ) {

        return this.multiplyScalar( length / this.length() );

    },

    lerp: function ( v, alpha ) {

        this.x += ( v.x - this.x ) * alpha;
        this.y += ( v.y - this.y ) * alpha;

        return this;

    },

    lerpVectors: function ( v1, v2, alpha ) {

        this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

        return this;

    },

    equals: function ( v ) {

        return ( ( v.x === this.x ) && ( v.y === this.y ) );

    },

    fromArray: function ( array, offset ) {

        if ( offset === undefined ) offset = 0;

        this.x = array[ offset ];
        this.y = array[ offset + 1 ];

        return this;

    },

    toArray: function ( array, offset ) {

        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this.x;
        array[ offset + 1 ] = this.y;

        return array;

    },

    fromAttribute: function ( attribute, index, offset ) {

        if ( offset === undefined ) offset = 0;

        index = index * attribute.itemSize + offset;

        this.x = attribute.array[ index ];
        this.y = attribute.array[ index + 1 ];

        return this;

    },

    rotateAround: function ( center, angle ) {

        var c = Math.cos( angle ), s = Math.sin( angle );

        var x = this.x - center.x;
        var y = this.y - center.y;

        this.x = x * c - y * s + center.x;
        this.y = x * s + y * c + center.y;

        return this;

    }

};

// File:src/math/Vector3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author *kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector3 = function ( x, y, z ) {

    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;

};

THREE.Vector3.prototype = {

    constructor: THREE.Vector3,

    set: function ( x, y, z ) {

        this.x = x;
        this.y = y;
        this.z = z;

        return this;

    },

    setX: function ( x ) {

        this.x = x;

        return this;

    },

    setY: function ( y ) {

        this.y = y;

        return this;

    },

    setZ: function ( z ) {

        this.z = z;

        return this;

    },

    setComponent: function ( index, value ) {

        switch ( index ) {

            case 0: this.x = value; break;
            case 1: this.y = value; break;
            case 2: this.z = value; break;
            default: throw new Error( 'index is out of range: ' + index );

        }

    },

    getComponent: function ( index ) {

        switch ( index ) {

            case 0: return this.x;
            case 1: return this.y;
            case 2: return this.z;
            default: throw new Error( 'index is out of range: ' + index );

        }

    },

    clone: function () {

        return new this.constructor( this.x, this.y, this.z );

    },

    copy: function ( v ) {

        this.x = v.x;
        this.y = v.y;
        this.z = v.z;

        return this;

    },

    add: function ( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
            return this.addVectors( v, w );

        }

        this.x += v.x;
        this.y += v.y;
        this.z += v.z;

        return this;

    },

    addScalar: function ( s ) {

        this.x += s;
        this.y += s;
        this.z += s;

        return this;

    },

    addVectors: function ( a, b ) {

        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;

        return this;

    },

    addScaledVector: function ( v, s ) {

        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;

        return this;

    },

    sub: function ( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
            return this.subVectors( v, w );

        }

        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;

        return this;

    },

    subScalar: function ( s ) {

        this.x -= s;
        this.y -= s;
        this.z -= s;

        return this;

    },

    subVectors: function ( a, b ) {

        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;

        return this;

    },

    multiply: function ( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
            return this.multiplyVectors( v, w );

        }

        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;

        return this;

    },

    multiplyScalar: function ( scalar ) {

        if ( isFinite( scalar ) ) {
            this.x *= scalar;
            this.y *= scalar;
            this.z *= scalar;
        } else {
            this.x = 0;
            this.y = 0;
            this.z = 0;
        }

        return this;

    },

    multiplyVectors: function ( a, b ) {

        this.x = a.x * b.x;
        this.y = a.y * b.y;
        this.z = a.z * b.z;

        return this;

    },

    applyEuler: function () {

        var quaternion;

        return function applyEuler( euler ) {

            if ( euler instanceof THREE.Euler === false ) {

                console.error( 'THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.' );

            }

            if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

            this.applyQuaternion( quaternion.setFromEuler( euler ) );

            return this;

        };

    }(),

    applyAxisAngle: function () {

        var quaternion;

        return function applyAxisAngle( axis, angle ) {

            if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

            this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

            return this;

        };

    }(),

    applyMatrix3: function ( m ) {

        var x = this.x;
        var y = this.y;
        var z = this.z;

        var e = m.elements;

        this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
        this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
        this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

        return this;

    },

    applyMatrix4: function ( m ) {

        // input: THREE.Matrix4 affine matrix

        var x = this.x, y = this.y, z = this.z;

        var e = m.elements;

        this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
        this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
        this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

        return this;

    },

    applyProjection: function ( m ) {

        // input: THREE.Matrix4 projection matrix

        var x = this.x, y = this.y, z = this.z;

        var e = m.elements;
        var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

        this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
        this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
        this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

        return this;

    },

    applyQuaternion: function ( q ) {

        var x = this.x;
        var y = this.y;
        var z = this.z;

        var qx = q.x;
        var qy = q.y;
        var qz = q.z;
        var qw = q.w;

        // calculate quat * vector

        var ix =  qw * x + qy * z - qz * y;
        var iy =  qw * y + qz * x - qx * z;
        var iz =  qw * z + qx * y - qy * x;
        var iw = - qx * x - qy * y - qz * z;

        // calculate result * inverse quat

        this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
        this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
        this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

        return this;

    },

    project: function () {

        var matrix;

        return function project( camera ) {

            if ( matrix === undefined ) matrix = new THREE.Matrix4();

            matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
            return this.applyProjection( matrix );

        };

    }(),

    unproject: function () {

        var matrix;

        return function unproject( camera ) {

            if ( matrix === undefined ) matrix = new THREE.Matrix4();

            matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
            return this.applyProjection( matrix );

        };

    }(),

    transformDirection: function ( m ) {

        // input: THREE.Matrix4 affine matrix
        // vector interpreted as a direction

        var x = this.x, y = this.y, z = this.z;

        var e = m.elements;

        this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
        this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
        this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

        this.normalize();

        return this;

    },

    divide: function ( v ) {

        this.x /= v.x;
        this.y /= v.y;
        this.z /= v.z;

        return this;

    },

    divideScalar: function ( scalar ) {

        return this.multiplyScalar( 1 / scalar );

    },

    min: function ( v ) {

        this.x = Math.min( this.x, v.x );
        this.y = Math.min( this.y, v.y );
        this.z = Math.min( this.z, v.z );

        return this;

    },

    max: function ( v ) {

        this.x = Math.max( this.x, v.x );
        this.y = Math.max( this.y, v.y );
        this.z = Math.max( this.z, v.z );

        return this;

    },

    clamp: function ( min, max ) {

        // This function assumes min < max, if this assumption isn't true it will not operate correctly

        this.x = Math.max( min.x, Math.min( max.x, this.x ) );
        this.y = Math.max( min.y, Math.min( max.y, this.y ) );
        this.z = Math.max( min.z, Math.min( max.z, this.z ) );

        return this;

    },

    clampScalar: function () {

        var min, max;

        return function clampScalar( minVal, maxVal ) {

            if ( min === undefined ) {

                min = new THREE.Vector3();
                max = new THREE.Vector3();

            }

            min.set( minVal, minVal, minVal );
            max.set( maxVal, maxVal, maxVal );

            return this.clamp( min, max );

        };

    }(),

    clampLength: function ( min, max ) {

        var length = this.length();

        this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

        return this;

    },

    floor: function () {

        this.x = Math.floor( this.x );
        this.y = Math.floor( this.y );
        this.z = Math.floor( this.z );

        return this;

    },

    ceil: function () {

        this.x = Math.ceil( this.x );
        this.y = Math.ceil( this.y );
        this.z = Math.ceil( this.z );

        return this;

    },

    round: function () {

        this.x = Math.round( this.x );
        this.y = Math.round( this.y );
        this.z = Math.round( this.z );

        return this;

    },

    roundToZero: function () {

        this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
        this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
        this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

        return this;

    },

    negate: function () {

        this.x = - this.x;
        this.y = - this.y;
        this.z = - this.z;

        return this;

    },

    dot: function ( v ) {

        return this.x * v.x + this.y * v.y + this.z * v.z;

    },

    lengthSq: function () {

        return this.x * this.x + this.y * this.y + this.z * this.z;

    },

    length: function () {

        return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

    },

    lengthManhattan: function () {

        return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

    },

    normalize: function () {

        return this.divideScalar( this.length() );

    },

    setLength: function ( length ) {

        return this.multiplyScalar( length / this.length() );

    },

    lerp: function ( v, alpha ) {

        this.x += ( v.x - this.x ) * alpha;
        this.y += ( v.y - this.y ) * alpha;
        this.z += ( v.z - this.z ) * alpha;

        return this;

    },

    lerpVectors: function ( v1, v2, alpha ) {

        this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

        return this;

    },

    cross: function ( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
            return this.crossVectors( v, w );

        }

        var x = this.x, y = this.y, z = this.z;

        this.x = y * v.z - z * v.y;
        this.y = z * v.x - x * v.z;
        this.z = x * v.y - y * v.x;

        return this;

    },

    crossVectors: function ( a, b ) {

        var ax = a.x, ay = a.y, az = a.z;
        var bx = b.x, by = b.y, bz = b.z;

        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;

        return this;

    },

    projectOnVector: function () {

        var v1, dot;

        return function projectOnVector( vector ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();

            v1.copy( vector ).normalize();

            dot = this.dot( v1 );

            return this.copy( v1 ).multiplyScalar( dot );

        };

    }(),

    projectOnPlane: function () {

        var v1;

        return function projectOnPlane( planeNormal ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();

            v1.copy( this ).projectOnVector( planeNormal );

            return this.sub( v1 );

        }

    }(),

    reflect: function () {

        // reflect incident vector off plane orthogonal to normal
        // normal is assumed to have unit length

        var v1;

        return function reflect( normal ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();

            return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

        }

    }(),

    angleTo: function ( v ) {

        var theta = this.dot( v ) / ( this.length() * v.length() );

        // clamp, to handle numerical problems

        return Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );

    },

    distanceTo: function ( v ) {

        return Math.sqrt( this.distanceToSquared( v ) );

    },

    distanceToSquared: function ( v ) {

        var dx = this.x - v.x;
        var dy = this.y - v.y;
        var dz = this.z - v.z;

        return dx * dx + dy * dy + dz * dz;

    },

    setEulerFromRotationMatrix: function ( m, order ) {

        console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

    },

    setEulerFromQuaternion: function ( q, order ) {

        console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

    },

    getPositionFromMatrix: function ( m ) {

        console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );

        return this.setFromMatrixPosition( m );

    },

    getScaleFromMatrix: function ( m ) {

        console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );

        return this.setFromMatrixScale( m );

    },

    getColumnFromMatrix: function ( index, matrix ) {

        console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );

        return this.setFromMatrixColumn( index, matrix );

    },

    setFromMatrixPosition: function ( m ) {

        this.x = m.elements[ 12 ];
        this.y = m.elements[ 13 ];
        this.z = m.elements[ 14 ];

        return this;

    },

    setFromMatrixScale: function ( m ) {

        var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[ 2 ] ).length();
        var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[ 6 ] ).length();
        var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();

        this.x = sx;
        this.y = sy;
        this.z = sz;

        return this;

    },

    setFromMatrixColumn: function ( index, matrix ) {

        var offset = index * 4;

        var me = matrix.elements;

        this.x = me[ offset ];
        this.y = me[ offset + 1 ];
        this.z = me[ offset + 2 ];

        return this;

    },

    equals: function ( v ) {

        return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

    },

    fromArray: function ( array, offset ) {

        if ( offset === undefined ) offset = 0;

        this.x = array[ offset ];
        this.y = array[ offset + 1 ];
        this.z = array[ offset + 2 ];

        return this;

    },

    toArray: function ( array, offset ) {

        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this.x;
        array[ offset + 1 ] = this.y;
        array[ offset + 2 ] = this.z;

        return array;

    },

    fromAttribute: function ( attribute, index, offset ) {

        if ( offset === undefined ) offset = 0;

        index = index * attribute.itemSize + offset;

        this.x = attribute.array[ index ];
        this.y = attribute.array[ index + 1 ];
        this.z = attribute.array[ index + 2 ];

        return this;

    }

};

// File:src/math/Vector4.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector4 = function ( x, y, z, w ) {

    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
    this.w = ( w !== undefined ) ? w : 1;

};

THREE.Vector4.prototype = {

    constructor: THREE.Vector4,

    set: function ( x, y, z, w ) {

        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;

        return this;

    },

    setX: function ( x ) {

        this.x = x;

        return this;

    },

    setY: function ( y ) {

        this.y = y;

        return this;

    },

    setZ: function ( z ) {

        this.z = z;

        return this;

    },

    setW: function ( w ) {

        this.w = w;

        return this;

    },

    setComponent: function ( index, value ) {

        switch ( index ) {

            case 0: this.x = value; break;
            case 1: this.y = value; break;
            case 2: this.z = value; break;
            case 3: this.w = value; break;
            default: throw new Error( 'index is out of range: ' + index );

        }

    },

    getComponent: function ( index ) {

        switch ( index ) {

            case 0: return this.x;
            case 1: return this.y;
            case 2: return this.z;
            case 3: return this.w;
            default: throw new Error( 'index is out of range: ' + index );

        }

    },

    clone: function () {

        return new this.constructor( this.x, this.y, this.z, this.w );

    },

    copy: function ( v ) {

        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = ( v.w !== undefined ) ? v.w : 1;

        return this;

    },

    add: function ( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
            return this.addVectors( v, w );

        }

        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        this.w += v.w;

        return this;

    },

    addScalar: function ( s ) {

        this.x += s;
        this.y += s;
        this.z += s;
        this.w += s;

        return this;

    },

    addVectors: function ( a, b ) {

        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        this.w = a.w + b.w;

        return this;

    },

    addScaledVector: function ( v, s ) {

        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        this.w += v.w * s;

        return this;

    },

    sub: function ( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
            return this.subVectors( v, w );

        }

        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        this.w -= v.w;

        return this;

    },

    subScalar: function ( s ) {

        this.x -= s;
        this.y -= s;
        this.z -= s;
        this.w -= s;

        return this;

    },

    subVectors: function ( a, b ) {

        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        this.w = a.w - b.w;

        return this;

    },

    multiplyScalar: function ( scalar ) {

        if ( isFinite( scalar ) ) {
            this.x *= scalar;
            this.y *= scalar;
            this.z *= scalar;
            this.w *= scalar;
        } else {
            this.x = 0;
            this.y = 0;
            this.z = 0;
            this.w = 0;
        }

        return this;

    },

    applyMatrix4: function ( m ) {

        var x = this.x;
        var y = this.y;
        var z = this.z;
        var w = this.w;

        var e = m.elements;

        this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
        this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
        this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
        this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

        return this;

    },

    divideScalar: function ( scalar ) {

        return this.multiplyScalar( 1 / scalar );

    },

    setAxisAngleFromQuaternion: function ( q ) {

        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

        // q is assumed to be normalized

        this.w = 2 * Math.acos( q.w );

        var s = Math.sqrt( 1 - q.w * q.w );

        if ( s < 0.0001 ) {

            this.x = 1;
            this.y = 0;
            this.z = 0;

        } else {

            this.x = q.x / s;
            this.y = q.y / s;
            this.z = q.z / s;

        }

        return this;

    },

    setAxisAngleFromRotationMatrix: function ( m ) {

        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

        var angle, x, y, z,		// variables for result
            epsilon = 0.01,		// margin to allow for rounding errors
            epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

            te = m.elements,

            m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
            m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
            m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

        if ( ( Math.abs( m12 - m21 ) < epsilon )
            && ( Math.abs( m13 - m31 ) < epsilon )
            && ( Math.abs( m23 - m32 ) < epsilon ) ) {

            // singularity found
            // first check for identity matrix which must have +1 for all terms
            // in leading diagonal and zero in other terms

            if ( ( Math.abs( m12 + m21 ) < epsilon2 )
                && ( Math.abs( m13 + m31 ) < epsilon2 )
                && ( Math.abs( m23 + m32 ) < epsilon2 )
                && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

                // this singularity is identity matrix so angle = 0

                this.set( 1, 0, 0, 0 );

                return this; // zero angle, arbitrary axis

            }

            // otherwise this singularity is angle = 180

            angle = Math.PI;

            var xx = ( m11 + 1 ) / 2;
            var yy = ( m22 + 1 ) / 2;
            var zz = ( m33 + 1 ) / 2;
            var xy = ( m12 + m21 ) / 4;
            var xz = ( m13 + m31 ) / 4;
            var yz = ( m23 + m32 ) / 4;

            if ( ( xx > yy ) && ( xx > zz ) ) {

                // m11 is the largest diagonal term

                if ( xx < epsilon ) {

                    x = 0;
                    y = 0.707106781;
                    z = 0.707106781;

                } else {

                    x = Math.sqrt( xx );
                    y = xy / x;
                    z = xz / x;

                }

            } else if ( yy > zz ) {

                // m22 is the largest diagonal term

                if ( yy < epsilon ) {

                    x = 0.707106781;
                    y = 0;
                    z = 0.707106781;

                } else {

                    y = Math.sqrt( yy );
                    x = xy / y;
                    z = yz / y;

                }

            } else {

                // m33 is the largest diagonal term so base result on this

                if ( zz < epsilon ) {

                    x = 0.707106781;
                    y = 0.707106781;
                    z = 0;

                } else {

                    z = Math.sqrt( zz );
                    x = xz / z;
                    y = yz / z;

                }

            }

            this.set( x, y, z, angle );

            return this; // return 180 deg rotation

        }

        // as we have reached here there are no singularities so we can handle normally

        var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )
            + ( m13 - m31 ) * ( m13 - m31 )
            + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

        if ( Math.abs( s ) < 0.001 ) s = 1;

        // prevent divide by zero, should not happen if matrix is orthogonal and should be
        // caught by singularity test above, but I've left it in just in case

        this.x = ( m32 - m23 ) / s;
        this.y = ( m13 - m31 ) / s;
        this.z = ( m21 - m12 ) / s;
        this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

        return this;

    },

    min: function ( v ) {

        this.x = Math.min( this.x, v.x );
        this.y = Math.min( this.y, v.y );
        this.z = Math.min( this.z, v.z );
        this.w = Math.min( this.w, v.w );

        return this;

    },

    max: function ( v ) {

        this.x = Math.max( this.x, v.x );
        this.y = Math.max( this.y, v.y );
        this.z = Math.max( this.z, v.z );
        this.w = Math.max( this.w, v.w );

        return this;

    },

    clamp: function ( min, max ) {

        // This function assumes min < max, if this assumption isn't true it will not operate correctly

        this.x = Math.max( min.x, Math.min( max.x, this.x ) );
        this.y = Math.max( min.y, Math.min( max.y, this.y ) );
        this.z = Math.max( min.z, Math.min( max.z, this.z ) );
        this.w = Math.max( min.w, Math.min( max.w, this.w ) );

        return this;

    },

    clampScalar: function () {

        var min, max;

        return function clampScalar( minVal, maxVal ) {

            if ( min === undefined ) {

                min = new THREE.Vector4();
                max = new THREE.Vector4();

            }

            min.set( minVal, minVal, minVal, minVal );
            max.set( maxVal, maxVal, maxVal, maxVal );

            return this.clamp( min, max );

        };

    }(),

    floor: function () {

        this.x = Math.floor( this.x );
        this.y = Math.floor( this.y );
        this.z = Math.floor( this.z );
        this.w = Math.floor( this.w );

        return this;

    },

    ceil: function () {

        this.x = Math.ceil( this.x );
        this.y = Math.ceil( this.y );
        this.z = Math.ceil( this.z );
        this.w = Math.ceil( this.w );

        return this;

    },

    round: function () {

        this.x = Math.round( this.x );
        this.y = Math.round( this.y );
        this.z = Math.round( this.z );
        this.w = Math.round( this.w );

        return this;

    },

    roundToZero: function () {

        this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
        this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
        this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
        this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

        return this;

    },

    negate: function () {

        this.x = - this.x;
        this.y = - this.y;
        this.z = - this.z;
        this.w = - this.w;

        return this;

    },

    dot: function ( v ) {

        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

    },

    lengthSq: function () {

        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

    },

    length: function () {

        return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

    },

    lengthManhattan: function () {

        return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

    },

    normalize: function () {

        return this.divideScalar( this.length() );

    },

    setLength: function ( length ) {

        return this.multiplyScalar( length / this.length() );

    },

    lerp: function ( v, alpha ) {

        this.x += ( v.x - this.x ) * alpha;
        this.y += ( v.y - this.y ) * alpha;
        this.z += ( v.z - this.z ) * alpha;
        this.w += ( v.w - this.w ) * alpha;

        return this;

    },

    lerpVectors: function ( v1, v2, alpha ) {

        this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

        return this;

    },

    equals: function ( v ) {

        return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

    },

    fromArray: function ( array, offset ) {

        if ( offset === undefined ) offset = 0;

        this.x = array[ offset ];
        this.y = array[ offset + 1 ];
        this.z = array[ offset + 2 ];
        this.w = array[ offset + 3 ];

        return this;

    },

    toArray: function ( array, offset ) {

        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this.x;
        array[ offset + 1 ] = this.y;
        array[ offset + 2 ] = this.z;
        array[ offset + 3 ] = this.w;

        return array;

    },

    fromAttribute: function ( attribute, index, offset ) {

        if ( offset === undefined ) offset = 0;

        index = index * attribute.itemSize + offset;

        this.x = attribute.array[ index ];
        this.y = attribute.array[ index + 1 ];
        this.z = attribute.array[ index + 2 ];
        this.w = attribute.array[ index + 3 ];

        return this;

    }

};

// File:src/math/Euler.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

THREE.Euler = function ( x, y, z, order ) {

    this._x = x || 0;
    this._y = y || 0;
    this._z = z || 0;
    this._order = order || THREE.Euler.DefaultOrder;

};

THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

THREE.Euler.DefaultOrder = 'XYZ';

THREE.Euler.prototype = {

    constructor: THREE.Euler,

    get x () {

        return this._x;

    },

    set x ( value ) {

        this._x = value;
        this.onChangeCallback();

    },

    get y () {

        return this._y;

    },

    set y ( value ) {

        this._y = value;
        this.onChangeCallback();

    },

    get z () {

        return this._z;

    },

    set z ( value ) {

        this._z = value;
        this.onChangeCallback();

    },

    get order () {

        return this._order;

    },

    set order ( value ) {

        this._order = value;
        this.onChangeCallback();

    },

    set: function ( x, y, z, order ) {

        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order || this._order;

        this.onChangeCallback();

        return this;

    },

    clone: function () {

        return new this.constructor( this._x, this._y, this._z, this._order);

    },

    copy: function ( euler ) {

        this._x = euler._x;
        this._y = euler._y;
        this._z = euler._z;
        this._order = euler._order;

        this.onChangeCallback();

        return this;

    },

    setFromRotationMatrix: function ( m, order, update ) {

        var clamp = THREE.Math.clamp;

        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

        var te = m.elements;
        var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
        var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
        var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

        order = order || this._order;

        if ( order === 'XYZ' ) {

            this._y = Math.asin( clamp( m13, - 1, 1 ) );

            if ( Math.abs( m13 ) < 0.99999 ) {

                this._x = Math.atan2( - m23, m33 );
                this._z = Math.atan2( - m12, m11 );

            } else {

                this._x = Math.atan2( m32, m22 );
                this._z = 0;

            }

        } else if ( order === 'YXZ' ) {

            this._x = Math.asin( - clamp( m23, - 1, 1 ) );

            if ( Math.abs( m23 ) < 0.99999 ) {

                this._y = Math.atan2( m13, m33 );
                this._z = Math.atan2( m21, m22 );

            } else {

                this._y = Math.atan2( - m31, m11 );
                this._z = 0;

            }

        } else if ( order === 'ZXY' ) {

            this._x = Math.asin( clamp( m32, - 1, 1 ) );

            if ( Math.abs( m32 ) < 0.99999 ) {

                this._y = Math.atan2( - m31, m33 );
                this._z = Math.atan2( - m12, m22 );

            } else {

                this._y = 0;
                this._z = Math.atan2( m21, m11 );

            }

        } else if ( order === 'ZYX' ) {

            this._y = Math.asin( - clamp( m31, - 1, 1 ) );

            if ( Math.abs( m31 ) < 0.99999 ) {

                this._x = Math.atan2( m32, m33 );
                this._z = Math.atan2( m21, m11 );

            } else {

                this._x = 0;
                this._z = Math.atan2( - m12, m22 );

            }

        } else if ( order === 'YZX' ) {

            this._z = Math.asin( clamp( m21, - 1, 1 ) );

            if ( Math.abs( m21 ) < 0.99999 ) {

                this._x = Math.atan2( - m23, m22 );
                this._y = Math.atan2( - m31, m11 );

            } else {

                this._x = 0;
                this._y = Math.atan2( m13, m33 );

            }

        } else if ( order === 'XZY' ) {

            this._z = Math.asin( - clamp( m12, - 1, 1 ) );

            if ( Math.abs( m12 ) < 0.99999 ) {

                this._x = Math.atan2( m32, m22 );
                this._y = Math.atan2( m13, m11 );

            } else {

                this._x = Math.atan2( - m23, m33 );
                this._y = 0;

            }

        } else {

            console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )

        }

        this._order = order;

        if ( update !== false ) this.onChangeCallback();

        return this;

    },

    setFromQuaternion: function () {

        var matrix;

        return function ( q, order, update ) {

            if ( matrix === undefined ) matrix = new THREE.Matrix4();
            matrix.makeRotationFromQuaternion( q );
            this.setFromRotationMatrix( matrix, order, update );

            return this;

        };

    }(),

    setFromVector3: function ( v, order ) {

        return this.set( v.x, v.y, v.z, order || this._order );

    },

    reorder: function () {

        // WARNING: this discards revolution information -bhouston

        var q = new THREE.Quaternion();

        return function ( newOrder ) {

            q.setFromEuler( this );
            this.setFromQuaternion( q, newOrder );

        };

    }(),

    equals: function ( euler ) {

        return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

    },

    fromArray: function ( array ) {

        this._x = array[ 0 ];
        this._y = array[ 1 ];
        this._z = array[ 2 ];
        if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

        this.onChangeCallback();

        return this;

    },

    toArray: function ( array, offset ) {

        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this._x;
        array[ offset + 1 ] = this._y;
        array[ offset + 2 ] = this._z;
        array[ offset + 3 ] = this._order;

        return array;

    },

    toVector3: function ( optionalResult ) {

        if ( optionalResult ) {

            return optionalResult.set( this._x, this._y, this._z );

        } else {

            return new THREE.Vector3( this._x, this._y, this._z );

        }

    },

    onChange: function ( callback ) {

        this.onChangeCallback = callback;

        return this;

    },

    onChangeCallback: function () {}

};

// File:src/math/Line3.js

/**
 * @author bhouston / http://clara.io
 */

THREE.Line3 = function ( start, end ) {

    this.start = ( start !== undefined ) ? start : new THREE.Vector3();
    this.end = ( end !== undefined ) ? end : new THREE.Vector3();

};

THREE.Line3.prototype = {

    constructor: THREE.Line3,

    set: function ( start, end ) {

        this.start.copy( start );
        this.end.copy( end );

        return this;

    },

    clone: function () {

        return new this.constructor().copy( this );

    },

    copy: function ( line ) {

        this.start.copy( line.start );
        this.end.copy( line.end );

        return this;

    },

    center: function ( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

    },

    delta: function ( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.subVectors( this.end, this.start );

    },

    distanceSq: function () {

        return this.start.distanceToSquared( this.end );

    },

    distance: function () {

        return this.start.distanceTo( this.end );

    },

    at: function ( t, optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();

        return this.delta( result ).multiplyScalar( t ).add( this.start );

    },

    closestPointToPointParameter: function () {

        var startP = new THREE.Vector3();
        var startEnd = new THREE.Vector3();

        return function ( point, clampToLine ) {

            startP.subVectors( point, this.start );
            startEnd.subVectors( this.end, this.start );

            var startEnd2 = startEnd.dot( startEnd );
            var startEnd_startP = startEnd.dot( startP );

            var t = startEnd_startP / startEnd2;

            if ( clampToLine ) {

                t = THREE.Math.clamp( t, 0, 1 );

            }

            return t;

        };

    }(),

    closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

        var t = this.closestPointToPointParameter( point, clampToLine );

        var result = optionalTarget || new THREE.Vector3();

        return this.delta( result ).multiplyScalar( t ).add( this.start );

    },

    applyMatrix4: function ( matrix ) {

        this.start.applyMatrix4( matrix );
        this.end.applyMatrix4( matrix );

        return this;

    },

    equals: function ( line ) {

        return line.start.equals( this.start ) && line.end.equals( this.end );

    }

};

// File:src/math/Box2.js

/**
 * @author bhouston / http://clara.io
 */

THREE.Box2 = function ( min, max ) {

    this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );
    this.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );

};

THREE.Box2.prototype = {

    constructor: THREE.Box2,

    set: function ( min, max ) {

        this.min.copy( min );
        this.max.copy( max );

        return this;

    },

    setFromPoints: function ( points ) {

        this.makeEmpty();

        for ( var i = 0, il = points.length; i < il; i ++ ) {

            this.expandByPoint( points[ i ] )

        }

        return this;

    },

    setFromCenterAndSize: function () {

        var v1 = new THREE.Vector2();

        return function ( center, size ) {

            var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
            this.min.copy( center ).sub( halfSize );
            this.max.copy( center ).add( halfSize );

            return this;

        };

    }(),

    clone: function () {

        return new this.constructor().copy( this );

    },

    copy: function ( box ) {

        this.min.copy( box.min );
        this.max.copy( box.max );

        return this;

    },

    makeEmpty: function () {

        this.min.x = this.min.y = Infinity;
        this.max.x = this.max.y = - Infinity;

        return this;

    },

    empty: function () {

        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

        return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

    },

    center: function ( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector2();
        return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

    },

    size: function ( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector2();
        return result.subVectors( this.max, this.min );

    },

    expandByPoint: function ( point ) {

        this.min.min( point );
        this.max.max( point );

        return this;

    },

    expandByVector: function ( vector ) {

        this.min.sub( vector );
        this.max.add( vector );

        return this;

    },

    expandByScalar: function ( scalar ) {

        this.min.addScalar( - scalar );
        this.max.addScalar( scalar );

        return this;

    },

    containsPoint: function ( point ) {

        if ( point.x < this.min.x || point.x > this.max.x ||
            point.y < this.min.y || point.y > this.max.y ) {

            return false;

        }

        return true;

    },

    containsBox: function ( box ) {

        if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
            ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

            return true;

        }

        return false;

    },

    getParameter: function ( point, optionalTarget ) {

        // This can potentially have a divide by zero if the box
        // has a size dimension of 0.

        var result = optionalTarget || new THREE.Vector2();

        return result.set(
            ( point.x - this.min.x ) / ( this.max.x - this.min.x ),
            ( point.y - this.min.y ) / ( this.max.y - this.min.y )
        );

    },

    isIntersectionBox: function ( box ) {

        // using 6 splitting planes to rule out intersections.

        if ( box.max.x < this.min.x || box.min.x > this.max.x ||
            box.max.y < this.min.y || box.min.y > this.max.y ) {

            return false;

        }

        return true;

    },

    clampPoint: function ( point, optionalTarget ) {

        var result = optionalTarget || new THREE.Vector2();
        return result.copy( point ).clamp( this.min, this.max );

    },

    distanceToPoint: function () {

        var v1 = new THREE.Vector2();

        return function ( point ) {

            var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
            return clampedPoint.sub( point ).length();

        };

    }(),

    intersect: function ( box ) {

        this.min.max( box.min );
        this.max.min( box.max );

        return this;

    },

    union: function ( box ) {

        this.min.min( box.min );
        this.max.max( box.max );

        return this;

    },

    translate: function ( offset ) {

        this.min.add( offset );
        this.max.add( offset );

        return this;

    },

    equals: function ( box ) {

        return box.min.equals( this.min ) && box.max.equals( this.max );

    }

};

// File:src/math/Box3.js

/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Box3 = function ( min, max ) {

    this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );
    this.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );

};

THREE.Box3.prototype = {

    constructor: THREE.Box3,

    set: function ( min, max ) {

        this.min.copy( min );
        this.max.copy( max );

        return this;

    },

    setFromPoints: function ( points ) {

        this.makeEmpty();

        for ( var i = 0, il = points.length; i < il; i ++ ) {

            this.expandByPoint( points[ i ] );

        }

        return this;

    },

    setFromCenterAndSize: function () {

        var v1 = new THREE.Vector3();

        return function ( center, size ) {

            var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

            this.min.copy( center ).sub( halfSize );
            this.max.copy( center ).add( halfSize );

            return this;

        };

    }(),

    setFromObject: function () {

        // Computes the world-axis-aligned bounding box of an object (including its children),
        // accounting for both the object's, and children's, world transforms

        var v1 = new THREE.Vector3();

        return function ( object ) {

            var scope = this;

            object.updateMatrixWorld( true );

            this.makeEmpty();

            object.traverse( function ( node ) {

                var geometry = node.geometry;

                if ( geometry !== undefined ) {

                    if ( geometry instanceof THREE.Geometry ) {

                        var vertices = geometry.vertices;

                        for ( var i = 0, il = vertices.length; i < il; i ++ ) {

                            v1.copy( vertices[ i ] );

                            v1.applyMatrix4( node.matrixWorld );

                            scope.expandByPoint( v1 );

                        }

                    } else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {

                        var positions = geometry.attributes[ 'position' ].array;

                        for ( var i = 0, il = positions.length; i < il; i += 3 ) {

                            v1.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );

                            v1.applyMatrix4( node.matrixWorld );

                            scope.expandByPoint( v1 );

                        }

                    }

                }

            } );

            return this;

        };

    }(),

    clone: function () {

        return new this.constructor().copy( this );

    },

    copy: function ( box ) {

        this.min.copy( box.min );
        this.max.copy( box.max );

        return this;

    },

    makeEmpty: function () {

        this.min.x = this.min.y = this.min.z = Infinity;
        this.max.x = this.max.y = this.max.z = - Infinity;

        return this;

    },

    empty: function () {

        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

        return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

    },

    center: function ( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

    },

    size: function ( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.subVectors( this.max, this.min );

    },

    expandByPoint: function ( point ) {

        this.min.min( point );
        this.max.max( point );

        return this;

    },

    expandByVector: function ( vector ) {

        this.min.sub( vector );
        this.max.add( vector );

        return this;

    },

    expandByScalar: function ( scalar ) {

        this.min.addScalar( - scalar );
        this.max.addScalar( scalar );

        return this;

    },

    containsPoint: function ( point ) {

        if ( point.x < this.min.x || point.x > this.max.x ||
            point.y < this.min.y || point.y > this.max.y ||
            point.z < this.min.z || point.z > this.max.z ) {

            return false;

        }

        return true;

    },

    containsBox: function ( box ) {

        if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
            ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
            ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

            return true;

        }

        return false;

    },

    getParameter: function ( point, optionalTarget ) {

        // This can potentially have a divide by zero if the box
        // has a size dimension of 0.

        var result = optionalTarget || new THREE.Vector3();

        return result.set(
            ( point.x - this.min.x ) / ( this.max.x - this.min.x ),
            ( point.y - this.min.y ) / ( this.max.y - this.min.y ),
            ( point.z - this.min.z ) / ( this.max.z - this.min.z )
        );

    },

    isIntersectionBox: function ( box ) {

        // using 6 splitting planes to rule out intersections.

        if ( box.max.x < this.min.x || box.min.x > this.max.x ||
            box.max.y < this.min.y || box.min.y > this.max.y ||
            box.max.z < this.min.z || box.min.z > this.max.z ) {

            return false;

        }

        return true;

    },

    clampPoint: function ( point, optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.copy( point ).clamp( this.min, this.max );

    },

    distanceToPoint: function () {

        var v1 = new THREE.Vector3();

        return function ( point ) {

            var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
            return clampedPoint.sub( point ).length();

        };

    }(),

    getBoundingSphere: function () {

        var v1 = new THREE.Vector3();

        return function ( optionalTarget ) {

            var result = optionalTarget || new THREE.Sphere();

            result.center = this.center();
            result.radius = this.size( v1 ).length() * 0.5;

            return result;

        };

    }(),

    intersect: function ( box ) {

        this.min.max( box.min );
        this.max.min( box.max );

        return this;

    },

    union: function ( box ) {

        this.min.min( box.min );
        this.max.max( box.max );

        return this;

    },

    applyMatrix4: function () {

        var points = [
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3()
        ];

        return function ( matrix ) {

            // NOTE: I am using a binary pattern to specify all 2^3 combinations below
            points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
            points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
            points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
            points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
            points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
            points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
            points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
            points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111

            this.makeEmpty();
            this.setFromPoints( points );

            return this;

        };

    }(),

    translate: function ( offset ) {

        this.min.add( offset );
        this.max.add( offset );

        return this;

    },

    equals: function ( box ) {

        return box.min.equals( this.min ) && box.max.equals( this.max );

    }

};

// File:src/math/Matrix3.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

THREE.Matrix3 = function () {

    this.elements = new Float32Array( [

        1, 0, 0,
        0, 1, 0,
        0, 0, 1

    ] );

    if ( arguments.length > 0 ) {

        console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

    }

};

THREE.Matrix3.prototype = {

    constructor: THREE.Matrix3,

    set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

        var te = this.elements;

        te[ 0 ] = n11; te[ 3 ] = n12; te[ 6 ] = n13;
        te[ 1 ] = n21; te[ 4 ] = n22; te[ 7 ] = n23;
        te[ 2 ] = n31; te[ 5 ] = n32; te[ 8 ] = n33;

        return this;

    },

    identity: function () {

        this.set(

            1, 0, 0,
            0, 1, 0,
            0, 0, 1

        );

        return this;

    },

    clone: function () {

        return new this.constructor().fromArray( this.elements );

    },

    copy: function ( m ) {

        var me = m.elements;

        this.set(

            me[ 0 ], me[ 3 ], me[ 6 ],
            me[ 1 ], me[ 4 ], me[ 7 ],
            me[ 2 ], me[ 5 ], me[ 8 ]

        );

        return this;

    },

    multiplyVector3: function ( vector ) {

        console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
        return vector.applyMatrix3( this );

    },

    multiplyVector3Array: function ( a ) {

        console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
        return this.applyToVector3Array( a );

    },

    applyToVector3Array: function () {

        var v1;

        return function ( array, offset, length ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();
            if ( offset === undefined ) offset = 0;
            if ( length === undefined ) length = array.length;

            for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

                v1.fromArray( array, j );
                v1.applyMatrix3( this );
                v1.toArray( array, j );

            }

            return array;

        };

    }(),

    applyToBuffer: function () {

        var v1;

        return function applyToBuffer( buffer, offset, length ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();
            if ( offset === undefined ) offset = 0;
            if ( length === undefined ) length = buffer.length / buffer.itemSize;

            for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

                v1.x = buffer.getX( j );
                v1.y = buffer.getY( j );
                v1.z = buffer.getZ( j );

                v1.applyMatrix3( this );

                buffer.setXYZ( v1.x, v1.y, v1.z );

            }

            return buffer;

        };

    }(),

    multiplyScalar: function ( s ) {

        var te = this.elements;

        te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
        te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
        te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

        return this;

    },

    determinant: function () {

        var te = this.elements;

        var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
            d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
            g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

        return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

    },

    getInverse: function ( matrix, throwOnInvertible ) {

        // input: THREE.Matrix4
        // ( based on http://code.google.com/p/webgl-mjs/ )

        var me = matrix.elements;
        var te = this.elements;

        te[ 0 ] =   me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];
        te[ 1 ] = - me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];
        te[ 2 ] =   me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];
        te[ 3 ] = - me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];
        te[ 4 ] =   me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];
        te[ 5 ] = - me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];
        te[ 6 ] =   me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];
        te[ 7 ] = - me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];
        te[ 8 ] =   me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];

        var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];

        // no inverse

        if ( det === 0 ) {

            var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";

            if ( throwOnInvertible || false ) {

                throw new Error( msg );

            } else {

                console.warn( msg );

            }

            this.identity();

            return this;

        }

        this.multiplyScalar( 1.0 / det );

        return this;

    },

    transpose: function () {

        var tmp, m = this.elements;

        tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
        tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
        tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

        return this;

    },

    flattenToArrayOffset: function ( array, offset ) {

        var te = this.elements;

        array[ offset ] = te[ 0 ];
        array[ offset + 1 ] = te[ 1 ];
        array[ offset + 2 ] = te[ 2 ];

        array[ offset + 3 ] = te[ 3 ];
        array[ offset + 4 ] = te[ 4 ];
        array[ offset + 5 ] = te[ 5 ];

        array[ offset + 6 ] = te[ 6 ];
        array[ offset + 7 ] = te[ 7 ];
        array[ offset + 8 ]  = te[ 8 ];

        return array;

    },

    getNormalMatrix: function ( m ) {

        // input: THREE.Matrix4

        this.getInverse( m ).transpose();

        return this;

    },

    transposeIntoArray: function ( r ) {

        var m = this.elements;

        r[ 0 ] = m[ 0 ];
        r[ 1 ] = m[ 3 ];
        r[ 2 ] = m[ 6 ];
        r[ 3 ] = m[ 1 ];
        r[ 4 ] = m[ 4 ];
        r[ 5 ] = m[ 7 ];
        r[ 6 ] = m[ 2 ];
        r[ 7 ] = m[ 5 ];
        r[ 8 ] = m[ 8 ];

        return this;

    },

    fromArray: function ( array ) {

        this.elements.set( array );

        return this;

    },

    toArray: function () {

        var te = this.elements;

        return [
            te[ 0 ], te[ 1 ], te[ 2 ],
            te[ 3 ], te[ 4 ], te[ 5 ],
            te[ 6 ], te[ 7 ], te[ 8 ]
        ];

    }

};

// File:src/math/Matrix4.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Matrix4 = function () {

    this.elements = new Float32Array( [

        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1

    ] );

    if ( arguments.length > 0 ) {

        console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

    }

};

THREE.Matrix4.prototype = {

    constructor: THREE.Matrix4,

    set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

        var te = this.elements;

        te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
        te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
        te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
        te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

        return this;

    },

    identity: function () {

        this.set(

            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1

        );

        return this;

    },

    clone: function () {

        return new THREE.Matrix4().fromArray( this.elements );

    },

    copy: function ( m ) {

        this.elements.set( m.elements );

        return this;

    },

    extractPosition: function ( m ) {

        console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
        return this.copyPosition( m );

    },

    copyPosition: function ( m ) {

        var te = this.elements;
        var me = m.elements;

        te[ 12 ] = me[ 12 ];
        te[ 13 ] = me[ 13 ];
        te[ 14 ] = me[ 14 ];

        return this;

    },

    extractBasis: function ( xAxis, yAxis, zAxis ) {

        var te = this.elements;

        xAxis.set( te[ 0 ], te[ 1 ], te[ 2 ] );
        yAxis.set( te[ 4 ], te[ 5 ], te[ 6 ] );
        zAxis.set( te[ 8 ], te[ 9 ], te[ 10 ] );

        return this;

    },

    makeBasis: function ( xAxis, yAxis, zAxis ) {

        this.set(
            xAxis.x, yAxis.x, zAxis.x, 0,
            xAxis.y, yAxis.y, zAxis.y, 0,
            xAxis.z, yAxis.z, zAxis.z, 0,
            0,       0,       0,       1
        );

        return this;

    },

    extractRotation: function () {

        var v1;

        return function ( m ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();

            var te = this.elements;
            var me = m.elements;

            var scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();
            var scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();
            var scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();

            te[ 0 ] = me[ 0 ] * scaleX;
            te[ 1 ] = me[ 1 ] * scaleX;
            te[ 2 ] = me[ 2 ] * scaleX;

            te[ 4 ] = me[ 4 ] * scaleY;
            te[ 5 ] = me[ 5 ] * scaleY;
            te[ 6 ] = me[ 6 ] * scaleY;

            te[ 8 ] = me[ 8 ] * scaleZ;
            te[ 9 ] = me[ 9 ] * scaleZ;
            te[ 10 ] = me[ 10 ] * scaleZ;

            return this;

        };

    }(),

    makeRotationFromEuler: function ( euler ) {

        if ( euler instanceof THREE.Euler === false ) {

            console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

        }

        var te = this.elements;

        var x = euler.x, y = euler.y, z = euler.z;
        var a = Math.cos( x ), b = Math.sin( x );
        var c = Math.cos( y ), d = Math.sin( y );
        var e = Math.cos( z ), f = Math.sin( z );

        if ( euler.order === 'XYZ' ) {

            var ae = a * e, af = a * f, be = b * e, bf = b * f;

            te[ 0 ] = c * e;
            te[ 4 ] = - c * f;
            te[ 8 ] = d;

            te[ 1 ] = af + be * d;
            te[ 5 ] = ae - bf * d;
            te[ 9 ] = - b * c;

            te[ 2 ] = bf - ae * d;
            te[ 6 ] = be + af * d;
            te[ 10 ] = a * c;

        } else if ( euler.order === 'YXZ' ) {

            var ce = c * e, cf = c * f, de = d * e, df = d * f;

            te[ 0 ] = ce + df * b;
            te[ 4 ] = de * b - cf;
            te[ 8 ] = a * d;

            te[ 1 ] = a * f;
            te[ 5 ] = a * e;
            te[ 9 ] = - b;

            te[ 2 ] = cf * b - de;
            te[ 6 ] = df + ce * b;
            te[ 10 ] = a * c;

        } else if ( euler.order === 'ZXY' ) {

            var ce = c * e, cf = c * f, de = d * e, df = d * f;

            te[ 0 ] = ce - df * b;
            te[ 4 ] = - a * f;
            te[ 8 ] = de + cf * b;

            te[ 1 ] = cf + de * b;
            te[ 5 ] = a * e;
            te[ 9 ] = df - ce * b;

            te[ 2 ] = - a * d;
            te[ 6 ] = b;
            te[ 10 ] = a * c;

        } else if ( euler.order === 'ZYX' ) {

            var ae = a * e, af = a * f, be = b * e, bf = b * f;

            te[ 0 ] = c * e;
            te[ 4 ] = be * d - af;
            te[ 8 ] = ae * d + bf;

            te[ 1 ] = c * f;
            te[ 5 ] = bf * d + ae;
            te[ 9 ] = af * d - be;

            te[ 2 ] = - d;
            te[ 6 ] = b * c;
            te[ 10 ] = a * c;

        } else if ( euler.order === 'YZX' ) {

            var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

            te[ 0 ] = c * e;
            te[ 4 ] = bd - ac * f;
            te[ 8 ] = bc * f + ad;

            te[ 1 ] = f;
            te[ 5 ] = a * e;
            te[ 9 ] = - b * e;

            te[ 2 ] = - d * e;
            te[ 6 ] = ad * f + bc;
            te[ 10 ] = ac - bd * f;

        } else if ( euler.order === 'XZY' ) {

            var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

            te[ 0 ] = c * e;
            te[ 4 ] = - f;
            te[ 8 ] = d * e;

            te[ 1 ] = ac * f + bd;
            te[ 5 ] = a * e;
            te[ 9 ] = ad * f - bc;

            te[ 2 ] = bc * f - ad;
            te[ 6 ] = b * e;
            te[ 10 ] = bd * f + ac;

        }

        // last column
        te[ 3 ] = 0;
        te[ 7 ] = 0;
        te[ 11 ] = 0;

        // bottom row
        te[ 12 ] = 0;
        te[ 13 ] = 0;
        te[ 14 ] = 0;
        te[ 15 ] = 1;

        return this;

    },

    setRotationFromQuaternion: function ( q ) {

        console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );

        return this.makeRotationFromQuaternion( q );

    },

    makeRotationFromQuaternion: function ( q ) {

        var te = this.elements;

        var x = q.x, y = q.y, z = q.z, w = q.w;
        var x2 = x + x, y2 = y + y, z2 = z + z;
        var xx = x * x2, xy = x * y2, xz = x * z2;
        var yy = y * y2, yz = y * z2, zz = z * z2;
        var wx = w * x2, wy = w * y2, wz = w * z2;

        te[ 0 ] = 1 - ( yy + zz );
        te[ 4 ] = xy - wz;
        te[ 8 ] = xz + wy;

        te[ 1 ] = xy + wz;
        te[ 5 ] = 1 - ( xx + zz );
        te[ 9 ] = yz - wx;

        te[ 2 ] = xz - wy;
        te[ 6 ] = yz + wx;
        te[ 10 ] = 1 - ( xx + yy );

        // last column
        te[ 3 ] = 0;
        te[ 7 ] = 0;
        te[ 11 ] = 0;

        // bottom row
        te[ 12 ] = 0;
        te[ 13 ] = 0;
        te[ 14 ] = 0;
        te[ 15 ] = 1;

        return this;

    },

    lookAt: function () {

        var x, y, z;

        return function ( eye, target, up ) {

            if ( x === undefined ) x = new THREE.Vector3();
            if ( y === undefined ) y = new THREE.Vector3();
            if ( z === undefined ) z = new THREE.Vector3();

            var te = this.elements;

            z.subVectors( eye, target ).normalize();

            if ( z.lengthSq() === 0 ) {

                z.z = 1;

            }

            x.crossVectors( up, z ).normalize();

            if ( x.lengthSq() === 0 ) {

                z.x += 0.0001;
                x.crossVectors( up, z ).normalize();

            }

            y.crossVectors( z, x );


            te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
            te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
            te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

            return this;

        };

    }(),

    multiply: function ( m, n ) {

        if ( n !== undefined ) {

            console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
            return this.multiplyMatrices( m, n );

        }

        return this.multiplyMatrices( this, m );

    },

    multiplyMatrices: function ( a, b ) {

        var ae = a.elements;
        var be = b.elements;
        var te = this.elements;

        var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
        var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
        var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
        var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

        var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
        var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
        var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
        var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

        te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

        te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

        te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

        te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

        return this;

    },

    multiplyToArray: function ( a, b, r ) {

        var te = this.elements;

        this.multiplyMatrices( a, b );

        r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
        r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
        r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
        r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];

        return this;

    },

    multiplyScalar: function ( s ) {

        var te = this.elements;

        te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
        te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
        te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
        te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

        return this;

    },

    multiplyVector3: function ( vector ) {

        console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
        return vector.applyProjection( this );

    },

    multiplyVector4: function ( vector ) {

        console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
        return vector.applyMatrix4( this );

    },

    multiplyVector3Array: function ( a ) {

        console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
        return this.applyToVector3Array( a );

    },

    applyToVector3Array: function () {

        var v1;

        return function ( array, offset, length ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();
            if ( offset === undefined ) offset = 0;
            if ( length === undefined ) length = array.length;

            for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

                v1.fromArray( array, j );
                v1.applyMatrix4( this );
                v1.toArray( array, j );

            }

            return array;

        };

    }(),

    applyToBuffer: function () {

        var v1;

        return function applyToBuffer( buffer, offset, length ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();
            if ( offset === undefined ) offset = 0;
            if ( length === undefined ) length = buffer.length / buffer.itemSize;

            for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

                v1.x = buffer.getX( j );
                v1.y = buffer.getY( j );
                v1.z = buffer.getZ( j );

                v1.applyMatrix4( this );

                buffer.setXYZ( v1.x, v1.y, v1.z );

            }

            return buffer;

        };

    }(),

    rotateAxis: function ( v ) {

        console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );

        v.transformDirection( this );

    },

    crossVector: function ( vector ) {

        console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
        return vector.applyMatrix4( this );

    },

    determinant: function () {

        var te = this.elements;

        var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
        var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
        var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
        var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

        //TODO: make this more efficient
        //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

        return (
            n41 * (
                + n14 * n23 * n32
                - n13 * n24 * n32
                - n14 * n22 * n33
                + n12 * n24 * n33
                + n13 * n22 * n34
                - n12 * n23 * n34
            ) +
            n42 * (
                + n11 * n23 * n34
                - n11 * n24 * n33
                + n14 * n21 * n33
                - n13 * n21 * n34
                + n13 * n24 * n31
                - n14 * n23 * n31
            ) +
            n43 * (
                + n11 * n24 * n32
                - n11 * n22 * n34
                - n14 * n21 * n32
                + n12 * n21 * n34
                + n14 * n22 * n31
                - n12 * n24 * n31
            ) +
            n44 * (
                - n13 * n22 * n31
                - n11 * n23 * n32
                + n11 * n22 * n33
                + n13 * n21 * n32
                - n12 * n21 * n33
                + n12 * n23 * n31
            )

        );

    },

    transpose: function () {

        var te = this.elements;
        var tmp;

        tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
        tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
        tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

        tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
        tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
        tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

        return this;

    },

    flattenToArrayOffset: function ( array, offset ) {

        var te = this.elements;

        array[ offset ] = te[ 0 ];
        array[ offset + 1 ] = te[ 1 ];
        array[ offset + 2 ] = te[ 2 ];
        array[ offset + 3 ] = te[ 3 ];

        array[ offset + 4 ] = te[ 4 ];
        array[ offset + 5 ] = te[ 5 ];
        array[ offset + 6 ] = te[ 6 ];
        array[ offset + 7 ] = te[ 7 ];

        array[ offset + 8 ]  = te[ 8 ];
        array[ offset + 9 ]  = te[ 9 ];
        array[ offset + 10 ] = te[ 10 ];
        array[ offset + 11 ] = te[ 11 ];

        array[ offset + 12 ] = te[ 12 ];
        array[ offset + 13 ] = te[ 13 ];
        array[ offset + 14 ] = te[ 14 ];
        array[ offset + 15 ] = te[ 15 ];

        return array;

    },

    getPosition: function () {

        var v1;

        return function () {

            if ( v1 === undefined ) v1 = new THREE.Vector3();
            console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

            var te = this.elements;
            return v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );

        };

    }(),

    setPosition: function ( v ) {

        var te = this.elements;

        te[ 12 ] = v.x;
        te[ 13 ] = v.y;
        te[ 14 ] = v.z;

        return this;

    },

    getInverse: function ( m, throwOnInvertible ) {

        // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
        var te = this.elements;
        var me = m.elements;

        var n11 = me[ 0 ], n12 = me[ 4 ], n13 = me[ 8 ], n14 = me[ 12 ];
        var n21 = me[ 1 ], n22 = me[ 5 ], n23 = me[ 9 ], n24 = me[ 13 ];
        var n31 = me[ 2 ], n32 = me[ 6 ], n33 = me[ 10 ], n34 = me[ 14 ];
        var n41 = me[ 3 ], n42 = me[ 7 ], n43 = me[ 11 ], n44 = me[ 15 ];

        te[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
        te[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
        te[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
        te[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
        te[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
        te[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
        te[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
        te[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
        te[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
        te[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
        te[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
        te[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
        te[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
        te[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
        te[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
        te[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;

        var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];

        if ( det === 0 ) {

            var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";

            if ( throwOnInvertible || false ) {

                throw new Error( msg );

            } else {

                console.warn( msg );

            }

            this.identity();

            return this;

        }

        this.multiplyScalar( 1 / det );

        return this;

    },

    translate: function ( v ) {

        console.error( 'THREE.Matrix4: .translate() has been removed.' );

    },

    rotateX: function ( angle ) {

        console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

    },

    rotateY: function ( angle ) {

        console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

    },

    rotateZ: function ( angle ) {

        console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

    },

    rotateByAxis: function ( axis, angle ) {

        console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

    },

    scale: function ( v ) {

        var te = this.elements;
        var x = v.x, y = v.y, z = v.z;

        te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
        te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
        te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
        te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

        return this;

    },

    getMaxScaleOnAxis: function () {

        var te = this.elements;

        var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
        var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
        var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

        return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

    },

    makeTranslation: function ( x, y, z ) {

        this.set(

            1, 0, 0, x,
            0, 1, 0, y,
            0, 0, 1, z,
            0, 0, 0, 1

        );

        return this;

    },

    makeRotationX: function ( theta ) {

        var c = Math.cos( theta ), s = Math.sin( theta );

        this.set(

            1, 0,  0, 0,
            0, c, - s, 0,
            0, s,  c, 0,
            0, 0,  0, 1

        );

        return this;

    },

    makeRotationY: function ( theta ) {

        var c = Math.cos( theta ), s = Math.sin( theta );

        this.set(

            c, 0, s, 0,
            0, 1, 0, 0,
            - s, 0, c, 0,
            0, 0, 0, 1

        );

        return this;

    },

    makeRotationZ: function ( theta ) {

        var c = Math.cos( theta ), s = Math.sin( theta );

        this.set(

            c, - s, 0, 0,
            s,  c, 0, 0,
            0,  0, 1, 0,
            0,  0, 0, 1

        );

        return this;

    },

    makeRotationAxis: function ( axis, angle ) {

        // Based on http://www.gamedev.net/reference/articles/article1199.asp

        var c = Math.cos( angle );
        var s = Math.sin( angle );
        var t = 1 - c;
        var x = axis.x, y = axis.y, z = axis.z;
        var tx = t * x, ty = t * y;

        this.set(

            tx * x + c, tx * y - s * z, tx * z + s * y, 0,
            tx * y + s * z, ty * y + c, ty * z - s * x, 0,
            tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
            0, 0, 0, 1

        );

        return this;

    },

    makeScale: function ( x, y, z ) {

        this.set(

            x, 0, 0, 0,
            0, y, 0, 0,
            0, 0, z, 0,
            0, 0, 0, 1

        );

        return this;

    },

    compose: function ( position, quaternion, scale ) {

        this.makeRotationFromQuaternion( quaternion );
        this.scale( scale );
        this.setPosition( position );

        return this;

    },

    decompose: function () {

        var vector, matrix;

        return function ( position, quaternion, scale ) {

            if ( vector === undefined ) vector = new THREE.Vector3();
            if ( matrix === undefined ) matrix = new THREE.Matrix4();

            var te = this.elements;

            var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
            var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
            var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

            // if determine is negative, we need to invert one scale
            var det = this.determinant();
            if ( det < 0 ) {

                sx = - sx;

            }

            position.x = te[ 12 ];
            position.y = te[ 13 ];
            position.z = te[ 14 ];

            // scale the rotation part

            matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

            var invSX = 1 / sx;
            var invSY = 1 / sy;
            var invSZ = 1 / sz;

            matrix.elements[ 0 ] *= invSX;
            matrix.elements[ 1 ] *= invSX;
            matrix.elements[ 2 ] *= invSX;

            matrix.elements[ 4 ] *= invSY;
            matrix.elements[ 5 ] *= invSY;
            matrix.elements[ 6 ] *= invSY;

            matrix.elements[ 8 ] *= invSZ;
            matrix.elements[ 9 ] *= invSZ;
            matrix.elements[ 10 ] *= invSZ;

            quaternion.setFromRotationMatrix( matrix );

            scale.x = sx;
            scale.y = sy;
            scale.z = sz;

            return this;

        };

    }(),

    makeFrustum: function ( left, right, bottom, top, near, far ) {

        var te = this.elements;
        var x = 2 * near / ( right - left );
        var y = 2 * near / ( top - bottom );

        var a = ( right + left ) / ( right - left );
        var b = ( top + bottom ) / ( top - bottom );
        var c = - ( far + near ) / ( far - near );
        var d = - 2 * far * near / ( far - near );

        te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
        te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
        te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
        te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

        return this;

    },

    makePerspective: function ( fov, aspect, near, far ) {

        var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
        var ymin = - ymax;
        var xmin = ymin * aspect;
        var xmax = ymax * aspect;

        return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

    },

    makeOrthographic: function ( left, right, top, bottom, near, far ) {

        var te = this.elements;
        var w = right - left;
        var h = top - bottom;
        var p = far - near;

        var x = ( right + left ) / w;
        var y = ( top + bottom ) / h;
        var z = ( far + near ) / p;

        te[ 0 ] = 2 / w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
        te[ 1 ] = 0;	te[ 5 ] = 2 / h;	te[ 9 ] = 0;	te[ 13 ] = - y;
        te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 / p;	te[ 14 ] = - z;
        te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

        return this;

    },

    equals: function ( matrix ) {

        var te = this.elements;
        var me = matrix.elements;

        for ( var i = 0; i < 16; i ++ ) {

            if ( te[ i ] !== me[ i ] ) return false;

        }

        return true;

    },

    fromArray: function ( array ) {

        this.elements.set( array );

        return this;

    },

    toArray: function () {

        var te = this.elements;

        return [
            te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
            te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
            te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
            te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
        ];

    }

};

// File:src/math/Ray.js

/**
 * @author bhouston / http://clara.io
 */

THREE.Ray = function ( origin, direction ) {

    this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
    this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();

};

THREE.Ray.prototype = {

    constructor: THREE.Ray,

    set: function ( origin, direction ) {

        this.origin.copy( origin );
        this.direction.copy( direction );

        return this;

    },

    clone: function () {

        return new this.constructor().copy( this );

    },

    copy: function ( ray ) {

        this.origin.copy( ray.origin );
        this.direction.copy( ray.direction );

        return this;

    },

    at: function ( t, optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();

        return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

    },

    recast: function () {

        var v1 = new THREE.Vector3();

        return function ( t ) {

            this.origin.copy( this.at( t, v1 ) );

            return this;

        };

    }(),

    closestPointToPoint: function ( point, optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        result.subVectors( point, this.origin );
        var directionDistance = result.dot( this.direction );

        if ( directionDistance < 0 ) {

            return result.copy( this.origin );

        }

        return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

    },

    distanceToPoint: function ( point ) {

        return Math.sqrt( this.distanceSqToPoint( point ) );

    },

    distanceSqToPoint: function () {

        var v1 = new THREE.Vector3();

        return function ( point ) {

            var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

            // point behind the ray

            if ( directionDistance < 0 ) {

                return this.origin.distanceToSquared( point );

            }

            v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

            return v1.distanceToSquared( point );

        };

    }(),

    distanceSqToSegment: function () {

        var segCenter = new THREE.Vector3();
        var segDir = new THREE.Vector3();
        var diff = new THREE.Vector3();

        return function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

            // from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
            // It returns the min distance between the ray and the segment
            // defined by v0 and v1
            // It can also set two optional targets :
            // - The closest point on the ray
            // - The closest point on the segment

            segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
            segDir.copy( v1 ).sub( v0 ).normalize();
            diff.copy( this.origin ).sub( segCenter );

            var segExtent = v0.distanceTo( v1 ) * 0.5;
            var a01 = - this.direction.dot( segDir );
            var b0 = diff.dot( this.direction );
            var b1 = - diff.dot( segDir );
            var c = diff.lengthSq();
            var det = Math.abs( 1 - a01 * a01 );
            var s0, s1, sqrDist, extDet;

            if ( det > 0 ) {

                // The ray and segment are not parallel.

                s0 = a01 * b1 - b0;
                s1 = a01 * b0 - b1;
                extDet = segExtent * det;

                if ( s0 >= 0 ) {

                    if ( s1 >= - extDet ) {

                        if ( s1 <= extDet ) {

                            // region 0
                            // Minimum at interior points of ray and segment.

                            var invDet = 1 / det;
                            s0 *= invDet;
                            s1 *= invDet;
                            sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

                        } else {

                            // region 1

                            s1 = segExtent;
                            s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
                            sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

                        }

                    } else {

                        // region 5

                        s1 = - segExtent;
                        s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
                        sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

                    }

                } else {

                    if ( s1 <= - extDet ) {

                        // region 4

                        s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
                        s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
                        sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

                    } else if ( s1 <= extDet ) {

                        // region 3

                        s0 = 0;
                        s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
                        sqrDist = s1 * ( s1 + 2 * b1 ) + c;

                    } else {

                        // region 2

                        s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
                        s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
                        sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

                    }

                }

            } else {

                // Ray and segment are parallel.

                s1 = ( a01 > 0 ) ? - segExtent : segExtent;
                s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
                sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

            }

            if ( optionalPointOnRay ) {

                optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

            }

            if ( optionalPointOnSegment ) {

                optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

            }

            return sqrDist;

        };

    }(),


    isIntersectionSphere: function ( sphere ) {

        return this.distanceToPoint( sphere.center ) <= sphere.radius;

    },

    intersectSphere: function () {

        // from http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/

        var v1 = new THREE.Vector3();

        return function ( sphere, optionalTarget ) {

            v1.subVectors( sphere.center, this.origin );

            var tca = v1.dot( this.direction );

            var d2 = v1.dot( v1 ) - tca * tca;

            var radius2 = sphere.radius * sphere.radius;

            if ( d2 > radius2 ) return null;

            var thc = Math.sqrt( radius2 - d2 );

            // t0 = first intersect point - entrance on front of sphere
            var t0 = tca - thc;

            // t1 = second intersect point - exit point on back of sphere
            var t1 = tca + thc;

            // test to see if both t0 and t1 are behind the ray - if so, return null
            if ( t0 < 0 && t1 < 0 ) return null;

            // test to see if t0 is behind the ray:
            // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
            // in order to always return an intersect point that is in front of the ray.
            if ( t0 < 0 ) return this.at( t1, optionalTarget );

            // else t0 is in front of the ray, so return the first collision point scaled by t0
            return this.at( t0, optionalTarget );

        }

    }(),

    isIntersectionPlane: function ( plane ) {

        // check if the ray lies on the plane first

        var distToPoint = plane.distanceToPoint( this.origin );

        if ( distToPoint === 0 ) {

            return true;

        }

        var denominator = plane.normal.dot( this.direction );

        if ( denominator * distToPoint < 0 ) {

            return true;

        }

        // ray origin is behind the plane (and is pointing behind it)

        return false;

    },

    distanceToPlane: function ( plane ) {

        var denominator = plane.normal.dot( this.direction );
        if ( denominator === 0 ) {

            // line is coplanar, return origin
            if ( plane.distanceToPoint( this.origin ) === 0 ) {

                return 0;

            }

            // Null is preferable to undefined since undefined means.... it is undefined

            return null;

        }

        var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

        // Return if the ray never intersects the plane

        return t >= 0 ? t :  null;

    },

    intersectPlane: function ( plane, optionalTarget ) {

        var t = this.distanceToPlane( plane );

        if ( t === null ) {

            return null;

        }

        return this.at( t, optionalTarget );

    },

    isIntersectionBox: function () {

        var v = new THREE.Vector3();

        return function ( box ) {

            return this.intersectBox( box, v ) !== null;

        };

    }(),

    intersectBox: function ( box, optionalTarget ) {

        // http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/

        var tmin, tmax, tymin, tymax, tzmin, tzmax;

        var invdirx = 1 / this.direction.x,
            invdiry = 1 / this.direction.y,
            invdirz = 1 / this.direction.z;

        var origin = this.origin;

        if ( invdirx >= 0 ) {

            tmin = ( box.min.x - origin.x ) * invdirx;
            tmax = ( box.max.x - origin.x ) * invdirx;

        } else {

            tmin = ( box.max.x - origin.x ) * invdirx;
            tmax = ( box.min.x - origin.x ) * invdirx;

        }

        if ( invdiry >= 0 ) {

            tymin = ( box.min.y - origin.y ) * invdiry;
            tymax = ( box.max.y - origin.y ) * invdiry;

        } else {

            tymin = ( box.max.y - origin.y ) * invdiry;
            tymax = ( box.min.y - origin.y ) * invdiry;

        }

        if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

        // These lines also handle the case where tmin or tmax is NaN
        // (result of 0 * Infinity). x !== x returns true if x is NaN

        if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

        if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

        if ( invdirz >= 0 ) {

            tzmin = ( box.min.z - origin.z ) * invdirz;
            tzmax = ( box.max.z - origin.z ) * invdirz;

        } else {

            tzmin = ( box.max.z - origin.z ) * invdirz;
            tzmax = ( box.min.z - origin.z ) * invdirz;

        }

        if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

        if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

        if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

        //return point closest to the ray (positive side)

        if ( tmax < 0 ) return null;

        return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

    },

    intersectTriangle: function () {

        // Compute the offset origin, edges, and normal.
        var diff = new THREE.Vector3();
        var edge1 = new THREE.Vector3();
        var edge2 = new THREE.Vector3();
        var normal = new THREE.Vector3();

        return function ( a, b, c, backfaceCulling, optionalTarget ) {

            // from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp

            edge1.subVectors( b, a );
            edge2.subVectors( c, a );
            normal.crossVectors( edge1, edge2 );

            // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
            // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
            //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
            //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
            //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
            var DdN = this.direction.dot( normal );
            var sign;

            if ( DdN > 0 ) {

                if ( backfaceCulling ) return null;
                sign = 1;

            } else if ( DdN < 0 ) {

                sign = - 1;
                DdN = - DdN;

            } else {

                return null;

            }

            diff.subVectors( this.origin, a );
            var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

            // b1 < 0, no intersection
            if ( DdQxE2 < 0 ) {

                return null;

            }

            var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

            // b2 < 0, no intersection
            if ( DdE1xQ < 0 ) {

                return null;

            }

            // b1+b2 > 1, no intersection
            if ( DdQxE2 + DdE1xQ > DdN ) {

                return null;

            }

            // Line intersects triangle, check if ray does.
            var QdN = - sign * diff.dot( normal );

            // t < 0, no intersection
            if ( QdN < 0 ) {

                return null;

            }

            // Ray intersects triangle.
            return this.at( QdN / DdN, optionalTarget );

        };

    }(),

    applyMatrix4: function ( matrix4 ) {

        this.direction.add( this.origin ).applyMatrix4( matrix4 );
        this.origin.applyMatrix4( matrix4 );
        this.direction.sub( this.origin );
        this.direction.normalize();

        return this;

    },

    equals: function ( ray ) {

        return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

    }

};

// File:src/math/Sphere.js

/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Sphere = function ( center, radius ) {

    this.center = ( center !== undefined ) ? center : new THREE.Vector3();
    this.radius = ( radius !== undefined ) ? radius : 0;

};

THREE.Sphere.prototype = {

    constructor: THREE.Sphere,

    set: function ( center, radius ) {

        this.center.copy( center );
        this.radius = radius;

        return this;

    },

    setFromPoints: function () {

        var box = new THREE.Box3();

        return function ( points, optionalCenter ) {

            var center = this.center;

            if ( optionalCenter !== undefined ) {

                center.copy( optionalCenter );

            } else {

                box.setFromPoints( points ).center( center );

            }

            var maxRadiusSq = 0;

            for ( var i = 0, il = points.length; i < il; i ++ ) {

                maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

            }

            this.radius = Math.sqrt( maxRadiusSq );

            return this;

        };

    }(),

    clone: function () {

        return new this.constructor().copy( this );

    },

    copy: function ( sphere ) {

        this.center.copy( sphere.center );
        this.radius = sphere.radius;

        return this;

    },

    empty: function () {

        return ( this.radius <= 0 );

    },

    containsPoint: function ( point ) {

        return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

    },

    distanceToPoint: function ( point ) {

        return ( point.distanceTo( this.center ) - this.radius );

    },

    intersectsSphere: function ( sphere ) {

        var radiusSum = this.radius + sphere.radius;

        return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

    },

    clampPoint: function ( point, optionalTarget ) {

        var deltaLengthSq = this.center.distanceToSquared( point );

        var result = optionalTarget || new THREE.Vector3();
        result.copy( point );

        if ( deltaLengthSq > ( this.radius * this.radius ) ) {

            result.sub( this.center ).normalize();
            result.multiplyScalar( this.radius ).add( this.center );

        }

        return result;

    },

    getBoundingBox: function ( optionalTarget ) {

        var box = optionalTarget || new THREE.Box3();

        box.set( this.center, this.center );
        box.expandByScalar( this.radius );

        return box;

    },

    applyMatrix4: function ( matrix ) {

        this.center.applyMatrix4( matrix );
        this.radius = this.radius * matrix.getMaxScaleOnAxis();

        return this;

    },

    translate: function ( offset ) {

        this.center.add( offset );

        return this;

    },

    equals: function ( sphere ) {

        return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

    }

};

// File:src/math/Frustum.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://clara.io
 */

THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {

    this.planes = [

        ( p0 !== undefined ) ? p0 : new THREE.Plane(),
        ( p1 !== undefined ) ? p1 : new THREE.Plane(),
        ( p2 !== undefined ) ? p2 : new THREE.Plane(),
        ( p3 !== undefined ) ? p3 : new THREE.Plane(),
        ( p4 !== undefined ) ? p4 : new THREE.Plane(),
        ( p5 !== undefined ) ? p5 : new THREE.Plane()

    ];

};

THREE.Frustum.prototype = {

    constructor: THREE.Frustum,

    set: function ( p0, p1, p2, p3, p4, p5 ) {

        var planes = this.planes;

        planes[ 0 ].copy( p0 );
        planes[ 1 ].copy( p1 );
        planes[ 2 ].copy( p2 );
        planes[ 3 ].copy( p3 );
        planes[ 4 ].copy( p4 );
        planes[ 5 ].copy( p5 );

        return this;

    },

    clone: function () {

        return new this.constructor().copy( this );

    },

    copy: function ( frustum ) {

        var planes = this.planes;

        for ( var i = 0; i < 6; i ++ ) {

            planes[ i ].copy( frustum.planes[ i ] );

        }

        return this;

    },

    setFromMatrix: function ( m ) {

        var planes = this.planes;
        var me = m.elements;
        var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
        var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
        var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
        var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

        planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
        planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
        planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
        planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
        planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
        planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

        return this;

    },

    intersectsObject: function () {

        var sphere = new THREE.Sphere();

        return function ( object ) {

            var geometry = object.geometry;

            if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

            sphere.copy( geometry.boundingSphere );
            sphere.applyMatrix4( object.matrixWorld );

            return this.intersectsSphere( sphere );

        };

    }(),

    intersectsSphere: function ( sphere ) {

        var planes = this.planes;
        var center = sphere.center;
        var negRadius = - sphere.radius;

        for ( var i = 0; i < 6; i ++ ) {

            var distance = planes[ i ].distanceToPoint( center );

            if ( distance < negRadius ) {

                return false;

            }

        }

        return true;

    },

    intersectsBox: function () {

        var p1 = new THREE.Vector3(),
            p2 = new THREE.Vector3();

        return function ( box ) {

            var planes = this.planes;

            for ( var i = 0; i < 6 ; i ++ ) {

                var plane = planes[ i ];

                p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
                p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
                p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
                p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
                p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
                p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

                var d1 = plane.distanceToPoint( p1 );
                var d2 = plane.distanceToPoint( p2 );

                // if both outside plane, no intersection

                if ( d1 < 0 && d2 < 0 ) {

                    return false;

                }

            }

            return true;

        };

    }(),


    containsPoint: function ( point ) {

        var planes = this.planes;

        for ( var i = 0; i < 6; i ++ ) {

            if ( planes[ i ].distanceToPoint( point ) < 0 ) {

                return false;

            }

        }

        return true;

    }

};

// File:src/math/Plane.js

/**
 * @author bhouston / http://clara.io
 */

THREE.Plane = function ( normal, constant ) {

    this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
    this.constant = ( constant !== undefined ) ? constant : 0;

};

THREE.Plane.prototype = {

    constructor: THREE.Plane,

    set: function ( normal, constant ) {

        this.normal.copy( normal );
        this.constant = constant;

        return this;

    },

    setComponents: function ( x, y, z, w ) {

        this.normal.set( x, y, z );
        this.constant = w;

        return this;

    },

    setFromNormalAndCoplanarPoint: function ( normal, point ) {

        this.normal.copy( normal );
        this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized

        return this;

    },

    setFromCoplanarPoints: function () {

        var v1 = new THREE.Vector3();
        var v2 = new THREE.Vector3();

        return function ( a, b, c ) {

            var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

            // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

            this.setFromNormalAndCoplanarPoint( normal, a );

            return this;

        };

    }(),

    clone: function () {

        return new this.constructor().copy( this );

    },

    copy: function ( plane ) {

        this.normal.copy( plane.normal );
        this.constant = plane.constant;

        return this;

    },

    normalize: function () {

        // Note: will lead to a divide by zero if the plane is invalid.

        var inverseNormalLength = 1.0 / this.normal.length();
        this.normal.multiplyScalar( inverseNormalLength );
        this.constant *= inverseNormalLength;

        return this;

    },

    negate: function () {

        this.constant *= - 1;
        this.normal.negate();

        return this;

    },

    distanceToPoint: function ( point ) {

        return this.normal.dot( point ) + this.constant;

    },

    distanceToSphere: function ( sphere ) {

        return this.distanceToPoint( sphere.center ) - sphere.radius;

    },

    projectPoint: function ( point, optionalTarget ) {

        return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

    },

    orthoPoint: function ( point, optionalTarget ) {

        var perpendicularMagnitude = this.distanceToPoint( point );

        var result = optionalTarget || new THREE.Vector3();
        return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

    },

    isIntersectionLine: function ( line ) {

        // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

        var startSign = this.distanceToPoint( line.start );
        var endSign = this.distanceToPoint( line.end );

        return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

    },

    intersectLine: function () {

        var v1 = new THREE.Vector3();

        return function ( line, optionalTarget ) {

            var result = optionalTarget || new THREE.Vector3();

            var direction = line.delta( v1 );

            var denominator = this.normal.dot( direction );

            if ( denominator === 0 ) {

                // line is coplanar, return origin
                if ( this.distanceToPoint( line.start ) === 0 ) {

                    return result.copy( line.start );

                }

                // Unsure if this is the correct method to handle this case.
                return undefined;

            }

            var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

            if ( t < 0 || t > 1 ) {

                return undefined;

            }

            return result.copy( direction ).multiplyScalar( t ).add( line.start );

        };

    }(),


    coplanarPoint: function ( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.copy( this.normal ).multiplyScalar( - this.constant );

    },

    applyMatrix4: function () {

        var v1 = new THREE.Vector3();
        var v2 = new THREE.Vector3();
        var m1 = new THREE.Matrix3();

        return function ( matrix, optionalNormalMatrix ) {

            // compute new normal based on theory here:
            // http://www.songho.ca/opengl/gl_normaltransform.html
            var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
            var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );

            var newCoplanarPoint = this.coplanarPoint( v2 );
            newCoplanarPoint.applyMatrix4( matrix );

            this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );

            return this;

        };

    }(),

    translate: function ( offset ) {

        this.constant = this.constant - offset.dot( this.normal );

        return this;

    },

    equals: function ( plane ) {

        return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

    }

};

// File:src/math/Math.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Math = {

    generateUUID: function () {

        // http://www.broofa.com/Tools/Math.uuid.htm

        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
        var uuid = new Array( 36 );
        var rnd = 0, r;

        return function () {

            for ( var i = 0; i < 36; i ++ ) {

                if ( i === 8 || i === 13 || i === 18 || i === 23 ) {

                    uuid[ i ] = '-';

                } else if ( i === 14 ) {

                    uuid[ i ] = '4';

                } else {

                    if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
                    r = rnd & 0xf;
                    rnd = rnd >> 4;
                    uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];

                }

            }

            return uuid.join( '' );

        };

    }(),

    clamp: function ( value, min, max ) {

        return Math.max( min, Math.min( max, value ) );

    },

    // compute euclidian modulo of m % n
    // https://en.wikipedia.org/wiki/Modulo_operation

    euclideanModulo: function ( n, m ) {

        return ( ( n % m ) + m ) % m;

    },

    // Linear mapping from range <a1, a2> to range <b1, b2>

    mapLinear: function ( x, a1, a2, b1, b2 ) {

        return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

    },

    // http://en.wikipedia.org/wiki/Smoothstep

    smoothstep: function ( x, min, max ) {

        if ( x <= min ) return 0;
        if ( x >= max ) return 1;

        x = ( x - min ) / ( max - min );

        return x * x * ( 3 - 2 * x );

    },

    smootherstep: function ( x, min, max ) {

        if ( x <= min ) return 0;
        if ( x >= max ) return 1;

        x = ( x - min ) / ( max - min );

        return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

    },

    // Random float from <0, 1> with 16 bits of randomness
    // (standard Math.random() creates repetitive patterns when applied over larger space)

    random16: function () {

        return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;

    },

    // Random integer from <low, high> interval

    randInt: function ( low, high ) {

        return low + Math.floor( Math.random() * ( high - low + 1 ) );

    },

    // Random float from <low, high> interval

    randFloat: function ( low, high ) {

        return low + Math.random() * ( high - low );

    },

    // Random float from <-range/2, range/2> interval

    randFloatSpread: function ( range ) {

        return range * ( 0.5 - Math.random() );

    },

    degToRad: function () {

        var degreeToRadiansFactor = Math.PI / 180;

        return function ( degrees ) {

            return degrees * degreeToRadiansFactor;

        };

    }(),

    radToDeg: function () {

        var radianToDegreesFactor = 180 / Math.PI;

        return function ( radians ) {

            return radians * radianToDegreesFactor;

        };

    }(),

    isPowerOfTwo: function ( value ) {

        return ( value & ( value - 1 ) ) === 0 && value !== 0;

    },

    nearestPowerOfTwo: function ( value ) {

        return Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );

    },

    nextPowerOfTwo: function ( value ) {

        value --;
        value |= value >> 1;
        value |= value >> 2;
        value |= value >> 4;
        value |= value >> 8;
        value |= value >> 16;
        value ++;

        return value;

    }

};

// File:src/math/Spline.js

/**
 * Spline from Tween.js, slightly optimized (and trashed)
 * http://sole.github.com/tween.js/examples/05_spline.html
 *
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Spline = function ( points ) {

    this.points = points;

    var c = [], v3 = { x: 0, y: 0, z: 0 },
        point, intPoint, weight, w2, w3,
        pa, pb, pc, pd;

    this.initFromArray = function ( a ) {

        this.points = [];

        for ( var i = 0; i < a.length; i ++ ) {

            this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

        }

    };

    this.getPoint = function ( k ) {

        point = ( this.points.length - 1 ) * k;
        intPoint = Math.floor( point );
        weight = point - intPoint;

        c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
        c[ 1 ] = intPoint;
        c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
        c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

        pa = this.points[ c[ 0 ] ];
        pb = this.points[ c[ 1 ] ];
        pc = this.points[ c[ 2 ] ];
        pd = this.points[ c[ 3 ] ];

        w2 = weight * weight;
        w3 = weight * w2;

        v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
        v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
        v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

        return v3;

    };

    this.getControlPointsArray = function () {

        var i, p, l = this.points.length,
            coords = [];

        for ( i = 0; i < l; i ++ ) {

            p = this.points[ i ];
            coords[ i ] = [ p.x, p.y, p.z ];

        }

        return coords;

    };

    // approximate length by summing linear segments

    this.getLength = function ( nSubDivisions ) {

        var i, index, nSamples, position,
            point = 0, intPoint = 0, oldIntPoint = 0,
            oldPosition = new THREE.Vector3(),
            tmpVec = new THREE.Vector3(),
            chunkLengths = [],
            totalLength = 0;

        // first point has 0 length

        chunkLengths[ 0 ] = 0;

        if ( ! nSubDivisions ) nSubDivisions = 100;

        nSamples = this.points.length * nSubDivisions;

        oldPosition.copy( this.points[ 0 ] );

        for ( i = 1; i < nSamples; i ++ ) {

            index = i / nSamples;

            position = this.getPoint( index );
            tmpVec.copy( position );

            totalLength += tmpVec.distanceTo( oldPosition );

            oldPosition.copy( position );

            point = ( this.points.length - 1 ) * index;
            intPoint = Math.floor( point );

            if ( intPoint !== oldIntPoint ) {

                chunkLengths[ intPoint ] = totalLength;
                oldIntPoint = intPoint;

            }

        }

        // last point ends with total length

        chunkLengths[ chunkLengths.length ] = totalLength;

        return { chunks: chunkLengths, total: totalLength };

    };

    this.reparametrizeByArcLength = function ( samplingCoef ) {

        var i, j,
            index, indexCurrent, indexNext,
            realDistance,
            sampling, position,
            newpoints = [],
            tmpVec = new THREE.Vector3(),
            sl = this.getLength();

        newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

        for ( i = 1; i < this.points.length; i ++ ) {

            //tmpVec.copy( this.points[ i - 1 ] );
            //linearDistance = tmpVec.distanceTo( this.points[ i ] );

            realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

            sampling = Math.ceil( samplingCoef * realDistance / sl.total );

            indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
            indexNext = i / ( this.points.length - 1 );

            for ( j = 1; j < sampling - 1; j ++ ) {

                index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

                position = this.getPoint( index );
                newpoints.push( tmpVec.copy( position ).clone() );

            }

            newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

        }

        this.points = newpoints;

    };

    // Catmull-Rom

    function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

        var v0 = ( p2 - p0 ) * 0.5,
            v1 = ( p3 - p1 ) * 0.5;

        return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

    }

};

// File:src/math/Triangle.js

/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Triangle = function ( a, b, c ) {

    this.a = ( a !== undefined ) ? a : new THREE.Vector3();
    this.b = ( b !== undefined ) ? b : new THREE.Vector3();
    this.c = ( c !== undefined ) ? c : new THREE.Vector3();

};

THREE.Triangle.normal = function () {

    var v0 = new THREE.Vector3();

    return function ( a, b, c, optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();

        result.subVectors( c, b );
        v0.subVectors( a, b );
        result.cross( v0 );

        var resultLengthSq = result.lengthSq();
        if ( resultLengthSq > 0 ) {

            return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

        }

        return result.set( 0, 0, 0 );

    };

}();

// static/instance method to calculate barycentric coordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
THREE.Triangle.barycoordFromPoint = function () {

    var v0 = new THREE.Vector3();
    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();

    return function ( point, a, b, c, optionalTarget ) {

        v0.subVectors( c, a );
        v1.subVectors( b, a );
        v2.subVectors( point, a );

        var dot00 = v0.dot( v0 );
        var dot01 = v0.dot( v1 );
        var dot02 = v0.dot( v2 );
        var dot11 = v1.dot( v1 );
        var dot12 = v1.dot( v2 );

        var denom = ( dot00 * dot11 - dot01 * dot01 );

        var result = optionalTarget || new THREE.Vector3();

        // collinear or singular triangle
        if ( denom === 0 ) {

            // arbitrary location outside of triangle?
            // not sure if this is the best idea, maybe should be returning undefined
            return result.set( - 2, - 1, - 1 );

        }

        var invDenom = 1 / denom;
        var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
        var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

        // barycentric coordinates must always sum to 1
        return result.set( 1 - u - v, v, u );

    };

}();

THREE.Triangle.containsPoint = function () {

    var v1 = new THREE.Vector3();

    return function ( point, a, b, c ) {

        var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );

        return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

    };

}();

THREE.Triangle.prototype = {

    constructor: THREE.Triangle,

    set: function ( a, b, c ) {

        this.a.copy( a );
        this.b.copy( b );
        this.c.copy( c );

        return this;

    },

    setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

        this.a.copy( points[ i0 ] );
        this.b.copy( points[ i1 ] );
        this.c.copy( points[ i2 ] );

        return this;

    },

    clone: function () {

        return new this.constructor().copy( this );

    },

    copy: function ( triangle ) {

        this.a.copy( triangle.a );
        this.b.copy( triangle.b );
        this.c.copy( triangle.c );

        return this;

    },

    area: function () {

        var v0 = new THREE.Vector3();
        var v1 = new THREE.Vector3();

        return function () {

            v0.subVectors( this.c, this.b );
            v1.subVectors( this.a, this.b );

            return v0.cross( v1 ).length() * 0.5;

        };

    }(),

    midpoint: function ( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

    },

    normal: function ( optionalTarget ) {

        return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );

    },

    plane: function ( optionalTarget ) {

        var result = optionalTarget || new THREE.Plane();

        return result.setFromCoplanarPoints( this.a, this.b, this.c );

    },

    barycoordFromPoint: function ( point, optionalTarget ) {

        return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

    },

    containsPoint: function ( point ) {

        return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );

    },

    equals: function ( triangle ) {

        return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

    }

};

// File:src/core/Channels.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Channels = function () {

    this.mask = 1;

};

THREE.Channels.prototype = {

    constructor: THREE.Channels,

    set: function ( channel ) {

        this.mask = 1 << channel;

    },

    enable: function ( channel ) {

        this.mask |= 1 << channel;

    },

    toggle: function ( channel ) {

        this.mask ^= 1 << channel;

    },

    disable: function ( channel ) {

        this.mask &= ~ ( 1 << channel );

    }

};

// File:src/core/Clock.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Clock = function ( autoStart ) {

    this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;

    this.running = false;

};

THREE.Clock.prototype = {

    constructor: THREE.Clock,

    start: function () {

        this.startTime = self.performance.now();

        this.oldTime = this.startTime;
        this.running = true;

    },

    stop: function () {

        this.getElapsedTime();
        this.running = false;

    },

    getElapsedTime: function () {

        this.getDelta();
        return this.elapsedTime;

    },

    getDelta: function () {

        var diff = 0;

        if ( this.autoStart && ! this.running ) {

            this.start();

        }

        if ( this.running ) {

            var newTime = self.performance.now();

            diff = 0.001 * ( newTime - this.oldTime );
            this.oldTime = newTime;

            this.elapsedTime += diff;

        }

        return diff;

    }

};

// File:src/core/EventDispatcher.js

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

THREE.EventDispatcher = function () {};

THREE.EventDispatcher.prototype = {

    constructor: THREE.EventDispatcher,

    apply: function ( object ) {

        object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
        object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
        object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
        object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;

    },

    addEventListener: function ( type, listener ) {

        if ( this._listeners === undefined ) this._listeners = {};

        var listeners = this._listeners;

        if ( listeners[ type ] === undefined ) {

            listeners[ type ] = [];

        }

        if ( listeners[ type ].indexOf( listener ) === - 1 ) {

            listeners[ type ].push( listener );

        }

    },

    hasEventListener: function ( type, listener ) {

        if ( this._listeners === undefined ) return false;

        var listeners = this._listeners;

        if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

            return true;

        }

        return false;

    },

    removeEventListener: function ( type, listener ) {

        if ( this._listeners === undefined ) return;

        var listeners = this._listeners;
        var listenerArray = listeners[ type ];

        if ( listenerArray !== undefined ) {

            var index = listenerArray.indexOf( listener );

            if ( index !== - 1 ) {

                listenerArray.splice( index, 1 );

            }

        }

    },

    dispatchEvent: function ( event ) {

        if ( this._listeners === undefined ) return;

        var listeners = this._listeners;
        var listenerArray = listeners[ event.type ];

        if ( listenerArray !== undefined ) {

            event.target = this;

            var array = [];
            var length = listenerArray.length;

            for ( var i = 0; i < length; i ++ ) {

                array[ i ] = listenerArray[ i ];

            }

            for ( var i = 0; i < length; i ++ ) {

                array[ i ].call( this, event );

            }

        }

    }

};

// File:src/core/Raycaster.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://clara.io/
 * @author stephomi / http://stephaneginier.com/
 */

( function ( THREE ) {

    THREE.Raycaster = function ( origin, direction, near, far ) {

        this.ray = new THREE.Ray( origin, direction );
        // direction is assumed to be normalized (for accurate distance calculations)

        this.near = near || 0;
        this.far = far || Infinity;

        this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: { threshold: 1 },
            Sprite: {}
        };

        Object.defineProperties( this.params, {
            PointCloud: {
                get: function () {
                    console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
                    return this.Points;
                }
            }
        } );

    };

    function descSort( a, b ) {

        return a.distance - b.distance;

    }

    function intersectObject( object, raycaster, intersects, recursive ) {

        if ( object.visible === false ) return;

        object.raycast( raycaster, intersects );

        if ( recursive === true ) {

            var children = object.children;

            for ( var i = 0, l = children.length; i < l; i ++ ) {

                intersectObject( children[ i ], raycaster, intersects, true );

            }

        }

    }

    //

    THREE.Raycaster.prototype = {

        constructor: THREE.Raycaster,

        linePrecision: 1,

        set: function ( origin, direction ) {

            // direction is assumed to be normalized (for accurate distance calculations)

            this.ray.set( origin, direction );

        },

        setFromCamera: function ( coords, camera ) {

            if ( camera instanceof THREE.PerspectiveCamera ) {

                this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
                this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

            } else if ( camera instanceof THREE.OrthographicCamera ) {

                this.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );
                this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

            } else {

                console.error( 'THREE.Raycaster: Unsupported camera type.' );

            }

        },

        intersectObject: function ( object, recursive ) {

            var intersects = [];

            intersectObject( object, this, intersects, recursive );

            intersects.sort( descSort );

            return intersects;

        },

        intersectObjects: function ( objects, recursive ) {

            var intersects = [];

            if ( Array.isArray( objects ) === false ) {

                console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
                return intersects;

            }

            for ( var i = 0, l = objects.length; i < l; i ++ ) {

                intersectObject( objects[ i ], this, intersects, recursive );

            }

            intersects.sort( descSort );

            return intersects;

        }

    };

}( THREE ) );

// File:src/core/Object3D.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author elephantatwork / www.elephantatwork.ch
 */

THREE.Object3D = function () {

    Object.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );

    this.uuid = THREE.Math.generateUUID();

    this.name = '';
    this.type = 'Object3D';

    this.parent = null;
    this.channels = new THREE.Channels();
    this.children = [];

    this.up = THREE.Object3D.DefaultUp.clone();

    var position = new THREE.Vector3();
    var rotation = new THREE.Euler();
    var quaternion = new THREE.Quaternion();
    var scale = new THREE.Vector3( 1, 1, 1 );

    function onRotationChange() {

        quaternion.setFromEuler( rotation, false );

    }

    function onQuaternionChange() {

        rotation.setFromQuaternion( quaternion, undefined, false );

    }

    rotation.onChange( onRotationChange );
    quaternion.onChange( onQuaternionChange );

    Object.defineProperties( this, {
        position: {
            enumerable: true,
            value: position
        },
        rotation: {
            enumerable: true,
            value: rotation
        },
        quaternion: {
            enumerable: true,
            value: quaternion
        },
        scale: {
            enumerable: true,
            value: scale
        },
        modelViewMatrix: {
            value: new THREE.Matrix4()
        },
        normalMatrix: {
            value: new THREE.Matrix3()
        }
    } );

    this.rotationAutoUpdate = true;

    this.matrix = new THREE.Matrix4();
    this.matrixWorld = new THREE.Matrix4();

    this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = false;

    this.visible = true;

    this.castShadow = false;
    this.receiveShadow = false;

    this.frustumCulled = true;
    this.renderOrder = 0;

    this.userData = {};

};

THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );
THREE.Object3D.DefaultMatrixAutoUpdate = true;

THREE.Object3D.prototype = {

    constructor: THREE.Object3D,

    get eulerOrder () {

        console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );

        return this.rotation.order;

    },

    set eulerOrder ( value ) {

        console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );

        this.rotation.order = value;

    },

    get useQuaternion () {

        console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

    },

    set useQuaternion ( value ) {

        console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

    },

    set renderDepth ( value ) {

        console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

    },

    //

    applyMatrix: function ( matrix ) {

        this.matrix.multiplyMatrices( matrix, this.matrix );

        this.matrix.decompose( this.position, this.quaternion, this.scale );

    },

    setRotationFromAxisAngle: function ( axis, angle ) {

        // assumes axis is normalized

        this.quaternion.setFromAxisAngle( axis, angle );

    },

    setRotationFromEuler: function ( euler ) {

        this.quaternion.setFromEuler( euler, true );

    },

    setRotationFromMatrix: function ( m ) {

        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

        this.quaternion.setFromRotationMatrix( m );

    },

    setRotationFromQuaternion: function ( q ) {

        // assumes q is normalized

        this.quaternion.copy( q );

    },

    rotateOnAxis: function () {

        // rotate object on axis in object space
        // axis is assumed to be normalized

        var q1 = new THREE.Quaternion();

        return function ( axis, angle ) {

            q1.setFromAxisAngle( axis, angle );

            this.quaternion.multiply( q1 );

            return this;

        };

    }(),

    rotateX: function () {

        var v1 = new THREE.Vector3( 1, 0, 0 );

        return function ( angle ) {

            return this.rotateOnAxis( v1, angle );

        };

    }(),

    rotateY: function () {

        var v1 = new THREE.Vector3( 0, 1, 0 );

        return function ( angle ) {

            return this.rotateOnAxis( v1, angle );

        };

    }(),

    rotateZ: function () {

        var v1 = new THREE.Vector3( 0, 0, 1 );

        return function ( angle ) {

            return this.rotateOnAxis( v1, angle );

        };

    }(),

    translateOnAxis: function () {

        // translate object by distance along axis in object space
        // axis is assumed to be normalized

        var v1 = new THREE.Vector3();

        return function ( axis, distance ) {

            v1.copy( axis ).applyQuaternion( this.quaternion );

            this.position.add( v1.multiplyScalar( distance ) );

            return this;

        };

    }(),

    translate: function ( distance, axis ) {

        console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
        return this.translateOnAxis( axis, distance );

    },

    translateX: function () {

        var v1 = new THREE.Vector3( 1, 0, 0 );

        return function ( distance ) {

            return this.translateOnAxis( v1, distance );

        };

    }(),

    translateY: function () {

        var v1 = new THREE.Vector3( 0, 1, 0 );

        return function ( distance ) {

            return this.translateOnAxis( v1, distance );

        };

    }(),

    translateZ: function () {

        var v1 = new THREE.Vector3( 0, 0, 1 );

        return function ( distance ) {

            return this.translateOnAxis( v1, distance );

        };

    }(),

    localToWorld: function ( vector ) {

        return vector.applyMatrix4( this.matrixWorld );

    },

    worldToLocal: function () {

        var m1 = new THREE.Matrix4();

        return function ( vector ) {

            return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

        };

    }(),

    lookAt: function () {

        // This routine does not support objects with rotated and/or translated parent(s)

        var m1 = new THREE.Matrix4();

        return function ( vector ) {

            m1.lookAt( vector, this.position, this.up );

            this.quaternion.setFromRotationMatrix( m1 );

        };

    }(),

    add: function ( object ) {

        if ( arguments.length > 1 ) {

            for ( var i = 0; i < arguments.length; i ++ ) {

                this.add( arguments[ i ] );

            }

            return this;

        }

        if ( object === this ) {

            console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
            return this;

        }

        if ( object instanceof THREE.Object3D ) {

            if ( object.parent !== null ) {

                object.parent.remove( object );

            }

            object.parent = this;
            object.dispatchEvent( { type: 'added' } );

            this.children.push( object );

        } else {

            console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

        }

        return this;

    },

    remove: function ( object ) {

        if ( arguments.length > 1 ) {

            for ( var i = 0; i < arguments.length; i ++ ) {

                this.remove( arguments[ i ] );

            }

        }

        var index = this.children.indexOf( object );

        if ( index !== - 1 ) {

            object.parent = null;

            object.dispatchEvent( { type: 'removed' } );

            this.children.splice( index, 1 );

        }

    },

    getChildByName: function ( name ) {

        console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
        return this.getObjectByName( name );

    },

    getObjectById: function ( id ) {

        return this.getObjectByProperty( 'id', id );

    },

    getObjectByName: function ( name ) {

        return this.getObjectByProperty( 'name', name );

    },

    getObjectByProperty: function ( name, value ) {

        if ( this[ name ] === value ) return this;

        for ( var i = 0, l = this.children.length; i < l; i ++ ) {

            var child = this.children[ i ];
            var object = child.getObjectByProperty( name, value );

            if ( object !== undefined ) {

                return object;

            }

        }

        return undefined;

    },

    getWorldPosition: function ( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();

        this.updateMatrixWorld( true );

        return result.setFromMatrixPosition( this.matrixWorld );

    },

    getWorldQuaternion: function () {

        var position = new THREE.Vector3();
        var scale = new THREE.Vector3();

        return function ( optionalTarget ) {

            var result = optionalTarget || new THREE.Quaternion();

            this.updateMatrixWorld( true );

            this.matrixWorld.decompose( position, result, scale );

            return result;

        };

    }(),

    getWorldRotation: function () {

        var quaternion = new THREE.Quaternion();

        return function ( optionalTarget ) {

            var result = optionalTarget || new THREE.Euler();

            this.getWorldQuaternion( quaternion );

            return result.setFromQuaternion( quaternion, this.rotation.order, false );

        };

    }(),

    getWorldScale: function () {

        var position = new THREE.Vector3();
        var quaternion = new THREE.Quaternion();

        return function ( optionalTarget ) {

            var result = optionalTarget || new THREE.Vector3();

            this.updateMatrixWorld( true );

            this.matrixWorld.decompose( position, quaternion, result );

            return result;

        };

    }(),

    getWorldDirection: function () {

        var quaternion = new THREE.Quaternion();

        return function ( optionalTarget ) {

            var result = optionalTarget || new THREE.Vector3();

            this.getWorldQuaternion( quaternion );

            return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

        };

    }(),

    raycast: function () {},

    traverse: function ( callback ) {

        callback( this );

        var children = this.children;

        for ( var i = 0, l = children.length; i < l; i ++ ) {

            children[ i ].traverse( callback );

        }

    },

    traverseVisible: function ( callback ) {

        if ( this.visible === false ) return;

        callback( this );

        var children = this.children;

        for ( var i = 0, l = children.length; i < l; i ++ ) {

            children[ i ].traverseVisible( callback );

        }

    },

    traverseAncestors: function ( callback ) {

        var parent = this.parent;

        if ( parent !== null ) {

            callback( parent );

            parent.traverseAncestors( callback );

        }

    },

    updateMatrix: function () {

        this.matrix.compose( this.position, this.quaternion, this.scale );

        this.matrixWorldNeedsUpdate = true;

    },

    updateMatrixWorld: function ( force ) {

        if ( this.matrixAutoUpdate === true ) this.updateMatrix();

        if ( this.matrixWorldNeedsUpdate === true || force === true ) {

            if ( this.parent === null ) {

                this.matrixWorld.copy( this.matrix );

            } else {

                this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

            }

            this.matrixWorldNeedsUpdate = false;

            force = true;

        }

        // update children

        for ( var i = 0, l = this.children.length; i < l; i ++ ) {

            this.children[ i ].updateMatrixWorld( force );

        }

    },

    toJSON: function ( meta ) {

        var isRootObject = ( meta === undefined );

        var output = {};

        // meta is a hash used to collect geometries, materials.
        // not providing it implies that this is the root object
        // being serialized.
        if ( isRootObject ) {

            // initialize meta obj
            meta = {
                geometries: {},
                materials: {},
                textures: {},
                images: {}
            };

            output.metadata = {
                version: 4.4,
                type: 'Object',
                generator: 'Object3D.toJSON'
            };

        }

        // standard Object3D serialization

        var object = {};

        object.uuid = this.uuid;
        object.type = this.type;

        if ( this.name !== '' ) object.name = this.name;
        if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
        if ( this.castShadow === true ) object.castShadow = true;
        if ( this.receiveShadow === true ) object.receiveShadow = true;
        if ( this.visible === false ) object.visible = false;

        object.matrix = this.matrix.toArray();

        //

        if ( this.geometry !== undefined ) {

            if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

                meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );

            }

            object.geometry = this.geometry.uuid;

        }

        if ( this.material !== undefined ) {

            if ( meta.materials[ this.material.uuid ] === undefined ) {

                meta.materials[ this.material.uuid ] = this.material.toJSON( meta );

            }

            object.material = this.material.uuid;

        }

        //

        if ( this.children.length > 0 ) {

            object.children = [];

            for ( var i = 0; i < this.children.length; i ++ ) {

                object.children.push( this.children[ i ].toJSON( meta ).object );

            }

        }

        if ( isRootObject ) {

            var geometries = extractFromCache( meta.geometries );
            var materials = extractFromCache( meta.materials );
            var textures = extractFromCache( meta.textures );
            var images = extractFromCache( meta.images );

            if ( geometries.length > 0 ) output.geometries = geometries;
            if ( materials.length > 0 ) output.materials = materials;
            if ( textures.length > 0 ) output.textures = textures;
            if ( images.length > 0 ) output.images = images;

        }

        output.object = object;

        return output;

        // extract data from the cache hash
        // remove metadata on each item
        // and return as array
        function extractFromCache ( cache ) {

            var values = [];
            for ( var key in cache ) {

                var data = cache[ key ];
                delete data.metadata;
                values.push( data );

            }
            return values;

        }

    },

    clone: function ( recursive ) {

        return new this.constructor().copy( this, recursive );

    },

    copy: function ( source, recursive ) {

        if ( recursive === undefined ) recursive = true;

        this.name = source.name;

        this.up.copy( source.up );

        this.position.copy( source.position );
        this.quaternion.copy( source.quaternion );
        this.scale.copy( source.scale );

        this.rotationAutoUpdate = source.rotationAutoUpdate;

        this.matrix.copy( source.matrix );
        this.matrixWorld.copy( source.matrixWorld );

        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

        this.visible = source.visible;

        this.castShadow = source.castShadow;
        this.receiveShadow = source.receiveShadow;

        this.frustumCulled = source.frustumCulled;
        this.renderOrder = source.renderOrder;

        this.userData = JSON.parse( JSON.stringify( source.userData ) );

        if ( recursive === true ) {

            for ( var i = 0; i < source.children.length; i ++ ) {

                var child = source.children[ i ];
                this.add( child.clone() );

            }

        }

        return this;

    }

};

THREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );

THREE.Object3DIdCount = 0;

// File:src/core/Face3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {

    this.a = a;
    this.b = b;
    this.c = c;

    this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
    this.vertexNormals = Array.isArray( normal ) ? normal : [];

    this.color = color instanceof THREE.Color ? color : new THREE.Color();
    this.vertexColors = Array.isArray( color ) ? color : [];

    this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

};

THREE.Face3.prototype = {

    constructor: THREE.Face3,

    clone: function () {

        return new this.constructor().copy( this );

    },

    copy: function ( source ) {

        this.a = source.a;
        this.b = source.b;
        this.c = source.c;

        this.normal.copy( source.normal );
        this.color.copy( source.color );

        this.materialIndex = source.materialIndex;

        for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

            this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

        }

        for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

            this.vertexColors[ i ] = source.vertexColors[ i ].clone();

        }

        return this;

    }

};

// File:src/core/Face4.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {

    console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
    return new THREE.Face3( a, b, c, normal, color, materialIndex );

};

// File:src/core/BufferAttribute.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferAttribute = function ( array, itemSize ) {

    this.uuid = THREE.Math.generateUUID();

    this.array = array;
    this.itemSize = itemSize;

    this.dynamic = false;
    this.updateRange = { offset: 0, count: - 1 };

    this.version = 0;

};

THREE.BufferAttribute.prototype = {

    constructor: THREE.BufferAttribute,

    get length() {

        console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
        return this.array.length;

    },

    get count() {

        return this.array.length / this.itemSize;

    },

    set needsUpdate( value ) {

        if ( value === true ) this.version ++;

    },

    setDynamic: function ( value ) {

        this.dynamic = value;

        return this;

    },

    copy: function ( source ) {

        this.array = new source.array.constructor( source.array );
        this.itemSize = source.itemSize;

        this.dynamic = source.dynamic;

        return this;

    },

    copyAt: function ( index1, attribute, index2 ) {

        index1 *= this.itemSize;
        index2 *= attribute.itemSize;

        for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

            this.array[ index1 + i ] = attribute.array[ index2 + i ];

        }

        return this;

    },

    copyArray: function ( array ) {

        this.array.set( array );

        return this;

    },

    copyColorsArray: function ( colors ) {

        var array = this.array, offset = 0;

        for ( var i = 0, l = colors.length; i < l; i ++ ) {

            var color = colors[ i ];

            if ( color === undefined ) {

                console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
                color = new THREE.Color();

            }

            array[ offset ++ ] = color.r;
            array[ offset ++ ] = color.g;
            array[ offset ++ ] = color.b;

        }

        return this;

    },

    copyIndicesArray: function ( indices ) {

        var array = this.array, offset = 0;

        for ( var i = 0, l = indices.length; i < l; i ++ ) {

            var index = indices[ i ];

            array[ offset ++ ] = index.a;
            array[ offset ++ ] = index.b;
            array[ offset ++ ] = index.c;

        }

        return this;

    },

    copyVector2sArray: function ( vectors ) {

        var array = this.array, offset = 0;

        for ( var i = 0, l = vectors.length; i < l; i ++ ) {

            var vector = vectors[ i ];

            if ( vector === undefined ) {

                console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
                vector = new THREE.Vector2();

            }

            array[ offset ++ ] = vector.x;
            array[ offset ++ ] = vector.y;

        }

        return this;

    },

    copyVector3sArray: function ( vectors ) {

        var array = this.array, offset = 0;

        for ( var i = 0, l = vectors.length; i < l; i ++ ) {

            var vector = vectors[ i ];

            if ( vector === undefined ) {

                console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
                vector = new THREE.Vector3();

            }

            array[ offset ++ ] = vector.x;
            array[ offset ++ ] = vector.y;
            array[ offset ++ ] = vector.z;

        }

        return this;

    },

    copyVector4sArray: function ( vectors ) {

        var array = this.array, offset = 0;

        for ( var i = 0, l = vectors.length; i < l; i ++ ) {

            var vector = vectors[ i ];

            if ( vector === undefined ) {

                console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
                vector = new THREE.Vector4();

            }

            array[ offset ++ ] = vector.x;
            array[ offset ++ ] = vector.y;
            array[ offset ++ ] = vector.z;
            array[ offset ++ ] = vector.w;

        }

        return this;

    },

    set: function ( value, offset ) {

        if ( offset === undefined ) offset = 0;

        this.array.set( value, offset );

        return this;

    },

    getX: function ( index ) {

        return this.array[ index * this.itemSize ];

    },

    setX: function ( index, x ) {

        this.array[ index * this.itemSize ] = x;

        return this;

    },

    getY: function ( index ) {

        return this.array[ index * this.itemSize + 1 ];

    },

    setY: function ( index, y ) {

        this.array[ index * this.itemSize + 1 ] = y;

        return this;

    },

    getZ: function ( index ) {

        return this.array[ index * this.itemSize + 2 ];

    },

    setZ: function ( index, z ) {

        this.array[ index * this.itemSize + 2 ] = z;

        return this;

    },

    getW: function ( index ) {

        return this.array[ index * this.itemSize + 3 ];

    },

    setW: function ( index, w ) {

        this.array[ index * this.itemSize + 3 ] = w;

        return this;

    },

    setXY: function ( index, x, y ) {

        index *= this.itemSize;

        this.array[ index + 0 ] = x;
        this.array[ index + 1 ] = y;

        return this;

    },

    setXYZ: function ( index, x, y, z ) {

        index *= this.itemSize;

        this.array[ index + 0 ] = x;
        this.array[ index + 1 ] = y;
        this.array[ index + 2 ] = z;

        return this;

    },

    setXYZW: function ( index, x, y, z, w ) {

        index *= this.itemSize;

        this.array[ index + 0 ] = x;
        this.array[ index + 1 ] = y;
        this.array[ index + 2 ] = z;
        this.array[ index + 3 ] = w;

        return this;

    },

    clone: function () {

        return new this.constructor().copy( this );

    }

};

//

THREE.Int8Attribute = function ( array, itemSize ) {

    return new THREE.BufferAttribute( new Int8Array( array ), itemSize );

};

THREE.Uint8Attribute = function ( array, itemSize ) {

    return new THREE.BufferAttribute( new Uint8Array( array ), itemSize );

};

THREE.Uint8ClampedAttribute = function ( array, itemSize ) {

    return new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );

};

THREE.Int16Attribute = function ( array, itemSize ) {

    return new THREE.BufferAttribute( new Int16Array( array ), itemSize );

};

THREE.Uint16Attribute = function ( array, itemSize ) {

    return new THREE.BufferAttribute( new Uint16Array( array ), itemSize );

};

THREE.Int32Attribute = function ( array, itemSize ) {

    return new THREE.BufferAttribute( new Int32Array( array ), itemSize );

};

THREE.Uint32Attribute = function ( array, itemSize ) {

    return new THREE.BufferAttribute( new Uint32Array( array ), itemSize );

};

THREE.Float32Attribute = function ( array, itemSize ) {

    return new THREE.BufferAttribute( new Float32Array( array ), itemSize );

};

THREE.Float64Attribute = function ( array, itemSize ) {

    return new THREE.BufferAttribute( new Float64Array( array ), itemSize );

};


// Deprecated

THREE.DynamicBufferAttribute = function ( array, itemSize ) {

    console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
    return new THREE.BufferAttribute( array, itemSize ).setDynamic( true );

};

// File:src/core/InstancedBufferAttribute.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedBufferAttribute = function ( array, itemSize, meshPerAttribute ) {

    THREE.BufferAttribute.call( this, array, itemSize );

    this.meshPerAttribute = meshPerAttribute || 1;

};

THREE.InstancedBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );
THREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;

THREE.InstancedBufferAttribute.prototype.copy = function ( source ) {

    THREE.BufferAttribute.prototype.copy.call( this, source );

    this.meshPerAttribute = source.meshPerAttribute;

    return this;

};

// File:src/core/InterleavedBuffer.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InterleavedBuffer = function ( array, stride ) {

    this.uuid = THREE.Math.generateUUID();

    this.array = array;
    this.stride = stride;

    this.dynamic = false;
    this.updateRange = { offset: 0, count: - 1 };

    this.version = 0;

};

THREE.InterleavedBuffer.prototype = {

    constructor: THREE.InterleavedBuffer,

    get length () {

        return this.array.length;

    },

    get count () {

        return this.array.length / this.stride;

    },

    set needsUpdate( value ) {

        if ( value === true ) this.version ++;

    },

    setDynamic: function ( value ) {

        this.dynamic = value;

        return this;

    },

    copy: function ( source ) {

        this.array = new source.array.constructor( source.array );
        this.stride = source.stride;
        this.dynamic = source.dynamic;

    },

    copyAt: function ( index1, attribute, index2 ) {

        index1 *= this.stride;
        index2 *= attribute.stride;

        for ( var i = 0, l = this.stride; i < l; i ++ ) {

            this.array[ index1 + i ] = attribute.array[ index2 + i ];

        }

        return this;

    },

    set: function ( value, offset ) {

        if ( offset === undefined ) offset = 0;

        this.array.set( value, offset );

        return this;

    },

    clone: function () {

        return new this.constructor().copy( this );

    }

};

// File:src/core/InstancedInterleavedBuffer.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedInterleavedBuffer = function ( array, stride, meshPerAttribute ) {

    THREE.InterleavedBuffer.call( this, array, stride );

    this.meshPerAttribute = meshPerAttribute || 1;

};

THREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );
THREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;

THREE.InstancedInterleavedBuffer.prototype.copy = function ( source ) {

    THREE.InterleavedBuffer.prototype.copy.call( this, source );

    this.meshPerAttribute = source.meshPerAttribute;

    return this;

};

// File:src/core/InterleavedBufferAttribute.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset ) {

    this.uuid = THREE.Math.generateUUID();

    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;

};


THREE.InterleavedBufferAttribute.prototype = {

    constructor: THREE.InterleavedBufferAttribute,

    get length() {

        console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
        return this.array.length;

    },

    get count() {

        return this.data.array.length / this.data.stride;

    },

    setX: function ( index, x ) {

        this.data.array[ index * this.data.stride + this.offset ] = x;

        return this;

    },

    setY: function ( index, y ) {

        this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

        return this;

    },

    setZ: function ( index, z ) {

        this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

        return this;

    },

    setW: function ( index, w ) {

        this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

        return this;

    },

    getX: function ( index ) {

        return this.data.array[ index * this.data.stride + this.offset ];

    },

    getY: function ( index ) {

        return this.data.array[ index * this.data.stride + this.offset + 1 ];

    },

    getZ: function ( index ) {

        return this.data.array[ index * this.data.stride + this.offset + 2 ];

    },

    getW: function ( index ) {

        return this.data.array[ index * this.data.stride + this.offset + 3 ];

    },

    setXY: function ( index, x, y ) {

        index = index * this.data.stride + this.offset;

        this.data.array[ index + 0 ] = x;
        this.data.array[ index + 1 ] = y;

        return this;

    },

    setXYZ: function ( index, x, y, z ) {

        index = index * this.data.stride + this.offset;

        this.data.array[ index + 0 ] = x;
        this.data.array[ index + 1 ] = y;
        this.data.array[ index + 2 ] = z;

        return this;

    },

    setXYZW: function ( index, x, y, z, w ) {

        index = index * this.data.stride + this.offset;

        this.data.array[ index + 0 ] = x;
        this.data.array[ index + 1 ] = y;
        this.data.array[ index + 2 ] = z;
        this.data.array[ index + 3 ] = w;

        return this;

    }

};

// File:src/core/Geometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://clara.io
 */

THREE.Geometry = function () {

    Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

    this.uuid = THREE.Math.generateUUID();

    this.name = '';
    this.type = 'Geometry';

    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [ [] ];

    this.morphTargets = [];
    this.morphNormals = [];

    this.skinWeights = [];
    this.skinIndices = [];

    this.lineDistances = [];

    this.boundingBox = null;
    this.boundingSphere = null;

    // update flags

    this.verticesNeedUpdate = false;
    this.elementsNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.lineDistancesNeedUpdate = false;
    this.groupsNeedUpdate = false;

};

THREE.Geometry.prototype = {

    constructor: THREE.Geometry,

    applyMatrix: function ( matrix ) {

        var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

        for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

            var vertex = this.vertices[ i ];
            vertex.applyMatrix4( matrix );

        }

        for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

            var face = this.faces[ i ];
            face.normal.applyMatrix3( normalMatrix ).normalize();

            for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

                face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

            }

        }

        if ( this.boundingBox !== null ) {

            this.computeBoundingBox();

        }

        if ( this.boundingSphere !== null ) {

            this.computeBoundingSphere();

        }

        this.verticesNeedUpdate = true;
        this.normalsNeedUpdate = true;

    },

    rotateX: function () {

        // rotate geometry around world x-axis

        var m1;

        return function rotateX( angle ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeRotationX( angle );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    rotateY: function () {

        // rotate geometry around world y-axis

        var m1;

        return function rotateY( angle ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeRotationY( angle );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    rotateZ: function () {

        // rotate geometry around world z-axis

        var m1;

        return function rotateZ( angle ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeRotationZ( angle );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    translate: function () {

        // translate geometry

        var m1;

        return function translate( x, y, z ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeTranslation( x, y, z );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    scale: function () {

        // scale geometry

        var m1;

        return function scale( x, y, z ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeScale( x, y, z );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    lookAt: function () {

        var obj;

        return function lookAt( vector ) {

            if ( obj === undefined ) obj = new THREE.Object3D();

            obj.lookAt( vector );

            obj.updateMatrix();

            this.applyMatrix( obj.matrix );

        };

    }(),

    fromBufferGeometry: function ( geometry ) {

        var scope = this;

        var indices = geometry.index !== null ? geometry.index.array : undefined;
        var attributes = geometry.attributes;

        var vertices = attributes.position.array;
        var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
        var colors = attributes.color !== undefined ? attributes.color.array : undefined;
        var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
        var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

        if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

        var tempNormals = [];
        var tempUVs = [];
        var tempUVs2 = [];

        for ( var i = 0, j = 0, k = 0; i < vertices.length; i += 3, j += 2, k += 4 ) {

            scope.vertices.push( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

            if ( normals !== undefined ) {

                tempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

            }

            if ( colors !== undefined ) {

                scope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

            }

            if ( uvs !== undefined ) {

                tempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );

            }

            if ( uvs2 !== undefined ) {

                tempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );

            }

        }

        function addFace( a, b, c ) {

            var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
            var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

            var face = new THREE.Face3( a, b, c, vertexNormals, vertexColors );

            scope.faces.push( face );

            if ( uvs !== undefined ) {

                scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

            }

            if ( uvs2 !== undefined ) {

                scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );

            }

        };

        if ( indices !== undefined ) {

            var groups = geometry.groups;

            if ( groups.length > 0 ) {

                for ( var i = 0; i < groups.length; i ++ ) {

                    var group = groups[ i ];

                    var start = group.start;
                    var count = group.count;

                    for ( var j = start, jl = start + count; j < jl; j += 3 ) {

                        addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ] );

                    }

                }

            } else {

                for ( var i = 0; i < indices.length; i += 3 ) {

                    addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

                }

            }

        } else {

            for ( var i = 0; i < vertices.length / 3; i += 3 ) {

                addFace( i, i + 1, i + 2 );

            }

        }

        this.computeFaceNormals();

        if ( geometry.boundingBox !== null ) {

            this.boundingBox = geometry.boundingBox.clone();

        }

        if ( geometry.boundingSphere !== null ) {

            this.boundingSphere = geometry.boundingSphere.clone();

        }

        return this;

    },

    center: function () {

        this.computeBoundingBox();

        var offset = this.boundingBox.center().negate();

        this.translate( offset.x, offset.y, offset.z );

        return offset;

    },

    normalize: function () {

        this.computeBoundingSphere();

        var center = this.boundingSphere.center;
        var radius = this.boundingSphere.radius;

        var s = radius === 0 ? 1 : 1.0 / radius;

        var matrix = new THREE.Matrix4();
        matrix.set(
            s, 0, 0, - s * center.x,
            0, s, 0, - s * center.y,
            0, 0, s, - s * center.z,
            0, 0, 0, 1
        );

        this.applyMatrix( matrix );

        return this;

    },

    computeFaceNormals: function () {

        var cb = new THREE.Vector3(), ab = new THREE.Vector3();

        for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

            var face = this.faces[ f ];

            var vA = this.vertices[ face.a ];
            var vB = this.vertices[ face.b ];
            var vC = this.vertices[ face.c ];

            cb.subVectors( vC, vB );
            ab.subVectors( vA, vB );
            cb.cross( ab );

            cb.normalize();

            face.normal.copy( cb );

        }

    },

    computeVertexNormals: function ( areaWeighted ) {

        var v, vl, f, fl, face, vertices;

        vertices = new Array( this.vertices.length );

        for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

            vertices[ v ] = new THREE.Vector3();

        }

        if ( areaWeighted ) {

            // vertex normals weighted by triangle areas
            // http://www.iquilezles.org/www/articles/normals/normals.htm

            var vA, vB, vC;
            var cb = new THREE.Vector3(), ab = new THREE.Vector3();

            for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

                face = this.faces[ f ];

                vA = this.vertices[ face.a ];
                vB = this.vertices[ face.b ];
                vC = this.vertices[ face.c ];

                cb.subVectors( vC, vB );
                ab.subVectors( vA, vB );
                cb.cross( ab );

                vertices[ face.a ].add( cb );
                vertices[ face.b ].add( cb );
                vertices[ face.c ].add( cb );

            }

        } else {

            for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

                face = this.faces[ f ];

                vertices[ face.a ].add( face.normal );
                vertices[ face.b ].add( face.normal );
                vertices[ face.c ].add( face.normal );

            }

        }

        for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

            vertices[ v ].normalize();

        }

        for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

            face = this.faces[ f ];

            var vertexNormals = face.vertexNormals;

            if ( vertexNormals.length === 3 ) {

                vertexNormals[ 0 ].copy( vertices[ face.a ] );
                vertexNormals[ 1 ].copy( vertices[ face.b ] );
                vertexNormals[ 2 ].copy( vertices[ face.c ] );

            } else {

                vertexNormals[ 0 ] = vertices[ face.a ].clone();
                vertexNormals[ 1 ] = vertices[ face.b ].clone();
                vertexNormals[ 2 ] = vertices[ face.c ].clone();

            }

        }

    },

    computeMorphNormals: function () {

        var i, il, f, fl, face;

        // save original normals
        // - create temp variables on first access
        //   otherwise just copy (for faster repeated calls)

        for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

            face = this.faces[ f ];

            if ( ! face.__originalFaceNormal ) {

                face.__originalFaceNormal = face.normal.clone();

            } else {

                face.__originalFaceNormal.copy( face.normal );

            }

            if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

            for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

                if ( ! face.__originalVertexNormals[ i ] ) {

                    face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

                } else {

                    face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

                }

            }

        }

        // use temp geometry to compute face and vertex normals for each morph

        var tmpGeo = new THREE.Geometry();
        tmpGeo.faces = this.faces;

        for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

            // create on first access

            if ( ! this.morphNormals[ i ] ) {

                this.morphNormals[ i ] = {};
                this.morphNormals[ i ].faceNormals = [];
                this.morphNormals[ i ].vertexNormals = [];

                var dstNormalsFace = this.morphNormals[ i ].faceNormals;
                var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

                var faceNormal, vertexNormals;

                for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

                    faceNormal = new THREE.Vector3();
                    vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };

                    dstNormalsFace.push( faceNormal );
                    dstNormalsVertex.push( vertexNormals );

                }

            }

            var morphNormals = this.morphNormals[ i ];

            // set vertices to morph target

            tmpGeo.vertices = this.morphTargets[ i ].vertices;

            // compute morph normals

            tmpGeo.computeFaceNormals();
            tmpGeo.computeVertexNormals();

            // store morph normals

            var faceNormal, vertexNormals;

            for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

                face = this.faces[ f ];

                faceNormal = morphNormals.faceNormals[ f ];
                vertexNormals = morphNormals.vertexNormals[ f ];

                faceNormal.copy( face.normal );

                vertexNormals.a.copy( face.vertexNormals[ 0 ] );
                vertexNormals.b.copy( face.vertexNormals[ 1 ] );
                vertexNormals.c.copy( face.vertexNormals[ 2 ] );

            }

        }

        // restore original normals

        for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

            face = this.faces[ f ];

            face.normal = face.__originalFaceNormal;
            face.vertexNormals = face.__originalVertexNormals;

        }

    },

    computeTangents: function () {

        console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );

    },

    computeLineDistances: function () {

        var d = 0;
        var vertices = this.vertices;

        for ( var i = 0, il = vertices.length; i < il; i ++ ) {

            if ( i > 0 ) {

                d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

            }

            this.lineDistances[ i ] = d;

        }

    },

    computeBoundingBox: function () {

        if ( this.boundingBox === null ) {

            this.boundingBox = new THREE.Box3();

        }

        this.boundingBox.setFromPoints( this.vertices );

    },

    computeBoundingSphere: function () {

        if ( this.boundingSphere === null ) {

            this.boundingSphere = new THREE.Sphere();

        }

        this.boundingSphere.setFromPoints( this.vertices );

    },

    merge: function ( geometry, matrix, materialIndexOffset ) {

        if ( geometry instanceof THREE.Geometry === false ) {

            console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
            return;

        }

        var normalMatrix,
            vertexOffset = this.vertices.length,
            vertices1 = this.vertices,
            vertices2 = geometry.vertices,
            faces1 = this.faces,
            faces2 = geometry.faces,
            uvs1 = this.faceVertexUvs[ 0 ],
            uvs2 = geometry.faceVertexUvs[ 0 ];

        if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

        if ( matrix !== undefined ) {

            normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

        }

        // vertices

        for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

            var vertex = vertices2[ i ];

            var vertexCopy = vertex.clone();

            if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

            vertices1.push( vertexCopy );

        }

        // faces

        for ( i = 0, il = faces2.length; i < il; i ++ ) {

            var face = faces2[ i ], faceCopy, normal, color,
                faceVertexNormals = face.vertexNormals,
                faceVertexColors = face.vertexColors;

            faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
            faceCopy.normal.copy( face.normal );

            if ( normalMatrix !== undefined ) {

                faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

            }

            for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

                normal = faceVertexNormals[ j ].clone();

                if ( normalMatrix !== undefined ) {

                    normal.applyMatrix3( normalMatrix ).normalize();

                }

                faceCopy.vertexNormals.push( normal );

            }

            faceCopy.color.copy( face.color );

            for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

                color = faceVertexColors[ j ];
                faceCopy.vertexColors.push( color.clone() );

            }

            faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

            faces1.push( faceCopy );

        }

        // uvs

        for ( i = 0, il = uvs2.length; i < il; i ++ ) {

            var uv = uvs2[ i ], uvCopy = [];

            if ( uv === undefined ) {

                continue;

            }

            for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

                uvCopy.push( uv[ j ].clone() );

            }

            uvs1.push( uvCopy );

        }

    },

    mergeMesh: function ( mesh ) {

        if ( mesh instanceof THREE.Mesh === false ) {

            console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
            return;

        }

        mesh.matrixAutoUpdate && mesh.updateMatrix();

        this.merge( mesh.geometry, mesh.matrix );

    },

    /*
     * Checks for duplicate vertices with hashmap.
     * Duplicated vertices are removed
     * and faces' vertices are updated.
     */

    mergeVertices: function () {

        var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
        var unique = [], changes = [];

        var v, key;
        var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
        var precision = Math.pow( 10, precisionPoints );
        var i, il, face;
        var indices, j, jl;

        for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

            v = this.vertices[ i ];
            key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

            if ( verticesMap[ key ] === undefined ) {

                verticesMap[ key ] = i;
                unique.push( this.vertices[ i ] );
                changes[ i ] = unique.length - 1;

            } else {

                //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
                changes[ i ] = changes[ verticesMap[ key ] ];

            }

        }


        // if faces are completely degenerate after merging vertices, we
        // have to remove them from the geometry.
        var faceIndicesToRemove = [];

        for ( i = 0, il = this.faces.length; i < il; i ++ ) {

            face = this.faces[ i ];

            face.a = changes[ face.a ];
            face.b = changes[ face.b ];
            face.c = changes[ face.c ];

            indices = [ face.a, face.b, face.c ];

            var dupIndex = - 1;

            // if any duplicate vertices are found in a Face3
            // we have to remove the face as nothing can be saved
            for ( var n = 0; n < 3; n ++ ) {

                if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

                    dupIndex = n;
                    faceIndicesToRemove.push( i );
                    break;

                }

            }

        }

        for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

            var idx = faceIndicesToRemove[ i ];

            this.faces.splice( idx, 1 );

            for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

                this.faceVertexUvs[ j ].splice( idx, 1 );

            }

        }

        // Use unique set of vertices

        var diff = this.vertices.length - unique.length;
        this.vertices = unique;
        return diff;

    },

    sortFacesByMaterialIndex: function () {

        var faces = this.faces;
        var length = faces.length;

        // tag faces

        for ( var i = 0; i < length; i ++ ) {

            faces[ i ]._id = i;

        }

        // sort faces

        function materialIndexSort( a, b ) {

            return a.materialIndex - b.materialIndex;

        }

        faces.sort( materialIndexSort );

        // sort uvs

        var uvs1 = this.faceVertexUvs[ 0 ];
        var uvs2 = this.faceVertexUvs[ 1 ];

        var newUvs1, newUvs2;

        if ( uvs1 && uvs1.length === length ) newUvs1 = [];
        if ( uvs2 && uvs2.length === length ) newUvs2 = [];

        for ( var i = 0; i < length; i ++ ) {

            var id = faces[ i ]._id;

            if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
            if ( newUvs2 ) newUvs2.push( uvs2[ id ] );

        }

        if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
        if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;

    },

    toJSON: function () {

        var data = {
            metadata: {
                version: 4.4,
                type: 'Geometry',
                generator: 'Geometry.toJSON'
            }
        };

        // standard Geometry serialization

        data.uuid = this.uuid;
        data.type = this.type;
        if ( this.name !== '' ) data.name = this.name;

        if ( this.parameters !== undefined ) {

            var parameters = this.parameters;

            for ( var key in parameters ) {

                if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

            }

            return data;

        }

        var vertices = [];

        for ( var i = 0; i < this.vertices.length; i ++ ) {

            var vertex = this.vertices[ i ];
            vertices.push( vertex.x, vertex.y, vertex.z );

        }

        var faces = [];
        var normals = [];
        var normalsHash = {};
        var colors = [];
        var colorsHash = {};
        var uvs = [];
        var uvsHash = {};

        for ( var i = 0; i < this.faces.length; i ++ ) {

            var face = this.faces[ i ];

            var hasMaterial = false; // face.materialIndex !== undefined;
            var hasFaceUv = false; // deprecated
            var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
            var hasFaceNormal = face.normal.length() > 0;
            var hasFaceVertexNormal = face.vertexNormals.length > 0;
            var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
            var hasFaceVertexColor = face.vertexColors.length > 0;

            var faceType = 0;

            faceType = setBit( faceType, 0, 0 );
            faceType = setBit( faceType, 1, hasMaterial );
            faceType = setBit( faceType, 2, hasFaceUv );
            faceType = setBit( faceType, 3, hasFaceVertexUv );
            faceType = setBit( faceType, 4, hasFaceNormal );
            faceType = setBit( faceType, 5, hasFaceVertexNormal );
            faceType = setBit( faceType, 6, hasFaceColor );
            faceType = setBit( faceType, 7, hasFaceVertexColor );

            faces.push( faceType );
            faces.push( face.a, face.b, face.c );

            if ( hasFaceVertexUv ) {

                var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

                faces.push(
                    getUvIndex( faceVertexUvs[ 0 ] ),
                    getUvIndex( faceVertexUvs[ 1 ] ),
                    getUvIndex( faceVertexUvs[ 2 ] )
                );

            }

            if ( hasFaceNormal ) {

                faces.push( getNormalIndex( face.normal ) );

            }

            if ( hasFaceVertexNormal ) {

                var vertexNormals = face.vertexNormals;

                faces.push(
                    getNormalIndex( vertexNormals[ 0 ] ),
                    getNormalIndex( vertexNormals[ 1 ] ),
                    getNormalIndex( vertexNormals[ 2 ] )
                );

            }

            if ( hasFaceColor ) {

                faces.push( getColorIndex( face.color ) );

            }

            if ( hasFaceVertexColor ) {

                var vertexColors = face.vertexColors;

                faces.push(
                    getColorIndex( vertexColors[ 0 ] ),
                    getColorIndex( vertexColors[ 1 ] ),
                    getColorIndex( vertexColors[ 2 ] )
                );

            }

        }

        function setBit( value, position, enabled ) {

            return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

        }

        function getNormalIndex( normal ) {

            var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

            if ( normalsHash[ hash ] !== undefined ) {

                return normalsHash[ hash ];

            }

            normalsHash[ hash ] = normals.length / 3;
            normals.push( normal.x, normal.y, normal.z );

            return normalsHash[ hash ];

        }

        function getColorIndex( color ) {

            var hash = color.r.toString() + color.g.toString() + color.b.toString();

            if ( colorsHash[ hash ] !== undefined ) {

                return colorsHash[ hash ];

            }

            colorsHash[ hash ] = colors.length;
            colors.push( color.getHex() );

            return colorsHash[ hash ];

        }

        function getUvIndex( uv ) {

            var hash = uv.x.toString() + uv.y.toString();

            if ( uvsHash[ hash ] !== undefined ) {

                return uvsHash[ hash ];

            }

            uvsHash[ hash ] = uvs.length / 2;
            uvs.push( uv.x, uv.y );

            return uvsHash[ hash ];

        }

        data.data = {};

        data.data.vertices = vertices;
        data.data.normals = normals;
        if ( colors.length > 0 ) data.data.colors = colors;
        if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
        data.data.faces = faces;

        return data;

    },

    clone: function () {

        return new this.constructor().copy( this );

    },

    copy: function ( source ) {

        this.vertices = [];
        this.faces = [];
        this.faceVertexUvs = [ [] ];

        var vertices = source.vertices;

        for ( var i = 0, il = vertices.length; i < il; i ++ ) {

            this.vertices.push( vertices[ i ].clone() );

        }

        var faces = source.faces;

        for ( var i = 0, il = faces.length; i < il; i ++ ) {

            this.faces.push( faces[ i ].clone() );

        }

        for ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

            var faceVertexUvs = source.faceVertexUvs[ i ];

            if ( this.faceVertexUvs[ i ] === undefined ) {

                this.faceVertexUvs[ i ] = [];

            }

            for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

                var uvs = faceVertexUvs[ j ], uvsCopy = [];

                for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {

                    var uv = uvs[ k ];

                    uvsCopy.push( uv.clone() );

                }

                this.faceVertexUvs[ i ].push( uvsCopy );

            }

        }

        return this;

    },

    dispose: function () {

        this.dispatchEvent( { type: 'dispose' } );

    }

};

THREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );

THREE.GeometryIdCount = 0;

// File:src/core/DirectGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.DirectGeometry = function () {

    Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

    this.uuid = THREE.Math.generateUUID();

    this.name = '';
    this.type = 'DirectGeometry';

    this.indices = [];
    this.vertices = [];
    this.normals = [];
    this.colors = [];
    this.uvs = [];
    this.uvs2 = [];

    this.groups = [];

    this.morphTargets = {};

    this.skinWeights = [];
    this.skinIndices = [];

    // this.lineDistances = [];

    this.boundingBox = null;
    this.boundingSphere = null;

    // update flags

    this.verticesNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.groupsNeedUpdate = false;

};

THREE.DirectGeometry.prototype = {

    constructor: THREE.DirectGeometry,

    computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,
    computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,

    computeFaceNormals: function () {

        console.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );

    },

    computeVertexNormals: function () {

        console.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );

    },

    computeGroups: function ( geometry ) {

        var group;
        var groups = [];
        var materialIndex;

        var faces = geometry.faces;

        for ( var i = 0; i < faces.length; i ++ ) {

            var face = faces[ i ];

            // materials

            if ( face.materialIndex !== materialIndex ) {

                materialIndex = face.materialIndex;

                if ( group !== undefined ) {

                    group.count = ( i * 3 ) - group.start;
                    groups.push( group );

                }

                group = {
                    start: i * 3,
                    materialIndex: materialIndex
                };

            }

        }

        if ( group !== undefined ) {

            group.count = ( i * 3 ) - group.start;
            groups.push( group );

        }

        this.groups = groups;

    },

    fromGeometry: function ( geometry ) {

        var faces = geometry.faces;
        var vertices = geometry.vertices;
        var faceVertexUvs = geometry.faceVertexUvs;

        var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
        var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

        // morphs

        var morphTargets = geometry.morphTargets;
        var morphTargetsLength = morphTargets.length;

        if ( morphTargetsLength > 0 ) {

            var morphTargetsPosition = [];

            for ( var i = 0; i < morphTargetsLength; i ++ ) {

                morphTargetsPosition[ i ] = [];

            }

            this.morphTargets.position = morphTargetsPosition;

        }

        var morphNormals = geometry.morphNormals;
        var morphNormalsLength = morphNormals.length;

        if ( morphNormalsLength > 0 ) {

            var morphTargetsNormal = [];

            for ( var i = 0; i < morphNormalsLength; i ++ ) {

                morphTargetsNormal[ i ] = [];

            }

            this.morphTargets.normal = morphTargetsNormal;

        }

        // skins

        var skinIndices = geometry.skinIndices;
        var skinWeights = geometry.skinWeights;

        var hasSkinIndices = skinIndices.length === vertices.length;
        var hasSkinWeights = skinWeights.length === vertices.length;

        //

        for ( var i = 0; i < faces.length; i ++ ) {

            var face = faces[ i ];

            this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

            var vertexNormals = face.vertexNormals;

            if ( vertexNormals.length === 3 ) {

                this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

            } else {

                var normal = face.normal;

                this.normals.push( normal, normal, normal );

            }

            var vertexColors = face.vertexColors;

            if ( vertexColors.length === 3 ) {

                this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

            } else {

                var color = face.color;

                this.colors.push( color, color, color );

            }

            if ( hasFaceVertexUv === true ) {

                var vertexUvs = faceVertexUvs[ 0 ][ i ];

                if ( vertexUvs !== undefined ) {

                    this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

                } else {

                    console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

                    this.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );

                }

            }

            if ( hasFaceVertexUv2 === true ) {

                var vertexUvs = faceVertexUvs[ 1 ][ i ];

                if ( vertexUvs !== undefined ) {

                    this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

                } else {

                    console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

                    this.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );

                }

            }

            // morphs

            for ( var j = 0; j < morphTargetsLength; j ++ ) {

                var morphTarget = morphTargets[ j ].vertices;

                morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

            }

            for ( var j = 0; j < morphNormalsLength; j ++ ) {

                var morphNormal = morphNormals[ j ].vertexNormals[ i ];

                morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

            }

            // skins

            if ( hasSkinIndices ) {

                this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

            }

            if ( hasSkinWeights ) {

                this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

            }

        }

        this.computeGroups( geometry );

        this.verticesNeedUpdate = geometry.verticesNeedUpdate;
        this.normalsNeedUpdate = geometry.normalsNeedUpdate;
        this.colorsNeedUpdate = geometry.colorsNeedUpdate;
        this.uvsNeedUpdate = geometry.uvsNeedUpdate;
        this.groupsNeedUpdate = geometry.groupsNeedUpdate;

        return this;

    },

    dispose: function () {

        this.dispatchEvent( { type: 'dispose' } );

    }

};

THREE.EventDispatcher.prototype.apply( THREE.DirectGeometry.prototype );

// File:src/core/BufferGeometry.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometry = function () {

    Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

    this.uuid = THREE.Math.generateUUID();

    this.name = '';
    this.type = 'BufferGeometry';

    this.index = null;
    this.attributes = {};

    this.morphAttributes = {};

    this.groups = [];

    this.boundingBox = null;
    this.boundingSphere = null;

    this.drawRange = { start: 0, count: Infinity };

};

THREE.BufferGeometry.prototype = {

    constructor: THREE.BufferGeometry,

    addIndex: function ( index ) {

        console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
        this.setIndex( index );

    },

    getIndex: function () {

        return this.index;

    },

    setIndex: function ( index ) {

        this.index = index;

    },

    addAttribute: function ( name, attribute ) {

        if ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {

            console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

            this.addAttribute( name, new THREE.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

            return;

        }

        if ( name === 'index' ) {

            console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
            this.setIndex( attribute );

            return;

        }

        this.attributes[ name ] = attribute;

    },

    getAttribute: function ( name ) {

        return this.attributes[ name ];

    },

    removeAttribute: function ( name ) {

        delete this.attributes[ name ];

    },

    get drawcalls() {

        console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
        return this.groups;

    },

    get offsets() {

        console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
        return this.groups;

    },

    addDrawCall: function ( start, count, indexOffset ) {

        if ( indexOffset !== undefined ) {

            console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

        }

        console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
        this.addGroup( start, count );

    },

    clearDrawCalls: function () {

        console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
        this.clearGroups();

    },

    addGroup: function ( start, count, materialIndex ) {

        this.groups.push( {

            start: start,
            count: count,
            materialIndex: materialIndex !== undefined ? materialIndex : 0

        } );

    },

    clearGroups: function () {

        this.groups = [];

    },

    setDrawRange: function ( start, count ) {

        this.drawRange.start = start;
        this.drawRange.count = count;

    },

    applyMatrix: function ( matrix ) {

        var position = this.attributes.position;

        if ( position !== undefined ) {

            matrix.applyToVector3Array( position.array );
            position.needsUpdate = true;

        }

        var normal = this.attributes.normal;

        if ( normal !== undefined ) {

            var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

            normalMatrix.applyToVector3Array( normal.array );
            normal.needsUpdate = true;

        }

        if ( this.boundingBox !== null ) {

            this.computeBoundingBox();

        }

        if ( this.boundingSphere !== null ) {

            this.computeBoundingSphere();

        }

    },

    rotateX: function () {

        // rotate geometry around world x-axis

        var m1;

        return function rotateX( angle ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeRotationX( angle );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    rotateY: function () {

        // rotate geometry around world y-axis

        var m1;

        return function rotateY( angle ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeRotationY( angle );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    rotateZ: function () {

        // rotate geometry around world z-axis

        var m1;

        return function rotateZ( angle ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeRotationZ( angle );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    translate: function () {

        // translate geometry

        var m1;

        return function translate( x, y, z ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeTranslation( x, y, z );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    scale: function () {

        // scale geometry

        var m1;

        return function scale( x, y, z ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeScale( x, y, z );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    lookAt: function () {

        var obj;

        return function lookAt( vector ) {

            if ( obj === undefined ) obj = new THREE.Object3D();

            obj.lookAt( vector );

            obj.updateMatrix();

            this.applyMatrix( obj.matrix );

        };

    }(),

    center: function () {

        this.computeBoundingBox();

        var offset = this.boundingBox.center().negate();

        this.translate( offset.x, offset.y, offset.z );

        return offset;

    },

    setFromObject: function ( object ) {

        // console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

        var geometry = object.geometry;

        if ( object instanceof THREE.Points || object instanceof THREE.Line ) {

            var positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );
            var colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );

            this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
            this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

            if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

                var lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );

                this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

            }

            if ( geometry.boundingSphere !== null ) {

                this.boundingSphere = geometry.boundingSphere.clone();

            }

            if ( geometry.boundingBox !== null ) {

                this.boundingBox = geometry.boundingBox.clone();

            }

        } else if ( object instanceof THREE.Mesh ) {

            if ( geometry instanceof THREE.Geometry ) {

                this.fromGeometry( geometry );

            }

        }

        return this;

    },

    updateFromObject: function ( object ) {

        var geometry = object.geometry;

        if ( object instanceof THREE.Mesh ) {

            var direct = geometry.__directGeometry;

            if ( direct === undefined ) {

                return this.fromGeometry( geometry );

            }

            direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
            direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
            direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
            direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
            direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

            geometry.verticesNeedUpdate = false;
            geometry.normalsNeedUpdate = false;
            geometry.colorsNeedUpdate = false;
            geometry.uvsNeedUpdate = false;
            geometry.groupsNeedUpdate = false;

            geometry = direct;

        }

        if ( geometry.verticesNeedUpdate === true ) {

            var attribute = this.attributes.position;

            if ( attribute !== undefined ) {

                attribute.copyVector3sArray( geometry.vertices );
                attribute.needsUpdate = true;

            }

            geometry.verticesNeedUpdate = false;

        }

        if ( geometry.normalsNeedUpdate === true ) {

            var attribute = this.attributes.normal;

            if ( attribute !== undefined ) {

                attribute.copyVector3sArray( geometry.normals );
                attribute.needsUpdate = true;

            }

            geometry.normalsNeedUpdate = false;

        }

        if ( geometry.colorsNeedUpdate === true ) {

            var attribute = this.attributes.color;

            if ( attribute !== undefined ) {

                attribute.copyColorsArray( geometry.colors );
                attribute.needsUpdate = true;

            }

            geometry.colorsNeedUpdate = false;

        }

        if ( geometry.uvsNeedUpdate ) {

            var attribute = this.attributes.uv;

            if ( attribute !== undefined ) {

                attribute.copyVector2sArray( geometry.uvs );
                attribute.needsUpdate = true;

            }

            geometry.uvsNeedUpdate = false;

        }

        if ( geometry.lineDistancesNeedUpdate ) {

            var attribute = this.attributes.lineDistance;

            if ( attribute !== undefined ) {

                attribute.copyArray( geometry.lineDistances );
                attribute.needsUpdate = true;

            }

            geometry.lineDistancesNeedUpdate = false;

        }

        if ( geometry.groupsNeedUpdate ) {

            geometry.computeGroups( object.geometry );
            this.groups = geometry.groups;

            geometry.groupsNeedUpdate = false;

        }

        return this;

    },

    fromGeometry: function ( geometry ) {

        geometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );

        return this.fromDirectGeometry( geometry.__directGeometry );

    },

    fromDirectGeometry: function ( geometry ) {

        var positions = new Float32Array( geometry.vertices.length * 3 );
        this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

        if ( geometry.normals.length > 0 ) {

            var normals = new Float32Array( geometry.normals.length * 3 );
            this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

        }

        if ( geometry.colors.length > 0 ) {

            var colors = new Float32Array( geometry.colors.length * 3 );
            this.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

        }

        if ( geometry.uvs.length > 0 ) {

            var uvs = new Float32Array( geometry.uvs.length * 2 );
            this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

        }

        if ( geometry.uvs2.length > 0 ) {

            var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
            this.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

        }

        if ( geometry.indices.length > 0 ) {

            var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
            var indices = new TypeArray( geometry.indices.length * 3 );
            this.setIndex( new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );

        }

        // groups

        this.groups = geometry.groups;

        // morphs

        for ( var name in geometry.morphTargets ) {

            var array = [];
            var morphTargets = geometry.morphTargets[ name ];

            for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

                var morphTarget = morphTargets[ i ];

                var attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );

                array.push( attribute.copyVector3sArray( morphTarget ) );

            }

            this.morphAttributes[ name ] = array;

        }

        // skinning

        if ( geometry.skinIndices.length > 0 ) {

            var skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );
            this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

        }

        if ( geometry.skinWeights.length > 0 ) {

            var skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );
            this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

        }

        //

        if ( geometry.boundingSphere !== null ) {

            this.boundingSphere = geometry.boundingSphere.clone();

        }

        if ( geometry.boundingBox !== null ) {

            this.boundingBox = geometry.boundingBox.clone();

        }

        return this;

    },

    computeBoundingBox: function () {

        var vector = new THREE.Vector3();

        return function () {

            if ( this.boundingBox === null ) {

                this.boundingBox = new THREE.Box3();

            }

            var positions = this.attributes.position.array;

            if ( positions ) {

                var bb = this.boundingBox;
                bb.makeEmpty();

                for ( var i = 0, il = positions.length; i < il; i += 3 ) {

                    vector.fromArray( positions, i );
                    bb.expandByPoint( vector );

                }

            }

            if ( positions === undefined || positions.length === 0 ) {

                this.boundingBox.min.set( 0, 0, 0 );
                this.boundingBox.max.set( 0, 0, 0 );

            }

            if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

                console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

            }

        };

    }(),

    computeBoundingSphere: function () {

        var box = new THREE.Box3();
        var vector = new THREE.Vector3();

        return function () {

            if ( this.boundingSphere === null ) {

                this.boundingSphere = new THREE.Sphere();

            }

            var positions = this.attributes.position.array;

            if ( positions ) {

                box.makeEmpty();

                var center = this.boundingSphere.center;

                for ( var i = 0, il = positions.length; i < il; i += 3 ) {

                    vector.fromArray( positions, i );
                    box.expandByPoint( vector );

                }

                box.center( center );

                // hoping to find a boundingSphere with a radius smaller than the
                // boundingSphere of the boundingBox: sqrt(3) smaller in the best case

                var maxRadiusSq = 0;

                for ( var i = 0, il = positions.length; i < il; i += 3 ) {

                    vector.fromArray( positions, i );
                    maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

                }

                this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

                if ( isNaN( this.boundingSphere.radius ) ) {

                    console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

                }

            }

        };

    }(),

    computeFaceNormals: function () {

        // backwards compatibility

    },

    computeVertexNormals: function () {

        var index = this.index;
        var attributes = this.attributes;
        var groups = this.groups;

        if ( attributes.position ) {

            var positions = attributes.position.array;

            if ( attributes.normal === undefined ) {

                this.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );

            } else {

                // reset existing normals to zero

                var normals = attributes.normal.array;

                for ( var i = 0, il = normals.length; i < il; i ++ ) {

                    normals[ i ] = 0;

                }

            }

            var normals = attributes.normal.array;

            var vA, vB, vC,

                pA = new THREE.Vector3(),
                pB = new THREE.Vector3(),
                pC = new THREE.Vector3(),

                cb = new THREE.Vector3(),
                ab = new THREE.Vector3();

            // indexed elements

            if ( index ) {

                var indices = index.array;

                if ( groups.length === 0 ) {

                    this.addGroup( 0, indices.length );

                }

                for ( var j = 0, jl = groups.length; j < jl; ++ j ) {

                    var group = groups[ j ];

                    var start = group.start;
                    var count = group.count;

                    for ( var i = start, il = start + count; i < il; i += 3 ) {

                        vA = indices[ i + 0 ] * 3;
                        vB = indices[ i + 1 ] * 3;
                        vC = indices[ i + 2 ] * 3;

                        pA.fromArray( positions, vA );
                        pB.fromArray( positions, vB );
                        pC.fromArray( positions, vC );

                        cb.subVectors( pC, pB );
                        ab.subVectors( pA, pB );
                        cb.cross( ab );

                        normals[ vA ] += cb.x;
                        normals[ vA + 1 ] += cb.y;
                        normals[ vA + 2 ] += cb.z;

                        normals[ vB ] += cb.x;
                        normals[ vB + 1 ] += cb.y;
                        normals[ vB + 2 ] += cb.z;

                        normals[ vC ] += cb.x;
                        normals[ vC + 1 ] += cb.y;
                        normals[ vC + 2 ] += cb.z;

                    }

                }

            } else {

                // non-indexed elements (unconnected triangle soup)

                for ( var i = 0, il = positions.length; i < il; i += 9 ) {

                    pA.fromArray( positions, i );
                    pB.fromArray( positions, i + 3 );
                    pC.fromArray( positions, i + 6 );

                    cb.subVectors( pC, pB );
                    ab.subVectors( pA, pB );
                    cb.cross( ab );

                    normals[ i ] = cb.x;
                    normals[ i + 1 ] = cb.y;
                    normals[ i + 2 ] = cb.z;

                    normals[ i + 3 ] = cb.x;
                    normals[ i + 4 ] = cb.y;
                    normals[ i + 5 ] = cb.z;

                    normals[ i + 6 ] = cb.x;
                    normals[ i + 7 ] = cb.y;
                    normals[ i + 8 ] = cb.z;

                }

            }

            this.normalizeNormals();

            attributes.normal.needsUpdate = true;

        }

    },

    computeTangents: function () {

        console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );

    },

    computeOffsets: function ( size ) {

        console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.')

    },

    merge: function ( geometry, offset ) {

        if ( geometry instanceof THREE.BufferGeometry === false ) {

            console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
            return;

        }

        if ( offset === undefined ) offset = 0;

        var attributes = this.attributes;

        for ( var key in attributes ) {

            if ( geometry.attributes[ key ] === undefined ) continue;

            var attribute1 = attributes[ key ];
            var attributeArray1 = attribute1.array;

            var attribute2 = geometry.attributes[ key ];
            var attributeArray2 = attribute2.array;

            var attributeSize = attribute2.itemSize;

            for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

                attributeArray1[ j ] = attributeArray2[ i ];

            }

        }

        return this;

    },

    normalizeNormals: function () {

        var normals = this.attributes.normal.array;

        var x, y, z, n;

        for ( var i = 0, il = normals.length; i < il; i += 3 ) {

            x = normals[ i ];
            y = normals[ i + 1 ];
            z = normals[ i + 2 ];

            n = 1.0 / Math.sqrt( x * x + y * y + z * z );

            normals[ i ] *= n;
            normals[ i + 1 ] *= n;
            normals[ i + 2 ] *= n;

        }

    },

    toJSON: function () {

        var data = {
            metadata: {
                version: 4.4,
                type: 'BufferGeometry',
                generator: 'BufferGeometry.toJSON'
            }
        };

        // standard BufferGeometry serialization

        data.uuid = this.uuid;
        data.type = this.type;
        if ( this.name !== '' ) data.name = this.name;

        if ( this.parameters !== undefined ) {

            var parameters = this.parameters;

            for ( var key in parameters ) {

                if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

            }

            return data;

        }

        data.data = { attributes: {} };

        var index = this.index;

        if ( index !== null ) {

            var array = Array.prototype.slice.call( index.array );

            data.data.index = {
                type: index.array.constructor.name,
                array: array
            };

        }

        var attributes = this.attributes;

        for ( var key in attributes ) {

            var attribute = attributes[ key ];

            var array = Array.prototype.slice.call( attribute.array );

            data.data.attributes[ key ] = {
                itemSize: attribute.itemSize,
                type: attribute.array.constructor.name,
                array: array
            };

        }

        var groups = this.groups;

        if ( groups.length > 0 ) {

            data.data.groups = JSON.parse( JSON.stringify( groups ) );

        }

        var boundingSphere = this.boundingSphere;

        if ( boundingSphere !== null ) {

            data.data.boundingSphere = {
                center: boundingSphere.center.toArray(),
                radius: boundingSphere.radius
            };

        }

        return data;

    },

    clone: function () {

        return new this.constructor().copy( this );

    },

    copy: function ( source ) {

        var index = source.index;

        if ( index !== null ) {

            this.setIndex( index.clone() );

        }

        var attributes = source.attributes;

        for ( var name in attributes ) {

            var attribute = attributes[ name ];
            this.addAttribute( name, attribute.clone() );

        }

        var groups = source.groups;

        for ( var i = 0, l = groups.length; i < l; i ++ ) {

            var group = groups[ i ];
            this.addGroup( group.start, group.count );

        }

        return this;

    },

    dispose: function () {

        this.dispatchEvent( { type: 'dispose' } );

    }

};

THREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );

THREE.BufferGeometry.MaxIndex = 65535;

// File:src/core/InstancedBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedBufferGeometry = function () {

    THREE.BufferGeometry.call( this );

    this.type = 'InstancedBufferGeometry';
    this.maxInstancedCount = undefined;

};

THREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;

THREE.InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {

    this.groups.push( {

        start: start,
        count: count,
        instances: instances

    } );

};

THREE.InstancedBufferGeometry.prototype.copy = function ( source ) {

    var index = source.index;

    if ( index !== null ) {

        this.setIndex( index.clone() );

    }

    var attributes = source.attributes;

    for ( var name in attributes ) {

        var attribute = attributes[ name ];
        this.addAttribute( name, attribute.clone() );

    }

    var groups = source.groups;

    for ( var i = 0, l = groups.length; i < l; i ++ ) {

        var group = groups[ i ];
        this.addGroup( group.start, group.count, group.instances );

    }

    return this;

};

THREE.EventDispatcher.prototype.apply( THREE.InstancedBufferGeometry.prototype );

// File:src/animation/AnimationAction.js

/**
 *
 * A clip that has been explicitly scheduled.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.AnimationAction = function ( clip, startTime, timeScale, weight, loop ) {

    if ( clip === undefined ) throw new Error( 'clip is null' );
    this.clip = clip;
    this.localRoot = null;
    this.startTime = startTime || 0;
    this.timeScale = timeScale || 1;
    this.weight = weight || 1;
    this.loop = loop || THREE.LoopRepeat;
    this.loopCount = 0;
    this.enabled = true;	// allow for easy disabling of the action.

    this.actionTime = - this.startTime;
    this.clipTime = 0;

    this.propertyBindings = [];
};

/*
 THREE.LoopOnce = 2200;
 THREE.LoopRepeat = 2201;
 THREE.LoopPingPing = 2202;
 */

THREE.AnimationAction.prototype = {

    constructor: THREE.AnimationAction,

    setLocalRoot: function( localRoot ) {

        this.localRoot = localRoot;

        return this;

    },

    updateTime: function( clipDeltaTime ) {

        var previousClipTime = this.clipTime;
        var previousLoopCount = this.loopCount;
        var previousActionTime = this.actionTime;

        var duration = this.clip.duration;

        this.actionTime = this.actionTime + clipDeltaTime;

        if ( this.loop === THREE.LoopOnce ) {

            this.loopCount = 0;
            this.clipTime = Math.min( Math.max( this.actionTime, 0 ), duration );

            // if time is changed since last time, see if we have hit a start/end limit
            if ( this.clipTime !== previousClipTime ) {

                if ( this.clipTime === duration ) {

                    this.mixer.dispatchEvent( { type: 'finished', action: this, direction: 1 } );

                } else if ( this.clipTime === 0 ) {

                    this.mixer.dispatchEvent( { type: 'finished', action: this, direction: -1 } );

                }

            }


            return this.clipTime;

        }

        this.loopCount = Math.floor( this.actionTime / duration );

        var newClipTime = this.actionTime - this.loopCount * duration;
        newClipTime = newClipTime % duration;

        // if we are ping pong looping, ensure that we go backwards when appropriate
        if ( this.loop == THREE.LoopPingPong ) {

            if ( Math.abs( this.loopCount % 2 ) === 1 ) {

                newClipTime = duration - newClipTime;

            }

        }

        this.clipTime = newClipTime;

        if ( this.loopCount !== previousLoopCount ) {

            this.mixer.dispatchEvent( { type: 'loop', action: this, loopDelta: ( this.loopCount - this.loopCount ) } );

        }

        return this.clipTime;

    },

    syncWith: function( action ) {

        this.actionTime = action.actionTime;
        this.timeScale = action.timeScale;

        return this;
    },

    warpToDuration: function( duration ) {

        this.timeScale = this.clip.duration / duration;

        return this;
    },

    init: function( time ) {

        this.clipTime = time - this.startTime;

        return this;

    },

    update: function( clipDeltaTime ) {

        this.updateTime( clipDeltaTime );

        var clipResults = this.clip.getAt( this.clipTime );

        return clipResults;

    },

    getTimeScaleAt: function( time ) {

        if ( this.timeScale.getAt ) {
            // pass in time, not clip time, allows for fadein/fadeout across multiple loops of the clip
            return this.timeScale.getAt( time );

        }

        return this.timeScale;

    },

    getWeightAt: function( time ) {

        if ( this.weight.getAt ) {
            // pass in time, not clip time, allows for fadein/fadeout across multiple loops of the clip
            return this.weight.getAt( time );

        }

        return this.weight;

    }

};

// File:src/animation/AnimationClip.js

/**
 *
 * Reusable set of Tracks that represent an animation.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.AnimationClip = function ( name, duration, tracks ) {

    this.name = name;
    this.tracks = tracks;
    this.duration = ( duration !== undefined ) ? duration : -1;

    // this means it should figure out its duration by scanning the tracks
    if ( this.duration < 0 ) {
        for ( var i = 0; i < this.tracks.length; i ++ ) {
            var track = this.tracks[i];
            this.duration = Math.max( track.keys[ track.keys.length - 1 ].time );
        }
    }

    // maybe only do these on demand, as doing them here could potentially slow down loading
    // but leaving these here during development as this ensures a lot of testing of these functions
    this.trim();
    this.optimize();

    this.results = [];

};

THREE.AnimationClip.prototype = {

    constructor: THREE.AnimationClip,

    getAt: function( clipTime ) {

        clipTime = Math.max( 0, Math.min( clipTime, this.duration ) );

        for ( var i = 0; i < this.tracks.length; i ++ ) {

            var track = this.tracks[ i ];

            this.results[ i ] = track.getAt( clipTime );

        }

        return this.results;
    },

    trim: function() {

        for ( var i = 0; i < this.tracks.length; i ++ ) {

            this.tracks[ i ].trim( 0, this.duration );

        }

        return this;

    },

    optimize: function() {

        for ( var i = 0; i < this.tracks.length; i ++ ) {

            this.tracks[ i ].optimize();

        }

        return this;

    }

};


THREE.AnimationClip.CreateFromMorphTargetSequence = function( name, morphTargetSequence, fps ) {


    var numMorphTargets = morphTargetSequence.length;
    var tracks = [];

    for ( var i = 0; i < numMorphTargets; i ++ ) {

        var keys = [];

        keys.push( { time: ( i + numMorphTargets - 1 ) % numMorphTargets, value: 0 } );
        keys.push( { time: i, value: 1 } );
        keys.push( { time: ( i + 1 ) % numMorphTargets, value: 0 } );

        keys.sort( THREE.KeyframeTrack.keyComparer );

        // if there is a key at the first frame, duplicate it as the last frame as well for perfect loop.
        if ( keys[0].time === 0 ) {
            keys.push( {
                time: numMorphTargets,
                value: keys[0].value
            });
        }

        tracks.push( new THREE.NumberKeyframeTrack( '.morphTargetInfluences[' + morphTargetSequence[i].name + ']', keys ).scale( 1.0 / fps ) );
    }

    return new THREE.AnimationClip( name, -1, tracks );

};

THREE.AnimationClip.findByName = function( clipArray, name ) {

    for ( var i = 0; i < clipArray.length; i ++ ) {

        if ( clipArray[i].name === name ) {

            return clipArray[i];

        }
    }

    return null;

};

THREE.AnimationClip.CreateClipsFromMorphTargetSequences = function( morphTargets, fps ) {

    var animationToMorphTargets = {};

    // tested with https://regex101.com/ on trick sequences such flamingo_flyA_003, flamingo_run1_003, crdeath0059
    var pattern = /^([\w-]*?)([\d]+)$/;

    // sort morph target names into animation groups based patterns like Walk_001, Walk_002, Run_001, Run_002
    for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

        var morphTarget = morphTargets[ i ];
        var parts = morphTarget.name.match( pattern );

        if ( parts && parts.length > 1 ) {

            var name = parts[ 1 ];

            var animationMorphTargets = animationToMorphTargets[ name ];
            if ( ! animationMorphTargets ) {
                animationToMorphTargets[ name ] = animationMorphTargets = [];
            }

            animationMorphTargets.push( morphTarget );

        }

    }

    var clips = [];

    for ( var name in animationToMorphTargets ) {

        clips.push( THREE.AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps ) );
    }

    return clips;

};

// parse the standard JSON format for clips
THREE.AnimationClip.parse = function( json ) {

    var tracks = [];

    for ( var i = 0; i < json.tracks.length; i ++ ) {

        tracks.push( THREE.KeyframeTrack.parse( json.tracks[i] ).scale( 1.0 / json.fps ) );

    }

    return new THREE.AnimationClip( json.name, json.duration, tracks );

};


// parse the animation.hierarchy format
THREE.AnimationClip.parseAnimation = function( animation, bones, nodeName ) {

    if ( ! animation ) {
        console.error( "  no animation in JSONLoader data" );
        return null;
    }

    var convertTrack = function( trackName, animationKeys, propertyName, trackType, animationKeyToValueFunc ) {

        var keys = [];

        for ( var k = 0; k < animationKeys.length; k ++ ) {

            var animationKey = animationKeys[k];

            if ( animationKey[propertyName] !== undefined ) {

                keys.push( { time: animationKey.time, value: animationKeyToValueFunc( animationKey ) } );
            }

        }

        // only return track if there are actually keys.
        if ( keys.length > 0 ) {

            return new trackType( trackName, keys );

        }

        return null;

    };

    var tracks = [];

    var clipName = animation.name || 'default';
    var duration = animation.length || -1; // automatic length determination in AnimationClip.
    var fps = animation.fps || 30;

    var hierarchyTracks = animation.hierarchy || [];

    for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

        var animationKeys = hierarchyTracks[ h ].keys;

        // skip empty tracks
        if ( ! animationKeys || animationKeys.length == 0 ) {
            continue;
        }

        // process morph targets in a way exactly compatible with AnimationHandler.init( animation )
        if ( animationKeys[0].morphTargets ) {

            // figure out all morph targets used in this track
            var morphTargetNames = {};
            for ( var k = 0; k < animationKeys.length; k ++ ) {

                if ( animationKeys[k].morphTargets ) {
                    for ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {

                        morphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;
                    }
                }

            }

            // create a track for each morph target with all zero morphTargetInfluences except for the keys in which the morphTarget is named.
            for ( var morphTargetName in morphTargetNames ) {

                var keys = [];

                for ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {

                    var animationKey = animationKeys[k];

                    keys.push( {
                        time: animationKey.time,
                        value: (( animationKey.morphTarget === morphTargetName ) ? 1 : 0 )
                    });

                }

                tracks.push( new THREE.NumberKeyframeTrack( nodeName + '.morphTargetInfluence[' + morphTargetName + ']', keys ) );

            }

            duration = morphTargetNames.length * ( fps || 1.0 );

        } else {

            var boneName = nodeName + '.bones[' + bones[ h ].name + ']';

            // track contains positions...
            var positionTrack = convertTrack( boneName + '.position', animationKeys, 'pos', THREE.VectorKeyframeTrack, function( animationKey ) {
                return new THREE.Vector3().fromArray( animationKey.pos )
            } );

            if ( positionTrack ) tracks.push( positionTrack );

            // track contains quaternions...
            var quaternionTrack = convertTrack( boneName + '.quaternion', animationKeys, 'rot', THREE.QuaternionKeyframeTrack, function( animationKey ) {
                if ( animationKey.rot.slerp ) {
                    return animationKey.rot.clone();
                } else {
                    return new THREE.Quaternion().fromArray( animationKey.rot );
                }
            } );

            if ( quaternionTrack ) tracks.push( quaternionTrack );

            // track contains quaternions...
            var scaleTrack = convertTrack( boneName + '.scale', animationKeys, 'scl', THREE.VectorKeyframeTrack, function( animationKey ) {
                return new THREE.Vector3().fromArray( animationKey.scl )
            } );

            if ( scaleTrack ) tracks.push( scaleTrack );

        }
    }

    if ( tracks.length === 0 ) {

        return null;

    }

    var clip = new THREE.AnimationClip( clipName, duration, tracks );

    return clip;

};

// File:src/animation/AnimationMixer.js

/**
 *
 * Mixes together the AnimationClips scheduled by AnimationActions and applies them to the root and subtree
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.AnimationMixer = function( root ) {

    this.root = root;
    this.time = 0;
    this.timeScale = 1.0;
    this.actions = [];
    this.propertyBindingMap = {};

};

THREE.AnimationMixer.prototype = {

    constructor: THREE.AnimationMixer,

    addAction: function( action ) {

        // TODO: check for duplicate action names?  Or provide each action with a UUID?

        this.actions.push( action );
        action.init( this.time );
        action.mixer = this;

        var tracks = action.clip.tracks;

        var root = action.localRoot || this.root;

        for ( var i = 0; i < tracks.length; i ++ ) {

            var track = tracks[ i ];

            var propertyBindingKey = root.uuid + '-' + track.name;
            var propertyBinding = this.propertyBindingMap[ propertyBindingKey ];

            if ( propertyBinding === undefined ) {

                propertyBinding = new THREE.PropertyBinding( root, track.name );
                this.propertyBindingMap[ propertyBindingKey ] = propertyBinding;

            }

            // push in the same order as the tracks.
            action.propertyBindings.push( propertyBinding );

            // track usages of shared property bindings, because if we leave too many around, the mixer can get slow
            propertyBinding.referenceCount += 1;

        }

    },

    removeAllActions: function() {

        for ( var i = 0; i < this.actions.length; i ++ ) {

            this.actions[i].mixer = null;

        }

        // unbind all property bindings
        for ( var properyBindingKey in this.propertyBindingMap ) {

            this.propertyBindingMap[ properyBindingKey ].unbind();

        }

        this.actions = [];
        this.propertyBindingMap = {};

        return this;

    },

    removeAction: function( action ) {

        var index = this.actions.indexOf( action );

        if ( index !== - 1 ) {

            this.actions.splice( index, 1 );
            action.mixer = null;

        }


        // remove unused property bindings because if we leave them around the mixer can get slow
        var root = action.localRoot || this.root;
        var tracks = action.clip.tracks;

        for ( var i = 0; i < tracks.length; i ++ ) {

            var track = tracks[ i ];

            var propertyBindingKey = root.uuid + '-' + track.name;
            var propertyBinding = this.propertyBindingMap[ propertyBindingKey ];

            propertyBinding.referenceCount -= 1;

            if ( propertyBinding.referenceCount <= 0 ) {

                propertyBinding.unbind();

                delete this.propertyBindingMap[ propertyBindingKey ];

            }
        }

        return this;

    },

    // can be optimized if needed
    findActionByName: function( name ) {

        for ( var i = 0; i < this.actions.length; i ++ ) {

            if ( this.actions[i].name === name ) return this.actions[i];

        }

        return null;

    },

    play: function( action, optionalFadeInDuration ) {

        action.startTime = this.time;
        this.addAction( action );

        return this;

    },

    fadeOut: function( action, duration ) {

        var keys = [];

        keys.push( { time: this.time, value: 1 } );
        keys.push( { time: this.time + duration, value: 0 } );

        action.weight = new THREE.NumberKeyframeTrack( "weight", keys );

        return this;

    },

    fadeIn: function( action, duration ) {

        var keys = [];

        keys.push( { time: this.time, value: 0 } );
        keys.push( { time: this.time + duration, value: 1 } );

        action.weight = new THREE.NumberKeyframeTrack( "weight", keys );

        return this;

    },

    warp: function( action, startTimeScale, endTimeScale, duration ) {

        var keys = [];

        keys.push( { time: this.time, value: startTimeScale } );
        keys.push( { time: this.time + duration, value: endTimeScale } );

        action.timeScale = new THREE.NumberKeyframeTrack( "timeScale", keys );

        return this;

    },

    crossFade: function( fadeOutAction, fadeInAction, duration, warp ) {

        this.fadeOut( fadeOutAction, duration );
        this.fadeIn( fadeInAction, duration );

        if ( warp ) {

            var startEndRatio = fadeOutAction.clip.duration / fadeInAction.clip.duration;
            var endStartRatio = 1.0 / startEndRatio;

            this.warp( fadeOutAction, 1.0, startEndRatio, duration );
            this.warp( fadeInAction, endStartRatio, 1.0, duration );

        }

        return this;

    },

    update: function( deltaTime ) {

        var mixerDeltaTime = deltaTime * this.timeScale;
        this.time += mixerDeltaTime;

        for ( var i = 0; i < this.actions.length; i ++ ) {

            var action = this.actions[i];

            var weight = action.getWeightAt( this.time );

            var actionTimeScale = action.getTimeScaleAt( this.time );
            var actionDeltaTime = mixerDeltaTime * actionTimeScale;

            var actionResults = action.update( actionDeltaTime );

            if ( action.weight <= 0 || ! action.enabled ) continue;

            for ( var j = 0; j < actionResults.length; j ++ ) {

                var name = action.clip.tracks[j].name;

                action.propertyBindings[ j ].accumulate( actionResults[j], weight );

            }

        }

        // apply to nodes
        for ( var propertyBindingKey in this.propertyBindingMap ) {

            this.propertyBindingMap[ propertyBindingKey ].apply();

        }

        return this;

    }

};

THREE.EventDispatcher.prototype.apply( THREE.AnimationMixer.prototype );

// File:src/animation/AnimationUtils.js

/**
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.AnimationUtils = {

    getEqualsFunc: function( exemplarValue ) {

        if ( exemplarValue.equals ) {
            return function equals_object( a, b ) {
                return a.equals( b );
            }
        }

        return function equals_primitive( a, b ) {
            return ( a === b );
        };

    },

    clone: function( exemplarValue ) {

        var typeName = typeof exemplarValue;
        if ( typeName === "object" ) {
            if ( exemplarValue.clone ) {
                return exemplarValue.clone();
            }
            console.error( "can not figure out how to copy exemplarValue", exemplarValue );
        }

        return exemplarValue;

    },

    lerp: function( a, b, alpha, interTrack ) {

        var lerpFunc = THREE.AnimationUtils.getLerpFunc( a, interTrack );

        return lerpFunc( a, b, alpha );

    },

    lerp_object: function( a, b, alpha ) {
        return a.lerp( b, alpha );
    },

    slerp_object: function( a, b, alpha ) {
        return a.slerp( b, alpha );
    },

    lerp_number: function( a, b, alpha ) {
        return a * ( 1 - alpha ) + b * alpha;
    },

    lerp_boolean: function( a, b, alpha ) {
        return ( alpha < 0.5 ) ? a : b;
    },

    lerp_boolean_immediate: function( a, b, alpha ) {
        return a;
    },

    lerp_string: function( a, b, alpha ) {
        return ( alpha < 0.5 ) ? a : b;
    },

    lerp_string_immediate: function( a, b, alpha ) {
        return a;
    },

    // NOTE: this is an accumulator function that modifies the first argument (e.g. a).	This is to minimize memory alocations.
    getLerpFunc: function( exemplarValue, interTrack ) {

        if ( exemplarValue === undefined || exemplarValue === null ) throw new Error( "examplarValue is null" );

        var typeName = typeof exemplarValue;

        switch( typeName ) {

            case "object":
                if ( exemplarValue.lerp ) {
                    return THREE.AnimationUtils.lerp_object;
                }

                if ( exemplarValue.slerp ) {
                    return THREE.AnimationUtils.slerp_object;
                }
                break;

            case "number":
                return THREE.AnimationUtils.lerp_number;

            case "boolean":
                if ( interTrack ) {
                    return THREE.AnimationUtils.lerp_boolean;
                } else {
                    return THREE.AnimationUtils.lerp_boolean_immediate;
                }

            case "string":
                if ( interTrack ) {
                    return THREE.AnimationUtils.lerp_string;
                } else {
                    return THREE.AnimationUtils.lerp_string_immediate;
                }

        }

    }

};

// File:src/animation/KeyframeTrack.js

/**
 *
 * A Track that returns a keyframe interpolated value, currently linearly interpolated
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.KeyframeTrack = function ( name, keys ) {

    if ( name === undefined ) throw new Error( "track name is undefined" );
    if ( keys === undefined || keys.length === 0 ) throw new Error( "no keys in track named " + name );

    this.name = name;
    this.keys = keys;	// time in seconds, value as value

    // the index of the last result, used as a starting point for local search.
    this.lastIndex = 0;

    this.validate();
    this.optimize();

};

THREE.KeyframeTrack.prototype = {

    constructor: THREE.KeyframeTrack,

    getAt: function( time ) {


        // this can not go higher than this.keys.length.
        while( ( this.lastIndex < this.keys.length ) && ( time >= this.keys[this.lastIndex].time ) ) {
            this.lastIndex ++;
        };

        // this can not go lower than 0.
        while( ( this.lastIndex > 0 ) && ( time < this.keys[this.lastIndex - 1].time ) ) {
            this.lastIndex --;
        }

        if ( this.lastIndex >= this.keys.length ) {

            this.setResult( this.keys[ this.keys.length - 1 ].value );

            return this.result;

        }

        if ( this.lastIndex === 0 ) {

            this.setResult( this.keys[ 0 ].value );

            return this.result;

        }

        var prevKey = this.keys[ this.lastIndex - 1 ];
        this.setResult( prevKey.value );

        // if true, means that prev/current keys are identical, thus no interpolation required.
        if ( prevKey.constantToNext ) {

            return this.result;

        }

        // linear interpolation to start with
        var currentKey = this.keys[ this.lastIndex ];
        var alpha = ( time - prevKey.time ) / ( currentKey.time - prevKey.time );
        this.result = this.lerpValues( this.result, currentKey.value, alpha );

        return this.result;

    },

    // move all keyframes either forwards or backwards in time
    shift: function( timeOffset ) {

        if ( timeOffset !== 0.0 ) {

            for ( var i = 0; i < this.keys.length; i ++ ) {
                this.keys[i].time += timeOffset;
            }

        }

        return this;

    },

    // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
    scale: function( timeScale ) {

        if ( timeScale !== 1.0 ) {

            for ( var i = 0; i < this.keys.length; i ++ ) {
                this.keys[i].time *= timeScale;
            }

        }

        return this;

    },

    // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
    // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
    trim: function( startTime, endTime ) {

        var firstKeysToRemove = 0;
        for ( var i = 1; i < this.keys.length; i ++ ) {
            if ( this.keys[i] <= startTime ) {
                firstKeysToRemove ++;
            }
        }

        var lastKeysToRemove = 0;
        for ( var i = this.keys.length - 2; i > 0; i ++ ) {
            if ( this.keys[i] >= endTime ) {
                lastKeysToRemove ++;
            } else {
                break;
            }
        }

        // remove last keys first because it doesn't affect the position of the first keys (the otherway around doesn't work as easily)
        if ( ( firstKeysToRemove + lastKeysToRemove ) > 0 ) {
            this.keys = this.keys.splice( firstKeysToRemove, this.keys.length - lastKeysToRemove - firstKeysToRemove );;
        }

        return this;

    },

    /* NOTE: This is commented out because we really shouldn't have to handle unsorted key lists
     Tracks with out of order keys should be considered to be invalid.  - bhouston
     sort: function() {

     this.keys.sort( THREE.KeyframeTrack.keyComparer );

     return this;

     },*/

    // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
    // One could eventually ensure that all key.values in a track are all of the same type (otherwise interpolation makes no sense.)
    validate: function() {

        var prevKey = null;

        if ( this.keys.length === 0 ) {
            console.error( "  track is empty, no keys", this );
            return;
        }

        for ( var i = 0; i < this.keys.length; i ++ ) {

            var currKey = this.keys[i];

            if ( ! currKey ) {
                console.error( "  key is null in track", this, i );
                return;
            }

            if ( ( typeof currKey.time ) !== 'number' || isNaN( currKey.time ) ) {
                console.error( "  key.time is not a valid number", this, i, currKey );
                return;
            }

            if ( currKey.value === undefined || currKey.value === null) {
                console.error( "  key.value is null in track", this, i, currKey );
                return;
            }

            if ( prevKey && prevKey.time > currKey.time ) {
                console.error( "  key.time is less than previous key time, out of order keys", this, i, currKey, prevKey );
                return;
            }

            prevKey = currKey;

        }

        return this;

    },

    // currently only removes equivalent sequential keys (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0), which are common in morph target animations
    optimize: function() {

        var newKeys = [];
        var prevKey = this.keys[0];
        newKeys.push( prevKey );

        var equalsFunc = THREE.AnimationUtils.getEqualsFunc( prevKey.value );

        for ( var i = 1; i < this.keys.length - 1; i ++ ) {
            var currKey = this.keys[i];
            var nextKey = this.keys[i+1];

            // if prevKey & currKey are the same time, remove currKey.  If you want immediate adjacent keys, use an epsilon offset
            // it is not possible to have two keys at the same time as we sort them.  The sort is not stable on keys with the same time.
            if ( ( prevKey.time === currKey.time ) ) {

                continue;

            }

            // remove completely unnecessary keyframes that are the same as their prev and next keys
            if ( this.compareValues( prevKey.value, currKey.value ) && this.compareValues( currKey.value, nextKey.value ) ) {

                continue;

            }

            // determine if interpolation is required
            prevKey.constantToNext = this.compareValues( prevKey.value, currKey.value );

            newKeys.push( currKey );
            prevKey = currKey;
        }
        newKeys.push( this.keys[ this.keys.length - 1 ] );

        this.keys = newKeys;

        return this;

    }

};

THREE.KeyframeTrack.keyComparer = function keyComparator(key0, key1) {
    return key0.time - key1.time;
};

THREE.KeyframeTrack.parse = function( json ) {

    if ( json.type === undefined ) throw new Error( "track type undefined, can not parse" );

    var trackType = THREE.KeyframeTrack.GetTrackTypeForTypeName( json.type );

    return trackType.parse( json );

};

THREE.KeyframeTrack.GetTrackTypeForTypeName = function( typeName ) {
    switch( typeName.toLowerCase() ) {
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
            return THREE.VectorKeyframeTrack;

        case "quaternion":
            return THREE.QuaternionKeyframeTrack;

        case "integer":
        case "scalar":
        case "double":
        case "float":
        case "number":
            return THREE.NumberKeyframeTrack;

        case "bool":
        case "boolean":
            return THREE.BooleanKeyframeTrack;

        case "string":
            return THREE.StringKeyframeTrack;
    };

    throw new Error( "Unsupported typeName: " + typeName );
};

// File:src/animation/PropertyBinding.js

/**
 *
 * A track bound to a real value in the scene graph.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.PropertyBinding = function ( rootNode, trackName ) {

    this.rootNode = rootNode;
    this.trackName = trackName;
    this.referenceCount = 0;
    this.originalValue = null; // the value of the property before it was controlled by this binding

    var parseResults = THREE.PropertyBinding.parseTrackName( trackName );

    this.directoryName = parseResults.directoryName;
    this.nodeName = parseResults.nodeName;
    this.objectName = parseResults.objectName;
    this.objectIndex = parseResults.objectIndex;
    this.propertyName = parseResults.propertyName;
    this.propertyIndex = parseResults.propertyIndex;

    this.node = THREE.PropertyBinding.findNode( rootNode, this.nodeName ) || rootNode;

    this.cumulativeValue = null;
    this.cumulativeWeight = 0;
};

THREE.PropertyBinding.prototype = {

    constructor: THREE.PropertyBinding,

    reset: function() {

        this.cumulativeValue = null;
        this.cumulativeWeight = 0;

    },

    accumulate: function( value, weight ) {

        if ( ! this.isBound ) this.bind();

        if ( this.cumulativeWeight === 0 ) {

            if ( weight > 0 ) {

                if ( this.cumulativeValue === null ) {
                    this.cumulativeValue = THREE.AnimationUtils.clone( value );
                }
                this.cumulativeWeight = weight;

            }

        } else {

            var lerpAlpha = weight / ( this.cumulativeWeight + weight );
            this.cumulativeValue = this.lerpValue( this.cumulativeValue, value, lerpAlpha );
            this.cumulativeWeight += weight;

        }

    },

    unbind: function() {

        if ( ! this.isBound ) return;

        this.setValue( this.originalValue );

        this.setValue = null;
        this.getValue = null;
        this.lerpValue = null;
        this.equalsValue = null;
        this.triggerDirty = null;
        this.isBound = false;

    },

    // bind to the real property in the scene graph, remember original value, memorize various accessors for speed/inefficiency
    bind: function() {

        if ( this.isBound ) return;

        var targetObject = this.node;

        // ensure there is a value node
        if ( ! targetObject ) {
            console.error( "  trying to update node for track: " + this.trackName + " but it wasn't found." );
            return;
        }

        if ( this.objectName ) {
            // special case were we need to reach deeper into the hierarchy to get the face materials....
            if ( this.objectName === "materials" ) {
                if ( ! targetObject.material ) {
                    console.error( '  can not bind to material as node does not have a material', this );
                    return;
                }
                if ( ! targetObject.material.materials ) {
                    console.error( '  can not bind to material.materials as node.material does not have a materials array', this );
                    return;
                }
                targetObject = targetObject.material.materials;
            } else if ( this.objectName === "bones" ) {
                if ( ! targetObject.skeleton ) {
                    console.error( '  can not bind to bones as node does not have a skeleton', this );
                    return;
                }
                // potential future optimization: skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

                targetObject = targetObject.skeleton.bones;

                // support resolving morphTarget names into indices.
                for ( var i = 0; i < targetObject.length; i ++ ) {
                    if ( targetObject[i].name === this.objectIndex ) {
                        this.objectIndex = i;
                        break;
                    }
                }
            } else {

                if ( targetObject[ this.objectName ] === undefined ) {
                    console.error( '  can not bind to objectName of node, undefined', this );
                    return;
                }
                targetObject = targetObject[ this.objectName ];
            }

            if ( this.objectIndex !== undefined ) {
                if ( targetObject[ this.objectIndex ] === undefined ) {
                    console.error( "  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject );
                    return;
                }

                targetObject = targetObject[ this.objectIndex ];
            }

        }

        // special case mappings
        var nodeProperty = targetObject[ this.propertyName ];
        if ( ! nodeProperty ) {
            console.error( "  trying to update property for track: " + this.nodeName + '.' + this.propertyName + " but it wasn't found.", targetObject );
            return;
        }

        // access a sub element of the property array (only primitives are supported right now)
        if ( this.propertyIndex !== undefined ) {

            if ( this.propertyName === "morphTargetInfluences" ) {
                // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

                // support resolving morphTarget names into indices.
                if ( ! targetObject.geometry ) {
                    console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );
                }
                if ( ! targetObject.geometry.morphTargets ) {
                    console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );
                }

                for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {
                    if ( targetObject.geometry.morphTargets[i].name === this.propertyIndex ) {
                        this.propertyIndex = i;
                        break;
                    }
                }
            }

            this.setValue = function setValue_propertyIndexed( value ) {
                if ( ! this.equalsValue( nodeProperty[ this.propertyIndex ], value ) ) {
                    nodeProperty[ this.propertyIndex ] = value;
                    return true;
                }
                return false;
            };

            this.getValue = function getValue_propertyIndexed() {
                return nodeProperty[ this.propertyIndex ];
            };

        }
        // must use copy for Object3D.Euler/Quaternion
        else if ( nodeProperty.copy ) {

            this.setValue = function setValue_propertyObject( value ) {
                if ( ! this.equalsValue( nodeProperty, value ) ) {
                    nodeProperty.copy( value );
                    return true;
                }
                return false;
            }

            this.getValue = function getValue_propertyObject() {
                return nodeProperty;
            };

        }
        // otherwise just set the property directly on the node (do not use nodeProperty as it may not be a reference object)
        else {

            this.setValue = function setValue_property( value ) {
                if ( ! this.equalsValue( targetObject[ this.propertyName ], value ) ) {
                    targetObject[ this.propertyName ] = value;
                    return true;
                }
                return false;
            }

            this.getValue = function getValue_property() {
                return targetObject[ this.propertyName ];
            };

        }

        // trigger node dirty
        if ( targetObject.needsUpdate !== undefined ) { // material

            this.triggerDirty = function triggerDirty_needsUpdate() {
                this.node.needsUpdate = true;
            }

        } else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

            this.triggerDirty = function triggerDirty_matrixWorldNeedsUpdate() {
                targetObject.matrixWorldNeedsUpdate = true;
            }

        }

        this.originalValue = this.getValue();

        this.equalsValue = THREE.AnimationUtils.getEqualsFunc( this.originalValue );
        this.lerpValue = THREE.AnimationUtils.getLerpFunc( this.originalValue, true );

        this.isBound = true;

    },

    apply: function() {

        // for speed capture the setter pattern as a closure (sort of a memoization pattern: https://en.wikipedia.org/wiki/Memoization)
        if ( ! this.isBound ) this.bind();

        // early exit if there is nothing to apply.
        if ( this.cumulativeWeight > 0 ) {

            // blend with original value
            if ( this.cumulativeWeight < 1 ) {

                var remainingWeight = 1 - this.cumulativeWeight;
                var lerpAlpha = remainingWeight / ( this.cumulativeWeight + remainingWeight );
                this.cumulativeValue = this.lerpValue( this.cumulativeValue, this.originalValue, lerpAlpha );

            }

            var valueChanged = this.setValue( this.cumulativeValue );

            if ( valueChanged && this.triggerDirty ) {
                this.triggerDirty();
            }

            // reset accumulator
            this.cumulativeValue = null;
            this.cumulativeWeight = 0;

        }
    }

};


THREE.PropertyBinding.parseTrackName = function( trackName ) {

    // matches strings in the form of:
    //    nodeName.property
    //    nodeName.property[accessor]
    //    nodeName.material.property[accessor]
    //    uuid.property[accessor]
    //    uuid.objectName[objectIndex].propertyName[propertyIndex]
    //    parentName/nodeName.property
    //    parentName/parentName/nodeName.property[index]
    //	  .bone[Armature.DEF_cog].position
    // created and tested via https://regex101.com/#javascript

    var re = /^(([\w]+\/)*)([\w-\d]+)?(\.([\w]+)(\[([\w\d\[\]\_. ]+)\])?)?(\.([\w.]+)(\[([\w\d\[\]\_. ]+)\])?)$/;
    var matches = re.exec(trackName);

    if ( ! matches ) {
        throw new Error( "cannot parse trackName at all: " + trackName );
    }

    if (matches.index === re.lastIndex) {
        re.lastIndex++;
    }

    var results = {
        directoryName: matches[1],
        nodeName: matches[3], 	// allowed to be null, specified root node.
        objectName: matches[5],
        objectIndex: matches[7],
        propertyName: matches[9],
        propertyIndex: matches[11]	// allowed to be null, specifies that the whole property is set.
    };

    if ( results.propertyName === null || results.propertyName.length === 0 ) {
        throw new Error( "can not parse propertyName from trackName: " + trackName );
    }

    return results;

};

THREE.PropertyBinding.findNode = function( root, nodeName ) {

    function searchSkeleton( skeleton ) {

        for ( var i = 0; i < skeleton.bones.length; i ++ ) {

            var bone = skeleton.bones[i];

            if ( bone.name === nodeName ) {

                return bone;

            }
        }

        return null;

    }

    function searchNodeSubtree( children ) {

        for ( var i = 0; i < children.length; i ++ ) {

            var childNode = children[i];

            if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

                return childNode;

            }

            var result = searchNodeSubtree( childNode.children );

            if ( result ) return result;

        }

        return null;

    }

    //

    if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {

        return root;

    }

    // search into skeleton bones.
    if ( root.skeleton ) {

        var bone = searchSkeleton( root.skeleton );

        if ( bone ) {

            return bone;

        }
    }

    // search into node subtree.
    if ( root.children ) {

        var subTreeNode = searchNodeSubtree( root.children );

        if ( subTreeNode ) {

            return subTreeNode;

        }

    }

    return null;
}

// File:src/animation/tracks/VectorKeyframeTrack.js

/**
 *
 * A Track that interpolates Vectors
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.VectorKeyframeTrack = function ( name, keys ) {

    THREE.KeyframeTrack.call( this, name, keys );

    // local cache of value type to avoid allocations during runtime.
    this.result = this.keys[0].value.clone();

};

THREE.VectorKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );

THREE.VectorKeyframeTrack.prototype.constructor = THREE.VectorKeyframeTrack;

THREE.VectorKeyframeTrack.prototype.setResult = function( value ) {

    this.result.copy( value );

};

// memoization of the lerp function for speed.
// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
THREE.VectorKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {

    return value0.lerp( value1, alpha );

};

THREE.VectorKeyframeTrack.prototype.compareValues = function( value0, value1 ) {

    return value0.equals( value1 );

};

THREE.VectorKeyframeTrack.prototype.clone = function() {

    var clonedKeys = [];

    for ( var i = 0; i < this.keys.length; i ++ ) {

        var key = this.keys[i];
        clonedKeys.push( {
            time: key.time,
            value: key.value.clone()
        } );
    }

    return new THREE.VectorKeyframeTrack( this.name, clonedKeys );

};

THREE.VectorKeyframeTrack.parse = function( json ) {

    var elementCount = json.keys[0].value.length;
    var valueType = THREE[ 'Vector' + elementCount ];

    var keys = [];

    for ( var i = 0; i < json.keys.length; i ++ ) {
        var jsonKey = json.keys[i];
        keys.push( {
            value: new valueType().fromArray( jsonKey.value ),
            time: jsonKey.time
        } );
    }

    return new THREE.VectorKeyframeTrack( json.name, keys );

};

// File:src/animation/tracks/QuaternionKeyframeTrack.js

/**
 *
 * A Track that interpolates Quaternion
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.QuaternionKeyframeTrack = function ( name, keys ) {

    THREE.KeyframeTrack.call( this, name, keys );

    // local cache of value type to avoid allocations during runtime.
    this.result = this.keys[0].value.clone();

};

THREE.QuaternionKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );

THREE.QuaternionKeyframeTrack.prototype.constructor = THREE.QuaternionKeyframeTrack;

THREE.QuaternionKeyframeTrack.prototype.setResult = function( value ) {

    this.result.copy( value );

};

// memoization of the lerp function for speed.
// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
THREE.QuaternionKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {

    return value0.slerp( value1, alpha );

};

THREE.QuaternionKeyframeTrack.prototype.compareValues = function( value0, value1 ) {

    return value0.equals( value1 );

};

THREE.QuaternionKeyframeTrack.prototype.multiply = function( quat ) {

    for ( var i = 0; i < this.keys.length; i ++ ) {

        this.keys[i].value.multiply( quat );

    }

    return this;

};

THREE.QuaternionKeyframeTrack.prototype.clone = function() {

    var clonedKeys = [];

    for ( var i = 0; i < this.keys.length; i ++ ) {

        var key = this.keys[i];
        clonedKeys.push( {
            time: key.time,
            value: key.value.clone()
        } );
    }

    return new THREE.QuaternionKeyframeTrack( this.name, clonedKeys );

};

THREE.QuaternionKeyframeTrack.parse = function( json ) {

    var keys = [];

    for ( var i = 0; i < json.keys.length; i ++ ) {
        var jsonKey = json.keys[i];
        keys.push( {
            value: new THREE.Quaternion().fromArray( jsonKey.value ),
            time: jsonKey.time
        } );
    }

    return new THREE.QuaternionKeyframeTrack( json.name, keys );

};

// File:src/animation/tracks/StringKeyframeTrack.js

/**
 *
 * A Track that interpolates Strings
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.StringKeyframeTrack = function ( name, keys ) {

    THREE.KeyframeTrack.call( this, name, keys );

    // local cache of value type to avoid allocations during runtime.
    this.result = this.keys[0].value;

};

THREE.StringKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );

THREE.StringKeyframeTrack.prototype.constructor = THREE.StringKeyframeTrack;

THREE.StringKeyframeTrack.prototype.setResult = function( value ) {

    this.result = value;

};

// memoization of the lerp function for speed.
// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
THREE.StringKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {

    return ( alpha < 1.0 ) ? value0 : value1;

};

THREE.StringKeyframeTrack.prototype.compareValues = function( value0, value1 ) {

    return ( value0 === value1 );

};

THREE.StringKeyframeTrack.prototype.clone = function() {

    var clonedKeys = [];

    for ( var i = 0; i < this.keys.length; i ++ ) {

        var key = this.keys[i];
        clonedKeys.push( {
            time: key.time,
            value: key.value
        } );
    }

    return new THREE.StringKeyframeTrack( this.name, clonedKeys );

};

THREE.StringKeyframeTrack.parse = function( json ) {

    return new THREE.StringKeyframeTrack( json.name, json.keys );

};

// File:src/animation/tracks/BooleanKeyframeTrack.js

/**
 *
 * A Track that interpolates Boolean
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.BooleanKeyframeTrack = function ( name, keys ) {

    THREE.KeyframeTrack.call( this, name, keys );

    // local cache of value type to avoid allocations during runtime.
    this.result = this.keys[0].value;

};

THREE.BooleanKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );

THREE.BooleanKeyframeTrack.prototype.constructor = THREE.BooleanKeyframeTrack;

THREE.BooleanKeyframeTrack.prototype.setResult = function( value ) {

    this.result = value;

};

// memoization of the lerp function for speed.
// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
THREE.BooleanKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {

    return ( alpha < 1.0 ) ? value0 : value1;

};

THREE.BooleanKeyframeTrack.prototype.compareValues = function( value0, value1 ) {

    return ( value0 === value1 );

};

THREE.BooleanKeyframeTrack.prototype.clone = function() {

    var clonedKeys = [];

    for ( var i = 0; i < this.keys.length; i ++ ) {

        var key = this.keys[i];
        clonedKeys.push( {
            time: key.time,
            value: key.value
        } );
    }

    return new THREE.BooleanKeyframeTrack( this.name, clonedKeys );

};

THREE.BooleanKeyframeTrack.parse = function( json ) {

    return new THREE.BooleanKeyframeTrack( json.name, json.keys );

};

// File:src/animation/tracks/NumberKeyframeTrack.js

/**
 *
 * A Track that interpolates Numbers
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.NumberKeyframeTrack = function ( name, keys ) {

    THREE.KeyframeTrack.call( this, name, keys );

    // local cache of value type to avoid allocations during runtime.
    this.result = this.keys[0].value;

};

THREE.NumberKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );

THREE.NumberKeyframeTrack.prototype.constructor = THREE.NumberKeyframeTrack;

THREE.NumberKeyframeTrack.prototype.setResult = function( value ) {

    this.result = value;

};

// memoization of the lerp function for speed.
// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
THREE.NumberKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {

    return value0 * ( 1 - alpha ) + value1 * alpha;

};

THREE.NumberKeyframeTrack.prototype.compareValues = function( value0, value1 ) {

    return ( value0 === value1 );

};

THREE.NumberKeyframeTrack.prototype.clone = function() {

    var clonedKeys = [];

    for ( var i = 0; i < this.keys.length; i ++ ) {

        var key = this.keys[i];
        clonedKeys.push( {
            time: key.time,
            value: key.value
        } );
    }

    return new THREE.NumberKeyframeTrack( this.name, clonedKeys );

};

THREE.NumberKeyframeTrack.parse = function( json ) {

    return new THREE.NumberKeyframeTrack( json.name, json.keys );

};

// File:src/cameras/Camera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Camera = function () {

    THREE.Object3D.call( this );

    this.type = 'Camera';

    this.matrixWorldInverse = new THREE.Matrix4();
    this.projectionMatrix = new THREE.Matrix4();

};

THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );
THREE.Camera.prototype.constructor = THREE.Camera;

THREE.Camera.prototype.getWorldDirection = function () {

    var quaternion = new THREE.Quaternion();

    return function ( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();

        this.getWorldQuaternion( quaternion );

        return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

    };

}();

THREE.Camera.prototype.lookAt = function () {

    // This routine does not support cameras with rotated and/or translated parent(s)

    var m1 = new THREE.Matrix4();

    return function ( vector ) {

        m1.lookAt( this.position, vector, this.up );

        this.quaternion.setFromRotationMatrix( m1 );

    };

}();

THREE.Camera.prototype.clone = function () {

    return new this.constructor().copy( this );

};

THREE.Camera.prototype.copy = function ( source ) {

    THREE.Object3D.prototype.copy.call( this, source );

    this.matrixWorldInverse.copy( source.matrixWorldInverse );
    this.projectionMatrix.copy( source.projectionMatrix );

    return this;

};

// File:src/cameras/CubeCamera.js

/**
 * Camera for rendering cube maps
 *	- renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CubeCamera = function ( near, far, cubeResolution ) {

    THREE.Object3D.call( this );

    this.type = 'CubeCamera';

    var fov = 90, aspect = 1;

    var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
    cameraPX.up.set( 0, - 1, 0 );
    cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
    this.add( cameraPX );

    var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
    cameraNX.up.set( 0, - 1, 0 );
    cameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );
    this.add( cameraNX );

    var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
    cameraPY.up.set( 0, 0, 1 );
    cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
    this.add( cameraPY );

    var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
    cameraNY.up.set( 0, 0, - 1 );
    cameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );
    this.add( cameraNY );

    var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
    cameraPZ.up.set( 0, - 1, 0 );
    cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
    this.add( cameraPZ );

    var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
    cameraNZ.up.set( 0, - 1, 0 );
    cameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );
    this.add( cameraNZ );

    this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );

    this.updateCubeMap = function ( renderer, scene ) {

        if ( this.parent === null ) this.updateMatrixWorld();

        var renderTarget = this.renderTarget;
        var generateMipmaps = renderTarget.texture.generateMipmaps;

        renderTarget.texture.generateMipmaps = false;

        renderTarget.activeCubeFace = 0;
        renderer.render( scene, cameraPX, renderTarget );

        renderTarget.activeCubeFace = 1;
        renderer.render( scene, cameraNX, renderTarget );

        renderTarget.activeCubeFace = 2;
        renderer.render( scene, cameraPY, renderTarget );

        renderTarget.activeCubeFace = 3;
        renderer.render( scene, cameraNY, renderTarget );

        renderTarget.activeCubeFace = 4;
        renderer.render( scene, cameraPZ, renderTarget );

        renderTarget.texture.generateMipmaps = generateMipmaps;

        renderTarget.activeCubeFace = 5;
        renderer.render( scene, cameraNZ, renderTarget );

        renderer.setRenderTarget( null );

    };

};

THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );
THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;

// File:src/cameras/OrthographicCamera.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {

    THREE.Camera.call( this );

    this.type = 'OrthographicCamera';

    this.zoom = 1;

    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;

    this.near = ( near !== undefined ) ? near : 0.1;
    this.far = ( far !== undefined ) ? far : 2000;

    this.updateProjectionMatrix();

};

THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );
THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;

THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {

    var dx = ( this.right - this.left ) / ( 2 * this.zoom );
    var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
    var cx = ( this.right + this.left ) / 2;
    var cy = ( this.top + this.bottom ) / 2;

    this.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );

};

THREE.OrthographicCamera.prototype.copy = function ( source ) {

    THREE.Camera.prototype.copy.call( this, source );

    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;

    this.zoom = source.zoom;

    return this;

};

THREE.OrthographicCamera.prototype.toJSON = function ( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;

    return data;

};

// File:src/cameras/PerspectiveCamera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {

    THREE.Camera.call( this );

    this.type = 'PerspectiveCamera';

    this.zoom = 1;

    this.fov = fov !== undefined ? fov : 50;
    this.aspect = aspect !== undefined ? aspect : 1;
    this.near = near !== undefined ? near : 0.1;
    this.far = far !== undefined ? far : 2000;

    this.updateProjectionMatrix();

};

THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );
THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;


/**
 * Uses Focal Length (in mm) to estimate and set FOV
 * 35mm (full-frame) camera is used if frame size is not specified;
 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
 */

THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {

    if ( frameHeight === undefined ) frameHeight = 24;

    this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
    this.updateProjectionMatrix();

};


/**
 * Sets an offset in a larger frustum. This is useful for multi-window or
 * multi-monitor/multi-machine setups.
 *
 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
 * the monitors are in grid like this
 *
 *   +---+---+---+
 *   | A | B | C |
 *   +---+---+---+
 *   | D | E | F |
 *   +---+---+---+
 *
 * then for each monitor you would call it like this
 *
 *   var w = 1920;
 *   var h = 1080;
 *   var fullWidth = w * 3;
 *   var fullHeight = h * 2;
 *
 *   --A--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
 *   --B--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
 *   --C--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
 *   --D--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
 *   --E--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
 *   --F--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
 *
 *   Note there is no reason monitors have to be the same size or in a grid.
 */

THREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {

    this.fullWidth = fullWidth;
    this.fullHeight = fullHeight;
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;

    this.updateProjectionMatrix();

};


THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {

    var fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );

    if ( this.fullWidth ) {

        var aspect = this.fullWidth / this.fullHeight;
        var top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;
        var bottom = - top;
        var left = aspect * bottom;
        var right = aspect * top;
        var width = Math.abs( right - left );
        var height = Math.abs( top - bottom );

        this.projectionMatrix.makeFrustum(
            left + this.x * width / this.fullWidth,
            left + ( this.x + this.width ) * width / this.fullWidth,
            top - ( this.y + this.height ) * height / this.fullHeight,
            top - this.y * height / this.fullHeight,
            this.near,
            this.far
        );

    } else {

        this.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );

    }

};

THREE.PerspectiveCamera.prototype.copy = function ( source ) {

    THREE.Camera.prototype.copy.call( this, source );

    this.fov = source.fov;
    this.aspect = source.aspect;
    this.near = source.near;
    this.far = source.far;

    this.zoom = source.zoom;

    return this;

};

THREE.PerspectiveCamera.prototype.toJSON = function ( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    data.object.zoom = this.zoom;
    data.object.fov = this.fov;
    data.object.aspect = this.aspect;
    data.object.near = this.near;
    data.object.far = this.far;

    return data;

};

// File:src/lights/Light.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Light = function ( color ) {

    THREE.Object3D.call( this );

    this.type = 'Light';

    this.color = new THREE.Color( color );

    this.receiveShadow = undefined;

};

THREE.Light.prototype = Object.create( THREE.Object3D.prototype );
THREE.Light.prototype.constructor = THREE.Light;

Object.defineProperties( THREE.Light.prototype, {
    onlyShadow: {
        set: function ( value ) {
            console.warn( 'THREE.Light: .onlyShadow has been removed.' );
        }
    },
    shadowCameraFov: {
        set: function ( value ) {
            this.shadow.camera.fov = value;
        }
    },
    shadowCameraLeft: {
        set: function ( value ) {
            this.shadow.camera.left = value;
        }
    },
    shadowCameraRight: {
        set: function ( value ) {
            this.shadow.camera.right = value;
        }
    },
    shadowCameraTop: {
        set: function ( value ) {
            this.shadow.camera.top = value;
        }
    },
    shadowCameraBottom: {
        set: function ( value ) {
            this.shadow.camera.bottom = value;
        }
    },
    shadowCameraNear: {
        set: function ( value ) {
            this.shadow.camera.near = value;
        }
    },
    shadowCameraFar: {
        set: function ( value ) {
            this.shadow.camera.far = value;
        }
    },
    shadowCameraVisible: {
        set: function ( value ) {
            console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow ) instead.' );
        }
    },
    shadowBias: {
        set: function ( value ) {
            this.shadow.bias = value;
        }
    },
    shadowDarkness: {
        set: function ( value ) {
            this.shadow.darkness = value;
        }
    },
    shadowMapWidth: {
        set: function ( value ) {
            this.shadow.mapSize.width = value;
        }
    },
    shadowMapHeight: {
        set: function ( value ) {
            this.shadow.mapSize.height = value;
        }
    }
} );

THREE.Light.prototype.copy = function ( source ) {

    THREE.Object3D.prototype.copy.call( this, source );

    this.color.copy( source.color );

    return this;

};

THREE.Light.prototype.toJSON = function ( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    data.object.color = this.color.getHex();
    if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

    if ( this.intensity !== undefined ) data.object.intensity = this.intensity;
    if ( this.distance !== undefined ) data.object.distance = this.distance;
    if ( this.angle !== undefined ) data.object.angle = this.angle;
    if ( this.decay !== undefined ) data.object.decay = this.decay;
    if ( this.exponent !== undefined ) data.object.exponent = this.exponent;

    return data;

};

// File:src/lights/LightShadow.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LightShadow = function ( camera ) {

    this.camera = camera;

    this.bias = 0;
    this.darkness = 1;

    this.mapSize = new THREE.Vector2( 512, 512 );

    this.map = null;
    this.matrix = null;

};

THREE.LightShadow.prototype = {

    constructor: THREE.LightShadow,

    copy: function ( source ) {

        this.camera = source.camera.clone();

        this.bias = source.bias;
        this.darkness = source.darkness;

        this.mapSize.copy( source.mapSize );

    },

    clone: function () {

        return new this.constructor().copy( this );

    }

};

// File:src/lights/AmbientLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AmbientLight = function ( color ) {

    THREE.Light.call( this, color );

    this.type = 'AmbientLight';

    this.castShadow = undefined;

};

THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );
THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;

// File:src/lights/DirectionalLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DirectionalLight = function ( color, intensity ) {

    THREE.Light.call( this, color );

    this.type = 'DirectionalLight';

    this.position.set( 0, 1, 0 );
    this.updateMatrix();

    this.target = new THREE.Object3D();

    this.intensity = ( intensity !== undefined ) ? intensity : 1;

    this.shadow = new THREE.LightShadow( new THREE.OrthographicCamera( - 500, 500, 500, - 500, 50, 5000 ) );

};

THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );
THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;

THREE.DirectionalLight.prototype.copy = function ( source ) {

    THREE.Light.prototype.copy.call( this, source );

    this.intensity = source.intensity;
    this.target = source.target.clone();

    this.shadow = source.shadow.clone();

    return this;

};

// File:src/lights/HemisphereLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {

    THREE.Light.call( this, skyColor );

    this.type = 'HemisphereLight';

    this.castShadow = undefined;

    this.position.set( 0, 1, 0 );
    this.updateMatrix();

    this.groundColor = new THREE.Color( groundColor );
    this.intensity = ( intensity !== undefined ) ? intensity : 1;

};

THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );
THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;

THREE.HemisphereLight.prototype.copy = function ( source ) {

    THREE.Light.prototype.copy.call( this, source );

    this.groundColor.copy( source.groundColor );
    this.intensity = source.intensity;

    return this;

};

// File:src/lights/PointLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */


THREE.PointLight = function ( color, intensity, distance, decay ) {

    THREE.Light.call( this, color );

    this.type = 'PointLight';

    this.intensity = ( intensity !== undefined ) ? intensity : 1;
    this.distance = ( distance !== undefined ) ? distance : 0;
    this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

    this.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 90, 1, 1, 500 ) );

};

THREE.PointLight.prototype = Object.create( THREE.Light.prototype );
THREE.PointLight.prototype.constructor = THREE.PointLight;

THREE.PointLight.prototype.copy = function ( source ) {

    THREE.Light.prototype.copy.call( this, source );

    this.intensity = source.intensity;
    this.distance = source.distance;
    this.decay = source.decay;

    this.shadow = source.shadow.clone();

    return this;

};

// File:src/lights/SpotLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpotLight = function ( color, intensity, distance, angle, exponent, decay ) {

    THREE.Light.call( this, color );

    this.type = 'SpotLight';

    this.position.set( 0, 1, 0 );
    this.updateMatrix();

    this.target = new THREE.Object3D();

    this.intensity = ( intensity !== undefined ) ? intensity : 1;
    this.distance = ( distance !== undefined ) ? distance : 0;
    this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
    this.exponent = ( exponent !== undefined ) ? exponent : 10;
    this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

    this.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 50, 1, 50, 5000 ) );

};

THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );
THREE.SpotLight.prototype.constructor = THREE.SpotLight;

THREE.SpotLight.prototype.copy = function ( source ) {

    THREE.Light.prototype.copy.call( this, source );

    this.intensity = source.intensity;
    this.distance = source.distance;
    this.angle = source.angle;
    this.exponent = source.exponent;
    this.decay = source.decay;

    this.target = source.target.clone();

    this.shadow = source.shadow.clone();

    return this;

};

// File:src/loaders/Cache.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Cache = {

    enabled: false,

    files: {},

    add: function ( key, file ) {

        if ( this.enabled === false ) return;

        // console.log( 'THREE.Cache', 'Adding key:', key );

        this.files[ key ] = file;

    },

    get: function ( key ) {

        if ( this.enabled === false ) return;

        // console.log( 'THREE.Cache', 'Checking key:', key );

        return this.files[ key ];

    },

    remove: function ( key ) {

        delete this.files[ key ];

    },

    clear: function () {

        this.files = {};

    }

};

// File:src/loaders/Loader.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Loader = function () {

    this.onLoadStart = function () {};
    this.onLoadProgress = function () {};
    this.onLoadComplete = function () {};

};

THREE.Loader.prototype = {

    constructor: THREE.Loader,

    crossOrigin: undefined,

    extractUrlBase: function ( url ) {

        var parts = url.split( '/' );

        if ( parts.length === 1 ) return './';

        parts.pop();

        return parts.join( '/' ) + '/';

    },

    initMaterials: function ( materials, texturePath, crossOrigin ) {

        var array = [];

        for ( var i = 0; i < materials.length; ++ i ) {

            array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

        }

        return array;

    },

    createMaterial: ( function () {

        var color, textureLoader, materialLoader;

        return function ( m, texturePath, crossOrigin ) {

            if ( color === undefined ) color = new THREE.Color();
            if ( textureLoader === undefined ) textureLoader = new THREE.TextureLoader();
            if ( materialLoader === undefined ) materialLoader = new THREE.MaterialLoader();

            // convert from old material format

            var textures = {};

            function loadTexture( path, repeat, offset, wrap, anisotropy ) {

                var fullPath = texturePath + path;
                var loader = THREE.Loader.Handlers.get( fullPath );

                var texture;

                if ( loader !== null ) {

                    texture = loader.load( fullPath );

                } else {

                    textureLoader.setCrossOrigin( crossOrigin );
                    texture = textureLoader.load( fullPath );

                }

                if ( repeat !== undefined ) {

                    texture.repeat.fromArray( repeat );

                    if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
                    if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;

                }

                if ( offset !== undefined ) {

                    texture.offset.fromArray( offset );

                }

                if ( wrap !== undefined ) {

                    if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = THREE.RepeatWrapping;
                    if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = THREE.MirroredRepeatWrapping;

                    if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = THREE.RepeatWrapping;
                    if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = THREE.MirroredRepeatWrapping;

                }

                if ( anisotropy !== undefined ) {

                    texture.anisotropy = anisotropy;

                }

                var uuid = THREE.Math.generateUUID();

                textures[ uuid ] = texture;

                return uuid;

            }

            //

            var json = {
                uuid: THREE.Math.generateUUID(),
                type: 'MeshLambertMaterial'
            };

            for ( var name in m ) {

                var value = m[ name ];

                switch ( name ) {
                    case 'DbgColor':
                        json.color = value;
                        break;
                    case 'DbgIndex':
                    case 'opticalDensity':
                    case 'illumination':
                        // These were never supported
                        break;
                    case 'DbgName':
                        json.name = value;
                        break;
                    case 'blending':
                        json.blending = THREE[ value ];
                        break;
                    case 'colorDiffuse':
                        json.color = color.fromArray( value ).getHex();
                        break;
                    case 'colorSpecular':
                        json.specular = color.fromArray( value ).getHex();
                        break;
                    case 'colorEmissive':
                        json.emissive = color.fromArray( value ).getHex();
                        break;
                    case 'specularCoef':
                        json.shininess = value;
                        break;
                    case 'shading':
                        if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
                        if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
                        break;
                    case 'mapDiffuse':
                        json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
                        break;
                    case 'mapDiffuseRepeat':
                    case 'mapDiffuseOffset':
                    case 'mapDiffuseWrap':
                    case 'mapDiffuseAnisotropy':
                        break;
                    case 'mapLight':
                        json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
                        break;
                    case 'mapLightRepeat':
                    case 'mapLightOffset':
                    case 'mapLightWrap':
                    case 'mapLightAnisotropy':
                        break;
                    case 'mapAO':
                        json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
                        break;
                    case 'mapAORepeat':
                    case 'mapAOOffset':
                    case 'mapAOWrap':
                    case 'mapAOAnisotropy':
                        break;
                    case 'mapBump':
                        json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
                        break;
                    case 'mapBumpScale':
                        json.bumpScale = value;
                        break;
                    case 'mapBumpRepeat':
                    case 'mapBumpOffset':
                    case 'mapBumpWrap':
                    case 'mapBumpAnisotropy':
                        break;
                    case 'mapNormal':
                        json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
                        break;
                    case 'mapNormalFactor':
                        json.normalScale = [ value, value ];
                        break;
                    case 'mapNormalRepeat':
                    case 'mapNormalOffset':
                    case 'mapNormalWrap':
                    case 'mapNormalAnisotropy':
                        break;
                    case 'mapSpecular':
                        json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
                        break;
                    case 'mapSpecularRepeat':
                    case 'mapSpecularOffset':
                    case 'mapSpecularWrap':
                    case 'mapSpecularAnisotropy':
                        break;
                    case 'mapAlpha':
                        json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
                        break;
                    case 'mapAlphaRepeat':
                    case 'mapAlphaOffset':
                    case 'mapAlphaWrap':
                    case 'mapAlphaAnisotropy':
                        break;
                    case 'flipSided':
                        json.side = THREE.BackSide;
                        break;
                    case 'doubleSided':
                        json.side = THREE.DoubleSide;
                        break;
                    case 'transparency':
                        console.warn( 'THREE.Loader: transparency has been renamed to opacity' );
                        json.opacity = value;
                        break;
                    case 'opacity':
                    case 'transparent':
                    case 'depthTest':
                    case 'depthWrite':
                    case 'transparent':
                    case 'visible':
                    case 'wireframe':
                        json[ name ] = value;
                        break;
                    case 'vertexColors':
                        if ( value === true ) json.vertexColors = THREE.VertexColors;
                        if ( value === 'face' ) json.vertexColors = THREE.FaceColors;
                        break;
                    default:
                        console.error( 'Loader.createMaterial: Unsupported', name, value );
                        break;
                }

            }

            if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;
            if ( json.opacity < 1 ) json.transparent = true;

            materialLoader.setTextures( textures );

            return materialLoader.parse( json );

        };

    } )()

};

THREE.Loader.Handlers = {

    handlers: [],

    add: function ( regex, loader ) {

        this.handlers.push( regex, loader );

    },

    get: function ( file ) {

        var handlers = this.handlers;

        for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

            var regex = handlers[ i ];
            var loader  = handlers[ i + 1 ];

            if ( regex.test( file ) ) {

                return loader;

            }

        }

        return null;

    }

};

// File:src/loaders/XHRLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.XHRLoader = function ( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.XHRLoader.prototype = {

    constructor: THREE.XHRLoader,

    load: function ( url, onLoad, onProgress, onError ) {

        var scope = this;

        var cached = THREE.Cache.get( url );

        if ( cached !== undefined ) {

            if ( onLoad ) {

                setTimeout( function () {

                    onLoad( cached );

                }, 0 );

            }

            return cached;

        }

        var request = new XMLHttpRequest();
        request.open( 'GET', url, true );

        request.addEventListener( 'load', function ( event ) {

            var response = event.target.response;

            THREE.Cache.add( url, response );

            if ( onLoad ) onLoad( response );

            scope.manager.itemEnd( url );

        }, false );

        if ( onProgress !== undefined ) {

            request.addEventListener( 'progress', function ( event ) {

                onProgress( event );

            }, false );

        }

        request.addEventListener( 'error', function ( event ) {

            if ( onError ) onError( event );

            scope.manager.itemError( url );

        }, false );

        if ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;
        if ( this.responseType !== undefined ) request.responseType = this.responseType;
        if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

        request.send( null );

        scope.manager.itemStart( url );

        return request;

    },

    setResponseType: function ( value ) {

        this.responseType = value;

    },

    setCrossOrigin: function ( value ) {

        this.crossOrigin = value;

    },

    setWithCredentials: function ( value ) {

        this.withCredentials = value;

    }

};

// File:src/loaders/ImageLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ImageLoader = function ( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.ImageLoader.prototype = {

    constructor: THREE.ImageLoader,

    load: function ( url, onLoad, onProgress, onError ) {

        var scope = this;

        var cached = THREE.Cache.get( url );

        if ( cached !== undefined ) {

            scope.manager.itemStart( url );

            if ( onLoad ) {

                setTimeout( function () {

                    onLoad( cached );

                    scope.manager.itemEnd( url );

                }, 0 );

            } else {

                scope.manager.itemEnd( url );

            }

            return cached;

        }

        var image = document.createElement( 'img' );

        image.addEventListener( 'load', function ( event ) {

            THREE.Cache.add( url, this );

            if ( onLoad ) onLoad( this );

            scope.manager.itemEnd( url );

        }, false );

        if ( onProgress !== undefined ) {

            image.addEventListener( 'progress', function ( event ) {

                onProgress( event );

            }, false );

        }

        image.addEventListener( 'error', function ( event ) {

            if ( onError ) onError( event );

            scope.manager.itemError( url );

        }, false );

        if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

        scope.manager.itemStart( url );

        image.src = url;

        return image;

    },

    setCrossOrigin: function ( value ) {

        this.crossOrigin = value;

    }

};

// File:src/loaders/JSONLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.JSONLoader = function ( manager ) {

    if ( typeof manager === 'boolean' ) {

        console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
        manager = undefined;

    }

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

    this.withCredentials = false;

};

THREE.JSONLoader.prototype = {

    constructor: THREE.JSONLoader,

    // Deprecated

    get statusDomElement () {

        if ( this._statusDomElement === undefined ) {

            this._statusDomElement = document.createElement( 'div' );

        }

        console.warn( 'THREE.JSONLoader: .statusDomElement has been removed.' );
        return this._statusDomElement;

    },

    load: function( url, onLoad, onProgress, onError ) {

        var scope = this;

        var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );

        var loader = new THREE.XHRLoader( this.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.setWithCredentials( this.withCredentials );
        loader.load( url, function ( text ) {

            var json = JSON.parse( text );
            var metadata = json.metadata;

            if ( metadata !== undefined ) {

                if ( metadata.type === 'object' ) {

                    console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
                    return;

                }

                if ( metadata.type === 'scene' ) {

                    console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
                    return;

                }

            }

            var object = scope.parse( json, texturePath );
            onLoad( object.geometry, object.materials );

        } );

    },

    setCrossOrigin: function ( value ) {

        this.crossOrigin = value;

    },

    setTexturePath: function ( value ) {

        this.texturePath = value;

    },

    parse: function ( json, texturePath ) {

        var geometry = new THREE.Geometry(),
            scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

        parseModel( scale );

        parseSkin();
        parseMorphing( scale );
        parseAnimations();

        geometry.computeFaceNormals();
        geometry.computeBoundingSphere();

        function parseModel( scale ) {

            function isBitSet( value, position ) {

                return value & ( 1 << position );

            }

            var i, j, fi,

                offset, zLength,

                colorIndex, normalIndex, uvIndex, materialIndex,

                type,
                isQuad,
                hasMaterial,
                hasFaceVertexUv,
                hasFaceNormal, hasFaceVertexNormal,
                hasFaceColor, hasFaceVertexColor,

                vertex, face, faceA, faceB, hex, normal,

                uvLayer, uv, u, v,

                faces = json.faces,
                vertices = json.vertices,
                normals = json.normals,
                colors = json.colors,

                nUvLayers = 0;

            if ( json.uvs !== undefined ) {

                // disregard empty arrays

                for ( i = 0; i < json.uvs.length; i ++ ) {

                    if ( json.uvs[ i ].length ) nUvLayers ++;

                }

                for ( i = 0; i < nUvLayers; i ++ ) {

                    geometry.faceVertexUvs[ i ] = [];

                }

            }

            offset = 0;
            zLength = vertices.length;

            while ( offset < zLength ) {

                vertex = new THREE.Vector3();

                vertex.x = vertices[ offset ++ ] * scale;
                vertex.y = vertices[ offset ++ ] * scale;
                vertex.z = vertices[ offset ++ ] * scale;

                geometry.vertices.push( vertex );

            }

            offset = 0;
            zLength = faces.length;

            while ( offset < zLength ) {

                type = faces[ offset ++ ];


                isQuad              = isBitSet( type, 0 );
                hasMaterial         = isBitSet( type, 1 );
                hasFaceVertexUv     = isBitSet( type, 3 );
                hasFaceNormal       = isBitSet( type, 4 );
                hasFaceVertexNormal = isBitSet( type, 5 );
                hasFaceColor	     = isBitSet( type, 6 );
                hasFaceVertexColor  = isBitSet( type, 7 );

                // console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

                if ( isQuad ) {

                    faceA = new THREE.Face3();
                    faceA.a = faces[ offset ];
                    faceA.b = faces[ offset + 1 ];
                    faceA.c = faces[ offset + 3 ];

                    faceB = new THREE.Face3();
                    faceB.a = faces[ offset + 1 ];
                    faceB.b = faces[ offset + 2 ];
                    faceB.c = faces[ offset + 3 ];

                    offset += 4;

                    if ( hasMaterial ) {

                        materialIndex = faces[ offset ++ ];
                        faceA.materialIndex = materialIndex;
                        faceB.materialIndex = materialIndex;

                    }

                    // to get face <=> uv index correspondence

                    fi = geometry.faces.length;

                    if ( hasFaceVertexUv ) {

                        for ( i = 0; i < nUvLayers; i ++ ) {

                            uvLayer = json.uvs[ i ];

                            geometry.faceVertexUvs[ i ][ fi ] = [];
                            geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

                            for ( j = 0; j < 4; j ++ ) {

                                uvIndex = faces[ offset ++ ];

                                u = uvLayer[ uvIndex * 2 ];
                                v = uvLayer[ uvIndex * 2 + 1 ];

                                uv = new THREE.Vector2( u, v );

                                if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
                                if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

                            }

                        }

                    }

                    if ( hasFaceNormal ) {

                        normalIndex = faces[ offset ++ ] * 3;

                        faceA.normal.set(
                            normals[ normalIndex ++ ],
                            normals[ normalIndex ++ ],
                            normals[ normalIndex ]
                        );

                        faceB.normal.copy( faceA.normal );

                    }

                    if ( hasFaceVertexNormal ) {

                        for ( i = 0; i < 4; i ++ ) {

                            normalIndex = faces[ offset ++ ] * 3;

                            normal = new THREE.Vector3(
                                normals[ normalIndex ++ ],
                                normals[ normalIndex ++ ],
                                normals[ normalIndex ]
                            );


                            if ( i !== 2 ) faceA.vertexNormals.push( normal );
                            if ( i !== 0 ) faceB.vertexNormals.push( normal );

                        }

                    }


                    if ( hasFaceColor ) {

                        colorIndex = faces[ offset ++ ];
                        hex = colors[ colorIndex ];

                        faceA.color.setHex( hex );
                        faceB.color.setHex( hex );

                    }


                    if ( hasFaceVertexColor ) {

                        for ( i = 0; i < 4; i ++ ) {

                            colorIndex = faces[ offset ++ ];
                            hex = colors[ colorIndex ];

                            if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
                            if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );

                        }

                    }

                    geometry.faces.push( faceA );
                    geometry.faces.push( faceB );

                } else {

                    face = new THREE.Face3();
                    face.a = faces[ offset ++ ];
                    face.b = faces[ offset ++ ];
                    face.c = faces[ offset ++ ];

                    if ( hasMaterial ) {

                        materialIndex = faces[ offset ++ ];
                        face.materialIndex = materialIndex;

                    }

                    // to get face <=> uv index correspondence

                    fi = geometry.faces.length;

                    if ( hasFaceVertexUv ) {

                        for ( i = 0; i < nUvLayers; i ++ ) {

                            uvLayer = json.uvs[ i ];

                            geometry.faceVertexUvs[ i ][ fi ] = [];

                            for ( j = 0; j < 3; j ++ ) {

                                uvIndex = faces[ offset ++ ];

                                u = uvLayer[ uvIndex * 2 ];
                                v = uvLayer[ uvIndex * 2 + 1 ];

                                uv = new THREE.Vector2( u, v );

                                geometry.faceVertexUvs[ i ][ fi ].push( uv );

                            }

                        }

                    }

                    if ( hasFaceNormal ) {

                        normalIndex = faces[ offset ++ ] * 3;

                        face.normal.set(
                            normals[ normalIndex ++ ],
                            normals[ normalIndex ++ ],
                            normals[ normalIndex ]
                        );

                    }

                    if ( hasFaceVertexNormal ) {

                        for ( i = 0; i < 3; i ++ ) {

                            normalIndex = faces[ offset ++ ] * 3;

                            normal = new THREE.Vector3(
                                normals[ normalIndex ++ ],
                                normals[ normalIndex ++ ],
                                normals[ normalIndex ]
                            );

                            face.vertexNormals.push( normal );

                        }

                    }


                    if ( hasFaceColor ) {

                        colorIndex = faces[ offset ++ ];
                        face.color.setHex( colors[ colorIndex ] );

                    }


                    if ( hasFaceVertexColor ) {

                        for ( i = 0; i < 3; i ++ ) {

                            colorIndex = faces[ offset ++ ];
                            face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );

                        }

                    }

                    geometry.faces.push( face );

                }

            }

        };

        function parseSkin() {

            var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

            if ( json.skinWeights ) {

                for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

                    var x =                               json.skinWeights[ i ];
                    var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
                    var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
                    var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

                    geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );

                }

            }

            if ( json.skinIndices ) {

                for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

                    var a =                               json.skinIndices[ i ];
                    var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
                    var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
                    var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

                    geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );

                }

            }

            geometry.bones = json.bones;

            if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

                console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
                    geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

            }

        };

        function parseMorphing( scale ) {

            if ( json.morphTargets !== undefined ) {

                for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {

                    geometry.morphTargets[ i ] = {};
                    geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
                    geometry.morphTargets[ i ].vertices = [];

                    var dstVertices = geometry.morphTargets[ i ].vertices;
                    var srcVertices = json.morphTargets[ i ].vertices;

                    for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

                        var vertex = new THREE.Vector3();
                        vertex.x = srcVertices[ v ] * scale;
                        vertex.y = srcVertices[ v + 1 ] * scale;
                        vertex.z = srcVertices[ v + 2 ] * scale;

                        dstVertices.push( vertex );

                    }

                }

            }

            if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {

                console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );

                var faces = geometry.faces;
                var morphColors = json.morphColors[ 0 ].colors;

                for ( var i = 0, l = faces.length; i < l; i ++ ) {

                    faces[ i ].color.fromArray( morphColors, i * 3 );

                }

            }

        }

        function parseAnimations() {

            var outputAnimations = [];

            // parse old style Bone/Hierarchy animations
            var animations = [];
            if ( json.animation !== undefined ) {
                animations.push( json.animation );
            }
            if ( json.animations !== undefined ) {
                if ( json.animations.length ) {
                    animations = animations.concat( json.animations );
                } else {
                    animations.push( json.animations );
                }
            }

            for ( var i = 0; i < animations.length; i ++ ) {

                var clip = THREE.AnimationClip.parseAnimation( animations[i], geometry.bones );
                if ( clip ) outputAnimations.push( clip );

            }

            // parse implicit morph animations
            if ( geometry.morphTargets ) {

                // TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
                var morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
                outputAnimations = outputAnimations.concat( morphAnimationClips );

            }

            if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;

        };

        if ( json.materials === undefined || json.materials.length === 0 ) {

            return { geometry: geometry };

        } else {

            var materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );

            return { geometry: geometry, materials: materials };

        }

    }

};

// File:src/loaders/LoadingManager.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LoadingManager = function ( onLoad, onProgress, onError ) {

    var scope = this;

    var isLoading = false, itemsLoaded = 0, itemsTotal = 0;

    this.onStart = undefined;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;

    this.itemStart = function ( url ) {

        itemsTotal ++;

        if ( isLoading === false ) {

            if ( scope.onStart !== undefined ) {

                scope.onStart( url, itemsLoaded, itemsTotal );

            }

        }

        isLoading = true;

    };

    this.itemEnd = function ( url ) {

        itemsLoaded ++;

        if ( scope.onProgress !== undefined ) {

            scope.onProgress( url, itemsLoaded, itemsTotal );

        }

        if ( itemsLoaded === itemsTotal ) {

            isLoading = false;

            if ( scope.onLoad !== undefined ) {

                scope.onLoad();

            }

        }

    };

    this.itemError = function ( url ) {

        if ( scope.onError !== undefined ) {

            scope.onError( url );

        }

    };

};

THREE.DefaultLoadingManager = new THREE.LoadingManager();

// File:src/loaders/BufferGeometryLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometryLoader = function ( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.BufferGeometryLoader.prototype = {

    constructor: THREE.BufferGeometryLoader,

    load: function ( url, onLoad, onProgress, onError ) {

        var scope = this;

        var loader = new THREE.XHRLoader( scope.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.load( url, function ( text ) {

            onLoad( scope.parse( JSON.parse( text ) ) );

        }, onProgress, onError );

    },

    setCrossOrigin: function ( value ) {

        this.crossOrigin = value;

    },

    parse: function ( json ) {

        var geometry = new THREE.BufferGeometry();

        var index = json.data.index;

        if ( index !== undefined ) {

            var typedArray = new self[ index.type ]( index.array );
            geometry.setIndex( new THREE.BufferAttribute( typedArray, 1 ) );

        }

        var attributes = json.data.attributes;

        for ( var key in attributes ) {

            var attribute = attributes[ key ];
            var typedArray = new self[ attribute.type ]( attribute.array );

            geometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );

        }

        var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

        if ( groups !== undefined ) {

            for ( var i = 0, n = groups.length; i !== n; ++ i ) {

                var group = groups[ i ];

                geometry.addGroup( group.start, group.count );

            }

        }

        var boundingSphere = json.data.boundingSphere;

        if ( boundingSphere !== undefined ) {

            var center = new THREE.Vector3();

            if ( boundingSphere.center !== undefined ) {

                center.fromArray( boundingSphere.center );

            }

            geometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );

        }

        return geometry;

    }

};

// File:src/loaders/MaterialLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MaterialLoader = function ( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
    this.textures = {};

};

THREE.MaterialLoader.prototype = {

    constructor: THREE.MaterialLoader,

    load: function ( url, onLoad, onProgress, onError ) {

        var scope = this;

        var loader = new THREE.XHRLoader( scope.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.load( url, function ( text ) {

            onLoad( scope.parse( JSON.parse( text ) ) );

        }, onProgress, onError );

    },

    setCrossOrigin: function ( value ) {

        this.crossOrigin = value;

    },

    setTextures: function ( value ) {

        this.textures = value;

    },

    getTexture: function ( name ) {

        var textures = this.textures;

        if ( textures[ name ] === undefined ) {

            console.warn( 'THREE.MaterialLoader: Undefined texture', name );

        }

        return textures[ name ];

    },

    parse: function ( json ) {

        var material = new THREE[ json.type ];
        material.uuid = json.uuid;

        if ( json.name !== undefined ) material.name = json.name;
        if ( json.color !== undefined ) material.color.setHex( json.color );
        if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
        if ( json.specular !== undefined ) material.specular.setHex( json.specular );
        if ( json.shininess !== undefined ) material.shininess = json.shininess;
        if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
        if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
        if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
        if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
        if ( json.shading !== undefined ) material.shading = json.shading;
        if ( json.blending !== undefined ) material.blending = json.blending;
        if ( json.side !== undefined ) material.side = json.side;
        if ( json.opacity !== undefined ) material.opacity = json.opacity;
        if ( json.transparent !== undefined ) material.transparent = json.transparent;
        if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
        if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
        if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
        if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
        if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;

        // for PointsMaterial
        if ( json.size !== undefined ) material.size = json.size;
        if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

        // maps

        if ( json.map !== undefined ) material.map = this.getTexture( json.map );

        if ( json.alphaMap !== undefined ) {

            material.alphaMap = this.getTexture( json.alphaMap );
            material.transparent = true;

        }

        if ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );
        if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

        if ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );
        if ( json.normalScale )	material.normalScale = new THREE.Vector2( json.normalScale, json.normalScale );

        if ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );
        if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
        if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

        if ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );

        if ( json.envMap !== undefined ) {

            material.envMap = this.getTexture( json.envMap );
            material.combine = THREE.MultiplyOperation;

        }

        if ( json.reflectivity ) material.reflectivity = json.reflectivity;

        if ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );
        if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

        if ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );
        if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

        // MeshFaceMaterial

        if ( json.materials !== undefined ) {

            for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

                material.materials.push( this.parse( json.materials[ i ] ) );

            }

        }

        return material;

    }

};

// File:src/loaders/ObjectLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ObjectLoader = function ( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
    this.texturePath = '';

};

THREE.ObjectLoader.prototype = {

    constructor: THREE.ObjectLoader,

    load: function ( url, onLoad, onProgress, onError ) {

        if ( this.texturePath === '' ) {

            this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

        }

        var scope = this;

        var loader = new THREE.XHRLoader( scope.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.load( url, function ( text ) {

            scope.parse( JSON.parse( text ), onLoad );

        }, onProgress, onError );

    },

    setTexturePath: function ( value ) {

        this.texturePath = value;

    },

    setCrossOrigin: function ( value ) {

        this.crossOrigin = value;

    },

    parse: function ( json, onLoad ) {

        var geometries = this.parseGeometries( json.geometries );

        var images = this.parseImages( json.images, function () {

            if ( onLoad !== undefined ) onLoad( object );

        } );

        var textures  = this.parseTextures( json.textures, images );
        var materials = this.parseMaterials( json.materials, textures );

        var object = this.parseObject( json.object, geometries, materials );

        if ( json.animations ) {

            object.animations = this.parseAnimations( json.animations );

        }

        if ( json.images === undefined || json.images.length === 0 ) {

            if ( onLoad !== undefined ) onLoad( object );

        }

        return object;

    },

    parseGeometries: function ( json ) {

        var geometries = {};

        if ( json !== undefined ) {

            var geometryLoader = new THREE.JSONLoader();
            var bufferGeometryLoader = new THREE.BufferGeometryLoader();

            for ( var i = 0, l = json.length; i < l; i ++ ) {

                var geometry;
                var data = json[ i ];

                switch ( data.type ) {

                    case 'PlaneGeometry':
                    case 'PlaneBufferGeometry':

                        geometry = new THREE[ data.type ](
                            data.width,
                            data.height,
                            data.widthSegments,
                            data.heightSegments
                        );

                        break;

                    case 'BoxGeometry':
                    case 'CubeGeometry': // backwards compatible

                        geometry = new THREE.BoxGeometry(
                            data.width,
                            data.height,
                            data.depth,
                            data.widthSegments,
                            data.heightSegments,
                            data.depthSegments
                        );

                        break;

                    case 'CircleBufferGeometry':

                        geometry = new THREE.CircleBufferGeometry(
                            data.radius,
                            data.segments,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'CircleGeometry':

                        geometry = new THREE.CircleGeometry(
                            data.radius,
                            data.segments,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'CylinderGeometry':

                        geometry = new THREE.CylinderGeometry(
                            data.radiusTop,
                            data.radiusBottom,
                            data.height,
                            data.radialSegments,
                            data.heightSegments,
                            data.openEnded,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'SphereGeometry':

                        geometry = new THREE.SphereGeometry(
                            data.radius,
                            data.widthSegments,
                            data.heightSegments,
                            data.phiStart,
                            data.phiLength,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'SphereBufferGeometry':

                        geometry = new THREE.SphereBufferGeometry(
                            data.radius,
                            data.widthSegments,
                            data.heightSegments,
                            data.phiStart,
                            data.phiLength,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'DodecahedronGeometry':

                        geometry = new THREE.DodecahedronGeometry(
                            data.radius,
                            data.detail
                        );

                        break;

                    case 'IcosahedronGeometry':

                        geometry = new THREE.IcosahedronGeometry(
                            data.radius,
                            data.detail
                        );

                        break;

                    case 'OctahedronGeometry':

                        geometry = new THREE.OctahedronGeometry(
                            data.radius,
                            data.detail
                        );

                        break;

                    case 'TetrahedronGeometry':

                        geometry = new THREE.TetrahedronGeometry(
                            data.radius,
                            data.detail
                        );

                        break;

                    case 'RingGeometry':

                        geometry = new THREE.RingGeometry(
                            data.innerRadius,
                            data.outerRadius,
                            data.thetaSegments,
                            data.phiSegments,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'TorusGeometry':

                        geometry = new THREE.TorusGeometry(
                            data.radius,
                            data.tube,
                            data.radialSegments,
                            data.tubularSegments,
                            data.arc
                        );

                        break;

                    case 'TorusKnotGeometry':

                        geometry = new THREE.TorusKnotGeometry(
                            data.radius,
                            data.tube,
                            data.radialSegments,
                            data.tubularSegments,
                            data.p,
                            data.q,
                            data.heightScale
                        );

                        break;

                    case 'BufferGeometry':

                        geometry = bufferGeometryLoader.parse( data );

                        break;

                    case 'Geometry':

                        geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;

                        break;

                    default:

                        console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

                        continue;

                }

                geometry.uuid = data.uuid;

                if ( data.name !== undefined ) geometry.name = data.name;

                geometries[ data.uuid ] = geometry;

            }

        }

        return geometries;

    },

    parseMaterials: function ( json, textures ) {

        var materials = {};

        if ( json !== undefined ) {

            var loader = new THREE.MaterialLoader();
            loader.setTextures( textures );

            for ( var i = 0, l = json.length; i < l; i ++ ) {

                var material = loader.parse( json[ i ] );
                materials[ material.uuid ] = material;

            }

        }

        return materials;

    },

    parseAnimations: function ( json ) {

        var animations = [];

        for ( var i = 0; i < json.length; i ++ ) {

            var clip = THREE.AnimationClip.parse( json[i] );

            animations.push( clip );

        }

        return animations;

    },

    parseImages: function ( json, onLoad ) {

        var scope = this;
        var images = {};

        function loadImage( url ) {

            scope.manager.itemStart( url );

            return loader.load( url, function () {

                scope.manager.itemEnd( url );

            } );

        }

        if ( json !== undefined && json.length > 0 ) {

            var manager = new THREE.LoadingManager( onLoad );

            var loader = new THREE.ImageLoader( manager );
            loader.setCrossOrigin( this.crossOrigin );

            for ( var i = 0, l = json.length; i < l; i ++ ) {

                var image = json[ i ];
                var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

                images[ image.uuid ] = loadImage( path );

            }

        }

        return images;

    },

    parseTextures: function ( json, images ) {

        function parseConstant( value ) {

            if ( typeof( value ) === 'number' ) return value;

            console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

            return THREE[ value ];

        }

        var textures = {};

        if ( json !== undefined ) {

            for ( var i = 0, l = json.length; i < l; i ++ ) {

                var data = json[ i ];

                if ( data.image === undefined ) {

                    console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

                }

                if ( images[ data.image ] === undefined ) {

                    console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

                }

                var texture = new THREE.Texture( images[ data.image ] );
                texture.needsUpdate = true;

                texture.uuid = data.uuid;

                if ( data.name !== undefined ) texture.name = data.name;
                if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );
                if ( data.offset !== undefined ) texture.offset = new THREE.Vector2( data.offset[ 0 ], data.offset[ 1 ] );
                if ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );
                if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );
                if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );
                if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;
                if ( Array.isArray( data.wrap ) ) {

                    texture.wrapS = parseConstant( data.wrap[ 0 ] );
                    texture.wrapT = parseConstant( data.wrap[ 1 ] );

                }

                textures[ data.uuid ] = texture;

            }

        }

        return textures;

    },

    parseObject: function () {

        var matrix = new THREE.Matrix4();

        return function ( data, geometries, materials ) {

            var object;

            function getGeometry( name ) {

                if ( geometries[ name ] === undefined ) {

                    console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

                }

                return geometries[ name ];

            }

            function getMaterial( name ) {

                if ( name === undefined ) return undefined;

                if ( materials[ name ] === undefined ) {

                    console.warn( 'THREE.ObjectLoader: Undefined material', name );

                }

                return materials[ name ];

            }

            switch ( data.type ) {

                case 'Scene':

                    object = new THREE.Scene();

                    break;

                case 'PerspectiveCamera':

                    object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

                    break;

                case 'OrthographicCamera':

                    object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

                    break;

                case 'AmbientLight':

                    object = new THREE.AmbientLight( data.color );

                    break;

                case 'DirectionalLight':

                    object = new THREE.DirectionalLight( data.color, data.intensity );

                    break;

                case 'PointLight':

                    object = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );

                    break;

                case 'SpotLight':

                    object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay );

                    break;

                case 'HemisphereLight':

                    object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );

                    break;

                case 'Mesh':

                    object = new THREE.Mesh( getGeometry( data.geometry ), getMaterial( data.material ) );

                    break;

                case 'LOD':

                    object = new THREE.LOD();

                    break;

                case 'Line':

                    object = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

                    break;

                case 'PointCloud':
                case 'Points':

                    object = new THREE.Points( getGeometry( data.geometry ), getMaterial( data.material ) );

                    break;

                case 'Sprite':

                    object = new THREE.Sprite( getMaterial( data.material ) );

                    break;

                case 'Group':

                    object = new THREE.Group();

                    break;

                default:

                    object = new THREE.Object3D();

            }

            object.uuid = data.uuid;

            if ( data.name !== undefined ) object.name = data.name;
            if ( data.matrix !== undefined ) {

                matrix.fromArray( data.matrix );
                matrix.decompose( object.position, object.quaternion, object.scale );

            } else {

                if ( data.position !== undefined ) object.position.fromArray( data.position );
                if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
                if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

            }

            if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
            if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

            if ( data.visible !== undefined ) object.visible = data.visible;
            if ( data.userData !== undefined ) object.userData = data.userData;

            if ( data.children !== undefined ) {

                for ( var child in data.children ) {

                    object.add( this.parseObject( data.children[ child ], geometries, materials ) );

                }

            }

            if ( data.type === 'LOD' ) {

                var levels = data.levels;

                for ( var l = 0; l < levels.length; l ++ ) {

                    var level = levels[ l ];
                    var child = object.getObjectByProperty( 'uuid', level.object );

                    if ( child !== undefined ) {

                        object.addLevel( child, level.distance );

                    }

                }

            }

            return object;

        }

    }()

};

// File:src/loaders/TextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.TextureLoader = function ( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.TextureLoader.prototype = {

    constructor: THREE.TextureLoader,

    load: function ( url, onLoad, onProgress, onError ) {

        var texture = new THREE.Texture();

        var loader = new THREE.ImageLoader( this.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.load( url, function ( image ) {

            texture.image = image;
            texture.needsUpdate = true;

            if ( onLoad !== undefined ) {

                onLoad( texture );

            }

        }, onProgress, onError );

        return texture;

    },

    setCrossOrigin: function ( value ) {

        this.crossOrigin = value;

    }

};

// File:src/loaders/CubeTextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CubeTextureLoader = function ( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.CubeTextureLoader.prototype = {

    constructor: THREE.CubeTextureLoader,

    load: function ( urls, onLoad, onProgress, onError ) {

        var texture = new THREE.CubeTexture( [] );

        var loader = new THREE.ImageLoader();
        loader.setCrossOrigin( this.crossOrigin );

        var loaded = 0;

        function loadTexture( i ) {

            loader.load( urls[ i ], function ( image ) {

                texture.images[ i ] = image;

                loaded ++;

                if ( loaded === 6 ) {

                    texture.needsUpdate = true;

                    if ( onLoad ) onLoad( texture );

                }

            }, undefined, onError );

        }

        for ( var i = 0; i < urls.length; ++ i ) {

            loadTexture( i );

        }

        return texture;

    },

    setCrossOrigin: function ( value ) {

        this.crossOrigin = value;

    }

};

// File:src/loaders/BinaryTextureLoader.js

/**
 * @author Nikos M. / https://github.com/foo123/
 *
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 */

THREE.DataTextureLoader = THREE.BinaryTextureLoader = function ( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

    // override in sub classes
    this._parser = null;

};

THREE.BinaryTextureLoader.prototype = {

    constructor: THREE.BinaryTextureLoader,

    load: function ( url, onLoad, onProgress, onError ) {

        var scope = this;

        var texture = new THREE.DataTexture();

        var loader = new THREE.XHRLoader( this.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.setResponseType( 'arraybuffer' );

        loader.load( url, function ( buffer ) {

            var texData = scope._parser( buffer );

            if ( ! texData ) return;

            if ( undefined !== texData.image ) {

                texture.image = texData.image;

            } else if ( undefined !== texData.data ) {

                texture.image.width = texData.width;
                texture.image.height = texData.height;
                texture.image.data = texData.data;

            }

            texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;
            texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;

            texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;
            texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;

            texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

            if ( undefined !== texData.format ) {

                texture.format = texData.format;

            }
            if ( undefined !== texData.type ) {

                texture.type = texData.type;

            }

            if ( undefined !== texData.mipmaps ) {

                texture.mipmaps = texData.mipmaps;

            }

            if ( 1 === texData.mipmapCount ) {

                texture.minFilter = THREE.LinearFilter;

            }

            texture.needsUpdate = true;

            if ( onLoad ) onLoad( texture, texData );

        }, onProgress, onError );


        return texture;

    },

    setCrossOrigin: function ( value ) {

        this.crossOrigin = value;

    }

};

// File:src/loaders/CompressedTextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 */

THREE.CompressedTextureLoader = function ( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

    // override in sub classes
    this._parser = null;

};


THREE.CompressedTextureLoader.prototype = {

    constructor: THREE.CompressedTextureLoader,

    load: function ( url, onLoad, onProgress, onError ) {

        var scope = this;

        var images = [];

        var texture = new THREE.CompressedTexture();
        texture.image = images;

        var loader = new THREE.XHRLoader( this.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.setResponseType( 'arraybuffer' );

        if ( Array.isArray( url ) ) {

            var loaded = 0;

            var loadTexture = function ( i ) {

                loader.load( url[ i ], function ( buffer ) {

                    var texDatas = scope._parser( buffer, true );

                    images[ i ] = {
                        width: texDatas.width,
                        height: texDatas.height,
                        format: texDatas.format,
                        mipmaps: texDatas.mipmaps
                    };

                    loaded += 1;

                    if ( loaded === 6 ) {

                        if ( texDatas.mipmapCount === 1 )
                            texture.minFilter = THREE.LinearFilter;

                        texture.format = texDatas.format;
                        texture.needsUpdate = true;

                        if ( onLoad ) onLoad( texture );

                    }

                }, onProgress, onError );

            };

            for ( var i = 0, il = url.length; i < il; ++ i ) {

                loadTexture( i );

            }

        } else {

            // compressed cubemap texture stored in a single DDS file

            loader.load( url, function ( buffer ) {

                var texDatas = scope._parser( buffer, true );

                if ( texDatas.isCubemap ) {

                    var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

                    for ( var f = 0; f < faces; f ++ ) {

                        images[ f ] = { mipmaps : [] };

                        for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

                            images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
                            images[ f ].format = texDatas.format;
                            images[ f ].width = texDatas.width;
                            images[ f ].height = texDatas.height;

                        }

                    }

                } else {

                    texture.image.width = texDatas.width;
                    texture.image.height = texDatas.height;
                    texture.mipmaps = texDatas.mipmaps;

                }

                if ( texDatas.mipmapCount === 1 ) {

                    texture.minFilter = THREE.LinearFilter;

                }

                texture.format = texDatas.format;
                texture.needsUpdate = true;

                if ( onLoad ) onLoad( texture );

            }, onProgress, onError );

        }

        return texture;

    },

    setCrossOrigin: function ( value ) {

        this.crossOrigin = value;

    }

};

// File:src/materials/Material.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Material = function () {

    Object.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );

    this.uuid = THREE.Math.generateUUID();

    this.name = '';
    this.type = 'Material';

    this.side = THREE.FrontSide;

    this.opacity = 1;
    this.transparent = false;

    this.blending = THREE.NormalBlending;

    this.blendSrc = THREE.SrcAlphaFactor;
    this.blendDst = THREE.OneMinusSrcAlphaFactor;
    this.blendEquation = THREE.AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;

    this.depthFunc = THREE.LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;

    this.colorWrite = true;

    this.precision = null; // override the renderer's default precision for this material

    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;

    this.alphaTest = 0;

    this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

    this.visible = true;

    this._needsUpdate = true;

};

THREE.Material.prototype = {

    constructor: THREE.Material,

    get needsUpdate () {

        return this._needsUpdate;

    },

    set needsUpdate ( value ) {

        if ( value === true ) this.update();

        this._needsUpdate = value;

    },

    setValues: function ( values ) {

        if ( values === undefined ) return;

        for ( var key in values ) {

            var newValue = values[ key ];

            if ( newValue === undefined ) {

                console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
                continue;

            }

            var currentValue = this[ key ];

            if ( currentValue === undefined ) {

                console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
                continue;

            }

            if ( currentValue instanceof THREE.Color ) {

                currentValue.set( newValue );

            } else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {

                currentValue.copy( newValue );

            } else if ( key === 'overdraw' ) {

                // ensure overdraw is backwards-compatible with legacy boolean type
                this[ key ] = Number( newValue );

            } else {

                this[ key ] = newValue;

            }

        }

    },

    toJSON: function ( meta ) {

        var data = {
            metadata: {
                version: 4.4,
                type: 'Material',
                generator: 'Material.toJSON'
            }
        };

        // standard Material serialization
        data.uuid = this.uuid;
        data.type = this.type;
        if ( this.name !== '' ) data.name = this.name;

        if ( this.color instanceof THREE.Color ) data.color = this.color.getHex();
        if ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();
        if ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();
        if ( this.shininess !== undefined ) data.shininess = this.shininess;

        if ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;
        if ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
        if ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
        if ( this.bumpMap instanceof THREE.Texture ) {

            data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
            data.bumpScale = this.bumpScale;

        }
        if ( this.normalMap instanceof THREE.Texture ) {

            data.normalMap = this.normalMap.toJSON( meta ).uuid;
            data.normalScale = this.normalScale; // Removed for now, causes issue in editor ui.js

        }
        if ( this.displacementMap instanceof THREE.Texture ) {

            data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
            data.displacementScale = this.displacementScale;
            data.displacementBias = this.displacementBias;

        }
        if ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
        if ( this.envMap instanceof THREE.Texture ) {

            data.envMap = this.envMap.toJSON( meta ).uuid;
            data.reflectivity = this.reflectivity; // Scale behind envMap

        }

        if ( this.size !== undefined ) data.size = this.size;
        if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

        if ( this.vertexColors !== undefined && this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;
        if ( this.shading !== undefined && this.shading !== THREE.SmoothShading ) data.shading = this.shading;
        if ( this.blending !== undefined && this.blending !== THREE.NormalBlending ) data.blending = this.blending;
        if ( this.side !== undefined && this.side !== THREE.FrontSide ) data.side = this.side;

        if ( this.opacity < 1 ) data.opacity = this.opacity;
        if ( this.transparent === true ) data.transparent = this.transparent;
        if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
        if ( this.wireframe === true ) data.wireframe = this.wireframe;
        if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;

        return data;

    },

    clone: function () {

        return new this.constructor().copy( this );

    },

    copy: function ( source ) {

        this.name = source.name;

        this.side = source.side;

        this.opacity = source.opacity;
        this.transparent = source.transparent;

        this.blending = source.blending;

        this.blendSrc = source.blendSrc;
        this.blendDst = source.blendDst;
        this.blendEquation = source.blendEquation;
        this.blendSrcAlpha = source.blendSrcAlpha;
        this.blendDstAlpha = source.blendDstAlpha;
        this.blendEquationAlpha = source.blendEquationAlpha;

        this.depthFunc = source.depthFunc;
        this.depthTest = source.depthTest;
        this.depthWrite = source.depthWrite;

        this.precision = source.precision;

        this.polygonOffset = source.polygonOffset;
        this.polygonOffsetFactor = source.polygonOffsetFactor;
        this.polygonOffsetUnits = source.polygonOffsetUnits;

        this.alphaTest = source.alphaTest;

        this.overdraw = source.overdraw;

        this.visible = source.visible;

        return this;

    },

    update: function () {

        this.dispatchEvent( { type: 'update' } );

    },

    dispose: function () {

        this.dispatchEvent( { type: 'dispose' } );

    },

    // Deprecated

    get wrapAround () {

        console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );

    },

    set wrapAround ( boolean ) {

        console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );

    },

    get wrapRGB () {

        console.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );
        return new THREE.Color();

    }

};

THREE.EventDispatcher.prototype.apply( THREE.Material.prototype );

THREE.MaterialIdCount = 0;

// File:src/materials/LineBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round",
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineBasicMaterial = function ( parameters ) {

    THREE.Material.call( this );

    this.type = 'LineBasicMaterial';

    this.color = new THREE.Color( 0xffffff );

    this.linewidth = 1;
    this.linecap = 'round';
    this.linejoin = 'round';

    this.vertexColors = THREE.NoColors;

    this.fog = true;

    this.setValues( parameters );

};

THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;

THREE.LineBasicMaterial.prototype.copy = function ( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );

    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;

    this.vertexColors = source.vertexColors;

    this.fog = source.fog;

    return this;

};

// File:src/materials/LineDashedMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>,
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineDashedMaterial = function ( parameters ) {

    THREE.Material.call( this );

    this.type = 'LineDashedMaterial';

    this.color = new THREE.Color( 0xffffff );

    this.linewidth = 1;

    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;

    this.vertexColors = false;

    this.fog = true;

    this.setValues( parameters );

};

THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;

THREE.LineDashedMaterial.prototype.copy = function ( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );

    this.linewidth = source.linewidth;

    this.scale = source.scale;
    this.dashSize = source.dashSize;
    this.gapSize = source.gapSize;

    this.vertexColors = source.vertexColors;

    this.fog = source.fog;

    return this;

};

// File:src/materials/MeshBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.MeshBasicMaterial = function ( parameters ) {

    THREE.Material.call( this );

    this.type = 'MeshBasicMaterial';

    this.color = new THREE.Color( 0xffffff ); // emissive

    this.map = null;

    this.aoMap = null;
    this.aoMapIntensity = 1.0;

    this.specularMap = null;

    this.alphaMap = null;

    this.envMap = null;
    this.combine = THREE.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;

    this.fog = true;

    this.shading = THREE.SmoothShading;

    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';

    this.vertexColors = THREE.NoColors;

    this.skinning = false;
    this.morphTargets = false;

    this.setValues( parameters );

};

THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;

THREE.MeshBasicMaterial.prototype.copy = function ( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );

    this.map = source.map;

    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;

    this.specularMap = source.specularMap;

    this.alphaMap = source.alphaMap;

    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;

    this.fog = source.fog;

    this.shading = source.shading;

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;

    this.vertexColors = source.vertexColors;

    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;

    return this;

};

// File:src/materials/MeshLambertMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  emissive: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshLambertMaterial = function ( parameters ) {

    THREE.Material.call( this );

    this.type = 'MeshLambertMaterial';

    this.color = new THREE.Color( 0xffffff ); // diffuse
    this.emissive = new THREE.Color( 0x000000 );

    this.map = null;

    this.specularMap = null;

    this.alphaMap = null;

    this.envMap = null;
    this.combine = THREE.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;

    this.fog = true;

    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';

    this.vertexColors = THREE.NoColors;

    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;

    this.setValues( parameters );

};

THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;

THREE.MeshLambertMaterial.prototype.copy = function ( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );
    this.emissive.copy( source.emissive );

    this.map = source.map;

    this.specularMap = source.specularMap;

    this.alphaMap = source.alphaMap;

    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;

    this.fog = source.fog;

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;

    this.vertexColors = source.vertexColors;

    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;

    return this;

};

// File:src/materials/MeshPhongMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  emissive: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshPhongMaterial = function ( parameters ) {

    THREE.Material.call( this );

    this.type = 'MeshPhongMaterial';

    this.color = new THREE.Color( 0xffffff ); // diffuse
    this.emissive = new THREE.Color( 0x000000 );
    this.specular = new THREE.Color( 0x111111 );
    this.shininess = 30;

    this.metal = false;

    this.map = null;

    this.lightMap = null;
    this.lightMapIntensity = 1.0;

    this.aoMap = null;
    this.aoMapIntensity = 1.0;

    this.emissiveMap = null;

    this.bumpMap = null;
    this.bumpScale = 1;

    this.normalMap = null;
    this.normalScale = new THREE.Vector2( 1, 1 );

    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;

    this.specularMap = null;

    this.alphaMap = null;

    this.envMap = null;
    this.combine = THREE.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;

    this.fog = true;

    this.shading = THREE.SmoothShading;

    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';

    this.vertexColors = THREE.NoColors;

    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;

    this.setValues( parameters );

};

THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;

THREE.MeshPhongMaterial.prototype.copy = function ( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );
    this.emissive.copy( source.emissive );
    this.specular.copy( source.specular );
    this.shininess = source.shininess;

    this.metal = source.metal;

    this.map = source.map;

    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;

    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;

    this.emissiveMap = source.emissiveMap;

    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;

    this.normalMap = source.normalMap;
    this.normalScale.copy( source.normalScale );

    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;

    this.specularMap = source.specularMap;

    this.alphaMap = source.alphaMap;

    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;

    this.fog = source.fog;

    this.shading = source.shading;

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;

    this.vertexColors = source.vertexColors;

    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;

    return this;

};

// File:src/materials/MeshDepthMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshDepthMaterial = function ( parameters ) {

    THREE.Material.call( this );

    this.type = 'MeshDepthMaterial';

    this.morphTargets = false;
    this.wireframe = false;
    this.wireframeLinewidth = 1;

    this.setValues( parameters );

};

THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;

THREE.MeshDepthMaterial.prototype.copy = function ( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;

    return this;

};

// File:src/materials/MeshNormalMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  shading: THREE.FlatShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshNormalMaterial = function ( parameters ) {

    THREE.Material.call( this, parameters );

    this.type = 'MeshNormalMaterial';

    this.wireframe = false;
    this.wireframeLinewidth = 1;

    this.morphTargets = false;

    this.setValues( parameters );

};

THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;

THREE.MeshNormalMaterial.prototype.copy = function ( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;

    return this;

};

// File:src/materials/MultiMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MultiMaterial = function ( materials ) {

    this.uuid = THREE.Math.generateUUID();

    this.type = 'MultiMaterial';

    this.materials = materials instanceof Array ? materials : [];

    this.visible = true;

};

THREE.MultiMaterial.prototype = {

    constructor: THREE.MultiMaterial,

    toJSON: function () {

        var output = {
            metadata: {
                version: 4.2,
                type: 'material',
                generator: 'MaterialExporter'
            },
            uuid: this.uuid,
            type: this.type,
            materials: []
        };

        for ( var i = 0, l = this.materials.length; i < l; i ++ ) {

            output.materials.push( this.materials[ i ].toJSON() );

        }

        output.visible = this.visible;

        return output;

    },

    clone: function () {

        var material = new this.constructor();

        for ( var i = 0; i < this.materials.length; i ++ ) {

            material.materials.push( this.materials[ i ].clone() );

        }

        material.visible = this.visible;

        return material;

    }

};

// backwards compatibility

THREE.MeshFaceMaterial = THREE.MultiMaterial;

// File:src/materials/PointsMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  vertexColors: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.PointsMaterial = function ( parameters ) {

    THREE.Material.call( this );

    this.type = 'PointsMaterial';

    this.color = new THREE.Color( 0xffffff );

    this.map = null;

    this.size = 1;
    this.sizeAttenuation = true;

    this.vertexColors = THREE.NoColors;

    this.fog = true;

    this.setValues( parameters );

};

THREE.PointsMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;

THREE.PointsMaterial.prototype.copy = function ( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );

    this.map = source.map;

    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;

    this.vertexColors = source.vertexColors;

    this.fog = source.fog;

    return this;

};

// backwards compatibility

THREE.PointCloudMaterial = function ( parameters ) {

    console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
    return new THREE.PointsMaterial( parameters );

};

THREE.ParticleBasicMaterial = function ( parameters ) {

    console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
    return new THREE.PointsMaterial( parameters );

};

THREE.ParticleSystemMaterial = function ( parameters ) {

    console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
    return new THREE.PointsMaterial( parameters );

};

// File:src/materials/ShaderMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.ShaderMaterial = function ( parameters ) {

    THREE.Material.call( this );

    this.type = 'ShaderMaterial';

    this.defines = {};
    this.uniforms = {};

    this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
    this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

    this.shading = THREE.SmoothShading;

    this.linewidth = 1;

    this.wireframe = false;
    this.wireframeLinewidth = 1;

    this.fog = false; // set to use scene fog

    this.lights = false; // set to use scene lights

    this.vertexColors = THREE.NoColors; // set to use "color" attribute stream

    this.skinning = false; // set to use skinning attribute streams

    this.morphTargets = false; // set to use morph targets
    this.morphNormals = false; // set to use morph normals

    this.derivatives = false; // set to use derivatives

    // When rendered geometry doesn't include these attributes but the material does,
    // use these default values in WebGL. This avoids errors when buffer data is missing.
    this.defaultAttributeValues = {
        'color': [ 1, 1, 1 ],
        'uv': [ 0, 0 ],
        'uv2': [ 0, 0 ]
    };

    this.index0AttributeName = undefined;

    if ( parameters !== undefined ) {

        if ( parameters.attributes !== undefined ) {

            console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

        }

        this.setValues( parameters );

    }

};

THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;

THREE.ShaderMaterial.prototype.copy = function ( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;

    this.uniforms = THREE.UniformsUtils.clone( source.uniforms );

    this.attributes = source.attributes;
    this.defines = source.defines;

    this.shading = source.shading;

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;

    this.fog = source.fog;

    this.lights = source.lights;

    this.vertexColors = source.vertexColors;

    this.skinning = source.skinning;

    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;

    this.derivatives = source.derivatives;

    return this;

};

THREE.ShaderMaterial.prototype.toJSON = function ( meta ) {

    var data = THREE.Material.prototype.toJSON.call( this, meta );

    data.uniforms = this.uniforms;
    data.attributes = this.attributes;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;

    return data;

};

// File:src/materials/RawShaderMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RawShaderMaterial = function ( parameters ) {

    THREE.ShaderMaterial.call( this, parameters );

    this.type = 'RawShaderMaterial';

};

THREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );
THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;
// File:src/materials/SpriteMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *	uvOffset: new THREE.Vector2(),
 *	uvScale: new THREE.Vector2(),
 *
 *  fog: <bool>
 * }
 */

THREE.SpriteMaterial = function ( parameters ) {

    THREE.Material.call( this );

    this.type = 'SpriteMaterial';

    this.color = new THREE.Color( 0xffffff );
    this.map = null;

    this.rotation = 0;

    this.fog = false;

    // set parameters

    this.setValues( parameters );

};

THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;

THREE.SpriteMaterial.prototype.copy = function ( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );
    this.map = source.map;

    this.rotation = source.rotation;

    this.fog = source.fog;

    return this;

};

// File:src/textures/Texture.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

    Object.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );

    this.uuid = THREE.Math.generateUUID();

    this.name = '';
    this.sourceFile = '';

    this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
    this.mipmaps = [];

    this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;

    this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
    this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;

    this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
    this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;

    this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

    this.format = format !== undefined ? format : THREE.RGBAFormat;
    this.type = type !== undefined ? type : THREE.UnsignedByteType;

    this.offset = new THREE.Vector2( 0, 0 );
    this.repeat = new THREE.Vector2( 1, 1 );

    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

    this.version = 0;
    this.onUpdate = null;

};

THREE.Texture.DEFAULT_IMAGE = undefined;
THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;

THREE.Texture.prototype = {

    constructor: THREE.Texture,

    set needsUpdate ( value ) {

        if ( value === true ) this.version ++;

    },

    clone: function () {

        return new this.constructor().copy( this );

    },

    copy: function ( source ) {

        this.image = source.image;
        this.mipmaps = source.mipmaps.slice( 0 );

        this.mapping = source.mapping;

        this.wrapS = source.wrapS;
        this.wrapT = source.wrapT;

        this.magFilter = source.magFilter;
        this.minFilter = source.minFilter;

        this.anisotropy = source.anisotropy;

        this.format = source.format;
        this.type = source.type;

        this.offset.copy( source.offset );
        this.repeat.copy( source.repeat );

        this.generateMipmaps = source.generateMipmaps;
        this.premultiplyAlpha = source.premultiplyAlpha;
        this.flipY = source.flipY;
        this.unpackAlignment = source.unpackAlignment;

        return this;

    },

    toJSON: function ( meta ) {

        if ( meta.textures[ this.uuid ] !== undefined ) {

            return meta.textures[ this.uuid ];

        }

        function getDataURL( image ) {

            var canvas;

            if ( image.toDataURL !== undefined ) {

                canvas = image;

            } else {

                canvas = document.createElement( 'canvas' );
                canvas.width = image.width;
                canvas.height = image.height;

                canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );

            }

            if ( canvas.width > 2048 || canvas.height > 2048 ) {

                return canvas.toDataURL( 'image/jpeg', 0.6 );

            } else {

                return canvas.toDataURL( 'image/png' );

            }

        }

        var output = {
            metadata: {
                version: 4.4,
                type: 'Texture',
                generator: 'Texture.toJSON'
            },

            uuid: this.uuid,
            name: this.name,

            mapping: this.mapping,

            repeat: [ this.repeat.x, this.repeat.y ],
            offset: [ this.offset.x, this.offset.y ],
            wrap: [ this.wrapS, this.wrapT ],

            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy
        };

        if ( this.image !== undefined ) {

            // TODO: Move to THREE.Image

            var image = this.image;

            if ( image.uuid === undefined ) {

                image.uuid = THREE.Math.generateUUID(); // UGH

            }

            if ( meta.images[ image.uuid ] === undefined ) {

                meta.images[ image.uuid ] = {
                    uuid: image.uuid,
                    url: getDataURL( image )
                };

            }

            output.image = image.uuid;

        }

        meta.textures[ this.uuid ] = output;

        return output;

    },

    dispose: function () {

        this.dispatchEvent( { type: 'dispose' } );

    },

    transformUv: function ( uv ) {

        if ( this.mapping !== THREE.UVMapping )  return;

        uv.multiply( this.repeat );
        uv.add( this.offset );

        if ( uv.x < 0 || uv.x > 1 ) {

            switch ( this.wrapS ) {

                case THREE.RepeatWrapping:

                    uv.x = uv.x - Math.floor( uv.x );
                    break;

                case THREE.ClampToEdgeWrapping:

                    uv.x = uv.x < 0 ? 0 : 1;
                    break;

                case THREE.MirroredRepeatWrapping:

                    if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

                        uv.x = Math.ceil( uv.x ) - uv.x;

                    } else {

                        uv.x = uv.x - Math.floor( uv.x );

                    }
                    break;

            }

        }

        if ( uv.y < 0 || uv.y > 1 ) {

            switch ( this.wrapT ) {

                case THREE.RepeatWrapping:

                    uv.y = uv.y - Math.floor( uv.y );
                    break;

                case THREE.ClampToEdgeWrapping:

                    uv.y = uv.y < 0 ? 0 : 1;
                    break;

                case THREE.MirroredRepeatWrapping:

                    if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

                        uv.y = Math.ceil( uv.y ) - uv.y;

                    } else {

                        uv.y = uv.y - Math.floor( uv.y );

                    }
                    break;

            }

        }

        if ( this.flipY ) {

            uv.y = 1 - uv.y;

        }

    }

};

THREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );

THREE.TextureIdCount = 0;

// File:src/textures/CanvasTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CanvasTexture = function ( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

    THREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    this.needsUpdate = true;

};

THREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;

// File:src/textures/CubeTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

    mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;

    THREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    this.images = images;
    this.flipY = false;

};

THREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;

THREE.CubeTexture.prototype.copy = function ( source ) {

    THREE.Texture.prototype.copy.call( this, source );

    this.images = source.images;

    return this;

};
// File:src/textures/CompressedTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

    THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    this.image = { width: width, height: height };
    this.mipmaps = mipmaps;

    // no flipping for cube textures
    // (also flipping doesn't work for compressed textures )

    this.flipY = false;

    // can't generate mipmaps for compressed textures
    // mips must be embedded in DDS files

    this.generateMipmaps = false;

};

THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;

// File:src/textures/DataTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

    THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    this.image = { data: data, width: width, height: height };

    this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;
    this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;

    this.flipY = false;
    this.generateMipmaps  = false;

};

THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.DataTexture.prototype.constructor = THREE.DataTexture;

// File:src/textures/VideoTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

    THREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    this.generateMipmaps = false;

    var scope = this;

    function update() {

        requestAnimationFrame( update );

        if ( video.readyState === video.HAVE_ENOUGH_DATA ) {

            scope.needsUpdate = true;

        }

    }

    update();

};

THREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;

// File:src/objects/Group.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Group = function () {

    THREE.Object3D.call( this );

    this.type = 'Group';

};

THREE.Group.prototype = Object.create( THREE.Object3D.prototype );
THREE.Group.prototype.constructor = THREE.Group;
// File:src/objects/Points.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Points = function ( geometry, material ) {

    THREE.Object3D.call( this );

    this.type = 'Points';

    this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
    this.material = material !== undefined ? material : new THREE.PointsMaterial( { color: Math.random() * 0xffffff } );

};

THREE.Points.prototype = Object.create( THREE.Object3D.prototype );
THREE.Points.prototype.constructor = THREE.Points;

THREE.Points.prototype.raycast = ( function () {

    var inverseMatrix = new THREE.Matrix4();
    var ray = new THREE.Ray();

    return function raycast( raycaster, intersects ) {

        var object = this;
        var geometry = object.geometry;
        var threshold = raycaster.params.Points.threshold;

        inverseMatrix.getInverse( this.matrixWorld );
        ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

        if ( geometry.boundingBox !== null ) {

            if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {

                return;

            }

        }

        var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
        var localThresholdSq = localThreshold * localThreshold;
        var position = new THREE.Vector3();

        function testPoint( point, index ) {

            var rayPointDistanceSq = ray.distanceSqToPoint( point );

            if ( rayPointDistanceSq < localThresholdSq ) {

                var intersectPoint = ray.closestPointToPoint( point );
                intersectPoint.applyMatrix4( object.matrixWorld );

                var distance = raycaster.ray.origin.distanceTo( intersectPoint );

                if ( distance < raycaster.near || distance > raycaster.far ) return;

                intersects.push( {

                    distance: distance,
                    distanceToRay: Math.sqrt( rayPointDistanceSq ),
                    point: intersectPoint.clone(),
                    index: index,
                    face: null,
                    object: object

                } );

            }

        }

        if ( geometry instanceof THREE.BufferGeometry ) {

            var index = geometry.index;
            var attributes = geometry.attributes;
            var positions = attributes.position.array;

            if ( index !== null ) {

                var indices = index.array;

                for ( var i = 0, il = indices.length; i < il; i ++ ) {

                    var a = indices[ i ];

                    position.fromArray( positions, a * 3 );

                    testPoint( position, a );

                }

            } else {

                for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

                    position.fromArray( positions, i * 3 );

                    testPoint( position, i );

                }

            }

        } else {

            var vertices = geometry.vertices;

            for ( var i = 0, l = vertices.length; i < l; i ++ ) {

                testPoint( vertices[ i ], i );

            }

        }

    };

}() );

THREE.Points.prototype.clone = function () {

    return new this.constructor( this.geometry, this.material ).copy( this );

};

// Backwards compatibility

THREE.PointCloud = function ( geometry, material ) {

    console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
    return new THREE.Points( geometry, material );

};

THREE.ParticleSystem = function ( geometry, material ) {

    console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
    return new THREE.Points( geometry, material );

};

// File:src/objects/Line.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Line = function ( geometry, material, mode ) {

    if ( mode === 1 ) {

        console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
        return new THREE.LineSegments( geometry, material );

    }

    THREE.Object3D.call( this );

    this.type = 'Line';

    this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
    this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );

};

THREE.Line.prototype = Object.create( THREE.Object3D.prototype );
THREE.Line.prototype.constructor = THREE.Line;

THREE.Line.prototype.raycast = ( function () {

    var inverseMatrix = new THREE.Matrix4();
    var ray = new THREE.Ray();
    var sphere = new THREE.Sphere();

    return function raycast( raycaster, intersects ) {

        var precision = raycaster.linePrecision;
        var precisionSq = precision * precision;

        var geometry = this.geometry;

        if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

        // Checking boundingSphere distance to ray

        sphere.copy( geometry.boundingSphere );
        sphere.applyMatrix4( this.matrixWorld );

        if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

            return;

        }

        inverseMatrix.getInverse( this.matrixWorld );
        ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

        var vStart = new THREE.Vector3();
        var vEnd = new THREE.Vector3();
        var interSegment = new THREE.Vector3();
        var interRay = new THREE.Vector3();
        var step = this instanceof THREE.LineSegments ? 2 : 1;

        if ( geometry instanceof THREE.BufferGeometry ) {

            var index = geometry.index;
            var attributes = geometry.attributes;

            if ( index !== null ) {

                var indices = index.array;
                var positions = attributes.position.array;

                for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

                    var a = indices[ i ];
                    var b = indices[ i + 1 ];

                    vStart.fromArray( positions, a * 3 );
                    vEnd.fromArray( positions, b * 3 );

                    var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

                    if ( distSq > precisionSq ) continue;

                    interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

                    var distance = raycaster.ray.origin.distanceTo( interRay );

                    if ( distance < raycaster.near || distance > raycaster.far ) continue;

                    intersects.push( {

                        distance: distance,
                        // What do we want? intersection point on the ray or on the segment??
                        // point: raycaster.ray.at( distance ),
                        point: interSegment.clone().applyMatrix4( this.matrixWorld ),
                        index: i,
                        face: null,
                        faceIndex: null,
                        object: this

                    } );

                }

            } else {

                var positions = attributes.position.array;

                for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

                    vStart.fromArray( positions, 3 * i );
                    vEnd.fromArray( positions, 3 * i + 3 );

                    var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

                    if ( distSq > precisionSq ) continue;

                    interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

                    var distance = raycaster.ray.origin.distanceTo( interRay );

                    if ( distance < raycaster.near || distance > raycaster.far ) continue;

                    intersects.push( {

                        distance: distance,
                        // What do we want? intersection point on the ray or on the segment??
                        // point: raycaster.ray.at( distance ),
                        point: interSegment.clone().applyMatrix4( this.matrixWorld ),
                        index: i,
                        face: null,
                        faceIndex: null,
                        object: this

                    } );

                }

            }

        } else if ( geometry instanceof THREE.Geometry ) {

            var vertices = geometry.vertices;
            var nbVertices = vertices.length;

            for ( var i = 0; i < nbVertices - 1; i += step ) {

                var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

                if ( distSq > precisionSq ) continue;

                interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

                var distance = raycaster.ray.origin.distanceTo( interRay );

                if ( distance < raycaster.near || distance > raycaster.far ) continue;

                intersects.push( {

                    distance: distance,
                    // What do we want? intersection point on the ray or on the segment??
                    // point: raycaster.ray.at( distance ),
                    point: interSegment.clone().applyMatrix4( this.matrixWorld ),
                    index: i,
                    face: null,
                    faceIndex: null,
                    object: this

                } );

            }

        }

    };

}() );

THREE.Line.prototype.clone = function () {

    return new this.constructor( this.geometry, this.material ).copy( this );

};

// DEPRECATED

THREE.LineStrip = 0;
THREE.LinePieces = 1;

// File:src/objects/LineSegments.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LineSegments = function ( geometry, material ) {

    THREE.Line.call( this, geometry, material );

    this.type = 'LineSegments';

};

THREE.LineSegments.prototype = Object.create( THREE.Line.prototype );
THREE.LineSegments.prototype.constructor = THREE.LineSegments;

// File:src/objects/Mesh.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

THREE.Mesh = function ( geometry, material ) {

    THREE.Object3D.call( this );

    this.type = 'Mesh';

    this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
    this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );

    this.updateMorphTargets();

};

THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );
THREE.Mesh.prototype.constructor = THREE.Mesh;

THREE.Mesh.prototype.updateMorphTargets = function () {

    if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {

        this.morphTargetBase = - 1;
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};

        for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {

            this.morphTargetInfluences.push( 0 );
            this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;

        }

    }

};

THREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {

    if ( this.morphTargetDictionary[ name ] !== undefined ) {

        return this.morphTargetDictionary[ name ];

    }

    console.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );

    return 0;

};


THREE.Mesh.prototype.raycast = ( function () {

    var inverseMatrix = new THREE.Matrix4();
    var ray = new THREE.Ray();
    var sphere = new THREE.Sphere();

    var vA = new THREE.Vector3();
    var vB = new THREE.Vector3();
    var vC = new THREE.Vector3();

    var tempA = new THREE.Vector3();
    var tempB = new THREE.Vector3();
    var tempC = new THREE.Vector3();

    var uvA = new THREE.Vector2();
    var uvB = new THREE.Vector2();
    var uvC = new THREE.Vector2();

    var barycoord = new THREE.Vector3();

    var intersectionPoint = new THREE.Vector3();
    var intersectionPointWorld = new THREE.Vector3();

    function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

        THREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );

        uv1.multiplyScalar( barycoord.x );
        uv2.multiplyScalar( barycoord.y );
        uv3.multiplyScalar( barycoord.z );

        uv1.add( uv2 ).add( uv3 );

        return uv1.clone();

    }

    function checkIntersection( object, raycaster, ray, pA, pB, pC, point ){

        var intersect;
        var material = object.material;

        if ( material.side === THREE.BackSide ) {

            intersect = ray.intersectTriangle( pC, pB, pA, true, point );

        } else {

            intersect = ray.intersectTriangle( pA, pB, pC, material.side !== THREE.DoubleSide, point );

        }

        if ( intersect === null ) return null;

        intersectionPointWorld.copy( point );
        intersectionPointWorld.applyMatrix4( object.matrixWorld );

        var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

        if ( distance < raycaster.near || distance > raycaster.far ) return null;

        return {
            distance: distance,
            point: intersectionPointWorld.clone(),
            object: object
        };

    }

    function checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {

        vA.fromArray( positions, a * 3 );
        vB.fromArray( positions, b * 3 );
        vC.fromArray( positions, c * 3 );

        var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );

        if ( intersection ) {

            if ( uvs ) {

                uvA.fromArray( uvs, a * 2 );
                uvB.fromArray( uvs, b * 2 );
                uvC.fromArray( uvs, c * 2 );

                intersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );

            }

            intersection.face = new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) );
            intersection.faceIndex = a;

        }

        return intersection;

    }

    return function raycast( raycaster, intersects ) {

        var geometry = this.geometry;
        var material = this.material;

        if ( material === undefined ) return;

        // Checking boundingSphere distance to ray

        if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

        var matrixWorld = this.matrixWorld;

        sphere.copy( geometry.boundingSphere );
        sphere.applyMatrix4( matrixWorld );

        if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) return;

        // Check boundingBox before continuing

        inverseMatrix.getInverse( matrixWorld );
        ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

        if ( geometry.boundingBox !== null ) {

            if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) return;

        }

        var uvs, intersection;

        if ( geometry instanceof THREE.BufferGeometry ) {

            var a, b, c;
            var index = geometry.index;
            var attributes = geometry.attributes;
            var positions = attributes.position.array;

            if ( attributes.uv !== undefined ){

                uvs = attributes.uv.array;

            }

            if ( index !== null ) {

                var indices = index.array;

                for ( var i = 0, l = indices.length; i < l; i += 3 ) {

                    a = indices[ i ];
                    b = indices[ i + 1 ];
                    c = indices[ i + 2 ];

                    intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );

                    if ( intersection ) {

                        intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
                        intersects.push( intersection );

                    }

                }

            } else {


                for ( var i = 0, l = positions.length; i < l; i += 9 ) {

                    a = i / 3;
                    b = a + 1;
                    c = a + 2;

                    intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );

                    if ( intersection ) {

                        intersection.index = a; // triangle number in positions buffer semantics
                        intersects.push( intersection );

                    }

                }

            }

        } else if ( geometry instanceof THREE.Geometry ) {

            var fvA, fvB, fvC;
            var isFaceMaterial = material instanceof THREE.MeshFaceMaterial;
            var materials = isFaceMaterial === true ? material.materials : null;

            var vertices = geometry.vertices;
            var faces = geometry.faces;
            var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
            if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;

            for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

                var face = faces[ f ];
                var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;

                if ( faceMaterial === undefined ) continue;

                fvA = vertices[ face.a ];
                fvB = vertices[ face.b ];
                fvC = vertices[ face.c ];

                if ( faceMaterial.morphTargets === true ) {

                    var morphTargets = geometry.morphTargets;
                    var morphInfluences = this.morphTargetInfluences;

                    vA.set( 0, 0, 0 );
                    vB.set( 0, 0, 0 );
                    vC.set( 0, 0, 0 );

                    for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

                        var influence = morphInfluences[ t ];

                        if ( influence === 0 ) continue;

                        var targets = morphTargets[ t ].vertices;

                        vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
                        vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
                        vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );

                    }

                    vA.add( fvA );
                    vB.add( fvB );
                    vC.add( fvC );

                    fvA = vA;
                    fvB = vB;
                    fvC = vC;

                }

                intersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );

                if ( intersection ) {

                    if ( uvs ) {

                        var uvs_f = uvs[ f ];
                        uvA.copy( uvs_f[ 0 ] );
                        uvB.copy( uvs_f[ 1 ] );
                        uvC.copy( uvs_f[ 2 ] );

                        intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );

                    }

                    intersection.face = face;
                    intersection.faceIndex = f;
                    intersects.push( intersection );

                }

            }

        }

    };

}() );

THREE.Mesh.prototype.clone = function () {

    return new this.constructor( this.geometry, this.material ).copy( this );

};

// File:src/objects/Bone.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.Bone = function ( skin ) {

    THREE.Object3D.call( this );

    this.type = 'Bone';

    this.skin = skin;

};

THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );
THREE.Bone.prototype.constructor = THREE.Bone;

THREE.Bone.prototype.copy = function ( source ) {

    THREE.Object3D.prototype.copy.call( this, source );

    this.skin = source.skin;

    return this;

};

// File:src/objects/Skeleton.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */

THREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {

    this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

    this.identityMatrix = new THREE.Matrix4();

    // copy the bone array

    bones = bones || [];

    this.bones = bones.slice( 0 );

    // create a bone texture or an array of floats

    if ( this.useVertexTexture ) {

        // layout (1 matrix = 4 pixels)
        //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
        //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
        //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
        //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
        //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


        var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
        size = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );
        size = Math.max( size, 4 );

        this.boneTextureWidth = size;
        this.boneTextureHeight = size;

        this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
        this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );

    } else {

        this.boneMatrices = new Float32Array( 16 * this.bones.length );

    }

    // use the supplied bone inverses or calculate the inverses

    if ( boneInverses === undefined ) {

        this.calculateInverses();

    } else {

        if ( this.bones.length === boneInverses.length ) {

            this.boneInverses = boneInverses.slice( 0 );

        } else {

            console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

            this.boneInverses = [];

            for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

                this.boneInverses.push( new THREE.Matrix4() );

            }

        }

    }

};

THREE.Skeleton.prototype.calculateInverses = function () {

    this.boneInverses = [];

    for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

        var inverse = new THREE.Matrix4();

        if ( this.bones[ b ] ) {

            inverse.getInverse( this.bones[ b ].matrixWorld );

        }

        this.boneInverses.push( inverse );

    }

};

THREE.Skeleton.prototype.pose = function () {

    var bone;

    // recover the bind-time world matrices

    for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

        bone = this.bones[ b ];

        if ( bone ) {

            bone.matrixWorld.getInverse( this.boneInverses[ b ] );

        }

    }

    // compute the local matrices, positions, rotations and scales

    for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

        bone = this.bones[ b ];

        if ( bone ) {

            if ( bone.parent ) {

                bone.matrix.getInverse( bone.parent.matrixWorld );
                bone.matrix.multiply( bone.matrixWorld );

            } else {

                bone.matrix.copy( bone.matrixWorld );

            }

            bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

        }

    }

};

THREE.Skeleton.prototype.update = ( function () {

    var offsetMatrix = new THREE.Matrix4();

    return function update() {

        // flatten bone matrices to array

        for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

            // compute the offset between the current and the original transform

            var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

            offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
            offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );

        }

        if ( this.useVertexTexture ) {

            this.boneTexture.needsUpdate = true;

        }

    };

} )();

THREE.Skeleton.prototype.clone = function () {

    return new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );

};

// File:src/objects/SkinnedMesh.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {

    THREE.Mesh.call( this, geometry, material );

    this.type = 'SkinnedMesh';

    this.bindMode = "attached";
    this.bindMatrix = new THREE.Matrix4();
    this.bindMatrixInverse = new THREE.Matrix4();

    // init bones

    // TODO: remove bone creation as there is no reason (other than
    // convenience) for THREE.SkinnedMesh to do this.

    var bones = [];

    if ( this.geometry && this.geometry.bones !== undefined ) {

        var bone, gbone;

        for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

            gbone = this.geometry.bones[ b ];

            bone = new THREE.Bone( this );
            bones.push( bone );

            bone.name = gbone.name;
            bone.position.fromArray( gbone.pos );
            bone.quaternion.fromArray( gbone.rotq );
            if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );

        }

        for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

            gbone = this.geometry.bones[ b ];

            if ( gbone.parent !== - 1 && gbone.parent !== null) {

                bones[ gbone.parent ].add( bones[ b ] );

            } else {

                this.add( bones[ b ] );

            }

        }

    }

    this.normalizeSkinWeights();

    this.updateMatrixWorld( true );
    this.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );

};


THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;

THREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {

    this.skeleton = skeleton;

    if ( bindMatrix === undefined ) {

        this.updateMatrixWorld( true );

        this.skeleton.calculateInverses();

        bindMatrix = this.matrixWorld;

    }

    this.bindMatrix.copy( bindMatrix );
    this.bindMatrixInverse.getInverse( bindMatrix );

};

THREE.SkinnedMesh.prototype.pose = function () {

    this.skeleton.pose();

};

THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {

    if ( this.geometry instanceof THREE.Geometry ) {

        for ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {

            var sw = this.geometry.skinWeights[ i ];

            var scale = 1.0 / sw.lengthManhattan();

            if ( scale !== Infinity ) {

                sw.multiplyScalar( scale );

            } else {

                sw.set( 1 ); // this will be normalized by the shader anyway

            }

        }

    } else {

        // skinning weights assumed to be normalized for THREE.BufferGeometry

    }

};

THREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {

    THREE.Mesh.prototype.updateMatrixWorld.call( this, true );

    if ( this.bindMode === "attached" ) {

        this.bindMatrixInverse.getInverse( this.matrixWorld );

    } else if ( this.bindMode === "detached" ) {

        this.bindMatrixInverse.getInverse( this.bindMatrix );

    } else {

        console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );

    }

};

THREE.SkinnedMesh.prototype.clone = function() {

    return new this.constructor( this.geometry, this.material, this.useVertexTexture ).copy( this );

};

// File:src/objects/LOD.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LOD = function () {

    THREE.Object3D.call( this );

    this.type = 'LOD';

    Object.defineProperties( this, {
        levels: {
            enumerable: true,
            value: []
        },
        objects: {
            get: function () {

                console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
                return this.levels;

            }
        }
    } );

};


THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );
THREE.LOD.prototype.constructor = THREE.LOD;

THREE.LOD.prototype.addLevel = function ( object, distance ) {

    if ( distance === undefined ) distance = 0;

    distance = Math.abs( distance );

    var levels = this.levels;

    for ( var l = 0; l < levels.length; l ++ ) {

        if ( distance < levels[ l ].distance ) {

            break;

        }

    }

    levels.splice( l, 0, { distance: distance, object: object } );

    this.add( object );

};

THREE.LOD.prototype.getObjectForDistance = function ( distance ) {

    var levels = this.levels;

    for ( var i = 1, l = levels.length; i < l; i ++ ) {

        if ( distance < levels[ i ].distance ) {

            break;

        }

    }

    return levels[ i - 1 ].object;

};

THREE.LOD.prototype.raycast = ( function () {

    var matrixPosition = new THREE.Vector3();

    return function raycast( raycaster, intersects ) {

        matrixPosition.setFromMatrixPosition( this.matrixWorld );

        var distance = raycaster.ray.origin.distanceTo( matrixPosition );

        this.getObjectForDistance( distance ).raycast( raycaster, intersects );

    };

}() );

THREE.LOD.prototype.update = function () {

    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();

    return function update( camera ) {

        var levels = this.levels;

        if ( levels.length > 1 ) {

            v1.setFromMatrixPosition( camera.matrixWorld );
            v2.setFromMatrixPosition( this.matrixWorld );

            var distance = v1.distanceTo( v2 );

            levels[ 0 ].object.visible = true;

            for ( var i = 1, l = levels.length; i < l; i ++ ) {

                if ( distance >= levels[ i ].distance ) {

                    levels[ i - 1 ].object.visible = false;
                    levels[ i ].object.visible = true;

                } else {

                    break;

                }

            }

            for ( ; i < l; i ++ ) {

                levels[ i ].object.visible = false;

            }

        }

    };

}();

THREE.LOD.prototype.copy = function ( source ) {

    THREE.Object3D.prototype.copy.call( this, source, false );

    var levels = source.levels;

    for ( var i = 0, l = levels.length; i < l; i ++ ) {

        var level = levels[ i ];

        this.addLevel( level.object.clone(), level.distance );

    }

    return this;

};

THREE.LOD.prototype.toJSON = function ( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    data.object.levels = [];

    var levels = this.levels;

    for ( var i = 0, l = levels.length; i < l; i ++ ) {

        var level = levels[ i ];

        data.object.levels.push( {
            object: level.object.uuid,
            distance: level.distance
        } );

    }

    return data;

};

// File:src/objects/Sprite.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Sprite = ( function () {

    var indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );
    var vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );
    var uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );

    var geometry = new THREE.BufferGeometry();
    geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
    geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
    geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

    return function Sprite( material ) {

        THREE.Object3D.call( this );

        this.type = 'Sprite';

        this.geometry = geometry;
        this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();

    };

} )();

THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );
THREE.Sprite.prototype.constructor = THREE.Sprite;

THREE.Sprite.prototype.raycast = ( function () {

    var matrixPosition = new THREE.Vector3();

    return function raycast( raycaster, intersects ) {

        matrixPosition.setFromMatrixPosition( this.matrixWorld );

        var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );
        var guessSizeSq = this.scale.x * this.scale.y;

        if ( distanceSq > guessSizeSq ) {

            return;

        }

        intersects.push( {

            distance: Math.sqrt( distanceSq ),
            point: this.position,
            face: null,
            object: this

        } );

    };

}() );

THREE.Sprite.prototype.clone = function () {

    return new this.constructor( this.material ).copy( this );

};

// Backwards compatibility

THREE.Particle = THREE.Sprite;

// File:src/objects/LensFlare.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlare = function ( texture, size, distance, blending, color ) {

    THREE.Object3D.call( this );

    this.lensFlares = [];

    this.positionScreen = new THREE.Vector3();
    this.customUpdateCallback = undefined;

    if ( texture !== undefined ) {

        this.add( texture, size, distance, blending, color );

    }

};

THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );
THREE.LensFlare.prototype.constructor = THREE.LensFlare;


/*
 * Add: adds another flare
 */

THREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {

    if ( size === undefined ) size = - 1;
    if ( distance === undefined ) distance = 0;
    if ( opacity === undefined ) opacity = 1;
    if ( color === undefined ) color = new THREE.Color( 0xffffff );
    if ( blending === undefined ) blending = THREE.NormalBlending;

    distance = Math.min( distance, Math.max( 0, distance ) );

    this.lensFlares.push( {
        texture: texture,	// THREE.Texture
        size: size, 		// size in pixels (-1 = use texture.width)
        distance: distance, 	// distance (0-1) from light source (0=at light source)
        x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back
        scale: 1, 		// scale
        rotation: 0, 		// rotation
        opacity: opacity,	// opacity
        color: color,		// color
        blending: blending	// blending
    } );

};

/*
 * Update lens flares update positions on all flares based on the screen position
 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
 */

THREE.LensFlare.prototype.updateLensFlares = function () {

    var f, fl = this.lensFlares.length;
    var flare;
    var vecX = - this.positionScreen.x * 2;
    var vecY = - this.positionScreen.y * 2;

    for ( f = 0; f < fl; f ++ ) {

        flare = this.lensFlares[ f ];

        flare.x = this.positionScreen.x + vecX * flare.distance;
        flare.y = this.positionScreen.y + vecY * flare.distance;

        flare.wantedRotation = flare.x * Math.PI * 0.25;
        flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

    }

};

THREE.LensFlare.prototype.copy = function ( source ) {

    THREE.Object3D.prototype.copy.call( this, source );

    this.positionScreen.copy( source.positionScreen );
    this.customUpdateCallback = source.customUpdateCallback;

    for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {

        this.lensFlares.push( source.lensFlares[ i ] );

    }

    return this;

};

// File:src/scenes/Scene.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Scene = function () {

    THREE.Object3D.call( this );

    this.type = 'Scene';

    this.fog = null;
    this.overrideMaterial = null;

    this.autoUpdate = true; // checked by the renderer

};

THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );
THREE.Scene.prototype.constructor = THREE.Scene;

THREE.Scene.prototype.copy = function ( source ) {

    THREE.Object3D.prototype.copy.call( this, source );

    if ( source.fog !== null ) this.fog = source.fog.clone();
    if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

    this.autoUpdate = source.autoUpdate;
    this.matrixAutoUpdate = source.matrixAutoUpdate;

    return this;

};

// File:src/scenes/Fog.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Fog = function ( color, near, far ) {

    this.name = '';

    this.color = new THREE.Color( color );

    this.near = ( near !== undefined ) ? near : 1;
    this.far = ( far !== undefined ) ? far : 1000;

};

THREE.Fog.prototype.clone = function () {

    return new THREE.Fog( this.color.getHex(), this.near, this.far );

};

// File:src/scenes/FogExp2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.FogExp2 = function ( color, density ) {

    this.name = '';

    this.color = new THREE.Color( color );
    this.density = ( density !== undefined ) ? density : 0.00025;

};

THREE.FogExp2.prototype.clone = function () {

    return new THREE.FogExp2( this.color.getHex(), this.density );

};

// File:src/renderers/shaders/ShaderChunk.js

THREE.ShaderChunk = {};

// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl

THREE.ShaderChunk[ 'alphamap_fragment'] = "#ifdef USE_ALPHAMAP\n\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl

THREE.ShaderChunk[ 'alphamap_pars_fragment'] = "#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl

THREE.ShaderChunk[ 'alphatest_fragment'] = "#ifdef ALPHATEST\n\n	if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl

THREE.ShaderChunk[ 'aomap_fragment'] = "#ifdef USE_AOMAP\n\n	totalAmbientLight *= ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl

THREE.ShaderChunk[ 'aomap_pars_fragment'] = "#ifdef USE_AOMAP\n\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl

THREE.ShaderChunk[ 'begin_vertex'] = "\nvec3 transformed = vec3( position );\n";

// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl

THREE.ShaderChunk[ 'beginnormal_vertex'] = "\nvec3 objectNormal = vec3( normal );\n";

// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl

THREE.ShaderChunk[ 'bumpmap_pars_fragment'] = "#ifdef USE_BUMPMAP\n\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n\n\n\n	vec2 dHdxy_fwd() {\n\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n		return vec2( dBx, dBy );\n\n	}\n\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n\n		float fDet = dot( vSigmaX, R1 );\n\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl

THREE.ShaderChunk[ 'color_fragment'] = "#ifdef USE_COLOR\n\n	diffuseColor.rgb *= vColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl

THREE.ShaderChunk[ 'color_pars_fragment'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl

THREE.ShaderChunk[ 'color_pars_vertex'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl

THREE.ShaderChunk[ 'color_vertex'] = "#ifdef USE_COLOR\n\n	vColor.xyz = color.xyz;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/common.glsl

THREE.ShaderChunk[ 'common'] = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n\n	return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n\n}\n\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\n	return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	float distance = dot( planeNormal, point - pointOnPlane );\n\n	return - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n\n	if ( decayExponent > 0.0 ) {\n\n	  return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n	}\n\n	return 1.0;\n\n}\n\nvec3 F_Schlick( in vec3 specularColor, in float dotLH ) {\n\n\n	float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );\n\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n\n}\n\nfloat G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {\n\n\n	return 0.25;\n\n}\n\nfloat D_BlinnPhong( in float shininess, in float dotNH ) {\n\n\n	return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {\n\n	vec3 halfDir = normalize( lightDir + viewDir );\n\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( lightDir, halfDir ) );\n\n	vec3 F = F_Schlick( specularColor, dotLH );\n\n	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n	float D = D_BlinnPhong( shininess, dotNH );\n\n	return F * G * D;\n\n}\n\nvec3 inputToLinear( in vec3 a ) {\n\n	#ifdef GAMMA_INPUT\n\n		return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n\n	#else\n\n		return a;\n\n	#endif\n\n}\n\nvec3 linearToOutput( in vec3 a ) {\n\n	#ifdef GAMMA_OUTPUT\n\n		return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\n	#else\n\n		return a;\n\n	#endif\n\n}\n";

// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl

THREE.ShaderChunk[ 'defaultnormal_vertex'] = "#ifdef FLIP_SIDED\n\n	objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n";

// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl

THREE.ShaderChunk[ 'displacementmap_vertex'] = "#ifdef USE_DISPLACEMENTMAP\n\n	transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl

THREE.ShaderChunk[ 'displacementmap_pars_vertex'] = "#ifdef USE_DISPLACEMENTMAP\n\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl

THREE.ShaderChunk[ 'emissivemap_fragment'] = "#ifdef USE_EMISSIVEMAP\n\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n	emissiveColor.rgb = inputToLinear( emissiveColor.rgb );\n\n	totalEmissiveLight *= emissiveColor.rgb;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl

THREE.ShaderChunk[ 'emissivemap_pars_fragment'] = "#ifdef USE_EMISSIVEMAP\n\n	uniform sampler2D emissiveMap;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl

THREE.ShaderChunk[ 'envmap_fragment'] = "#ifdef USE_ENVMAP\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n		#ifdef ENVMAP_MODE_REFLECTION\n\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n		#else\n\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n		#endif\n\n	#else\n\n		vec3 reflectVec = vReflect;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n		float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#else\n		float flipNormal = 1.0;\n	#endif\n\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n\n	envColor.xyz = inputToLinear( envColor.xyz );\n\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_MIX )\n\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_ADD )\n\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl

THREE.ShaderChunk[ 'envmap_pars_fragment'] = "#ifdef USE_ENVMAP\n\n	uniform float reflectivity;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		uniform float refractionRatio;\n\n	#else\n\n		varying vec3 vReflect;\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl

THREE.ShaderChunk[ 'envmap_pars_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	varying vec3 vReflect;\n\n	uniform float refractionRatio;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl

THREE.ShaderChunk[ 'envmap_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n	vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\n	#ifdef ENVMAP_MODE_REFLECTION\n\n		vReflect = reflect( cameraToVertex, worldNormal );\n\n	#else\n\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl

THREE.ShaderChunk[ 'fog_fragment'] = "#ifdef USE_FOG\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n	#else\n\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n	#endif\n\n	#ifdef FOG_EXP2\n\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\n	#else\n\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n	#endif\n	\n	outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl

THREE.ShaderChunk[ 'fog_pars_fragment'] = "#ifdef USE_FOG\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/hemilight_fragment.glsl

THREE.ShaderChunk[ 'hemilight_fragment'] = "#if MAX_HEMI_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lightDir = hemisphereLightDirection[ i ];\n\n		float dotProduct = dot( normal, lightDir );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vec3 lightColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		totalAmbientLight += lightColor;\n\n	}\n\n#endif\n\n";

// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl

THREE.ShaderChunk[ 'lightmap_fragment'] = "#ifdef USE_LIGHTMAP\n\n	totalAmbientLight += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl

THREE.ShaderChunk[ 'lightmap_pars_fragment'] = "#ifdef USE_LIGHTMAP\n\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_pars_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_pars_vertex'] = "#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_vertex'] = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vec3( 0.0 );\n\n#endif\n\nvec3 normal = normalize( transformedNormal );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = pointLightColor[ i ];\n\n		vec3 lVector = pointLightPosition[ i ] - mvPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n\n		float dotProduct = dot( normal, lightDir );\n\n		vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = spotLightColor[ i ];\n\n		vec3 lightPosition = spotLightPosition[ i ];\n		vec3 lVector = lightPosition - mvPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], lightDir );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			attenuation *= spotEffect;\n\n\n			float dotProduct = dot( normal, lightDir );\n\n			vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n			#ifdef DOUBLE_SIDED\n\n				vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n			#endif\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 lightColor = directionalLightColor[ i ];\n\n		vec3 lightDir = directionalLightDirection[ i ];\n\n\n		float dotProduct = dot( normal, lightDir );\n\n		vLightFront += lightColor * saturate( dotProduct );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += lightColor * saturate( - dotProduct );\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lightDir = hemisphereLightDirection[ i ];\n\n\n		float dotProduct = dot( normal, lightDir );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		#ifdef DOUBLE_SIDED\n\n			float hemiDiffuseWeightBack = - 0.5 * dotProduct + 0.5;\n\n			vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n		#endif\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_fragment'] = "vec3 viewDir = normalize( vViewPosition );\n\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = pointLightColor[ i ];\n\n		vec3 lightPosition = pointLightPosition[ i ];\n		vec3 lVector = lightPosition + vViewPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n\n		float cosineTerm = saturate( dot( normal, lightDir ) );\n\n		totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = spotLightColor[ i ];\n\n		vec3 lightPosition = spotLightPosition[ i ];\n		vec3 lVector = lightPosition + vViewPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], lightDir );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			attenuation *= spotEffect;\n\n\n			float cosineTerm = saturate( dot( normal, lightDir ) );\n\n			totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n\n			vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n			totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 lightColor = directionalLightColor[ i ];\n\n		vec3 lightDir = directionalLightDirection[ i ];\n\n\n		float cosineTerm = saturate( dot( normal, lightDir ) );\n\n		totalDiffuseLight += lightColor * cosineTerm;\n\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * cosineTerm;\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_pars_fragment'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_pars_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	vWorldPosition = worldPosition.xyz;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl

THREE.ShaderChunk[ 'linear_to_gamma_fragment'] = "\n	outgoingLight = linearToOutput( outgoingLight );\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_fragment'] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_fragment'] = "#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n	uniform float logDepthBufFC;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl

THREE.ShaderChunk[ 'map_fragment'] = "#ifdef USE_MAP\n\n	vec4 texelColor = texture2D( map, vUv );\n\n	texelColor.xyz = inputToLinear( texelColor.xyz );\n\n	diffuseColor *= texelColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl

THREE.ShaderChunk[ 'map_pars_fragment'] = "#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl

THREE.ShaderChunk[ 'map_particle_fragment'] = "#ifdef USE_MAP\n\n	diffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl

THREE.ShaderChunk[ 'map_particle_pars_fragment'] = "#ifdef USE_MAP\n\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl

THREE.ShaderChunk[ 'morphnormal_vertex'] = "#ifdef USE_MORPHNORMALS\n\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_pars_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	#ifndef USE_MORPHNORMALS\n\n	uniform float morphTargetInfluences[ 8 ];\n\n	#else\n\n	uniform float morphTargetInfluences[ 4 ];\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n	#ifndef USE_MORPHNORMALS\n\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/normal_phong_fragment.glsl

THREE.ShaderChunk[ 'normal_phong_fragment'] = "#ifndef FLAT_SHADED\n\n	vec3 normal = normalize( vNormal );\n\n	#ifdef DOUBLE_SIDED\n\n		normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n	#endif\n\n#else\n\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\n";

// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl

THREE.ShaderChunk[ 'normalmap_pars_fragment'] = "#ifdef USE_NORMALMAP\n\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n\n\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl

THREE.ShaderChunk[ 'project_vertex'] = "#ifdef USE_SKINNING\n\n	vec4 mvPosition = modelViewMatrix * skinned;\n\n#else\n\n	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_fragment'] = "#ifdef USE_SHADOWMAP\n\n	for ( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		float texelSizeY =  1.0 / shadowMapSize[ i ].y;\n\n		float shadow = 0.0;\n\n#if defined( POINT_LIGHT_SHADOWS )\n\n		bool isPointLight = shadowDarkness[ i ] < 0.0;\n\n		if ( isPointLight ) {\n\n			float realShadowDarkness = abs( shadowDarkness[ i ] );\n\n			vec3 lightToPosition = vShadowCoord[ i ].xyz;\n\n	#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n			vec3 bd3D = normalize( lightToPosition );\n			float dp = length( lightToPosition );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D, texelSizeY ) ), shadowBias[ i ], shadow );\n\n\n	#if defined( SHADOWMAP_TYPE_PCF )\n			const float Dr = 1.25;\n	#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			const float Dr = 2.25;\n	#endif\n\n			float os = Dr *  2.0 * texelSizeY;\n\n			const vec3 Gsd = vec3( - 1, 0, 1 );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zyz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xyz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zyx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xyx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\n			shadow *= realShadowDarkness * ( 1.0 / 21.0 );\n\n	#else \n			vec3 bd3D = normalize( lightToPosition );\n			float dp = length( lightToPosition );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D, texelSizeY ) ), shadowBias[ i ], shadow );\n\n			shadow *= realShadowDarkness;\n\n	#endif\n\n		} else {\n\n#endif \n			float texelSizeX =  1.0 / shadowMapSize[ i ].x;\n\n			vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n\n			bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n			bool inFrustum = all( inFrustumVec );\n\n			bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n			bool frustumTest = all( frustumTestVec );\n\n			if ( frustumTest ) {\n\n	#if defined( SHADOWMAP_TYPE_PCF )\n\n\n				/*\n					for ( float y = -1.25; y <= 1.25; y += 1.25 )\n						for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n							vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n							float fDepth = unpackDepth( rgbaDepth );\n							if ( fDepth < shadowCoord.z )\n								shadow += 1.0;\n					}\n					shadow /= 9.0;\n				*/\n\n				shadowCoord.z += shadowBias[ i ];\n\n				const float ShadowDelta = 1.0 / 9.0;\n\n				float xPixelOffset = texelSizeX;\n				float yPixelOffset = texelSizeY;\n\n				float dx0 = - 1.25 * xPixelOffset;\n				float dy0 = - 1.25 * yPixelOffset;\n				float dx1 = 1.25 * xPixelOffset;\n				float dy1 = 1.25 * yPixelOffset;\n\n				float fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				shadow *= shadowDarkness[ i ];\n\n	#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\n				shadowCoord.z += shadowBias[ i ];\n\n				float xPixelOffset = texelSizeX;\n				float yPixelOffset = texelSizeY;\n\n				float dx0 = - 1.0 * xPixelOffset;\n				float dy0 = - 1.0 * yPixelOffset;\n				float dx1 = 1.0 * xPixelOffset;\n				float dy1 = 1.0 * yPixelOffset;\n\n				mat3 shadowKernel;\n				mat3 depthKernel;\n\n				depthKernel[ 0 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				depthKernel[ 0 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				depthKernel[ 0 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				depthKernel[ 1 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				depthKernel[ 1 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				depthKernel[ 1 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				depthKernel[ 2 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				depthKernel[ 2 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				depthKernel[ 2 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n				vec3 shadowZ = vec3( shadowCoord.z );\n				shadowKernel[ 0 ] = vec3( lessThan( depthKernel[ 0 ], shadowZ ) );\n				shadowKernel[ 0 ] *= vec3( 0.25 );\n\n				shadowKernel[ 1 ] = vec3( lessThan( depthKernel[ 1 ], shadowZ ) );\n				shadowKernel[ 1 ] *= vec3( 0.25 );\n\n				shadowKernel[ 2 ] = vec3( lessThan( depthKernel[ 2 ], shadowZ ) );\n				shadowKernel[ 2 ] *= vec3( 0.25 );\n\n				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[ i ].xy );\n\n				shadowKernel[ 0 ] = mix( shadowKernel[ 1 ], shadowKernel[ 0 ], fractionalCoord.x );\n				shadowKernel[ 1 ] = mix( shadowKernel[ 2 ], shadowKernel[ 1 ], fractionalCoord.x );\n\n				vec4 shadowValues;\n				shadowValues.x = mix( shadowKernel[ 0 ][ 1 ], shadowKernel[ 0 ][ 0 ], fractionalCoord.y );\n				shadowValues.y = mix( shadowKernel[ 0 ][ 2 ], shadowKernel[ 0 ][ 1 ], fractionalCoord.y );\n				shadowValues.z = mix( shadowKernel[ 1 ][ 1 ], shadowKernel[ 1 ][ 0 ], fractionalCoord.y );\n				shadowValues.w = mix( shadowKernel[ 1 ][ 2 ], shadowKernel[ 1 ][ 1 ], fractionalCoord.y );\n\n				shadow = dot( shadowValues, vec4( 1.0 ) ) * shadowDarkness[ i ];\n\n	#else \n				shadowCoord.z += shadowBias[ i ];\n\n				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n				float fDepth = unpackDepth( rgbaDepth );\n\n				if ( fDepth < shadowCoord.z )\n					shadow = shadowDarkness[ i ];\n\n	#endif\n\n			}\n\n#ifdef SHADOWMAP_DEBUG\n\n			if ( inFrustum ) {\n\n				if ( i == 0 ) {\n\n					outgoingLight *= vec3( 1.0, 0.5, 0.0 );\n\n				} else if ( i == 1 ) {\n\n					outgoingLight *= vec3( 0.0, 1.0, 0.8 );\n\n				} else {\n\n					outgoingLight *= vec3( 0.0, 0.5, 1.0 );\n\n				}\n\n			}\n\n#endif\n\n#if defined( POINT_LIGHT_SHADOWS )\n\n		}\n\n#endif\n\n		shadowMask = shadowMask * vec3( 1.0 - shadow );\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_pars_fragment'] = "#ifdef USE_SHADOWMAP\n\n	uniform sampler2D shadowMap[ MAX_SHADOWS ];\n	uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform float shadowBias[ MAX_SHADOWS ];\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n	float unpackDepth( const in vec4 rgba_depth ) {\n\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		float depth = dot( rgba_depth, bit_shift );\n		return depth;\n\n	}\n\n	#if defined(POINT_LIGHT_SHADOWS)\n\n\n		void adjustShadowValue1K( const float testDepth, const vec4 textureData, const float bias, inout float shadowValue ) {\n\n			const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n			if ( testDepth >= dot( textureData, bitSh ) * 1000.0 + bias )\n				shadowValue += 1.0;\n\n		}\n\n\n		vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n\n			vec3 absV = abs( v );\n\n\n			float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n			absV *= scaleToCube;\n\n\n			v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n\n\n			vec2 planar = v.xy;\n\n			float almostATexel = 1.5 * texelSizeY;\n			float almostOne = 1.0 - almostATexel;\n\n			if ( absV.z >= almostOne ) {\n\n				if ( v.z > 0.0 )\n					planar.x = 4.0 - v.x;\n\n			} else if ( absV.x >= almostOne ) {\n\n				float signX = sign( v.x );\n				planar.x = v.z * signX + 2.0 * signX;\n\n			} else if ( absV.y >= almostOne ) {\n\n				float signY = sign( v.y );\n				planar.x = v.x + 2.0 * signY + 2.0;\n				planar.y = v.z * signY - 2.0;\n\n			}\n\n\n			return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n		}\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_pars_vertex'] = "#ifdef USE_SHADOWMAP\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_vertex'] = "#ifdef USE_SHADOWMAP\n\n	for ( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n			vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n	}\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl

THREE.ShaderChunk[ 'skinbase_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl

THREE.ShaderChunk[ 'skinning_pars_vertex'] = "#ifdef USE_SKINNING\n\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n\n	#ifdef BONE_TEXTURE\n\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n\n			y = dy * ( y + 0.5 );\n\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n			mat4 bone = mat4( v1, v2, v3, v4 );\n\n			return bone;\n\n		}\n\n	#else\n\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n\n		}\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl

THREE.ShaderChunk[ 'skinning_vertex'] = "#ifdef USE_SKINNING\n\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl

THREE.ShaderChunk[ 'skinnormal_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl

THREE.ShaderChunk[ 'specularmap_fragment'] = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n\n#else\n\n	specularStrength = 1.0;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl

THREE.ShaderChunk[ 'specularmap_pars_fragment'] = "#ifdef USE_SPECULARMAP\n\n	uniform sampler2D specularMap;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl

THREE.ShaderChunk[ 'uv2_pars_fragment'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	varying vec2 vUv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl

THREE.ShaderChunk[ 'uv2_pars_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl

THREE.ShaderChunk[ 'uv2_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	vUv2 = uv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl

THREE.ShaderChunk[ 'uv_pars_fragment'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	varying vec2 vUv;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl

THREE.ShaderChunk[ 'uv_pars_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl

THREE.ShaderChunk[ 'uv_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl

THREE.ShaderChunk[ 'worldpos_vertex'] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n	#ifdef USE_SKINNING\n\n		vec4 worldPosition = modelMatrix * skinned;\n\n	#else\n\n		vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/UniformsUtils.js

/**
 * Uniform Utilities
 */

THREE.UniformsUtils = {

    merge: function ( uniforms ) {

        var merged = {};

        for ( var u = 0; u < uniforms.length; u ++ ) {

            var tmp = this.clone( uniforms[ u ] );

            for ( var p in tmp ) {

                merged[ p ] = tmp[ p ];

            }

        }

        return merged;

    },

    clone: function ( uniforms_src ) {

        var uniforms_dst = {};

        for ( var u in uniforms_src ) {

            uniforms_dst[ u ] = {};

            for ( var p in uniforms_src[ u ] ) {

                var parameter_src = uniforms_src[ u ][ p ];

                if ( parameter_src instanceof THREE.Color ||
                    parameter_src instanceof THREE.Vector2 ||
                    parameter_src instanceof THREE.Vector3 ||
                    parameter_src instanceof THREE.Vector4 ||
                    parameter_src instanceof THREE.Matrix3 ||
                    parameter_src instanceof THREE.Matrix4 ||
                    parameter_src instanceof THREE.Texture ) {

                    uniforms_dst[ u ][ p ] = parameter_src.clone();

                } else if ( Array.isArray( parameter_src ) ) {

                    uniforms_dst[ u ][ p ] = parameter_src.slice();

                } else {

                    uniforms_dst[ u ][ p ] = parameter_src;

                }

            }

        }

        return uniforms_dst;

    }

};

// File:src/renderers/shaders/UniformsLib.js

/**
 * Uniforms library for shared webgl shaders
 */

THREE.UniformsLib = {

    common: {

        "diffuse" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
        "opacity" : { type: "f", value: 1.0 },

        "map" : { type: "t", value: null },
        "offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

        "specularMap" : { type: "t", value: null },
        "alphaMap" : { type: "t", value: null },

        "envMap" : { type: "t", value: null },
        "flipEnvMap" : { type: "f", value: - 1 },
        "reflectivity" : { type: "f", value: 1.0 },
        "refractionRatio" : { type: "f", value: 0.98 }

    },

    aomap: {

        "aoMap" : { type: "t", value: null },
        "aoMapIntensity" : { type: "f", value: 1 },

    },

    lightmap: {

        "lightMap" : { type: "t", value: null },
        "lightMapIntensity" : { type: "f", value: 1 },

    },

    emissivemap: {

        "emissiveMap" : { type: "t", value: null },

    },

    bumpmap: {

        "bumpMap" : { type: "t", value: null },
        "bumpScale" : { type: "f", value: 1 }

    },

    normalmap: {

        "normalMap" : { type: "t", value: null },
        "normalScale" : { type: "v2", value: new THREE.Vector2( 1, 1 ) }

    },

    displacementmap: {

        "displacementMap" : { type: "t", value: null },
        "displacementScale" : { type: "f", value: 1 },
        "displacementBias" : { type: "f", value: 0 }

    },

    fog : {

        "fogDensity" : { type: "f", value: 0.00025 },
        "fogNear" : { type: "f", value: 1 },
        "fogFar" : { type: "f", value: 2000 },
        "fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

    },

    lights: {

        "ambientLightColor" : { type: "fv", value: [] },

        "directionalLightDirection" : { type: "fv", value: [] },
        "directionalLightColor" : { type: "fv", value: [] },

        "hemisphereLightDirection" : { type: "fv", value: [] },
        "hemisphereLightSkyColor" : { type: "fv", value: [] },
        "hemisphereLightGroundColor" : { type: "fv", value: [] },

        "pointLightColor" : { type: "fv", value: [] },
        "pointLightPosition" : { type: "fv", value: [] },
        "pointLightDistance" : { type: "fv1", value: [] },
        "pointLightDecay" : { type: "fv1", value: [] },

        "spotLightColor" : { type: "fv", value: [] },
        "spotLightPosition" : { type: "fv", value: [] },
        "spotLightDirection" : { type: "fv", value: [] },
        "spotLightDistance" : { type: "fv1", value: [] },
        "spotLightAngleCos" : { type: "fv1", value: [] },
        "spotLightExponent" : { type: "fv1", value: [] },
        "spotLightDecay" : { type: "fv1", value: [] }

    },

    points: {

        "psColor" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
        "opacity" : { type: "f", value: 1.0 },
        "size" : { type: "f", value: 1.0 },
        "scale" : { type: "f", value: 1.0 },
        "map" : { type: "t", value: null },
        "offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

        "fogDensity" : { type: "f", value: 0.00025 },
        "fogNear" : { type: "f", value: 1 },
        "fogFar" : { type: "f", value: 2000 },
        "fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

    },

    shadowmap: {

        "shadowMap": { type: "tv", value: [] },
        "shadowMapSize": { type: "v2v", value: [] },

        "shadowBias" : { type: "fv1", value: [] },
        "shadowDarkness": { type: "fv1", value: [] },

        "shadowMatrix" : { type: "m4v", value: [] }

    }

};

// File:src/renderers/shaders/ShaderLib.js

/**
 * Webgl Shader Library for three.js
 *
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */


THREE.ShaderLib = {

    'basic': {

        uniforms: THREE.UniformsUtils.merge( [

            THREE.UniformsLib[ "common" ],
            THREE.UniformsLib[ "aomap" ],
            THREE.UniformsLib[ "fog" ],
            THREE.UniformsLib[ "shadowmap" ]

        ] ),

        vertexShader: [

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "uv_pars_vertex" ],
            THREE.ShaderChunk[ "uv2_pars_vertex" ],
            THREE.ShaderChunk[ "envmap_pars_vertex" ],
            THREE.ShaderChunk[ "color_pars_vertex" ],
            THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
            THREE.ShaderChunk[ "skinning_pars_vertex" ],
            THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "uv_vertex" ],
            THREE.ShaderChunk[ "uv2_vertex" ],
            THREE.ShaderChunk[ "color_vertex" ],
            THREE.ShaderChunk[ "skinbase_vertex" ],

            "	#ifdef USE_ENVMAP",

            THREE.ShaderChunk[ "beginnormal_vertex" ],
            THREE.ShaderChunk[ "morphnormal_vertex" ],
            THREE.ShaderChunk[ "skinnormal_vertex" ],
            THREE.ShaderChunk[ "defaultnormal_vertex" ],

            "	#endif",

            THREE.ShaderChunk[ "begin_vertex" ],
            THREE.ShaderChunk[ "morphtarget_vertex" ],
            THREE.ShaderChunk[ "skinning_vertex" ],
            THREE.ShaderChunk[ "project_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            THREE.ShaderChunk[ "worldpos_vertex" ],
            THREE.ShaderChunk[ "envmap_vertex" ],
            THREE.ShaderChunk[ "shadowmap_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform vec3 diffuse;",
            "uniform float opacity;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_fragment" ],
            THREE.ShaderChunk[ "uv_pars_fragment" ],
            THREE.ShaderChunk[ "uv2_pars_fragment" ],
            THREE.ShaderChunk[ "map_pars_fragment" ],
            THREE.ShaderChunk[ "alphamap_pars_fragment" ],
            THREE.ShaderChunk[ "aomap_pars_fragment" ],
            THREE.ShaderChunk[ "envmap_pars_fragment" ],
            THREE.ShaderChunk[ "fog_pars_fragment" ],
            THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
            THREE.ShaderChunk[ "specularmap_pars_fragment" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	vec3 outgoingLight = vec3( 0.0 );",
            "	vec4 diffuseColor = vec4( diffuse, opacity );",
            "	vec3 totalAmbientLight = vec3( 1.0 );", // hardwired
            "	vec3 shadowMask = vec3( 1.0 );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],
            THREE.ShaderChunk[ "map_fragment" ],
            THREE.ShaderChunk[ "color_fragment" ],
            THREE.ShaderChunk[ "alphamap_fragment" ],
            THREE.ShaderChunk[ "alphatest_fragment" ],
            THREE.ShaderChunk[ "specularmap_fragment" ],
            THREE.ShaderChunk[ "aomap_fragment" ],
            THREE.ShaderChunk[ "shadowmap_fragment" ],

            "	outgoingLight = diffuseColor.rgb * totalAmbientLight * shadowMask;",

            THREE.ShaderChunk[ "envmap_fragment" ],

            THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

            THREE.ShaderChunk[ "fog_fragment" ],

            "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

            "}"

        ].join( "\n" )

    },

    'lambert': {

        uniforms: THREE.UniformsUtils.merge( [

            THREE.UniformsLib[ "common" ],
            THREE.UniformsLib[ "fog" ],
            THREE.UniformsLib[ "lights" ],
            THREE.UniformsLib[ "shadowmap" ],

            {
                "emissive" : { type: "c", value: new THREE.Color( 0x000000 ) }
            }

        ] ),

        vertexShader: [

            "#define LAMBERT",

            "varying vec3 vLightFront;",

            "#ifdef DOUBLE_SIDED",

            "	varying vec3 vLightBack;",

            "#endif",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "uv_pars_vertex" ],
            THREE.ShaderChunk[ "uv2_pars_vertex" ],
            THREE.ShaderChunk[ "envmap_pars_vertex" ],
            THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
            THREE.ShaderChunk[ "color_pars_vertex" ],
            THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
            THREE.ShaderChunk[ "skinning_pars_vertex" ],
            THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "uv_vertex" ],
            THREE.ShaderChunk[ "uv2_vertex" ],
            THREE.ShaderChunk[ "color_vertex" ],

            THREE.ShaderChunk[ "beginnormal_vertex" ],
            THREE.ShaderChunk[ "morphnormal_vertex" ],
            THREE.ShaderChunk[ "skinbase_vertex" ],
            THREE.ShaderChunk[ "skinnormal_vertex" ],
            THREE.ShaderChunk[ "defaultnormal_vertex" ],

            THREE.ShaderChunk[ "begin_vertex" ],
            THREE.ShaderChunk[ "morphtarget_vertex" ],
            THREE.ShaderChunk[ "skinning_vertex" ],
            THREE.ShaderChunk[ "project_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            THREE.ShaderChunk[ "worldpos_vertex" ],
            THREE.ShaderChunk[ "envmap_vertex" ],
            THREE.ShaderChunk[ "lights_lambert_vertex" ],
            THREE.ShaderChunk[ "shadowmap_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform vec3 diffuse;",
            "uniform vec3 emissive;",
            "uniform float opacity;",

            "uniform vec3 ambientLightColor;",

            "varying vec3 vLightFront;",

            "#ifdef DOUBLE_SIDED",

            "	varying vec3 vLightBack;",

            "#endif",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_fragment" ],
            THREE.ShaderChunk[ "uv_pars_fragment" ],
            THREE.ShaderChunk[ "uv2_pars_fragment" ],
            THREE.ShaderChunk[ "map_pars_fragment" ],
            THREE.ShaderChunk[ "alphamap_pars_fragment" ],
            THREE.ShaderChunk[ "envmap_pars_fragment" ],
            THREE.ShaderChunk[ "fog_pars_fragment" ],
            THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
            THREE.ShaderChunk[ "specularmap_pars_fragment" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	vec3 outgoingLight = vec3( 0.0 );",	// outgoing light does not have an alpha, the surface does
            "	vec4 diffuseColor = vec4( diffuse, opacity );",
            "	vec3 totalAmbientLight = ambientLightColor;",
            "	vec3 shadowMask = vec3( 1.0 );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],
            THREE.ShaderChunk[ "map_fragment" ],
            THREE.ShaderChunk[ "color_fragment" ],
            THREE.ShaderChunk[ "alphamap_fragment" ],
            THREE.ShaderChunk[ "alphatest_fragment" ],
            THREE.ShaderChunk[ "specularmap_fragment" ],
            THREE.ShaderChunk[ "shadowmap_fragment" ],

            "	#ifdef DOUBLE_SIDED",

            "		if ( gl_FrontFacing )",
            "			outgoingLight += diffuseColor.rgb * ( vLightFront * shadowMask + totalAmbientLight ) + emissive;",
            "		else",
            "			outgoingLight += diffuseColor.rgb * ( vLightBack * shadowMask + totalAmbientLight ) + emissive;",

            "	#else",

            "		outgoingLight += diffuseColor.rgb * ( vLightFront * shadowMask + totalAmbientLight ) + emissive;",

            "	#endif",

            THREE.ShaderChunk[ "envmap_fragment" ],

            THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

            THREE.ShaderChunk[ "fog_fragment" ],

            "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

            "}"

        ].join( "\n" )

    },

    'phong': {

        uniforms: THREE.UniformsUtils.merge( [

            THREE.UniformsLib[ "common" ],
            THREE.UniformsLib[ "aomap" ],
            THREE.UniformsLib[ "lightmap" ],
            THREE.UniformsLib[ "emissivemap" ],
            THREE.UniformsLib[ "bumpmap" ],
            THREE.UniformsLib[ "normalmap" ],
            THREE.UniformsLib[ "displacementmap" ],
            THREE.UniformsLib[ "fog" ],
            THREE.UniformsLib[ "lights" ],
            THREE.UniformsLib[ "shadowmap" ],

            {
                "emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
                "specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
                "shininess": { type: "f", value: 30 }
            }

        ] ),

        vertexShader: [

            "#define PHONG",

            "varying vec3 vViewPosition;",

            "#ifndef FLAT_SHADED",

            "	varying vec3 vNormal;",

            "#endif",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "uv_pars_vertex" ],
            THREE.ShaderChunk[ "uv2_pars_vertex" ],
            THREE.ShaderChunk[ "displacementmap_pars_vertex" ],
            THREE.ShaderChunk[ "envmap_pars_vertex" ],
            THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
            THREE.ShaderChunk[ "color_pars_vertex" ],
            THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
            THREE.ShaderChunk[ "skinning_pars_vertex" ],
            THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "uv_vertex" ],
            THREE.ShaderChunk[ "uv2_vertex" ],
            THREE.ShaderChunk[ "color_vertex" ],

            THREE.ShaderChunk[ "beginnormal_vertex" ],
            THREE.ShaderChunk[ "morphnormal_vertex" ],
            THREE.ShaderChunk[ "skinbase_vertex" ],
            THREE.ShaderChunk[ "skinnormal_vertex" ],
            THREE.ShaderChunk[ "defaultnormal_vertex" ],

            "#ifndef FLAT_SHADED", // Normal computed with derivatives when FLAT_SHADED

            "	vNormal = normalize( transformedNormal );",

            "#endif",

            THREE.ShaderChunk[ "begin_vertex" ],
            THREE.ShaderChunk[ "displacementmap_vertex" ],
            THREE.ShaderChunk[ "morphtarget_vertex" ],
            THREE.ShaderChunk[ "skinning_vertex" ],
            THREE.ShaderChunk[ "project_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "	vViewPosition = - mvPosition.xyz;",

            THREE.ShaderChunk[ "worldpos_vertex" ],
            THREE.ShaderChunk[ "envmap_vertex" ],
            THREE.ShaderChunk[ "lights_phong_vertex" ],
            THREE.ShaderChunk[ "shadowmap_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "#define PHONG",

            "uniform vec3 diffuse;",
            "uniform vec3 emissive;",
            "uniform vec3 specular;",
            "uniform float shininess;",
            "uniform float opacity;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_fragment" ],
            THREE.ShaderChunk[ "uv_pars_fragment" ],
            THREE.ShaderChunk[ "uv2_pars_fragment" ],
            THREE.ShaderChunk[ "map_pars_fragment" ],
            THREE.ShaderChunk[ "alphamap_pars_fragment" ],
            THREE.ShaderChunk[ "aomap_pars_fragment" ],
            THREE.ShaderChunk[ "lightmap_pars_fragment" ],
            THREE.ShaderChunk[ "emissivemap_pars_fragment" ],
            THREE.ShaderChunk[ "envmap_pars_fragment" ],
            THREE.ShaderChunk[ "fog_pars_fragment" ],
            THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
            THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
            THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
            THREE.ShaderChunk[ "normalmap_pars_fragment" ],
            THREE.ShaderChunk[ "specularmap_pars_fragment" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	vec3 outgoingLight = vec3( 0.0 );",
            "	vec4 diffuseColor = vec4( diffuse, opacity );",
            "	vec3 totalAmbientLight = ambientLightColor;",
            "	vec3 totalEmissiveLight = emissive;",
            "	vec3 shadowMask = vec3( 1.0 );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],
            THREE.ShaderChunk[ "map_fragment" ],
            THREE.ShaderChunk[ "color_fragment" ],
            THREE.ShaderChunk[ "alphamap_fragment" ],
            THREE.ShaderChunk[ "alphatest_fragment" ],
            THREE.ShaderChunk[ "specularmap_fragment" ],
            THREE.ShaderChunk[ "normal_phong_fragment" ],
            THREE.ShaderChunk[ "lightmap_fragment" ],
            THREE.ShaderChunk[ "hemilight_fragment" ],
            THREE.ShaderChunk[ "aomap_fragment" ],
            THREE.ShaderChunk[ "emissivemap_fragment" ],

            THREE.ShaderChunk[ "lights_phong_fragment" ],
            THREE.ShaderChunk[ "shadowmap_fragment" ],

            "totalDiffuseLight *= shadowMask;",
            "totalSpecularLight *= shadowMask;",

            "#ifdef METAL",

            "	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) * specular + totalSpecularLight + totalEmissiveLight;",

            "#else",

            "	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) + totalSpecularLight + totalEmissiveLight;",

            "#endif",

            THREE.ShaderChunk[ "envmap_fragment" ],

            THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

            THREE.ShaderChunk[ "fog_fragment" ],

            "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

            "}"

        ].join( "\n" )

    },

    'points': {

        uniforms: THREE.UniformsUtils.merge( [

            THREE.UniformsLib[ "points" ],
            THREE.UniformsLib[ "shadowmap" ]

        ] ),

        vertexShader: [

            "uniform float size;",
            "uniform float scale;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_vertex" ],
            THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "color_vertex" ],

            "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

            "	#ifdef USE_SIZEATTENUATION",
            "		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
            "	#else",
            "		gl_PointSize = size;",
            "	#endif",

            "	gl_Position = projectionMatrix * mvPosition;",

            THREE.ShaderChunk[ "logdepthbuf_vertex" ],
            THREE.ShaderChunk[ "worldpos_vertex" ],
            THREE.ShaderChunk[ "shadowmap_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform vec3 psColor;",
            "uniform float opacity;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_fragment" ],
            THREE.ShaderChunk[ "map_particle_pars_fragment" ],
            THREE.ShaderChunk[ "fog_pars_fragment" ],
            THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	vec3 outgoingLight = vec3( 0.0 );",
            "	vec4 diffuseColor = vec4( psColor, opacity );",
            "	vec3 shadowMask = vec3( 1.0 );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],
            THREE.ShaderChunk[ "map_particle_fragment" ],
            THREE.ShaderChunk[ "color_fragment" ],
            THREE.ShaderChunk[ "alphatest_fragment" ],
            THREE.ShaderChunk[ "shadowmap_fragment" ],

            "	outgoingLight = diffuseColor.rgb * shadowMask;",

            THREE.ShaderChunk[ "fog_fragment" ],

            "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

            "}"

        ].join( "\n" )

    },

    'dashed': {

        uniforms: THREE.UniformsUtils.merge( [

            THREE.UniformsLib[ "common" ],
            THREE.UniformsLib[ "fog" ],

            {
                "scale"    : { type: "f", value: 1 },
                "dashSize" : { type: "f", value: 1 },
                "totalSize": { type: "f", value: 2 }
            }

        ] ),

        vertexShader: [

            "uniform float scale;",
            "attribute float lineDistance;",

            "varying float vLineDistance;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "color_vertex" ],

            "	vLineDistance = scale * lineDistance;",

            "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
            "	gl_Position = projectionMatrix * mvPosition;",

            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform vec3 diffuse;",
            "uniform float opacity;",

            "uniform float dashSize;",
            "uniform float totalSize;",

            "varying float vLineDistance;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_fragment" ],
            THREE.ShaderChunk[ "fog_pars_fragment" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	if ( mod( vLineDistance, totalSize ) > dashSize ) {",

            "		discard;",

            "	}",

            "	vec3 outgoingLight = vec3( 0.0 );",
            "	vec4 diffuseColor = vec4( diffuse, opacity );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],
            THREE.ShaderChunk[ "color_fragment" ],

            "	outgoingLight = diffuseColor.rgb;", // simple shader

            THREE.ShaderChunk[ "fog_fragment" ],

            "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

            "}"

        ].join( "\n" )

    },

    'depth': {

        uniforms: {

            "mNear": { type: "f", value: 1.0 },
            "mFar" : { type: "f", value: 2000.0 },
            "opacity" : { type: "f", value: 1.0 }

        },

        vertexShader: [

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "begin_vertex" ],
            THREE.ShaderChunk[ "morphtarget_vertex" ],
            THREE.ShaderChunk[ "project_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform float mNear;",
            "uniform float mFar;",
            "uniform float opacity;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],

            "	#ifdef USE_LOGDEPTHBUF_EXT",

            "		float depth = gl_FragDepthEXT / gl_FragCoord.w;",

            "	#else",

            "		float depth = gl_FragCoord.z / gl_FragCoord.w;",

            "	#endif",

            "	float color = 1.0 - smoothstep( mNear, mFar, depth );",
            "	gl_FragColor = vec4( vec3( color ), opacity );",

            "}"

        ].join( "\n" )

    },

    'normal': {

        uniforms: {

            "opacity" : { type: "f", value: 1.0 }

        },

        vertexShader: [

            "varying vec3 vNormal;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            "	vNormal = normalize( normalMatrix * normal );",

            THREE.ShaderChunk[ "begin_vertex" ],
            THREE.ShaderChunk[ "morphtarget_vertex" ],
            THREE.ShaderChunk[ "project_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform float opacity;",
            "varying vec3 vNormal;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],

            "}"

        ].join( "\n" )

    },

    /* -------------------------------------------------------------------------
     //	Cube map shader
     ------------------------------------------------------------------------- */

    'cube': {

        uniforms: { "tCube": { type: "t", value: null },
            "tFlip": { type: "f", value: - 1 } },

        vertexShader: [

            "varying vec3 vWorldPosition;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            "	vWorldPosition = transformDirection( position, modelMatrix );",

            "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform samplerCube tCube;",
            "uniform float tFlip;",

            "varying vec3 vWorldPosition;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],

            "}"

        ].join( "\n" )

    },

    /* -------------------------------------------------------------------------
     //	Cube map shader
     ------------------------------------------------------------------------- */

    'equirect': {

        uniforms: { "tEquirect": { type: "t", value: null },
            "tFlip": { type: "f", value: - 1 } },

        vertexShader: [

            "varying vec3 vWorldPosition;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            "	vWorldPosition = transformDirection( position, modelMatrix );",

            "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform sampler2D tEquirect;",
            "uniform float tFlip;",

            "varying vec3 vWorldPosition;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            // "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
            "vec3 direction = normalize( vWorldPosition );",
            "vec2 sampleUV;",
            "sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );",
            "sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;",
            "gl_FragColor = texture2D( tEquirect, sampleUV );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],

            "}"

        ].join( "\n" )

    },

    /* Depth encoding into RGBA texture
     *
     * based on SpiderGL shadow map example
     * http://spidergl.org/example.php?id=6
     *
     * originally from
     * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
     *
     * see also
     * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
     */

    'depthRGBA': {

        uniforms: {},

        vertexShader: [

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
            THREE.ShaderChunk[ "skinning_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "skinbase_vertex" ],

            THREE.ShaderChunk[ "begin_vertex" ],
            THREE.ShaderChunk[ "morphtarget_vertex" ],
            THREE.ShaderChunk[ "skinning_vertex" ],
            THREE.ShaderChunk[ "project_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "vec4 pack_depth( const in float depth ) {",

            "	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
            "	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
            "	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", // "	vec4 res = fract( depth * bit_shift );",
            "	res -= res.xxyz * bit_mask;",
            "	return res;",

            "}",

            "void main() {",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],

            "	#ifdef USE_LOGDEPTHBUF_EXT",

            "		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );",

            "	#else",

            "		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",

            "	#endif",

            //"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
            //"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
            //"gl_FragData[ 0 ] = pack_depth( z );",
            //"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",

            "}"

        ].join( "\n" )

    },


    'distanceRGBA': {

        uniforms: {

            "lightPos": { type: "v3", value: new THREE.Vector3( 0, 0, 0 ) }

        },

        vertexShader: [

            "varying vec4 vWorldPosition;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
            THREE.ShaderChunk[ "skinning_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "skinbase_vertex" ],
            THREE.ShaderChunk[ "begin_vertex" ],
            THREE.ShaderChunk[ "morphtarget_vertex" ],
            THREE.ShaderChunk[ "skinning_vertex" ],
            THREE.ShaderChunk[ "project_vertex" ],
            THREE.ShaderChunk[ "worldpos_vertex" ],

            "vWorldPosition = worldPosition;",

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform vec3 lightPos;",
            "varying vec4 vWorldPosition;",

            THREE.ShaderChunk[ "common" ],

            "vec4 pack1K ( float depth ) {",

            "   depth /= 1000.0;",
            "   const vec4 bitSh = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
            "	const vec4 bitMsk = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
            "	vec4 res = fract( depth * bitSh );",
            "	res -= res.xxyz * bitMsk;",
            "	return res; ",

            "}",

            "float unpack1K ( vec4 color ) {",

            "	const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
            "	return dot( color, bitSh ) * 1000.0;",

            "}",

            "void main () {",

            "	gl_FragColor = pack1K( length( vWorldPosition.xyz - lightPos.xyz ) );",

            "}"

        ].join( "\n" )

    }

};

// File:src/renderers/WebGLRenderer.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.WebGLRenderer = function ( parameters ) {

    console.log( 'THREE.WebGLRenderer', THREE.REVISION );

    parameters = parameters || {};

    var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),
        _context = parameters.context !== undefined ? parameters.context : null,

        _width = _canvas.width,
        _height = _canvas.height,

        pixelRatio = 1,

        _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
        _depth = parameters.depth !== undefined ? parameters.depth : true,
        _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
        _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
        _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
        _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,

        _clearColor = new THREE.Color( 0x000000 ),
        _clearAlpha = 0;

    var lights = [];

    var opaqueObjects = [];
    var opaqueObjectsLastIndex = - 1;
    var transparentObjects = [];
    var transparentObjectsLastIndex = - 1;

    var morphInfluences = new Float32Array( 8 );


    var sprites = [];
    var lensFlares = [];

    // public properties

    this.domElement = _canvas;
    this.context = null;

    // clearing

    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;

    // scene graph

    this.sortObjects = true;

    // physically based shading

    this.gammaFactor = 2.0;	// for backwards compatibility
    this.gammaInput = false;
    this.gammaOutput = false;

    // morphs

    this.maxMorphTargets = 8;
    this.maxMorphNormals = 4;

    // flags

    this.autoScaleCubemaps = true;

    // internal properties

    var _this = this,

    // internal state cache

        _currentProgram = null,
        _currentFramebuffer = null,
        _currentMaterialId = - 1,
        _currentGeometryProgram = '',
        _currentCamera = null,

        _usedTextureUnits = 0,

        _viewportX = 0,
        _viewportY = 0,
        _viewportWidth = _canvas.width,
        _viewportHeight = _canvas.height,
        _currentWidth = 0,
        _currentHeight = 0,

    // frustum

        _frustum = new THREE.Frustum(),

    // camera matrices cache

        _projScreenMatrix = new THREE.Matrix4(),

        _vector3 = new THREE.Vector3(),

    // light arrays cache

        _direction = new THREE.Vector3(),

        _lightsNeedUpdate = true,

        _lights = {

            ambient: [ 0, 0, 0 ],
            directional: { length: 0, colors: [], positions: [] },
            point: { length: 0, colors: [], positions: [], distances: [], decays: [] },
            spot: { length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: [], decays: [] },
            hemi: { length: 0, skyColors: [], groundColors: [], positions: [] }

        },

    // info

        _infoMemory = {

            geometries: 0,
            textures: 0

        },

        _infoRender = {

            calls: 0,
            vertices: 0,
            faces: 0,
            points: 0

        };

    this.info = {

        render: _infoRender,
        memory: _infoMemory,
        programs: null

    };


    // initialize

    var _gl;

    try {

        var attributes = {
            alpha: _alpha,
            depth: _depth,
            stencil: _stencil,
            antialias: _antialias,
            premultipliedAlpha: _premultipliedAlpha,
            preserveDrawingBuffer: _preserveDrawingBuffer
        };

        _gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

        if ( _gl === null ) {

            if ( _canvas.getContext( 'webgl' ) !== null ) {

                throw 'Error creating WebGL context with your selected attributes.';

            } else {

                throw 'Error creating WebGL context.';

            }

        }

        _canvas.addEventListener( 'webglcontextlost', onContextLost, false );

    } catch ( error ) {

        console.error( 'THREE.WebGLRenderer: ' + error );

    }

    var extensions = new THREE.WebGLExtensions( _gl );

    extensions.get( 'OES_texture_float' );
    extensions.get( 'OES_texture_float_linear' );
    extensions.get( 'OES_texture_half_float' );
    extensions.get( 'OES_texture_half_float_linear' );
    extensions.get( 'OES_standard_derivatives' );
    extensions.get( 'ANGLE_instanced_arrays' );

    if ( extensions.get( 'OES_element_index_uint' ) ) {

        THREE.BufferGeometry.MaxIndex = 4294967296;

    }

    var capabilities = new THREE.WebGLCapabilities( _gl, extensions, parameters );

    var state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );
    var properties = new THREE.WebGLProperties();
    var objects = new THREE.WebGLObjects( _gl, properties, this.info );
    var programCache = new THREE.WebGLPrograms( this, capabilities );

    this.info.programs = programCache.programs;

    var bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );
    var indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );

    //

    function glClearColor( r, g, b, a ) {

        if ( _premultipliedAlpha === true ) {

            r *= a; g *= a; b *= a;

        }

        _gl.clearColor( r, g, b, a );

    }

    function setDefaultGLState() {

        state.init();

        _gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

        glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

    }

    function resetGLState() {

        _currentProgram = null;
        _currentCamera = null;

        _currentGeometryProgram = '';
        _currentMaterialId = - 1;

        _lightsNeedUpdate = true;

        state.reset();

    }

    setDefaultGLState();

    this.context = _gl;
    this.capabilities = capabilities;
    this.extensions = extensions;
    this.state = state;

    // shadow map

    var shadowMap = new THREE.WebGLShadowMap( this, lights, objects );

    this.shadowMap = shadowMap;


    // Plugins

    var spritePlugin = new THREE.SpritePlugin( this, sprites );
    var lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );

    // API

    this.getContext = function () {

        return _gl;

    };

    this.getContextAttributes = function () {

        return _gl.getContextAttributes();

    };

    this.forceContextLoss = function () {

        extensions.get( 'WEBGL_lose_context' ).loseContext();

    };

    this.getMaxAnisotropy = ( function () {

        var value;

        return function getMaxAnisotropy() {

            if ( value !== undefined ) return value;

            var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

            if ( extension !== null ) {

                value = _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

            } else {

                value = 0;

            }

            return value;

        }

    } )();

    this.getPrecision = function () {

        return capabilities.precision;

    };

    this.getPixelRatio = function () {

        return pixelRatio;

    };

    this.setPixelRatio = function ( value ) {

        if ( value !== undefined ) pixelRatio = value;

    };

    this.getSize = function () {

        return {
            width: _width,
            height: _height
        };

    };

    this.setSize = function ( width, height, updateStyle ) {

        _width = width;
        _height = height;

        _canvas.width = width * pixelRatio;
        _canvas.height = height * pixelRatio;

        if ( updateStyle !== false ) {

            _canvas.style.width = width + 'px';
            _canvas.style.height = height + 'px';

        }

        this.setViewport( 0, 0, width, height );

    };

    this.setViewport = function ( x, y, width, height ) {

        _viewportX = x * pixelRatio;
        _viewportY = y * pixelRatio;

        _viewportWidth = width * pixelRatio;
        _viewportHeight = height * pixelRatio;

        _gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

    };

    this.getViewport = function ( dimensions ) {

        dimensions.x = _viewportX / pixelRatio;
        dimensions.y = _viewportY / pixelRatio;

        dimensions.z = _viewportWidth / pixelRatio;
        dimensions.w = _viewportHeight / pixelRatio;

    };

    this.setScissor = function ( x, y, width, height ) {

        _gl.scissor(
            x * pixelRatio,
            y * pixelRatio,
            width * pixelRatio,
            height * pixelRatio
        );

    };

    this.enableScissorTest = function ( boolean ) {

        state.setScissorTest( boolean );

    };

    // Clearing

    this.getClearColor = function () {

        return _clearColor;

    };

    this.setClearColor = function ( color, alpha ) {

        _clearColor.set( color );

        _clearAlpha = alpha !== undefined ? alpha : 1;

        glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

    };

    this.getClearAlpha = function () {

        return _clearAlpha;

    };

    this.setClearAlpha = function ( alpha ) {

        _clearAlpha = alpha;

        glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

    };

    this.clear = function ( color, depth, stencil ) {

        var bits = 0;

        if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
        if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
        if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

        _gl.clear( bits );

    };

    this.clearColor = function () {

        _gl.clear( _gl.COLOR_BUFFER_BIT );

    };

    this.clearDepth = function () {

        _gl.clear( _gl.DEPTH_BUFFER_BIT );

    };

    this.clearStencil = function () {

        _gl.clear( _gl.STENCIL_BUFFER_BIT );

    };

    this.clearTarget = function ( renderTarget, color, depth, stencil ) {

        this.setRenderTarget( renderTarget );
        this.clear( color, depth, stencil );

    };

    // Reset

    this.resetGLState = resetGLState;

    this.dispose = function() {

        _canvas.removeEventListener( 'webglcontextlost', onContextLost, false );

    };

    // Events

    function onContextLost( event ) {

        event.preventDefault();

        resetGLState();
        setDefaultGLState();

        properties.clear();

    };

    function onTextureDispose( event ) {

        var texture = event.target;

        texture.removeEventListener( 'dispose', onTextureDispose );

        deallocateTexture( texture );

        _infoMemory.textures --;


    }

    function onRenderTargetDispose( event ) {

        var renderTarget = event.target;

        renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

        deallocateRenderTarget( renderTarget );

        _infoMemory.textures --;

    }

    function onMaterialDispose( event ) {

        var material = event.target;

        material.removeEventListener( 'dispose', onMaterialDispose );

        deallocateMaterial( material );

    }

    // Buffer deallocation

    function deallocateTexture( texture ) {

        var textureProperties = properties.get( texture );

        if ( texture.image && textureProperties.__image__webglTextureCube ) {

            // cube texture

            _gl.deleteTexture( textureProperties.__image__webglTextureCube );

        } else {

            // 2D texture

            if ( textureProperties.__webglInit === undefined ) return;

            _gl.deleteTexture( textureProperties.__webglTexture );

        }

        // remove all webgl properties
        properties.delete( texture );

    }

    function deallocateRenderTarget( renderTarget ) {

        var renderTargetProperties = properties.get( renderTarget );
        var textureProperties = properties.get( renderTarget.texture );

        if ( ! renderTarget || textureProperties.__webglTexture === undefined ) return;

        _gl.deleteTexture( textureProperties.__webglTexture );

        if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

            for ( var i = 0; i < 6; i ++ ) {

                _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
                _gl.deleteRenderbuffer( renderTargetProperties.__webglRenderbuffer[ i ] );

            }

        } else {

            _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
            _gl.deleteRenderbuffer( renderTargetProperties.__webglRenderbuffer );

        }

        properties.delete( renderTarget.texture );
        properties.delete( renderTarget );

    }

    function deallocateMaterial( material ) {

        releaseMaterialProgramReference( material );

        properties.delete( material );

    }


    function releaseMaterialProgramReference( material ) {

        var programInfo = properties.get( material ).program;

        material.program = undefined;

        if ( programInfo !== undefined ) {

            programCache.releaseProgram( programInfo );

        }

    }

    // Buffer rendering

    this.renderBufferImmediate = function ( object, program, material ) {

        state.initAttributes();

        var buffers = properties.get( object );

        if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
        if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
        if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
        if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

        var attributes = program.getAttributes();

        if ( object.hasPositions ) {

            _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
            _gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

            state.enableAttribute( attributes.position );
            _gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

        }

        if ( object.hasNormals ) {

            _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );

            if ( material.type !== 'MeshPhongMaterial' && material.shading === THREE.FlatShading ) {

                for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {

                    var array = object.normalArray;

                    var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
                    var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
                    var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;

                    array[ i + 0 ] = nx;
                    array[ i + 1 ] = ny;
                    array[ i + 2 ] = nz;

                    array[ i + 3 ] = nx;
                    array[ i + 4 ] = ny;
                    array[ i + 5 ] = nz;

                    array[ i + 6 ] = nx;
                    array[ i + 7 ] = ny;
                    array[ i + 8 ] = nz;

                }

            }

            _gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

            state.enableAttribute( attributes.normal );

            _gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

        }

        if ( object.hasUvs && material.map ) {

            _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
            _gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

            state.enableAttribute( attributes.uv );

            _gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

        }

        if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {

            _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
            _gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

            state.enableAttribute( attributes.color );

            _gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

        }

        state.disableUnusedAttributes();

        _gl.drawArrays( _gl.TRIANGLES, 0, object.count );

        object.count = 0;

    };

    this.renderBufferDirect = function ( camera, lights, fog, geometry, material, object, group ) {

        setMaterial( material );

        var program = setProgram( camera, lights, fog, material, object );

        var updateBuffers = false;
        var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;

        if ( geometryProgram !== _currentGeometryProgram ) {

            _currentGeometryProgram = geometryProgram;
            updateBuffers = true;

        }

        // morph targets

        var morphTargetInfluences = object.morphTargetInfluences;

        if ( morphTargetInfluences !== undefined ) {

            var activeInfluences = [];

            for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {

                var influence = morphTargetInfluences[ i ];
                activeInfluences.push( [ influence, i ] );

            }

            activeInfluences.sort( numericalSort );

            if ( activeInfluences.length > 8 ) {

                activeInfluences.length = 8;

            }

            var morphAttributes = geometry.morphAttributes;

            for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {

                var influence = activeInfluences[ i ];
                morphInfluences[ i ] = influence[ 0 ];

                if ( influence[ 0 ] !== 0 ) {

                    var index = influence[ 1 ];

                    if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
                    if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );

                } else {

                    if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
                    if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );

                }

            }

            var uniforms = program.getUniforms();

            if ( uniforms.morphTargetInfluences !== null ) {

                _gl.uniform1fv( uniforms.morphTargetInfluences, morphInfluences );

            }

            updateBuffers = true;

        }

        //

        var index = geometry.index;
        var position = geometry.attributes.position;

        if ( material.wireframe === true ) {

            index = objects.getWireframeAttribute( geometry );

        }

        var renderer;

        if ( index !== null ) {

            renderer = indexedBufferRenderer;
            renderer.setIndex( index );

        } else {

            renderer = bufferRenderer;

        }

        if ( updateBuffers ) {

            setupVertexAttributes( material, program, geometry );

            if ( index !== null ) {

                _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );

            }

        }

        //

        var dataStart = 0;
        var dataCount = Infinity;

        if ( index !== null ) {

            dataCount = index.count

        } else if ( position !== undefined ) {

            dataCount = position.count;

        }

        var rangeStart = geometry.drawRange.start;
        var rangeCount = geometry.drawRange.count;

        var groupStart = group !== null ? group.start : 0;
        var groupCount = group !== null ? group.count : Infinity;

        var drawStart = Math.max( dataStart, rangeStart, groupStart );
        var drawEnd = Math.min( dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

        var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

        //

        if ( object instanceof THREE.Mesh ) {

            if ( material.wireframe === true ) {

                state.setLineWidth( material.wireframeLinewidth * pixelRatio );
                renderer.setMode( _gl.LINES );

            } else {

                renderer.setMode( _gl.TRIANGLES );

            }

            if ( geometry instanceof THREE.InstancedBufferGeometry && geometry.maxInstancedCount > 0 ) {

                renderer.renderInstances( geometry );

            } else {

                renderer.render( drawStart, drawCount );

            }

        } else if ( object instanceof THREE.Line ) {

            var lineWidth = material.linewidth;

            if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

            state.setLineWidth( lineWidth * pixelRatio );

            if ( object instanceof THREE.LineSegments ) {

                renderer.setMode( _gl.LINES );

            } else {

                renderer.setMode( _gl.LINE_STRIP );

            }

            renderer.render( drawStart, drawCount );

        } else if ( object instanceof THREE.Points ) {

            renderer.setMode( _gl.POINTS );
            renderer.render( drawStart, drawCount );

        }

    };

    function setupVertexAttributes( material, program, geometry, startIndex ) {

        var extension;

        if ( geometry instanceof THREE.InstancedBufferGeometry ) {

            extension = extensions.get( 'ANGLE_instanced_arrays' );

            if ( extension === null ) {

                console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
                return;

            }

        }

        if ( startIndex === undefined ) startIndex = 0;

        state.initAttributes();

        var geometryAttributes = geometry.attributes;

        var programAttributes = program.getAttributes();

        var materialDefaultAttributeValues = material.defaultAttributeValues;

        for ( var name in programAttributes ) {

            var programAttribute = programAttributes[ name ];

            if ( programAttribute >= 0 ) {

                var geometryAttribute = geometryAttributes[ name ];

                if ( geometryAttribute !== undefined ) {

                    var size = geometryAttribute.itemSize;
                    var buffer = objects.getAttributeBuffer( geometryAttribute );

                    if ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {

                        var data = geometryAttribute.data;
                        var stride = data.stride;
                        var offset = geometryAttribute.offset;

                        if ( data instanceof THREE.InstancedInterleavedBuffer ) {

                            state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );

                            if ( geometry.maxInstancedCount === undefined ) {

                                geometry.maxInstancedCount = data.meshPerAttribute * data.count;

                            }

                        } else {

                            state.enableAttribute( programAttribute );

                        }

                        _gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
                        _gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );

                    } else {

                        if ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {

                            state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );

                            if ( geometry.maxInstancedCount === undefined ) {

                                geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

                            }

                        } else {

                            state.enableAttribute( programAttribute );

                        }

                        _gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
                        _gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32

                    }

                } else if ( materialDefaultAttributeValues !== undefined ) {

                    var value = materialDefaultAttributeValues[ name ];

                    if ( value !== undefined ) {

                        switch ( value.length ) {

                            case 2:
                                _gl.vertexAttrib2fv( programAttribute, value );
                                break;

                            case 3:
                                _gl.vertexAttrib3fv( programAttribute, value );
                                break;

                            case 4:
                                _gl.vertexAttrib4fv( programAttribute, value );
                                break;

                            default:
                                _gl.vertexAttrib1fv( programAttribute, value );

                        }

                    }

                }

            }

        }

        state.disableUnusedAttributes();

    }

    // Sorting

    function numericalSort ( a, b ) {

        return b[ 0 ] - a[ 0 ];

    }

    function painterSortStable ( a, b ) {

        if ( a.object.renderOrder !== b.object.renderOrder ) {

            return a.object.renderOrder - b.object.renderOrder;

        } else if ( a.material.id !== b.material.id ) {

            return a.material.id - b.material.id;

        } else if ( a.z !== b.z ) {

            return a.z - b.z;

        } else {

            return a.id - b.id;

        }

    }

    function reversePainterSortStable ( a, b ) {

        if ( a.object.renderOrder !== b.object.renderOrder ) {

            return a.object.renderOrder - b.object.renderOrder;

        } if ( a.z !== b.z ) {

            return b.z - a.z;

        } else {

            return a.id - b.id;

        }

    }

    // Rendering

    this.render = function ( scene, camera, renderTarget, forceClear ) {

        if ( camera instanceof THREE.Camera === false ) {

            console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
            return;

        }

        var fog = scene.fog;

        // reset caching for this frame

        _currentGeometryProgram = '';
        _currentMaterialId = - 1;
        _currentCamera = null;
        _lightsNeedUpdate = true;

        // update scene graph

        if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

        // update camera matrices and frustum

        if ( camera.parent === null ) camera.updateMatrixWorld();

        camera.matrixWorldInverse.getInverse( camera.matrixWorld );

        _projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
        _frustum.setFromMatrix( _projScreenMatrix );

        lights.length = 0;

        opaqueObjectsLastIndex = - 1;
        transparentObjectsLastIndex = - 1;

        sprites.length = 0;
        lensFlares.length = 0;

        projectObject( scene, camera );

        opaqueObjects.length = opaqueObjectsLastIndex + 1;
        transparentObjects.length = transparentObjectsLastIndex + 1;

        if ( _this.sortObjects === true ) {

            opaqueObjects.sort( painterSortStable );
            transparentObjects.sort( reversePainterSortStable );

        }

        //

        shadowMap.render( scene );

        //

        _infoRender.calls = 0;
        _infoRender.vertices = 0;
        _infoRender.faces = 0;
        _infoRender.points = 0;

        this.setRenderTarget( renderTarget );

        if ( this.autoClear || forceClear ) {

            this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

        }

        //

        if ( scene.overrideMaterial ) {

            var overrideMaterial = scene.overrideMaterial;

            renderObjects( opaqueObjects, camera, lights, fog, overrideMaterial );
            renderObjects( transparentObjects, camera, lights, fog, overrideMaterial );

        } else {

            // opaque pass (front-to-back order)

            state.setBlending( THREE.NoBlending );
            renderObjects( opaqueObjects, camera, lights, fog );

            // transparent pass (back-to-front order)

            renderObjects( transparentObjects, camera, lights, fog );

        }

        // custom render plugins (post pass)

        spritePlugin.render( scene, camera );
        lensFlarePlugin.render( scene, camera, _currentWidth, _currentHeight );

        // Generate mipmap if we're using any kind of mipmap filtering

        if ( renderTarget ) {

            var texture = renderTarget.texture;
            var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );
            if ( texture.generateMipmaps && isTargetPowerOfTwo && texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {

                updateRenderTargetMipmap( renderTarget );

            }

        }

        // Ensure depth buffer writing is enabled so it can be cleared on next render

        state.setDepthTest( true );
        state.setDepthWrite( true );
        state.setColorWrite( true );

        // _gl.finish();

    };

    function pushRenderItem( object, geometry, material, z, group ) {

        var array, index;

        // allocate the next position in the appropriate array

        if ( material.transparent ) {

            array = transparentObjects;
            index = ++ transparentObjectsLastIndex;

        } else {

            array = opaqueObjects;
            index = ++ opaqueObjectsLastIndex;

        }

        // recycle existing render item or grow the array

        var renderItem = array[ index ];

        if ( renderItem !== undefined ) {

            renderItem.id = object.id;
            renderItem.object = object;
            renderItem.geometry = geometry;
            renderItem.material = material;
            renderItem.z = _vector3.z;
            renderItem.group = group;

        } else {

            renderItem = {
                id: object.id,
                object: object,
                geometry: geometry,
                material: material,
                z: _vector3.z,
                group: group
            };

            // assert( index === array.length );
            array.push( renderItem );

        }

    }

    function projectObject( object, camera ) {

        if ( object.visible === false ) return;

        if ( ( object.channels.mask & camera.channels.mask ) !== 0 ) {

            if ( object instanceof THREE.Light ) {

                lights.push( object );

            } else if ( object instanceof THREE.Sprite ) {

                sprites.push( object );

            } else if ( object instanceof THREE.LensFlare ) {

                lensFlares.push( object );

            } else if ( object instanceof THREE.ImmediateRenderObject ) {

                if ( _this.sortObjects === true ) {

                    _vector3.setFromMatrixPosition( object.matrixWorld );
                    _vector3.applyProjection( _projScreenMatrix );

                }

                pushRenderItem( object, null, object.material, _vector3.z, null );

            } else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {

                if ( object instanceof THREE.SkinnedMesh ) {

                    object.skeleton.update();

                }

                if ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {

                    var material = object.material;

                    if ( material.visible === true ) {

                        if ( _this.sortObjects === true ) {

                            _vector3.setFromMatrixPosition( object.matrixWorld );
                            _vector3.applyProjection( _projScreenMatrix );

                        }

                        var geometry = objects.update( object );

                        if ( material instanceof THREE.MeshFaceMaterial ) {

                            var groups = geometry.groups;
                            var materials = material.materials;

                            for ( var i = 0, l = groups.length; i < l; i ++ ) {

                                var group = groups[ i ];
                                var groupMaterial = materials[ group.materialIndex ];

                                if ( groupMaterial.visible === true ) {

                                    pushRenderItem( object, geometry, groupMaterial, _vector3.z, group );

                                }

                            }

                        } else {

                            pushRenderItem( object, geometry, material, _vector3.z, null );

                        }

                    }

                }

            }

        }

        var children = object.children;

        for ( var i = 0, l = children.length; i < l; i ++ ) {

            projectObject( children[ i ], camera );

        }

    }

    function renderObjects( renderList, camera, lights, fog, overrideMaterial ) {

        for ( var i = 0, l = renderList.length; i < l; i ++ ) {

            var renderItem = renderList[ i ];

            var object = renderItem.object;
            var geometry = renderItem.geometry;
            var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
            var group = renderItem.group;

            object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
            object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

            if ( object instanceof THREE.ImmediateRenderObject ) {

                setMaterial( material );

                var program = setProgram( camera, lights, fog, material, object );

                _currentGeometryProgram = '';

                object.render( function ( object ) {

                    _this.renderBufferImmediate( object, program, material );

                } );

            } else {

                _this.renderBufferDirect( camera, lights, fog, geometry, material, object, group );

            }

        }

    }

    function initMaterial( material, lights, fog, object ) {

        var materialProperties = properties.get( material );

        var parameters = programCache.getParameters( material, lights, fog, object );
        var code = programCache.getProgramCode( material, parameters );

        var program = materialProperties.program;
        var programChange = true;

        if ( program === undefined ) {

            // new material
            material.addEventListener( 'dispose', onMaterialDispose );

        } else if ( program.code !== code ) {

            // changed glsl or parameters
            releaseMaterialProgramReference( material );

        } else if ( parameters.shaderID !== undefined ) {

            // same glsl and uniform list
            return;

        } else {

            // only rebuild uniform list
            programChange = false;

        }

        if ( programChange ) {

            if ( parameters.shaderID ) {

                var shader = THREE.ShaderLib[ parameters.shaderID ];

                materialProperties.__webglShader = {
                    name: material.type,
                    uniforms: THREE.UniformsUtils.clone( shader.uniforms ),
                    vertexShader: shader.vertexShader,
                    fragmentShader: shader.fragmentShader
                };

            } else {

                materialProperties.__webglShader = {
                    name: material.type,
                    uniforms: material.uniforms,
                    vertexShader: material.vertexShader,
                    fragmentShader: material.fragmentShader
                };

            }

            material.__webglShader = materialProperties.__webglShader;

            program = programCache.acquireProgram( material, parameters, code );

            materialProperties.program = program;
            material.program = program;

        }

        var attributes = program.getAttributes();

        if ( material.morphTargets ) {

            material.numSupportedMorphTargets = 0;

            for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

                if ( attributes[ 'morphTarget' + i ] >= 0 ) {

                    material.numSupportedMorphTargets ++;

                }

            }

        }

        if ( material.morphNormals ) {

            material.numSupportedMorphNormals = 0;

            for ( i = 0; i < _this.maxMorphNormals; i ++ ) {

                if ( attributes[ 'morphNormal' + i ] >= 0 ) {

                    material.numSupportedMorphNormals ++;

                }

            }

        }

        materialProperties.uniformsList = [];

        var uniformLocations = materialProperties.program.getUniforms();

        for ( var u in materialProperties.__webglShader.uniforms ) {

            var location = uniformLocations[ u ];

            if ( location ) {

                materialProperties.uniformsList.push( [ materialProperties.__webglShader.uniforms[ u ], location ] );

            }

        }

    }

    function setMaterial( material ) {

        setMaterialFaces( material );

        if ( material.transparent === true ) {

            state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha );

        } else {

            state.setBlending( THREE.NoBlending );

        }

        state.setDepthFunc( material.depthFunc );
        state.setDepthTest( material.depthTest );
        state.setDepthWrite( material.depthWrite );
        state.setColorWrite( material.colorWrite );
        state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

    }

    function setMaterialFaces( material ) {

        material.side !== THREE.DoubleSide ? state.enable( _gl.CULL_FACE ) : state.disable( _gl.CULL_FACE );
        state.setFlipSided( material.side === THREE.BackSide );

    }

    function setProgram( camera, lights, fog, material, object ) {

        _usedTextureUnits = 0;

        var materialProperties = properties.get( material );

        if ( material.needsUpdate || ! materialProperties.program ) {

            initMaterial( material, lights, fog, object );
            material.needsUpdate = false;

        }

        var refreshProgram = false;
        var refreshMaterial = false;
        var refreshLights = false;

        var program = materialProperties.program,
            p_uniforms = program.getUniforms(),
            m_uniforms = materialProperties.__webglShader.uniforms;

        if ( program.id !== _currentProgram ) {

            _gl.useProgram( program.program );
            _currentProgram = program.id;

            refreshProgram = true;
            refreshMaterial = true;
            refreshLights = true;

        }

        if ( material.id !== _currentMaterialId ) {

            if ( _currentMaterialId === - 1 ) refreshLights = true;
            _currentMaterialId = material.id;

            refreshMaterial = true;

        }

        if ( refreshProgram || camera !== _currentCamera ) {

            _gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

            if ( capabilities.logarithmicDepthBuffer ) {

                _gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

            }


            if ( camera !== _currentCamera ) _currentCamera = camera;

            // load material specific uniforms
            // (shader material also gets them for the sake of genericity)

            if ( material instanceof THREE.ShaderMaterial ||
                material instanceof THREE.MeshPhongMaterial ||
                material.envMap ) {

                if ( p_uniforms.cameraPosition !== undefined ) {

                    _vector3.setFromMatrixPosition( camera.matrixWorld );
                    _gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );

                }

            }

            if ( material instanceof THREE.MeshPhongMaterial ||
                material instanceof THREE.MeshLambertMaterial ||
                material instanceof THREE.MeshBasicMaterial ||
                material instanceof THREE.ShaderMaterial ||
                material.skinning ) {

                if ( p_uniforms.viewMatrix !== undefined ) {

                    _gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );

                }

            }

        }

        // skinning uniforms must be set even if material didn't change
        // auto-setting of texture unit for bone texture must go before other textures
        // not sure why, but otherwise weird things happen

        if ( material.skinning ) {

            if ( object.bindMatrix && p_uniforms.bindMatrix !== undefined ) {

                _gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );

            }

            if ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== undefined ) {

                _gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );

            }

            if ( capabilities.floatVertexTextures && object.skeleton && object.skeleton.useVertexTexture ) {

                if ( p_uniforms.boneTexture !== undefined ) {

                    var textureUnit = getTextureUnit();

                    _gl.uniform1i( p_uniforms.boneTexture, textureUnit );
                    _this.setTexture( object.skeleton.boneTexture, textureUnit );

                }

                if ( p_uniforms.boneTextureWidth !== undefined ) {

                    _gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );

                }

                if ( p_uniforms.boneTextureHeight !== undefined ) {

                    _gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );

                }

            } else if ( object.skeleton && object.skeleton.boneMatrices ) {

                if ( p_uniforms.boneGlobalMatrices !== undefined ) {

                    _gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );

                }

            }

        }

        if ( refreshMaterial ) {

            // refresh uniforms common to several materials

            if ( fog && material.fog ) {

                refreshUniformsFog( m_uniforms, fog );

            }

            if ( material instanceof THREE.MeshPhongMaterial ||
                material instanceof THREE.MeshLambertMaterial ||
                material.lights ) {

                if ( _lightsNeedUpdate ) {

                    refreshLights = true;
                    setupLights( lights, camera );
                    _lightsNeedUpdate = false;

                }

                if ( refreshLights ) {

                    refreshUniformsLights( m_uniforms, _lights );
                    markUniformsLightsNeedsUpdate( m_uniforms, true );

                } else {

                    markUniformsLightsNeedsUpdate( m_uniforms, false );

                }

            }

            if ( material instanceof THREE.MeshBasicMaterial ||
                material instanceof THREE.MeshLambertMaterial ||
                material instanceof THREE.MeshPhongMaterial ) {

                refreshUniformsCommon( m_uniforms, material );

            }

            // refresh single material specific uniforms

            if ( material instanceof THREE.LineBasicMaterial ) {

                refreshUniformsLine( m_uniforms, material );

            } else if ( material instanceof THREE.LineDashedMaterial ) {

                refreshUniformsLine( m_uniforms, material );
                refreshUniformsDash( m_uniforms, material );

            } else if ( material instanceof THREE.PointsMaterial ) {

                refreshUniformsParticle( m_uniforms, material );

            } else if ( material instanceof THREE.MeshPhongMaterial ) {

                refreshUniformsPhong( m_uniforms, material );

            } else if ( material instanceof THREE.MeshDepthMaterial ) {

                m_uniforms.mNear.value = camera.near;
                m_uniforms.mFar.value = camera.far;
                m_uniforms.opacity.value = material.opacity;

            } else if ( material instanceof THREE.MeshNormalMaterial ) {

                m_uniforms.opacity.value = material.opacity;

            }

            if ( object.receiveShadow && ! material._shadowPass ) {

                refreshUniformsShadow( m_uniforms, lights, camera );

            }

            // load common uniforms

            loadUniformsGeneric( materialProperties.uniformsList );

        }

        loadUniformsMatrices( p_uniforms, object );

        if ( p_uniforms.modelMatrix !== undefined ) {

            _gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );

        }

        return program;

    }

    // Uniforms (refresh uniforms objects)

    function refreshUniformsCommon ( uniforms, material ) {

        uniforms.opacity.value = material.opacity;

        uniforms.diffuse.value = material.color;

        if ( material.emissive ) {

            uniforms.emissive.value = material.emissive;

        }

        uniforms.map.value = material.map;
        uniforms.specularMap.value = material.specularMap;
        uniforms.alphaMap.value = material.alphaMap;

        if ( material.aoMap ) {

            uniforms.aoMap.value = material.aoMap;
            uniforms.aoMapIntensity.value = material.aoMapIntensity;

        }

        // uv repeat and offset setting priorities
        // 1. color map
        // 2. specular map
        // 3. normal map
        // 4. bump map
        // 5. alpha map
        // 6. emissive map

        var uvScaleMap;

        if ( material.map ) {

            uvScaleMap = material.map;

        } else if ( material.specularMap ) {

            uvScaleMap = material.specularMap;

        } else if ( material.displacementMap ) {

            uvScaleMap = material.displacementMap;

        } else if ( material.normalMap ) {

            uvScaleMap = material.normalMap;

        } else if ( material.bumpMap ) {

            uvScaleMap = material.bumpMap;

        } else if ( material.alphaMap ) {

            uvScaleMap = material.alphaMap;

        } else if ( material.emissiveMap ) {

            uvScaleMap = material.emissiveMap;

        }

        if ( uvScaleMap !== undefined ) {

            if ( uvScaleMap instanceof THREE.WebGLRenderTarget ) uvScaleMap = uvScaleMap.texture;
            var offset = uvScaleMap.offset;
            var repeat = uvScaleMap.repeat;

            uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

        }

        uniforms.envMap.value = material.envMap;
        uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;

        uniforms.reflectivity.value = material.reflectivity;
        uniforms.refractionRatio.value = material.refractionRatio;

    }

    function refreshUniformsLine ( uniforms, material ) {

        uniforms.diffuse.value = material.color;
        uniforms.opacity.value = material.opacity;

    }

    function refreshUniformsDash ( uniforms, material ) {

        uniforms.dashSize.value = material.dashSize;
        uniforms.totalSize.value = material.dashSize + material.gapSize;
        uniforms.scale.value = material.scale;

    }

    function refreshUniformsParticle ( uniforms, material ) {

        uniforms.psColor.value = material.color;
        uniforms.opacity.value = material.opacity;
        uniforms.size.value = material.size;
        uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.

        uniforms.map.value = material.map;

        if ( material.map !== null ) {

            var offset = material.map.offset;
            var repeat = material.map.repeat;

            uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

        }

    }

    function refreshUniformsFog ( uniforms, fog ) {

        uniforms.fogColor.value = fog.color;

        if ( fog instanceof THREE.Fog ) {

            uniforms.fogNear.value = fog.near;
            uniforms.fogFar.value = fog.far;

        } else if ( fog instanceof THREE.FogExp2 ) {

            uniforms.fogDensity.value = fog.density;

        }

    }

    function refreshUniformsPhong ( uniforms, material ) {

        uniforms.specular.value = material.specular;
        uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

        if ( material.lightMap ) {

            uniforms.lightMap.value = material.lightMap;
            uniforms.lightMapIntensity.value = material.lightMapIntensity;

        }

        if ( material.emissiveMap ) {

            uniforms.emissiveMap.value = material.emissiveMap;

        }

        if ( material.bumpMap ) {

            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;

        }

        if ( material.normalMap ) {

            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy( material.normalScale );

        }

        if ( material.displacementMap ) {

            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;

        }

    }

    function refreshUniformsLights ( uniforms, lights ) {

        uniforms.ambientLightColor.value = lights.ambient;

        uniforms.directionalLightColor.value = lights.directional.colors;
        uniforms.directionalLightDirection.value = lights.directional.positions;

        uniforms.pointLightColor.value = lights.point.colors;
        uniforms.pointLightPosition.value = lights.point.positions;
        uniforms.pointLightDistance.value = lights.point.distances;
        uniforms.pointLightDecay.value = lights.point.decays;

        uniforms.spotLightColor.value = lights.spot.colors;
        uniforms.spotLightPosition.value = lights.spot.positions;
        uniforms.spotLightDistance.value = lights.spot.distances;
        uniforms.spotLightDirection.value = lights.spot.directions;
        uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
        uniforms.spotLightExponent.value = lights.spot.exponents;
        uniforms.spotLightDecay.value = lights.spot.decays;

        uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
        uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
        uniforms.hemisphereLightDirection.value = lights.hemi.positions;

    }

    // If uniforms are marked as clean, they don't need to be loaded to the GPU.

    function markUniformsLightsNeedsUpdate ( uniforms, value ) {

        uniforms.ambientLightColor.needsUpdate = value;

        uniforms.directionalLightColor.needsUpdate = value;
        uniforms.directionalLightDirection.needsUpdate = value;

        uniforms.pointLightColor.needsUpdate = value;
        uniforms.pointLightPosition.needsUpdate = value;
        uniforms.pointLightDistance.needsUpdate = value;
        uniforms.pointLightDecay.needsUpdate = value;

        uniforms.spotLightColor.needsUpdate = value;
        uniforms.spotLightPosition.needsUpdate = value;
        uniforms.spotLightDistance.needsUpdate = value;
        uniforms.spotLightDirection.needsUpdate = value;
        uniforms.spotLightAngleCos.needsUpdate = value;
        uniforms.spotLightExponent.needsUpdate = value;
        uniforms.spotLightDecay.needsUpdate = value;

        uniforms.hemisphereLightSkyColor.needsUpdate = value;
        uniforms.hemisphereLightGroundColor.needsUpdate = value;
        uniforms.hemisphereLightDirection.needsUpdate = value;

    }

    function refreshUniformsShadow ( uniforms, lights, camera ) {

        if ( uniforms.shadowMatrix ) {

            var j = 0;

            for ( var i = 0, il = lights.length; i < il; i ++ ) {

                var light = lights[ i ];

                if ( light.castShadow === true ) {

                    if ( light instanceof THREE.PointLight || light instanceof THREE.SpotLight || light instanceof THREE.DirectionalLight ) {

                        var shadow = light.shadow;

                        if ( light instanceof THREE.PointLight ) {

                            // for point lights we set the shadow matrix to be a translation-only matrix
                            // equal to inverse of the light's position
                            _vector3.setFromMatrixPosition( light.matrixWorld ).negate();
                            shadow.matrix.identity().setPosition( _vector3 );

                            // for point lights we set the sign of the shadowDarkness uniform to be negative
                            uniforms.shadowDarkness.value[ j ] = - shadow.darkness;

                        } else {

                            uniforms.shadowDarkness.value[ j ] = shadow.darkness;

                        }

                        uniforms.shadowMatrix.value[ j ] = shadow.matrix;
                        uniforms.shadowMap.value[ j ] = shadow.map;
                        uniforms.shadowMapSize.value[ j ] = shadow.mapSize;
                        uniforms.shadowBias.value[ j ] = shadow.bias;

                        j ++;

                    }

                }

            }

        }

    }

    // Uniforms (load to GPU)

    function loadUniformsMatrices ( uniforms, object ) {

        _gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object.modelViewMatrix.elements );

        if ( uniforms.normalMatrix ) {

            _gl.uniformMatrix3fv( uniforms.normalMatrix, false, object.normalMatrix.elements );

        }

    }

    function getTextureUnit() {

        var textureUnit = _usedTextureUnits;

        if ( textureUnit >= capabilities.maxTextures ) {

            console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

        }

        _usedTextureUnits += 1;

        return textureUnit;

    }

    function loadUniformsGeneric ( uniforms ) {

        var texture, textureUnit;

        for ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {

            var uniform = uniforms[ j ][ 0 ];

            // needsUpdate property is not added to all uniforms.
            if ( uniform.needsUpdate === false ) continue;

            var type = uniform.type;
            var value = uniform.value;
            var location = uniforms[ j ][ 1 ];

            switch ( type ) {

                case '1i':
                    _gl.uniform1i( location, value );
                    break;

                case '1f':
                    _gl.uniform1f( location, value );
                    break;

                case '2f':
                    _gl.uniform2f( location, value[ 0 ], value[ 1 ] );
                    break;

                case '3f':
                    _gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );
                    break;

                case '4f':
                    _gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );
                    break;

                case '1iv':
                    _gl.uniform1iv( location, value );
                    break;

                case '3iv':
                    _gl.uniform3iv( location, value );
                    break;

                case '1fv':
                    _gl.uniform1fv( location, value );
                    break;

                case '2fv':
                    _gl.uniform2fv( location, value );
                    break;

                case '3fv':
                    _gl.uniform3fv( location, value );
                    break;

                case '4fv':
                    _gl.uniform4fv( location, value );
                    break;

                case 'Matrix3fv':
                    _gl.uniformMatrix3fv( location, false, value );
                    break;

                case 'Matrix4fv':
                    _gl.uniformMatrix4fv( location, false, value );
                    break;

                //

                case 'i':

                    // single integer
                    _gl.uniform1i( location, value );

                    break;

                case 'f':

                    // single float
                    _gl.uniform1f( location, value );

                    break;

                case 'v2':

                    // single THREE.Vector2
                    _gl.uniform2f( location, value.x, value.y );

                    break;

                case 'v3':

                    // single THREE.Vector3
                    _gl.uniform3f( location, value.x, value.y, value.z );

                    break;

                case 'v4':

                    // single THREE.Vector4
                    _gl.uniform4f( location, value.x, value.y, value.z, value.w );

                    break;

                case 'c':

                    // single THREE.Color
                    _gl.uniform3f( location, value.r, value.g, value.b );

                    break;

                case 'iv1':

                    // flat array of integers (JS or typed array)
                    _gl.uniform1iv( location, value );

                    break;

                case 'iv':

                    // flat array of integers with 3 x N size (JS or typed array)
                    _gl.uniform3iv( location, value );

                    break;

                case 'fv1':

                    // flat array of floats (JS or typed array)
                    _gl.uniform1fv( location, value );

                    break;

                case 'fv':

                    // flat array of floats with 3 x N size (JS or typed array)
                    _gl.uniform3fv( location, value );

                    break;

                case 'v2v':

                    // array of THREE.Vector2

                    if ( uniform._array === undefined ) {

                        uniform._array = new Float32Array( 2 * value.length );

                    }

                    for ( var i = 0, i2 = 0, il = value.length; i < il; i ++, i2 += 2 ) {

                        uniform._array[ i2 + 0 ] = value[ i ].x;
                        uniform._array[ i2 + 1 ] = value[ i ].y;

                    }

                    _gl.uniform2fv( location, uniform._array );

                    break;

                case 'v3v':

                    // array of THREE.Vector3

                    if ( uniform._array === undefined ) {

                        uniform._array = new Float32Array( 3 * value.length );

                    }

                    for ( var i = 0, i3 = 0, il = value.length; i < il; i ++, i3 += 3 ) {

                        uniform._array[ i3 + 0 ] = value[ i ].x;
                        uniform._array[ i3 + 1 ] = value[ i ].y;
                        uniform._array[ i3 + 2 ] = value[ i ].z;

                    }

                    _gl.uniform3fv( location, uniform._array );

                    break;

                case 'v4v':

                    // array of THREE.Vector4

                    if ( uniform._array === undefined ) {

                        uniform._array = new Float32Array( 4 * value.length );

                    }

                    for ( var i = 0, i4 = 0, il = value.length; i < il; i ++, i4 += 4 ) {

                        uniform._array[ i4 + 0 ] = value[ i ].x;
                        uniform._array[ i4 + 1 ] = value[ i ].y;
                        uniform._array[ i4 + 2 ] = value[ i ].z;
                        uniform._array[ i4 + 3 ] = value[ i ].w;

                    }

                    _gl.uniform4fv( location, uniform._array );

                    break;

                case 'm3':

                    // single THREE.Matrix3
                    _gl.uniformMatrix3fv( location, false, value.elements );

                    break;

                case 'm3v':

                    // array of THREE.Matrix3

                    if ( uniform._array === undefined ) {

                        uniform._array = new Float32Array( 9 * value.length );

                    }

                    for ( var i = 0, il = value.length; i < il; i ++ ) {

                        value[ i ].flattenToArrayOffset( uniform._array, i * 9 );

                    }

                    _gl.uniformMatrix3fv( location, false, uniform._array );

                    break;

                case 'm4':

                    // single THREE.Matrix4
                    _gl.uniformMatrix4fv( location, false, value.elements );

                    break;

                case 'm4v':

                    // array of THREE.Matrix4

                    if ( uniform._array === undefined ) {

                        uniform._array = new Float32Array( 16 * value.length );

                    }

                    for ( var i = 0, il = value.length; i < il; i ++ ) {

                        value[ i ].flattenToArrayOffset( uniform._array, i * 16 );

                    }

                    _gl.uniformMatrix4fv( location, false, uniform._array );

                    break;

                case 't':

                    // single THREE.Texture (2d or cube)

                    texture = value;
                    textureUnit = getTextureUnit();

                    _gl.uniform1i( location, textureUnit );

                    if ( ! texture ) continue;

                    if ( texture instanceof THREE.CubeTexture ||
                        ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

                        // CompressedTexture can have Array in image :/

                        setCubeTexture( texture, textureUnit );

                    } else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

                        setCubeTextureDynamic( texture.texture, textureUnit );

                    } else if ( texture instanceof THREE.WebGLRenderTarget ) {

                        _this.setTexture( texture.texture, textureUnit );

                    } else {

                        _this.setTexture( texture, textureUnit );

                    }

                    break;

                case 'tv':

                    // array of THREE.Texture (2d or cube)

                    if ( uniform._array === undefined ) {

                        uniform._array = [];

                    }

                    for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

                        uniform._array[ i ] = getTextureUnit();

                    }

                    _gl.uniform1iv( location, uniform._array );

                    for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

                        texture = uniform.value[ i ];
                        textureUnit = uniform._array[ i ];

                        if ( ! texture ) continue;

                        if ( texture instanceof THREE.CubeTexture ||
                            ( texture.image instanceof Array && texture.image.length === 6 ) ) {

                            // CompressedTexture can have Array in image :/

                            setCubeTexture( texture, textureUnit );

                        } else if ( texture instanceof THREE.WebGLRenderTarget ) {

                            _this.setTexture( texture.texture, textureUnit );

                        } else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

                            setCubeTextureDynamic( texture.texture, textureUnit );

                        } else {

                            _this.setTexture( texture, textureUnit );

                        }

                    }

                    break;

                default:

                    console.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );

            }

        }

    }

    function setColorLinear( array, offset, color, intensity ) {

        array[ offset + 0 ] = color.r * intensity;
        array[ offset + 1 ] = color.g * intensity;
        array[ offset + 2 ] = color.b * intensity;

    }

    function setupLights ( lights, camera ) {

        var l, ll, light,
            r = 0, g = 0, b = 0,
            color, skyColor, groundColor,
            intensity,
            distance,

            zlights = _lights,

            viewMatrix = camera.matrixWorldInverse,

            dirColors = zlights.directional.colors,
            dirPositions = zlights.directional.positions,

            pointColors = zlights.point.colors,
            pointPositions = zlights.point.positions,
            pointDistances = zlights.point.distances,
            pointDecays = zlights.point.decays,

            spotColors = zlights.spot.colors,
            spotPositions = zlights.spot.positions,
            spotDistances = zlights.spot.distances,
            spotDirections = zlights.spot.directions,
            spotAnglesCos = zlights.spot.anglesCos,
            spotExponents = zlights.spot.exponents,
            spotDecays = zlights.spot.decays,

            hemiSkyColors = zlights.hemi.skyColors,
            hemiGroundColors = zlights.hemi.groundColors,
            hemiPositions = zlights.hemi.positions,

            dirLength = 0,
            pointLength = 0,
            spotLength = 0,
            hemiLength = 0,

            dirCount = 0,
            pointCount = 0,
            spotCount = 0,
            hemiCount = 0,

            dirOffset = 0,
            pointOffset = 0,
            spotOffset = 0,
            hemiOffset = 0;

        for ( l = 0, ll = lights.length; l < ll; l ++ ) {

            light = lights[ l ];

            color = light.color;
            intensity = light.intensity;
            distance = light.distance;

            if ( light instanceof THREE.AmbientLight ) {

                if ( ! light.visible ) continue;

                r += color.r;
                g += color.g;
                b += color.b;

            } else if ( light instanceof THREE.DirectionalLight ) {

                dirCount += 1;

                if ( ! light.visible ) continue;

                _direction.setFromMatrixPosition( light.matrixWorld );
                _vector3.setFromMatrixPosition( light.target.matrixWorld );
                _direction.sub( _vector3 );
                _direction.transformDirection( viewMatrix );

                dirOffset = dirLength * 3;

                dirPositions[ dirOffset + 0 ] = _direction.x;
                dirPositions[ dirOffset + 1 ] = _direction.y;
                dirPositions[ dirOffset + 2 ] = _direction.z;

                setColorLinear( dirColors, dirOffset, color, intensity );

                dirLength += 1;

            } else if ( light instanceof THREE.PointLight ) {

                pointCount += 1;

                if ( ! light.visible ) continue;

                pointOffset = pointLength * 3;

                setColorLinear( pointColors, pointOffset, color, intensity );

                _vector3.setFromMatrixPosition( light.matrixWorld );
                _vector3.applyMatrix4( viewMatrix );

                pointPositions[ pointOffset + 0 ] = _vector3.x;
                pointPositions[ pointOffset + 1 ] = _vector3.y;
                pointPositions[ pointOffset + 2 ] = _vector3.z;

                // distance is 0 if decay is 0, because there is no attenuation at all.
                pointDistances[ pointLength ] = distance;
                pointDecays[ pointLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;

                pointLength += 1;

            } else if ( light instanceof THREE.SpotLight ) {

                spotCount += 1;

                if ( ! light.visible ) continue;

                spotOffset = spotLength * 3;

                setColorLinear( spotColors, spotOffset, color, intensity );

                _direction.setFromMatrixPosition( light.matrixWorld );
                _vector3.copy( _direction ).applyMatrix4( viewMatrix );

                spotPositions[ spotOffset + 0 ] = _vector3.x;
                spotPositions[ spotOffset + 1 ] = _vector3.y;
                spotPositions[ spotOffset + 2 ] = _vector3.z;

                spotDistances[ spotLength ] = distance;

                _vector3.setFromMatrixPosition( light.target.matrixWorld );
                _direction.sub( _vector3 );
                _direction.transformDirection( viewMatrix );

                spotDirections[ spotOffset + 0 ] = _direction.x;
                spotDirections[ spotOffset + 1 ] = _direction.y;
                spotDirections[ spotOffset + 2 ] = _direction.z;

                spotAnglesCos[ spotLength ] = Math.cos( light.angle );
                spotExponents[ spotLength ] = light.exponent;
                spotDecays[ spotLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;

                spotLength += 1;

            } else if ( light instanceof THREE.HemisphereLight ) {

                hemiCount += 1;

                if ( ! light.visible ) continue;

                _direction.setFromMatrixPosition( light.matrixWorld );
                _direction.transformDirection( viewMatrix );

                hemiOffset = hemiLength * 3;

                hemiPositions[ hemiOffset + 0 ] = _direction.x;
                hemiPositions[ hemiOffset + 1 ] = _direction.y;
                hemiPositions[ hemiOffset + 2 ] = _direction.z;

                skyColor = light.color;
                groundColor = light.groundColor;

                setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
                setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );

                hemiLength += 1;

            }

        }

        // null eventual remains from removed lights
        // (this is to avoid if in shader)

        for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;
        for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;
        for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;
        for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;
        for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;

        zlights.directional.length = dirLength;
        zlights.point.length = pointLength;
        zlights.spot.length = spotLength;
        zlights.hemi.length = hemiLength;

        zlights.ambient[ 0 ] = r;
        zlights.ambient[ 1 ] = g;
        zlights.ambient[ 2 ] = b;

    }

    // GL state setting

    this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

        if ( cullFace === THREE.CullFaceNone ) {

            state.disable( _gl.CULL_FACE );

        } else {

            if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {

                _gl.frontFace( _gl.CW );

            } else {

                _gl.frontFace( _gl.CCW );

            }

            if ( cullFace === THREE.CullFaceBack ) {

                _gl.cullFace( _gl.BACK );

            } else if ( cullFace === THREE.CullFaceFront ) {

                _gl.cullFace( _gl.FRONT );

            } else {

                _gl.cullFace( _gl.FRONT_AND_BACK );

            }

            state.enable( _gl.CULL_FACE );

        }

    };

    // Textures

    function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {

        var extension;

        if ( isImagePowerOfTwo ) {

            _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
            _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

            _gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
            _gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

        } else {

            _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
            _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

            if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {

                console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );

            }

            _gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
            _gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

            if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {

                console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );

            }

        }

        extension = extensions.get( 'EXT_texture_filter_anisotropic' );

        if ( extension ) {

            if ( texture.type === THREE.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
            if ( texture.type === THREE.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;

            if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

                _gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );
                properties.get( texture ).__currentAnisotropy = texture.anisotropy;

            }

        }

    }

    function uploadTexture( textureProperties, texture, slot ) {

        if ( textureProperties.__webglInit === undefined ) {

            textureProperties.__webglInit = true;

            texture.addEventListener( 'dispose', onTextureDispose );

            textureProperties.__webglTexture = _gl.createTexture();

            _infoMemory.textures ++;

        }

        state.activeTexture( _gl.TEXTURE0 + slot );
        state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

        _gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
        _gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
        _gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

        texture.image = clampToMaxSize( texture.image, capabilities.maxTextureSize );

        if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false ) {

            texture.image = makePowerOfTwo( texture.image );

        }

        var image = texture.image,
            isImagePowerOfTwo = isPowerOfTwo( image ),
            glFormat = paramThreeToGL( texture.format ),
            glType = paramThreeToGL( texture.type );

        setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );

        var mipmap, mipmaps = texture.mipmaps;

        if ( texture instanceof THREE.DataTexture ) {

            // use manually created mipmaps if available
            // if there are no manual mipmaps
            // set 0 level mipmap and then use GL to generate other mipmap levels

            if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

                for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

                    mipmap = mipmaps[ i ];
                    state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

                }

                texture.generateMipmaps = false;

            } else {

                state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

            }

        } else if ( texture instanceof THREE.CompressedTexture ) {

            for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

                mipmap = mipmaps[ i ];

                if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

                    if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

                        state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

                    } else {

                        console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );

                    }

                } else {

                    state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

                }

            }

        } else {

            // regular Texture (image, video, canvas)

            // use manually created mipmaps if available
            // if there are no manual mipmaps
            // set 0 level mipmap and then use GL to generate other mipmap levels

            if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

                for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

                    mipmap = mipmaps[ i ];
                    state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

                }

                texture.generateMipmaps = false;

            } else {

                state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

            }

        }

        if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

        textureProperties.__version = texture.version;

        if ( texture.onUpdate ) texture.onUpdate( texture );

    }

    this.setTexture = function ( texture, slot ) {

        var textureProperties = properties.get( texture );

        if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

            var image = texture.image;

            if ( image === undefined ) {

                console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );
                return;

            }

            if ( image.complete === false ) {

                console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );
                return;

            }

            uploadTexture( textureProperties, texture, slot );

            return;

        }

        state.activeTexture( _gl.TEXTURE0 + slot );
        state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

    };

    function clampToMaxSize ( image, maxSize ) {

        if ( image.width > maxSize || image.height > maxSize ) {

            // Warning: Scaling through the canvas will only work with images that use
            // premultiplied alpha.

            var scale = maxSize / Math.max( image.width, image.height );

            var canvas = document.createElement( 'canvas' );
            canvas.width = Math.floor( image.width * scale );
            canvas.height = Math.floor( image.height * scale );

            var context = canvas.getContext( '2d' );
            context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

            console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

            return canvas;

        }

        return image;

    }

    function isPowerOfTwo( image ) {

        return THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height );

    }

    function textureNeedsPowerOfTwo( texture ) {

        if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) return true;
        if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) return true;

        return false;

    }

    function makePowerOfTwo( image ) {

        if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {

            var canvas = document.createElement( 'canvas' );
            canvas.width = THREE.Math.nearestPowerOfTwo( image.width );
            canvas.height = THREE.Math.nearestPowerOfTwo( image.height );

            var context = canvas.getContext( '2d' );
            context.drawImage( image, 0, 0, canvas.width, canvas.height );

            console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

            return canvas;

        }

        return image;

    }

    function setCubeTexture ( texture, slot ) {

        var textureProperties = properties.get( texture );

        if ( texture.image.length === 6 ) {

            if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

                if ( ! textureProperties.__image__webglTextureCube ) {

                    texture.addEventListener( 'dispose', onTextureDispose );

                    textureProperties.__image__webglTextureCube = _gl.createTexture();

                    _infoMemory.textures ++;

                }

                state.activeTexture( _gl.TEXTURE0 + slot );
                state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

                _gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

                var isCompressed = texture instanceof THREE.CompressedTexture;
                var isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;

                var cubeImage = [];

                for ( var i = 0; i < 6; i ++ ) {

                    if ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {

                        cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );

                    } else {

                        cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

                    }

                }

                var image = cubeImage[ 0 ],
                    isImagePowerOfTwo = isPowerOfTwo( image ),
                    glFormat = paramThreeToGL( texture.format ),
                    glType = paramThreeToGL( texture.type );

                setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );

                for ( var i = 0; i < 6; i ++ ) {

                    if ( ! isCompressed ) {

                        if ( isDataTexture ) {

                            state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

                        } else {

                            state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

                        }

                    } else {

                        var mipmap, mipmaps = cubeImage[ i ].mipmaps;

                        for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

                            mipmap = mipmaps[ j ];

                            if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

                                if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

                                    state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

                                } else {

                                    console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()" );

                                }

                            } else {

                                state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

                            }

                        }

                    }

                }

                if ( texture.generateMipmaps && isImagePowerOfTwo ) {

                    _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

                }

                textureProperties.__version = texture.version;

                if ( texture.onUpdate ) texture.onUpdate( texture );

            } else {

                state.activeTexture( _gl.TEXTURE0 + slot );
                state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

            }

        }

    }

    function setCubeTextureDynamic ( texture, slot ) {

        state.activeTexture( _gl.TEXTURE0 + slot );
        state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

    }

    // Render targets

    function setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {

        _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
        _gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );

    }

    function setupRenderBuffer ( renderbuffer, renderTarget ) {

        _gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

        if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

            _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
            _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

            /* For some reason this is not working. Defaulting to RGBA4.
             } else if ( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

             _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
             _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
             */

        } else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

            _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
            _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

        } else {

            _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

        }

    }

    this.setRenderTarget = function ( renderTarget ) {

        var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );

        if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

            var renderTargetProperties = properties.get( renderTarget );
            var textureProperties = properties.get( renderTarget.texture );

            if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;
            if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;

            renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

            textureProperties.__webglTexture = _gl.createTexture();

            _infoMemory.textures ++;

            // Setup texture, create render and frame buffers

            var isTargetPowerOfTwo = isPowerOfTwo( renderTarget ),
                glFormat = paramThreeToGL( renderTarget.texture.format ),
                glType = paramThreeToGL( renderTarget.texture.type );

            if ( isCube ) {

                renderTargetProperties.__webglFramebuffer = [];
                renderTargetProperties.__webglRenderbuffer = [];

                state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );

                setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );

                for ( var i = 0; i < 6; i ++ ) {

                    renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();
                    renderTargetProperties.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();
                    state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

                    setupFrameBuffer( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
                    setupRenderBuffer( renderTargetProperties.__webglRenderbuffer[ i ], renderTarget );

                }

                if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

            } else {

                renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

                if ( renderTarget.shareDepthFrom ) {

                    renderTargetProperties.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;

                } else {

                    renderTargetProperties.__webglRenderbuffer = _gl.createRenderbuffer();

                }

                state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
                setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );

                state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

                setupFrameBuffer( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );

                if ( renderTarget.shareDepthFrom ) {

                    if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

                        _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer );

                    } else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

                        _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer );

                    }

                } else {

                    setupRenderBuffer( renderTargetProperties.__webglRenderbuffer, renderTarget );

                }

                if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

            }

            // Release everything

            if ( isCube ) {

                state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

            } else {

                state.bindTexture( _gl.TEXTURE_2D, null );

            }

            _gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
            _gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

        }

        var framebuffer, width, height, vx, vy;

        if ( renderTarget ) {

            var renderTargetProperties = properties.get( renderTarget );

            if ( isCube ) {

                framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];

            } else {

                framebuffer = renderTargetProperties.__webglFramebuffer;

            }

            width = renderTarget.width;
            height = renderTarget.height;

            vx = 0;
            vy = 0;

        } else {

            framebuffer = null;

            width = _viewportWidth;
            height = _viewportHeight;

            vx = _viewportX;
            vy = _viewportY;

        }

        if ( framebuffer !== _currentFramebuffer ) {

            _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
            _gl.viewport( vx, vy, width, height );

            _currentFramebuffer = framebuffer;

        }

        if ( isCube ) {

            var textureProperties = properties.get( renderTarget.texture );
            _gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, 0 );

        }

        _currentWidth = width;
        _currentHeight = height;

    };

    this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {

        if ( renderTarget instanceof THREE.WebGLRenderTarget === false ) {

            console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
            return;

        }

        var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

        if ( framebuffer ) {

            var restore = false;

            if ( framebuffer !== _currentFramebuffer ) {

                _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

                restore = true;

            }

            try {

                var texture = renderTarget.texture;

                if ( texture.format !== THREE.RGBAFormat
                    && paramThreeToGL( texture.format ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

                    console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
                    return;

                }

                if ( texture.type !== THREE.UnsignedByteType
                    && paramThreeToGL( texture.type ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE )
                    && ! ( texture.type === THREE.FloatType && extensions.get( 'WEBGL_color_buffer_float' ) )
                    && ! ( texture.type === THREE.HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {

                    console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
                    return;

                }

                if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

                    _gl.readPixels( x, y, width, height, paramThreeToGL( texture.format ), paramThreeToGL( texture.type ), buffer );

                } else {

                    console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

                }

            } finally {

                if ( restore ) {

                    _gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

                }

            }

        }

    };

    function updateRenderTargetMipmap( renderTarget ) {

        var target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
        var texture = properties.get( renderTarget.texture ).__webglTexture;

        state.bindTexture( target, texture );
        _gl.generateMipmap( target );
        state.bindTexture( target, null );

    }

    // Fallback filters for non-power-of-2 textures

    function filterFallback ( f ) {

        if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {

            return _gl.NEAREST;

        }

        return _gl.LINEAR;

    }

    // Map three.js constants to WebGL constants

    function paramThreeToGL ( p ) {

        var extension;

        if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
        if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
        if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

        if ( p === THREE.NearestFilter ) return _gl.NEAREST;
        if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
        if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

        if ( p === THREE.LinearFilter ) return _gl.LINEAR;
        if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
        if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

        if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
        if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
        if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
        if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

        if ( p === THREE.ByteType ) return _gl.BYTE;
        if ( p === THREE.ShortType ) return _gl.SHORT;
        if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
        if ( p === THREE.IntType ) return _gl.INT;
        if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
        if ( p === THREE.FloatType ) return _gl.FLOAT;

        extension = extensions.get( 'OES_texture_half_float' );

        if ( extension !== null ) {

            if ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;

        }

        if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
        if ( p === THREE.RGBFormat ) return _gl.RGB;
        if ( p === THREE.RGBAFormat ) return _gl.RGBA;
        if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
        if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;

        if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
        if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
        if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

        if ( p === THREE.ZeroFactor ) return _gl.ZERO;
        if ( p === THREE.OneFactor ) return _gl.ONE;
        if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
        if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
        if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
        if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
        if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
        if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

        if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
        if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
        if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

        extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

        if ( extension !== null ) {

            if ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

        }

        extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

        if ( extension !== null ) {

            if ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

        }

        extension = extensions.get( 'EXT_blend_minmax' );

        if ( extension !== null ) {

            if ( p === THREE.MinEquation ) return extension.MIN_EXT;
            if ( p === THREE.MaxEquation ) return extension.MAX_EXT;

        }

        return 0;

    }

    // DEPRECATED

    this.supportsFloatTextures = function () {

        console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
        return extensions.get( 'OES_texture_float' );

    };

    this.supportsHalfFloatTextures = function () {

        console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
        return extensions.get( 'OES_texture_half_float' );

    };

    this.supportsStandardDerivatives = function () {

        console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
        return extensions.get( 'OES_standard_derivatives' );

    };

    this.supportsCompressedTextureS3TC = function () {

        console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
        return extensions.get( 'WEBGL_compressed_texture_s3tc' );

    };

    this.supportsCompressedTexturePVRTC = function () {

        console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
        return extensions.get( 'WEBGL_compressed_texture_pvrtc' );

    };

    this.supportsBlendMinMax = function () {

        console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
        return extensions.get( 'EXT_blend_minmax' );

    };

    this.supportsVertexTextures = function () {

        return capabilities.vertexTextures;

    };

    this.supportsInstancedArrays = function () {

        console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
        return extensions.get( 'ANGLE_instanced_arrays' );

    };

    //

    this.initMaterial = function () {

        console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

    };

    this.addPrePlugin = function () {

        console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

    };

    this.addPostPlugin = function () {

        console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

    };

    this.updateShadowMap = function () {

        console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

    };

    Object.defineProperties( this, {
        shadowMapEnabled: {
            get: function () {

                return shadowMap.enabled;

            },
            set: function ( value ) {

                console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
                shadowMap.enabled = value;

            }
        },
        shadowMapType: {
            get: function () {

                return shadowMap.type;

            },
            set: function ( value ) {

                console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
                shadowMap.type = value;

            }
        },
        shadowMapCullFace: {
            get: function () {

                return shadowMap.cullFace;

            },
            set: function ( value ) {

                console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
                shadowMap.cullFace = value;

            }
        },
        shadowMapDebug: {
            get: function () {

                return shadowMap.debug;

            },
            set: function ( value ) {

                console.warn( 'THREE.WebGLRenderer: .shadowMapDebug is now .shadowMap.debug.' );
                shadowMap.debug = value;

            }
        }
    } );

};

// File:src/renderers/WebGLRenderTarget.js

/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.WebGLRenderTarget = function ( width, height, options ) {

    this.uuid = THREE.Math.generateUUID();

    this.width = width;
    this.height = height;

    options = options || {};

    if ( options.minFilter === undefined ) options.minFilter = THREE.LinearFilter;

    this.texture = new THREE.Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy );

    this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
    this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;

    this.shareDepthFrom = options.shareDepthFrom !== undefined ? options.shareDepthFrom : null;

};

THREE.WebGLRenderTarget.prototype = {

    constructor: THREE.WebGLRenderTarget,

    get wrapS() {

        console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );

        return this.texture.wrapS;

    },

    set wrapS( value ) {

        console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );

        this.texture.wrapS = value;

    },

    get wrapT() {

        console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );

        return this.texture.wrapT;

    },

    set wrapT( value ) {

        console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );

        this.texture.wrapT = value;

    },

    get magFilter() {

        console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );

        return this.texture.magFilter;

    },

    set magFilter( value ) {

        console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );

        this.texture.magFilter = value;

    },

    get minFilter() {

        console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );

        return this.texture.minFilter;

    },

    set minFilter( value ) {

        console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );

        this.texture.minFilter = value;

    },

    get anisotropy() {

        console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );

        return this.texture.anisotropy;

    },

    set anisotropy( value ) {

        console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );

        this.texture.anisotropy = value;

    },

    get offset() {

        console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );

        return this.texture.offset;

    },

    set offset( value ) {

        console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );

        this.texture.offset = value;

    },

    get repeat() {

        console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );

        return this.texture.repeat;

    },

    set repeat( value ) {

        console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );

        this.texture.repeat = value;

    },

    get format() {

        console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );

        return this.texture.format;

    },

    set format( value ) {

        console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );

        this.texture.format = value;

    },

    get type() {

        console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );

        return this.texture.type;

    },

    set type( value ) {

        console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );

        this.texture.type = value;

    },

    get generateMipmaps() {

        console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );

        return this.texture.generateMipmaps;

    },

    set generateMipmaps( value ) {

        console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );

        this.texture.generateMipmaps = value;

    },

    //

    setSize: function ( width, height ) {

        if ( this.width !== width || this.height !== height ) {

            this.width = width;
            this.height = height;

            this.dispose();

        }

    },

    clone: function () {

        return new this.constructor().copy( this );

    },

    copy: function ( source ) {

        this.width = source.width;
        this.height = source.height;

        this.texture = source.texture.clone();

        this.depthBuffer = source.depthBuffer;
        this.stencilBuffer = source.stencilBuffer;

        this.shareDepthFrom = source.shareDepthFrom;

        return this;

    },

    dispose: function () {

        this.dispatchEvent( { type: 'dispose' } );

    }

};

THREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );

// File:src/renderers/WebGLRenderTargetCube.js

/**
 * @author alteredq / http://alteredqualia.com
 */

THREE.WebGLRenderTargetCube = function ( width, height, options ) {

    THREE.WebGLRenderTarget.call( this, width, height, options );

    this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5

};

THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );
THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;

// File:src/renderers/webgl/WebGLBufferRenderer.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLBufferRenderer = function ( _gl, extensions, _infoRender ) {

    var mode;

    function setMode( value ) {

        mode = value;

    }

    function render( start, count ) {

        _gl.drawArrays( mode, start, count );

        _infoRender.calls ++;
        _infoRender.vertices += count;
        if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;

    }

    function renderInstances( geometry ) {

        var extension = extensions.get( 'ANGLE_instanced_arrays' );

        if ( extension === null ) {

            console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
            return;

        }

        var position = geometry.attributes.position;

        if ( position instanceof THREE.InterleavedBufferAttribute ) {

            extension.drawArraysInstancedANGLE( mode, 0, position.data.count, geometry.maxInstancedCount );

        } else {

            extension.drawArraysInstancedANGLE( mode, 0, position.count, geometry.maxInstancedCount );

        }

    }

    this.setMode = setMode;
    this.render = render;
    this.renderInstances = renderInstances;

};

// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLIndexedBufferRenderer = function ( _gl, extensions, _infoRender ) {

    var mode;

    function setMode( value ) {

        mode = value;

    }

    var type, size;

    function setIndex( index ) {

        if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

            type = _gl.UNSIGNED_INT;
            size = 4;

        } else {

            type = _gl.UNSIGNED_SHORT;
            size = 2;

        }

    }

    function render( start, count ) {

        _gl.drawElements( mode, count, type, start * size );

        _infoRender.calls ++;
        _infoRender.vertices += count;
        if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;

    }

    function renderInstances( geometry ) {

        var extension = extensions.get( 'ANGLE_instanced_arrays' );

        if ( extension === null ) {

            console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
            return;

        }

        var index = geometry.index;

        extension.drawElementsInstancedANGLE( mode, index.array.length, type, 0, geometry.maxInstancedCount );

    }

    this.setMode = setMode;
    this.setIndex = setIndex;
    this.render = render;
    this.renderInstances = renderInstances;

};

// File:src/renderers/webgl/WebGLExtensions.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLExtensions = function ( gl ) {

    var extensions = {};

    this.get = function ( name ) {

        if ( extensions[ name ] !== undefined ) {

            return extensions[ name ];

        }

        var extension;

        switch ( name ) {

            case 'EXT_texture_filter_anisotropic':
                extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
                break;

            case 'WEBGL_compressed_texture_s3tc':
                extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
                break;

            case 'WEBGL_compressed_texture_pvrtc':
                extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
                break;

            default:
                extension = gl.getExtension( name );

        }

        if ( extension === null ) {

            console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

        }

        extensions[ name ] = extension;

        return extension;

    };

};

// File:src/renderers/webgl/WebGLCapabilities.js

THREE.WebGLCapabilities = function ( gl, extensions, parameters ) {

    function getMaxPrecision( precision ) {

        if ( precision === 'highp' ) {

            if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
                gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

                return 'highp';

            }

            precision = 'mediump';

        }

        if ( precision === 'mediump' ) {

            if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
                gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

                return 'mediump';

            }

        }

        return 'lowp';

    }

    this.getMaxPrecision = getMaxPrecision;

    this.precision = parameters.precision !== undefined ? parameters.precision : 'highp',
        this.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;

    this.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
    this.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
    this.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
    this.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

    this.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
    this.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
    this.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
    this.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

    this.vertexTextures = this.maxVertexTextures > 0;
    this.floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
    this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;

    var _maxPrecision = getMaxPrecision( this.precision );

    if ( _maxPrecision !== this.precision ) {

        console.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );
        this.precision = _maxPrecision;

    }

    if ( this.logarithmicDepthBuffer ) {

        this.logarithmicDepthBuffer = !! extensions.get( 'EXT_frag_depth' );

    }

};

// File:src/renderers/webgl/WebGLGeometries.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLGeometries = function ( gl, properties, info ) {

    var geometries = {};

    function get( object ) {

        var geometry = object.geometry;

        if ( geometries[ geometry.id ] !== undefined ) {

            return geometries[ geometry.id ];

        }

        geometry.addEventListener( 'dispose', onGeometryDispose );

        var buffergeometry;

        if ( geometry instanceof THREE.BufferGeometry ) {

            buffergeometry = geometry;

        } else if ( geometry instanceof THREE.Geometry ) {

            if ( geometry._bufferGeometry === undefined ) {

                geometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );

            }

            buffergeometry = geometry._bufferGeometry;

        }

        geometries[ geometry.id ] = buffergeometry;

        info.memory.geometries ++;

        return buffergeometry;

    }

    function onGeometryDispose( event ) {

        var geometry = event.target;
        var buffergeometry = geometries[ geometry.id ];

        deleteAttributes( buffergeometry.attributes );

        geometry.removeEventListener( 'dispose', onGeometryDispose );

        delete geometries[ geometry.id ];

        var property = properties.get( geometry );
        if ( property.wireframe ) deleteAttribute( property.wireframe );

        info.memory.geometries --;

    }

    function getAttributeBuffer( attribute ) {

        if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

            return properties.get( attribute.data ).__webglBuffer;

        }

        return properties.get( attribute ).__webglBuffer;

    }

    function deleteAttribute( attribute ) {

        var buffer = getAttributeBuffer( attribute );

        if ( buffer !== undefined ) {

            gl.deleteBuffer( buffer );
            removeAttributeBuffer( attribute );

        }

    }

    function deleteAttributes( attributes ) {

        for ( var name in attributes ) {

            deleteAttribute( attributes[ name ] );

        }

    }

    function removeAttributeBuffer( attribute ) {

        if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

            properties.delete( attribute.data );

        } else {

            properties.delete( attribute );

        }

    }

    this.get = get;

};

// File:src/renderers/webgl/WebGLObjects.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLObjects = function ( gl, properties, info ) {

    var geometries = new THREE.WebGLGeometries( gl, properties, info );

    //

    function update( object ) {

        // TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.

        var geometry = geometries.get( object );

        if ( object.geometry instanceof THREE.Geometry ) {

            geometry.updateFromObject( object );

        }

        var index = geometry.index;
        var attributes = geometry.attributes;

        if ( index !== null ) {

            updateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );

        }

        for ( var name in attributes ) {

            updateAttribute( attributes[ name ], gl.ARRAY_BUFFER );

        }

        // morph targets

        var morphAttributes = geometry.morphAttributes;

        for ( var name in morphAttributes ) {

            var array = morphAttributes[ name ];

            for ( var i = 0, l = array.length; i < l; i ++ ) {

                updateAttribute( array[ i ], gl.ARRAY_BUFFER );

            }

        }

        return geometry;

    }

    function updateAttribute( attribute, bufferType ) {

        var data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;

        var attributeProperties = properties.get( data );

        if ( attributeProperties.__webglBuffer === undefined ) {

            createBuffer( attributeProperties, data, bufferType );

        } else if ( attributeProperties.version !== data.version ) {

            updateBuffer( attributeProperties, data, bufferType );

        }

    }

    function createBuffer( attributeProperties, data, bufferType ) {

        attributeProperties.__webglBuffer = gl.createBuffer();
        gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

        var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

        gl.bufferData( bufferType, data.array, usage );

        attributeProperties.version = data.version;

    }

    function updateBuffer( attributeProperties, data, bufferType ) {

        gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

        if ( data.dynamic === false || data.updateRange.count === - 1 ) {

            // Not using update ranges

            gl.bufferSubData( bufferType, 0, data.array );

        } else if ( data.updateRange.count === 0 ) {

            console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

        } else {

            gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
                data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );

            data.updateRange.count = 0; // reset range

        }

        attributeProperties.version = data.version;

    }

    function getAttributeBuffer( attribute ) {

        if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

            return properties.get( attribute.data ).__webglBuffer;

        }

        return properties.get( attribute ).__webglBuffer;

    }

    function getWireframeAttribute( geometry ) {

        var property = properties.get( geometry );

        if ( property.wireframe !== undefined ) {

            return property.wireframe;

        }

        var indices = [];

        var index = geometry.index;
        var attributes = geometry.attributes;
        var position = attributes.position;

        // console.time( 'wireframe' );

        if ( index !== null ) {

            var edges = {};
            var array = index.array;

            for ( var i = 0, l = array.length; i < l; i += 3 ) {

                var a = array[ i + 0 ];
                var b = array[ i + 1 ];
                var c = array[ i + 2 ];

                if ( checkEdge( edges, a, b ) ) indices.push( a, b );
                if ( checkEdge( edges, b, c ) ) indices.push( b, c );
                if ( checkEdge( edges, c, a ) ) indices.push( c, a );

            }

        } else {

            var array = attributes.position.array;

            for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

                var a = i + 0;
                var b = i + 1;
                var c = i + 2;

                indices.push( a, b, b, c, c, a );

            }

        }

        // console.timeEnd( 'wireframe' );

        var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
        var attribute = new THREE.BufferAttribute( new TypeArray( indices ), 1 );

        updateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );

        property.wireframe = attribute;

        return attribute;

    }

    function checkEdge( edges, a, b ) {

        if ( a > b ) {

            var tmp = a;
            a = b;
            b = tmp;

        }

        var list = edges[ a ];

        if ( list === undefined ) {

            edges[ a ] = [ b ];
            return true;

        } else if ( list.indexOf( b ) === -1 ) {

            list.push( b );
            return true;

        }

        return false;

    }

    this.getAttributeBuffer = getAttributeBuffer;
    this.getWireframeAttribute = getWireframeAttribute;

    this.update = update;

};

// File:src/renderers/webgl/WebGLProgram.js

THREE.WebGLProgram = ( function () {

    var programIdCount = 0;

    function generateDefines( defines ) {

        var chunks = [];

        for ( var name in defines ) {

            var value = defines[ name ];

            if ( value === false ) continue;

            chunks.push( '#define ' + name + ' ' + value );

        }

        return chunks.join( '\n' );

    }

    function fetchUniformLocations( gl, program, identifiers ) {

        var uniforms = {};

        var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

        for ( var i = 0; i < n; i ++ ) {

            var info = gl.getActiveUniform( program, i );
            var name = info.name;
            var location = gl.getUniformLocation( program, name );

            // console.log("THREE.WebGLProgram: ACTIVE UNIFORM:", name);

            var suffixPos = name.lastIndexOf( '[0]' );
            if ( suffixPos !== - 1 && suffixPos === name.length - 3 ) {

                uniforms[ name.substr( 0, suffixPos ) ] = location;

            }

            uniforms[ name ] = location;

        }

        return uniforms;

    }

    function fetchAttributeLocations( gl, program, identifiers ) {

        var attributes = {};

        var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

        for ( var i = 0; i < n; i ++ ) {

            var info = gl.getActiveAttrib( program, i );
            var name = info.name;

            // console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );

            attributes[ name ] = gl.getAttribLocation( program, name );

        }

        return attributes;

    }

    function filterEmptyLine( string ) {

        return string !== '';

    }

    return function WebGLProgram( renderer, code, material, parameters ) {

        var gl = renderer.context;

        var defines = material.defines;

        var vertexShader = material.__webglShader.vertexShader;
        var fragmentShader = material.__webglShader.fragmentShader;

        var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

        if ( parameters.shadowMapType === THREE.PCFShadowMap ) {

            shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

        } else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {

            shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

        }

        var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
        var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
        var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

        if ( parameters.envMap ) {

            switch ( material.envMap.mapping ) {

                case THREE.CubeReflectionMapping:
                case THREE.CubeRefractionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
                    break;

                case THREE.EquirectangularReflectionMapping:
                case THREE.EquirectangularRefractionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
                    break;

                case THREE.SphericalReflectionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
                    break;

            }

            switch ( material.envMap.mapping ) {

                case THREE.CubeRefractionMapping:
                case THREE.EquirectangularRefractionMapping:
                    envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
                    break;

            }

            switch ( material.combine ) {

                case THREE.MultiplyOperation:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
                    break;

                case THREE.MixOperation:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
                    break;

                case THREE.AddOperation:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
                    break;

            }

        }

        var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

        // console.log( 'building new program ' );

        //

        var customDefines = generateDefines( defines );

        //

        var program = gl.createProgram();

        var prefixVertex, prefixFragment;

        if ( material instanceof THREE.RawShaderMaterial ) {

            prefixVertex = '';
            prefixFragment = '';

        } else {

            prefixVertex = [

                'precision ' + parameters.precision + ' float;',
                'precision ' + parameters.precision + ' int;',

                '#define SHADER_NAME ' + material.__webglShader.name,

                customDefines,

                parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

                renderer.gammaInput ? '#define GAMMA_INPUT' : '',
                renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
                '#define GAMMA_FACTOR ' + gammaFactorDefine,

                '#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
                '#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
                '#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
                '#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

                '#define MAX_SHADOWS ' + parameters.maxShadows,

                '#define MAX_BONES ' + parameters.maxBones,

                parameters.map ? '#define USE_MAP' : '',
                parameters.envMap ? '#define USE_ENVMAP' : '',
                parameters.envMap ? '#define ' + envMapModeDefine : '',
                parameters.lightMap ? '#define USE_LIGHTMAP' : '',
                parameters.aoMap ? '#define USE_AOMAP' : '',
                parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                parameters.bumpMap ? '#define USE_BUMPMAP' : '',
                parameters.normalMap ? '#define USE_NORMALMAP' : '',
                parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
                parameters.specularMap ? '#define USE_SPECULARMAP' : '',
                parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
                parameters.vertexColors ? '#define USE_COLOR' : '',

                parameters.flatShading ? '#define FLAT_SHADED' : '',

                parameters.skinning ? '#define USE_SKINNING' : '',
                parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

                parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
                parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
                parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
                parameters.flipSided ? '#define FLIP_SIDED' : '',

                parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
                parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
                parameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '',

                parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

                parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',


                'uniform mat4 modelMatrix;',
                'uniform mat4 modelViewMatrix;',
                'uniform mat4 projectionMatrix;',
                'uniform mat4 viewMatrix;',
                'uniform mat3 normalMatrix;',
                'uniform vec3 cameraPosition;',

                'attribute vec3 position;',
                'attribute vec3 normal;',
                'attribute vec2 uv;',

                '#ifdef USE_COLOR',

                '	attribute vec3 color;',

                '#endif',

                '#ifdef USE_MORPHTARGETS',

                '	attribute vec3 morphTarget0;',
                '	attribute vec3 morphTarget1;',
                '	attribute vec3 morphTarget2;',
                '	attribute vec3 morphTarget3;',

                '	#ifdef USE_MORPHNORMALS',

                '		attribute vec3 morphNormal0;',
                '		attribute vec3 morphNormal1;',
                '		attribute vec3 morphNormal2;',
                '		attribute vec3 morphNormal3;',

                '	#else',

                '		attribute vec3 morphTarget4;',
                '		attribute vec3 morphTarget5;',
                '		attribute vec3 morphTarget6;',
                '		attribute vec3 morphTarget7;',

                '	#endif',

                '#endif',

                '#ifdef USE_SKINNING',

                '	attribute vec4 skinIndex;',
                '	attribute vec4 skinWeight;',

                '#endif',

                '\n'

            ].filter( filterEmptyLine ).join( '\n' );

            prefixFragment = [

                parameters.bumpMap || parameters.normalMap || parameters.flatShading || material.derivatives ? '#extension GL_OES_standard_derivatives : enable' : '',
                parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',

                'precision ' + parameters.precision + ' float;',
                'precision ' + parameters.precision + ' int;',

                '#define SHADER_NAME ' + material.__webglShader.name,

                customDefines,

                '#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
                '#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
                '#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
                '#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

                '#define MAX_SHADOWS ' + parameters.maxShadows,

                parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

                renderer.gammaInput ? '#define GAMMA_INPUT' : '',
                renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
                '#define GAMMA_FACTOR ' + gammaFactorDefine,

                ( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
                ( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

                parameters.map ? '#define USE_MAP' : '',
                parameters.envMap ? '#define USE_ENVMAP' : '',
                parameters.envMap ? '#define ' + envMapTypeDefine : '',
                parameters.envMap ? '#define ' + envMapModeDefine : '',
                parameters.envMap ? '#define ' + envMapBlendingDefine : '',
                parameters.lightMap ? '#define USE_LIGHTMAP' : '',
                parameters.aoMap ? '#define USE_AOMAP' : '',
                parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                parameters.bumpMap ? '#define USE_BUMPMAP' : '',
                parameters.normalMap ? '#define USE_NORMALMAP' : '',
                parameters.specularMap ? '#define USE_SPECULARMAP' : '',
                parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
                parameters.vertexColors ? '#define USE_COLOR' : '',

                parameters.flatShading ? '#define FLAT_SHADED' : '',

                parameters.metal ? '#define METAL' : '',
                parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
                parameters.flipSided ? '#define FLIP_SIDED' : '',

                parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
                parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
                parameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '',

                parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

                'uniform mat4 viewMatrix;',
                'uniform vec3 cameraPosition;',

                '\n'

            ].filter( filterEmptyLine ).join( '\n' );

        }

        var vertexGlsl = prefixVertex + vertexShader;
        var fragmentGlsl = prefixFragment + fragmentShader;

        var glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
        var glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

        gl.attachShader( program, glVertexShader );
        gl.attachShader( program, glFragmentShader );

        // Force a particular attribute to index 0.

        if ( material.index0AttributeName !== undefined ) {

            gl.bindAttribLocation( program, 0, material.index0AttributeName );

        } else if ( parameters.morphTargets === true ) {

            // programs with morphTargets displace position out of attribute 0
            gl.bindAttribLocation( program, 0, 'position' );

        }

        gl.linkProgram( program );

        var programLog = gl.getProgramInfoLog( program );
        var vertexLog = gl.getShaderInfoLog( glVertexShader );
        var fragmentLog = gl.getShaderInfoLog( glFragmentShader );

        var runnable = true;
        var haveDiagnostics = true;

        if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

            runnable = false;

            console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

        } else if ( programLog !== '' ) {

            console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

        } else if ( vertexLog === '' || fragmentLog === '' ) {

            haveDiagnostics = false;

        }

        if ( haveDiagnostics ) {

            this.diagnostics = {

                runnable: runnable,
                material: material,

                programLog: programLog,

                vertexShader: {

                    log: vertexLog,
                    prefix: prefixVertex

                },

                fragmentShader: {

                    log: fragmentLog,
                    prefix: prefixFragment

                }

            };

        }

        // clean up

        gl.deleteShader( glVertexShader );
        gl.deleteShader( glFragmentShader );

        // set up caching for uniform locations

        var cachedUniforms;

        this.getUniforms = function() {

            if ( cachedUniforms === undefined ) {

                cachedUniforms = fetchUniformLocations( gl, program );

            }

            return cachedUniforms;

        };

        // set up caching for attribute locations

        var cachedAttributes;

        this.getAttributes = function() {

            if ( cachedAttributes === undefined ) {

                cachedAttributes = fetchAttributeLocations( gl, program );

            }

            return cachedAttributes;

        };

        // free resource

        this.destroy = function() {

            gl.deleteProgram( program );
            this.program = undefined;

        };

        // DEPRECATED

        Object.defineProperties( this, {

            uniforms: {
                get: function() {

                    console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
                    return this.getUniforms();

                }
            },

            attributes: {
                get: function() {

                    console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
                    return this.getAttributes();

                }
            }

        } );


        //

        this.id = programIdCount ++;
        this.code = code;
        this.usedTimes = 1;
        this.program = program;
        this.vertexShader = glVertexShader;
        this.fragmentShader = glFragmentShader;

        return this;

    };

} )();

// File:src/renderers/webgl/WebGLPrograms.js

THREE.WebGLPrograms = function ( renderer, capabilities ) {

    var programs = [];

    var shaderIDs = {
        MeshDepthMaterial: 'depth',
        MeshNormalMaterial: 'normal',
        MeshBasicMaterial: 'basic',
        MeshLambertMaterial: 'lambert',
        MeshPhongMaterial: 'phong',
        LineBasicMaterial: 'basic',
        LineDashedMaterial: 'dashed',
        PointsMaterial: 'points'
    };

    var parameterNames = [
        "precision", "supportsVertexTextures", "map", "envMap", "envMapMode",
        "lightMap", "aoMap", "emissiveMap", "bumpMap", "normalMap", "displacementMap", "specularMap",
        "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
        "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
        "maxBones", "useVertexTexture", "morphTargets", "morphNormals",
        "maxMorphTargets", "maxMorphNormals", "maxDirLights", "maxPointLights",
        "maxSpotLights", "maxHemiLights", "maxShadows", "shadowMapEnabled", "pointLightShadows",
        "shadowMapType", "shadowMapDebug", "alphaTest", "metal", "doubleSided",
        "flipSided"
    ];


    function allocateBones ( object ) {

        if ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

            return 1024;

        } else {

            // default for when object is not specified
            // ( for example when prebuilding shader to be used with multiple objects )
            //
            //  - leave some extra space for other uniforms
            //  - limit here is ANGLE's 254 max uniform vectors
            //    (up to 54 should be safe)

            var nVertexUniforms = capabilities.maxVertexUniforms;
            var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

            var maxBones = nVertexMatrices;

            if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {

                maxBones = Math.min( object.skeleton.bones.length, maxBones );

                if ( maxBones < object.skeleton.bones.length ) {

                    console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

                }

            }

            return maxBones;

        }

    }

    function allocateLights( lights ) {

        var dirLights = 0;
        var pointLights = 0;
        var spotLights = 0;
        var hemiLights = 0;

        for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

            var light = lights[ l ];

            if ( light.visible === false ) continue;

            if ( light instanceof THREE.DirectionalLight ) dirLights ++;
            if ( light instanceof THREE.PointLight ) pointLights ++;
            if ( light instanceof THREE.SpotLight ) spotLights ++;
            if ( light instanceof THREE.HemisphereLight ) hemiLights ++;

        }

        return { 'directional': dirLights, 'point': pointLights, 'spot': spotLights, 'hemi': hemiLights };

    }

    function allocateShadows( lights ) {

        var maxShadows = 0;
        var pointLightShadows = 0;

        for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

            var light = lights[ l ];

            if ( ! light.castShadow ) continue;

            if ( light instanceof THREE.SpotLight || light instanceof THREE.DirectionalLight ) maxShadows ++;
            if ( light instanceof THREE.PointLight ) {

                maxShadows ++;
                pointLightShadows ++;

            }

        }

        return { 'maxShadows': maxShadows, 'pointLightShadows': pointLightShadows };

    }

    this.getParameters = function ( material, lights, fog, object ) {

        var shaderID = shaderIDs[ material.type ];
        // heuristics to create shader parameters according to lights in the scene
        // (not to blow over maxLights budget)

        var maxLightCount = allocateLights( lights );
        var allocatedShadows = allocateShadows( lights );
        var maxBones = allocateBones( object );
        var precision = renderer.getPrecision();

        if ( material.precision !== null ) {

            precision = capabilities.getMaxPrecision( material.precision );

            if ( precision !== material.precision ) {

                console.warn( 'THREE.WebGLRenderer.initMaterial:', material.precision, 'not supported, using', precision, 'instead.' );

            }

        }

        var parameters = {

            shaderID: shaderID,

            precision: precision,
            supportsVertexTextures: capabilities.vertexTextures,

            map: !! material.map,
            envMap: !! material.envMap,
            envMapMode: material.envMap && material.envMap.mapping,
            lightMap: !! material.lightMap,
            aoMap: !! material.aoMap,
            emissiveMap: !! material.emissiveMap,
            bumpMap: !! material.bumpMap,
            normalMap: !! material.normalMap,
            displacementMap: !! material.displacementMap,
            specularMap: !! material.specularMap,
            alphaMap: !! material.alphaMap,

            combine: material.combine,

            vertexColors: material.vertexColors,

            fog: fog,
            useFog: material.fog,
            fogExp: fog instanceof THREE.FogExp2,

            flatShading: material.shading === THREE.FlatShading,

            sizeAttenuation: material.sizeAttenuation,
            logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

            skinning: material.skinning,
            maxBones: maxBones,
            useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,

            morphTargets: material.morphTargets,
            morphNormals: material.morphNormals,
            maxMorphTargets: renderer.maxMorphTargets,
            maxMorphNormals: renderer.maxMorphNormals,

            maxDirLights: maxLightCount.directional,
            maxPointLights: maxLightCount.point,
            maxSpotLights: maxLightCount.spot,
            maxHemiLights: maxLightCount.hemi,

            maxShadows: allocatedShadows.maxShadows,
            pointLightShadows: allocatedShadows.pointLightShadows,
            shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && allocatedShadows.maxShadows > 0,
            shadowMapType: renderer.shadowMap.type,
            shadowMapDebug: renderer.shadowMap.debug,

            alphaTest: material.alphaTest,
            metal: material.metal,
            doubleSided: material.side === THREE.DoubleSide,
            flipSided: material.side === THREE.BackSide

        };

        return parameters;

    };

    this.getProgramCode = function ( material, parameters ) {

        var chunks = [];

        if ( parameters.shaderID ) {

            chunks.push( parameters.shaderID );

        } else {

            chunks.push( material.fragmentShader );
            chunks.push( material.vertexShader );

        }

        if ( material.defines !== undefined ) {

            for ( var name in material.defines ) {

                chunks.push( name );
                chunks.push( material.defines[ name ] );

            }

        }

        for ( var i = 0; i < parameterNames.length; i ++ ) {

            var parameterName = parameterNames[ i ];
            chunks.push( parameterName );
            chunks.push( parameters[ parameterName ] );

        }

        return chunks.join();

    };

    this.acquireProgram = function ( material, parameters, code ) {

        var program;

        // Check if code has been already compiled
        for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

            var programInfo = programs[ p ];

            if ( programInfo.code === code ) {

                program = programInfo;
                ++ program.usedTimes;

                break;

            }

        }

        if ( program === undefined ) {

            program = new THREE.WebGLProgram( renderer, code, material, parameters );
            programs.push( program );

        }

        return program;

    };

    this.releaseProgram = function( program ) {

        if ( -- program.usedTimes === 0 ) {

            // Remove from unordered set
            var i = programs.indexOf( program );
            programs[ i ] = programs[ programs.length - 1 ];
            programs.pop();

            // Free WebGL resources
            program.destroy();

        }

    };

    // Exposed for resource monitoring & error feedback via renderer.info:
    this.programs = programs;

};

// File:src/renderers/webgl/WebGLProperties.js

/**
 * @author fordacious / fordacious.github.io
 */

THREE.WebGLProperties = function () {

    var properties = {};

    this.get = function ( object ) {

        var uuid = object.uuid;
        var map = properties[ uuid ];

        if ( map === undefined ) {

            map = {};
            properties[ uuid ] = map;

        }

        return map;

    };

    this.delete = function ( object ) {

        delete properties[ object.uuid ];

    };

    this.clear = function () {

        properties = {};

    };

};

// File:src/renderers/webgl/WebGLShader.js

THREE.WebGLShader = ( function () {

    function addLineNumbers( string ) {

        var lines = string.split( '\n' );

        for ( var i = 0; i < lines.length; i ++ ) {

            lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

        }

        return lines.join( '\n' );

    }

    return function WebGLShader( gl, type, string ) {

        var shader = gl.createShader( type );

        gl.shaderSource( shader, string );
        gl.compileShader( shader );

        if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

            console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

        }

        if ( gl.getShaderInfoLog( shader ) !== '' ) {

            console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

        }

        // --enable-privileged-webgl-extension
        // console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

        return shader;

    };

} )();

// File:src/renderers/webgl/WebGLShadowMap.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLShadowMap = function ( _renderer, _lights, _objects ) {

    var _gl = _renderer.context,
        _state = _renderer.state,
        _frustum = new THREE.Frustum(),
        _projScreenMatrix = new THREE.Matrix4(),

        _min = new THREE.Vector3(),
        _max = new THREE.Vector3(),

        _lookTarget = new THREE.Vector3(),
        _lightPositionWorld = new THREE.Vector3(),

        _renderList = [],

        _MorphingFlag = 1,
        _SkinningFlag = 2,

        _NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,

        _depthMaterials = new Array( _NumberOfMaterialVariants ),
        _distanceMaterials = new Array( _NumberOfMaterialVariants );

    var cubeDirections = [
        new THREE.Vector3( 1, 0, 0 ), new THREE.Vector3( - 1, 0, 0 ), new THREE.Vector3( 0, 0, 1 ),
        new THREE.Vector3( 0, 0, - 1 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, - 1, 0 )
    ];

    var cubeUps = [
        new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ),
        new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, 1 ),	new THREE.Vector3( 0, 0, - 1 )
    ];

    var cube2DViewPorts = [
        new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(),
        new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()
    ];

    var _vector4 = new THREE.Vector4();

    // init

    var depthShader = THREE.ShaderLib[ "depthRGBA" ];
    var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

    var distanceShader = THREE.ShaderLib[ "distanceRGBA" ];
    var distanceUniforms = THREE.UniformsUtils.clone( distanceShader.uniforms );

    for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {

        var useMorphing = ( i & _MorphingFlag ) !== 0;
        var useSkinning = ( i & _SkinningFlag ) !== 0;

        var depthMaterial = new THREE.ShaderMaterial( {
            uniforms: depthUniforms,
            vertexShader: depthShader.vertexShader,
            fragmentShader: depthShader.fragmentShader,
            morphTargets: useMorphing,
            skinning: useSkinning
        } );

        depthMaterial._shadowPass = true;

        _depthMaterials[ i ] = depthMaterial;

        var distanceMaterial = new THREE.ShaderMaterial( {
            uniforms: distanceUniforms,
            vertexShader: distanceShader.vertexShader,
            fragmentShader: distanceShader.fragmentShader,
            morphTargets: useMorphing,
            skinning: useSkinning
        } );

        distanceMaterial._shadowPass = true;

        _distanceMaterials[ i ] = distanceMaterial;

    }

    //

    var scope = this;

    this.enabled = false;

    this.autoUpdate = true;
    this.needsUpdate = false;

    this.type = THREE.PCFShadowMap;
    this.cullFace = THREE.CullFaceFront;

    this.render = function ( scene ) {

        var faceCount, isPointLight;

        if ( scope.enabled === false ) return;
        if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

        // Set GL state for depth map.
        _gl.clearColor( 1, 1, 1, 1 );
        _state.disable( _gl.BLEND );
        _state.enable( _gl.CULL_FACE );
        _gl.frontFace( _gl.CCW );
        _gl.cullFace( scope.cullFace === THREE.CullFaceFront ? _gl.FRONT : _gl.BACK );
        _state.setDepthTest( true );

        // save the existing viewport so it can be restored later
        _renderer.getViewport( _vector4 );

        // render depth map

        for ( var i = 0, il = _lights.length; i < il; i ++ ) {

            var light = _lights[ i ];

            if ( light.castShadow === true ) {

                var shadow = light.shadow;
                var shadowCamera = shadow.camera;
                var shadowMapSize = shadow.mapSize;

                if ( light instanceof THREE.PointLight ) {

                    faceCount = 6;
                    isPointLight = true;

                    var vpWidth = shadowMapSize.x / 4.0;
                    var vpHeight = shadowMapSize.y / 2.0;

                    // These viewports map a cube-map onto a 2D texture with the
                    // following orientation:
                    //
                    //  xzXZ
                    //   y Y
                    //
                    // X - Positive x direction
                    // x - Negative x direction
                    // Y - Positive y direction
                    // y - Negative y direction
                    // Z - Positive z direction
                    // z - Negative z direction

                    // positive X
                    cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
                    // negative X
                    cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
                    // positive Z
                    cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
                    // negative Z
                    cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
                    // positive Y
                    cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
                    // negative Y
                    cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );

                } else {

                    faceCount = 1;
                    isPointLight = false;

                }

                if ( shadow.map === null ) {

                    var shadowFilter = THREE.LinearFilter;

                    if ( scope.type === THREE.PCFSoftShadowMap ) {

                        shadowFilter = THREE.NearestFilter;

                    }

                    var pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };

                    shadow.map = new THREE.WebGLRenderTarget( shadowMapSize.x, shadowMapSize.y, pars );
                    shadow.matrix = new THREE.Matrix4();

                    //

                    if ( light instanceof THREE.SpotLight ) {

                        shadowCamera.aspect = shadowMapSize.x / shadowMapSize.y;

                    }

                    shadowCamera.updateProjectionMatrix();

                }

                var shadowMap = shadow.map;
                var shadowMatrix = shadow.matrix;

                _lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
                shadowCamera.position.copy( _lightPositionWorld );

                _renderer.setRenderTarget( shadowMap );
                _renderer.clear();

                // render shadow map for each cube face (if omni-directional) or
                // run a single pass if not

                for ( var face = 0; face < faceCount; face ++ ) {

                    if ( isPointLight ) {

                        _lookTarget.copy( shadowCamera.position );
                        _lookTarget.add( cubeDirections[ face ] );
                        shadowCamera.up.copy( cubeUps[ face ] );
                        shadowCamera.lookAt( _lookTarget );
                        var vpDimensions = cube2DViewPorts[ face ];
                        _renderer.setViewport( vpDimensions.x, vpDimensions.y, vpDimensions.z, vpDimensions.w );

                    } else {

                        _lookTarget.setFromMatrixPosition( light.target.matrixWorld );
                        shadowCamera.lookAt( _lookTarget );

                    }

                    shadowCamera.updateMatrixWorld();
                    shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

                    // compute shadow matrix

                    shadowMatrix.set(
                        0.5, 0.0, 0.0, 0.5,
                        0.0, 0.5, 0.0, 0.5,
                        0.0, 0.0, 0.5, 0.5,
                        0.0, 0.0, 0.0, 1.0
                    );

                    shadowMatrix.multiply( shadowCamera.projectionMatrix );
                    shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

                    // update camera matrices and frustum

                    _projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
                    _frustum.setFromMatrix( _projScreenMatrix );

                    // set object matrices & frustum culling

                    _renderList.length = 0;

                    projectObject( scene, shadowCamera );

                    // render shadow map
                    // render regular objects

                    for ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {

                        var object = _renderList[ j ];
                        var geometry = _objects.update( object );
                        var material = object.material;

                        if ( material instanceof THREE.MeshFaceMaterial ) {

                            var groups = geometry.groups;
                            var materials = material.materials;

                            for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

                                var group = groups[ k ];
                                var groupMaterial = materials[ group.materialIndex ];

                                if ( groupMaterial.visible === true ) {

                                    var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );
                                    _renderer.renderBufferDirect( shadowCamera, _lights, null, geometry, depthMaterial, object, group );

                                }

                            }

                        } else {

                            var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );
                            _renderer.renderBufferDirect( shadowCamera, _lights, null, geometry, depthMaterial, object, null );

                        }

                    }

                }

                // We must call _renderer.resetGLState() at the end of each iteration of
                // the light loop in order to force material updates for each light.
                _renderer.resetGLState();

            }

        }

        _renderer.setViewport( _vector4.x, _vector4.y, _vector4.z, _vector4.w );

        // Restore GL state.
        var clearColor = _renderer.getClearColor(),
            clearAlpha = _renderer.getClearAlpha();
        _renderer.setClearColor( clearColor, clearAlpha );
        _state.enable( _gl.BLEND );

        if ( scope.cullFace === THREE.CullFaceFront ) {

            _gl.cullFace( _gl.BACK );

        }

        _renderer.resetGLState();

        scope.needsUpdate = false;

    };

    function getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {

        var geometry = object.geometry;

        var newMaterial = null;

        var materialVariants = _depthMaterials;
        var customMaterial = object.customDepthMaterial;

        if ( isPointLight ) {

            materialVariants = _distanceMaterials;
            customMaterial = object.customDistanceMaterial;

        }

        if ( ! customMaterial ) {

            var useMorphing = geometry.morphTargets !== undefined &&
                geometry.morphTargets.length > 0 && material.morphTargets;

            var useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;

            var variantIndex = 0;

            if ( useMorphing ) variantIndex |= _MorphingFlag;
            if ( useSkinning ) variantIndex |= _SkinningFlag;

            newMaterial = materialVariants[ variantIndex ];

        } else {

            newMaterial = customMaterial;

        }

        newMaterial.visible = material.visible;
        newMaterial.wireframe = material.wireframe;
        newMaterial.wireframeLinewidth = material.wireframeLinewidth;

        if ( isPointLight && newMaterial.uniforms.lightPos !== undefined ) {

            newMaterial.uniforms.lightPos.value.copy( lightPositionWorld );

        }

        return newMaterial;

    }

    function projectObject( object, camera ) {

        if ( object.visible === false ) return;

        if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {

            if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

                var material = object.material;

                if ( material.visible === true ) {

                    object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
                    _renderList.push( object );

                }

            }

        }

        var children = object.children;

        for ( var i = 0, l = children.length; i < l; i ++ ) {

            projectObject( children[ i ], camera );

        }

    }

};

// File:src/renderers/webgl/WebGLState.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLState = function ( gl, extensions, paramThreeToGL ) {

    var _this = this;

    var newAttributes = new Uint8Array( 16 );
    var enabledAttributes = new Uint8Array( 16 );
    var attributeDivisors = new Uint8Array( 16 );

    var capabilities = {};

    var compressedTextureFormats = null;

    var currentBlending = null;
    var currentBlendEquation = null;
    var currentBlendSrc = null;
    var currentBlendDst = null;
    var currentBlendEquationAlpha = null;
    var currentBlendSrcAlpha = null;
    var currentBlendDstAlpha = null;

    var currentDepthFunc = null;
    var currentDepthWrite = null;

    var currentColorWrite = null;

    var currentFlipSided = null;

    var currentLineWidth = null;

    var currentPolygonOffsetFactor = null;
    var currentPolygonOffsetUnits = null;

    var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );

    var currentTextureSlot = undefined;
    var currentBoundTextures = {};

    this.init = function () {

        gl.clearColor( 0, 0, 0, 1 );
        gl.clearDepth( 1 );
        gl.clearStencil( 0 );

        this.enable( gl.DEPTH_TEST );
        gl.depthFunc( gl.LEQUAL );

        gl.frontFace( gl.CCW );
        gl.cullFace( gl.BACK );
        this.enable( gl.CULL_FACE );

        this.enable( gl.BLEND );
        gl.blendEquation( gl.FUNC_ADD );
        gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );

    };

    this.initAttributes = function () {

        for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

            newAttributes[ i ] = 0;

        }

    };

    this.enableAttribute = function ( attribute ) {

        newAttributes[ attribute ] = 1;

        if ( enabledAttributes[ attribute ] === 0 ) {

            gl.enableVertexAttribArray( attribute );
            enabledAttributes[ attribute ] = 1;

        }

        if ( attributeDivisors[ attribute ] !== 0 ) {

            var extension = extensions.get( 'ANGLE_instanced_arrays' );

            extension.vertexAttribDivisorANGLE( attribute, 0 );
            attributeDivisors[ attribute ] = 0;

        }

    };

    this.enableAttributeAndDivisor = function ( attribute, meshPerAttribute, extension ) {

        newAttributes[ attribute ] = 1;

        if ( enabledAttributes[ attribute ] === 0 ) {

            gl.enableVertexAttribArray( attribute );
            enabledAttributes[ attribute ] = 1;

        }

        if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

            extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
            attributeDivisors[ attribute ] = meshPerAttribute;

        }

    };

    this.disableUnusedAttributes = function () {

        for ( var i = 0, l = enabledAttributes.length; i < l; i ++ ) {

            if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

                gl.disableVertexAttribArray( i );
                enabledAttributes[ i ] = 0;

            }

        }

    };

    this.enable = function ( id ) {

        if ( capabilities[ id ] !== true ) {

            gl.enable( id );
            capabilities[ id ] = true;

        }

    };

    this.disable = function ( id ) {

        if ( capabilities[ id ] !== false ) {

            gl.disable( id );
            capabilities[ id ] = false;

        }

    };

    this.getCompressedTextureFormats = function () {

        if ( compressedTextureFormats === null ) {

            compressedTextureFormats = [];

            if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
                extensions.get( 'WEBGL_compressed_texture_s3tc' ) ) {

                var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

                for ( var i = 0; i < formats.length; i ++ ) {

                    compressedTextureFormats.push( formats[ i ] );

                }

            }

        }

        return compressedTextureFormats;

    };

    this.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha ) {

        if ( blending !== currentBlending ) {

            if ( blending === THREE.NoBlending ) {

                this.disable( gl.BLEND );

            } else if ( blending === THREE.AdditiveBlending ) {

                this.enable( gl.BLEND );
                gl.blendEquation( gl.FUNC_ADD );
                gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

            } else if ( blending === THREE.SubtractiveBlending ) {

                // TODO: Find blendFuncSeparate() combination

                this.enable( gl.BLEND );
                gl.blendEquation( gl.FUNC_ADD );
                gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

            } else if ( blending === THREE.MultiplyBlending ) {

                // TODO: Find blendFuncSeparate() combination

                this.enable( gl.BLEND );
                gl.blendEquation( gl.FUNC_ADD );
                gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

            } else if ( blending === THREE.CustomBlending ) {

                this.enable( gl.BLEND );

            } else {

                this.enable( gl.BLEND );
                gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
                gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

            }

            currentBlending = blending;

        }

        if ( blending === THREE.CustomBlending ) {

            blendEquationAlpha = blendEquationAlpha || blendEquation;
            blendSrcAlpha = blendSrcAlpha || blendSrc;
            blendDstAlpha = blendDstAlpha || blendDst;

            if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

                gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );

                currentBlendEquation = blendEquation;
                currentBlendEquationAlpha = blendEquationAlpha;

            }

            if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

                gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );

                currentBlendSrc = blendSrc;
                currentBlendDst = blendDst;
                currentBlendSrcAlpha = blendSrcAlpha;
                currentBlendDstAlpha = blendDstAlpha;

            }

        } else {

            currentBlendEquation = null;
            currentBlendSrc = null;
            currentBlendDst = null;
            currentBlendEquationAlpha = null;
            currentBlendSrcAlpha = null;
            currentBlendDstAlpha = null;

        }

    };

    this.setDepthFunc = function ( depthFunc ) {

        if ( currentDepthFunc !== depthFunc ) {

            if ( depthFunc ) {

                switch ( depthFunc ) {

                    case THREE.NeverDepth:

                        gl.depthFunc( gl.NEVER );
                        break;

                    case THREE.AlwaysDepth:

                        gl.depthFunc( gl.ALWAYS );
                        break;

                    case THREE.LessDepth:

                        gl.depthFunc( gl.LESS );
                        break;

                    case THREE.LessEqualDepth:

                        gl.depthFunc( gl.LEQUAL );
                        break;

                    case THREE.EqualDepth:

                        gl.depthFunc( gl.EQUAL );
                        break;

                    case THREE.GreaterEqualDepth:

                        gl.depthFunc( gl.GEQUAL );
                        break;

                    case THREE.GreaterDepth:

                        gl.depthFunc( gl.GREATER );
                        break;

                    case THREE.NotEqualDepth:

                        gl.depthFunc( gl.NOTEQUAL );
                        break;

                    default:

                        gl.depthFunc( gl.LEQUAL );

                }

            } else {

                gl.depthFunc( gl.LEQUAL );

            }

            currentDepthFunc = depthFunc;

        }

    };

    this.setDepthTest = function ( depthTest ) {

        if ( depthTest ) {

            this.enable( gl.DEPTH_TEST );

        } else {

            this.disable( gl.DEPTH_TEST );

        }

    };

    this.setDepthWrite = function ( depthWrite ) {

        if ( currentDepthWrite !== depthWrite ) {

            gl.depthMask( depthWrite );
            currentDepthWrite = depthWrite;

        }

    };

    this.setColorWrite = function ( colorWrite ) {

        if ( currentColorWrite !== colorWrite ) {

            gl.colorMask( colorWrite, colorWrite, colorWrite, colorWrite );
            currentColorWrite = colorWrite;

        }

    };

    this.setFlipSided = function ( flipSided ) {

        if ( currentFlipSided !== flipSided ) {

            if ( flipSided ) {

                gl.frontFace( gl.CW );

            } else {

                gl.frontFace( gl.CCW );

            }

            currentFlipSided = flipSided;

        }

    };

    this.setLineWidth = function ( width ) {

        if ( width !== currentLineWidth ) {

            gl.lineWidth( width );

            currentLineWidth = width;

        }

    };

    this.setPolygonOffset = function ( polygonOffset, factor, units ) {

        if ( polygonOffset ) {

            this.enable( gl.POLYGON_OFFSET_FILL );

        } else {

            this.disable( gl.POLYGON_OFFSET_FILL );

        }

        if ( polygonOffset && ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) ) {

            gl.polygonOffset( factor, units );

            currentPolygonOffsetFactor = factor;
            currentPolygonOffsetUnits = units;

        }

    };

    this.setScissorTest = function ( scissorTest ) {

        if ( scissorTest ) {

            this.enable( gl.SCISSOR_TEST );

        } else {

            this.disable( gl.SCISSOR_TEST );

        }

    };

    // texture

    this.activeTexture = function ( webglSlot ) {

        if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

        if ( currentTextureSlot !== webglSlot ) {

            gl.activeTexture( webglSlot );
            currentTextureSlot = webglSlot;

        }

    }

    this.bindTexture = function ( webglType, webglTexture ) {

        if ( currentTextureSlot === undefined ) {

            _this.activeTexture();

        }

        var boundTexture = currentBoundTextures[ currentTextureSlot ];

        if ( boundTexture === undefined ) {

            boundTexture = { type: undefined, texture: undefined };
            currentBoundTextures[ currentTextureSlot ] = boundTexture;

        }

        if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

            gl.bindTexture( webglType, webglTexture );

            boundTexture.type = webglType;
            boundTexture.texture = webglTexture;

        }

    };

    this.compressedTexImage2D = function () {

        try {

            gl.compressedTexImage2D.apply( gl, arguments );

        } catch ( error ) {

            console.error( error );

        }

    };

    this.texImage2D = function () {

        try {

            gl.texImage2D.apply( gl, arguments );

        } catch ( error ) {

            console.error( error );

        }

    };

    //

    this.reset = function () {

        for ( var i = 0; i < enabledAttributes.length; i ++ ) {

            if ( enabledAttributes[ i ] === 1 ) {

                gl.disableVertexAttribArray( i );
                enabledAttributes[ i ] = 0;

            }

        }

        capabilities = {};

        compressedTextureFormats = null;

        currentBlending = null;

        currentDepthWrite = null;
        currentColorWrite = null;

        currentFlipSided = null;

    };

};

// File:src/renderers/webgl/plugins/LensFlarePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlarePlugin = function ( renderer, flares ) {

    var gl = renderer.context;
    var state = renderer.state;

    var vertexBuffer, elementBuffer;
    var program, attributes, uniforms;
    var hasVertexTexture;

    var tempTexture, occlusionTexture;

    function init() {

        var vertices = new Float32Array( [
            - 1, - 1,  0, 0,
            1, - 1,  1, 0,
            1,  1,  1, 1,
            - 1,  1,  0, 1
        ] );

        var faces = new Uint16Array( [
            0, 1, 2,
            0, 2, 3
        ] );

        // buffers

        vertexBuffer     = gl.createBuffer();
        elementBuffer    = gl.createBuffer();

        gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
        gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

        gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
        gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

        // textures

        tempTexture      = gl.createTexture();
        occlusionTexture = gl.createTexture();

        state.bindTexture( gl.TEXTURE_2D, tempTexture );
        gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

        state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
        gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

        hasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;

        var shader;

        if ( hasVertexTexture ) {

            shader = {

                vertexShader: [

                    "uniform lowp int renderType;",

                    "uniform vec3 screenPosition;",
                    "uniform vec2 scale;",
                    "uniform float rotation;",

                    "uniform sampler2D occlusionMap;",

                    "attribute vec2 position;",
                    "attribute vec2 uv;",

                    "varying vec2 vUV;",
                    "varying float vVisibility;",

                    "void main() {",

                    "vUV = uv;",

                    "vec2 pos = position;",

                    "if ( renderType == 2 ) {",

                    "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

                    "vVisibility =        visibility.r / 9.0;",
                    "vVisibility *= 1.0 - visibility.g / 9.0;",
                    "vVisibility *=       visibility.b / 9.0;",
                    "vVisibility *= 1.0 - visibility.a / 9.0;",

                    "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
                    "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

                    "}",

                    "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

                    "}"

                ].join( "\n" ),

                fragmentShader: [

                    "uniform lowp int renderType;",

                    "uniform sampler2D map;",
                    "uniform float opacity;",
                    "uniform vec3 color;",

                    "varying vec2 vUV;",
                    "varying float vVisibility;",

                    "void main() {",

                    // pink square

                    "if ( renderType == 0 ) {",

                    "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

                    // restore

                    "} else if ( renderType == 1 ) {",

                    "gl_FragColor = texture2D( map, vUV );",

                    // flare

                    "} else {",

                    "vec4 texture = texture2D( map, vUV );",
                    "texture.a *= opacity * vVisibility;",
                    "gl_FragColor = texture;",
                    "gl_FragColor.rgb *= color;",

                    "}",

                    "}"

                ].join( "\n" )

            };

        } else {

            shader = {

                vertexShader: [

                    "uniform lowp int renderType;",

                    "uniform vec3 screenPosition;",
                    "uniform vec2 scale;",
                    "uniform float rotation;",

                    "attribute vec2 position;",
                    "attribute vec2 uv;",

                    "varying vec2 vUV;",

                    "void main() {",

                    "vUV = uv;",

                    "vec2 pos = position;",

                    "if ( renderType == 2 ) {",

                    "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
                    "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

                    "}",

                    "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

                    "}"

                ].join( "\n" ),

                fragmentShader: [

                    "precision mediump float;",

                    "uniform lowp int renderType;",

                    "uniform sampler2D map;",
                    "uniform sampler2D occlusionMap;",
                    "uniform float opacity;",
                    "uniform vec3 color;",

                    "varying vec2 vUV;",

                    "void main() {",

                    // pink square

                    "if ( renderType == 0 ) {",

                    "gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",

                    // restore

                    "} else if ( renderType == 1 ) {",

                    "gl_FragColor = texture2D( map, vUV );",

                    // flare

                    "} else {",

                    "float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
                    "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
                    "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
                    "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
                    "visibility = ( 1.0 - visibility / 4.0 );",

                    "vec4 texture = texture2D( map, vUV );",
                    "texture.a *= opacity * visibility;",
                    "gl_FragColor = texture;",
                    "gl_FragColor.rgb *= color;",

                    "}",

                    "}"

                ].join( "\n" )

            };

        }

        program = createProgram( shader );

        attributes = {
            vertex: gl.getAttribLocation ( program, "position" ),
            uv:     gl.getAttribLocation ( program, "uv" )
        };

        uniforms = {
            renderType:     gl.getUniformLocation( program, "renderType" ),
            map:            gl.getUniformLocation( program, "map" ),
            occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
            opacity:        gl.getUniformLocation( program, "opacity" ),
            color:          gl.getUniformLocation( program, "color" ),
            scale:          gl.getUniformLocation( program, "scale" ),
            rotation:       gl.getUniformLocation( program, "rotation" ),
            screenPosition: gl.getUniformLocation( program, "screenPosition" )
        };

    }

    /*
     * Render lens flares
     * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
     *         reads these back and calculates occlusion.
     */

    this.render = function ( scene, camera, viewportWidth, viewportHeight ) {

        if ( flares.length === 0 ) return;

        var tempPosition = new THREE.Vector3();

        var invAspect = viewportHeight / viewportWidth,
            halfViewportWidth = viewportWidth * 0.5,
            halfViewportHeight = viewportHeight * 0.5;

        var size = 16 / viewportHeight,
            scale = new THREE.Vector2( size * invAspect, size );

        var screenPosition = new THREE.Vector3( 1, 1, 0 ),
            screenPositionPixels = new THREE.Vector2( 1, 1 );

        if ( program === undefined ) {

            init();

        }

        gl.useProgram( program );

        state.initAttributes();
        state.enableAttribute( attributes.vertex );
        state.enableAttribute( attributes.uv );
        state.disableUnusedAttributes();

        // loop through all lens flares to update their occlusion and positions
        // setup gl and common used attribs/uniforms

        gl.uniform1i( uniforms.occlusionMap, 0 );
        gl.uniform1i( uniforms.map, 1 );

        gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
        gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
        gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

        gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

        state.disable( gl.CULL_FACE );
        gl.depthMask( false );

        for ( var i = 0, l = flares.length; i < l; i ++ ) {

            size = 16 / viewportHeight;
            scale.set( size * invAspect, size );

            // calc object screen position

            var flare = flares[ i ];

            tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );

            tempPosition.applyMatrix4( camera.matrixWorldInverse );
            tempPosition.applyProjection( camera.projectionMatrix );

            // setup arrays for gl programs

            screenPosition.copy( tempPosition );

            screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
            screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;

            // screen cull

            if ( hasVertexTexture || (
                screenPositionPixels.x > 0 &&
                screenPositionPixels.x < viewportWidth &&
                screenPositionPixels.y > 0 &&
                screenPositionPixels.y < viewportHeight ) ) {

                // save current RGB to temp texture

                state.activeTexture( gl.TEXTURE0 );
                state.bindTexture( gl.TEXTURE_2D, null );
                state.activeTexture( gl.TEXTURE1 );
                state.bindTexture( gl.TEXTURE_2D, tempTexture );
                gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


                // render pink quad

                gl.uniform1i( uniforms.renderType, 0 );
                gl.uniform2f( uniforms.scale, scale.x, scale.y );
                gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

                state.disable( gl.BLEND );
                state.enable( gl.DEPTH_TEST );

                gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


                // copy result to occlusionMap

                state.activeTexture( gl.TEXTURE0 );
                state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
                gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


                // restore graphics

                gl.uniform1i( uniforms.renderType, 1 );
                state.disable( gl.DEPTH_TEST );

                state.activeTexture( gl.TEXTURE1 );
                state.bindTexture( gl.TEXTURE_2D, tempTexture );
                gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


                // update object positions

                flare.positionScreen.copy( screenPosition );

                if ( flare.customUpdateCallback ) {

                    flare.customUpdateCallback( flare );

                } else {

                    flare.updateLensFlares();

                }

                // render flares

                gl.uniform1i( uniforms.renderType, 2 );
                state.enable( gl.BLEND );

                for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

                    var sprite = flare.lensFlares[ j ];

                    if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

                        screenPosition.x = sprite.x;
                        screenPosition.y = sprite.y;
                        screenPosition.z = sprite.z;

                        size = sprite.size * sprite.scale / viewportHeight;

                        scale.x = size * invAspect;
                        scale.y = size;

                        gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
                        gl.uniform2f( uniforms.scale, scale.x, scale.y );
                        gl.uniform1f( uniforms.rotation, sprite.rotation );

                        gl.uniform1f( uniforms.opacity, sprite.opacity );
                        gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

                        state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
                        renderer.setTexture( sprite.texture, 1 );

                        gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

                    }

                }

            }

        }

        // restore gl

        state.enable( gl.CULL_FACE );
        state.enable( gl.DEPTH_TEST );
        gl.depthMask( true );

        renderer.resetGLState();

    };

    function createProgram ( shader ) {

        var program = gl.createProgram();

        var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
        var vertexShader = gl.createShader( gl.VERTEX_SHADER );

        var prefix = "precision " + renderer.getPrecision() + " float;\n";

        gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
        gl.shaderSource( vertexShader, prefix + shader.vertexShader );

        gl.compileShader( fragmentShader );
        gl.compileShader( vertexShader );

        gl.attachShader( program, fragmentShader );
        gl.attachShader( program, vertexShader );

        gl.linkProgram( program );

        return program;

    }

};

// File:src/renderers/webgl/plugins/SpritePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpritePlugin = function ( renderer, sprites ) {

    var gl = renderer.context;
    var state = renderer.state;

    var vertexBuffer, elementBuffer;
    var program, attributes, uniforms;

    var texture;

    // decompose matrixWorld

    var spritePosition = new THREE.Vector3();
    var spriteRotation = new THREE.Quaternion();
    var spriteScale = new THREE.Vector3();

    function init() {

        var vertices = new Float32Array( [
            - 0.5, - 0.5,  0, 0,
            0.5, - 0.5,  1, 0,
            0.5,   0.5,  1, 1,
            - 0.5,   0.5,  0, 1
        ] );

        var faces = new Uint16Array( [
            0, 1, 2,
            0, 2, 3
        ] );

        vertexBuffer  = gl.createBuffer();
        elementBuffer = gl.createBuffer();

        gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
        gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

        gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
        gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

        program = createProgram();

        attributes = {
            position:			gl.getAttribLocation ( program, 'position' ),
            uv:					gl.getAttribLocation ( program, 'uv' )
        };

        uniforms = {
            uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
            uvScale:			gl.getUniformLocation( program, 'uvScale' ),

            rotation:			gl.getUniformLocation( program, 'rotation' ),
            scale:				gl.getUniformLocation( program, 'scale' ),

            color:				gl.getUniformLocation( program, 'color' ),
            map:				gl.getUniformLocation( program, 'map' ),
            opacity:			gl.getUniformLocation( program, 'opacity' ),

            modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
            projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),

            fogType:			gl.getUniformLocation( program, 'fogType' ),
            fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
            fogNear:			gl.getUniformLocation( program, 'fogNear' ),
            fogFar:				gl.getUniformLocation( program, 'fogFar' ),
            fogColor:			gl.getUniformLocation( program, 'fogColor' ),

            alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
        };

        var canvas = document.createElement( 'canvas' );
        canvas.width = 8;
        canvas.height = 8;

        var context = canvas.getContext( '2d' );
        context.fillStyle = 'white';
        context.fillRect( 0, 0, 8, 8 );

        texture = new THREE.Texture( canvas );
        texture.needsUpdate = true;

    }

    this.render = function ( scene, camera ) {

        if ( sprites.length === 0 ) return;

        // setup gl

        if ( program === undefined ) {

            init();

        }

        gl.useProgram( program );

        state.initAttributes();
        state.enableAttribute( attributes.position );
        state.enableAttribute( attributes.uv );
        state.disableUnusedAttributes();

        state.disable( gl.CULL_FACE );
        state.enable( gl.BLEND );

        gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
        gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
        gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

        gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

        gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

        state.activeTexture( gl.TEXTURE0 );
        gl.uniform1i( uniforms.map, 0 );

        var oldFogType = 0;
        var sceneFogType = 0;
        var fog = scene.fog;

        if ( fog ) {

            gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

            if ( fog instanceof THREE.Fog ) {

                gl.uniform1f( uniforms.fogNear, fog.near );
                gl.uniform1f( uniforms.fogFar, fog.far );

                gl.uniform1i( uniforms.fogType, 1 );
                oldFogType = 1;
                sceneFogType = 1;

            } else if ( fog instanceof THREE.FogExp2 ) {

                gl.uniform1f( uniforms.fogDensity, fog.density );

                gl.uniform1i( uniforms.fogType, 2 );
                oldFogType = 2;
                sceneFogType = 2;

            }

        } else {

            gl.uniform1i( uniforms.fogType, 0 );
            oldFogType = 0;
            sceneFogType = 0;

        }


        // update positions and sort

        for ( var i = 0, l = sprites.length; i < l; i ++ ) {

            var sprite = sprites[ i ];

            sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
            sprite.z = - sprite.modelViewMatrix.elements[ 14 ];

        }

        sprites.sort( painterSortStable );

        // render all sprites

        var scale = [];

        for ( var i = 0, l = sprites.length; i < l; i ++ ) {

            var sprite = sprites[ i ];
            var material = sprite.material;

            gl.uniform1f( uniforms.alphaTest, material.alphaTest );
            gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );

            sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

            scale[ 0 ] = spriteScale.x;
            scale[ 1 ] = spriteScale.y;

            var fogType = 0;

            if ( scene.fog && material.fog ) {

                fogType = sceneFogType;

            }

            if ( oldFogType !== fogType ) {

                gl.uniform1i( uniforms.fogType, fogType );
                oldFogType = fogType;

            }

            if ( material.map !== null ) {

                gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
                gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

            } else {

                gl.uniform2f( uniforms.uvOffset, 0, 0 );
                gl.uniform2f( uniforms.uvScale, 1, 1 );

            }

            gl.uniform1f( uniforms.opacity, material.opacity );
            gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

            gl.uniform1f( uniforms.rotation, material.rotation );
            gl.uniform2fv( uniforms.scale, scale );

            state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
            state.setDepthTest( material.depthTest );
            state.setDepthWrite( material.depthWrite );

            if ( material.map && material.map.image && material.map.image.width ) {

                renderer.setTexture( material.map, 0 );

            } else {

                renderer.setTexture( texture, 0 );

            }

            gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

        }

        // restore gl

        state.enable( gl.CULL_FACE );

        renderer.resetGLState();

    };

    function createProgram () {

        var program = gl.createProgram();

        var vertexShader = gl.createShader( gl.VERTEX_SHADER );
        var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

        gl.shaderSource( vertexShader, [

            'precision ' + renderer.getPrecision() + ' float;',

            'uniform mat4 modelViewMatrix;',
            'uniform mat4 projectionMatrix;',
            'uniform float rotation;',
            'uniform vec2 scale;',
            'uniform vec2 uvOffset;',
            'uniform vec2 uvScale;',

            'attribute vec2 position;',
            'attribute vec2 uv;',

            'varying vec2 vUV;',

            'void main() {',

            'vUV = uvOffset + uv * uvScale;',

            'vec2 alignedPosition = position * scale;',

            'vec2 rotatedPosition;',
            'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
            'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

            'vec4 finalPosition;',

            'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
            'finalPosition.xy += rotatedPosition;',
            'finalPosition = projectionMatrix * finalPosition;',

            'gl_Position = finalPosition;',

            '}'

        ].join( '\n' ) );

        gl.shaderSource( fragmentShader, [

            'precision ' + renderer.getPrecision() + ' float;',

            'uniform vec3 color;',
            'uniform sampler2D map;',
            'uniform float opacity;',

            'uniform int fogType;',
            'uniform vec3 fogColor;',
            'uniform float fogDensity;',
            'uniform float fogNear;',
            'uniform float fogFar;',
            'uniform float alphaTest;',

            'varying vec2 vUV;',

            'void main() {',

            'vec4 texture = texture2D( map, vUV );',

            'if ( texture.a < alphaTest ) discard;',

            'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

            'if ( fogType > 0 ) {',

            'float depth = gl_FragCoord.z / gl_FragCoord.w;',
            'float fogFactor = 0.0;',

            'if ( fogType == 1 ) {',

            'fogFactor = smoothstep( fogNear, fogFar, depth );',

            '} else {',

            'const float LOG2 = 1.442695;',
            'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
            'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

            '}',

            'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

            '}',

            '}'

        ].join( '\n' ) );

        gl.compileShader( vertexShader );
        gl.compileShader( fragmentShader );

        gl.attachShader( program, vertexShader );
        gl.attachShader( program, fragmentShader );

        gl.linkProgram( program );

        return program;

    }

    function painterSortStable ( a, b ) {

        if ( a.z !== b.z ) {

            return b.z - a.z;

        } else {

            return b.id - a.id;

        }

    }

};

// File:src/extras/CurveUtils.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.CurveUtils = {

    tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

        return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

    },

    // Puay Bing, thanks for helping with this derivative!

    tangentCubicBezier: function ( t, p0, p1, p2, p3 ) {

        return - 3 * p0 * ( 1 - t ) * ( 1 - t )  +
            3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +
            6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +
            3 * t * t * p3;

    },

    tangentSpline: function ( t, p0, p1, p2, p3 ) {

        // To check if my formulas are correct

        var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3 ? 3t^2 + 1
        var h10 = 3 * t * t - 4 * t + 1; // t^3 ? 2t^2 + t
        var h01 = - 6 * t * t + 6 * t; 	// ? 2t3 + 3t2
        var h11 = 3 * t * t - 2 * t;	// t3 ? t2

        return h00 + h10 + h01 + h11;

    },

    // Catmull-Rom

    interpolate: function( p0, p1, p2, p3, t ) {

        var v0 = ( p2 - p0 ) * 0.5;
        var v1 = ( p3 - p1 ) * 0.5;
        var t2 = t * t;
        var t3 = t * t2;
        return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

    }

};

// File:src/extras/GeometryUtils.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GeometryUtils = {

    merge: function ( geometry1, geometry2, materialIndexOffset ) {

        console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );

        var matrix;

        if ( geometry2 instanceof THREE.Mesh ) {

            geometry2.matrixAutoUpdate && geometry2.updateMatrix();

            matrix = geometry2.matrix;
            geometry2 = geometry2.geometry;

        }

        geometry1.merge( geometry2, matrix, materialIndexOffset );

    },

    center: function ( geometry ) {

        console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
        return geometry.center();

    }

};

// File:src/extras/ImageUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author Daosheng Mu / https://github.com/DaoshengMu/
 */

THREE.ImageUtils = {

    crossOrigin: undefined,

    loadTexture: function ( url, mapping, onLoad, onError ) {

        console.warn( 'THREE.ImageUtils.loadTexture is being deprecated. Use THREE.TextureLoader() instead.' );

        var loader = new THREE.TextureLoader();
        loader.setCrossOrigin( this.crossOrigin );

        var texture = loader.load( url, onLoad, undefined, onError );

        if ( mapping ) texture.mapping = mapping;

        return texture;

    },

    loadTextureCube: function ( urls, mapping, onLoad, onError ) {

        console.warn( 'THREE.ImageUtils.loadTextureCube is being deprecated. Use THREE.CubeTextureLoader() instead.' );

        var loader = new THREE.CubeTextureLoader();
        loader.setCrossOrigin( this.crossOrigin );

        var texture = loader.load( urls, onLoad, undefined, onError );

        if ( mapping ) texture.mapping = mapping;

        return texture;

    },

    loadCompressedTexture: function () {

        console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' )

    },

    loadCompressedTextureCube: function () {

        console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' )

    }

};

// File:src/extras/SceneUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SceneUtils = {

    createMultiMaterialObject: function ( geometry, materials ) {

        var group = new THREE.Group();

        for ( var i = 0, l = materials.length; i < l; i ++ ) {

            group.add( new THREE.Mesh( geometry, materials[ i ] ) );

        }

        return group;

    },

    detach: function ( child, parent, scene ) {

        child.applyMatrix( parent.matrixWorld );
        parent.remove( child );
        scene.add( child );

    },

    attach: function ( child, scene, parent ) {

        var matrixWorldInverse = new THREE.Matrix4();
        matrixWorldInverse.getInverse( parent.matrixWorld );
        child.applyMatrix( matrixWorldInverse );

        scene.remove( child );
        parent.add( child );

    }

};

// File:src/extras/ShapeUtils.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.ShapeUtils = {

    // calculate area of the contour polygon

    area: function ( contour ) {

        var n = contour.length;
        var a = 0.0;

        for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

            a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

        }

        return a * 0.5;

    },

    triangulate: ( function () {

        /**
         * This code is a quick port of code written in C++ which was submitted to
         * flipcode.com by John W. Ratcliff  // July 22, 2000
         * See original code and more information here:
         * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
         *
         * ported to actionscript by Zevan Rosser
         * www.actionsnippet.com
         *
         * ported to javascript by Joshua Koo
         * http://www.lab4games.net/zz85/blog
         *
         */

        function snip( contour, u, v, w, n, verts ) {

            var p;
            var ax, ay, bx, by;
            var cx, cy, px, py;

            ax = contour[ verts[ u ] ].x;
            ay = contour[ verts[ u ] ].y;

            bx = contour[ verts[ v ] ].x;
            by = contour[ verts[ v ] ].y;

            cx = contour[ verts[ w ] ].x;
            cy = contour[ verts[ w ] ].y;

            if ( Number.EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;

            var aX, aY, bX, bY, cX, cY;
            var apx, apy, bpx, bpy, cpx, cpy;
            var cCROSSap, bCROSScp, aCROSSbp;

            aX = cx - bx;  aY = cy - by;
            bX = ax - cx;  bY = ay - cy;
            cX = bx - ax;  cY = by - ay;

            for ( p = 0; p < n; p ++ ) {

                px = contour[ verts[ p ] ].x;
                py = contour[ verts[ p ] ].y;

                if ( ( ( px === ax ) && ( py === ay ) ) ||
                    ( ( px === bx ) && ( py === by ) ) ||
                    ( ( px === cx ) && ( py === cy ) ) )	continue;

                apx = px - ax;  apy = py - ay;
                bpx = px - bx;  bpy = py - by;
                cpx = px - cx;  cpy = py - cy;

                // see if p is inside triangle abc

                aCROSSbp = aX * bpy - aY * bpx;
                cCROSSap = cX * apy - cY * apx;
                bCROSScp = bX * cpy - bY * cpx;

                if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;

            }

            return true;

        }

        // takes in an contour array and returns

        return function ( contour, indices ) {

            var n = contour.length;

            if ( n < 3 ) return null;

            var result = [],
                verts = [],
                vertIndices = [];

            /* we want a counter-clockwise polygon in verts */

            var u, v, w;

            if ( THREE.ShapeUtils.area( contour ) > 0.0 ) {

                for ( v = 0; v < n; v ++ ) verts[ v ] = v;

            } else {

                for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

            }

            var nv = n;

            /*  remove nv - 2 vertices, creating 1 triangle every time */

            var count = 2 * nv;   /* error detection */

            for ( v = nv - 1; nv > 2; ) {

                /* if we loop, it is probably a non-simple polygon */

                if ( ( count -- ) <= 0 ) {

                    //** Triangulate: ERROR - probable bad polygon!

                    //throw ( "Warning, unable to triangulate polygon!" );
                    //return null;
                    // Sometimes warning is fine, especially polygons are triangulated in reverse.
                    console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );

                    if ( indices ) return vertIndices;
                    return result;

                }

                /* three consecutive vertices in current polygon, <u,v,w> */

                u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
                v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
                w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

                if ( snip( contour, u, v, w, nv, verts ) ) {

                    var a, b, c, s, t;

                    /* true names of the vertices */

                    a = verts[ u ];
                    b = verts[ v ];
                    c = verts[ w ];

                    /* output Triangle */

                    result.push( [ contour[ a ],
                        contour[ b ],
                        contour[ c ] ] );


                    vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

                    /* remove v from the remaining polygon */

                    for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {

                        verts[ s ] = verts[ t ];

                    }

                    nv --;

                    /* reset error detection counter */

                    count = 2 * nv;

                }

            }

            if ( indices ) return vertIndices;
            return result;

        }

    } )(),

    triangulateShape: function ( contour, holes ) {

        function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {

            // inOtherPt needs to be collinear to the inSegment
            if ( inSegPt1.x !== inSegPt2.x ) {

                if ( inSegPt1.x < inSegPt2.x ) {

                    return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );

                } else {

                    return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );

                }

            } else {

                if ( inSegPt1.y < inSegPt2.y ) {

                    return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );

                } else {

                    return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );

                }

            }

        }

        function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {

            var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
            var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

            var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
            var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

            var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
            var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

            if ( Math.abs( limit ) > Number.EPSILON ) {

                // not parallel

                var perpSeg2;
                if ( limit > 0 ) {

                    if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
                    perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
                    if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];

                } else {

                    if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
                    perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
                    if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];

                }

                // i.e. to reduce rounding errors
                // intersection at endpoint of segment#1?
                if ( perpSeg2 === 0 ) {

                    if ( ( inExcludeAdjacentSegs ) &&
                        ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
                    return [ inSeg1Pt1 ];

                }
                if ( perpSeg2 === limit ) {

                    if ( ( inExcludeAdjacentSegs ) &&
                        ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
                    return [ inSeg1Pt2 ];

                }
                // intersection at endpoint of segment#2?
                if ( perpSeg1 === 0 )		return [ inSeg2Pt1 ];
                if ( perpSeg1 === limit )	return [ inSeg2Pt2 ];

                // return real intersection point
                var factorSeg1 = perpSeg2 / limit;
                return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
                    y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

            } else {

                // parallel or collinear
                if ( ( perpSeg1 !== 0 ) ||
                    ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			return [];

                // they are collinear or degenerate
                var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );	// segment1 is just a point?
                var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );	// segment2 is just a point?
                // both segments are points
                if ( seg1Pt && seg2Pt ) {

                    if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
                        ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		return [];	// they are distinct  points
                    return [ inSeg1Pt1 ];                 						// they are the same point

                }
                // segment#1  is a single point
                if ( seg1Pt ) {

                    if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
                    return [ inSeg1Pt1 ];

                }
                // segment#2  is a single point
                if ( seg2Pt ) {

                    if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
                    return [ inSeg2Pt1 ];

                }

                // they are collinear segments, which might overlap
                var seg1min, seg1max, seg1minVal, seg1maxVal;
                var seg2min, seg2max, seg2minVal, seg2maxVal;
                if ( seg1dx !== 0 ) {

                    // the segments are NOT on a vertical line
                    if ( inSeg1Pt1.x < inSeg1Pt2.x ) {

                        seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
                        seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;

                    } else {

                        seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
                        seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;

                    }
                    if ( inSeg2Pt1.x < inSeg2Pt2.x ) {

                        seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
                        seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;

                    } else {

                        seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
                        seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;

                    }

                } else {

                    // the segments are on a vertical line
                    if ( inSeg1Pt1.y < inSeg1Pt2.y ) {

                        seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
                        seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;

                    } else {

                        seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
                        seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;

                    }
                    if ( inSeg2Pt1.y < inSeg2Pt2.y ) {

                        seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
                        seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;

                    } else {

                        seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
                        seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;

                    }

                }
                if ( seg1minVal <= seg2minVal ) {

                    if ( seg1maxVal <  seg2minVal )	return [];
                    if ( seg1maxVal === seg2minVal )	{

                        if ( inExcludeAdjacentSegs )		return [];
                        return [ seg2min ];

                    }
                    if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
                    return	[ seg2min, seg2max ];

                } else {

                    if ( seg1minVal >  seg2maxVal )	return [];
                    if ( seg1minVal === seg2maxVal )	{

                        if ( inExcludeAdjacentSegs )		return [];
                        return [ seg1min ];

                    }
                    if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
                    return	[ seg1min, seg2max ];

                }

            }

        }

        function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {

            // The order of legs is important

            // translation of all points, so that Vertex is at (0,0)
            var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
            var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
            var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;

            // main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
            var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
            var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;

            if ( Math.abs( from2toAngle ) > Number.EPSILON ) {

                // angle != 180 deg.

                var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
                // console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

                if ( from2toAngle > 0 ) {

                    // main angle < 180 deg.
                    return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );

                } else {

                    // main angle > 180 deg.
                    return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );

                }

            } else {

                // angle == 180 deg.
                // console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
                return	( from2otherAngle > 0 );

            }

        }


        function removeHoles( contour, holes ) {

            var shape = contour.concat(); // work on this shape
            var hole;

            function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {

                // Check if hole point lies within angle around shape point
                var lastShapeIdx = shape.length - 1;

                var prevShapeIdx = inShapeIdx - 1;
                if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;

                var nextShapeIdx = inShapeIdx + 1;
                if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;

                var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
                if ( ! insideAngle ) {

                    // console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
                    return	false;

                }

                // Check if shape point lies within angle around hole point
                var lastHoleIdx = hole.length - 1;

                var prevHoleIdx = inHoleIdx - 1;
                if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;

                var nextHoleIdx = inHoleIdx + 1;
                if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;

                insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
                if ( ! insideAngle ) {

                    // console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
                    return	false;

                }

                return	true;

            }

            function intersectsShapeEdge( inShapePt, inHolePt ) {

                // checks for intersections with shape edges
                var sIdx, nextIdx, intersection;
                for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {

                    nextIdx = sIdx + 1; nextIdx %= shape.length;
                    intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
                    if ( intersection.length > 0 )		return	true;

                }

                return	false;

            }

            var indepHoles = [];

            function intersectsHoleEdge( inShapePt, inHolePt ) {

                // checks for intersections with hole edges
                var ihIdx, chkHole,
                    hIdx, nextIdx, intersection;
                for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {

                    chkHole = holes[ indepHoles[ ihIdx ]];
                    for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {

                        nextIdx = hIdx + 1; nextIdx %= chkHole.length;
                        intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
                        if ( intersection.length > 0 )		return	true;

                    }

                }
                return	false;

            }

            var holeIndex, shapeIndex,
                shapePt, holePt,
                holeIdx, cutKey, failedCuts = [],
                tmpShape1, tmpShape2,
                tmpHole1, tmpHole2;

            for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

                indepHoles.push( h );

            }

            var minShapeIndex = 0;
            var counter = indepHoles.length * 2;
            while ( indepHoles.length > 0 ) {

                counter --;
                if ( counter < 0 ) {

                    console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
                    break;

                }

                // search for shape-vertex and hole-vertex,
                // which can be connected without intersections
                for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

                    shapePt = shape[ shapeIndex ];
                    holeIndex	= - 1;

                    // search for hole which can be reached without intersections
                    for ( var h = 0; h < indepHoles.length; h ++ ) {

                        holeIdx = indepHoles[ h ];

                        // prevent multiple checks
                        cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
                        if ( failedCuts[ cutKey ] !== undefined )			continue;

                        hole = holes[ holeIdx ];
                        for ( var h2 = 0; h2 < hole.length; h2 ++ ) {

                            holePt = hole[ h2 ];
                            if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
                            if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
                            if ( intersectsHoleEdge( shapePt, holePt ) )		continue;

                            holeIndex = h2;
                            indepHoles.splice( h, 1 );

                            tmpShape1 = shape.slice( 0, shapeIndex + 1 );
                            tmpShape2 = shape.slice( shapeIndex );
                            tmpHole1 = hole.slice( holeIndex );
                            tmpHole2 = hole.slice( 0, holeIndex + 1 );

                            shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

                            minShapeIndex = shapeIndex;

                            // Debug only, to show the selected cuts
                            // glob_CutLines.push( [ shapePt, holePt ] );

                            break;

                        }
                        if ( holeIndex >= 0 )	break;		// hole-vertex found

                        failedCuts[ cutKey ] = true;			// remember failure

                    }
                    if ( holeIndex >= 0 )	break;		// hole-vertex found

                }

            }

            return shape; 			/* shape with no holes */

        }


        var i, il, f, face,
            key, index,
            allPointsMap = {};

        // To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

        var allpoints = contour.concat();

        for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

            Array.prototype.push.apply( allpoints, holes[ h ] );

        }

        //console.log( "allpoints",allpoints, allpoints.length );

        // prepare all points map

        for ( i = 0, il = allpoints.length; i < il; i ++ ) {

            key = allpoints[ i ].x + ":" + allpoints[ i ].y;

            if ( allPointsMap[ key ] !== undefined ) {

                console.warn( "THREE.Shape: Duplicate point", key );

            }

            allPointsMap[ key ] = i;

        }

        // remove holes by cutting paths to holes and adding them to the shape
        var shapeWithoutHoles = removeHoles( contour, holes );

        var triangles = THREE.ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
        //console.log( "triangles",triangles, triangles.length );

        // check all face vertices against all points map

        for ( i = 0, il = triangles.length; i < il; i ++ ) {

            face = triangles[ i ];

            for ( f = 0; f < 3; f ++ ) {

                key = face[ f ].x + ":" + face[ f ].y;

                index = allPointsMap[ key ];

                if ( index !== undefined ) {

                    face[ f ] = index;

                }

            }

        }

        return triangles.concat();

    },

    isClockWise: function ( pts ) {

        return THREE.ShapeUtils.area( pts ) < 0;

    },

    // Bezier Curves formulas obtained from
    // http://en.wikipedia.org/wiki/B%C3%A9zier_curve

    // Quad Bezier Functions

    b2: ( function () {

        function b2p0( t, p ) {

            var k = 1 - t;
            return k * k * p;

        }

        function b2p1( t, p ) {

            return 2 * ( 1 - t ) * t * p;

        }

        function b2p2( t, p ) {

            return t * t * p;

        }

        return function ( t, p0, p1, p2 ) {

            return b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );

        };

    } )(),

    // Cubic Bezier Functions

    b3: ( function () {

        function b3p0( t, p ) {

            var k = 1 - t;
            return k * k * k * p;

        }

        function b3p1( t, p ) {

            var k = 1 - t;
            return 3 * k * k * t * p;

        }

        function b3p2( t, p ) {

            var k = 1 - t;
            return 3 * k * t * t * p;

        }

        function b3p3( t, p ) {

            return t * t * t * p;

        }

        return function ( t, p0, p1, p2, p3 ) {

            return b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );

        };

    } )()

};

// File:src/extras/audio/Audio.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Audio = function ( listener ) {

    THREE.Object3D.call( this );

    this.type = 'Audio';

    this.context = listener.context;
    this.source = this.context.createBufferSource();
    this.source.onended = this.onEnded.bind( this );

    this.gain = this.context.createGain();
    this.gain.connect( this.context.destination );

    this.panner = this.context.createPanner();
    this.panner.connect( this.gain );

    this.autoplay = false;

    this.startTime = 0;
    this.playbackRate = 1;
    this.isPlaying = false;

};

THREE.Audio.prototype = Object.create( THREE.Object3D.prototype );
THREE.Audio.prototype.constructor = THREE.Audio;

THREE.Audio.prototype.load = function ( file ) {

    var scope = this;

    var request = new XMLHttpRequest();
    request.open( 'GET', file, true );
    request.responseType = 'arraybuffer';
    request.onload = function ( e ) {

        scope.context.decodeAudioData( this.response, function ( buffer ) {

            scope.source.buffer = buffer;

            if ( scope.autoplay ) scope.play();

        } );

    };
    request.send();

    return this;

};

THREE.Audio.prototype.play = function () {

    if ( this.isPlaying === true ) {

        console.warn( 'THREE.Audio: Audio is already playing.' );
        return;

    }

    var source = this.context.createBufferSource();

    source.buffer = this.source.buffer;
    source.loop = this.source.loop;
    source.onended = this.source.onended;
    source.start( 0, this.startTime );
    source.playbackRate.value = this.playbackRate;

    this.isPlaying = true;

    this.source = source;

    this.connect();

};

THREE.Audio.prototype.pause = function () {

    this.source.stop();
    this.startTime = this.context.currentTime;

};

THREE.Audio.prototype.stop = function () {

    this.source.stop();
    this.startTime = 0;

};

THREE.Audio.prototype.connect = function () {

    if ( this.filter !== undefined ) {

        this.source.connect( this.filter );
        this.filter.connect( this.panner );

    } else {

        this.source.connect( this.panner );

    }

};

THREE.Audio.prototype.disconnect = function () {

    if ( this.filter !== undefined ) {

        this.source.disconnect( this.filter );
        this.filter.disconnect( this.panner );

    } else {

        this.source.disconnect( this.panner );

    }

};

THREE.Audio.prototype.setFilter = function ( value ) {

    if ( this.isPlaying === true ) {

        this.disconnect();
        this.filter = value;
        this.connect();

    } else {

        this.filter = value;

    }

};

THREE.Audio.prototype.getFilter = function () {

    return this.filter;

};

THREE.Audio.prototype.setPlaybackRate = function ( value ) {

    this.playbackRate = value;

    if ( this.isPlaying === true ) {

        this.source.playbackRate.value = this.playbackRate;

    }

};

THREE.Audio.prototype.getPlaybackRate = function () {

    return this.playbackRate;

};

THREE.Audio.prototype.onEnded = function() {

    this.isPlaying = false;

};

THREE.Audio.prototype.setLoop = function ( value ) {

    this.source.loop = value;

};

THREE.Audio.prototype.getLoop = function () {

    return this.source.loop;

};

THREE.Audio.prototype.setRefDistance = function ( value ) {

    this.panner.refDistance = value;

};

THREE.Audio.prototype.getRefDistance = function () {

    return this.panner.refDistance;

};

THREE.Audio.prototype.setRolloffFactor = function ( value ) {

    this.panner.rolloffFactor = value;

};

THREE.Audio.prototype.getRolloffFactor = function () {

    return this.panner.rolloffFactor;

};

THREE.Audio.prototype.setVolume = function ( value ) {

    this.gain.gain.value = value;

};

THREE.Audio.prototype.getVolume = function () {

    return this.gain.gain.value;

};

THREE.Audio.prototype.updateMatrixWorld = ( function () {

    var position = new THREE.Vector3();

    return function updateMatrixWorld( force ) {

        THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

        position.setFromMatrixPosition( this.matrixWorld );

        this.panner.setPosition( position.x, position.y, position.z );

    };

} )();

// File:src/extras/audio/AudioListener.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AudioListener = function () {

    THREE.Object3D.call( this );

    this.type = 'AudioListener';

    this.context = new ( window.AudioContext || window.webkitAudioContext )();

};

THREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );
THREE.AudioListener.prototype.constructor = THREE.AudioListener;

THREE.AudioListener.prototype.updateMatrixWorld = ( function () {

    var position = new THREE.Vector3();
    var quaternion = new THREE.Quaternion();
    var scale = new THREE.Vector3();

    var orientation = new THREE.Vector3();

    return function updateMatrixWorld( force ) {

        THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

        var listener = this.context.listener;
        var up = this.up;

        this.matrixWorld.decompose( position, quaternion, scale );

        orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );

        listener.setPosition( position.x, position.y, position.z );
        listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

    };

} )();

// File:src/extras/core/Curve.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of Curve methods
 * .getPoint(t), getTangent(t)
 * .getPointAt(u), getTagentAt(u)
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following classes subclasses THREE.Curve:
 *
 * -- 2d classes --
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.CubicBezierCurve
 * THREE.SplineCurve
 * THREE.ArcCurve
 * THREE.EllipseCurve
 *
 * -- 3d classes --
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 * THREE.CubicBezierCurve3
 * THREE.SplineCurve3
 * THREE.ClosedSplineCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath
 *
 **/

/**************************************************************
 *	Abstract Curve base class
 **************************************************************/

THREE.Curve = function () {

};

THREE.Curve.prototype = {

    constructor: THREE.Curve,

    // Virtual base class method to overwrite and implement in subclasses
    //	- t [0 .. 1]

    getPoint: function ( t ) {

        console.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
        return null;

    },

    // Get point at relative position in curve according to arc length
    // - u [0 .. 1]

    getPointAt: function ( u ) {

        var t = this.getUtoTmapping( u );
        return this.getPoint( t );

    },

    // Get sequence of points using getPoint( t )

    getPoints: function ( divisions ) {

        if ( ! divisions ) divisions = 5;

        var d, pts = [];

        for ( d = 0; d <= divisions; d ++ ) {

            pts.push( this.getPoint( d / divisions ) );

        }

        return pts;

    },

    // Get sequence of points using getPointAt( u )

    getSpacedPoints: function ( divisions ) {

        if ( ! divisions ) divisions = 5;

        var d, pts = [];

        for ( d = 0; d <= divisions; d ++ ) {

            pts.push( this.getPointAt( d / divisions ) );

        }

        return pts;

    },

    // Get total curve arc length

    getLength: function () {

        var lengths = this.getLengths();
        return lengths[ lengths.length - 1 ];

    },

    // Get list of cumulative segment lengths

    getLengths: function ( divisions ) {

        if ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;

        if ( this.cacheArcLengths
            && ( this.cacheArcLengths.length === divisions + 1 )
            && ! this.needsUpdate ) {

            //console.log( "cached", this.cacheArcLengths );
            return this.cacheArcLengths;

        }

        this.needsUpdate = false;

        var cache = [];
        var current, last = this.getPoint( 0 );
        var p, sum = 0;

        cache.push( 0 );

        for ( p = 1; p <= divisions; p ++ ) {

            current = this.getPoint ( p / divisions );
            sum += current.distanceTo( last );
            cache.push( sum );
            last = current;

        }

        this.cacheArcLengths = cache;

        return cache; // { sums: cache, sum:sum }; Sum is in the last element.

    },

    updateArcLengths: function() {

        this.needsUpdate = true;
        this.getLengths();

    },

    // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

    getUtoTmapping: function ( u, distance ) {

        var arcLengths = this.getLengths();

        var i = 0, il = arcLengths.length;

        var targetArcLength; // The targeted u distance value to get

        if ( distance ) {

            targetArcLength = distance;

        } else {

            targetArcLength = u * arcLengths[ il - 1 ];

        }

        //var time = Date.now();

        // binary search for the index with largest value smaller than target u distance

        var low = 0, high = il - 1, comparison;

        while ( low <= high ) {

            i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

            comparison = arcLengths[ i ] - targetArcLength;

            if ( comparison < 0 ) {

                low = i + 1;

            } else if ( comparison > 0 ) {

                high = i - 1;

            } else {

                high = i;
                break;

                // DONE

            }

        }

        i = high;

        //console.log('b' , i, low, high, Date.now()- time);

        if ( arcLengths[ i ] === targetArcLength ) {

            var t = i / ( il - 1 );
            return t;

        }

        // we could get finer grain at lengths, or use simple interpolation between two points

        var lengthBefore = arcLengths[ i ];
        var lengthAfter = arcLengths[ i + 1 ];

        var segmentLength = lengthAfter - lengthBefore;

        // determine where we are between the 'before' and 'after' points

        var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

        // add that fractional amount to t

        var t = ( i + segmentFraction ) / ( il - 1 );

        return t;

    },

    // Returns a unit vector tangent at t
    // In case any sub curve does not implement its tangent derivation,
    // 2 points a small delta apart will be used to find its gradient
    // which seems to give a reasonable approximation

    getTangent: function( t ) {

        var delta = 0.0001;
        var t1 = t - delta;
        var t2 = t + delta;

        // Capping in case of danger

        if ( t1 < 0 ) t1 = 0;
        if ( t2 > 1 ) t2 = 1;

        var pt1 = this.getPoint( t1 );
        var pt2 = this.getPoint( t2 );

        var vec = pt2.clone().sub( pt1 );
        return vec.normalize();

    },

    getTangentAt: function ( u ) {

        var t = this.getUtoTmapping( u );
        return this.getTangent( t );

    }

}

THREE.Curve.Utils = THREE.CurveUtils; // backwards compatibility

// TODO: Transformation for Curves?

/**************************************************************
 *	3D Curves
 **************************************************************/

// A Factory method for creating new curve subclasses

THREE.Curve.create = function ( constructor, getPointFunc ) {

    constructor.prototype = Object.create( THREE.Curve.prototype );
    constructor.prototype.constructor = constructor;
    constructor.prototype.getPoint = getPointFunc;

    return constructor;

};

// File:src/extras/core/CurvePath.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

THREE.CurvePath = function () {

    this.curves = [];

    this.autoClose = false; // Automatically closes the path

};

THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );
THREE.CurvePath.prototype.constructor = THREE.CurvePath;

THREE.CurvePath.prototype.add = function ( curve ) {

    this.curves.push( curve );

};

/*
 THREE.CurvePath.prototype.checkConnection = function() {
 // TODO
 // If the ending of curve is not connected to the starting
 // or the next curve, then, this is not a real path
 };
 */

THREE.CurvePath.prototype.closePath = function() {

    // TODO Test
    // and verify for vector3 (needs to implement equals)
    // Add a line curve if start and end of lines are not connected
    var startPoint = this.curves[ 0 ].getPoint( 0 );
    var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

    if ( ! startPoint.equals( endPoint ) ) {

        this.curves.push( new THREE.LineCurve( endPoint, startPoint ) );

    }

};

// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:

// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')

THREE.CurvePath.prototype.getPoint = function( t ) {

    var d = t * this.getLength();
    var curveLengths = this.getCurveLengths();
    var i = 0;

    // To think about boundaries points.

    while ( i < curveLengths.length ) {

        if ( curveLengths[ i ] >= d ) {

            var diff = curveLengths[ i ] - d;
            var curve = this.curves[ i ];

            var u = 1 - diff / curve.getLength();

            return curve.getPointAt( u );

        }

        i ++;

    }

    return null;

    // loop where sum != 0, sum > d , sum+1 <d

};

/*
 THREE.CurvePath.prototype.getTangent = function( t ) {
 };
 */

// We cannot use the default THREE.Curve getPoint() with getLength() because in
// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
// getPoint() depends on getLength

THREE.CurvePath.prototype.getLength = function() {

    var lens = this.getCurveLengths();
    return lens[ lens.length - 1 ];

};

// Compute lengths and cache them
// We cannot overwrite getLengths() because UtoT mapping uses it.

THREE.CurvePath.prototype.getCurveLengths = function() {

    // We use cache values if curves and cache array are same length

    if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

        return this.cacheLengths;

    }

    // Get length of sub-curve
    // Push sums into cached array

    var lengths = [], sums = 0;

    for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

        sums += this.curves[ i ].getLength();
        lengths.push( sums );

    }

    this.cacheLengths = lengths;

    return lengths;

};



/**************************************************************
 *	Create Geometries Helpers
 **************************************************************/

/// Generate geometry from path points (for Line or Points objects)

THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {

    var pts = this.getPoints( divisions, true );
    return this.createGeometry( pts );

};

// Generate geometry from equidistant sampling along the path

THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {

    var pts = this.getSpacedPoints( divisions, true );
    return this.createGeometry( pts );

};

THREE.CurvePath.prototype.createGeometry = function( points ) {

    var geometry = new THREE.Geometry();

    for ( var i = 0, l = points.length; i < l; i ++ ) {

        var point = points[ i ];
        geometry.vertices.push( new THREE.Vector3( point.x, point.y, point.z || 0 ) );

    }

    return geometry;

};

// File:src/extras/core/Path.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 *
 **/

THREE.Path = function ( points ) {

    THREE.CurvePath.call( this );

    this.actions = [];

    if ( points ) {

        this.fromPoints( points );

    }

};

THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );
THREE.Path.prototype.constructor = THREE.Path;

// TODO Clean up PATH API

// Create path using straight lines to connect all points
// - vectors: array of Vector2

THREE.Path.prototype.fromPoints = function ( vectors ) {

    this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

    for ( var i = 1, l = vectors.length; i < l; i ++ ) {

        this.lineTo( vectors[ i ].x, vectors[ i ].y );

    }

};

// startPath() endPath()?

THREE.Path.prototype.moveTo = function ( x, y ) {

    this.actions.push( { action: 'moveTo', args: [ x, y ] } );

};

THREE.Path.prototype.lineTo = function ( x, y ) {

    var lastargs = this.actions[ this.actions.length - 1 ].args;

    var x0 = lastargs[ lastargs.length - 2 ];
    var y0 = lastargs[ lastargs.length - 1 ];

    var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
    this.curves.push( curve );

    this.actions.push( { action: 'lineTo', args: [ x, y ] } );

};

THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {

    var lastargs = this.actions[ this.actions.length - 1 ].args;

    var x0 = lastargs[ lastargs.length - 2 ];
    var y0 = lastargs[ lastargs.length - 1 ];

    var curve = new THREE.QuadraticBezierCurve(
        new THREE.Vector2( x0, y0 ),
        new THREE.Vector2( aCPx, aCPy ),
        new THREE.Vector2( aX, aY )
    );

    this.curves.push( curve );

    this.actions.push( { action: 'quadraticCurveTo', args: [ aCPx, aCPy, aX, aY ] } );

};

THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

    var lastargs = this.actions[ this.actions.length - 1 ].args;

    var x0 = lastargs[ lastargs.length - 2 ];
    var y0 = lastargs[ lastargs.length - 1 ];

    var curve = new THREE.CubicBezierCurve(
        new THREE.Vector2( x0, y0 ),
        new THREE.Vector2( aCP1x, aCP1y ),
        new THREE.Vector2( aCP2x, aCP2y ),
        new THREE.Vector2( aX, aY )
    );

    this.curves.push( curve );

    this.actions.push( { action: 'bezierCurveTo', args: [ aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ] } );

};

THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {

    var args = Array.prototype.slice.call( arguments );

    var lastargs = this.actions[ this.actions.length - 1 ].args;

    var x0 = lastargs[ lastargs.length - 2 ];
    var y0 = lastargs[ lastargs.length - 1 ];

    var npts = [ new THREE.Vector2( x0, y0 ) ];
    Array.prototype.push.apply( npts, pts );

    var curve = new THREE.SplineCurve( npts );
    this.curves.push( curve );

    this.actions.push( { action: 'splineThru', args: args } );

};

// FUTURE: Change the API or follow canvas API?

THREE.Path.prototype.arc = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

    var lastargs = this.actions[ this.actions.length - 1 ].args;
    var x0 = lastargs[ lastargs.length - 2 ];
    var y0 = lastargs[ lastargs.length - 1 ];

    this.absarc( aX + x0, aY + y0, aRadius,
        aStartAngle, aEndAngle, aClockwise );

};

THREE.Path.prototype.absarc = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

    this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

};

THREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

    var lastargs = this.actions[ this.actions.length - 1 ].args;
    var x0 = lastargs[ lastargs.length - 2 ];
    var y0 = lastargs[ lastargs.length - 1 ];

    this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

};


THREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

    var args = [
        aX, aY,
        xRadius, yRadius,
        aStartAngle, aEndAngle,
        aClockwise,
        aRotation || 0 // aRotation is optional.
    ];

    var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
    this.curves.push( curve );

    var lastPoint = curve.getPoint( 1 );
    args.push( lastPoint.x );
    args.push( lastPoint.y );

    this.actions.push( { action: 'ellipse', args: args } );

};

THREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {

    if ( ! divisions ) divisions = 40;

    var points = [];

    for ( var i = 0; i < divisions; i ++ ) {

        points.push( this.getPoint( i / divisions ) );

        //if ( !this.getPoint( i / divisions ) ) throw "DIE";

    }

    // if ( closedPath ) {
    //
    // 	points.push( points[ 0 ] );
    //
    // }

    return points;

};

/* Return an array of vectors based on contour of the path */

THREE.Path.prototype.getPoints = function( divisions, closedPath ) {

    divisions = divisions || 12;

    var b2 = THREE.ShapeUtils.b2;
    var b3 = THREE.ShapeUtils.b3;

    var points = [];

    var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
        laste, tx, ty;

    for ( var i = 0, l = this.actions.length; i < l; i ++ ) {

        var item = this.actions[ i ];

        var action = item.action;
        var args = item.args;

        switch ( action ) {

            case 'moveTo':

                points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

                break;

            case 'lineTo':

                points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

                break;

            case 'quadraticCurveTo':

                cpx  = args[ 2 ];
                cpy  = args[ 3 ];

                cpx1 = args[ 0 ];
                cpy1 = args[ 1 ];

                if ( points.length > 0 ) {

                    laste = points[ points.length - 1 ];

                    cpx0 = laste.x;
                    cpy0 = laste.y;

                } else {

                    laste = this.actions[ i - 1 ].args;

                    cpx0 = laste[ laste.length - 2 ];
                    cpy0 = laste[ laste.length - 1 ];

                }

                for ( var j = 1; j <= divisions; j ++ ) {

                    var t = j / divisions;

                    tx = b2( t, cpx0, cpx1, cpx );
                    ty = b2( t, cpy0, cpy1, cpy );

                    points.push( new THREE.Vector2( tx, ty ) );

                }

                break;

            case 'bezierCurveTo':

                cpx  = args[ 4 ];
                cpy  = args[ 5 ];

                cpx1 = args[ 0 ];
                cpy1 = args[ 1 ];

                cpx2 = args[ 2 ];
                cpy2 = args[ 3 ];

                if ( points.length > 0 ) {

                    laste = points[ points.length - 1 ];

                    cpx0 = laste.x;
                    cpy0 = laste.y;

                } else {

                    laste = this.actions[ i - 1 ].args;

                    cpx0 = laste[ laste.length - 2 ];
                    cpy0 = laste[ laste.length - 1 ];

                }


                for ( var j = 1; j <= divisions; j ++ ) {

                    var t = j / divisions;

                    tx = b3( t, cpx0, cpx1, cpx2, cpx );
                    ty = b3( t, cpy0, cpy1, cpy2, cpy );

                    points.push( new THREE.Vector2( tx, ty ) );

                }

                break;

            case 'splineThru':

                laste = this.actions[ i - 1 ].args;

                var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
                var spts = [ last ];

                var n = divisions * args[ 0 ].length;

                spts = spts.concat( args[ 0 ] );

                var spline = new THREE.SplineCurve( spts );

                for ( var j = 1; j <= n; j ++ ) {

                    points.push( spline.getPointAt( j / n ) );

                }

                break;

            case 'arc':

                var aX = args[ 0 ], aY = args[ 1 ],
                    aRadius = args[ 2 ],
                    aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
                    aClockwise = !! args[ 5 ];

                var deltaAngle = aEndAngle - aStartAngle;
                var angle;
                var tdivisions = divisions * 2;

                for ( var j = 1; j <= tdivisions; j ++ ) {

                    var t = j / tdivisions;

                    if ( ! aClockwise ) {

                        t = 1 - t;

                    }

                    angle = aStartAngle + t * deltaAngle;

                    tx = aX + aRadius * Math.cos( angle );
                    ty = aY + aRadius * Math.sin( angle );

                    //console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

                    points.push( new THREE.Vector2( tx, ty ) );

                }

                //console.log(points);

                break;

            case 'ellipse':

                var aX = args[ 0 ], aY = args[ 1 ],
                    xRadius = args[ 2 ],
                    yRadius = args[ 3 ],
                    aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],
                    aClockwise = !! args[ 6 ],
                    aRotation = args[ 7 ];


                var deltaAngle = aEndAngle - aStartAngle;
                var angle;
                var tdivisions = divisions * 2;

                var cos, sin;
                if ( aRotation !== 0 ) {

                    cos = Math.cos( aRotation );
                    sin = Math.sin( aRotation );

                }

                for ( var j = 1; j <= tdivisions; j ++ ) {

                    var t = j / tdivisions;

                    if ( ! aClockwise ) {

                        t = 1 - t;

                    }

                    angle = aStartAngle + t * deltaAngle;

                    tx = aX + xRadius * Math.cos( angle );
                    ty = aY + yRadius * Math.sin( angle );

                    if ( aRotation !== 0 ) {

                        var x = tx, y = ty;

                        // Rotate the point about the center of the ellipse.
                        tx = ( x - aX ) * cos - ( y - aY ) * sin + aX;
                        ty = ( x - aX ) * sin + ( y - aY ) * cos + aY;

                    }

                    //console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

                    points.push( new THREE.Vector2( tx, ty ) );

                }

                //console.log(points);

                break;

        } // end switch

    }



    // Normalize to remove the closing point by default.
    var lastPoint = points[ points.length - 1 ];
    if ( Math.abs( lastPoint.x - points[ 0 ].x ) < Number.EPSILON &&
        Math.abs( lastPoint.y - points[ 0 ].y ) < Number.EPSILON )
        points.splice( points.length - 1, 1 );
    if ( closedPath ) {

        points.push( points[ 0 ] );

    }

    return points;

};

//
// Breaks path into shapes
//
//	Assumptions (if parameter isCCW==true the opposite holds):
//	- solid shapes are defined clockwise (CW)
//	- holes are defined counterclockwise (CCW)
//
//	If parameter noHoles==true:
//  - all subPaths are regarded as solid shapes
//  - definition order CW/CCW has no relevance
//

THREE.Path.prototype.toShapes = function( isCCW, noHoles ) {

    function extractSubpaths( inActions ) {

        var subPaths = [], lastPath = new THREE.Path();

        for ( var i = 0, l = inActions.length; i < l; i ++ ) {

            var item = inActions[ i ];

            var args = item.args;
            var action = item.action;

            if ( action === 'moveTo' ) {

                if ( lastPath.actions.length !== 0 ) {

                    subPaths.push( lastPath );
                    lastPath = new THREE.Path();

                }

            }

            lastPath[ action ].apply( lastPath, args );

        }

        if ( lastPath.actions.length !== 0 ) {

            subPaths.push( lastPath );

        }

        // console.log(subPaths);

        return	subPaths;

    }

    function toShapesNoHoles( inSubpaths ) {

        var shapes = [];

        for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

            var tmpPath = inSubpaths[ i ];

            var tmpShape = new THREE.Shape();
            tmpShape.actions = tmpPath.actions;
            tmpShape.curves = tmpPath.curves;

            shapes.push( tmpShape );

        }

        //console.log("shape", shapes);

        return shapes;

    }

    function isPointInsidePolygon( inPt, inPolygon ) {

        var polyLen = inPolygon.length;

        // inPt on polygon contour => immediate success    or
        // toggling of inside/outside at every single! intersection point of an edge
        //  with the horizontal line through inPt, left of inPt
        //  not counting lowerY endpoints of edges and whole edges on that line
        var inside = false;
        for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

            var edgeLowPt  = inPolygon[ p ];
            var edgeHighPt = inPolygon[ q ];

            var edgeDx = edgeHighPt.x - edgeLowPt.x;
            var edgeDy = edgeHighPt.y - edgeLowPt.y;

            if ( Math.abs( edgeDy ) > Number.EPSILON ) {

                // not parallel
                if ( edgeDy < 0 ) {

                    edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
                    edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

                }
                if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

                if ( inPt.y === edgeLowPt.y ) {

                    if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
                    // continue;				// no intersection or edgeLowPt => doesn't count !!!

                } else {

                    var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
                    if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
                    if ( perpEdge < 0 ) 				continue;
                    inside = ! inside;		// true intersection left of inPt

                }

            } else {

                // parallel or collinear
                if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
                // edge lies on the same horizontal line as inPt
                if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
                    ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
                // continue;

            }

        }

        return	inside;

    }

    var isClockWise = THREE.ShapeUtils.isClockWise;

    var subPaths = extractSubpaths( this.actions );
    if ( subPaths.length === 0 ) return [];

    if ( noHoles === true )	return	toShapesNoHoles( subPaths );


    var solid, tmpPath, tmpShape, shapes = [];

    if ( subPaths.length === 1 ) {

        tmpPath = subPaths[ 0 ];
        tmpShape = new THREE.Shape();
        tmpShape.actions = tmpPath.actions;
        tmpShape.curves = tmpPath.curves;
        shapes.push( tmpShape );
        return shapes;

    }

    var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
    holesFirst = isCCW ? ! holesFirst : holesFirst;

    // console.log("Holes first", holesFirst);

    var betterShapeHoles = [];
    var newShapes = [];
    var newShapeHoles = [];
    var mainIdx = 0;
    var tmpPoints;

    newShapes[ mainIdx ] = undefined;
    newShapeHoles[ mainIdx ] = [];

    for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

        tmpPath = subPaths[ i ];
        tmpPoints = tmpPath.getPoints();
        solid = isClockWise( tmpPoints );
        solid = isCCW ? ! solid : solid;

        if ( solid ) {

            if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

            newShapes[ mainIdx ] = { s: new THREE.Shape(), p: tmpPoints };
            newShapes[ mainIdx ].s.actions = tmpPath.actions;
            newShapes[ mainIdx ].s.curves = tmpPath.curves;

            if ( holesFirst )	mainIdx ++;
            newShapeHoles[ mainIdx ] = [];

            //console.log('cw', i);

        } else {

            newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

            //console.log('ccw', i);

        }

    }

    // only Holes? -> probably all Shapes with wrong orientation
    if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


    if ( newShapes.length > 1 ) {

        var ambiguous = false;
        var toChange = [];

        for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

            betterShapeHoles[ sIdx ] = [];

        }

        for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

            var sho = newShapeHoles[ sIdx ];

            for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

                var ho = sho[ hIdx ];
                var hole_unassigned = true;

                for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

                    if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

                        if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
                        if ( hole_unassigned ) {

                            hole_unassigned = false;
                            betterShapeHoles[ s2Idx ].push( ho );

                        } else {

                            ambiguous = true;

                        }

                    }

                }
                if ( hole_unassigned ) {

                    betterShapeHoles[ sIdx ].push( ho );

                }

            }

        }
        // console.log("ambiguous: ", ambiguous);
        if ( toChange.length > 0 ) {

            // console.log("to change: ", toChange);
            if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

        }

    }

    var tmpHoles;

    for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

        tmpShape = newShapes[ i ].s;
        shapes.push( tmpShape );
        tmpHoles = newShapeHoles[ i ];

        for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

            tmpShape.holes.push( tmpHoles[ j ].h );

        }

    }

    //console.log("shape", shapes);

    return shapes;

};

// File:src/extras/core/Shape.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/

// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

THREE.Shape = function () {

    THREE.Path.apply( this, arguments );

    this.holes = [];

};

THREE.Shape.prototype = Object.create( THREE.Path.prototype );
THREE.Shape.prototype.constructor = THREE.Shape;

// Convenience method to return ExtrudeGeometry

THREE.Shape.prototype.extrude = function ( options ) {

    return new THREE.ExtrudeGeometry( this, options );

};

// Convenience method to return ShapeGeometry

THREE.Shape.prototype.makeGeometry = function ( options ) {

    return new THREE.ShapeGeometry( this, options );

};

// Get points of holes

THREE.Shape.prototype.getPointsHoles = function ( divisions ) {

    var holesPts = [];

    for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

        holesPts[ i ] = this.holes[ i ].getPoints( divisions );

    }

    return holesPts;

};


// Get points of shape and holes (keypoints based on segments parameter)

THREE.Shape.prototype.extractAllPoints = function ( divisions ) {

    return {

        shape: this.getPoints( divisions ),
        holes: this.getPointsHoles( divisions )

    };

};

THREE.Shape.prototype.extractPoints = function ( divisions ) {

    return this.extractAllPoints( divisions );

};

THREE.Shape.Utils = THREE.ShapeUtils; // backwards compatibility

// File:src/extras/curves/LineCurve.js

/**************************************************************
 *	Line
 **************************************************************/

THREE.LineCurve = function ( v1, v2 ) {

    this.v1 = v1;
    this.v2 = v2;

};

THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.LineCurve.prototype.constructor = THREE.LineCurve;

THREE.LineCurve.prototype.getPoint = function ( t ) {

    var point = this.v2.clone().sub( this.v1 );
    point.multiplyScalar( t ).add( this.v1 );

    return point;

};

// Line curve is linear, so we can overwrite default getPointAt

THREE.LineCurve.prototype.getPointAt = function ( u ) {

    return this.getPoint( u );

};

THREE.LineCurve.prototype.getTangent = function( t ) {

    var tangent = this.v2.clone().sub( this.v1 );

    return tangent.normalize();

};

// File:src/extras/curves/QuadraticBezierCurve.js

/**************************************************************
 *	Quadratic Bezier curve
 **************************************************************/


THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {

    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;

};

THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;


THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {

    var b2 = THREE.ShapeUtils.b2;

    return new THREE.Vector2(
        b2( t, this.v0.x, this.v1.x, this.v2.x ),
        b2( t, this.v0.y, this.v1.y, this.v2.y )
    );

};


THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {

    var tangentQuadraticBezier = THREE.CurveUtils.tangentQuadraticBezier;

    return new THREE.Vector2(
        tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),
        tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )
    ).normalize();

};

// File:src/extras/curves/CubicBezierCurve.js

/**************************************************************
 *	Cubic Bezier curve
 **************************************************************/

THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {

    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;

};

THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;

THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {

    var b3 = THREE.ShapeUtils.b3;

    return new THREE.Vector2(
        b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
        b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
    );

};

THREE.CubicBezierCurve.prototype.getTangent = function( t ) {

    var tangentCubicBezier = THREE.CurveUtils.tangentCubicBezier;

    return new THREE.Vector2(
        tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
        tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
    ).normalize();

};

// File:src/extras/curves/SplineCurve.js

/**************************************************************
 *	Spline curve
 **************************************************************/

THREE.SplineCurve = function ( points /* array of Vector2 */ ) {

    this.points = ( points == undefined ) ? [] : points;

};

THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;

THREE.SplineCurve.prototype.getPoint = function ( t ) {

    var points = this.points;
    var point = ( points.length - 1 ) * t;

    var intPoint = Math.floor( point );
    var weight = point - intPoint;

    var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
    var point1 = points[ intPoint ];
    var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
    var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

    var interpolate = THREE.CurveUtils.interpolate;

    return new THREE.Vector2(
        interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
        interpolate( point0.y, point1.y, point2.y, point3.y, weight )
    );

};

// File:src/extras/curves/EllipseCurve.js

/**************************************************************
 *	Ellipse curve
 **************************************************************/

THREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

    this.aX = aX;
    this.aY = aY;

    this.xRadius = xRadius;
    this.yRadius = yRadius;

    this.aStartAngle = aStartAngle;
    this.aEndAngle = aEndAngle;

    this.aClockwise = aClockwise;

    this.aRotation = aRotation || 0;

};

THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;

THREE.EllipseCurve.prototype.getPoint = function ( t ) {

    var deltaAngle = this.aEndAngle - this.aStartAngle;

    if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
    if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;

    var angle;

    if ( this.aClockwise === true ) {

        angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );

    } else {

        angle = this.aStartAngle + t * deltaAngle;

    }

    var x = this.aX + this.xRadius * Math.cos( angle );
    var y = this.aY + this.yRadius * Math.sin( angle );

    if ( this.aRotation !== 0 ) {

        var cos = Math.cos( this.aRotation );
        var sin = Math.sin( this.aRotation );

        var tx = x, ty = y;

        // Rotate the point about the center of the ellipse.
        x = ( tx - this.aX ) * cos - ( ty - this.aY ) * sin + this.aX;
        y = ( tx - this.aX ) * sin + ( ty - this.aY ) * cos + this.aY;

    }

    return new THREE.Vector2( x, y );

};

// File:src/extras/curves/ArcCurve.js

/**************************************************************
 *	Arc curve
 **************************************************************/

THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

    THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

};

THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );
THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;

// File:src/extras/curves/LineCurve3.js

/**************************************************************
 *	Line3D
 **************************************************************/

THREE.LineCurve3 = THREE.Curve.create(

    function ( v1, v2 ) {

        this.v1 = v1;
        this.v2 = v2;

    },

    function ( t ) {

        var vector = new THREE.Vector3();

        vector.subVectors( this.v2, this.v1 ); // diff
        vector.multiplyScalar( t );
        vector.add( this.v1 );

        return vector;

    }

);

// File:src/extras/curves/QuadraticBezierCurve3.js

/**************************************************************
 *	Quadratic Bezier 3D curve
 **************************************************************/

THREE.QuadraticBezierCurve3 = THREE.Curve.create(

    function ( v0, v1, v2 ) {

        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;

    },

    function ( t ) {

        var b2 = THREE.ShapeUtils.b2;

        return new THREE.Vector3(
            b2( t, this.v0.x, this.v1.x, this.v2.x ),
            b2( t, this.v0.y, this.v1.y, this.v2.y ),
            b2( t, this.v0.z, this.v1.z, this.v2.z )
        );

    }

);

// File:src/extras/curves/CubicBezierCurve3.js

/**************************************************************
 *	Cubic Bezier 3D curve
 **************************************************************/

THREE.CubicBezierCurve3 = THREE.Curve.create(

    function ( v0, v1, v2, v3 ) {

        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;

    },

    function ( t ) {

        var b3 = THREE.ShapeUtils.b3;

        return new THREE.Vector3(
            b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
            b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),
            b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )
        );

    }

);

// File:src/extras/curves/SplineCurve3.js

/**************************************************************
 *	Spline 3D curve
 **************************************************************/


THREE.SplineCurve3 = THREE.Curve.create(

    function ( points /* array of Vector3 */ ) {

        console.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );
        this.points = ( points == undefined ) ? [] : points;

    },

    function ( t ) {

        var points = this.points;
        var point = ( points.length - 1 ) * t;

        var intPoint = Math.floor( point );
        var weight = point - intPoint;

        var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
        var point1 = points[ intPoint ];
        var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
        var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

        var interpolate = THREE.CurveUtils.interpolate;

        return new THREE.Vector3(
            interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
            interpolate( point0.y, point1.y, point2.y, point3.y, weight ),
            interpolate( point0.z, point1.z, point2.z, point3.z, weight )
        );

    }

);

// File:src/extras/curves/CatmullRomCurve3.js

/**
 * @author zz85 https://github.com/zz85
 *
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */

THREE.CatmullRomCurve3 = ( function() {

    var
        tmp = new THREE.Vector3(),
        px = new CubicPoly(),
        py = new CubicPoly(),
        pz = new CubicPoly();

    /*
     Based on an optimized c++ solution in
     - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
     - http://ideone.com/NoEbVM

     This CubicPoly class could be used for reusing some variables and calculations,
     but for three.js curve use, it could be possible inlined and flatten into a single function call
     which can be placed in CurveUtils.
     */

    function CubicPoly() {

    }

    /*
     * Compute coefficients for a cubic polynomial
     *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
     * such that
     *   p(0) = x0, p(1) = x1
     *  and
     *   p'(0) = t0, p'(1) = t1.
     */
    CubicPoly.prototype.init = function( x0, x1, t0, t1 ) {

        this.c0 = x0;
        this.c1 = t0;
        this.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
        this.c3 = 2 * x0 - 2 * x1 + t0 + t1;

    };

    CubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {

        // compute tangents when parameterized in [t1,t2]
        var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
        var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

        // rescale tangents for parametrization in [0,1]
        t1 *= dt1;
        t2 *= dt1;

        // initCubicPoly
        this.init( x1, x2, t1, t2 );

    };

    // standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4
    CubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {

        this.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

    };

    CubicPoly.prototype.calc = function( t ) {

        var t2 = t * t;
        var t3 = t2 * t;
        return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;

    };

    // Subclass Three.js curve
    return THREE.Curve.create(

        function ( p /* array of Vector3 */ ) {

            this.points = p || [];

        },

        function ( t ) {

            var points = this.points,
                point, intPoint, weight, l;

            l = points.length;

            if ( l < 2 ) console.log( 'duh, you need at least 2 points' );

            point = ( l - 1 ) * t;
            intPoint = Math.floor( point );
            weight = point - intPoint;

            if ( weight === 0 && intPoint === l - 1 ) {

                intPoint = l - 2;
                weight = 1;

            }

            var p0, p1, p2, p3;

            if ( intPoint === 0 ) {

                // extrapolate first point
                tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
                p0 = tmp;

            } else {

                p0 = points[ intPoint - 1 ];

            }

            p1 = points[ intPoint ];
            p2 = points[ intPoint + 1 ];

            if ( intPoint + 2 < l ) {

                p3 = points[ intPoint + 2 ]

            } else {

                // extrapolate last point
                tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 2 ] );
                p3 = tmp;

            }

            if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {

                // init Centripetal / Chordal Catmull-Rom
                var pow = this.type === 'chordal' ? 0.5 : 0.25;
                var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
                var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
                var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

                // safety check for repeated points
                if ( dt1 < 1e-4 ) dt1 = 1.0;
                if ( dt0 < 1e-4 ) dt0 = dt1;
                if ( dt2 < 1e-4 ) dt2 = dt1;

                px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
                py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
                pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

            } else if ( this.type === 'catmullrom' ) {

                var tension = this.tension !== undefined ? this.tension : 0.5;
                px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
                py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
                pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );

            }

            var v = new THREE.Vector3(
                px.calc( weight ),
                py.calc( weight ),
                pz.calc( weight )
            );

            return v;

        }

    );

} )();

// File:src/extras/curves/ClosedSplineCurve3.js

/**************************************************************
 *	Closed Spline 3D curve
 **************************************************************/


THREE.ClosedSplineCurve3 = THREE.Curve.create(

    function ( points /* array of Vector3 */ ) {

        this.points = ( points == undefined ) ? [] : points;

    },

    function ( t ) {

        var points = this.points;
        var point = ( points.length - 0 ) * t; // This needs to be from 0-length +1

        var intPoint = Math.floor( point );
        var weight = point - intPoint;

        intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

        var point0 = points[ ( intPoint - 1 ) % points.length ];
        var point1 = points[ ( intPoint     ) % points.length ];
        var point2 = points[ ( intPoint + 1 ) % points.length ];
        var point3 = points[ ( intPoint + 2 ) % points.length ];

        var interpolate = THREE.CurveUtils.interpolate;

        return new THREE.Vector3(
            interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
            interpolate( point0.y, point1.y, point2.y, point3.y, weight ),
            interpolate( point0.z, point1.z, point2.z, point3.z, weight )
        );

    }

);

// File:src/extras/geometries/BoxGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
 */

THREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

    THREE.Geometry.call( this );

    this.type = 'BoxGeometry';

    this.parameters = {
        width: width,
        height: height,
        depth: depth,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        depthSegments: depthSegments
    };

    this.widthSegments = widthSegments || 1;
    this.heightSegments = heightSegments || 1;
    this.depthSegments = depthSegments || 1;

    var scope = this;

    var width_half = width / 2;
    var height_half = height / 2;
    var depth_half = depth / 2;

    buildPlane( 'z', 'y', - 1, - 1, depth, height, width_half, 0 ); // px
    buildPlane( 'z', 'y',   1, - 1, depth, height, - width_half, 1 ); // nx
    buildPlane( 'x', 'z',   1,   1, width, depth, height_half, 2 ); // py
    buildPlane( 'x', 'z',   1, - 1, width, depth, - height_half, 3 ); // ny
    buildPlane( 'x', 'y',   1, - 1, width, height, depth_half, 4 ); // pz
    buildPlane( 'x', 'y', - 1, - 1, width, height, - depth_half, 5 ); // nz

    function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {

        var w, ix, iy,
            gridX = scope.widthSegments,
            gridY = scope.heightSegments,
            width_half = width / 2,
            height_half = height / 2,
            offset = scope.vertices.length;

        if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {

            w = 'z';

        } else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {

            w = 'y';
            gridY = scope.depthSegments;

        } else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {

            w = 'x';
            gridX = scope.depthSegments;

        }

        var gridX1 = gridX + 1,
            gridY1 = gridY + 1,
            segment_width = width / gridX,
            segment_height = height / gridY,
            normal = new THREE.Vector3();

        normal[ w ] = depth > 0 ? 1 : - 1;

        for ( iy = 0; iy < gridY1; iy ++ ) {

            for ( ix = 0; ix < gridX1; ix ++ ) {

                var vector = new THREE.Vector3();
                vector[ u ] = ( ix * segment_width - width_half ) * udir;
                vector[ v ] = ( iy * segment_height - height_half ) * vdir;
                vector[ w ] = depth;

                scope.vertices.push( vector );

            }

        }

        for ( iy = 0; iy < gridY; iy ++ ) {

            for ( ix = 0; ix < gridX; ix ++ ) {

                var a = ix + gridX1 * iy;
                var b = ix + gridX1 * ( iy + 1 );
                var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
                var d = ( ix + 1 ) + gridX1 * iy;

                var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );
                var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );
                var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );
                var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );

                var face = new THREE.Face3( a + offset, b + offset, d + offset );
                face.normal.copy( normal );
                face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
                face.materialIndex = materialIndex;

                scope.faces.push( face );
                scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

                face = new THREE.Face3( b + offset, c + offset, d + offset );
                face.normal.copy( normal );
                face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
                face.materialIndex = materialIndex;

                scope.faces.push( face );
                scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

            }

        }

    }

    this.mergeVertices();

};

THREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;

THREE.BoxGeometry.prototype.clone = function () {

    var parameters = this.parameters;

    return new THREE.BoxGeometry(
        parameters.width,
        parameters.height,
        parameters.depth,
        parameters.widthSegments,
        parameters.heightSegments,
        parameters.depthSegments
    );

};

THREE.CubeGeometry = THREE.BoxGeometry; // backwards compatibility

// File:src/extras/geometries/CircleGeometry.js

/**
 * @author hughes
 */

THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {

    THREE.Geometry.call( this );

    this.type = 'CircleGeometry';

    this.parameters = {
        radius: radius,
        segments: segments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };

    this.fromBufferGeometry( new THREE.CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );

};

THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;

THREE.CircleGeometry.prototype.clone = function () {

    var parameters = this.parameters;

    return new THREE.CircleGeometry(
        parameters.radius,
        parameters.segments,
        parameters.thetaStart,
        parameters.thetaLength
    );

};

// File:src/extras/geometries/CircleBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {

    THREE.BufferGeometry.call( this );

    this.type = 'CircleBufferGeometry';

    this.parameters = {
        radius: radius,
        segments: segments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };

    radius = radius || 50;
    segments = segments !== undefined ? Math.max( 3, segments ) : 8;

    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

    var vertices = segments + 2;

    var positions = new Float32Array( vertices * 3 );
    var normals = new Float32Array( vertices * 3 );
    var uvs = new Float32Array( vertices * 2 );

    // center data is already zero, but need to set a few extras
    normals[ 2 ] = 1.0;
    uvs[ 0 ] = 0.5;
    uvs[ 1 ] = 0.5;

    for ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {

        var segment = thetaStart + s / segments * thetaLength;

        positions[ i ] = radius * Math.cos( segment );
        positions[ i + 1 ] = radius * Math.sin( segment );

        normals[ i + 2 ] = 1; // normal z

        uvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;
        uvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;

    }

    var indices = [];

    for ( var i = 1; i <= segments; i ++ ) {

        indices.push( i, i + 1, 0 );

    }

    this.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );
    this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
    this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
    this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;

THREE.CircleBufferGeometry.prototype.clone = function () {

    var parameters = this.parameters;

    return new THREE.CircleBufferGeometry(
        parameters.radius,
        parameters.segments,
        parameters.thetaStart,
        parameters.thetaLength
    );

};

// File:src/extras/geometries/CylinderGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

    THREE.Geometry.call( this );

    this.type = 'CylinderGeometry';

    this.parameters = {
        radiusTop: radiusTop,
        radiusBottom: radiusBottom,
        height: height,
        radialSegments: radialSegments,
        heightSegments: heightSegments,
        openEnded: openEnded,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };

    radiusTop = radiusTop !== undefined ? radiusTop : 20;
    radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
    height = height !== undefined ? height : 100;

    radialSegments = radialSegments || 8;
    heightSegments = heightSegments || 1;

    openEnded = openEnded !== undefined ? openEnded : false;
    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;

    var heightHalf = height / 2;

    var x, y, vertices = [], uvs = [];

    for ( y = 0; y <= heightSegments; y ++ ) {

        var verticesRow = [];
        var uvsRow = [];

        var v = y / heightSegments;
        var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

        for ( x = 0; x <= radialSegments; x ++ ) {

            var u = x / radialSegments;

            var vertex = new THREE.Vector3();
            vertex.x = radius * Math.sin( u * thetaLength + thetaStart );
            vertex.y = - v * height + heightHalf;
            vertex.z = radius * Math.cos( u * thetaLength + thetaStart );

            this.vertices.push( vertex );

            verticesRow.push( this.vertices.length - 1 );
            uvsRow.push( new THREE.Vector2( u, 1 - v ) );

        }

        vertices.push( verticesRow );
        uvs.push( uvsRow );

    }

    var tanTheta = ( radiusBottom - radiusTop ) / height;
    var na, nb;

    for ( x = 0; x < radialSegments; x ++ ) {

        if ( radiusTop !== 0 ) {

            na = this.vertices[ vertices[ 0 ][ x ] ].clone();
            nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();

        } else {

            na = this.vertices[ vertices[ 1 ][ x ] ].clone();
            nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();

        }

        na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
        nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();

        for ( y = 0; y < heightSegments; y ++ ) {

            var v1 = vertices[ y ][ x ];
            var v2 = vertices[ y + 1 ][ x ];
            var v3 = vertices[ y + 1 ][ x + 1 ];
            var v4 = vertices[ y ][ x + 1 ];

            var n1 = na.clone();
            var n2 = na.clone();
            var n3 = nb.clone();
            var n4 = nb.clone();

            var uv1 = uvs[ y ][ x ].clone();
            var uv2 = uvs[ y + 1 ][ x ].clone();
            var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
            var uv4 = uvs[ y ][ x + 1 ].clone();

            this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
            this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

            this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
            this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

        }

    }

    // top cap

    if ( openEnded === false && radiusTop > 0 ) {

        this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );

        for ( x = 0; x < radialSegments; x ++ ) {

            var v1 = vertices[ 0 ][ x ];
            var v2 = vertices[ 0 ][ x + 1 ];
            var v3 = this.vertices.length - 1;

            var n1 = new THREE.Vector3( 0, 1, 0 );
            var n2 = new THREE.Vector3( 0, 1, 0 );
            var n3 = new THREE.Vector3( 0, 1, 0 );

            var uv1 = uvs[ 0 ][ x ].clone();
            var uv2 = uvs[ 0 ][ x + 1 ].clone();
            var uv3 = new THREE.Vector2( uv2.x, 0 );

            this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 1 ) );
            this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

        }

    }

    // bottom cap

    if ( openEnded === false && radiusBottom > 0 ) {

        this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );

        for ( x = 0; x < radialSegments; x ++ ) {

            var v1 = vertices[ heightSegments ][ x + 1 ];
            var v2 = vertices[ heightSegments ][ x ];
            var v3 = this.vertices.length - 1;

            var n1 = new THREE.Vector3( 0, - 1, 0 );
            var n2 = new THREE.Vector3( 0, - 1, 0 );
            var n3 = new THREE.Vector3( 0, - 1, 0 );

            var uv1 = uvs[ heightSegments ][ x + 1 ].clone();
            var uv2 = uvs[ heightSegments ][ x ].clone();
            var uv3 = new THREE.Vector2( uv2.x, 1 );

            this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 2 ) );
            this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

        }

    }

    this.computeFaceNormals();

};

THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;

THREE.CylinderGeometry.prototype.clone = function () {

    var parameters = this.parameters;

    return new THREE.CylinderGeometry(
        parameters.radiusTop,
        parameters.radiusBottom,
        parameters.height,
        parameters.radialSegments,
        parameters.heightSegments,
        parameters.openEnded,
        parameters.thetaStart,
        parameters.thetaLength
    );

};

// File:src/extras/geometries/EdgesGeometry.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.EdgesGeometry = function ( geometry, thresholdAngle ) {

    THREE.BufferGeometry.call( this );

    thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

    var thresholdDot = Math.cos( THREE.Math.degToRad( thresholdAngle ) );

    var edge = [ 0, 0 ], hash = {};

    function sortFunction( a, b ) {

        return a - b;

    }

    var keys = [ 'a', 'b', 'c' ];

    var geometry2;

    if ( geometry instanceof THREE.BufferGeometry ) {

        geometry2 = new THREE.Geometry();
        geometry2.fromBufferGeometry( geometry );

    } else {

        geometry2 = geometry.clone();

    }

    geometry2.mergeVertices();
    geometry2.computeFaceNormals();

    var vertices = geometry2.vertices;
    var faces = geometry2.faces;

    for ( var i = 0, l = faces.length; i < l; i ++ ) {

        var face = faces[ i ];

        for ( var j = 0; j < 3; j ++ ) {

            edge[ 0 ] = face[ keys[ j ] ];
            edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
            edge.sort( sortFunction );

            var key = edge.toString();

            if ( hash[ key ] === undefined ) {

                hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };

            } else {

                hash[ key ].face2 = i;

            }

        }

    }

    var coords = [];

    for ( var key in hash ) {

        var h = hash[ key ];

        if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {

            var vertex = vertices[ h.vert1 ];
            coords.push( vertex.x );
            coords.push( vertex.y );
            coords.push( vertex.z );

            vertex = vertices[ h.vert2 ];
            coords.push( vertex.x );
            coords.push( vertex.y );
            coords.push( vertex.z );

        }

    }

    this.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );

};

THREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;

// File:src/extras/geometries/ExtrudeGeometry.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  amount: <int>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline is bevel
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
 *
 *  uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ExtrudeGeometry = function ( shapes, options ) {

    if ( typeof( shapes ) === "undefined" ) {

        shapes = [];
        return;

    }

    THREE.Geometry.call( this );

    this.type = 'ExtrudeGeometry';

    shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

    this.addShapeList( shapes, options );

    this.computeFaceNormals();

    // can't really use automatic vertex normals
    // as then front and back sides get smoothed too
    // should do separate smoothing just for sides

    //this.computeVertexNormals();

    //console.log( "took", ( Date.now() - startTime ) );

};

THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;

THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {

    var sl = shapes.length;

    for ( var s = 0; s < sl; s ++ ) {

        var shape = shapes[ s ];
        this.addShape( shape, options );

    }

};

THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

    var amount = options.amount !== undefined ? options.amount : 100;

    var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
    var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
    var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

    var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

    var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

    var steps = options.steps !== undefined ? options.steps : 1;

    var extrudePath = options.extrudePath;
    var extrudePts, extrudeByPath = false;

    // Use default WorldUVGenerator if no UV generators are specified.
    var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;

    var splineTube, binormal, normal, position2;
    if ( extrudePath ) {

        extrudePts = extrudePath.getSpacedPoints( steps );

        extrudeByPath = true;
        bevelEnabled = false; // bevels not supported for path extrusion

        // SETUP TNB variables

        // Reuse TNB from TubeGeomtry for now.
        // TODO1 - have a .isClosed in spline?

        splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );

        // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

        binormal = new THREE.Vector3();
        normal = new THREE.Vector3();
        position2 = new THREE.Vector3();

    }

    // Safeguards if bevels are not enabled

    if ( ! bevelEnabled ) {

        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;

    }

    // Variables initialization

    var ahole, h, hl; // looping of holes
    var scope = this;

    var shapesOffset = this.vertices.length;

    var shapePoints = shape.extractPoints( curveSegments );

    var vertices = shapePoints.shape;
    var holes = shapePoints.holes;

    var reverse = ! THREE.ShapeUtils.isClockWise( vertices );

    if ( reverse ) {

        vertices = vertices.reverse();

        // Maybe we should also check if holes are in the opposite direction, just to be safe ...

        for ( h = 0, hl = holes.length; h < hl; h ++ ) {

            ahole = holes[ h ];

            if ( THREE.ShapeUtils.isClockWise( ahole ) ) {

                holes[ h ] = ahole.reverse();

            }

        }

        reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

    }


    var faces = THREE.ShapeUtils.triangulateShape( vertices, holes );

    /* Vertices */

    var contour = vertices; // vertices has all points but contour has only points of circumference

    for ( h = 0, hl = holes.length; h < hl; h ++ ) {

        ahole = holes[ h ];

        vertices = vertices.concat( ahole );

    }


    function scalePt2 ( pt, vec, size ) {

        if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

        return vec.clone().multiplyScalar( size ).add( pt );

    }

    var b, bs, t, z,
        vert, vlen = vertices.length,
        face, flen = faces.length;


    // Find directions for point movement


    function getBevelVec( inPt, inPrev, inNext ) {

        // computes for inPt the corresponding point inPt' on a new contour
        //   shifted by 1 unit (length of normalized vector) to the left
        // if we walk along contour clockwise, this new contour is outside the old one
        //
        // inPt' is the intersection of the two lines parallel to the two
        //  adjacent edges of inPt at a distance of 1 unit on the left side.

        var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt

        // good reading for geometry algorithms (here: line-line intersection)
        // http://geomalgorithms.com/a05-_intersect-1.html

        var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
        var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;

        var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

        // check for collinear edges
        var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

        if ( Math.abs( collinear0 ) > Number.EPSILON ) {

            // not collinear

            // length of vectors for normalizing

            var v_prev_len = Math.sqrt( v_prev_lensq );
            var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

            // shift adjacent points by unit vectors to the left

            var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
            var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

            var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
            var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

            // scaling factor for v_prev to intersection point

            var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
                ( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
                ( v_prev_x * v_next_y - v_prev_y * v_next_x );

            // vector from inPt to intersection point

            v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
            v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

            // Don't normalize!, otherwise sharp corners become ugly
            //  but prevent crazy spikes
            var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
            if ( v_trans_lensq <= 2 ) {

                return	new THREE.Vector2( v_trans_x, v_trans_y );

            } else {

                shrink_by = Math.sqrt( v_trans_lensq / 2 );

            }

        } else {

            // handle special case of collinear edges

            var direction_eq = false;		// assumes: opposite
            if ( v_prev_x > Number.EPSILON ) {

                if ( v_next_x > Number.EPSILON ) {

                    direction_eq = true;

                }

            } else {

                if ( v_prev_x < - Number.EPSILON ) {

                    if ( v_next_x < - Number.EPSILON ) {

                        direction_eq = true;

                    }

                } else {

                    if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

                        direction_eq = true;

                    }

                }

            }

            if ( direction_eq ) {

                // console.log("Warning: lines are a straight sequence");
                v_trans_x = - v_prev_y;
                v_trans_y =  v_prev_x;
                shrink_by = Math.sqrt( v_prev_lensq );

            } else {

                // console.log("Warning: lines are a straight spike");
                v_trans_x = v_prev_x;
                v_trans_y = v_prev_y;
                shrink_by = Math.sqrt( v_prev_lensq / 2 );

            }

        }

        return	new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

    }


    var contourMovements = [];

    for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

        if ( j === il ) j = 0;
        if ( k === il ) k = 0;

        //  (j)---(i)---(k)
        // console.log('i,j,k', i, j , k)

        contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

    }

    var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

    for ( h = 0, hl = holes.length; h < hl; h ++ ) {

        ahole = holes[ h ];

        oneHoleMovements = [];

        for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

            if ( j === il ) j = 0;
            if ( k === il ) k = 0;

            //  (j)---(i)---(k)
            oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

        }

        holesMovements.push( oneHoleMovements );
        verticesMovements = verticesMovements.concat( oneHoleMovements );

    }


    // Loop bevelSegments, 1 for the front, 1 for the back

    for ( b = 0; b < bevelSegments; b ++ ) {

        //for ( b = bevelSegments; b > 0; b -- ) {

        t = b / bevelSegments;
        z = bevelThickness * ( 1 - t );

        //z = bevelThickness * t;
        bs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ); // curved
        //bs = bevelSize * t; // linear

        // contract shape

        for ( i = 0, il = contour.length; i < il; i ++ ) {

            vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

            v( vert.x, vert.y,  - z );

        }

        // expand holes

        for ( h = 0, hl = holes.length; h < hl; h ++ ) {

            ahole = holes[ h ];
            oneHoleMovements = holesMovements[ h ];

            for ( i = 0, il = ahole.length; i < il; i ++ ) {

                vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

                v( vert.x, vert.y,  - z );

            }

        }

    }

    bs = bevelSize;

    // Back facing vertices

    for ( i = 0; i < vlen; i ++ ) {

        vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

        if ( ! extrudeByPath ) {

            v( vert.x, vert.y, 0 );

        } else {

            // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

            normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
            binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

            position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

            v( position2.x, position2.y, position2.z );

        }

    }

    // Add stepped vertices...
    // Including front facing vertices

    var s;

    for ( s = 1; s <= steps; s ++ ) {

        for ( i = 0; i < vlen; i ++ ) {

            vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

            if ( ! extrudeByPath ) {

                v( vert.x, vert.y, amount / steps * s );

            } else {

                // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

                normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
                binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

                position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

                v( position2.x, position2.y, position2.z );

            }

        }

    }


    // Add bevel segments planes

    //for ( b = 1; b <= bevelSegments; b ++ ) {
    for ( b = bevelSegments - 1; b >= 0; b -- ) {

        t = b / bevelSegments;
        z = bevelThickness * ( 1 - t );
        //bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
        bs = bevelSize * Math.sin ( t * Math.PI / 2 );

        // contract shape

        for ( i = 0, il = contour.length; i < il; i ++ ) {

            vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
            v( vert.x, vert.y,  amount + z );

        }

        // expand holes

        for ( h = 0, hl = holes.length; h < hl; h ++ ) {

            ahole = holes[ h ];
            oneHoleMovements = holesMovements[ h ];

            for ( i = 0, il = ahole.length; i < il; i ++ ) {

                vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

                if ( ! extrudeByPath ) {

                    v( vert.x, vert.y,  amount + z );

                } else {

                    v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

                }

            }

        }

    }

    /* Faces */

    // Top and bottom faces

    buildLidFaces();

    // Sides faces

    buildSideFaces();


    /////  Internal functions

    function buildLidFaces() {

        if ( bevelEnabled ) {

            var layer = 0; // steps + 1
            var offset = vlen * layer;

            // Bottom faces

            for ( i = 0; i < flen; i ++ ) {

                face = faces[ i ];
                f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

            }

            layer = steps + bevelSegments * 2;
            offset = vlen * layer;

            // Top faces

            for ( i = 0; i < flen; i ++ ) {

                face = faces[ i ];
                f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

            }

        } else {

            // Bottom faces

            for ( i = 0; i < flen; i ++ ) {

                face = faces[ i ];
                f3( face[ 2 ], face[ 1 ], face[ 0 ] );

            }

            // Top faces

            for ( i = 0; i < flen; i ++ ) {

                face = faces[ i ];
                f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

            }

        }

    }

    // Create faces for the z-sides of the shape

    function buildSideFaces() {

        var layeroffset = 0;
        sidewalls( contour, layeroffset );
        layeroffset += contour.length;

        for ( h = 0, hl = holes.length; h < hl; h ++ ) {

            ahole = holes[ h ];
            sidewalls( ahole, layeroffset );

            //, true
            layeroffset += ahole.length;

        }

    }

    function sidewalls( contour, layeroffset ) {

        var j, k;
        i = contour.length;

        while ( -- i >= 0 ) {

            j = i;
            k = i - 1;
            if ( k < 0 ) k = contour.length - 1;

            //console.log('b', i,j, i-1, k,vertices.length);

            var s = 0, sl = steps  + bevelSegments * 2;

            for ( s = 0; s < sl; s ++ ) {

                var slen1 = vlen * s;
                var slen2 = vlen * ( s + 1 );

                var a = layeroffset + j + slen1,
                    b = layeroffset + k + slen1,
                    c = layeroffset + k + slen2,
                    d = layeroffset + j + slen2;

                f4( a, b, c, d, contour, s, sl, j, k );

            }

        }

    }


    function v( x, y, z ) {

        scope.vertices.push( new THREE.Vector3( x, y, z ) );

    }

    function f3( a, b, c ) {

        a += shapesOffset;
        b += shapesOffset;
        c += shapesOffset;

        scope.faces.push( new THREE.Face3( a, b, c, null, null, 0 ) );

        var uvs = uvgen.generateTopUV( scope, a, b, c );

        scope.faceVertexUvs[ 0 ].push( uvs );

    }

    function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

        a += shapesOffset;
        b += shapesOffset;
        c += shapesOffset;
        d += shapesOffset;

        scope.faces.push( new THREE.Face3( a, b, d, null, null, 1 ) );
        scope.faces.push( new THREE.Face3( b, c, d, null, null, 1 ) );

        var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

        scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
        scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

    }

};

THREE.ExtrudeGeometry.WorldUVGenerator = {

    generateTopUV: function ( geometry, indexA, indexB, indexC ) {

        var vertices = geometry.vertices;

        var a = vertices[ indexA ];
        var b = vertices[ indexB ];
        var c = vertices[ indexC ];

        return [
            new THREE.Vector2( a.x, a.y ),
            new THREE.Vector2( b.x, b.y ),
            new THREE.Vector2( c.x, c.y )
        ];

    },

    generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {

        var vertices = geometry.vertices;

        var a = vertices[ indexA ];
        var b = vertices[ indexB ];
        var c = vertices[ indexC ];
        var d = vertices[ indexD ];

        if ( Math.abs( a.y - b.y ) < 0.01 ) {

            return [
                new THREE.Vector2( a.x, 1 - a.z ),
                new THREE.Vector2( b.x, 1 - b.z ),
                new THREE.Vector2( c.x, 1 - c.z ),
                new THREE.Vector2( d.x, 1 - d.z )
            ];

        } else {

            return [
                new THREE.Vector2( a.y, 1 - a.z ),
                new THREE.Vector2( b.y, 1 - b.z ),
                new THREE.Vector2( c.y, 1 - c.z ),
                new THREE.Vector2( d.y, 1 - d.z )
            ];

        }

    }
};

// File:src/extras/geometries/ShapeGeometry.js

/**
 * @author jonobr1 / http://jonobr1.com
 *
 * Creates a one-sided polygonal geometry from a path shape. Similar to
 * ExtrudeGeometry.
 *
 * parameters = {
 *
 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
 *
 *	material: <int> // material index for front and back faces
 *	uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ShapeGeometry = function ( shapes, options ) {

    THREE.Geometry.call( this );

    this.type = 'ShapeGeometry';

    if ( Array.isArray( shapes ) === false ) shapes = [ shapes ];

    this.addShapeList( shapes, options );

    this.computeFaceNormals();

};

THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;

/**
 * Add an array of shapes to THREE.ShapeGeometry.
 */
THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {

    for ( var i = 0, l = shapes.length; i < l; i ++ ) {

        this.addShape( shapes[ i ], options );

    }

    return this;

};

/**
 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
 */
THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {

    if ( options === undefined ) options = {};
    var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

    var material = options.material;
    var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

    //

    var i, l, hole;

    var shapesOffset = this.vertices.length;
    var shapePoints = shape.extractPoints( curveSegments );

    var vertices = shapePoints.shape;
    var holes = shapePoints.holes;

    var reverse = ! THREE.ShapeUtils.isClockWise( vertices );

    if ( reverse ) {

        vertices = vertices.reverse();

        // Maybe we should also check if holes are in the opposite direction, just to be safe...

        for ( i = 0, l = holes.length; i < l; i ++ ) {

            hole = holes[ i ];

            if ( THREE.ShapeUtils.isClockWise( hole ) ) {

                holes[ i ] = hole.reverse();

            }

        }

        reverse = false;

    }

    var faces = THREE.ShapeUtils.triangulateShape( vertices, holes );

    // Vertices

    for ( i = 0, l = holes.length; i < l; i ++ ) {

        hole = holes[ i ];
        vertices = vertices.concat( hole );

    }

    //

    var vert, vlen = vertices.length;
    var face, flen = faces.length;

    for ( i = 0; i < vlen; i ++ ) {

        vert = vertices[ i ];

        this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );

    }

    for ( i = 0; i < flen; i ++ ) {

        face = faces[ i ];

        var a = face[ 0 ] + shapesOffset;
        var b = face[ 1 ] + shapesOffset;
        var c = face[ 2 ] + shapesOffset;

        this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
        this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );

    }

};

// File:src/extras/geometries/LatheGeometry.js

/**
 * @author astrodud / http://astrodud.isgreat.org/
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://clara.io
 */

// points - to create a closed torus, one must use a set of points 
//    like so: [ a, b, c, d, a ], see first is the same as last.
// segments - the number of circumference segments to create
// phiStart - the starting radian
// phiLength - the radian (0 to 2*PI) range of the lathed section
//    2*pi is a closed lathe, less than 2PI is a portion.

THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {

    THREE.Geometry.call( this );

    this.type = 'LatheGeometry';

    this.parameters = {
        points: points,
        segments: segments,
        phiStart: phiStart,
        phiLength: phiLength
    };

    segments = segments || 12;
    phiStart = phiStart || 0;
    phiLength = phiLength || 2 * Math.PI;

    var inversePointLength = 1.0 / ( points.length - 1 );
    var inverseSegments = 1.0 / segments;

    for ( var i = 0, il = segments; i <= il; i ++ ) {

        var phi = phiStart + i * inverseSegments * phiLength;

        var c = Math.cos( phi ),
            s = Math.sin( phi );

        for ( var j = 0, jl = points.length; j < jl; j ++ ) {

            var pt = points[ j ];

            var vertex = new THREE.Vector3();

            vertex.x = c * pt.x - s * pt.y;
            vertex.y = s * pt.x + c * pt.y;
            vertex.z = pt.z;

            this.vertices.push( vertex );

        }

    }

    var np = points.length;

    for ( var i = 0, il = segments; i < il; i ++ ) {

        for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {

            var base = j + np * i;
            var a = base;
            var b = base + np;
            var c = base + 1 + np;
            var d = base + 1;

            var u0 = i * inverseSegments;
            var v0 = j * inversePointLength;
            var u1 = u0 + inverseSegments;
            var v1 = v0 + inversePointLength;

            this.faces.push( new THREE.Face3( a, b, d ) );

            this.faceVertexUvs[ 0 ].push( [

                new THREE.Vector2( u0, v0 ),
                new THREE.Vector2( u1, v0 ),
                new THREE.Vector2( u0, v1 )

            ] );

            this.faces.push( new THREE.Face3( b, c, d ) );

            this.faceVertexUvs[ 0 ].push( [

                new THREE.Vector2( u1, v0 ),
                new THREE.Vector2( u1, v1 ),
                new THREE.Vector2( u0, v1 )

            ] );


        }

    }

    this.mergeVertices();
    this.computeFaceNormals();
    this.computeVertexNormals();

};

THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;

// File:src/extras/geometries/PlaneGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {

    THREE.Geometry.call( this );

    this.type = 'PlaneGeometry';

    this.parameters = {
        width: width,
        height: height,
        widthSegments: widthSegments,
        heightSegments: heightSegments
    };

    this.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

};

THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;

THREE.PlaneGeometry.prototype.clone = function () {

    var parameters = this.parameters;

    return new THREE.PlaneGeometry(
        parameters.width,
        parameters.height,
        parameters.widthSegments,
        parameters.heightSegments
    );

};

// File:src/extras/geometries/PlaneBufferGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {

    THREE.BufferGeometry.call( this );

    this.type = 'PlaneBufferGeometry';

    this.parameters = {
        width: width,
        height: height,
        widthSegments: widthSegments,
        heightSegments: heightSegments
    };

    var width_half = width / 2;
    var height_half = height / 2;

    var gridX = Math.floor( widthSegments ) || 1;
    var gridY = Math.floor( heightSegments ) || 1;

    var gridX1 = gridX + 1;
    var gridY1 = gridY + 1;

    var segment_width = width / gridX;
    var segment_height = height / gridY;

    var vertices = new Float32Array( gridX1 * gridY1 * 3 );
    var normals = new Float32Array( gridX1 * gridY1 * 3 );
    var uvs = new Float32Array( gridX1 * gridY1 * 2 );

    var offset = 0;
    var offset2 = 0;

    for ( var iy = 0; iy < gridY1; iy ++ ) {

        var y = iy * segment_height - height_half;

        for ( var ix = 0; ix < gridX1; ix ++ ) {

            var x = ix * segment_width - width_half;

            vertices[ offset ] = x;
            vertices[ offset + 1 ] = - y;

            normals[ offset + 2 ] = 1;

            uvs[ offset2 ] = ix / gridX;
            uvs[ offset2 + 1 ] = 1 - ( iy / gridY );

            offset += 3;
            offset2 += 2;

        }

    }

    offset = 0;

    var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

    for ( var iy = 0; iy < gridY; iy ++ ) {

        for ( var ix = 0; ix < gridX; ix ++ ) {

            var a = ix + gridX1 * iy;
            var b = ix + gridX1 * ( iy + 1 );
            var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
            var d = ( ix + 1 ) + gridX1 * iy;

            indices[ offset ] = a;
            indices[ offset + 1 ] = b;
            indices[ offset + 2 ] = d;

            indices[ offset + 3 ] = b;
            indices[ offset + 4 ] = c;
            indices[ offset + 5 ] = d;

            offset += 6;

        }

    }

    this.setIndex( new THREE.BufferAttribute( indices, 1 ) );
    this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
    this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
    this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

};

THREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;

THREE.PlaneBufferGeometry.prototype.clone = function () {

    var parameters = this.parameters;

    return new THREE.PlaneBufferGeometry(
        parameters.width,
        parameters.height,
        parameters.widthSegments,
        parameters.heightSegments
    );

};

// File:src/extras/geometries/RingGeometry.js

/**
 * @author Kaleb Murphy
 */

THREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

    THREE.Geometry.call( this );

    this.type = 'RingGeometry';

    this.parameters = {
        innerRadius: innerRadius,
        outerRadius: outerRadius,
        thetaSegments: thetaSegments,
        phiSegments: phiSegments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };

    innerRadius = innerRadius || 0;
    outerRadius = outerRadius || 50;

    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

    thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
    phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;

    var i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );

    for ( i = 0; i < phiSegments + 1; i ++ ) {

        // concentric circles inside ring

        for ( o = 0; o < thetaSegments + 1; o ++ ) {

            // number of segments per circle

            var vertex = new THREE.Vector3();
            var segment = thetaStart + o / thetaSegments * thetaLength;
            vertex.x = radius * Math.cos( segment );
            vertex.y = radius * Math.sin( segment );

            this.vertices.push( vertex );
            uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );

        }

        radius += radiusStep;

    }

    var n = new THREE.Vector3( 0, 0, 1 );

    for ( i = 0; i < phiSegments; i ++ ) {

        // concentric circles inside ring

        var thetaSegment = i * ( thetaSegments + 1 );

        for ( o = 0; o < thetaSegments ; o ++ ) {

            // number of segments per circle

            var segment = o + thetaSegment;

            var v1 = segment;
            var v2 = segment + thetaSegments + 1;
            var v3 = segment + thetaSegments + 2;

            this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
            this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );

            v1 = segment;
            v2 = segment + thetaSegments + 2;
            v3 = segment + 1;

            this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
            this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );

        }

    }

    this.computeFaceNormals();

    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;

THREE.RingGeometry.prototype.clone = function () {

    var parameters = this.parameters;

    return new THREE.RingGeometry(
        parameters.innerRadius,
        parameters.outerRadius,
        parameters.thetaSegments,
        parameters.phiSegments,
        parameters.thetaStart,
        parameters.thetaLength
    );

};

// File:src/extras/geometries/SphereGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

    THREE.Geometry.call( this );

    this.type = 'SphereGeometry';

    this.parameters = {
        radius: radius,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        phiStart: phiStart,
        phiLength: phiLength,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };

    this.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );

};

THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;

THREE.SphereGeometry.prototype.clone = function () {

    var parameters = this.parameters;

    return new THREE.SphereGeometry(
        parameters.radius,
        parameters.widthSegments,
        parameters.heightSegments,
        parameters.phiStart,
        parameters.phiLength,
        parameters.thetaStart,
        parameters.thetaLength
    );

};

// File:src/extras/geometries/SphereBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * based on THREE.SphereGeometry
 */

THREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

    THREE.BufferGeometry.call( this );

    this.type = 'SphereBufferGeometry';

    this.parameters = {
        radius: radius,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        phiStart: phiStart,
        phiLength: phiLength,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };

    radius = radius || 50;

    widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
    heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

    phiStart = phiStart !== undefined ? phiStart : 0;
    phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

    var thetaEnd = thetaStart + thetaLength;

    var vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );

    var positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    var normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    var uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

    var index = 0, vertices = [], normal = new THREE.Vector3();

    for ( var y = 0; y <= heightSegments; y ++ ) {

        var verticesRow = [];

        var v = y / heightSegments;

        for ( var x = 0; x <= widthSegments; x ++ ) {

            var u = x / widthSegments;

            var px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
            var py = radius * Math.cos( thetaStart + v * thetaLength );
            var pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

            normal.set( px, py, pz ).normalize();

            positions.setXYZ( index, px, py, pz );
            normals.setXYZ( index, normal.x, normal.y, normal.z );
            uvs.setXY( index, u, 1 - v );

            verticesRow.push( index );

            index ++;

        }

        vertices.push( verticesRow );

    }

    var indices = [];

    for ( var y = 0; y < heightSegments; y ++ ) {

        for ( var x = 0; x < widthSegments; x ++ ) {

            var v1 = vertices[ y ][ x + 1 ];
            var v2 = vertices[ y ][ x ];
            var v3 = vertices[ y + 1 ][ x ];
            var v4 = vertices[ y + 1 ][ x + 1 ];

            if ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );
            if ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );

        }

    }

    this.setIndex( new ( positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute )( indices, 1 ) );
    this.addAttribute( 'position', positions );
    this.addAttribute( 'normal', normals );
    this.addAttribute( 'uv', uvs );

    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;

THREE.SphereBufferGeometry.prototype.clone = function () {

    var parameters = this.parameters;

    return new THREE.SphereBufferGeometry(
        parameters.radius,
        parameters.widthSegments,
        parameters.heightSegments,
        parameters.phiStart,
        parameters.phiLength,
        parameters.thetaStart,
        parameters.thetaLength
    );

};

// File:src/extras/geometries/TorusGeometry.js

/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
 */

THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {

    THREE.Geometry.call( this );

    this.type = 'TorusGeometry';

    this.parameters = {
        radius: radius,
        tube: tube,
        radialSegments: radialSegments,
        tubularSegments: tubularSegments,
        arc: arc
    };

    radius = radius || 100;
    tube = tube || 40;
    radialSegments = radialSegments || 8;
    tubularSegments = tubularSegments || 6;
    arc = arc || Math.PI * 2;

    var center = new THREE.Vector3(), uvs = [], normals = [];

    for ( var j = 0; j <= radialSegments; j ++ ) {

        for ( var i = 0; i <= tubularSegments; i ++ ) {

            var u = i / tubularSegments * arc;
            var v = j / radialSegments * Math.PI * 2;

            center.x = radius * Math.cos( u );
            center.y = radius * Math.sin( u );

            var vertex = new THREE.Vector3();
            vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
            vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
            vertex.z = tube * Math.sin( v );

            this.vertices.push( vertex );

            uvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );
            normals.push( vertex.clone().sub( center ).normalize() );

        }

    }

    for ( var j = 1; j <= radialSegments; j ++ ) {

        for ( var i = 1; i <= tubularSegments; i ++ ) {

            var a = ( tubularSegments + 1 ) * j + i - 1;
            var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
            var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
            var d = ( tubularSegments + 1 ) * j + i;

            var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );
            this.faces.push( face );
            this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );

            face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );
            this.faces.push( face );
            this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );

        }

    }

    this.computeFaceNormals();

};

THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;

THREE.TorusGeometry.prototype.clone = function () {

    var parameters = this.parameters;

    return new THREE.TorusGeometry(
        parameters.radius,
        parameters.tube,
        parameters.radialSegments,
        parameters.tubularSegments,
        parameters.arc
    );

};

// File:src/extras/geometries/TorusKnotGeometry.js

/**
 * @author oosmoxiecode
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
 */

THREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {

    THREE.Geometry.call( this );

    this.type = 'TorusKnotGeometry';

    this.parameters = {
        radius: radius,
        tube: tube,
        radialSegments: radialSegments,
        tubularSegments: tubularSegments,
        p: p,
        q: q,
        heightScale: heightScale
    };

    radius = radius || 100;
    tube = tube || 40;
    radialSegments = radialSegments || 64;
    tubularSegments = tubularSegments || 8;
    p = p || 2;
    q = q || 3;
    heightScale = heightScale || 1;

    var grid = new Array( radialSegments );
    var tang = new THREE.Vector3();
    var n = new THREE.Vector3();
    var bitan = new THREE.Vector3();

    for ( var i = 0; i < radialSegments; ++ i ) {

        grid[ i ] = new Array( tubularSegments );
        var u = i / radialSegments * 2 * p * Math.PI;
        var p1 = getPos( u, q, p, radius, heightScale );
        var p2 = getPos( u + 0.01, q, p, radius, heightScale );
        tang.subVectors( p2, p1 );
        n.addVectors( p2, p1 );

        bitan.crossVectors( tang, n );
        n.crossVectors( bitan, tang );
        bitan.normalize();
        n.normalize();

        for ( var j = 0; j < tubularSegments; ++ j ) {

            var v = j / tubularSegments * 2 * Math.PI;
            var cx = - tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
            var cy = tube * Math.sin( v );

            var pos = new THREE.Vector3();
            pos.x = p1.x + cx * n.x + cy * bitan.x;
            pos.y = p1.y + cx * n.y + cy * bitan.y;
            pos.z = p1.z + cx * n.z + cy * bitan.z;

            grid[ i ][ j ] = this.vertices.push( pos ) - 1;

        }

    }

    for ( var i = 0; i < radialSegments; ++ i ) {

        for ( var j = 0; j < tubularSegments; ++ j ) {

            var ip = ( i + 1 ) % radialSegments;
            var jp = ( j + 1 ) % tubularSegments;

            var a = grid[ i ][ j ];
            var b = grid[ ip ][ j ];
            var c = grid[ ip ][ jp ];
            var d = grid[ i ][ jp ];

            var uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );
            var uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );
            var uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );
            var uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );

            this.faces.push( new THREE.Face3( a, b, d ) );
            this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

            this.faces.push( new THREE.Face3( b, c, d ) );
            this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

        }

    }

    this.computeFaceNormals();
    this.computeVertexNormals();

    function getPos( u, in_q, in_p, radius, heightScale ) {

        var cu = Math.cos( u );
        var su = Math.sin( u );
        var quOverP = in_q / in_p * u;
        var cs = Math.cos( quOverP );

        var tx = radius * ( 2 + cs ) * 0.5 * cu;
        var ty = radius * ( 2 + cs ) * su * 0.5;
        var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;

        return new THREE.Vector3( tx, ty, tz );

    }

};

THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;

THREE.TorusKnotGeometry.prototype.clone = function () {

    var parameters = this.parameters;

    return new THREE.TorusKnotGeometry(
        parameters.radius,
        parameters.tube,
        parameters.radialSegments,
        parameters.tubularSegments,
        parameters.p,
        parameters.q,
        parameters.heightScale
    );

};

// File:src/extras/geometries/TubeGeometry.js

/**
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 * @author jonobr1 / https://github.com/jonobr1
 *
 * Modified from the TorusKnotGeometry by @oosmoxiecode
 *
 * Creates a tube which extrudes along a 3d spline
 *
 * Uses parallel transport frames as described in
 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
 */

THREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {

    THREE.Geometry.call( this );

    this.type = 'TubeGeometry';

    this.parameters = {
        path: path,
        segments: segments,
        radius: radius,
        radialSegments: radialSegments,
        closed: closed,
        taper: taper
    };

    segments = segments || 64;
    radius = radius || 1;
    radialSegments = radialSegments || 8;
    closed = closed || false;
    taper = taper || THREE.TubeGeometry.NoTaper;

    var grid = [];

    var scope = this,

        tangent,
        normal,
        binormal,

        numpoints = segments + 1,

        u, v, r,

        cx, cy,
        pos, pos2 = new THREE.Vector3(),
        i, j,
        ip, jp,
        a, b, c, d,
        uva, uvb, uvc, uvd;

    var frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),
        tangents = frames.tangents,
        normals = frames.normals,
        binormals = frames.binormals;

    // proxy internals
    this.tangents = tangents;
    this.normals = normals;
    this.binormals = binormals;

    function vert( x, y, z ) {

        return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;

    }

    // construct the grid

    for ( i = 0; i < numpoints; i ++ ) {

        grid[ i ] = [];

        u = i / ( numpoints - 1 );

        pos = path.getPointAt( u );

        tangent = tangents[ i ];
        normal = normals[ i ];
        binormal = binormals[ i ];

        r = radius * taper( u );

        for ( j = 0; j < radialSegments; j ++ ) {

            v = j / radialSegments * 2 * Math.PI;

            cx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
            cy = r * Math.sin( v );

            pos2.copy( pos );
            pos2.x += cx * normal.x + cy * binormal.x;
            pos2.y += cx * normal.y + cy * binormal.y;
            pos2.z += cx * normal.z + cy * binormal.z;

            grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

        }

    }


    // construct the mesh

    for ( i = 0; i < segments; i ++ ) {

        for ( j = 0; j < radialSegments; j ++ ) {

            ip = ( closed ) ? ( i + 1 ) % segments : i + 1;
            jp = ( j + 1 ) % radialSegments;

            a = grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
            b = grid[ ip ][ j ];
            c = grid[ ip ][ jp ];
            d = grid[ i ][ jp ];

            uva = new THREE.Vector2( i / segments, j / radialSegments );
            uvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );
            uvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
            uvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );

            this.faces.push( new THREE.Face3( a, b, d ) );
            this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

            this.faces.push( new THREE.Face3( b, c, d ) );
            this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

        }

    }

    this.computeFaceNormals();
    this.computeVertexNormals();

};

THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;
THREE.TubeGeometry.prototype.clone = function() {

    return new this.constructor( this.parameters.path,
        this.parameters.segments, this.parameters.radius, this.parameters.radialSegments,
        this.parameters.closed, this.parameters.taper
    );

};

THREE.TubeGeometry.NoTaper = function ( u ) {

    return 1;

};

THREE.TubeGeometry.SinusoidalTaper = function ( u ) {

    return Math.sin( Math.PI * u );

};

// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
THREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {

    var	normal = new THREE.Vector3(),

        tangents = [],
        normals = [],
        binormals = [],

        vec = new THREE.Vector3(),
        mat = new THREE.Matrix4(),

        numpoints = segments + 1,
        theta,
        smallest,

        tx, ty, tz,
        i, u;


    // expose internals
    this.tangents = tangents;
    this.normals = normals;
    this.binormals = binormals;

    // compute the tangent vectors for each segment on the path

    for ( i = 0; i < numpoints; i ++ ) {

        u = i / ( numpoints - 1 );

        tangents[ i ] = path.getTangentAt( u );
        tangents[ i ].normalize();

    }

    initialNormal3();

    /*
     function initialNormal1(lastBinormal) {
     // fixed start binormal. Has dangers of 0 vectors
     normals[ 0 ] = new THREE.Vector3();
     binormals[ 0 ] = new THREE.Vector3();
     if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
     normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
     binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
     }

     function initialNormal2() {

     // This uses the Frenet-Serret formula for deriving binormal
     var t2 = path.getTangentAt( epsilon );

     normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
     binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

     normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
     binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

     }
     */

    function initialNormal3() {

        // select an initial normal vector perpendicular to the first tangent vector,
        // and in the direction of the smallest tangent xyz component

        normals[ 0 ] = new THREE.Vector3();
        binormals[ 0 ] = new THREE.Vector3();
        smallest = Number.MAX_VALUE;
        tx = Math.abs( tangents[ 0 ].x );
        ty = Math.abs( tangents[ 0 ].y );
        tz = Math.abs( tangents[ 0 ].z );

        if ( tx <= smallest ) {

            smallest = tx;
            normal.set( 1, 0, 0 );

        }

        if ( ty <= smallest ) {

            smallest = ty;
            normal.set( 0, 1, 0 );

        }

        if ( tz <= smallest ) {

            normal.set( 0, 0, 1 );

        }

        vec.crossVectors( tangents[ 0 ], normal ).normalize();

        normals[ 0 ].crossVectors( tangents[ 0 ], vec );
        binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );

    }


    // compute the slowly-varying normal and binormal vectors for each segment on the path

    for ( i = 1; i < numpoints; i ++ ) {

        normals[ i ] = normals[ i - 1 ].clone();

        binormals[ i ] = binormals[ i - 1 ].clone();

        vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

        if ( vec.length() > Number.EPSILON ) {

            vec.normalize();

            theta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

            normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

        }

        binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

    }


    // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

    if ( closed ) {

        theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );
        theta /= ( numpoints - 1 );

        if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {

            theta = - theta;

        }

        for ( i = 1; i < numpoints; i ++ ) {

            // twist a little...
            normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
            binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

        }

    }

};

// File:src/extras/geometries/PolyhedronGeometry.js

/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {

    THREE.Geometry.call( this );

    this.type = 'PolyhedronGeometry';

    this.parameters = {
        vertices: vertices,
        indices: indices,
        radius: radius,
        detail: detail
    };

    radius = radius || 1;
    detail = detail || 0;

    var that = this;

    for ( var i = 0, l = vertices.length; i < l; i += 3 ) {

        prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

    }

    var p = this.vertices;

    var faces = [];

    for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {

        var v1 = p[ indices[ i ] ];
        var v2 = p[ indices[ i + 1 ] ];
        var v3 = p[ indices[ i + 2 ] ];

        faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, j );

    }

    var centroid = new THREE.Vector3();

    for ( var i = 0, l = faces.length; i < l; i ++ ) {

        subdivide( faces[ i ], detail );

    }


    // Handle case when face straddles the seam

    for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {

        var uvs = this.faceVertexUvs[ 0 ][ i ];

        var x0 = uvs[ 0 ].x;
        var x1 = uvs[ 1 ].x;
        var x2 = uvs[ 2 ].x;

        var max = Math.max( x0, x1, x2 );
        var min = Math.min( x0, x1, x2 );

        if ( max > 0.9 && min < 0.1 ) {

            // 0.9 is somewhat arbitrary

            if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
            if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
            if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

        }

    }


    // Apply radius

    for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {

        this.vertices[ i ].multiplyScalar( radius );

    }


    // Merge vertices

    this.mergeVertices();

    this.computeFaceNormals();

    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );


    // Project vector onto sphere's surface

    function prepare( vector ) {

        var vertex = vector.normalize().clone();
        vertex.index = that.vertices.push( vertex ) - 1;

        // Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

        var u = azimuth( vector ) / 2 / Math.PI + 0.5;
        var v = inclination( vector ) / Math.PI + 0.5;
        vertex.uv = new THREE.Vector2( u, 1 - v );

        return vertex;

    }


    // Approximate a curved face with recursively sub-divided triangles.

    function make( v1, v2, v3, materialIndex ) {

        var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, materialIndex );
        that.faces.push( face );

        centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );

        var azi = azimuth( centroid );

        that.faceVertexUvs[ 0 ].push( [
            correctUV( v1.uv, v1, azi ),
            correctUV( v2.uv, v2, azi ),
            correctUV( v3.uv, v3, azi )
        ] );

    }


    // Analytically subdivide a face to the required detail level.

    function subdivide( face, detail ) {

        var cols = Math.pow( 2, detail );
        var a = prepare( that.vertices[ face.a ] );
        var b = prepare( that.vertices[ face.b ] );
        var c = prepare( that.vertices[ face.c ] );
        var v = [];

        var materialIndex = face.materialIndex;

        // Construct all of the vertices for this subdivision.

        for ( var i = 0 ; i <= cols; i ++ ) {

            v[ i ] = [];

            var aj = prepare( a.clone().lerp( c, i / cols ) );
            var bj = prepare( b.clone().lerp( c, i / cols ) );
            var rows = cols - i;

            for ( var j = 0; j <= rows; j ++ ) {

                if ( j === 0 && i === cols ) {

                    v[ i ][ j ] = aj;

                } else {

                    v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

                }

            }

        }

        // Construct all of the faces.

        for ( var i = 0; i < cols ; i ++ ) {

            for ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

                var k = Math.floor( j / 2 );

                if ( j % 2 === 0 ) {

                    make(
                        v[ i ][ k + 1 ],
                        v[ i + 1 ][ k ],
                        v[ i ][ k ],
                        materialIndex
                    );

                } else {

                    make(
                        v[ i ][ k + 1 ],
                        v[ i + 1 ][ k + 1 ],
                        v[ i + 1 ][ k ],
                        materialIndex
                    );

                }

            }

        }

    }


    // Angle around the Y axis, counter-clockwise when looking from above.

    function azimuth( vector ) {

        return Math.atan2( vector.z, - vector.x );

    }


    // Angle above the XZ plane.

    function inclination( vector ) {

        return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

    }


    // Texture fixing helper. Spheres have some odd behaviours.

    function correctUV( uv, vector, azimuth ) {

        if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
        if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
        return uv.clone();

    }


};

THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;

THREE.PolyhedronGeometry.prototype.clone = function () {

    var parameters = this.parameters;

    return new THREE.PolyhedronGeometry(
        parameters.vertices,
        parameters.indices,
        parameters.radius,
        parameters.detail
    );

};

// File:src/extras/geometries/DodecahedronGeometry.js

/**
 * @author Abe Pazos / https://hamoid.com
 */

THREE.DodecahedronGeometry = function ( radius, detail ) {

    var t = ( 1 + Math.sqrt( 5 ) ) / 2;
    var r = 1 / t;

    var vertices = [

        // (1, 1, 1)
        - 1, - 1, - 1,    - 1, - 1,  1,
        - 1,  1, - 1,    - 1,  1,  1,
        1, - 1, - 1,     1, - 1,  1,
        1,  1, - 1,     1,  1,  1,

        // (0, 1/?, ?)
        0, - r, - t,     0, - r,  t,
        0,  r, - t,     0,  r,  t,

        // (1/?, ?, 0)
        - r, - t,  0,    - r,  t,  0,
        r, - t,  0,     r,  t,  0,

        // (?, 0, 1/?)
        - t,  0, - r,     t,  0, - r,
        - t,  0,  r,     t,  0,  r
    ];

    var indices = [
        3, 11,  7,      3,  7, 15,      3, 15, 13,
        7, 19, 17,      7, 17,  6,      7,  6, 15,
        17,  4,  8,     17,  8, 10,     17, 10,  6,
        8,  0, 16,      8, 16,  2,      8,  2, 10,
        0, 12,  1,      0,  1, 18,      0, 18, 16,
        6, 10,  2,      6,  2, 13,      6, 13, 15,
        2, 16, 18,      2, 18,  3,      2,  3, 13,
        18,  1,  9,     18,  9, 11,     18, 11,  3,
        4, 14, 12,      4, 12,  0,      4,  0,  8,
        11,  9,  5,     11,  5, 19,     11, 19,  7,
        19,  5, 14,     19, 14,  4,     19,  4, 17,
        1, 12, 14,      1, 14,  5,      1,  5,  9
    ];

    THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    this.type = 'DodecahedronGeometry';

    this.parameters = {
        radius: radius,
        detail: detail
    };

};

THREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;

THREE.DodecahedronGeometry.prototype.clone = function () {

    var parameters = this.parameters;

    return new THREE.DodecahedronGeometry(
        parameters.radius,
        parameters.detail
    );

};

// File:src/extras/geometries/IcosahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.IcosahedronGeometry = function ( radius, detail ) {

    var t = ( 1 + Math.sqrt( 5 ) ) / 2;

    var vertices = [
        - 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
        0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
        t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
    ];

    var indices = [
        0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
        1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
        3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
        4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
    ];

    THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    this.type = 'IcosahedronGeometry';

    this.parameters = {
        radius: radius,
        detail: detail
    };

};

THREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;

THREE.IcosahedronGeometry.prototype.clone = function () {

    var parameters = this.parameters;

    return new THREE.IcosahedronGeometry(
        parameters.radius,
        parameters.detail
    );

};

// File:src/extras/geometries/OctahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.OctahedronGeometry = function ( radius, detail ) {

    var vertices = [
        1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1
    ];

    var indices = [
        0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
    ];

    THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    this.type = 'OctahedronGeometry';

    this.parameters = {
        radius: radius,
        detail: detail
    };

};

THREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;

THREE.OctahedronGeometry.prototype.clone = function () {

    var parameters = this.parameters;

    return new THREE.OctahedronGeometry(
        parameters.radius,
        parameters.detail
    );

};

// File:src/extras/geometries/TetrahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.TetrahedronGeometry = function ( radius, detail ) {

    var vertices = [
        1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
    ];

    var indices = [
        2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
    ];

    THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    this.type = 'TetrahedronGeometry';

    this.parameters = {
        radius: radius,
        detail: detail
    };

};

THREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;

THREE.TetrahedronGeometry.prototype.clone = function () {

    var parameters = this.parameters;

    return new THREE.TetrahedronGeometry(
        parameters.radius,
        parameters.detail
    );

};

// File:src/extras/geometries/ParametricGeometry.js

/**
 * @author zz85 / https://github.com/zz85
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 *
 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
 *
 */

THREE.ParametricGeometry = function ( func, slices, stacks ) {

    THREE.Geometry.call( this );

    this.type = 'ParametricGeometry';

    this.parameters = {
        func: func,
        slices: slices,
        stacks: stacks
    };

    var verts = this.vertices;
    var faces = this.faces;
    var uvs = this.faceVertexUvs[ 0 ];

    var i, j, p;
    var u, v;

    var sliceCount = slices + 1;

    for ( i = 0; i <= stacks; i ++ ) {

        v = i / stacks;

        for ( j = 0; j <= slices; j ++ ) {

            u = j / slices;

            p = func( u, v );
            verts.push( p );

        }

    }

    var a, b, c, d;
    var uva, uvb, uvc, uvd;

    for ( i = 0; i < stacks; i ++ ) {

        for ( j = 0; j < slices; j ++ ) {

            a = i * sliceCount + j;
            b = i * sliceCount + j + 1;
            c = ( i + 1 ) * sliceCount + j + 1;
            d = ( i + 1 ) * sliceCount + j;

            uva = new THREE.Vector2( j / slices, i / stacks );
            uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
            uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
            uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );

            faces.push( new THREE.Face3( a, b, d ) );
            uvs.push( [ uva, uvb, uvd ] );

            faces.push( new THREE.Face3( b, c, d ) );
            uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );

        }

    }

    // console.log(this);

    // magic bullet
    // var diff = this.mergeVertices();
    // console.log('removed ', diff, ' vertices by merging');

    this.computeFaceNormals();
    this.computeVertexNormals();

};

THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;

// File:src/extras/geometries/WireframeGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeGeometry = function ( geometry ) {

    THREE.BufferGeometry.call( this );

    var edge = [ 0, 0 ], hash = {};

    function sortFunction( a, b ) {

        return a - b;

    }

    var keys = [ 'a', 'b', 'c' ];

    if ( geometry instanceof THREE.Geometry ) {

        var vertices = geometry.vertices;
        var faces = geometry.faces;
        var numEdges = 0;

        // allocate maximal size
        var edges = new Uint32Array( 6 * faces.length );

        for ( var i = 0, l = faces.length; i < l; i ++ ) {

            var face = faces[ i ];

            for ( var j = 0; j < 3; j ++ ) {

                edge[ 0 ] = face[ keys[ j ] ];
                edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
                edge.sort( sortFunction );

                var key = edge.toString();

                if ( hash[ key ] === undefined ) {

                    edges[ 2 * numEdges ] = edge[ 0 ];
                    edges[ 2 * numEdges + 1 ] = edge[ 1 ];
                    hash[ key ] = true;
                    numEdges ++;

                }

            }

        }

        var coords = new Float32Array( numEdges * 2 * 3 );

        for ( var i = 0, l = numEdges; i < l; i ++ ) {

            for ( var j = 0; j < 2; j ++ ) {

                var vertex = vertices[ edges [ 2 * i + j ] ];

                var index = 6 * i + 3 * j;
                coords[ index + 0 ] = vertex.x;
                coords[ index + 1 ] = vertex.y;
                coords[ index + 2 ] = vertex.z;

            }

        }

        this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

    } else if ( geometry instanceof THREE.BufferGeometry ) {

        if ( geometry.index !== null ) {

            // Indexed BufferGeometry

            var indices = geometry.index.array;
            var vertices = geometry.attributes.position;
            var drawcalls = geometry.drawcalls;
            var numEdges = 0;

            if ( drawcalls.length === 0 ) {

                geometry.addGroup( 0, indices.length );

            }

            // allocate maximal size
            var edges = new Uint32Array( 2 * indices.length );

            for ( var o = 0, ol = drawcalls.length; o < ol; ++ o ) {

                var drawcall = drawcalls[ o ];

                var start = drawcall.start;
                var count = drawcall.count;

                for ( var i = start, il = start + count; i < il; i += 3 ) {

                    for ( var j = 0; j < 3; j ++ ) {

                        edge[ 0 ] = indices[ i + j ];
                        edge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];
                        edge.sort( sortFunction );

                        var key = edge.toString();

                        if ( hash[ key ] === undefined ) {

                            edges[ 2 * numEdges ] = edge[ 0 ];
                            edges[ 2 * numEdges + 1 ] = edge[ 1 ];
                            hash[ key ] = true;
                            numEdges ++;

                        }

                    }

                }

            }

            var coords = new Float32Array( numEdges * 2 * 3 );

            for ( var i = 0, l = numEdges; i < l; i ++ ) {

                for ( var j = 0; j < 2; j ++ ) {

                    var index = 6 * i + 3 * j;
                    var index2 = edges[ 2 * i + j ];

                    coords[ index + 0 ] = vertices.getX( index2 );
                    coords[ index + 1 ] = vertices.getY( index2 );
                    coords[ index + 2 ] = vertices.getZ( index2 );

                }

            }

            this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

        } else {

            // non-indexed BufferGeometry

            var vertices = geometry.attributes.position.array;
            var numEdges = vertices.length / 3;
            var numTris = numEdges / 3;

            var coords = new Float32Array( numEdges * 2 * 3 );

            for ( var i = 0, l = numTris; i < l; i ++ ) {

                for ( var j = 0; j < 3; j ++ ) {

                    var index = 18 * i + 6 * j;

                    var index1 = 9 * i + 3 * j;
                    coords[ index + 0 ] = vertices[ index1 ];
                    coords[ index + 1 ] = vertices[ index1 + 1 ];
                    coords[ index + 2 ] = vertices[ index1 + 2 ];

                    var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
                    coords[ index + 3 ] = vertices[ index2 ];
                    coords[ index + 4 ] = vertices[ index2 + 1 ];
                    coords[ index + 5 ] = vertices[ index2 + 2 ];

                }

            }

            this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

        }

    }

};

THREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;

// File:src/extras/helpers/AxisHelper.js

/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AxisHelper = function ( size ) {

    size = size || 1;

    var vertices = new Float32Array( [
        0, 0, 0,  size, 0, 0,
        0, 0, 0,  0, size, 0,
        0, 0, 0,  0, 0, size
    ] );

    var colors = new Float32Array( [
        1, 0, 0,  1, 0.6, 0,
        0, 1, 0,  0.6, 1, 0,
        0, 0, 1,  0, 0.6, 1
    ] );

    var geometry = new THREE.BufferGeometry();
    geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
    geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

    var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

    THREE.LineSegments.call( this, geometry, material );

};

THREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;

// File:src/extras/helpers/ArrowHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://clara.io
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */

THREE.ArrowHelper = ( function () {

    var lineGeometry = new THREE.Geometry();
    lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );

    var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );
    coneGeometry.translate( 0, - 0.5, 0 );

    return function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

        // dir is assumed to be normalized

        THREE.Object3D.call( this );

        if ( color === undefined ) color = 0xffff00;
        if ( length === undefined ) length = 1;
        if ( headLength === undefined ) headLength = 0.2 * length;
        if ( headWidth === undefined ) headWidth = 0.2 * headLength;

        this.position.copy( origin );

        if ( headLength < length ) {
            this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );
            this.line.matrixAutoUpdate = false;
            this.add( this.line );
        }

        this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );
        this.cone.matrixAutoUpdate = false;
        this.add( this.cone );

        this.setDirection( dir );
        this.setLength( length, headLength, headWidth );

    }

}() );

THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;

THREE.ArrowHelper.prototype.setDirection = ( function () {

    var axis = new THREE.Vector3();
    var radians;

    return function setDirection( dir ) {

        // dir is assumed to be normalized

        if ( dir.y > 0.99999 ) {

            this.quaternion.set( 0, 0, 0, 1 );

        } else if ( dir.y < - 0.99999 ) {

            this.quaternion.set( 1, 0, 0, 0 );

        } else {

            axis.set( dir.z, 0, - dir.x ).normalize();

            radians = Math.acos( dir.y );

            this.quaternion.setFromAxisAngle( axis, radians );

        }

    };

}() );

THREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

    if ( headLength === undefined ) headLength = 0.2 * length;
    if ( headWidth === undefined ) headWidth = 0.2 * headLength;

    if ( headLength < length ){
        this.line.scale.set( 1, length - headLength, 1 );
        this.line.updateMatrix();
    }

    this.cone.scale.set( headWidth, headLength, headWidth );
    this.cone.position.y = length;
    this.cone.updateMatrix();

};

THREE.ArrowHelper.prototype.setColor = function ( color ) {

    if ( this.line !== undefined ) this.line.material.color.set( color );
    this.cone.material.color.set( color );

};

// File:src/extras/helpers/BoxHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BoxHelper = function ( object ) {

    var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
    var positions = new Float32Array( 8 * 3 );

    var geometry = new THREE.BufferGeometry();
    geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
    geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

    THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ) );

    if ( object !== undefined ) {

        this.update( object );

    }

};

THREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;

THREE.BoxHelper.prototype.update = ( function () {

    var box = new THREE.Box3();

    return function ( object ) {

        box.setFromObject( object );

        if ( box.empty() ) return;

        var min = box.min;
        var max = box.max;

        /*
         5____4
         1/___0/|
         | 6__|_7
         2/___3/

         0: max.x, max.y, max.z
         1: min.x, max.y, max.z
         2: min.x, min.y, max.z
         3: max.x, min.y, max.z
         4: max.x, max.y, min.z
         5: min.x, max.y, min.z
         6: min.x, min.y, min.z
         7: max.x, min.y, min.z
         */

        var position = this.geometry.attributes.position;
        var array = position.array;

        array[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;
        array[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;
        array[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;
        array[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
        array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
        array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
        array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
        array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

        position.needsUpdate = true;

        this.geometry.computeBoundingSphere();

    }

} )();

// File:src/extras/helpers/BoundingBoxHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

// a helper to show the world-axis-aligned bounding box for an object

THREE.BoundingBoxHelper = function ( object, hex ) {

    var color = ( hex !== undefined ) ? hex : 0x888888;

    this.object = object;

    this.box = new THREE.Box3();

    THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );

};

THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );
THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;

THREE.BoundingBoxHelper.prototype.update = function () {

    this.box.setFromObject( this.object );

    this.box.size( this.scale );

    this.box.center( this.position );

};

// File:src/extras/helpers/CameraHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

THREE.CameraHelper = function ( camera ) {

    var geometry = new THREE.Geometry();
    var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );

    var pointMap = {};

    // colors

    var hexFrustum = 0xffaa00;
    var hexCone = 0xff0000;
    var hexUp = 0x00aaff;
    var hexTarget = 0xffffff;
    var hexCross = 0x333333;

    // near

    addLine( "n1", "n2", hexFrustum );
    addLine( "n2", "n4", hexFrustum );
    addLine( "n4", "n3", hexFrustum );
    addLine( "n3", "n1", hexFrustum );

    // far

    addLine( "f1", "f2", hexFrustum );
    addLine( "f2", "f4", hexFrustum );
    addLine( "f4", "f3", hexFrustum );
    addLine( "f3", "f1", hexFrustum );

    // sides

    addLine( "n1", "f1", hexFrustum );
    addLine( "n2", "f2", hexFrustum );
    addLine( "n3", "f3", hexFrustum );
    addLine( "n4", "f4", hexFrustum );

    // cone

    addLine( "p", "n1", hexCone );
    addLine( "p", "n2", hexCone );
    addLine( "p", "n3", hexCone );
    addLine( "p", "n4", hexCone );

    // up

    addLine( "u1", "u2", hexUp );
    addLine( "u2", "u3", hexUp );
    addLine( "u3", "u1", hexUp );

    // target

    addLine( "c", "t", hexTarget );
    addLine( "p", "c", hexCross );

    // cross

    addLine( "cn1", "cn2", hexCross );
    addLine( "cn3", "cn4", hexCross );

    addLine( "cf1", "cf2", hexCross );
    addLine( "cf3", "cf4", hexCross );

    function addLine( a, b, hex ) {

        addPoint( a, hex );
        addPoint( b, hex );

    }

    function addPoint( id, hex ) {

        geometry.vertices.push( new THREE.Vector3() );
        geometry.colors.push( new THREE.Color( hex ) );

        if ( pointMap[ id ] === undefined ) {

            pointMap[ id ] = [];

        }

        pointMap[ id ].push( geometry.vertices.length - 1 );

    }

    THREE.LineSegments.call( this, geometry, material );

    this.camera = camera;
    this.camera.updateProjectionMatrix();

    this.matrix = camera.matrixWorld;
    this.matrixAutoUpdate = false;

    this.pointMap = pointMap;

    this.update();

};

THREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;

THREE.CameraHelper.prototype.update = function () {

    var geometry, pointMap;

    var vector = new THREE.Vector3();
    var camera = new THREE.Camera();

    function setPoint( point, x, y, z ) {

        vector.set( x, y, z ).unproject( camera );

        var points = pointMap[ point ];

        if ( points !== undefined ) {

            for ( var i = 0, il = points.length; i < il; i ++ ) {

                geometry.vertices[ points[ i ] ].copy( vector );

            }

        }

    }

    return function () {

        geometry = this.geometry;
        pointMap = this.pointMap;

        var w = 1, h = 1;

        // we need just camera projection matrix
        // world matrix must be identity

        camera.projectionMatrix.copy( this.camera.projectionMatrix );

        // center / target

        setPoint( "c", 0, 0, - 1 );
        setPoint( "t", 0, 0,  1 );

        // near

        setPoint( "n1", - w, - h, - 1 );
        setPoint( "n2",   w, - h, - 1 );
        setPoint( "n3", - w,   h, - 1 );
        setPoint( "n4",   w,   h, - 1 );

        // far

        setPoint( "f1", - w, - h, 1 );
        setPoint( "f2",   w, - h, 1 );
        setPoint( "f3", - w,   h, 1 );
        setPoint( "f4",   w,   h, 1 );

        // up

        setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
        setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
        setPoint( "u3",         0, h * 2,   - 1 );

        // cross

        setPoint( "cf1", - w,   0, 1 );
        setPoint( "cf2",   w,   0, 1 );
        setPoint( "cf3",   0, - h, 1 );
        setPoint( "cf4",   0,   h, 1 );

        setPoint( "cn1", - w,   0, - 1 );
        setPoint( "cn2",   w,   0, - 1 );
        setPoint( "cn3",   0, - h, - 1 );
        setPoint( "cn4",   0,   h, - 1 );

        geometry.verticesNeedUpdate = true;

    };

}();

// File:src/extras/helpers/DirectionalLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.DirectionalLightHelper = function ( light, size ) {

    THREE.Object3D.call( this );

    this.light = light;
    this.light.updateMatrixWorld();

    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;

    size = size || 1;

    var geometry = new THREE.Geometry();
    geometry.vertices.push(
        new THREE.Vector3( - size,   size, 0 ),
        new THREE.Vector3(   size,   size, 0 ),
        new THREE.Vector3(   size, - size, 0 ),
        new THREE.Vector3( - size, - size, 0 ),
        new THREE.Vector3( - size,   size, 0 )
    );

    var material = new THREE.LineBasicMaterial( { fog: false } );
    material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    this.lightPlane = new THREE.Line( geometry, material );
    this.add( this.lightPlane );

    geometry = new THREE.Geometry();
    geometry.vertices.push(
        new THREE.Vector3(),
        new THREE.Vector3()
    );

    material = new THREE.LineBasicMaterial( { fog: false } );
    material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    this.targetLine = new THREE.Line( geometry, material );
    this.add( this.targetLine );

    this.update();

};

THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;

THREE.DirectionalLightHelper.prototype.dispose = function () {

    this.lightPlane.geometry.dispose();
    this.lightPlane.material.dispose();
    this.targetLine.geometry.dispose();
    this.targetLine.material.dispose();

};

THREE.DirectionalLightHelper.prototype.update = function () {

    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    var v3 = new THREE.Vector3();

    return function () {

        v1.setFromMatrixPosition( this.light.matrixWorld );
        v2.setFromMatrixPosition( this.light.target.matrixWorld );
        v3.subVectors( v2, v1 );

        this.lightPlane.lookAt( v3 );
        this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

        this.targetLine.geometry.vertices[ 1 ].copy( v3 );
        this.targetLine.geometry.verticesNeedUpdate = true;
        this.targetLine.material.color.copy( this.lightPlane.material.color );

    };

}();

// File:src/extras/helpers/EdgesHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 * @param object THREE.Mesh whose geometry will be used
 * @param hex line color
 * @param thresholdAngle the minimum angle (in degrees),
 * between the face normals of adjacent faces,
 * that is required to render an edge. A value of 10 means
 * an edge is only rendered if the angle is at least 10 degrees.
 */

THREE.EdgesHelper = function ( object, hex, thresholdAngle ) {

    var color = ( hex !== undefined ) ? hex : 0xffffff;

    THREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( { color: color } ) );

    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;

};

THREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;

// File:src/extras/helpers/FaceNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {

    // FaceNormalsHelper only supports THREE.Geometry

    this.object = object;

    this.size = ( size !== undefined ) ? size : 1;

    var color = ( hex !== undefined ) ? hex : 0xffff00;

    var width = ( linewidth !== undefined ) ? linewidth : 1;

    //

    var nNormals = 0;

    var objGeometry = this.object.geometry;

    if ( objGeometry instanceof THREE.Geometry ) {

        nNormals = objGeometry.faces.length;

    } else {

        console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

    }

    //

    var geometry = new THREE.BufferGeometry();

    var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );

    geometry.addAttribute( 'position', positions );

    THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );

    //

    this.matrixAutoUpdate = false;
    this.update();

};

THREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;

THREE.FaceNormalsHelper.prototype.update = ( function () {

    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    var normalMatrix = new THREE.Matrix3();

    return function update() {

        this.object.updateMatrixWorld( true );

        normalMatrix.getNormalMatrix( this.object.matrixWorld );

        var matrixWorld = this.object.matrixWorld;

        var position = this.geometry.attributes.position;

        //

        var objGeometry = this.object.geometry;

        var vertices = objGeometry.vertices;

        var faces = objGeometry.faces;

        var idx = 0;

        for ( var i = 0, l = faces.length; i < l; i ++ ) {

            var face = faces[ i ];

            var normal = face.normal;

            v1.copy( vertices[ face.a ] )
                .add( vertices[ face.b ] )
                .add( vertices[ face.c ] )
                .divideScalar( 3 )
                .applyMatrix4( matrixWorld );

            v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

            position.setXYZ( idx, v1.x, v1.y, v1.z );

            idx = idx + 1;

            position.setXYZ( idx, v2.x, v2.y, v2.z );

            idx = idx + 1;

        }

        position.needsUpdate = true;

        return this;

    }

}() );

// File:src/extras/helpers/GridHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GridHelper = function ( size, step ) {

    var geometry = new THREE.Geometry();
    var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

    this.color1 = new THREE.Color( 0x444444 );
    this.color2 = new THREE.Color( 0x888888 );

    for ( var i = - size; i <= size; i += step ) {

        geometry.vertices.push(
            new THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),
            new THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )
        );

        var color = i === 0 ? this.color1 : this.color2;

        geometry.colors.push( color, color, color, color );

    }

    THREE.LineSegments.call( this, geometry, material );

};

THREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.GridHelper.prototype.constructor = THREE.GridHelper;

THREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {

    this.color1.set( colorCenterLine );
    this.color2.set( colorGrid );

    this.geometry.colorsNeedUpdate = true;

};

// File:src/extras/helpers/HemisphereLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.HemisphereLightHelper = function ( light, sphereSize ) {

    THREE.Object3D.call( this );

    this.light = light;
    this.light.updateMatrixWorld();

    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;

    this.colors = [ new THREE.Color(), new THREE.Color() ];

    var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
    geometry.rotateX( - Math.PI / 2 );

    for ( var i = 0, il = 8; i < il; i ++ ) {

        geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

    }

    var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );

    this.lightSphere = new THREE.Mesh( geometry, material );
    this.add( this.lightSphere );

    this.update();

};

THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;

THREE.HemisphereLightHelper.prototype.dispose = function () {

    this.lightSphere.geometry.dispose();
    this.lightSphere.material.dispose();

};

THREE.HemisphereLightHelper.prototype.update = function () {

    var vector = new THREE.Vector3();

    return function () {

        this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
        this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

        this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
        this.lightSphere.geometry.colorsNeedUpdate = true;

    }

}();

// File:src/extras/helpers/PointLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLightHelper = function ( light, sphereSize ) {

    this.light = light;
    this.light.updateMatrixWorld();

    var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
    var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
    material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    THREE.Mesh.call( this, geometry, material );

    this.matrix = this.light.matrixWorld;
    this.matrixAutoUpdate = false;

    /*
     var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
     var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

     this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
     this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

     var d = light.distance;

     if ( d === 0.0 ) {

     this.lightDistance.visible = false;

     } else {

     this.lightDistance.scale.set( d, d, d );

     }

     this.add( this.lightDistance );
     */

};

THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );
THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;

THREE.PointLightHelper.prototype.dispose = function () {

    this.geometry.dispose();
    this.material.dispose();

};

THREE.PointLightHelper.prototype.update = function () {

    this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    /*
     var d = this.light.distance;

     if ( d === 0.0 ) {

     this.lightDistance.visible = false;

     } else {

     this.lightDistance.visible = true;
     this.lightDistance.scale.set( d, d, d );

     }
     */

};

// File:src/extras/helpers/SkeletonHelper.js

/**
 * @author Sean Griffin / http://twitter.com/sgrif
 * @author Michael Guerrero / http://realitymeltdown.com
 * @author mrdoob / http://mrdoob.com/
 * @author ikerr / http://verold.com
 */

THREE.SkeletonHelper = function ( object ) {

    this.bones = this.getBoneList( object );

    var geometry = new THREE.Geometry();

    for ( var i = 0; i < this.bones.length; i ++ ) {

        var bone = this.bones[ i ];

        if ( bone.parent instanceof THREE.Bone ) {

            geometry.vertices.push( new THREE.Vector3() );
            geometry.vertices.push( new THREE.Vector3() );
            geometry.colors.push( new THREE.Color( 0, 0, 1 ) );
            geometry.colors.push( new THREE.Color( 0, 1, 0 ) );

        }

    }

    geometry.dynamic = true;

    var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );

    THREE.LineSegments.call( this, geometry, material );

    this.root = object;

    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;

    this.update();

};


THREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;

THREE.SkeletonHelper.prototype.getBoneList = function( object ) {

    var boneList = [];

    if ( object instanceof THREE.Bone ) {

        boneList.push( object );

    }

    for ( var i = 0; i < object.children.length; i ++ ) {

        boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

    }

    return boneList;

};

THREE.SkeletonHelper.prototype.update = function () {

    var geometry = this.geometry;

    var matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );

    var boneMatrix = new THREE.Matrix4();

    var j = 0;

    for ( var i = 0; i < this.bones.length; i ++ ) {

        var bone = this.bones[ i ];

        if ( bone.parent instanceof THREE.Bone ) {

            boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
            geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );

            boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
            geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );

            j += 2;

        }

    }

    geometry.verticesNeedUpdate = true;

    geometry.computeBoundingSphere();

};

// File:src/extras/helpers/SpotLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.SpotLightHelper = function ( light ) {

    THREE.Object3D.call( this );

    this.light = light;
    this.light.updateMatrixWorld();

    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;

    var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );

    geometry.translate( 0, - 0.5, 0 );
    geometry.rotateX( - Math.PI / 2 );

    var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );

    this.cone = new THREE.Mesh( geometry, material );
    this.add( this.cone );

    this.update();

};

THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;

THREE.SpotLightHelper.prototype.dispose = function () {

    this.cone.geometry.dispose();
    this.cone.material.dispose();

};

THREE.SpotLightHelper.prototype.update = function () {

    var vector = new THREE.Vector3();
    var vector2 = new THREE.Vector3();

    return function () {

        var coneLength = this.light.distance ? this.light.distance : 10000;
        var coneWidth = coneLength * Math.tan( this.light.angle );

        this.cone.scale.set( coneWidth, coneWidth, coneLength );

        vector.setFromMatrixPosition( this.light.matrixWorld );
        vector2.setFromMatrixPosition( this.light.target.matrixWorld );

        this.cone.lookAt( vector2.sub( vector ) );

        this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    };

}();

// File:src/extras/helpers/VertexNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {

    this.object = object;

    this.size = ( size !== undefined ) ? size : 1;

    var color = ( hex !== undefined ) ? hex : 0xff0000;

    var width = ( linewidth !== undefined ) ? linewidth : 1;

    //

    var nNormals = 0;

    var objGeometry = this.object.geometry;

    if ( objGeometry instanceof THREE.Geometry ) {

        nNormals = objGeometry.faces.length * 3;

    } else if ( objGeometry instanceof THREE.BufferGeometry ) {

        nNormals = objGeometry.attributes.normal.count

    }

    //

    var geometry = new THREE.BufferGeometry();

    var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );

    geometry.addAttribute( 'position', positions );

    THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );

    //

    this.matrixAutoUpdate = false;

    this.update();

};

THREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;

THREE.VertexNormalsHelper.prototype.update = ( function () {

    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    var normalMatrix = new THREE.Matrix3();

    return function update() {

        var keys = [ 'a', 'b', 'c' ];

        this.object.updateMatrixWorld( true );

        normalMatrix.getNormalMatrix( this.object.matrixWorld );

        var matrixWorld = this.object.matrixWorld;

        var position = this.geometry.attributes.position;

        //

        var objGeometry = this.object.geometry;

        if ( objGeometry instanceof THREE.Geometry ) {

            var vertices = objGeometry.vertices;

            var faces = objGeometry.faces;

            var idx = 0;

            for ( var i = 0, l = faces.length; i < l; i ++ ) {

                var face = faces[ i ];

                for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

                    var vertex = vertices[ face[ keys[ j ] ] ];

                    var normal = face.vertexNormals[ j ];

                    v1.copy( vertex ).applyMatrix4( matrixWorld );

                    v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

                    position.setXYZ( idx, v1.x, v1.y, v1.z );

                    idx = idx + 1;

                    position.setXYZ( idx, v2.x, v2.y, v2.z );

                    idx = idx + 1;

                }

            }

        } else if ( objGeometry instanceof THREE.BufferGeometry ) {

            var objPos = objGeometry.attributes.position;

            var objNorm = objGeometry.attributes.normal;

            var idx = 0;

            // for simplicity, ignore index and drawcalls, and render every normal

            for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

                v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

                v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

                v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

                position.setXYZ( idx, v1.x, v1.y, v1.z );

                idx = idx + 1;

                position.setXYZ( idx, v2.x, v2.y, v2.z );

                idx = idx + 1;

            }

        }

        position.needsUpdate = true;

        return this;

    }

}() );

// File:src/extras/helpers/WireframeHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeHelper = function ( object, hex ) {

    var color = ( hex !== undefined ) ? hex : 0xffffff;

    THREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( { color: color } ) );

    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;

};

THREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;

// File:src/extras/objects/ImmediateRenderObject.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ImmediateRenderObject = function ( material ) {

    THREE.Object3D.call( this );

    this.material = material;
    this.render = function ( renderCallback ) {};

};

THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );
THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;

// File:src/extras/objects/MorphBlendMesh.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphBlendMesh = function( geometry, material ) {

    THREE.Mesh.call( this, geometry, material );

    this.animationsMap = {};
    this.animationsList = [];

    // prepare default animation
    // (all frames played together in 1 second)

    var numFrames = this.geometry.morphTargets.length;

    var name = "__default";

    var startFrame = 0;
    var endFrame = numFrames - 1;

    var fps = numFrames / 1;

    this.createAnimation( name, startFrame, endFrame, fps );
    this.setAnimationWeight( name, 1 );

};

THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;

THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

    var animation = {

        start: start,
        end: end,

        length: end - start + 1,

        fps: fps,
        duration: ( end - start ) / fps,

        lastFrame: 0,
        currentFrame: 0,

        active: false,

        time: 0,
        direction: 1,
        weight: 1,

        directionBackwards: false,
        mirroredLoop: false

    };

    this.animationsMap[ name ] = animation;
    this.animationsList.push( animation );

};

THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

    var pattern = /([a-z]+)_?(\d+)/;

    var firstAnimation, frameRanges = {};

    var geometry = this.geometry;

    for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

        var morph = geometry.morphTargets[ i ];
        var chunks = morph.name.match( pattern );

        if ( chunks && chunks.length > 1 ) {

            var name = chunks[ 1 ];

            if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };

            var range = frameRanges[ name ];

            if ( i < range.start ) range.start = i;
            if ( i > range.end ) range.end = i;

            if ( ! firstAnimation ) firstAnimation = name;

        }

    }

    for ( var name in frameRanges ) {

        var range = frameRanges[ name ];
        this.createAnimation( name, range.start, range.end, fps );

    }

    this.firstAnimation = firstAnimation;

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.direction = 1;
        animation.directionBackwards = false;

    }

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.direction = - 1;
        animation.directionBackwards = true;

    }

};

THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.fps = fps;
        animation.duration = ( animation.end - animation.start ) / animation.fps;

    }

};

THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.duration = duration;
        animation.fps = ( animation.end - animation.start ) / animation.duration;

    }

};

THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.weight = weight;

    }

};

THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.time = time;

    }

};

THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

    var time = 0;

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        time = animation.time;

    }

    return time;

};

THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

    var duration = - 1;

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        duration = animation.duration;

    }

    return duration;

};

THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.time = 0;
        animation.active = true;

    } else {

        console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );

    }

};

THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.active = false;

    }

};

THREE.MorphBlendMesh.prototype.update = function ( delta ) {

    for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

        var animation = this.animationsList[ i ];

        if ( ! animation.active ) continue;

        var frameTime = animation.duration / animation.length;

        animation.time += animation.direction * delta;

        if ( animation.mirroredLoop ) {

            if ( animation.time > animation.duration || animation.time < 0 ) {

                animation.direction *= - 1;

                if ( animation.time > animation.duration ) {

                    animation.time = animation.duration;
                    animation.directionBackwards = true;

                }

                if ( animation.time < 0 ) {

                    animation.time = 0;
                    animation.directionBackwards = false;

                }

            }

        } else {

            animation.time = animation.time % animation.duration;

            if ( animation.time < 0 ) animation.time += animation.duration;

        }

        var keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
        var weight = animation.weight;

        if ( keyframe !== animation.currentFrame ) {

            this.morphTargetInfluences[ animation.lastFrame ] = 0;
            this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

            this.morphTargetInfluences[ keyframe ] = 0;

            animation.lastFrame = animation.currentFrame;
            animation.currentFrame = keyframe;

        }

        var mix = ( animation.time % frameTime ) / frameTime;

        if ( animation.directionBackwards ) mix = 1 - mix;

        if ( animation.currentFrame !== animation.lastFrame ) {

            this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
            this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

        } else {

            this.morphTargetInfluences[ animation.currentFrame ] = weight;

        }

    }

};
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For creating 3D text geometry in three.js
 *
 * Text = 3D Text
 *
 * parameters = {
 *  size: 			<float>, 	// size of the text
 *  height: 		<float>, 	// thickness to extrude text
 *  curveSegments: 	<int>,		// number of points on the curves
 *
 *  font: 			<string>,		// font name
 *  weight: 		<string>,		// font weight (normal, bold)
 *  style: 			<string>,		// font style  (normal, italics)
 *
 *  bevelEnabled:	<bool>,			// turn on bevel
 *  bevelThickness: <float>, 		// how deep into text bevel goes
 *  bevelSize:		<float>, 		// how far from text outline is bevel
 *  }
 *
 */

/*	Usage Examples

 // TextGeometry wrapper

 var text3d = new TextGeometry( text, options );

 // Complete manner

 var textShapes = THREE.FontUtils.generateShapes( text, options );
 var text3d = new ExtrudeGeometry( textShapes, options );

 */

THREE.TextGeometry = function ( text, parameters ) {

    parameters = parameters || {};

    var textShapes = THREE.FontUtils.generateShapes( text, parameters );

    // translate parameters to ExtrudeGeometry API

    parameters.amount = parameters.height !== undefined ? parameters.height : 50;

    // defaults

    if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
    if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
    if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

    THREE.ExtrudeGeometry.call( this, textShapes, parameters );

    this.type = 'TextGeometry';

};

THREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );
THREE.TextGeometry.prototype.constructor = THREE.TextGeometry;




/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For Text operations in three.js (See TextGeometry)
 *
 * It uses techniques used in:
 *
 *	Triangulation ported from AS3
 *		Simple Polygon Triangulation
 *		http://actionsnippet.com/?p=1462
 *
 * 	A Method to triangulate shapes with holes
 *		http://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/
 *
 */

THREE.FontUtils = {

    faces: {},

    // Just for now. face[weight][style]

    face: 'helvetiker',
    weight: 'normal',
    style: 'normal',
    size: 150,
    divisions: 10,

    getFace: function () {

        try {

            return this.faces[ this.face.toLowerCase() ][ this.weight ][ this.style ];

        } catch ( e ) {

            throw "The font " + this.face + " with " + this.weight + " weight and " + this.style + " style is missing."

        }

    },

    loadFace: function ( data ) {

        var family = data.familyName.toLowerCase();

        var ThreeFont = this;

        ThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};

        ThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};
        ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

        ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

        return data;

    },

    drawText: function ( text ) {

        // RenderText

        var i,
            face = this.getFace(),
            scale = this.size / face.resolution,
            offset = 0,
            chars = String( text ).split( '' ),
            length = chars.length;

        var fontPaths = [];

        for ( i = 0; i < length; i ++ ) {

            var path = new THREE.Path();

            var ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );
            offset += ret.offset;

            fontPaths.push( ret.path );

        }

        // get the width

        var width = offset / 2;
        //
        // for ( p = 0; p < allPts.length; p++ ) {
        //
        // 	allPts[ p ].x -= width;
        //
        // }

        //var extract = this.extractPoints( allPts, characterPts );
        //extract.contour = allPts;

        //extract.paths = fontPaths;
        //extract.offset = width;

        return { paths: fontPaths, offset: width };

    },




    extractGlyphPoints: function ( c, face, scale, offset, path ) {

        var pts = [];

        var b2 = THREE.ShapeUtils.b2;
        var b3 = THREE.ShapeUtils.b3;

        var i, i2, divisions,
            outline, action, length,
            scaleX, scaleY,
            x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,
            laste,
            glyph = face.glyphs[ c ] || face.glyphs[ '?' ];

        if ( ! glyph ) return;

        if ( glyph.o ) {

            outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
            length = outline.length;

            scaleX = scale;
            scaleY = scale;

            for ( i = 0; i < length; ) {

                action = outline[ i ++ ];

                //console.log( action );

                switch ( action ) {

                    case 'm':

                        // Move To

                        x = outline[ i ++ ] * scaleX + offset;
                        y = outline[ i ++ ] * scaleY;

                        path.moveTo( x, y );
                        break;

                    case 'l':

                        // Line To

                        x = outline[ i ++ ] * scaleX + offset;
                        y = outline[ i ++ ] * scaleY;
                        path.lineTo( x, y );
                        break;

                    case 'q':

                        // QuadraticCurveTo

                        cpx  = outline[ i ++ ] * scaleX + offset;
                        cpy  = outline[ i ++ ] * scaleY;
                        cpx1 = outline[ i ++ ] * scaleX + offset;
                        cpy1 = outline[ i ++ ] * scaleY;

                        path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

                        laste = pts[ pts.length - 1 ];

                        if ( laste ) {

                            cpx0 = laste.x;
                            cpy0 = laste.y;

                            for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

                                var t = i2 / divisions;
                                b2( t, cpx0, cpx1, cpx );
                                b2( t, cpy0, cpy1, cpy );

                            }

                        }

                        break;

                    case 'b':

                        // Cubic Bezier Curve

                        cpx  = outline[ i ++ ] * scaleX + offset;
                        cpy  = outline[ i ++ ] * scaleY;
                        cpx1 = outline[ i ++ ] * scaleX + offset;
                        cpy1 = outline[ i ++ ] * scaleY;
                        cpx2 = outline[ i ++ ] * scaleX + offset;
                        cpy2 = outline[ i ++ ] * scaleY;

                        path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

                        laste = pts[ pts.length - 1 ];

                        if ( laste ) {

                            cpx0 = laste.x;
                            cpy0 = laste.y;

                            for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

                                var t = i2 / divisions;
                                b3( t, cpx0, cpx1, cpx2, cpx );
                                b3( t, cpy0, cpy1, cpy2, cpy );

                            }

                        }

                        break;

                }

            }

        }



        return { offset: glyph.ha * scale, path: path };

    }

};


THREE.FontUtils.generateShapes = function ( text, parameters ) {

    // Parameters

    parameters = parameters || {};

    var size = parameters.size !== undefined ? parameters.size : 100;
    var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments : 4;

    var font = parameters.font !== undefined ? parameters.font : 'helvetiker';
    var weight = parameters.weight !== undefined ? parameters.weight : 'normal';
    var style = parameters.style !== undefined ? parameters.style : 'normal';

    THREE.FontUtils.size = size;
    THREE.FontUtils.divisions = curveSegments;

    THREE.FontUtils.face = font;
    THREE.FontUtils.weight = weight;
    THREE.FontUtils.style = style;

    // Get a Font data json object

    var data = THREE.FontUtils.drawText( text );

    var paths = data.paths;
    var shapes = [];

    for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

        Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

    }

    return shapes;

};

// To use the typeface.js face files, hook up the API

THREE.typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };
if ( typeof self !== 'undefined' ) self._typeface_js = THREE.typeface_js;




// From github repository at three.js\examples\fontshelvetiker_regular.typeface.js
if (_typeface_js && _typeface_js.loadFace) _typeface_js.loadFace({"glyphs":{"?":{"x_min":0,"x_max":712,"ha":815,"o":"m 356 -25 q 96 88 192 -25 q 0 368 0 201 q 92 642 0 533 q 356 761 192 761 q 617 644 517 761 q 712 368 712 533 q 619 91 712 201 q 356 -25 520 -25 m 356 85 q 527 175 465 85 q 583 369 583 255 q 528 562 583 484 q 356 651 466 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 356 85 250 85 "},"S":{"x_min":0,"x_max":788,"ha":890,"o":"m 788 291 q 662 54 788 144 q 397 -26 550 -26 q 116 68 226 -26 q 0 337 0 168 l 131 337 q 200 152 131 220 q 384 85 269 85 q 557 129 479 85 q 650 270 650 183 q 490 429 650 379 q 194 513 341 470 q 33 739 33 584 q 142 964 33 881 q 388 1041 242 1041 q 644 957 543 1041 q 756 716 756 867 l 625 716 q 561 874 625 816 q 395 933 497 933 q 243 891 309 933 q 164 759 164 841 q 325 609 164 656 q 625 526 475 568 q 788 291 788 454 "},"":{"x_min":343,"x_max":449,"ha":792,"o":"m 449 462 l 343 462 l 343 986 l 449 986 l 449 462 m 449 -242 l 343 -242 l 343 280 l 449 280 l 449 -242 "},"/":{"x_min":183.25,"x_max":608.328125,"ha":792,"o":"m 608 1041 l 266 -129 l 183 -129 l 520 1041 l 608 1041 "},"?":{"x_min":-0.4375,"x_max":777.453125,"ha":839,"o":"m 777 893 l 458 893 l 458 0 l 319 0 l 319 892 l 0 892 l 0 1013 l 777 1013 l 777 893 "},"y":{"x_min":0,"x_max":684.78125,"ha":771,"o":"m 684 738 l 388 -83 q 311 -216 356 -167 q 173 -279 252 -279 q 97 -266 133 -279 l 97 -149 q 132 -155 109 -151 q 168 -160 155 -160 q 240 -114 213 -160 q 274 -26 248 -98 l 0 738 l 137 737 l 341 139 l 548 737 l 684 738 "},"?":{"x_min":0,"x_max":803,"ha":917,"o":"m 803 0 l 667 0 l 667 886 l 140 886 l 140 0 l 0 0 l 0 1012 l 803 1012 l 803 0 "},"?":{"x_min":-111,"x_max":339,"ha":361,"o":"m 339 800 l 229 800 l 229 925 l 339 925 l 339 800 m -1 800 l -111 800 l -111 925 l -1 925 l -1 800 m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 737 l 167 737 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 103 239 101 q 284 112 257 104 l 284 3 m 302 1040 l 113 819 l 30 819 l 165 1040 l 302 1040 "},"g":{"x_min":0,"x_max":686,"ha":838,"o":"m 686 34 q 586 -213 686 -121 q 331 -306 487 -306 q 131 -252 216 -306 q 31 -84 31 -190 l 155 -84 q 228 -174 166 -138 q 345 -207 284 -207 q 514 -109 454 -207 q 564 89 564 -27 q 461 6 521 36 q 335 -23 401 -23 q 88 100 184 -23 q 0 370 0 215 q 87 634 0 522 q 330 758 183 758 q 457 728 398 758 q 564 644 515 699 l 564 737 l 686 737 l 686 34 m 582 367 q 529 560 582 481 q 358 652 468 652 q 189 561 250 652 q 135 369 135 482 q 189 176 135 255 q 361 85 251 85 q 529 176 468 85 q 582 367 582 255 "},"":{"x_min":0,"x_max":442,"ha":539,"o":"m 442 383 l 0 383 q 91 566 0 492 q 260 668 176 617 q 354 798 354 727 q 315 875 354 845 q 227 905 277 905 q 136 869 173 905 q 99 761 99 833 l 14 761 q 82 922 14 864 q 232 974 141 974 q 379 926 316 974 q 442 797 442 878 q 351 635 442 704 q 183 539 321 611 q 92 455 92 491 l 442 455 l 442 383 "},"":{"x_min":0,"x_max":705.5625,"ha":803,"o":"m 705 334 l 0 334 l 0 410 l 705 410 l 705 334 "},"?":{"x_min":0,"x_max":819.5625,"ha":893,"o":"m 819 0 l 650 0 l 294 509 l 139 356 l 139 0 l 0 0 l 0 1013 l 139 1013 l 139 526 l 626 1013 l 809 1013 l 395 600 l 819 0 "},"":{"x_min":-46.265625,"x_max":392,"ha":513,"o":"m 392 651 l 259 651 l 79 -279 l -46 -278 l 134 651 l 14 651 l 14 751 l 135 751 q 151 948 135 900 q 304 1041 185 1041 q 334 1040 319 1041 q 392 1034 348 1039 l 392 922 q 337 931 360 931 q 271 883 287 931 q 260 793 260 853 l 260 751 l 392 751 l 392 651 "},"e":{"x_min":0,"x_max":714,"ha":813,"o":"m 714 326 l 140 326 q 200 157 140 227 q 359 87 260 87 q 488 130 431 87 q 561 245 545 174 l 697 245 q 577 48 670 123 q 358 -26 484 -26 q 97 85 195 -26 q 0 363 0 197 q 94 642 0 529 q 358 765 195 765 q 626 627 529 765 q 714 326 714 503 m 576 429 q 507 583 564 522 q 355 650 445 650 q 206 583 266 650 q 140 429 152 522 l 576 429 "},"?":{"x_min":0,"x_max":712,"ha":815,"o":"m 356 -25 q 94 91 194 -25 q 0 368 0 202 q 92 642 0 533 q 356 761 192 761 q 617 644 517 761 q 712 368 712 533 q 619 91 712 201 q 356 -25 520 -25 m 356 85 q 527 175 465 85 q 583 369 583 255 q 528 562 583 484 q 356 651 466 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 356 85 250 85 m 576 1040 l 387 819 l 303 819 l 438 1040 l 576 1040 "},"J":{"x_min":0,"x_max":588,"ha":699,"o":"m 588 279 q 287 -26 588 -26 q 58 73 126 -26 q 0 327 0 158 l 133 327 q 160 172 133 227 q 288 96 198 96 q 426 171 391 96 q 449 336 449 219 l 449 1013 l 588 1013 l 588 279 "},"":{"x_min":-1,"x_max":503,"ha":601,"o":"m 503 302 l 280 136 l 281 256 l 429 373 l 281 486 l 280 608 l 503 440 l 503 302 m 221 302 l 0 136 l 0 255 l 145 372 l 0 486 l -1 608 l 221 440 l 221 302 "},"":{"x_min":-3,"x_max":1008,"ha":1106,"o":"m 502 -7 q 123 151 263 -7 q -3 501 -3 294 q 123 851 -3 706 q 502 1011 263 1011 q 881 851 739 1011 q 1008 501 1008 708 q 883 151 1008 292 q 502 -7 744 -7 m 502 60 q 830 197 709 60 q 940 501 940 322 q 831 805 940 681 q 502 944 709 944 q 174 805 296 944 q 65 501 65 680 q 173 197 65 320 q 502 60 294 60 m 741 394 q 661 246 731 302 q 496 190 591 190 q 294 285 369 190 q 228 497 228 370 q 295 714 228 625 q 499 813 370 813 q 656 762 588 813 q 733 625 724 711 l 634 625 q 589 704 629 673 q 498 735 550 735 q 377 666 421 735 q 334 504 334 597 q 374 340 334 408 q 490 272 415 272 q 589 304 549 272 q 638 394 628 337 l 741 394 "},"?":{"x_min":0,"x_max":922,"ha":1030,"o":"m 687 1040 l 498 819 l 415 819 l 549 1040 l 687 1040 m 922 339 q 856 97 922 203 q 650 -26 780 -26 q 538 9 587 -26 q 461 103 489 44 q 387 12 436 46 q 277 -22 339 -22 q 69 97 147 -22 q 0 338 0 202 q 45 551 0 444 q 161 737 84 643 l 302 737 q 175 552 219 647 q 124 336 124 446 q 155 179 124 248 q 275 88 197 88 q 375 163 341 88 q 400 294 400 219 l 400 572 l 524 572 l 524 294 q 561 135 524 192 q 643 88 591 88 q 762 182 719 88 q 797 341 797 257 q 745 555 797 450 q 619 737 705 637 l 760 737 q 874 551 835 640 q 922 339 922 444 "},"^":{"x_min":193.0625,"x_max":598.609375,"ha":792,"o":"m 598 772 l 515 772 l 395 931 l 277 772 l 193 772 l 326 1013 l 462 1013 l 598 772 "},"":{"x_min":0,"x_max":507.203125,"ha":604,"o":"m 506 136 l 284 302 l 284 440 l 506 608 l 507 485 l 360 371 l 506 255 l 506 136 m 222 136 l 0 302 l 0 440 l 222 608 l 221 486 l 73 373 l 222 256 l 222 136 "},"D":{"x_min":0,"x_max":828,"ha":935,"o":"m 389 1013 q 714 867 593 1013 q 828 521 828 729 q 712 161 828 309 q 382 0 587 0 l 0 0 l 0 1013 l 389 1013 m 376 124 q 607 247 523 124 q 681 510 681 355 q 607 771 681 662 q 376 896 522 896 l 139 896 l 139 124 l 376 124 "},"?":{"x_min":0,"x_max":142,"ha":239,"o":"m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 "},"":{"x_min":0,"x_max":47,"ha":125,"o":"m 47 3 q 37 -7 47 -7 q 28 0 30 -7 q 39 -4 32 -4 q 45 3 45 -1 l 37 0 q 28 9 28 0 q 39 19 28 19 l 47 16 l 47 19 l 47 3 m 37 1 q 44 8 44 1 q 37 16 44 16 q 30 8 30 16 q 37 1 30 1 m 26 1 l 23 22 l 14 0 l 3 22 l 3 3 l 0 25 l 13 1 l 22 25 l 26 1 "},"w":{"x_min":0,"x_max":1009.71875,"ha":1100,"o":"m 1009 738 l 783 0 l 658 0 l 501 567 l 345 0 l 222 0 l 0 738 l 130 738 l 284 174 l 432 737 l 576 738 l 721 173 l 881 737 l 1009 738 "},"$":{"x_min":0,"x_max":700,"ha":793,"o":"m 664 717 l 542 717 q 490 825 531 785 q 381 872 450 865 l 381 551 q 620 446 540 522 q 700 241 700 370 q 618 45 700 116 q 381 -25 536 -25 l 381 -152 l 307 -152 l 307 -25 q 81 62 162 -25 q 0 297 0 149 l 124 297 q 169 146 124 204 q 307 81 215 89 l 307 441 q 80 536 148 469 q 13 725 13 603 q 96 910 13 839 q 307 982 180 982 l 307 1077 l 381 1077 l 381 982 q 574 917 494 982 q 664 717 664 845 m 307 565 l 307 872 q 187 831 233 872 q 142 724 142 791 q 180 618 142 656 q 307 565 218 580 m 381 76 q 562 237 562 96 q 517 361 562 313 q 381 423 472 409 l 381 76 "},"\\":{"x_min":-0.015625,"x_max":425.0625,"ha":522,"o":"m 425 -129 l 337 -129 l 0 1041 l 83 1041 l 425 -129 "},"":{"x_min":0,"x_max":697.21875,"ha":747,"o":"m 697 -4 q 629 -14 658 -14 q 498 97 513 -14 q 422 9 470 41 q 313 -23 374 -23 q 207 4 258 -23 q 119 81 156 32 l 119 -278 l 0 -278 l 0 738 l 124 738 l 124 343 q 165 173 124 246 q 308 83 216 83 q 452 178 402 83 q 493 359 493 255 l 493 738 l 617 738 l 617 214 q 623 136 617 160 q 673 92 637 92 q 697 96 684 92 l 697 -4 "},"?":{"x_min":42,"x_max":181,"ha":297,"o":"m 181 0 l 42 0 l 42 1013 l 181 1013 l 181 0 "},"?":{"x_min":0,"x_max":1144.5,"ha":1214,"o":"m 1144 1012 l 807 416 l 807 0 l 667 0 l 667 416 l 325 1012 l 465 1012 l 736 533 l 1004 1012 l 1144 1012 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 "},"":{"x_min":0,"x_max":139,"ha":236,"o":"m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 "},"?":{"x_min":0,"x_max":801,"ha":915,"o":"m 801 0 l 651 0 l 131 822 l 131 0 l 0 0 l 0 1013 l 151 1013 l 670 191 l 670 1013 l 801 1013 l 801 0 "},"-":{"x_min":8.71875,"x_max":350.390625,"ha":478,"o":"m 350 317 l 8 317 l 8 428 l 350 428 l 350 317 "},"Q":{"x_min":0,"x_max":968,"ha":1072,"o":"m 954 5 l 887 -79 l 744 35 q 622 -11 687 2 q 483 -26 556 -26 q 127 130 262 -26 q 0 504 0 279 q 127 880 0 728 q 484 1041 262 1041 q 841 884 708 1041 q 968 507 968 735 q 933 293 968 398 q 832 104 899 188 l 954 5 m 723 191 q 802 330 777 248 q 828 499 828 412 q 744 790 828 673 q 483 922 650 922 q 228 791 322 922 q 142 505 142 673 q 227 221 142 337 q 487 91 323 91 q 632 123 566 91 l 520 215 l 587 301 l 723 191 "},"?":{"x_min":1,"x_max":676.28125,"ha":740,"o":"m 676 460 l 551 460 q 498 595 542 546 q 365 651 448 651 q 199 578 263 651 q 136 401 136 505 q 266 178 136 241 q 508 106 387 142 q 640 -50 640 62 q 625 -158 640 -105 q 583 -278 611 -211 l 465 -278 q 498 -182 490 -211 q 515 -80 515 -126 q 381 12 515 -15 q 134 91 197 51 q 1 388 1 179 q 100 651 1 542 q 354 761 199 761 q 587 680 498 761 q 676 460 676 599 "},"M":{"x_min":0,"x_max":954,"ha":1067,"o":"m 954 0 l 819 0 l 819 869 l 537 0 l 405 0 l 128 866 l 128 0 l 0 0 l 0 1013 l 200 1013 l 472 160 l 757 1013 l 954 1013 l 954 0 "},"?":{"x_min":0,"x_max":1006,"ha":1094,"o":"m 1006 678 q 914 319 1006 429 q 571 200 814 200 l 571 0 l 433 0 l 433 200 q 92 319 194 200 q 0 678 0 429 l 0 1013 l 139 1013 l 139 679 q 191 417 139 492 q 433 326 255 326 l 433 1013 l 571 1013 l 571 326 l 580 326 q 813 423 747 326 q 868 679 868 502 l 868 1013 l 1006 1013 l 1006 678 "},"C":{"x_min":0,"x_max":886,"ha":944,"o":"m 886 379 q 760 87 886 201 q 455 -26 634 -26 q 112 136 236 -26 q 0 509 0 283 q 118 882 0 737 q 469 1041 245 1041 q 748 955 630 1041 q 879 708 879 859 l 745 708 q 649 862 724 805 q 473 920 573 920 q 219 791 312 920 q 136 509 136 675 q 217 229 136 344 q 470 99 311 99 q 672 179 591 99 q 753 379 753 259 l 886 379 "},"!":{"x_min":0,"x_max":138,"ha":236,"o":"m 138 684 q 116 409 138 629 q 105 244 105 299 l 33 244 q 16 465 33 313 q 0 684 0 616 l 0 1013 l 138 1013 l 138 684 m 138 0 l 0 0 l 0 151 l 138 151 l 138 0 "},"{":{"x_min":0,"x_max":480.5625,"ha":578,"o":"m 480 -286 q 237 -213 303 -286 q 187 -45 187 -159 q 194 48 187 -15 q 201 141 201 112 q 164 264 201 225 q 0 314 118 314 l 0 417 q 164 471 119 417 q 201 605 201 514 q 199 665 201 644 q 193 772 193 769 q 241 941 193 887 q 480 1015 308 1015 l 480 915 q 336 866 375 915 q 306 742 306 828 q 310 662 306 717 q 314 577 314 606 q 288 452 314 500 q 176 365 256 391 q 289 275 257 337 q 314 143 314 226 q 313 84 314 107 q 310 -11 310 -5 q 339 -131 310 -94 q 480 -182 377 -182 l 480 -286 "},"X":{"x_min":-0.015625,"x_max":854.15625,"ha":940,"o":"m 854 0 l 683 0 l 423 409 l 166 0 l 0 0 l 347 519 l 18 1013 l 186 1013 l 428 637 l 675 1013 l 836 1013 l 504 520 l 854 0 "},"#":{"x_min":0,"x_max":963.890625,"ha":1061,"o":"m 963 690 l 927 590 l 719 590 l 655 410 l 876 410 l 840 310 l 618 310 l 508 -3 l 393 -2 l 506 309 l 329 310 l 215 -2 l 102 -3 l 212 310 l 0 310 l 36 410 l 248 409 l 312 590 l 86 590 l 120 690 l 347 690 l 459 1006 l 573 1006 l 462 690 l 640 690 l 751 1006 l 865 1006 l 754 690 l 963 690 m 606 590 l 425 590 l 362 410 l 543 410 l 606 590 "},"?":{"x_min":42,"x_max":284,"ha":361,"o":"m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 738 l 167 738 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 103 239 101 q 284 112 257 104 l 284 3 "},"?":{"x_min":0,"x_max":906.953125,"ha":982,"o":"m 283 1040 l 88 799 l 5 799 l 145 1040 l 283 1040 m 906 0 l 756 0 l 650 303 l 251 303 l 143 0 l 0 0 l 376 1012 l 529 1012 l 906 0 m 609 421 l 452 866 l 293 421 l 609 421 "},")":{"x_min":0,"x_max":318,"ha":415,"o":"m 318 365 q 257 25 318 191 q 87 -290 197 -141 l 0 -290 q 140 21 93 -128 q 193 360 193 189 q 141 704 193 537 q 0 1024 97 850 l 87 1024 q 257 706 197 871 q 318 365 318 542 "},"?":{"x_min":0,"x_max":634.71875,"ha":714,"o":"m 634 234 q 527 38 634 110 q 300 -25 433 -25 q 98 29 183 -25 q 0 204 0 93 q 37 314 0 265 q 128 390 67 353 q 56 460 82 419 q 26 555 26 505 q 114 712 26 654 q 295 763 191 763 q 499 700 416 763 q 589 515 589 631 l 478 515 q 419 618 464 580 q 307 657 374 657 q 207 630 253 657 q 151 547 151 598 q 238 445 151 469 q 389 434 280 434 l 389 331 l 349 331 q 206 315 255 331 q 125 210 125 287 q 183 107 125 145 q 302 76 233 76 q 436 117 379 76 q 509 234 493 159 l 634 234 "},"?":{"x_min":0,"x_max":952.78125,"ha":1028,"o":"m 952 0 l 0 0 l 400 1013 l 551 1013 l 952 0 m 762 124 l 476 867 l 187 124 l 762 124 "},"}":{"x_min":0,"x_max":481,"ha":578,"o":"m 481 314 q 318 262 364 314 q 282 136 282 222 q 284 65 282 97 q 293 -58 293 -48 q 241 -217 293 -166 q 0 -286 174 -286 l 0 -182 q 143 -130 105 -182 q 171 -2 171 -93 q 168 81 171 22 q 165 144 165 140 q 188 275 165 229 q 306 365 220 339 q 191 455 224 391 q 165 588 165 505 q 168 681 165 624 q 171 742 171 737 q 141 865 171 827 q 0 915 102 915 l 0 1015 q 243 942 176 1015 q 293 773 293 888 q 287 675 293 741 q 282 590 282 608 q 318 466 282 505 q 481 417 364 417 l 481 314 "},"":{"x_min":-3,"x_max":1672,"ha":1821,"o":"m 846 0 q 664 76 732 0 q 603 244 603 145 q 662 412 603 344 q 846 489 729 489 q 1027 412 959 489 q 1089 244 1089 343 q 1029 76 1089 144 q 846 0 962 0 m 845 103 q 945 143 910 103 q 981 243 981 184 q 947 340 981 301 q 845 385 910 385 q 745 342 782 385 q 709 243 709 300 q 742 147 709 186 q 845 103 781 103 m 888 986 l 284 -25 l 199 -25 l 803 986 l 888 986 m 241 468 q 58 545 126 468 q -3 715 -3 615 q 56 881 -3 813 q 238 958 124 958 q 421 881 353 958 q 483 712 483 813 q 423 544 483 612 q 241 468 356 468 m 241 855 q 137 811 175 855 q 100 710 100 768 q 136 612 100 653 q 240 572 172 572 q 344 614 306 572 q 382 713 382 656 q 347 810 382 771 q 241 855 308 855 m 1428 0 q 1246 76 1314 0 q 1185 244 1185 145 q 1244 412 1185 344 q 1428 489 1311 489 q 1610 412 1542 489 q 1672 244 1672 343 q 1612 76 1672 144 q 1428 0 1545 0 m 1427 103 q 1528 143 1492 103 q 1564 243 1564 184 q 1530 340 1564 301 q 1427 385 1492 385 q 1327 342 1364 385 q 1291 243 1291 300 q 1324 147 1291 186 q 1427 103 1363 103 "},"a":{"x_min":0,"x_max":698.609375,"ha":794,"o":"m 698 0 q 661 -12 679 -7 q 615 -17 643 -17 q 536 12 564 -17 q 500 96 508 41 q 384 6 456 37 q 236 -25 312 -25 q 65 31 130 -25 q 0 194 0 88 q 118 390 0 334 q 328 435 180 420 q 488 483 476 451 q 495 523 495 504 q 442 619 495 584 q 325 654 389 654 q 209 617 257 654 q 152 513 161 580 l 33 513 q 123 705 33 633 q 332 772 207 772 q 528 712 448 772 q 617 531 617 645 l 617 163 q 624 108 617 126 q 664 90 632 90 l 698 94 l 698 0 m 491 262 l 491 372 q 272 329 350 347 q 128 201 128 294 q 166 113 128 144 q 264 83 205 83 q 414 130 346 83 q 491 262 491 183 "},"":{"x_min":0,"x_max":941.671875,"ha":1039,"o":"m 941 334 l 0 334 l 0 410 l 941 410 l 941 334 "},"=":{"x_min":8.71875,"x_max":780.953125,"ha":792,"o":"m 780 510 l 8 510 l 8 606 l 780 606 l 780 510 m 780 235 l 8 235 l 8 332 l 780 332 l 780 235 "},"N":{"x_min":0,"x_max":801,"ha":914,"o":"m 801 0 l 651 0 l 131 823 l 131 0 l 0 0 l 0 1013 l 151 1013 l 670 193 l 670 1013 l 801 1013 l 801 0 "},"?":{"x_min":0,"x_max":712,"ha":797,"o":"m 712 369 q 620 94 712 207 q 362 -26 521 -26 q 230 2 292 -26 q 119 83 167 30 l 119 -278 l 0 -278 l 0 362 q 91 643 0 531 q 355 764 190 764 q 617 647 517 764 q 712 369 712 536 m 583 366 q 530 559 583 480 q 359 651 469 651 q 190 562 252 651 q 135 370 135 483 q 189 176 135 257 q 359 85 250 85 q 528 175 466 85 q 583 366 583 254 "},"2":{"x_min":59,"x_max":731,"ha":792,"o":"m 731 0 l 59 0 q 197 314 59 188 q 457 487 199 315 q 598 691 598 580 q 543 819 598 772 q 411 867 488 867 q 272 811 328 867 q 209 630 209 747 l 81 630 q 182 901 81 805 q 408 986 271 986 q 629 909 536 986 q 731 694 731 826 q 613 449 731 541 q 378 316 495 383 q 201 122 235 234 l 731 122 l 731 0 "},"":{"x_min":0,"x_max":941.671875,"ha":938,"o":"m 941 1033 l 0 1033 l 0 1109 l 941 1109 l 941 1033 "},"Z":{"x_min":0,"x_max":779,"ha":849,"o":"m 779 0 l 0 0 l 0 113 l 621 896 l 40 896 l 40 1013 l 779 1013 l 778 887 l 171 124 l 779 124 l 779 0 "},"u":{"x_min":0,"x_max":617,"ha":729,"o":"m 617 0 l 499 0 l 499 110 q 391 10 460 45 q 246 -25 322 -25 q 61 58 127 -25 q 0 258 0 136 l 0 738 l 125 738 l 125 284 q 156 148 125 202 q 273 82 197 82 q 433 165 369 82 q 493 340 493 243 l 493 738 l 617 738 l 617 0 "},"k":{"x_min":0,"x_max":612.484375,"ha":697,"o":"m 612 738 l 338 465 l 608 0 l 469 0 l 251 382 l 121 251 l 121 0 l 0 0 l 0 1013 l 121 1013 l 121 402 l 456 738 l 612 738 "},"?":{"x_min":0,"x_max":803,"ha":917,"o":"m 803 0 l 667 0 l 667 475 l 140 475 l 140 0 l 0 0 l 0 1013 l 140 1013 l 140 599 l 667 599 l 667 1013 l 803 1013 l 803 0 "},"?":{"x_min":0,"x_max":906.953125,"ha":985,"o":"m 906 0 l 756 0 l 650 303 l 251 303 l 143 0 l 0 0 l 376 1013 l 529 1013 l 906 0 m 609 421 l 452 866 l 293 421 l 609 421 "},"s":{"x_min":0,"x_max":604,"ha":697,"o":"m 604 217 q 501 36 604 104 q 292 -23 411 -23 q 86 43 166 -23 q 0 238 0 114 l 121 237 q 175 122 121 164 q 300 85 223 85 q 415 112 363 85 q 479 207 479 147 q 361 309 479 276 q 140 372 141 370 q 21 544 21 426 q 111 708 21 647 q 298 761 190 761 q 492 705 413 761 q 583 531 583 643 l 462 531 q 412 625 462 594 q 298 657 363 657 q 199 636 242 657 q 143 558 143 608 q 262 454 143 486 q 484 394 479 397 q 604 217 604 341 "},"B":{"x_min":0,"x_max":778,"ha":876,"o":"m 580 546 q 724 469 670 535 q 778 311 778 403 q 673 83 778 171 q 432 0 575 0 l 0 0 l 0 1013 l 411 1013 q 629 957 541 1013 q 732 768 732 892 q 691 633 732 693 q 580 546 650 572 m 393 899 l 139 899 l 139 588 l 379 588 q 521 624 462 588 q 592 744 592 667 q 531 859 592 819 q 393 899 471 899 m 419 124 q 566 169 504 124 q 635 303 635 219 q 559 436 635 389 q 402 477 494 477 l 139 477 l 139 124 l 419 124 "},"":{"x_min":0,"x_max":614,"ha":708,"o":"m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 m 378 0 l 236 0 l 236 151 l 378 151 l 378 0 m 614 0 l 472 0 l 472 151 l 614 151 l 614 0 "},"?":{"x_min":0,"x_max":607,"ha":704,"o":"m 607 777 q 543 599 607 674 q 422 474 482 537 q 357 272 357 391 l 236 272 q 297 487 236 395 q 411 619 298 490 q 474 762 474 691 q 422 885 474 838 q 301 933 371 933 q 179 880 228 933 q 124 706 124 819 l 0 706 q 94 963 0 872 q 302 1044 177 1044 q 511 973 423 1044 q 607 777 607 895 m 370 0 l 230 0 l 230 151 l 370 151 l 370 0 "},"H":{"x_min":0,"x_max":803,"ha":915,"o":"m 803 0 l 667 0 l 667 475 l 140 475 l 140 0 l 0 0 l 0 1013 l 140 1013 l 140 599 l 667 599 l 667 1013 l 803 1013 l 803 0 "},"?":{"x_min":0,"x_max":675,"ha":761,"o":"m 675 738 l 404 0 l 272 0 l 0 738 l 133 738 l 340 147 l 541 738 l 675 738 "},"c":{"x_min":1,"x_max":701.390625,"ha":775,"o":"m 701 264 q 584 53 681 133 q 353 -26 487 -26 q 91 91 188 -26 q 1 370 1 201 q 92 645 1 537 q 353 761 190 761 q 572 688 479 761 q 690 493 666 615 l 556 493 q 487 606 545 562 q 356 650 428 650 q 186 563 246 650 q 134 372 134 487 q 188 179 134 258 q 359 88 250 88 q 492 136 437 88 q 566 264 548 185 l 701 264 "},"":{"x_min":0,"x_max":566.671875,"ha":678,"o":"m 21 892 l 52 892 l 98 761 l 145 892 l 176 892 l 178 741 l 157 741 l 157 867 l 108 741 l 88 741 l 40 871 l 40 741 l 21 741 l 21 892 m 308 854 l 308 731 q 252 691 308 691 q 227 691 240 691 q 207 696 213 695 l 207 712 l 253 706 q 288 733 288 706 l 288 763 q 244 741 279 741 q 193 797 193 741 q 261 860 193 860 q 287 860 273 860 q 308 854 302 855 m 288 842 l 263 843 q 213 796 213 843 q 248 756 213 756 q 288 796 288 756 l 288 842 m 566 988 l 502 988 l 502 -1 l 439 -1 l 439 988 l 317 988 l 317 -1 l 252 -1 l 252 602 q 81 653 155 602 q 0 805 0 711 q 101 989 0 918 q 309 1053 194 1053 l 566 1053 l 566 988 "},"?":{"x_min":0,"x_max":660,"ha":745,"o":"m 471 550 q 610 450 561 522 q 660 280 660 378 q 578 64 660 151 q 367 -22 497 -22 q 239 5 299 -22 q 126 82 178 32 l 126 -278 l 0 -278 l 0 593 q 54 903 0 801 q 318 1042 127 1042 q 519 964 436 1042 q 603 771 603 887 q 567 644 603 701 q 471 550 532 586 m 337 79 q 476 138 418 79 q 535 279 535 198 q 427 437 535 386 q 226 477 344 477 l 226 583 q 398 620 329 583 q 486 762 486 668 q 435 884 486 833 q 312 935 384 935 q 169 861 219 935 q 126 698 126 797 l 126 362 q 170 169 126 242 q 337 79 224 79 "},"?":{"x_min":0,"x_max":954,"ha":1068,"o":"m 954 0 l 819 0 l 819 868 l 537 0 l 405 0 l 128 865 l 128 0 l 0 0 l 0 1013 l 199 1013 l 472 158 l 758 1013 l 954 1013 l 954 0 "},"?":{"x_min":0.109375,"x_max":1120,"ha":1217,"o":"m 1120 505 q 994 132 1120 282 q 642 -29 861 -29 q 290 130 422 -29 q 167 505 167 280 q 294 883 167 730 q 650 1046 430 1046 q 999 882 868 1046 q 1120 505 1120 730 m 977 504 q 896 784 977 669 q 644 915 804 915 q 391 785 484 915 q 307 504 307 669 q 391 224 307 339 q 644 95 486 95 q 894 224 803 95 q 977 504 977 339 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 "},"?":{"x_min":0,"x_max":1158,"ha":1275,"o":"m 1158 0 l 1022 0 l 1022 475 l 496 475 l 496 0 l 356 0 l 356 1012 l 496 1012 l 496 599 l 1022 599 l 1022 1012 l 1158 1012 l 1158 0 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 "},"":{"x_min":0,"x_max":663.890625,"ha":775,"o":"m 663 529 q 566 293 663 391 q 331 196 469 196 q 97 294 194 196 q 0 529 0 393 q 96 763 0 665 q 331 861 193 861 q 566 763 469 861 q 663 529 663 665 "},"":{"x_min":0.1875,"x_max":819.546875,"ha":886,"o":"m 563 561 l 697 561 l 696 487 l 520 487 l 482 416 l 482 380 l 697 380 l 695 308 l 482 308 l 482 0 l 342 0 l 342 308 l 125 308 l 125 380 l 342 380 l 342 417 l 303 487 l 125 487 l 125 561 l 258 561 l 0 1013 l 140 1013 l 411 533 l 679 1013 l 819 1013 l 563 561 "},"(":{"x_min":0,"x_max":318.0625,"ha":415,"o":"m 318 -290 l 230 -290 q 61 23 122 -142 q 0 365 0 190 q 62 712 0 540 q 230 1024 119 869 l 318 1024 q 175 705 219 853 q 125 360 125 542 q 176 22 125 187 q 318 -290 223 -127 "},"U":{"x_min":0,"x_max":796,"ha":904,"o":"m 796 393 q 681 93 796 212 q 386 -25 566 -25 q 101 95 208 -25 q 0 393 0 211 l 0 1013 l 138 1013 l 138 391 q 204 191 138 270 q 394 107 276 107 q 586 191 512 107 q 656 391 656 270 l 656 1013 l 796 1013 l 796 393 "},"?":{"x_min":0.5,"x_max":744.953125,"ha":822,"o":"m 744 737 l 463 54 l 463 -278 l 338 -278 l 338 54 l 154 495 q 104 597 124 569 q 13 651 67 651 l 0 651 l 0 751 l 39 753 q 168 711 121 753 q 242 594 207 676 l 403 208 l 617 737 l 744 737 "},"?":{"x_min":0,"x_max":765.5625,"ha":809,"o":"m 765 -4 q 698 -14 726 -14 q 564 97 586 -14 q 466 7 525 40 q 337 -26 407 -26 q 88 98 186 -26 q 0 369 0 212 q 88 637 0 525 q 337 760 184 760 q 465 728 407 760 q 563 637 524 696 l 563 739 l 685 739 l 685 222 q 693 141 685 168 q 748 94 708 94 q 765 96 760 94 l 765 -4 m 584 371 q 531 562 584 485 q 360 653 470 653 q 192 566 254 653 q 135 379 135 489 q 186 181 135 261 q 358 84 247 84 q 528 176 465 84 q 584 371 584 260 "},"F":{"x_min":0,"x_max":683.328125,"ha":717,"o":"m 683 888 l 140 888 l 140 583 l 613 583 l 613 458 l 140 458 l 140 0 l 0 0 l 0 1013 l 683 1013 l 683 888 "},"":{"x_min":0,"x_max":705.5625,"ha":803,"o":"m 705 334 l 0 334 l 0 410 l 705 410 l 705 334 "},":":{"x_min":0,"x_max":142,"ha":239,"o":"m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 "},"?":{"x_min":0,"x_max":854.171875,"ha":935,"o":"m 854 0 l 683 0 l 423 409 l 166 0 l 0 0 l 347 519 l 18 1013 l 186 1013 l 427 637 l 675 1013 l 836 1013 l 504 521 l 854 0 "},"*":{"x_min":116,"x_max":674,"ha":792,"o":"m 674 768 l 475 713 l 610 544 l 517 477 l 394 652 l 272 478 l 178 544 l 314 713 l 116 766 l 153 876 l 341 812 l 342 1013 l 446 1013 l 446 811 l 635 874 l 674 768 "},"":{"x_min":0,"x_max":777,"ha":835,"o":"m 458 804 l 777 804 l 777 683 l 458 683 l 458 0 l 319 0 l 319 681 l 0 683 l 0 804 l 319 804 l 319 1015 l 458 1013 l 458 804 "},"":{"x_min":0,"x_max":347,"ha":444,"o":"m 173 802 q 43 856 91 802 q 0 977 0 905 q 45 1101 0 1049 q 173 1153 90 1153 q 303 1098 255 1153 q 347 977 347 1049 q 303 856 347 905 q 173 802 256 802 m 173 884 q 238 910 214 884 q 262 973 262 937 q 239 1038 262 1012 q 173 1064 217 1064 q 108 1037 132 1064 q 85 973 85 1010 q 108 910 85 937 q 173 884 132 884 "},"V":{"x_min":0,"x_max":862.71875,"ha":940,"o":"m 862 1013 l 505 0 l 361 0 l 0 1013 l 143 1013 l 434 165 l 718 1012 l 862 1013 "},"?":{"x_min":0,"x_max":734.71875,"ha":763,"o":"m 723 889 l 9 889 l 9 1013 l 723 1013 l 723 889 m 673 463 l 61 463 l 61 589 l 673 589 l 673 463 m 734 0 l 0 0 l 0 124 l 734 124 l 734 0 "},"":{"x_min":0,"x_max":0,"ha":853},"?":{"x_min":0.328125,"x_max":819.515625,"ha":889,"o":"m 588 1046 l 460 1046 l 460 1189 l 588 1189 l 588 1046 m 360 1046 l 232 1046 l 232 1189 l 360 1189 l 360 1046 m 819 1012 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1012 l 140 1012 l 411 533 l 679 1012 l 819 1012 "},"0":{"x_min":73,"x_max":715,"ha":792,"o":"m 394 -29 q 153 129 242 -29 q 73 479 73 272 q 152 829 73 687 q 394 989 241 989 q 634 829 545 989 q 715 479 715 684 q 635 129 715 270 q 394 -29 546 -29 m 394 89 q 546 211 489 89 q 598 479 598 322 q 548 748 598 640 q 394 871 491 871 q 241 748 298 871 q 190 479 190 637 q 239 211 190 319 q 394 89 296 89 "},"":{"x_min":0,"x_max":347,"ha":454,"o":"m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 m 347 851 q 310 737 347 784 q 208 669 273 690 l 208 734 q 267 787 250 741 q 280 873 280 821 l 208 873 l 208 1013 l 347 1013 l 347 851 "},"@":{"x_min":0,"x_max":1260,"ha":1357,"o":"m 1098 -45 q 877 -160 1001 -117 q 633 -203 752 -203 q 155 -29 327 -203 q 0 360 0 127 q 176 802 0 616 q 687 1008 372 1008 q 1123 854 969 1008 q 1260 517 1260 718 q 1155 216 1260 341 q 868 82 1044 82 q 772 106 801 82 q 737 202 737 135 q 647 113 700 144 q 527 82 594 82 q 367 147 420 82 q 314 312 314 212 q 401 565 314 452 q 639 690 498 690 q 810 588 760 690 l 849 668 l 938 668 q 877 441 900 532 q 833 226 833 268 q 853 182 833 198 q 902 167 873 167 q 1088 272 1012 167 q 1159 512 1159 372 q 1051 793 1159 681 q 687 925 925 925 q 248 747 415 925 q 97 361 97 586 q 226 26 97 159 q 627 -122 370 -122 q 856 -87 737 -122 q 1061 8 976 -53 l 1098 -45 m 786 488 q 738 580 777 545 q 643 615 700 615 q 483 517 548 615 q 425 322 425 430 q 457 203 425 250 q 552 156 490 156 q 722 273 665 156 q 786 488 738 309 "},"?":{"x_min":0,"x_max":499,"ha":613,"o":"m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 m 499 0 l 360 0 l 360 1012 l 499 1012 l 499 0 "},"i":{"x_min":14,"x_max":136,"ha":275,"o":"m 136 873 l 14 873 l 14 1013 l 136 1013 l 136 873 m 136 0 l 14 0 l 14 737 l 136 737 l 136 0 "},"?":{"x_min":0,"x_max":778,"ha":877,"o":"m 580 545 q 724 468 671 534 q 778 310 778 402 q 673 83 778 170 q 432 0 575 0 l 0 0 l 0 1013 l 411 1013 q 629 957 541 1013 q 732 768 732 891 q 691 632 732 692 q 580 545 650 571 m 393 899 l 139 899 l 139 587 l 379 587 q 521 623 462 587 q 592 744 592 666 q 531 859 592 819 q 393 899 471 899 m 419 124 q 566 169 504 124 q 635 302 635 219 q 559 435 635 388 q 402 476 494 476 l 139 476 l 139 124 l 419 124 "},"?":{"x_min":0,"x_max":617,"ha":725,"o":"m 617 352 q 540 94 617 199 q 308 -24 455 -24 q 76 94 161 -24 q 0 352 0 199 l 0 739 l 126 739 l 126 355 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 355 492 257 l 492 739 l 617 739 l 617 352 "},"]":{"x_min":0,"x_max":275,"ha":372,"o":"m 275 -281 l 0 -281 l 0 -187 l 151 -187 l 151 920 l 0 920 l 0 1013 l 275 1013 l 275 -281 "},"m":{"x_min":0,"x_max":1019,"ha":1128,"o":"m 1019 0 l 897 0 l 897 454 q 860 591 897 536 q 739 660 816 660 q 613 586 659 660 q 573 436 573 522 l 573 0 l 447 0 l 447 455 q 412 591 447 535 q 294 657 372 657 q 165 586 213 657 q 122 437 122 521 l 122 0 l 0 0 l 0 738 l 117 738 l 117 640 q 202 730 150 697 q 316 763 254 763 q 437 730 381 763 q 525 642 494 697 q 621 731 559 700 q 753 763 682 763 q 943 694 867 763 q 1019 512 1019 625 l 1019 0 "},"?":{"x_min":8.328125,"x_max":780.5625,"ha":815,"o":"m 780 -278 q 715 -294 747 -294 q 616 -257 663 -294 q 548 -175 576 -227 l 379 133 l 143 -277 l 9 -277 l 313 254 l 163 522 q 127 586 131 580 q 36 640 91 640 q 8 637 27 640 l 8 752 l 52 757 q 162 719 113 757 q 236 627 200 690 l 383 372 l 594 737 l 726 737 l 448 250 l 625 -69 q 670 -153 647 -110 q 743 -188 695 -188 q 780 -184 759 -188 l 780 -278 "},"8":{"x_min":55,"x_max":736,"ha":792,"o":"m 571 527 q 694 424 652 491 q 736 280 736 358 q 648 71 736 158 q 395 -26 551 -26 q 142 69 238 -26 q 55 279 55 157 q 96 425 55 359 q 220 527 138 491 q 120 615 153 562 q 88 726 88 668 q 171 904 88 827 q 395 986 261 986 q 618 905 529 986 q 702 727 702 830 q 670 616 702 667 q 571 527 638 565 m 394 565 q 519 610 475 565 q 563 717 563 655 q 521 823 563 781 q 392 872 474 872 q 265 824 312 872 q 224 720 224 783 q 265 613 224 656 q 394 565 312 565 m 395 91 q 545 150 488 91 q 597 280 597 204 q 546 408 597 355 q 395 465 492 465 q 244 408 299 465 q 194 280 194 356 q 244 150 194 203 q 395 91 299 91 "},"?":{"x_min":42,"x_max":326.71875,"ha":361,"o":"m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 737 l 167 737 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 102 239 101 q 284 112 257 104 l 284 3 m 326 1040 l 137 819 l 54 819 l 189 1040 l 326 1040 "},"?":{"x_min":0,"x_max":779.171875,"ha":850,"o":"m 779 0 l 0 0 l 0 113 l 620 896 l 40 896 l 40 1013 l 779 1013 l 779 887 l 170 124 l 779 124 l 779 0 "},"R":{"x_min":0,"x_max":781.953125,"ha":907,"o":"m 781 0 l 623 0 q 587 242 590 52 q 407 433 585 433 l 138 433 l 138 0 l 0 0 l 0 1013 l 396 1013 q 636 946 539 1013 q 749 731 749 868 q 711 597 749 659 q 608 502 674 534 q 718 370 696 474 q 729 207 722 352 q 781 26 736 62 l 781 0 m 373 551 q 533 594 465 551 q 614 731 614 645 q 532 859 614 815 q 373 896 465 896 l 138 896 l 138 551 l 373 551 "},"o":{"x_min":0,"x_max":713,"ha":821,"o":"m 357 -25 q 94 91 194 -25 q 0 368 0 202 q 93 642 0 533 q 357 761 193 761 q 618 644 518 761 q 713 368 713 533 q 619 91 713 201 q 357 -25 521 -25 m 357 85 q 528 175 465 85 q 584 369 584 255 q 529 562 584 484 q 357 651 467 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 357 85 250 85 "},"5":{"x_min":54.171875,"x_max":738,"ha":792,"o":"m 738 314 q 626 60 738 153 q 382 -23 526 -23 q 155 47 248 -23 q 54 256 54 125 l 183 256 q 259 132 204 174 q 382 91 314 91 q 533 149 471 91 q 602 314 602 213 q 538 469 602 411 q 386 528 475 528 q 284 506 332 528 q 197 439 237 484 l 81 439 l 159 958 l 684 958 l 684 840 l 254 840 l 214 579 q 306 627 258 612 q 407 643 354 643 q 636 552 540 643 q 738 314 738 457 "},"7":{"x_min":58.71875,"x_max":730.953125,"ha":792,"o":"m 730 839 q 469 448 560 641 q 335 0 378 255 l 192 0 q 328 441 235 252 q 593 830 421 630 l 58 830 l 58 958 l 730 958 l 730 839 "},"K":{"x_min":0,"x_max":819.46875,"ha":906,"o":"m 819 0 l 649 0 l 294 509 l 139 355 l 139 0 l 0 0 l 0 1013 l 139 1013 l 139 526 l 626 1013 l 809 1013 l 395 600 l 819 0 "},",":{"x_min":0,"x_max":142,"ha":239,"o":"m 142 -12 q 105 -132 142 -82 q 0 -205 68 -182 l 0 -138 q 57 -82 40 -124 q 70 0 70 -51 l 0 0 l 0 151 l 142 151 l 142 -12 "},"d":{"x_min":0,"x_max":683,"ha":796,"o":"m 683 0 l 564 0 l 564 93 q 456 6 516 38 q 327 -25 395 -25 q 87 100 181 -25 q 0 365 0 215 q 90 639 0 525 q 343 763 187 763 q 564 647 486 763 l 564 1013 l 683 1013 l 683 0 m 582 373 q 529 562 582 484 q 361 653 468 653 q 190 561 253 653 q 135 365 135 479 q 189 175 135 254 q 358 85 251 85 q 529 178 468 85 q 582 373 582 258 "},"":{"x_min":-109,"x_max":247,"ha":232,"o":"m 247 1046 l 119 1046 l 119 1189 l 247 1189 l 247 1046 m 19 1046 l -109 1046 l -109 1189 l 19 1189 l 19 1046 "},"E":{"x_min":0,"x_max":736.109375,"ha":789,"o":"m 736 0 l 0 0 l 0 1013 l 725 1013 l 725 889 l 139 889 l 139 585 l 677 585 l 677 467 l 139 467 l 139 125 l 736 125 l 736 0 "},"Y":{"x_min":0,"x_max":820,"ha":886,"o":"m 820 1013 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1013 l 140 1013 l 411 534 l 679 1012 l 820 1013 "},"\"":{"x_min":0,"x_max":299,"ha":396,"o":"m 299 606 l 203 606 l 203 988 l 299 988 l 299 606 m 96 606 l 0 606 l 0 988 l 96 988 l 96 606 "},"":{"x_min":17.984375,"x_max":773.609375,"ha":792,"o":"m 773 40 l 18 376 l 17 465 l 773 799 l 773 692 l 159 420 l 773 149 l 773 40 "},"":{"x_min":0,"x_max":364,"ha":467,"o":"m 141 -12 q 104 -132 141 -82 q 0 -205 67 -182 l 0 -138 q 56 -82 40 -124 q 69 0 69 -51 l 0 0 l 0 151 l 141 151 l 141 -12 m 364 -12 q 327 -132 364 -82 q 222 -205 290 -182 l 222 -138 q 279 -82 262 -124 q 292 0 292 -51 l 222 0 l 222 151 l 364 151 l 364 -12 "},"?":{"x_min":1,"x_max":710,"ha":810,"o":"m 710 360 q 616 87 710 196 q 356 -28 518 -28 q 99 82 197 -28 q 1 356 1 192 q 100 606 1 509 q 355 703 199 703 q 180 829 288 754 q 70 903 124 866 l 70 1012 l 643 1012 l 643 901 l 258 901 q 462 763 422 794 q 636 592 577 677 q 710 360 710 485 m 584 365 q 552 501 584 447 q 451 602 521 555 q 372 611 411 611 q 197 541 258 611 q 136 355 136 472 q 190 171 136 245 q 358 85 252 85 q 528 173 465 85 q 584 365 584 252 "},"?":{"x_min":0,"x_max":634.71875,"ha":714,"o":"m 634 234 q 527 38 634 110 q 300 -25 433 -25 q 98 29 183 -25 q 0 204 0 93 q 37 313 0 265 q 128 390 67 352 q 56 459 82 419 q 26 555 26 505 q 114 712 26 654 q 295 763 191 763 q 499 700 416 763 q 589 515 589 631 l 478 515 q 419 618 464 580 q 307 657 374 657 q 207 630 253 657 q 151 547 151 598 q 238 445 151 469 q 389 434 280 434 l 389 331 l 349 331 q 206 315 255 331 q 125 210 125 287 q 183 107 125 145 q 302 76 233 76 q 436 117 379 76 q 509 234 493 159 l 634 234 m 520 1040 l 331 819 l 248 819 l 383 1040 l 520 1040 "},"?":{"x_min":0,"x_max":922,"ha":1031,"o":"m 922 339 q 856 97 922 203 q 650 -26 780 -26 q 538 9 587 -26 q 461 103 489 44 q 387 12 436 46 q 277 -22 339 -22 q 69 97 147 -22 q 0 339 0 203 q 45 551 0 444 q 161 738 84 643 l 302 738 q 175 553 219 647 q 124 336 124 446 q 155 179 124 249 q 275 88 197 88 q 375 163 341 88 q 400 294 400 219 l 400 572 l 524 572 l 524 294 q 561 135 524 192 q 643 88 591 88 q 762 182 719 88 q 797 342 797 257 q 745 556 797 450 q 619 738 705 638 l 760 738 q 874 551 835 640 q 922 339 922 444 "},"":{"x_min":0,"x_max":96,"ha":251,"o":"m 96 606 l 0 606 l 0 988 l 96 988 l 96 606 "},"":{"x_min":11,"x_max":781,"ha":792,"o":"m 781 490 l 446 490 l 446 255 l 349 255 l 349 490 l 11 490 l 11 586 l 349 586 l 349 819 l 446 819 l 446 586 l 781 586 l 781 490 m 781 21 l 11 21 l 11 115 l 781 115 l 781 21 "},"|":{"x_min":343,"x_max":449,"ha":792,"o":"m 449 462 l 343 462 l 343 986 l 449 986 l 449 462 m 449 -242 l 343 -242 l 343 280 l 449 280 l 449 -242 "},"?":{"x_min":0,"x_max":617,"ha":725,"o":"m 482 800 l 372 800 l 372 925 l 482 925 l 482 800 m 239 800 l 129 800 l 129 925 l 239 925 l 239 800 m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 "},"":{"x_min":0,"x_max":593,"ha":690,"o":"m 593 425 q 554 312 593 369 q 467 233 516 254 q 537 83 537 172 q 459 -74 537 -12 q 288 -133 387 -133 q 115 -69 184 -133 q 47 96 47 -6 l 166 96 q 199 7 166 40 q 288 -26 232 -26 q 371 -5 332 -26 q 420 60 420 21 q 311 201 420 139 q 108 309 210 255 q 0 490 0 383 q 33 602 0 551 q 124 687 66 654 q 75 743 93 712 q 58 812 58 773 q 133 984 58 920 q 300 1043 201 1043 q 458 987 394 1043 q 529 814 529 925 l 411 814 q 370 908 404 877 q 289 939 336 939 q 213 911 246 939 q 180 841 180 883 q 286 720 180 779 q 484 612 480 615 q 593 425 593 534 m 467 409 q 355 544 467 473 q 196 630 228 612 q 146 587 162 609 q 124 525 124 558 q 239 387 124 462 q 398 298 369 315 q 448 345 429 316 q 467 409 467 375 "},"b":{"x_min":0,"x_max":685,"ha":783,"o":"m 685 372 q 597 99 685 213 q 347 -25 501 -25 q 219 5 277 -25 q 121 93 161 36 l 121 0 l 0 0 l 0 1013 l 121 1013 l 121 634 q 214 723 157 692 q 341 754 272 754 q 591 637 493 754 q 685 372 685 526 m 554 356 q 499 550 554 470 q 328 644 437 644 q 162 556 223 644 q 108 369 108 478 q 160 176 108 256 q 330 83 221 83 q 498 169 435 83 q 554 356 554 245 "},"q":{"x_min":0,"x_max":683,"ha":876,"o":"m 683 -278 l 564 -278 l 564 97 q 474 8 533 39 q 345 -23 415 -23 q 91 93 188 -23 q 0 364 0 203 q 87 635 0 522 q 337 760 184 760 q 466 727 408 760 q 564 637 523 695 l 564 737 l 683 737 l 683 -278 m 582 375 q 527 564 582 488 q 358 652 466 652 q 190 565 253 652 q 135 377 135 488 q 189 179 135 261 q 361 84 251 84 q 530 179 469 84 q 582 375 582 260 "},"?":{"x_min":-0.171875,"x_max":969.5625,"ha":1068,"o":"m 969 0 l 555 0 l 555 123 q 744 308 675 194 q 814 558 814 423 q 726 812 814 709 q 484 922 633 922 q 244 820 334 922 q 154 567 154 719 q 223 316 154 433 q 412 123 292 199 l 412 0 l 0 0 l 0 124 l 217 124 q 68 327 122 210 q 15 572 15 444 q 144 911 15 781 q 484 1041 274 1041 q 822 909 691 1041 q 953 569 953 777 q 899 326 953 443 q 750 124 846 210 l 969 124 l 969 0 "},"?":{"x_min":0,"x_max":617,"ha":725,"o":"m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 m 535 1040 l 346 819 l 262 819 l 397 1040 l 535 1040 "},"z":{"x_min":-0.015625,"x_max":613.890625,"ha":697,"o":"m 613 0 l 0 0 l 0 100 l 433 630 l 20 630 l 20 738 l 594 738 l 593 636 l 163 110 l 613 110 l 613 0 "},"":{"x_min":0,"x_max":894,"ha":1000,"o":"m 389 951 l 229 951 l 229 503 l 160 503 l 160 951 l 0 951 l 0 1011 l 389 1011 l 389 951 m 894 503 l 827 503 l 827 939 l 685 503 l 620 503 l 481 937 l 481 503 l 417 503 l 417 1011 l 517 1011 l 653 580 l 796 1010 l 894 1011 l 894 503 "},"?":{"x_min":0.78125,"x_max":697,"ha":810,"o":"m 697 -278 l 572 -278 l 572 454 q 540 587 572 536 q 425 650 501 650 q 271 579 337 650 q 206 420 206 509 l 206 0 l 81 0 l 81 489 q 73 588 81 562 q 0 644 56 644 l 0 741 q 68 755 38 755 q 158 721 124 755 q 200 630 193 687 q 297 726 234 692 q 434 761 359 761 q 620 692 544 761 q 697 516 697 624 l 697 -278 m 479 1040 l 290 819 l 207 819 l 341 1040 l 479 1040 "},"?":{"x_min":0,"x_max":960,"ha":1056,"o":"m 960 507 q 833 129 960 280 q 476 -32 698 -32 q 123 129 255 -32 q 0 507 0 280 q 123 883 0 732 q 476 1045 255 1045 q 832 883 696 1045 q 960 507 960 732 m 817 500 q 733 789 817 669 q 476 924 639 924 q 223 792 317 924 q 142 507 142 675 q 222 222 142 339 q 476 89 315 89 q 730 218 636 89 q 817 500 817 334 m 716 449 l 243 449 l 243 571 l 716 571 l 716 449 "},"":{"x_min":-3,"x_max":1008,"ha":1106,"o":"m 503 532 q 614 562 566 532 q 672 658 672 598 q 614 747 672 716 q 503 772 569 772 l 338 772 l 338 532 l 503 532 m 502 -7 q 123 151 263 -7 q -3 501 -3 294 q 123 851 -3 706 q 502 1011 263 1011 q 881 851 739 1011 q 1008 501 1008 708 q 883 151 1008 292 q 502 -7 744 -7 m 502 60 q 830 197 709 60 q 940 501 940 322 q 831 805 940 681 q 502 944 709 944 q 174 805 296 944 q 65 501 65 680 q 173 197 65 320 q 502 60 294 60 m 788 146 l 678 146 q 653 316 655 183 q 527 449 652 449 l 338 449 l 338 146 l 241 146 l 241 854 l 518 854 q 688 808 621 854 q 766 658 766 755 q 739 563 766 607 q 668 497 713 519 q 751 331 747 472 q 788 164 756 190 l 788 146 "},"~":{"x_min":0,"x_max":833,"ha":931,"o":"m 833 958 q 778 753 833 831 q 594 665 716 665 q 402 761 502 665 q 240 857 302 857 q 131 795 166 857 q 104 665 104 745 l 0 665 q 54 867 0 789 q 237 958 116 958 q 429 861 331 958 q 594 765 527 765 q 704 827 670 765 q 729 958 729 874 l 833 958 "},"?":{"x_min":0,"x_max":736.21875,"ha":778,"o":"m 736 0 l 0 0 l 0 1013 l 725 1013 l 725 889 l 139 889 l 139 585 l 677 585 l 677 467 l 139 467 l 139 125 l 736 125 l 736 0 "},"":{"x_min":0,"x_max":450,"ha":547,"o":"m 450 552 q 379 413 450 464 q 220 366 313 366 q 69 414 130 366 q 0 567 0 470 l 85 567 q 126 470 85 504 q 225 437 168 437 q 320 467 280 437 q 360 552 360 498 q 318 632 360 608 q 213 657 276 657 q 195 657 203 657 q 176 657 181 657 l 176 722 q 279 733 249 722 q 334 815 334 752 q 300 881 334 856 q 220 907 267 907 q 133 875 169 907 q 97 781 97 844 l 15 781 q 78 926 15 875 q 220 972 135 972 q 364 930 303 972 q 426 817 426 888 q 344 697 426 733 q 421 642 392 681 q 450 552 450 603 "},"[":{"x_min":0,"x_max":273.609375,"ha":371,"o":"m 273 -281 l 0 -281 l 0 1013 l 273 1013 l 273 920 l 124 920 l 124 -187 l 273 -187 l 273 -281 "},"L":{"x_min":0,"x_max":645.828125,"ha":696,"o":"m 645 0 l 0 0 l 0 1013 l 140 1013 l 140 126 l 645 126 l 645 0 "},"?":{"x_min":0,"x_max":803.390625,"ha":894,"o":"m 803 628 l 633 628 q 713 368 713 512 q 618 93 713 204 q 357 -25 518 -25 q 94 91 194 -25 q 0 368 0 201 q 94 644 0 533 q 356 761 194 761 q 481 750 398 761 q 608 739 564 739 l 803 739 l 803 628 m 360 85 q 529 180 467 85 q 584 374 584 262 q 527 566 584 490 q 352 651 463 651 q 187 559 247 651 q 135 368 135 478 q 189 175 135 254 q 360 85 251 85 "},"?":{"x_min":0,"x_max":573,"ha":642,"o":"m 573 -40 q 553 -162 573 -97 q 510 -278 543 -193 l 400 -278 q 441 -187 428 -219 q 462 -90 462 -132 q 378 -14 462 -14 q 108 45 197 -14 q 0 290 0 117 q 108 631 0 462 q 353 901 194 767 l 55 901 l 55 1012 l 561 1012 l 561 924 q 261 669 382 831 q 128 301 128 489 q 243 117 128 149 q 458 98 350 108 q 573 -40 573 80 "},"?":{"x_min":0,"x_max":674,"ha":778,"o":"m 674 496 q 601 160 674 304 q 336 -26 508 -26 q 73 153 165 -26 q 0 485 0 296 q 72 840 0 683 q 343 1045 166 1045 q 605 844 516 1045 q 674 496 674 692 m 546 579 q 498 798 546 691 q 336 935 437 935 q 178 798 237 935 q 126 579 137 701 l 546 579 m 546 475 l 126 475 q 170 233 126 348 q 338 80 230 80 q 504 233 447 80 q 546 475 546 346 "},"?":{"x_min":0,"x_max":958,"ha":1054,"o":"m 485 1042 q 834 883 703 1042 q 958 511 958 735 q 834 136 958 287 q 481 -26 701 -26 q 126 130 261 -26 q 0 504 0 279 q 127 880 0 729 q 485 1042 263 1042 m 480 98 q 731 225 638 98 q 815 504 815 340 q 733 783 815 670 q 480 913 640 913 q 226 785 321 913 q 142 504 142 671 q 226 224 142 339 q 480 98 319 98 "},"?":{"x_min":0,"x_max":705.28125,"ha":749,"o":"m 705 886 l 140 886 l 140 0 l 0 0 l 0 1012 l 705 1012 l 705 886 "}," ":{"x_min":0,"x_max":0,"ha":375},"%":{"x_min":-3,"x_max":1089,"ha":1186,"o":"m 845 0 q 663 76 731 0 q 602 244 602 145 q 661 412 602 344 q 845 489 728 489 q 1027 412 959 489 q 1089 244 1089 343 q 1029 76 1089 144 q 845 0 962 0 m 844 103 q 945 143 909 103 q 981 243 981 184 q 947 340 981 301 q 844 385 909 385 q 744 342 781 385 q 708 243 708 300 q 741 147 708 186 q 844 103 780 103 m 888 986 l 284 -25 l 199 -25 l 803 986 l 888 986 m 241 468 q 58 545 126 468 q -3 715 -3 615 q 56 881 -3 813 q 238 958 124 958 q 421 881 353 958 q 483 712 483 813 q 423 544 483 612 q 241 468 356 468 m 241 855 q 137 811 175 855 q 100 710 100 768 q 136 612 100 653 q 240 572 172 572 q 344 614 306 572 q 382 713 382 656 q 347 810 382 771 q 241 855 308 855 "},"P":{"x_min":0,"x_max":726,"ha":806,"o":"m 424 1013 q 640 931 555 1013 q 726 719 726 850 q 637 506 726 587 q 413 426 548 426 l 140 426 l 140 0 l 0 0 l 0 1013 l 424 1013 m 379 889 l 140 889 l 140 548 l 372 548 q 522 589 459 548 q 593 720 593 637 q 528 845 593 801 q 379 889 463 889 "},"?":{"x_min":0,"x_max":1078.21875,"ha":1118,"o":"m 1078 0 l 342 0 l 342 1013 l 1067 1013 l 1067 889 l 481 889 l 481 585 l 1019 585 l 1019 467 l 481 467 l 481 125 l 1078 125 l 1078 0 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 "},"?":{"x_min":0.125,"x_max":1136.546875,"ha":1235,"o":"m 1136 0 l 722 0 l 722 123 q 911 309 842 194 q 981 558 981 423 q 893 813 981 710 q 651 923 800 923 q 411 821 501 923 q 321 568 321 720 q 390 316 321 433 q 579 123 459 200 l 579 0 l 166 0 l 166 124 l 384 124 q 235 327 289 210 q 182 572 182 444 q 311 912 182 782 q 651 1042 441 1042 q 989 910 858 1042 q 1120 569 1120 778 q 1066 326 1120 443 q 917 124 1013 210 l 1136 124 l 1136 0 m 277 1040 l 83 800 l 0 800 l 140 1041 l 277 1040 "},"_":{"x_min":0,"x_max":705.5625,"ha":803,"o":"m 705 -334 l 0 -334 l 0 -234 l 705 -234 l 705 -334 "},"?":{"x_min":-110,"x_max":246,"ha":275,"o":"m 246 1046 l 118 1046 l 118 1189 l 246 1189 l 246 1046 m 18 1046 l -110 1046 l -110 1189 l 18 1189 l 18 1046 m 136 0 l 0 0 l 0 1012 l 136 1012 l 136 0 "},"+":{"x_min":23,"x_max":768,"ha":792,"o":"m 768 372 l 444 372 l 444 0 l 347 0 l 347 372 l 23 372 l 23 468 l 347 468 l 347 840 l 444 840 l 444 468 l 768 468 l 768 372 "},"":{"x_min":0,"x_max":1050,"ha":1149,"o":"m 1050 0 l 625 0 q 712 178 625 108 q 878 277 722 187 q 967 385 967 328 q 932 456 967 429 q 850 484 897 484 q 759 450 798 484 q 721 352 721 416 l 640 352 q 706 502 640 448 q 851 551 766 551 q 987 509 931 551 q 1050 385 1050 462 q 976 251 1050 301 q 829 179 902 215 q 717 68 740 133 l 1050 68 l 1050 0 m 834 985 l 215 -28 l 130 -28 l 750 984 l 834 985 m 224 422 l 142 422 l 142 811 l 0 811 l 0 867 q 104 889 62 867 q 164 973 157 916 l 224 973 l 224 422 "},"?":{"x_min":0,"x_max":720,"ha":783,"o":"m 424 1013 q 637 933 554 1013 q 720 723 720 853 q 633 508 720 591 q 413 426 546 426 l 140 426 l 140 0 l 0 0 l 0 1013 l 424 1013 m 378 889 l 140 889 l 140 548 l 371 548 q 521 589 458 548 q 592 720 592 637 q 527 845 592 801 q 378 889 463 889 "},"'":{"x_min":0,"x_max":139,"ha":236,"o":"m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 "},"":{"x_min":0,"x_max":350,"ha":397,"o":"m 350 625 q 307 616 328 616 q 266 631 281 616 q 247 673 251 645 q 190 628 225 644 q 116 613 156 613 q 32 641 64 613 q 0 722 0 669 q 72 826 0 800 q 247 866 159 846 l 247 887 q 220 934 247 916 q 162 953 194 953 q 104 934 129 953 q 76 882 80 915 l 16 882 q 60 976 16 941 q 166 1011 104 1011 q 266 979 224 1011 q 308 891 308 948 l 308 706 q 311 679 308 688 q 331 670 315 670 l 350 672 l 350 625 m 247 757 l 247 811 q 136 790 175 798 q 64 726 64 773 q 83 682 64 697 q 132 667 103 667 q 207 690 174 667 q 247 757 247 718 "},"?":{"x_min":0,"x_max":450,"ha":553,"o":"m 450 800 l 340 800 l 340 925 l 450 925 l 450 800 m 406 1040 l 212 800 l 129 800 l 269 1040 l 406 1040 m 110 800 l 0 800 l 0 925 l 110 925 l 110 800 "},"T":{"x_min":0,"x_max":777,"ha":835,"o":"m 777 894 l 458 894 l 458 0 l 319 0 l 319 894 l 0 894 l 0 1013 l 777 1013 l 777 894 "},"?":{"x_min":0,"x_max":915,"ha":997,"o":"m 527 0 l 389 0 l 389 122 q 110 231 220 122 q 0 509 0 340 q 110 785 0 677 q 389 893 220 893 l 389 1013 l 527 1013 l 527 893 q 804 786 693 893 q 915 509 915 679 q 805 231 915 341 q 527 122 696 122 l 527 0 m 527 226 q 712 310 641 226 q 779 507 779 389 q 712 705 779 627 q 527 787 641 787 l 527 226 m 389 226 l 389 787 q 205 698 275 775 q 136 505 136 620 q 206 308 136 391 q 389 226 276 226 "},"?":{"x_min":0,"x_max":0,"ha":694},"j":{"x_min":-77.78125,"x_max":167,"ha":349,"o":"m 167 871 l 42 871 l 42 1013 l 167 1013 l 167 871 m 167 -80 q 121 -231 167 -184 q -26 -278 76 -278 l -77 -278 l -77 -164 l -41 -164 q 26 -143 11 -164 q 42 -65 42 -122 l 42 737 l 167 737 l 167 -80 "},"?":{"x_min":0,"x_max":756.953125,"ha":819,"o":"m 756 0 l 0 0 l 0 107 l 395 523 l 22 904 l 22 1013 l 745 1013 l 745 889 l 209 889 l 566 523 l 187 125 l 756 125 l 756 0 "},"1":{"x_min":215.671875,"x_max":574,"ha":792,"o":"m 574 0 l 442 0 l 442 697 l 215 697 l 215 796 q 386 833 330 796 q 475 986 447 875 l 574 986 l 574 0 "},"":{"x_min":18.0625,"x_max":774,"ha":792,"o":"m 774 376 l 18 40 l 18 149 l 631 421 l 18 692 l 18 799 l 774 465 l 774 376 "},"<":{"x_min":17.984375,"x_max":773.609375,"ha":792,"o":"m 773 40 l 18 376 l 17 465 l 773 799 l 773 692 l 159 420 l 773 149 l 773 40 "},"":{"x_min":0,"x_max":704.484375,"ha":801,"o":"m 704 41 q 623 -10 664 5 q 543 -26 583 -26 q 359 15 501 -26 q 243 36 288 36 q 158 23 197 36 q 73 -21 119 10 l 6 76 q 125 195 90 150 q 175 331 175 262 q 147 443 175 383 l 0 443 l 0 512 l 108 512 q 43 734 43 623 q 120 929 43 854 q 358 1010 204 1010 q 579 936 487 1010 q 678 729 678 857 l 678 684 l 552 684 q 504 838 552 780 q 362 896 457 896 q 216 852 263 896 q 176 747 176 815 q 199 627 176 697 q 248 512 217 574 l 468 512 l 468 443 l 279 443 q 297 356 297 398 q 230 194 297 279 q 153 107 211 170 q 227 133 190 125 q 293 142 264 142 q 410 119 339 142 q 516 96 482 96 q 579 105 550 96 q 648 142 608 115 l 704 41 "},"t":{"x_min":0,"x_max":367,"ha":458,"o":"m 367 0 q 312 -5 339 -2 q 262 -8 284 -8 q 145 28 183 -8 q 108 143 108 64 l 108 638 l 0 638 l 0 738 l 108 738 l 108 944 l 232 944 l 232 738 l 367 738 l 367 638 l 232 638 l 232 185 q 248 121 232 140 q 307 102 264 102 q 345 104 330 102 q 367 107 360 107 l 367 0 "},"":{"x_min":0,"x_max":706,"ha":803,"o":"m 706 411 l 706 158 l 630 158 l 630 335 l 0 335 l 0 411 l 706 411 "},"?":{"x_min":0,"x_max":750,"ha":803,"o":"m 750 -7 q 679 -15 716 -15 q 538 59 591 -15 q 466 214 512 97 l 336 551 l 126 0 l 0 0 l 270 705 q 223 837 247 770 q 116 899 190 899 q 90 898 100 899 l 90 1004 q 152 1011 125 1011 q 298 938 244 1011 q 373 783 326 901 l 605 192 q 649 115 629 136 q 716 95 669 95 l 736 95 q 750 97 745 97 l 750 -7 "},"W":{"x_min":0,"x_max":1263.890625,"ha":1351,"o":"m 1263 1013 l 995 0 l 859 0 l 627 837 l 405 0 l 265 0 l 0 1013 l 136 1013 l 342 202 l 556 1013 l 701 1013 l 921 207 l 1133 1012 l 1263 1013 "},">":{"x_min":18.0625,"x_max":774,"ha":792,"o":"m 774 376 l 18 40 l 18 149 l 631 421 l 18 692 l 18 799 l 774 465 l 774 376 "},"v":{"x_min":0,"x_max":675.15625,"ha":761,"o":"m 675 738 l 404 0 l 272 0 l 0 738 l 133 737 l 340 147 l 541 737 l 675 738 "},"?":{"x_min":0.28125,"x_max":644.5,"ha":703,"o":"m 644 628 l 382 628 l 382 179 q 388 120 382 137 q 436 91 401 91 q 474 94 447 91 q 504 97 501 97 l 504 0 q 454 -9 482 -5 q 401 -14 426 -14 q 278 67 308 -14 q 260 233 260 118 l 260 628 l 0 628 l 0 739 l 644 739 l 644 628 "},"?":{"x_min":0,"x_max":624.9375,"ha":699,"o":"m 624 -37 q 608 -153 624 -96 q 563 -278 593 -211 l 454 -278 q 491 -183 486 -200 q 511 -83 511 -126 q 484 -23 511 -44 q 370 1 452 1 q 323 0 354 1 q 283 -1 293 -1 q 84 76 169 -1 q 0 266 0 154 q 56 431 0 358 q 197 538 108 498 q 94 613 134 562 q 54 730 54 665 q 77 823 54 780 q 143 901 101 867 l 27 901 l 27 1012 l 576 1012 l 576 901 l 380 901 q 244 863 303 901 q 178 745 178 820 q 312 600 178 636 q 532 582 380 582 l 532 479 q 276 455 361 479 q 118 281 118 410 q 165 173 118 217 q 274 120 208 133 q 494 101 384 110 q 624 -37 624 76 "},"&":{"x_min":-3,"x_max":894.25,"ha":992,"o":"m 894 0 l 725 0 l 624 123 q 471 0 553 40 q 306 -41 390 -41 q 168 -7 231 -41 q 62 92 105 26 q 14 187 31 139 q -3 276 -3 235 q 55 433 -3 358 q 248 581 114 508 q 170 689 196 640 q 137 817 137 751 q 214 985 137 922 q 384 1041 284 1041 q 548 988 483 1041 q 622 824 622 928 q 563 666 622 739 q 431 556 516 608 l 621 326 q 649 407 639 361 q 663 493 653 426 l 781 493 q 703 229 781 352 l 894 0 m 504 818 q 468 908 504 877 q 384 940 433 940 q 293 907 331 940 q 255 818 255 875 q 289 714 255 767 q 363 628 313 678 q 477 729 446 682 q 504 818 504 771 m 556 209 l 314 499 q 179 395 223 449 q 135 283 135 341 q 146 222 135 253 q 183 158 158 192 q 333 80 241 80 q 556 209 448 80 "},"?":{"x_min":0,"x_max":862.5,"ha":942,"o":"m 862 0 l 719 0 l 426 847 l 143 0 l 0 0 l 356 1013 l 501 1013 l 862 0 "},"I":{"x_min":41,"x_max":180,"ha":293,"o":"m 180 0 l 41 0 l 41 1013 l 180 1013 l 180 0 "},"G":{"x_min":0,"x_max":921,"ha":1011,"o":"m 921 0 l 832 0 l 801 136 q 655 15 741 58 q 470 -28 568 -28 q 126 133 259 -28 q 0 499 0 284 q 125 881 0 731 q 486 1043 259 1043 q 763 957 647 1043 q 905 709 890 864 l 772 709 q 668 866 747 807 q 486 926 589 926 q 228 795 322 926 q 142 507 142 677 q 228 224 142 342 q 483 94 323 94 q 712 195 625 94 q 796 435 796 291 l 477 435 l 477 549 l 921 549 l 921 0 "},"?":{"x_min":0,"x_max":617,"ha":725,"o":"m 524 800 l 414 800 l 414 925 l 524 925 l 524 800 m 183 800 l 73 800 l 73 925 l 183 925 l 183 800 m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 m 489 1040 l 300 819 l 216 819 l 351 1040 l 489 1040 "},"`":{"x_min":0,"x_max":138.890625,"ha":236,"o":"m 138 699 l 0 699 l 0 861 q 36 974 0 929 q 138 1041 72 1020 l 138 977 q 82 931 95 969 q 69 839 69 893 l 138 839 l 138 699 "},"":{"x_min":0,"x_max":142,"ha":239,"o":"m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 "},"?":{"x_min":0.328125,"x_max":819.515625,"ha":889,"o":"m 819 1013 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1013 l 140 1013 l 411 533 l 679 1013 l 819 1013 "},"r":{"x_min":0,"x_max":355.5625,"ha":432,"o":"m 355 621 l 343 621 q 179 569 236 621 q 122 411 122 518 l 122 0 l 0 0 l 0 737 l 117 737 l 117 604 q 204 719 146 686 q 355 753 262 753 l 355 621 "},"x":{"x_min":0,"x_max":675,"ha":764,"o":"m 675 0 l 525 0 l 331 286 l 144 0 l 0 0 l 256 379 l 12 738 l 157 737 l 336 473 l 516 738 l 661 738 l 412 380 l 675 0 "},"?":{"x_min":0,"x_max":696.609375,"ha":747,"o":"m 696 -4 q 628 -14 657 -14 q 498 97 513 -14 q 422 8 470 41 q 313 -24 374 -24 q 207 3 258 -24 q 120 80 157 31 l 120 -278 l 0 -278 l 0 738 l 124 738 l 124 343 q 165 172 124 246 q 308 82 216 82 q 451 177 402 82 q 492 358 492 254 l 492 738 l 616 738 l 616 214 q 623 136 616 160 q 673 92 636 92 q 696 95 684 92 l 696 -4 "},"h":{"x_min":0,"x_max":615,"ha":724,"o":"m 615 472 l 615 0 l 490 0 l 490 454 q 456 590 490 535 q 338 654 416 654 q 186 588 251 654 q 122 436 122 522 l 122 0 l 0 0 l 0 1013 l 122 1013 l 122 633 q 218 727 149 694 q 362 760 287 760 q 552 676 484 760 q 615 472 615 600 "},".":{"x_min":0,"x_max":142,"ha":239,"o":"m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 "},"?":{"x_min":-2,"x_max":878,"ha":974,"o":"m 496 -279 l 378 -279 l 378 -17 q 101 88 204 -17 q -2 367 -2 194 q 68 626 -2 510 q 283 758 151 758 l 283 646 q 167 537 209 626 q 133 373 133 462 q 192 177 133 254 q 378 93 259 93 l 378 758 q 445 764 426 763 q 476 765 464 765 q 765 659 653 765 q 878 377 878 553 q 771 96 878 209 q 496 -17 665 -17 l 496 -279 m 496 93 l 514 93 q 687 183 623 93 q 746 380 746 265 q 691 569 746 491 q 522 658 629 658 l 496 656 l 496 93 "},";":{"x_min":0,"x_max":142,"ha":239,"o":"m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 m 142 -12 q 105 -132 142 -82 q 0 -206 68 -182 l 0 -138 q 58 -82 43 -123 q 68 0 68 -56 l 0 0 l 0 151 l 142 151 l 142 -12 "},"f":{"x_min":0,"x_max":378,"ha":472,"o":"m 378 638 l 246 638 l 246 0 l 121 0 l 121 638 l 0 638 l 0 738 l 121 738 q 137 935 121 887 q 290 1028 171 1028 q 320 1027 305 1028 q 378 1021 334 1026 l 378 908 q 323 918 346 918 q 257 870 273 918 q 246 780 246 840 l 246 738 l 378 738 l 378 638 "},"":{"x_min":1,"x_max":348.21875,"ha":454,"o":"m 140 670 l 1 670 l 1 830 q 37 943 1 897 q 140 1011 74 990 l 140 947 q 82 900 97 940 q 68 810 68 861 l 140 810 l 140 670 m 348 670 l 209 670 l 209 830 q 245 943 209 897 q 348 1011 282 990 l 348 947 q 290 900 305 940 q 276 810 276 861 l 348 810 l 348 670 "},"A":{"x_min":0.03125,"x_max":906.953125,"ha":1008,"o":"m 906 0 l 756 0 l 648 303 l 251 303 l 142 0 l 0 0 l 376 1013 l 529 1013 l 906 0 m 610 421 l 452 867 l 293 421 l 610 421 "},"6":{"x_min":53,"x_max":739,"ha":792,"o":"m 739 312 q 633 62 739 162 q 400 -31 534 -31 q 162 78 257 -31 q 53 439 53 206 q 178 859 53 712 q 441 986 284 986 q 643 912 559 986 q 732 713 732 833 l 601 713 q 544 830 594 786 q 426 875 494 875 q 268 793 331 875 q 193 517 193 697 q 301 597 240 570 q 427 624 362 624 q 643 540 552 624 q 739 312 739 451 m 603 298 q 540 461 603 400 q 404 516 484 516 q 268 461 323 516 q 207 300 207 401 q 269 137 207 198 q 405 83 325 83 q 541 137 486 83 q 603 298 603 197 "},"":{"x_min":1,"x_max":139.890625,"ha":236,"o":"m 139 670 l 1 670 l 1 830 q 37 943 1 897 q 139 1011 74 990 l 139 947 q 82 900 97 940 q 68 810 68 861 l 139 810 l 139 670 "},"?":{"x_min":-70,"x_max":283,"ha":361,"o":"m 283 800 l 173 800 l 173 925 l 283 925 l 283 800 m 40 800 l -70 800 l -70 925 l 40 925 l 40 800 m 283 3 q 232 -10 257 -5 q 181 -15 206 -15 q 84 26 118 -15 q 41 200 41 79 l 41 737 l 166 737 l 167 215 q 171 141 167 157 q 225 101 182 101 q 247 103 238 101 q 283 112 256 104 l 283 3 "},"?":{"x_min":-0.21875,"x_max":773.21875,"ha":857,"o":"m 773 -7 l 707 -11 q 575 40 607 -11 q 552 174 552 77 l 552 226 l 552 626 l 222 626 l 222 0 l 97 0 l 97 626 l 0 626 l 0 737 l 773 737 l 773 626 l 676 626 l 676 171 q 695 103 676 117 q 773 90 714 90 l 773 -7 "},"?":{"x_min":0,"x_max":765.5625,"ha":809,"o":"m 765 -4 q 698 -14 726 -14 q 564 97 586 -14 q 466 7 525 40 q 337 -26 407 -26 q 88 98 186 -26 q 0 369 0 212 q 88 637 0 525 q 337 760 184 760 q 465 727 407 760 q 563 637 524 695 l 563 738 l 685 738 l 685 222 q 693 141 685 168 q 748 94 708 94 q 765 95 760 94 l 765 -4 m 584 371 q 531 562 584 485 q 360 653 470 653 q 192 566 254 653 q 135 379 135 489 q 186 181 135 261 q 358 84 247 84 q 528 176 465 84 q 584 371 584 260 m 604 1040 l 415 819 l 332 819 l 466 1040 l 604 1040 "},"O":{"x_min":0,"x_max":958,"ha":1057,"o":"m 485 1041 q 834 882 702 1041 q 958 512 958 734 q 834 136 958 287 q 481 -26 702 -26 q 126 130 261 -26 q 0 504 0 279 q 127 880 0 728 q 485 1041 263 1041 m 480 98 q 731 225 638 98 q 815 504 815 340 q 733 783 815 669 q 480 912 640 912 q 226 784 321 912 q 142 504 142 670 q 226 224 142 339 q 480 98 319 98 "},"n":{"x_min":0,"x_max":615,"ha":724,"o":"m 615 463 l 615 0 l 490 0 l 490 454 q 453 592 490 537 q 331 656 410 656 q 178 585 240 656 q 117 421 117 514 l 117 0 l 0 0 l 0 738 l 117 738 l 117 630 q 218 728 150 693 q 359 764 286 764 q 552 675 484 764 q 615 463 615 593 "},"3":{"x_min":54,"x_max":737,"ha":792,"o":"m 737 284 q 635 55 737 141 q 399 -25 541 -25 q 156 52 248 -25 q 54 308 54 140 l 185 308 q 245 147 185 202 q 395 96 302 96 q 539 140 484 96 q 602 280 602 190 q 510 429 602 390 q 324 454 451 454 l 324 565 q 487 584 441 565 q 565 719 565 617 q 515 835 565 791 q 395 879 466 879 q 255 824 307 879 q 203 661 203 769 l 78 661 q 166 909 78 822 q 387 992 250 992 q 603 921 513 992 q 701 723 701 844 q 669 607 701 656 q 578 524 637 558 q 696 434 655 499 q 737 284 737 369 "},"9":{"x_min":53,"x_max":739,"ha":792,"o":"m 739 524 q 619 94 739 241 q 362 -32 516 -32 q 150 47 242 -32 q 59 244 59 126 l 191 244 q 246 129 191 176 q 373 82 301 82 q 526 161 466 82 q 597 440 597 255 q 363 334 501 334 q 130 432 216 334 q 53 650 53 521 q 134 880 53 786 q 383 986 226 986 q 659 841 566 986 q 739 524 739 719 m 388 449 q 535 514 480 449 q 585 658 585 573 q 535 805 585 744 q 388 873 480 873 q 242 809 294 873 q 191 658 191 745 q 239 514 191 572 q 388 449 292 449 "},"l":{"x_min":41,"x_max":166,"ha":279,"o":"m 166 0 l 41 0 l 41 1013 l 166 1013 l 166 0 "},"":{"x_min":40.09375,"x_max":728.796875,"ha":825,"o":"m 728 304 l 649 224 l 512 363 q 383 331 458 331 q 256 363 310 331 l 119 224 l 40 304 l 177 441 q 150 553 150 493 q 184 673 150 621 l 40 818 l 119 898 l 267 749 q 321 766 291 759 q 384 773 351 773 q 447 766 417 773 q 501 749 477 759 l 649 898 l 728 818 l 585 675 q 612 618 604 648 q 621 553 621 587 q 591 441 621 491 l 728 304 m 384 682 q 280 643 318 682 q 243 551 243 604 q 279 461 243 499 q 383 423 316 423 q 487 461 449 423 q 525 553 525 500 q 490 641 525 605 q 384 682 451 682 "},"?":{"x_min":0,"x_max":632.328125,"ha":679,"o":"m 632 0 l 482 0 l 225 384 l 124 288 l 124 0 l 0 0 l 0 738 l 124 738 l 124 446 l 433 738 l 596 738 l 312 466 l 632 0 "},"4":{"x_min":48,"x_max":742.453125,"ha":792,"o":"m 742 243 l 602 243 l 602 0 l 476 0 l 476 243 l 48 243 l 48 368 l 476 958 l 602 958 l 602 354 l 742 354 l 742 243 m 476 354 l 476 792 l 162 354 l 476 354 "},"p":{"x_min":0,"x_max":685,"ha":786,"o":"m 685 364 q 598 96 685 205 q 350 -23 504 -23 q 121 89 205 -23 l 121 -278 l 0 -278 l 0 738 l 121 738 l 121 633 q 220 726 159 691 q 351 761 280 761 q 598 636 504 761 q 685 364 685 522 m 557 371 q 501 560 557 481 q 330 651 437 651 q 162 559 223 651 q 108 366 108 479 q 162 177 108 254 q 333 87 224 87 q 502 178 441 87 q 557 371 557 258 "},"":{"x_min":0,"x_max":777,"ha":835,"o":"m 458 238 l 458 0 l 319 0 l 319 238 l 0 238 l 0 360 l 319 360 l 319 681 l 0 683 l 0 804 l 319 804 l 319 1015 l 458 1013 l 458 804 l 777 804 l 777 683 l 458 683 l 458 360 l 777 360 l 777 238 l 458 238 "},"?":{"x_min":0,"x_max":808,"ha":907,"o":"m 465 -278 l 341 -278 l 341 -15 q 87 102 180 -15 q 0 378 0 210 l 0 739 l 133 739 l 133 379 q 182 195 133 275 q 341 98 242 98 l 341 922 l 465 922 l 465 98 q 623 195 563 98 q 675 382 675 278 l 675 742 l 808 742 l 808 381 q 720 104 808 213 q 466 -13 627 -13 l 465 -278 "},"?":{"x_min":0.78125,"x_max":697,"ha":810,"o":"m 697 -278 l 572 -278 l 572 454 q 540 587 572 536 q 425 650 501 650 q 271 579 337 650 q 206 420 206 509 l 206 0 l 81 0 l 81 489 q 73 588 81 562 q 0 644 56 644 l 0 741 q 68 755 38 755 q 158 720 124 755 q 200 630 193 686 q 297 726 234 692 q 434 761 359 761 q 620 692 544 761 q 697 516 697 624 l 697 -278 "}},"cssFontWeight":"normal","ascender":1189,"underlinePosition":-100,"cssFontStyle":"normal","boundingBox":{"yMin":-334,"xMin":-111,"yMax":1189,"xMax":1672},"resolution":1000,"original_font_information":{"postscript_name":"Helvetiker-Regular","version_string":"Version 1.00 2004 initial release","vendor_url":"http://www.magenta.gr/","full_font_name":"Helvetiker","font_family_name":"Helvetiker","copyright":"Copyright (c) ?agenta ltd, 2004","description":"","trademark":"","designer":"","designer_url":"","unique_font_identifier":"?agenta ltd:Helvetiker:22-10-104","license_url":"http://www.ellak.gr/fonts/MgOpen/license.html","license_description":"Copyright (c) 2004 by MAGENTA Ltd. All Rights Reserved.\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of the fonts accompanying this license (\"Fonts\") and associated documentation files (the \"Font Software\"), to reproduce and distribute the Font Software, including without limitation the rights to use, copy, merge, publish, distribute, and/or sell copies of the Font Software, and to permit persons to whom the Font Software is furnished to do so, subject to the following conditions: \r\n\r\nThe above copyright and this permission notice shall be included in all copies of one or more of the Font Software typefaces.\r\n\r\nThe Font Software may be modified, altered, or added to, and in particular the designs of glyphs or characters in the Fonts may be modified and additional glyphs or characters may be added to the Fonts, only if the fonts are renamed to names not containing the word \"MgOpen\", or if the modifications are accepted for inclusion in the Font Software itself by the each appointed Administrator.\r\n\r\nThis License becomes null and void to the extent applicable to Fonts or Font Software that has been modified and is distributed under the \"MgOpen\" name.\r\n\r\nThe Font Software may be sold as part of a larger software package but no copy of one or more of the Font Software typefaces may be sold by itself. \r\n\r\nTHE FONT SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL MAGENTA OR PERSONS OR BODIES IN CHARGE OF ADMINISTRATION AND MAINTENANCE OF THE FONT SOFTWARE BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.","manufacturer_name":"?agenta ltd","font_sub_family_name":"Regular"},"descender":-334,"familyName":"Helvetiker","lineHeight":1522,"underlineThickness":50});
},{}]},{},[11])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImM6L1VzZXJzL01yVHJ1c3R3b3J0aHkvQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsInNyYy9qcy9hY3Rvci9hY3Rvci5qcyIsInNyYy9qcy9hY3Rvci90cmFuc3BvcnRlci5qcyIsInNyYy9qcy9hbmltYXRpb24uanMiLCJzcmMvanMvY29tbW9uL2dhbWVvYmplY3QuanMiLCJzcmMvanMvY29tbW9uL2xpc3QyZC5qcyIsInNyYy9qcy9jb21tb24vcG9pbnQuanMiLCJzcmMvanMvY29tbW9uL3R3ZWVuLmpzIiwic3JjL2pzL2NvbnRyb2xsZXJzL2lucHV0aGFuZGxlci5qcyIsInNyYy9qcy9jb250cm9sbGVycy9tYWluY29udHJvbGxlci5qcyIsInNyYy9qcy9jb250cm9sbGVycy9tb3VzZWhhbmRsZXIuanMiLCJzcmMvanMvbWFpbi5qcyIsInNyYy9qcy9tYXAvbWFwLmpzIiwic3JjL2pzL21hcC9tYXBub2RlLmpzIiwic3JjL2pzL21hcC9tb2RlbC5qcyIsInNyYy9qcy9tYXAvcGF0aC5qcyIsInNyYy9qcy9tYXAvc3RydWN0dXJlLmpzIiwic3JjL2pzL3Jlc291cmNlL3Jlc291cmNlLmpzIiwic3JjL2xpYi9tdC1ldmVudC5qcyIsInNyYy9saWIvbXQtcHJvbWlzZS5qcyIsInNyYy9saWIvdGhyZWUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgR2FtZU9iamVjdCA9IHJlcXVpcmUoXCIuLi9jb21tb24vZ2FtZW9iamVjdFwiKTtcclxudmFyIFRIUkVFID0gcmVxdWlyZShcIi4uLy4uL2xpYi90aHJlZVwiKTtcclxudmFyIFBvaW50ID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wb2ludFwiKTtcclxudmFyIFR3ZWVuID0gcmVxdWlyZShcIi4uL2NvbW1vbi90d2VlblwiKTtcclxudmFyIERlZmVycmVkID0gcmVxdWlyZShcIi4uLy4uL2xpYi9tdC1wcm9taXNlXCIpO1xyXG5cclxuY2xhc3MgQWN0b3IgZXh0ZW5kcyBHYW1lT2JqZWN0IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbm9kZSBNYXBOb2RlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG5vZGUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG5cclxuICAgICAgICBub2RlLmxvY2soKTtcclxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlOyAvLyBtYXBub2RlXHJcblxyXG4gICAgICAgIHRoaXMubWVzaCA9IHRoaXMuZ2VuZXJhdGVfbW9kZWwoKTtcclxuICAgICAgICB0aGlzLm1lc2gudXNlckRhdGEgPSB0aGlzO1xyXG5cclxuXHJcbiAgICAgICAgdGhpcy5idXN5ID0gZmFsc2U7IC8vIHdpbGwgYmUgXCJ0cnVlXCIgaWYgbW92aW5nXHJcbiAgICAgICAgdGhpcy5idXN5X3dpdGggPSBudWxsOyAvLyBwcm9taXNlIG9mIG1vdmVtZW50IHRoYXQgcmVzb2x2ZXMvcmVqZWN0c1xyXG5cclxuICAgICAgICAvLyBjYWxsIHRoaXMuYWJvcnQoKSB0aGlzIHRvIGZvcmNlIGNhbmNlbGxpbmcgdGhlIGN1cnJlbnQgbW92aW5nIGFmdGVyIG5leHQgZmllbGRcclxuICAgICAgICB0aGlzLl9fYWJvcnRfcmVxdWVzdCA9IGZhbHNlO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFib3J0cyB0aGUgY3VycmVudCBtb3ZlbWVudCBhZnRlciB0aGUgbmV4dCBzdGVwIGFuZCByZXR1cm5zIGEgcHJvbWlzZVxyXG4gICAgICogdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBtb3ZlbWVudCBoYXMgZW5kZWQuXHJcbiAgICAgKlxyXG4gICAgICogQWxzbyByZXNvbHZlcyBpZiB0aGUgbW92ZW1lbnQgaGFzbid0IGJlZW4gZm9yY2UtZW5kZWQgaWYgaXQgY29pbmNpZGVudGFsbHkgZW5kcyBvbiB0aGUgbmV4dCBzdGVwXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge251bGx8Kn1cclxuICAgICAqL1xyXG4gICAgYWJvcnQoKSB7XHJcbiAgICAgICAgbGV0IGRlZiA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgICAgIHRoaXMuX19hYm9ydF9yZXF1ZXN0ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy5idXN5X3dpdGgudGhlbihcclxuICAgICAgICAgICAgKCkgPT4gZGVmLnJlc29sdmUoKSxcclxuICAgICAgICAgICAgKCkgPT4gZGVmLnJlc29sdmUoKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIGRlZi5wcm9taXNlO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vdmVzIHRvIGEgbmVpZ2hib3VyaW5nIG5vZGVcclxuICAgICAqIEBwYXJhbSB0YXJnZXQgTUFLRSBTVVJFIElUUyBBIE5FSUdIQk9VUiBPUiBJVCdMTCBMT09LIFdFSVJEXHJcbiAgICAgKiBAcmV0dXJucyBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0YXJnZXQgaXMgcmVhY2hlcyBhbmQgcmVqZWN0cyBpZiBpdCdzIGltcG9zc2libGVcclxuICAgICAqL1xyXG4gICAgbW92ZV90byh0YXJnZXQpIHtcclxuICAgICAgICBsZXQgZGVmID0gbmV3IERlZmVycmVkKCk7XHJcblxyXG4gICAgICAgIC8vIGd1YXJkIHN0YXRlbWVudHNcclxuICAgICAgICBpZiAodGhpcy5fX2Fib3J0X3JlcXVlc3QgfHwgdGhpcy5idXN5IHx8IHRhcmdldC5sb2NrZWQpIHtcclxuXHJcbiAgICAgICAgICAgIGxldCByZWFzb25zID0ge1xyXG4gICAgICAgICAgICAgICAgYWJvcnRlZDogdGhpcy5fX2Fib3J0X3JlcXVlc3QsXHJcbiAgICAgICAgICAgICAgICBidXN5OiB0aGlzLmJ1c3ksXHJcbiAgICAgICAgICAgICAgICBsb2NrZWQ6IHRhcmdldC5sb2NrZWRcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIHJlc2V0IGFib3J0aW9uIGZsYWdcclxuICAgICAgICAgICAgdGhpcy5fX2Fib3J0X3JlcXVlc3QgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGRlZi5yZWplY3QocmVhc29ucyk7XHJcbiAgICAgICAgICAgIHJldHVybiBkZWYucHJvbWlzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vaWYgbm90LCBwcm9jZWVkXHJcbiAgICAgICAgdGhpcy5idXN5ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmJ1c3lfd2l0aCA9IGRlZi5wcm9taXNlO1xyXG5cclxuICAgICAgICAvLyBsb2NrIHRhcmdldCBzbyBub2JvZHkgZWxzZSB0cmllcyB0byB3YWxrIHRoZXJlXHJcbiAgICAgICAgdGFyZ2V0LmxvY2soKTtcclxuXHJcbiAgICAgICAgLy8gZ2V0IHRoZSB0d2VlbmluZyBwb2ludHNcclxuICAgICAgICBsZXQgcG9pbnRzID0gbmV3IFR3ZWVuKHRoaXMubm9kZS5wb2ludCwgdGFyZ2V0LnBvaW50LCAxMCk7XHJcbiAgICAgICAgcG9pbnRzID0gQXJyYXkuZnJvbShwb2ludHMpO1xyXG5cclxuICAgICAgICAvLyBwdXQgdGhlIG1vdmUtZnVuY3Rpb24gaW50byB0aGUgY3VycmVudCBob29rc1xyXG4gICAgICAgIHZhciB1cGRhdGVfZnVuYyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gcG9pbnRzLnNoaWZ0KCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLm1lc2gucG9zaXRpb24ueCA9IGN1cnJlbnQueDtcclxuICAgICAgICAgICAgdGhpcy5tZXNoLnBvc2l0aW9uLnkgPSBjdXJyZW50Lnk7XHJcbiAgICAgICAgICAgIHRoaXMubWVzaC5wb3NpdGlvbi56ID0gY3VycmVudC56O1xyXG5cclxuICAgICAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPT09IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBzdG9wIG1vdmluZ1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwic2NlbmVfdXBkYXRlZFwiLCB1cGRhdGVfZnVuYyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gdW5sb2NrIHRoZSBvbGQgbm9kZSBhbmQgc2V0IHRoZSBjdXJyZW50IG5vZGUgdG8gdGhlIG5ldyBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlLnVubG9jaygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlID0gdGFyZ2V0O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG5vdCBidXN5IGFueW1vcmVcclxuICAgICAgICAgICAgICAgIHRoaXMuYnVzeSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idXN5X3dpdGggPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgIGRlZi5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LmJpbmQodGhpcyk7XHJcblxyXG5cclxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJzY2VuZV91cGRhdGVkXCIsIHVwZGF0ZV9mdW5jKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGRlZi5wcm9taXNlO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7VEhSRUUuTWVzaH1cclxuICAgICAqL1xyXG4gICAgZ2VuZXJhdGVfbW9kZWwoKSB7XHJcbiAgICAgICAgbGV0IGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJveEdlb21ldHJ5KDEsIDEsIDEpO1xyXG4gICAgICAgIGxldCBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsKHtjb2xvcjogMHhmZjAwMDB9KTtcclxuICAgICAgICBsZXQgbWVzaCA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XHJcbiAgICAgICAgbWVzaC5wb3NpdGlvbi54ID0gdGhpcy5ub2RlLnBvaW50Lng7XHJcbiAgICAgICAgbWVzaC5wb3NpdGlvbi55ID0gdGhpcy5ub2RlLnBvaW50Lnk7XHJcbiAgICAgICAgbWVzaC5wb3NpdGlvbi56ID0gdGhpcy5ub2RlLnBvaW50Lno7XHJcbiAgICAgICAgcmV0dXJuIG1lc2g7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBY3RvcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKipcclxuICogSGVscGVyIGNsYXNzIGZvciBhY3RvciBtb3ZlbWVudFxyXG4gKi9cclxuY2xhc3MgVHJhbnNwb3J0ZXIge1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNpbmdsZXRvbnMgYXJlIGV2aWxcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWN0b3JcclxuICAgICAqIEBwYXJhbSB0YXJnZXRcclxuICAgICAqIEBwYXJhbSBtYXBcclxuICAgICAqL1xyXG4gICAgc3RhdGljIG1vdmUoYWN0b3IsIHRhcmdldCwgbWFwKSB7XHJcblxyXG4gICAgICAgIGxldCBub2RlcztcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gZ2V0IHRoZSBwYXRoXHJcbiAgICAgICAgICAgIG5vZGVzID0gbWFwLmdldF9wYXRoKGFjdG9yLm5vZGUucG9pbnQsIHRhcmdldC5wb2ludCk7XHJcbiAgICAgICAgICAgIG5vZGVzID0gQXJyYXkuZnJvbShub2Rlcykuc2xpY2UoMSk7XHJcblxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGFib3J0IGlmIHRoZSB0YXJnZXQgZmllbGQgaXMgYWxyZWFkeSBsb2NrZWQgb3IgZ2VuZXJhbGx5IHVucGFzc2FibGVcclxuICAgICAgICAgICAgLy8gYmVjYXVzZSBob25lc3RseSwgdGhpcyB3aWxsIGhhcHBlbiBvZnRlblxyXG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEV2YWxFcnJvciB8fCBlIGluc3RhbmNlb2YgUmFuZ2VFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiI1RyYW5zcG9ydGVyOiBDYW4ndCBmaW5kIHBhdGhcIiwgZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzb21ldGhpbmcgdW5leHBlY3RlZCBoYXBwZW5lZCwgaW4gdGhhdCBjYXNlXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgdmFyIGhhbmRsZV9tb3ZlX2Vycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnJvci5hYm9ydGVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkbyBub3RoaW5nIGlmIGFib3J0ZWQgZXhjZXB0IG5vdCBtb3ZpbmcgYW55IGZ1cnRoZXJcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIiNUcmFuc3BvcnRlcjogQWN0b3IgbW92ZW1lbnQgd2FzIGFib3J0ZWQ6XCIsIGVycm9yKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvci5idXN5KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBidXN5LCBhYm9ydCBjdXJyZW50IG1vdmVtZW50IHRoZW4gdHJ5IGFnYWluXHJcbiAgICAgICAgICAgICAgICBhY3Rvci5hYm9ydCgpLnRoZW4oKCkgPT4gVHJhbnNwb3J0ZXIubW92ZShhY3RvciwgdGFyZ2V0LCBtYXApKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvci5sb2NrZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIGxvY2tlZCwgdHJ5IGFnYWluXHJcbiAgICAgICAgICAgICAgICBUcmFuc3BvcnRlci5tb3ZlKGFjdG9yLCB0YXJnZXQsIG1hcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgdmFyIG1vdmVfZnVuYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgbGV0IG5leHQgPSBub2Rlcy5zaGlmdCgpO1xyXG4gICAgICAgICAgICBpZiAoIW5leHQpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGFjdG9yLm1vdmVfdG8obmV4dCkudGhlbihcclxuICAgICAgICAgICAgICAgIG1vdmVfZnVuYyxcclxuICAgICAgICAgICAgICAgIGhhbmRsZV9tb3ZlX2Vycm9yXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgbW92ZV9mdW5jKCk7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zcG9ydGVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIFRIUkVFID0gcmVxdWlyZShcIi4uL2xpYi90aHJlZVwiKTtcbnZhciBHYW1lT2JqZWN0ID0gcmVxdWlyZShcIi4vY29tbW9uL2dhbWVvYmplY3RcIik7XG4vKipcbiAqIFRoaXMgY2xhc3MgaXMgcmVzcG9uc2libGUgZm9yIHRoZSByZW5kZXJlciwgc2NlbmUgZXRjLlxuICogSXQgYmFzaWNhbGx5IGhhbmRsZXMgYWxsIHRoZSBhbmltYXRpb24tcmVsYXRlZCBzdHVmZlxuICpcbiAqIFRPRE86IEhhbmRsZSB3aW5kb3cgcmVzaXplIGhlcmVcbiAqL1xuY2xhc3MgQW5pbWF0aW9uIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbmV3IEFuaW1hdGlvbi1PYmplY3QgYW5kIHNldHMgdXAgdGhlIHN1cnJvdW5kaW5nIChldmVyeXRoaW5nIGJ1dCB0aGUgYm9kaWVzIHRoZW1zZWx2ZXMpXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSh0aGlzKTtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm1haW5fY2FudmFzXCIpO1xuXG5cbiAgICAgICAgdGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIpO1xuXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcih7XG4gICAgICAgICAgICBjYW52YXM6IHRoaXMuY2FudmFzLFxuICAgICAgICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgICAgICAgYW50aWFsaWFzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG5cbiAgICAgICAgdGhpcy5zY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuXG5cbiAgICAgICAgdGhpcy5jYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoNzUsIHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0LCAwLjEsIDEwMDApO1xuICAgICAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi54ID0gNTA7XG4gICAgICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnkgPSAyNTtcbiAgICAgICAgdGhpcy5jYW1lcmEucG9zaXRpb24ueiA9IDUwO1xuICAgICAgICB0aGlzLmNhbWVyYS5yb3RhdGlvbi54ID0gMC4zO1xuXG5cbiAgICAgICAgdmFyIGRpcmVjdGlvbmFsTGlnaHQgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCgweGZmZmZmZiwgMSk7XG4gICAgICAgIGRpcmVjdGlvbmFsTGlnaHQucG9zaXRpb24uc2V0KDAsIDYsIDEyKTtcbiAgICAgICAgdGhpcy5zY2VuZS5hZGQoZGlyZWN0aW9uYWxMaWdodCk7XG5cbiAgICAgICAgdGhpcy5hY3RvcnMgPSBbXTtcblxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgdGhlIG1hcFxuICAgICAqIEBwYXJhbSBtYXBcbiAgICAgKi9cbiAgICBsb2FkX21hcChtYXApIHtcbiAgICAgICAgdGhpcy5zY2VuZS5hZGQobWFwLm1lc2gpO1xuICAgICAgICBtYXAucmVzb3VyY2VzLmZvckVhY2gocmVzID0+IHRoaXMuc2NlbmUuYWRkKHJlcy5tZXNoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBlbGVtZW50IHRvIHRoZSBzY2VuZVxuICAgICAqXG4gICAgICogQHBhcmFtIG9ialxuICAgICAqL1xuICAgIGFkZF9lbGVtZW50KG9iaikge1xuICAgICAgICBpZiAoIShvYmogaW5zdGFuY2VvZiBHYW1lT2JqZWN0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIiNBbmltYXRpb246IENhbiBvbmx5IGFkZCBnYW1lb2JqZWN0cyB0byB0aGUgc2NlbmVcIik7XG4gICAgICAgIHRoaXMuYWN0b3JzLnB1c2gob2JqKTtcbiAgICAgICAgdGhpcy5zY2VuZS5hZGQob2JqLm1lc2gpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogU3RhcnRzIHRoZSBhbmltYXRpb25cbiAgICAgKi9cbiAgICBzdGFydCgpIHtcbiAgICAgICAgLy8gcmVjdXJzaXZlIGNhbGxcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuc3RhcnQuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vIHRoaXMgd2F5IHdlIGNhbiBob29rIHR3ZWVucyBhbmQgc3R1ZmYgbGlrZSB0aGF0IG9uIGVhY2ggZnJhbWVcbiAgICAgICAgdGhpcy5hY3RvcnMuZm9yRWFjaCh4ID0+IHguZGlzcGF0Y2hFdmVudCh7dHlwZTogXCJzY2VuZV91cGRhdGVkXCJ9KSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZTogXCJzY2VuZV91cGRhdGVkXCJ9KTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICAgIH1cblxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQW5pbWF0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgVEhSRUUgPSByZXF1aXJlKFwiLi4vLi4vbGliL3RocmVlXCIpO1xyXG5cclxuLy8ganVzdCBmb3IgZnVuOyBuZWVkIGEgZ2l0LWhvb2sgb3Igc29tZXRoaW5nIHRoYXQgdGhyb3dzIGVycm9ycyBpZiBpdCBzZWVzIFwiZ2V0b3ducHJvcGVydHlzeW1ib2xzXCJcclxudmFyIG1lc2hTeW1ib2wgPSBTeW1ib2woKTtcclxuXHJcbi8qKlxyXG4gKiBQYXJlbnQgY2xhc3MgZm9yIGFsbCBHYW1lb2JqZWN0cyB3aGljaCBndWFyYW50ZWVzIGF2YWlsYWJpbGl0eSBvZiBjb21tb24gZ2FtZW9iamVjdC1wcm9wZXJ0aWVzIGxpa2UgbWVzaGVzXHJcbiAqL1xyXG5jbGFzcyBHYW1lT2JqZWN0IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIHdlIF9fTkVFRF9fIHRvIGNhbGwgdGhpcyBpbiBhbGwgc3ViY2xhc3NlcyFcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICBUSFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KHRoaXMpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE92ZXJ3cml0ZSFcclxuICAgICAqL1xyXG4gICAgcHJvZ3Jlc3MoKXtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZXR1cm5zIHRoZSBtZXNoIGlmIGFza2VkIGZvciBpdFxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIGdldCBtZXNoKCl7XHJcbiAgICAgICAgaWYgKHRoaXNbbWVzaFN5bWJvbF0pIHJldHVybiB0aGlzW21lc2hTeW1ib2xdO1xyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIGxldCBnZW9tZXRyeSA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSgxLCAxLCAxKTtcclxuICAgICAgICAgICAgbGV0IG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwoe2NvbG9yOiAweGZmZmZmZn0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBtYWtlIHN1cmUgd2UgY2FuIG5vdCBvdmVyd3JpdGUgdGhlIG1lc2hcclxuICAgICAqIEBwYXJhbSBtZXNoXHJcbiAgICAgKi9cclxuICAgIHNldCBtZXNoKG1lc2gpe1xyXG4gICAgICAgIGlmICh0aGlzW21lc2hTeW1ib2xdKSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJDYW4ndCBvdmVyd3JpdGUgZXhpc3RpbmcgbWVzaGVzIVwiKTtcclxuICAgICAgICB0aGlzW21lc2hTeW1ib2xdID0gbWVzaDtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2FtZU9iamVjdDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbGlzdFN5bWJvbCA9IFN5bWJvbCgpO1xyXG5cclxuLyoqXHJcbiAqIEEgc2ltcGxlIDJkLWxpc3QgY2xhc3NcclxuICpcclxuICogVE9ETzogbWF5YmUgaW52ZXJ0IHJvd3MvY29scyBpbiB0aGUgZGF0YSBzdHJ1Y3R1cmUgYmVjYXVzZSB3ZSBoYXZlIHRvIHF1ZXJ5IHJvd3MgbW9yZSBvZnRlblxyXG4gKiBhbmQgaXQncyBjdXJyZW50bHkgbW9yZSBleHBlbnNpdmVcclxuICovXHJcbmNsYXNzIExpc3QyRCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBpbml0aWFsaXplcyBhbiBlbXB0eSAyZCBsaXN0IHdpdGggbnVsbC12YWx1ZXNcclxuICAgICAqIEBwYXJhbSB3aWR0aDogZmlyc3QgdmFsdWUsIGFraW4gdG8gWCBpbiBhIHNjcmVlbiBjb29yZGluYXRlIHN5c3RlbVxyXG4gICAgICogQHBhcmFtIGxlbmd0aDogc2Vjb25kIHZhbHVlLCBha2luIHRvIFkgaW4gYSBzY3JlZW4gY29vcmRpbmF0ZSBzeXN0ZW1cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Iod2lkdGgsIGxlbmd0aCkge1xyXG5cclxuICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5jb2x1bW5zID0gd2lkdGggfHwgMTtcclxuICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMucm93cyA9IGxlbmd0aCB8fCB0aGlzLndpZHRoO1xyXG5cclxuICAgICAgICBsZXQgY29sX2FycmF5ID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcclxuICAgICAgICBjb2xfYXJyYXkuZmlsbChudWxsKTtcclxuXHJcbiAgICAgICAgdGhpc1tsaXN0U3ltYm9sXSA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy53aWR0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXNbbGlzdFN5bWJvbF1baV0gPSBjb2xfYXJyYXkuc2xpY2UoMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBnZXQoeCwgeSkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpc1tsaXN0U3ltYm9sXVt4XVt5XTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHJldHVybnMgYWxsIHN1cnJvdW5kaW5nIHBvaW50cyBvZiBhIHBvaW50IHg6eVxyXG4gICAgICogQHBhcmFtIHhcclxuICAgICAqIEBwYXJhbSB5XHJcbiAgICAgKi9cclxuICAgIGdldF9zdXJyb3VuZGluZyh4LCB5KSB7XHJcblxyXG4gICAgICAgIGxldCBsaXN0ID0gW107XHJcblxyXG4gICAgICAgIGZvciAobGV0IHhpID0geCAtIDE7IHhpIDw9IHggKyAxOyB4aSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHlpID0geSAtIDE7IHlpIDw9IHkgKyAxOyB5aSsrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHhpID09PSB4ICYmIHlpID09PSB5KSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGlmICh4aSA8IDAgfHwgeGkgPj0gdGhpcy53aWR0aCB8fCB5aSA8IDAgfHwgeWkgPj0gdGhpcy5sZW5ndGgpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBlbGVtID0gdGhpcy5nZXQoeGksIHlpKTtcclxuICAgICAgICAgICAgICAgIGlmKCFlbGVtKSBkZWJ1Z2dlcjtcclxuICAgICAgICAgICAgICAgIGxpc3QucHVzaChlbGVtKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxpc3Q7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0KHgsIHksIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXNbbGlzdFN5bWJvbF1beF1beV0gPSB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIGZvcmVhY2ggZ29lcyBmcm9tIHRvcC1sZWZ0IHRvIGJvdHRvbS1yaWdodFxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrXHJcbiAgICAgKi9cclxuICAgIGZvcl9lYWNoKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmdldF9yb3coaSkuZm9yRWFjaCgoZWxlbSwgaikgPT4gY2FsbGJhY2soZWxlbSwgaiwgaSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgZ2V0X3JvdyhpbmRleCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzW2xpc3RTeW1ib2xdLm1hcChzdWJsaXN0ID0+IHN1Ymxpc3RbaW5kZXhdKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRfY29sKGluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXNbbGlzdFN5bWJvbF1baW5kZXhdLnNsaWNlKDApO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIHByaW50cyB0aGUgbGlzdCBmcm9tIHRvcC1sZWZ0IHRvIGJvdHRvbS1yaWdodDtcclxuICAgICAqL1xyXG4gICAgcHJpbnQoKSB7XHJcbiAgICAgICAgbGV0IG91dHB1dCA9IFwiXCI7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRfcm93ID0gMDtcclxuICAgICAgICB0aGlzLmZvcl9lYWNoKGZ1bmN0aW9uIChlbGVtLCB4LCB5KSB7XHJcbiAgICAgICAgICAgIGlmICh5ID4gY3VycmVudF9yb3cpIG91dHB1dCArPSBcIlxcblwiO1xyXG4gICAgICAgICAgICBvdXRwdXQgKz0gXCIgfCBcIiArIFN0cmluZyhlbGVtKSArIFwiIHwgXCI7XHJcbiAgICAgICAgICAgIGN1cnJlbnRfcm93ID0geTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zb2xlLmxvZyhvdXRwdXQpO1xyXG4gICAgfVxyXG5cclxuXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTGlzdDJEOyIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIFRIUkVFID0gcmVxdWlyZShcIi4uLy4uL2xpYi90aHJlZVwiKTtcclxuXHJcbmNsYXNzIFBvaW50IHtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcih4LCB5LCB6KSB7XHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIHRoaXMueiA9IHogfHwgMDtcclxuICAgIH1cclxuXHJcbiAgICB0b192ZWN0b3IoKXtcclxuICAgICAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjModGhpcy54LCB0aGlzLnksIHRoaXMueik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcclxuICAgICAqIEBwYXJhbSBvdGhlclxyXG4gICAgICogQHBhcmFtIGluY2x1ZGVfelxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZGlzdGFuY2VfdG8ob3RoZXIsIGluY2x1ZGVfeil7XHJcblxyXG4gICAgICAgIGluY2x1ZGVfeiA9IGluY2x1ZGVfeiB8fCBmYWxzZTtcclxuICAgICAgICBpZihpbmNsdWRlX3opIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcIiNQb2ludDogRGlzdGFuY2UgYmFzZWQgb24gWiBub3QgaW1wbGVtZW50ZWQhXCIpO1xyXG5cclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KG90aGVyLnggLSB0aGlzLngsIDIpICsgTWF0aC5wb3cob3RoZXIueSAtIHRoaXMueSwgMikpO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgZXF1YWxzKG90aGVyKXtcclxuICAgICAgICByZXR1cm4gdGhpcy54ID09PSBvdGhlci54ICYmIHRoaXMueSA9PT0gb3RoZXIueTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByZXR0eSBwcmludHNcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICB0b1N0cmluZygpe1xyXG4gICAgICAgIHJldHVybiBgKCR7dGhpcy54fToke3RoaXMueX06JHt0aGlzLnp9KWA7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG4vKipcclxuICogVXNhZ2U6XHJcbiAqXHJcbiAqIGxldCBhID0gbmV3IFR3ZWVuKHt4OiAwfSwge3g6IDEwfSwgNCk7XHJcbiAqIGZvcih2YXIgaSBvZiBhKXtcclxuICogICBjb25zb2xlLmxvZyhpKTtcclxuICogfVxyXG4gKlxyXG4gKi9cclxuY2xhc3MgVHdlZW4ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvLCBzdGVwcykge1xyXG5cclxuICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xyXG5cclxuICAgICAgICBsZXQgY3VycmVudF9zdGVwID0gMDtcclxuICAgICAgICBsZXQgY3VycmVudF92YWwgPSB7fTtcclxuICAgICAgICBsZXQgc3RlcF9zaXplID0ge307XHJcblxyXG4gICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRfdmFsW2tleV0gPSBmcm9tW2tleV07XHJcbiAgICAgICAgICAgIHN0ZXBfc2l6ZVtrZXldID0gKHRvW2tleV0gLSBmcm9tW2tleV0pIC8gc3RlcHM7XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICB0aGlzW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiogKCkge1xyXG5cclxuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnRfc3RlcCA8IHN0ZXBzKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50X3N0ZXArKztcclxuICAgICAgICAgICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gY3VycmVudF92YWxba2V5XSArPSBzdGVwX3NpemVba2V5XSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY2xvbmUgYW5kIHJldHVybiBvYmplY3RcclxuICAgICAgICAgICAgICAgIGxldCBjbG9uZSA9IHt9O1xyXG4gICAgICAgICAgICAgICAga2V5cy5mb3JFYWNoKGtleT0+IGNsb25lW2tleV0gPSBjdXJyZW50X3ZhbFtrZXldKTtcclxuXHJcbiAgICAgICAgICAgICAgICB5aWVsZCBjbG9uZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgfVxyXG5cclxufVxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVHdlZW47XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIFRIUkVFID0gcmVxdWlyZShcIi4uLy4uL2xpYi90aHJlZVwiKTtcclxuXHJcbmNsYXNzIElucHV0SGFuZGxlciB7XHJcblxyXG4gICAgY29uc3RydWN0b3IoY2FtZXJhLCBzY2VuZSl7XHJcblxyXG4gICAgICAgIFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5jYWxsKHRoaXMpO1xyXG5cclxuICAgICAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcclxuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XHJcblxyXG4gICAgICAgIHdpbmRvdy5vbmtleWRvd24gPSB0aGlzLmhhbmRsZV9rZXlkb3duLmJpbmQodGhpcyk7XHJcbiAgICAgICAgd2luZG93Lm9ubW91c2V3aGVlbCA9IHRoaXMuaGFuZGxlX21vdXNld2hlZWwuYmluZCh0aGlzKTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuXHJcbiAgICBoYW5kbGVfbW91c2V3aGVlbChldnQpe1xyXG4gICAgICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnogKz0gZXZ0LndoZWVsRGVsdGEgPiAwID8gLTEgOiAxO1xyXG4gICAgfVxyXG5cclxuICAgIGhhbmRsZV9rZXlkb3duKGV2dCl7XHJcbiAgICAgICAgbGV0IGtleWJpbmRzID0ge1xyXG4gICAgICAgICAgICBEOiBbMSwgMF0sXHJcbiAgICAgICAgICAgIFM6IFswLCAtMV0sXHJcbiAgICAgICAgICAgIEE6ICBbLTEsIDBdLFxyXG4gICAgICAgICAgICBXOiBbMCwgMV1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBsZXQga2V5ID0gZXZ0LmNvZGUuc3Vic3RyaW5nKDMpO1xyXG5cclxuICAgICAgICBpZigha2V5YmluZHNba2V5XSl7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBkZWx0YSA9IGtleWJpbmRzW2tleV07XHJcblxyXG4gICAgICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnggKz0gZGVsdGFbMF0gKiA0O1xyXG4gICAgICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnkgKz0gZGVsdGFbMV0gKiA0O1xyXG5cclxuICAgIH1cclxuXHJcblxyXG5cclxuXHJcblxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IElucHV0SGFuZGxlcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgSW5wdXRIYW5kbGVyID0gcmVxdWlyZShcIi4vaW5wdXRoYW5kbGVyXCIpO1xyXG52YXIgVEhSRUUgPSByZXF1aXJlKFwiLi4vLi4vbGliL3RocmVlXCIpO1xyXG52YXIgTWFwID0gcmVxdWlyZShcIi4uL21hcC9tYXBcIik7XHJcbnZhciBNYXBOb2RlID0gcmVxdWlyZShcIi4uL21hcC9tYXBub2RlXCIpO1xyXG52YXIgQWN0b3IgPSByZXF1aXJlKFwiLi4vYWN0b3IvYWN0b3JcIik7XHJcbnZhciBUcmFuc3BvcnRlciA9IHJlcXVpcmUoXCIuLi9hY3Rvci90cmFuc3BvcnRlclwiKTtcclxudmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKFwiLi4vY29tbW9uL2dhbWVvYmplY3RcIik7XHJcbnZhciBQYXRoID0gcmVxdWlyZShcIi4uL21hcC9wYXRoXCIpO1xyXG52YXIgTW91c2VIYW5kbGVyID0gcmVxdWlyZShcIi4vbW91c2VoYW5kbGVyXCIpO1xyXG5cclxuXHJcbmNsYXNzIE1haW5Db250cm9sbGVyIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihhbmltYXRpb24sIG1hcCwgYWN0b3JzKSB7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb24gPSBhbmltYXRpb247XHJcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XHJcbiAgICAgICAgdGhpcy5hY3RvcnMgPSBhY3RvcnM7XHJcblxyXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gW107XHJcblxyXG4gICAgICAgIHRoaXMuaW5wdXRfaGFuZGxlciA9IG5ldyBJbnB1dEhhbmRsZXIoYW5pbWF0aW9uLmNhbWVyYSwgYW5pbWF0aW9uLnNjZW5lKTtcclxuICAgICAgICB0aGlzLm1vdXNlX2hhbmRsZXIgPSBuZXcgTW91c2VIYW5kbGVyKGFuaW1hdGlvbiwgbWFwLCBhY3RvcnMpO1xyXG5cclxuICAgICAgICB0aGlzLm1vdXNlX2hhbmRsZXIub24oXCJjbGlja1wiLCB0aGlzLmhhbmRsZV9jbGljay5iaW5kKHRoaXMpKTtcclxuICAgICAgICB0aGlzLm1vdXNlX2hhbmRsZXIub24oXCJzZWxlY3Rpb25cIiwgdGhpcy5oYW5kbGVfc2VsZWN0LmJpbmQodGhpcykpO1xyXG4gICAgICAgIHRoaXMubW91c2VfaGFuZGxlci5vbihcInJpZ2h0Y2xpY2tcIiwgdGhpcy5oYW5kbGVfcmlnaHRjbGljay5iaW5kKHRoaXMpKTtcclxuXHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjbGlja2VkIE9iamVjdHtvYmplY3QsIGZhY2UsIHBvaW50LCAuLi4pXHJcbiAgICAgKi9cclxuICAgIGhhbmRsZV9jbGljayhjbGlja2VkKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCIjTUM6IGNsaWNrXCIsIGNsaWNrZWQpO1xyXG5cclxuICAgICAgICBsZXQgb2JqID0gY2xpY2tlZC5vYmplY3Q7XHJcblxyXG4gICAgICAgIGlmIChvYmoudXNlckRhdGEgaW5zdGFuY2VvZiBBY3RvcikgdGhpcy5zZWxlY3Rpb24gPSBbb2JqLnVzZXJEYXRhXTtcclxuICAgICAgICBlbHNlIHRoaXMuc2VsZWN0aW9uLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzZWxlY3Rpb25zIEFycmF5PEFjdG9yPlxyXG4gICAgICovXHJcbiAgICBoYW5kbGVfc2VsZWN0KHNlbGVjdGlvbnMpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIiNNQzogc2VsZWN0XCIsIHNlbGVjdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ucHVzaC5hcHBseSh0aGlzLnNlbGVjdGlvbiwgc2VsZWN0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBhY3RvcnMgYXJlIHNlbGVjdGVkLCB3aWxsIHNlbmQgdGhlbSB0byB0aGUgdGFyZ2V0IGZpZWxkXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNsaWNrZWQgT2JqZWN0e29iamVjdCwgZmFjZSwgcG9pbnQsIC4uLilcclxuICAgICAqL1xyXG4gICAgaGFuZGxlX3JpZ2h0Y2xpY2soY2xpY2tlZCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiI01DOiByaWdodGNsaWNrXCIsIGNsaWNrZWQpO1xyXG5cclxuICAgICAgICBpZih0aGlzLnNlbGVjdGlvbi5sZW5ndGggPT09IDApIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IGdlb192ZXJ0cyA9IGNsaWNrZWQub2JqZWN0Lmdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cclxuICAgICAgICB0aGlzLnNlbGVjdGlvbi5mb3JFYWNoKCBhY3RvciA9PiB7XHJcblxyXG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgdGhlIHZlcnRpY2VzIGJhc2VkIG9uIHRoZSBjbGlja2VkIGZhY2VcclxuICAgICAgICAgICAgbGV0IHZlcnRzID0gW1xyXG4gICAgICAgICAgICAgICAgZ2VvX3ZlcnRzW2NsaWNrZWQuZmFjZS5hXSxcclxuICAgICAgICAgICAgICAgIGdlb192ZXJ0c1tjbGlja2VkLmZhY2UuYl0sXHJcbiAgICAgICAgICAgICAgICBnZW9fdmVydHNbY2xpY2tlZC5mYWNlLmNdXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIC8vIGdldCB0aGUgY29ycmVzcG9uZGluZyBtYXAtbm9kZXNcclxuICAgICAgICAgICAgbGV0IG1hcF9ub2RlcyA9IHZlcnRzLm1hcCh2ID0+IHRoaXMubWFwLnN0cnVjdHVyZS5nZXQodi54LCB2LnkpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBwYXNzYWJsZSBub2RlcyBvbmx5XHJcbiAgICAgICAgICAgIGxldCB2YWxpZCA9IG1hcF9ub2Rlcy5maWx0ZXIobiA9PiBuLnBhc3NhYmxlKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh2YWxpZC5sZW5ndGggPT09IDApIHRocm93IG5ldyBSYW5nZUVycm9yKFwiI01haW5Db250cm9sbGVyOiBjYW4ndCB3b3JrIHdpdGggdW5wYXNzYWJsZSBtYXAgbm9kZXMhXCIpO1xyXG5cclxuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHZhbGlkLnBvcCgpO1xyXG5cclxuICAgICAgICAgICAgLy8gdHJhbnNwb3J0ZXIgd2lsbCBoYW5kbGUgYWxsIG90aGVyIHN0dWZmXHJcbiAgICAgICAgICAgIFRyYW5zcG9ydGVyLm1vdmUoYWN0b3IsIHRhcmdldCwgdGhpcy5tYXApXHJcblxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1haW5Db250cm9sbGVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmxldCBUSFJFRSA9IHJlcXVpcmUoXCIuLi8uLi9saWIvdGhyZWVcIik7XHJcbmxldCBFdmVudGVkID0gcmVxdWlyZShcIi4uLy4uL2xpYi9tdC1ldmVudFwiKTtcclxuXHJcblxyXG5jbGFzcyBNb3VzZUhhbmRsZXIge1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYW5pbWF0aW9uXHJcbiAgICAgKiBAcGFyYW0gbWFwXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGFuaW1hdGlvbiwgbWFwLCBhY3RvcnMpIHtcclxuXHJcbiAgICAgICAgRXZlbnRlZC5tYWtlRXZlbnRlZCh0aGlzKTtcclxuXHJcbiAgICAgICAgdGhpcy5jbGlja19kZWxheSA9IDAuMiAqIDEwMDA7XHJcblxyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uID0gYW5pbWF0aW9uO1xyXG4gICAgICAgIHRoaXMubWFwID0gbWFwO1xyXG4gICAgICAgIHRoaXMuYWN0b3JzID0gYWN0b3JzO1xyXG5cclxuICAgICAgICB0aGlzLm1vdXNlZG93biA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubW91c2Vkb3duX2V2dCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tb3VzZWRvd25fb2JqX2J1ZmZlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tb3VzZWRvd25fdGltZSA9IG51bGw7XHJcblxyXG5cclxuICAgICAgICAvLyBzcGVjaWFsIHRocmVlIGpzIG1lc2ggdGhhdCB3ZSB1c2UgdG8gZGlzcGxheSBzZWxlY3Rpb25cclxuICAgICAgICB0aGlzLnNlbGVjdGlvbl9tb2RlbCA9IHRoaXMubG9hZF9zZWxlY3Rpb25fbW9kZWwoKTtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvbi5zY2VuZS5hZGQodGhpcy5zZWxlY3Rpb25fbW9kZWwpO1xyXG5cclxuICAgICAgICB0aGlzLmxvYWRfaG9va3MoKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBsb2FkX2hvb2tzKCkge1xyXG5cclxuICAgICAgICB3aW5kb3cub25tb3VzZWRvd24gPSB0aGlzLm9ubW91c2Vkb3duLmJpbmQodGhpcyk7XHJcbiAgICAgICAgd2luZG93Lm9ubW91c2V1cCA9IHRoaXMub25tb3VzZXVwLmJpbmQodGhpcyk7XHJcbiAgICAgICAgd2luZG93Lm9uY29udGV4dG1lbnUgPSB0aGlzLm9uY29udGV4dG1lbnUuYmluZCh0aGlzKTtcclxuICAgICAgICB3aW5kb3cub25tb3VzZW1vdmUgPSB0aGlzLm9ubW91c2Vtb3ZlLmJpbmQodGhpcyk7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZ0XHJcbiAgICAgKi9cclxuICAgIG9ubW91c2Vkb3duKGV2dCkge1xyXG4gICAgICAgIC8vIGluIHRoZSBjYXNlIG9mIHJpZ2h0Y2xpY2tzOlxyXG4gICAgICAgIGlmIChldnQuYnV0dG9uICE9PSAwKSByZXR1cm47XHJcblxyXG4gICAgICAgIHRoaXMubW91c2Vkb3duID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLm1vdXNlZG93bl9ldnQgPSBldnQ7XHJcbiAgICAgICAgdGhpcy5tb3VzZWRvd25fdGltZSA9IERhdGUubm93KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2dFxyXG4gICAgICovXHJcbiAgICBvbm1vdXNlbW92ZShldnQpIHtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLm1vdXNlZG93biB8fCB0aGlzLm1vdXNlZG93bl90aW1lICsgdGhpcy5jbGlja19kZWxheSA+IERhdGUubm93KCkpIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IGdlb21ldHJ5ID0gdGhpcy5zZWxlY3Rpb25fbW9kZWwuZ2VvbWV0cnk7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5tb3VzZWRvd25fb2JqX2J1ZmZlcikgdGhpcy5tb3VzZWRvd25fb2JqX2J1ZmZlciA9IHRoaXMuX2dldF9vYmplY3QodGhpcy5tb3VzZWRvd25fZXZ0KTtcclxuXHJcblxyXG4gICAgICAgIGxldCBwMSA9IHRoaXMubW91c2Vkb3duX29ial9idWZmZXIucG9pbnQ7XHJcbiAgICAgICAgbGV0IHA0ID0gdGhpcy5fZ2V0X29iamVjdChldnQpLnBvaW50O1xyXG4gICAgICAgIHZhciBwMiwgcDM7XHJcblxyXG4gICAgICAgIC8vIG5lZWQgdG8gc3dpdGNoIHZlcnRpY2VzIGluIHRvcC1yaWdodCBhbmQgYm90dG9tLWxlZnQgcXVhZHJhbnRzXHJcbiAgICAgICAgLy8gc28gd2UgY2FuIG1ha2Ugc3VyZSB0aGF0IGZhY2VzIGFsd2F5cyBmYWNlIHVwd2FyZHNcclxuXHJcbiAgICAgICAgLy8gaWYgaW4gdG9wLWxlZnQgb3IgYm90dG9tLXJpZ2h0IHF1YWRyYW50OlxyXG4gICAgICAgIGlmICgocDQueCA+IHAxLnggJiYgcDQueSA8IHAxLnkpIHx8IChwNC54IDwgcDEueCAmJiBwNC55ID4gcDEueSkpIHtcclxuICAgICAgICAgICAgcDIgPSBwMS5jbG9uZSgpO1xyXG4gICAgICAgICAgICBwMi54ID0gcDQueDtcclxuICAgICAgICAgICAgcDMgPSBwMS5jbG9uZSgpO1xyXG4gICAgICAgICAgICBwMy55ID0gcDQueTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwMyA9IHAxLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHAzLnggPSBwNC54O1xyXG4gICAgICAgICAgICBwMiA9IHAxLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHAyLnkgPSBwNC55O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgW3AxLCBwMiwgcDMsIHA0XS5mb3JFYWNoKChwLCBpKSA9PiB7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzW2ldLnggPSBwLng7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzW2ldLnkgPSBwLnk7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzW2ldLnogPSA1O1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLnNlbGVjdGlvbl9tb2RlbC52aXNpYmxlID0gdHJ1ZTtcclxuXHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZ0XHJcbiAgICAgKi9cclxuICAgIG9ubW91c2V1cChldnQpIHtcclxuXHJcbiAgICAgICAgLy8gaW4gdGhlIGNhc2Ugb2YgcmlnaHRjbGlja3M6XHJcbiAgICAgICAgaWYgKGV2dC5idXR0b24gIT09IDApIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMubW91c2Vkb3duX3RpbWUgKyB0aGlzLmNsaWNrX2RlbGF5ID4gRGF0ZS5ub3coKSkge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJjbGlja1wiLCB0aGlzLl9nZXRfb2JqZWN0KGV2dCkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbGN1bGF0ZV9zZWxlY3Rpb24oKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNsZWFudXAgdGhlIG1lc3NcclxuICAgICAgICB0aGlzLm1vdXNlZG93biA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubW91c2Vkb3duX2V2dCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tb3VzZWRvd25fdGltZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tb3VzZWRvd25fb2JqX2J1ZmZlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25fbW9kZWwudmlzaWJsZSA9IGZhbHNlO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2dFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIG9uY29udGV4dG1lbnUoZXZ0KSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KFwicmlnaHRjbGlja1wiLCB0aGlzLl9nZXRfb2JqZWN0KGV2dCkpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2dFxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfZ2V0X29iamVjdChldnQpIHtcclxuICAgICAgICBsZXQgcmF5Y2FzdGVyID0gbmV3IFRIUkVFLlJheWNhc3RlcigpO1xyXG4gICAgICAgIGxldCBtb3VzZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblxyXG4gICAgICAgIG1vdXNlLnggPSAoIGV2dC5jbGllbnRYIC8gdGhpcy5hbmltYXRpb24ucmVuZGVyZXIuZG9tRWxlbWVudC53aWR0aCApICogMiAtIDE7XHJcbiAgICAgICAgbW91c2UueSA9IC0oIGV2dC5jbGllbnRZIC8gdGhpcy5hbmltYXRpb24ucmVuZGVyZXIuZG9tRWxlbWVudC5oZWlnaHQgKSAqIDIgKyAxO1xyXG4gICAgICAgIHJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKG1vdXNlLCB0aGlzLmFuaW1hdGlvbi5jYW1lcmEpO1xyXG5cclxuICAgICAgICByZXR1cm4gcmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdHModGhpcy5hbmltYXRpb24uc2NlbmUuY2hpbGRyZW4pWzBdO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgYWxsIGdhbWVvYmplY3RzIGluc2lkZSBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb25cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9jYWxjdWxhdGVfc2VsZWN0aW9uKCkge1xyXG5cclxuICAgICAgICB0aGlzLnNlbGVjdGlvbl9tb2RlbC5nZW9tZXRyeS52ZXJ0aWNlcy5mb3JFYWNoKHYgPT4gdi56ID0gMCk7XHJcblxyXG4gICAgICAgIGxldCBib3VuZGluZ19ib3hfaGVpZ2h0ID0gMTAwOyAvLyBGSVhNRTogc2hvdWxkIGJlIHNhZmVcclxuICAgICAgICBsZXQgYmJveCA9IG5ldyBUSFJFRS5Cb3gzKCkuc2V0RnJvbU9iamVjdCh0aGlzLnNlbGVjdGlvbl9tb2RlbCk7XHJcblxyXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBhbGwgaW50ZXJzZWN0aW5nIGFjdG9yc1xyXG4gICAgICAgIGxldCBoaXRzID0gdGhpcy5hY3RvcnMuZmlsdGVyKHggPT4ge1xyXG4gICAgICAgICAgICBsZXQgYiA9IG5ldyBUSFJFRS5Cb3gzKCkuc2V0RnJvbU9iamVjdCh4Lm1lc2gpO1xyXG4gICAgICAgICAgICAvLyBjaGFuZ2UgdGhlIGFjdG9ycyBib3VuZGluZyBib3hlcyB0byBnbyBwcmV0dHkgaGlnaCBpbiB0aGUgWi1heGlzXHJcbiAgICAgICAgICAgIC8vIHNvIHRoZSBzZWxlY3Rpb24gbW9kZWwgd2lsbCBkZWZpbml0ZWx5IGludGVyc2VjdCBpdFxyXG4gICAgICAgICAgICBiLmV4cGFuZEJ5VmVjdG9yKG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIGJvdW5kaW5nX2JveF9oZWlnaHQpKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBiYm94LmlzSW50ZXJzZWN0aW9uQm94KGIpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmVtaXQoXCJzZWxlY3Rpb25cIiwgaGl0cyk7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7VEhSRUUuTWVzaH1cclxuICAgICAqL1xyXG4gICAgbG9hZF9zZWxlY3Rpb25fbW9kZWwoKSB7XHJcblxyXG4gICAgICAgIGxldCBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG4gICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMCksIG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDApLCBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAwKSwgbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMCkpO1xyXG4gICAgICAgIGdlb21ldHJ5LmZhY2VzLnB1c2gobmV3IFRIUkVFLkZhY2UzKDAsIDIsIDEpLCBuZXcgVEhSRUUuRmFjZTMoMiwgMywgMSkpO1xyXG5cclxuXHJcbiAgICAgICAgbGV0IG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwoe2NvbG9yOiAweGZmMDAwMH0pO1xyXG4gICAgICAgIG1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcclxuICAgICAgICBtYXRlcmlhbC5vcGFjaXR5ID0gMC41O1xyXG5cclxuICAgICAgICBsZXQgbWVzaCA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XHJcbiAgICAgICAgbWVzaC52aXNpYmxlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHdpbmRvdy5tID0gbWVzaDtcclxuICAgICAgICByZXR1cm4gbWVzaDtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNb3VzZUhhbmRsZXI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxubGV0IEFuaW1hdGlvbiA9IHJlcXVpcmUoXCIuL2FuaW1hdGlvblwiKTtcclxubGV0IE1hcCA9IHJlcXVpcmUoXCIuL21hcC9tYXBcIik7XHJcbmxldCBNYWluQ29udHJvbGxlciA9IHJlcXVpcmUoXCIuL2NvbnRyb2xsZXJzL21haW5jb250cm9sbGVyXCIpO1xyXG5sZXQgQWN0b3IgPSByZXF1aXJlKFwiLi9hY3Rvci9hY3RvclwiKTtcclxubGV0IFJlc291cmNlID0gcmVxdWlyZShcIi4vcmVzb3VyY2UvcmVzb3VyY2VcIik7XHJcblxyXG5cclxuXHJcblxyXG5sZXQgYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbigpO1xyXG5cclxubGV0IG1hcCA9IG5ldyBNYXAoKTtcclxuXHJcbmxldCByZXNvdXJjZSA9IG5ldyBSZXNvdXJjZSgpO1xyXG5tYXAuYWRkX3Jlc291cmNlKHJlc291cmNlKTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5hbmltYXRpb24ubG9hZF9tYXAobWFwKTtcclxuXHJcblxyXG5cclxubGV0IGFjdG9ycyA9IFtuZXcgQWN0b3IobWFwLnN0cnVjdHVyZS5nZXQoMjAsIDIwKSksIG5ldyBBY3RvcihtYXAuc3RydWN0dXJlLmdldCgzMCwgMjApKV07XHJcbmFuaW1hdGlvbi5hZGRfZWxlbWVudChhY3RvcnNbMF0pO1xyXG5hbmltYXRpb24uYWRkX2VsZW1lbnQoYWN0b3JzWzFdKTtcclxuXHJcblxyXG5cclxubGV0IGMgPSBuZXcgTWFpbkNvbnRyb2xsZXIoYW5pbWF0aW9uLCBtYXAsIGFjdG9ycyk7XHJcbmFuaW1hdGlvbi5zdGFydCgpO1xyXG5cclxuXHJcblxyXG5cclxuY29uc29sZS5sb2coXCJsb2FkZWRcIik7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKFwiLi4vY29tbW9uL2dhbWVvYmplY3RcIik7XHJcbnZhciBUSFJFRSA9IHJlcXVpcmUoXCIuLi8uLi9saWIvdGhyZWVcIik7XHJcbnZhciBMaXN0MkQgPSByZXF1aXJlKFwiLi4vY29tbW9uL2xpc3QyZFwiKTtcclxudmFyIFBvaW50ID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wb2ludFwiKTtcclxudmFyIFN0cnVjdHVyZSA9IHJlcXVpcmUoXCIuL3N0cnVjdHVyZVwiKTtcclxudmFyIE1vZGVsID0gcmVxdWlyZShcIi4vbW9kZWxcIik7XHJcbnZhciBQYXRoID0gcmVxdWlyZShcIi4vcGF0aFwiKTtcclxuXHJcblxyXG5jbGFzcyBNYXAgZXh0ZW5kcyBHYW1lT2JqZWN0IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcHJvcGVydGllczogTWFwIHdpdGgga2V5czogc2l6ZV94LCBzaXplX3lcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJvcGVydGllcykge1xyXG5cclxuICAgICAgICBzdXBlcigpO1xyXG5cclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IE1hcC5fZ2V0X2RlZmF1bHRfcHJvcGVydGllcygpO1xyXG4gICAgICAgIC8vIHN0cnVjdHVyZSBpcyBhIExpc3QyRCBmaWxsZWQgd2l0aCBNYXBOb2Rlc1xyXG4gICAgICAgIHRoaXMuc3RydWN0dXJlID0gU3RydWN0dXJlLmNyZWF0ZV9yYW5kb20odGhpcy5wcm9wZXJ0aWVzKTtcclxuXHJcbiAgICAgICAgdGhpcy5tZXNoID0gTW9kZWwuZ2VuZXJhdGVfbW9kZWwodGhpcy5wcm9wZXJ0aWVzLCB0aGlzLnN0cnVjdHVyZSk7XHJcbiAgICAgICAgdGhpcy5tZXNoLnVzZXJEYXRhID0gdGhpcztcclxuXHJcblxyXG4gICAgICAgIHRoaXMucmVzb3VyY2VzID0gW107XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHJlc291cmNlIHRvIHRoaXMgbWFwXHJcbiAgICAgKiBAcGFyYW0gcmVzb3VyY2VcclxuICAgICAqL1xyXG4gICAgYWRkX3Jlc291cmNlKHJlc291cmNlKXtcclxuICAgICAgICB0aGlzLnJlc291cmNlcy5wdXNoKHJlc291cmNlKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmVzIHRoZSBiZXN0IHBvc3NpYmxlIHBhdGggYmV0d2VlbiB0d28gcG9pbnRzXHJcbiAgICAgKiBAcGFyYW0gZnJvbVxyXG4gICAgICogQHBhcmFtIHRvXHJcbiAgICAgKiBAcmV0dXJucyB7UGF0aHxleHBvcnRzfG1vZHVsZS5leHBvcnRzfVxyXG4gICAgICovXHJcbiAgICBnZXRfcGF0aChmcm9tLCB0byl7XHJcblxyXG4gICAgICAgIGlmKCFmcm9tLnggfHwgIWZyb20ueSB8fCAhdG8ueCB8fCAhdG8ueSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIiNNYXA6IE5lZWQgdG8gcGFzcyB0d28gcG9pbnRzIHdpdGggeC95IHZhbCFcIik7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUGF0aChmcm9tLCB0bywgdGhpcy5zdHJ1Y3R1cmUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGRlZmF1bHQgcHJvcGVydGllcyBmb3Igd2hlbiBub25lIGhhdmUgYmVlbiBwcm92aWRlZFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgc3RhdGljIF9nZXRfZGVmYXVsdF9wcm9wZXJ0aWVzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNpemVfeDogMTAwLFxyXG4gICAgICAgICAgICBzaXplX3k6IDEwMCxcclxuICAgICAgICAgICAgc3RydWN0dXJlOiBudWxsLFxyXG4gICAgICAgICAgICBncm91bmR3YXRlcjogLTAuOCxcclxuICAgICAgICAgICAgbW91bnRhaW46IDEsXHJcbiAgICAgICAgICAgIGhpZ2hsaWdodF9jaGFuY2U6IDMwMCAvLyAxMDAwIG1lYW5zIDEgaW4gMTAwMFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG5cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNYXA7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuY2xhc3MgTWFwTm9kZSB7XHJcblxyXG4gICAgY29uc3RydWN0b3IocG9pbnQsIHBhc3NhYmxlKSB7XHJcbiAgICAgICAgdGhpcy5wb2ludCA9IHBvaW50O1xyXG4gICAgICAgIHRoaXMucGFzc2FibGUgPSBwYXNzYWJsZSB8fCBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy5fX2xvY2tlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGxvY2soKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX19sb2NrZWQpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiI01hcG5vZGU6IE5vZGUgaXMgYWxyZWFkeSBsb2NrZWQhXCIpO1xyXG4gICAgICAgIHRoaXMuX19sb2NrZWQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHVubG9jaygpIHtcclxuICAgICAgICB0aGlzLl9fbG9ja2VkID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGxvY2tlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fX2xvY2tlZDtcclxuICAgIH1cclxuXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gYCgke3RoaXMucG9pbnQueH06JHt0aGlzLnBvaW50Lnl9KSAke3RoaXMucG9pbnQuei50b1N0cmluZygpLnN1YnN0cmluZygwLCAzKX0gJHt0aGlzLnBhc3NhYmxlID8gXCJvXCIgOiBcInhcIn1gO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNYXBOb2RlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBUSFJFRSA9IHJlcXVpcmUoXCIuLi8uLi9saWIvdGhyZWVcIik7XHJcblxyXG5jbGFzcyBNb2RlbCB7XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgcmF0aGVyIGNvbXBsZXggbWFwLW1lc2ggaW5jbHVkaW5nIHRleHR1cmVzXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge1RIUkVFLk1lc2h9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2VuZXJhdGVfbW9kZWwocHJvcGVydGllcywgc3RydWN0dXJlKSB7XHJcblxyXG5cclxuICAgICAgICBsZXQgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHJcbiAgICAgICAgbGV0IHdpZHRoID0gc3RydWN0dXJlLndpZHRoO1xyXG4gICAgICAgIGxldCBsZW5ndGggPSBzdHJ1Y3R1cmUubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggZmFjZXMgYXJlIHdhdGVyIGFuZCBtb3VudGFpbnNcclxuICAgICAgICBsZXQgd2F0ZXIgPSBwcm9wZXJ0aWVzLmdyb3VuZHdhdGVyO1xyXG4gICAgICAgIGxldCBtb3VudGFpbiA9IHByb3BlcnRpZXMubW91bnRhaW47XHJcblxyXG5cclxuICAgICAgICBsZXQgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCh7dmVydGV4Q29sb3JzOiBUSFJFRS5WZXJ0ZXhDb2xvcnN9KTtcclxuXHJcblxyXG4gICAgICAgIC8vIDA6IHdhdGVyLCAxOiBlYXJ0aCwgMjogbW91bnRhaW50b3BcclxuICAgICAgICBsZXQgdmVydGljZV9jb2xvcnMgPSBbXHJcbiAgICAgICAgICAgIG5ldyBUSFJFRS5Db2xvcigweDIyOUNFNCksXHJcbiAgICAgICAgICAgIG5ldyBUSFJFRS5Db2xvcigweDAwNjQwMCksXHJcbiAgICAgICAgICAgIG5ldyBUSFJFRS5Db2xvcigweGY0YTQ2MClcclxuICAgICAgICBdO1xyXG5cclxuXHJcblxyXG5cclxuICAgICAgICAvLyBjcmVhdGUgdmVydGljZXMgYmFzZWQgb24gdGhlIHN0cnVjdHVyZVxyXG4gICAgICAgIHN0cnVjdHVyZS5mb3JfZWFjaChmdW5jdGlvbiAobm9kZSwgeCwgeSkge1xyXG4gICAgICAgICAgICAvLyBhZGQgdGhlIHZlcnRpY2VzIGZvciBlYWNoIHBvaW50XHJcbiAgICAgICAgICAgIGxldCB2ZXJ0ID0gbmV3IFRIUkVFLlZlY3RvcjMobm9kZS5wb2ludC54LCBub2RlLnBvaW50LnksIG5vZGUucG9pbnQueik7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2godmVydCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAvLyBjcmVhdGUgMiBmYWNlcyBmb3IgZWFjaCBwb2ludCwgZXhjbHVkaW5nIHRoZSBwb2ludHMgYXQgdGhlIGNvcm5lcnNcclxuICAgICAgICBzdHJ1Y3R1cmUuZm9yX2VhY2goZnVuY3Rpb24gKG5vZGUsIHgsIHkpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIG5vIGZhY2VzIGlmIHdlIGFyZSBhdCB0aGUgcmlnaHQgb3IgYm90dG9tL3RvcCg/KSBib3JkZXJcclxuICAgICAgICAgICAgaWYgKHggPT09IHdpZHRoIC0gMSB8fCB5ID09PSBsZW5ndGggLSAxKSByZXR1cm47XHJcblxyXG5cclxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBpbmRleCBvZiB0aGUgY29ycmVzcG9uZGluZyB2ZXJ0aWNlcy92ZXJ0aXgvdmVydGl4ZXM/P1xyXG4gICAgICAgICAgICBsZXQgZmFjZTFfY29vcmRzID0ge1xyXG4gICAgICAgICAgICAgICAgYTogeCArIHkgKiB3aWR0aCxcclxuICAgICAgICAgICAgICAgIGI6IHggKyAxICsgeSAqIHdpZHRoLFxyXG4gICAgICAgICAgICAgICAgYzogeCArICh5ICsgMSkgKiB3aWR0aFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSB2ZXJ0aWNlIGNvbG9ycyBieSBjcm9zcy1jaGVja2luZyB0aGVpciB2YWx1ZXMgd2l0aCB0aGUgdGhyZXNoaG9sZHNcclxuICAgICAgICAgICAgbGV0IGZhY2UxX2NvbG9ycyA9IFtcImFcIiwgXCJiXCIsIFwiY1wiXS5tYXAobWF0X2Nvb3JkID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB2ZXJ0ID0gZ2VvbWV0cnkudmVydGljZXNbZmFjZTFfY29vcmRzW21hdF9jb29yZF1dO1xyXG4gICAgICAgICAgICAgICAgbGV0IGkgPSB2ZXJ0LnogPD0gd2F0ZXIgPyAwIDogdmVydC56ID49IG1vdW50YWluID8gMjogMTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2ZXJ0aWNlX2NvbG9yc1tpXTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBsZXQgZmFjZTEgPSBuZXcgVEhSRUUuRmFjZTMoXHJcbiAgICAgICAgICAgICAgICBmYWNlMV9jb29yZHMuYSxcclxuICAgICAgICAgICAgICAgIGZhY2UxX2Nvb3Jkcy5iLFxyXG4gICAgICAgICAgICAgICAgZmFjZTFfY29vcmRzLmMsXHJcbiAgICAgICAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgICAgICAgZmFjZTFfY29sb3JzXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAvLysrKysrKysrKysrKysrXHJcblxyXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIGluZGV4IG9mIHRoZSBjb3JyZXNwb25kaW5nIHZlcnRpY2VzL3ZlcnRpeC92ZXJ0aXhlcz8/XHJcbiAgICAgICAgICAgIGxldCBmYWNlMl9jb29yZHMgPSB7XHJcbiAgICAgICAgICAgICAgICBhOiB4ICsgKHkgKyAxKSAqIHdpZHRoLFxyXG4gICAgICAgICAgICAgICAgYjogeCArIDEgKyB5ICogd2lkdGgsXHJcbiAgICAgICAgICAgICAgICBjOiB4ICsgMSArICh5ICsgMSkgKiB3aWR0aFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSB2ZXJ0aWNlIGNvbG9ycyBieSBjcm9zcy1jaGVja2luZyB0aGVpciB2YWx1ZXMgd2l0aCB0aGUgdGhyZXNoaG9sZHNcclxuICAgICAgICAgICAgbGV0IGZhY2UyX2NvbG9ycyA9IFtcImFcIiwgXCJiXCIsIFwiY1wiXS5tYXAobWF0X2Nvb3JkID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB2ZXJ0ID0gZ2VvbWV0cnkudmVydGljZXNbZmFjZTJfY29vcmRzW21hdF9jb29yZF1dO1xyXG4gICAgICAgICAgICAgICAgbGV0IGkgPSB2ZXJ0LnogPD0gd2F0ZXIgPyAwIDogdmVydC56ID49IG1vdW50YWluID8gMjogMTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2ZXJ0aWNlX2NvbG9yc1tpXTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAgICAgbGV0IGZhY2UyID0gbmV3IFRIUkVFLkZhY2UzKFxyXG4gICAgICAgICAgICAgICAgZmFjZTJfY29vcmRzLmEsXHJcbiAgICAgICAgICAgICAgICBmYWNlMl9jb29yZHMuYixcclxuICAgICAgICAgICAgICAgIGZhY2UyX2Nvb3Jkcy5jLFxyXG4gICAgICAgICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgICAgIGZhY2UyX2NvbG9yc1xyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgZ2VvbWV0cnkuZmFjZXMucHVzaChmYWNlMSwgZmFjZTIpO1xyXG5cclxuXHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICBnZW9tZXRyeS5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuICAgICAgICBnZW9tZXRyeS5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xyXG4gICAgICAgIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG4gICAgICAgIC8vZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNb2RlbDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBjbGFzcyB0byBlbmNhcHN1bGF0ZSB0aGUgZGlzdGFuY2UvaGV1cmlzdGljcyB2YWx1ZXNcclxuICovXHJcbmNsYXNzIFBhdGhOb2RlIHtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBkaXN0YW5jZSwgaGV1cmlzdGljcywgcGFyZW50KSB7XHJcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcclxuICAgICAgICB0aGlzLmQgPSBkaXN0YW5jZTtcclxuICAgICAgICB0aGlzLmggPSBoZXVyaXN0aWNzO1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBwYXRoIGJldHdlZW4gdHdvIHBvaW50cyBiYXNlZCBvbiBhIGdpdmVuIHN0cnVjdHVyZVxyXG4gKi9cclxuY2xhc3MgUGF0aCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgcGF0aCBiZXR3ZWVuIHR3byBwb2ludHMgYW5kIG1ha2VzIHRoZSBwYXRoLWluc3RhbmNlIGFuIGl0ZXJhYmxlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZyb21cclxuICAgICAqIEBwYXJhbSB0b1xyXG4gICAgICogQHBhcmFtIHN0cnVjdHVyZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bywgc3RydWN0dXJlKSB7XHJcblxyXG4gICAgICAgIC8vIHNhbml0aXplIGlucHV0XHJcbiAgICAgICAgZnJvbSA9IHN0cnVjdHVyZS5nZXQoZnJvbS54LCBmcm9tLnkpO1xyXG4gICAgICAgIHRvID0gc3RydWN0dXJlLmdldCh0by54LCB0by55KTtcclxuXHJcblxyXG4gICAgICAgIC8vIHRocm93IGVycm9yIGlmIGltcG9zc2libGVcclxuICAgICAgICBpZighZnJvbS5wYXNzYWJsZSB8fCAhdG8ucGFzc2FibGUgfHwgdG8ubG9ja2VkKXtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEV2YWxFcnJvcihcIiNQYXRoOiBDYW4ndCBkZXRlcm1pbmUgYSBwYXRoIGJlY2F1c2UgZWl0aGVyIG9yaWdpbiBvciB0YXJnZXQgaXNuJ3QgcGFzc2FibGVcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgY3VycmVudCxcclxuICAgICAgICAgICAgc3Vycm91bmRpbmcgPSBbXSxcclxuICAgICAgICAgICAgY2FuZGlkYXRlcyA9IFtdLFxyXG4gICAgICAgICAgICBwYXRoID0gW10sXHJcbiAgICAgICAgICAgIGtub3duID0gW107XHJcblxyXG5cclxuICAgICAgICAvLyBiZWZvcmUgdGhlIGZpcnN0IGl0ZXJhdGlvbiwgd2UnbGwgc2V0IHRoZSBjdXJyZW50IHBvaW50IHRvIHRoZSBzdGFydCBub2RlXHJcbiAgICAgICAgY3VycmVudCA9IG5ldyBQYXRoTm9kZShmcm9tLCAwLCBmcm9tLnBvaW50LmRpc3RhbmNlX3RvKHRvLnBvaW50KSwgbnVsbCk7XHJcblxyXG4gICAgICAgIHdoaWxlICghY3VycmVudC5ub2RlLnBvaW50LmVxdWFscyh0by5wb2ludCkpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGRldGVybWluZSBzdXJyb3VuZGluZyBub2Rlc1xyXG4gICAgICAgICAgICBzdXJyb3VuZGluZyA9IHN0cnVjdHVyZS5nZXRfc3Vycm91bmRpbmcoY3VycmVudC5ub2RlLnBvaW50LngsIGN1cnJlbnQubm9kZS5wb2ludC55KTtcclxuXHJcbiAgICAgICAgICAgIC8vIGZpbHRlciBhbHJlYWQga25vd24gb25lc1xyXG4gICAgICAgICAgICBzdXJyb3VuZGluZyA9IHN1cnJvdW5kaW5nLmZpbHRlcihlbGVtID0+IGtub3duLmluZGV4T2YoZWxlbSkgPT09IC0xKTtcclxuICAgICAgICAgICAgLy8gYWRkIHRoZSBuZXcgb25lcyB0byB0aGUga25vd24tbGlzdFxyXG4gICAgICAgICAgICBrbm93biA9IGtub3duLmNvbmNhdChzdXJyb3VuZGluZyk7XHJcbiAgICAgICAgICAgIC8vIGZpbHRlciBibG9ja2VkIG9uZXNcclxuICAgICAgICAgICAgc3Vycm91bmRpbmcgPSBzdXJyb3VuZGluZy5maWx0ZXIoZWxlbSA9PiBlbGVtLnBhc3NhYmxlICYmICFlbGVtLmxvY2tlZCk7XHJcblxyXG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgZGlzdGFuY2VzIGFuZCB0dXJuIHRoZW0gaW50byBQYXRoTm9kZXNcclxuICAgICAgICAgICAgLy8gY29uY2F0IHdpdGggcHJldmlvdXMgY2FuZGlkYXRlcyB0byB3ZSdsbCBtb3JlIGVhc2lseSBiZSBhYmxlIHRvIHN3aXRjaCBwYXRocyBpZiBuZWVkZWRcclxuICAgICAgICAgICAgY2FuZGlkYXRlcyA9IGNhbmRpZGF0ZXMuY29uY2F0KFxyXG4gICAgICAgICAgICAgICAgc3Vycm91bmRpbmcubWFwKGVsZW0gPT4gbmV3IFBhdGhOb2RlKFxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5kICsgY3VycmVudC5ub2RlLnBvaW50LmRpc3RhbmNlX3RvKGVsZW0ucG9pbnQpLFxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW0ucG9pbnQuZGlzdGFuY2VfdG8odG8ucG9pbnQpLFxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRcclxuICAgICAgICAgICAgICAgICkpXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAvLyBzb3J0IGxpc3Qgc28gdGhlIGxvd2VzdCBpbmRleCBoYXMgdGhlIGJlc3QgZXhwZWN0ZWQgdmFsdWVcclxuICAgICAgICAgICAgY2FuZGlkYXRlcy5zb3J0KChhLCBiKSA9PiAoYS5kICsgYS5oKSAtIChiLmQgKyBiLmgpKTtcclxuXHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjYW5kaWRhdGVzLnNoaWZ0KCk7XHJcblxyXG4gICAgICAgICAgICBpZighY3VycmVudCkgdGhyb3cgbmV3IEV2YWxFcnJvcihcIiNQYXRoOiBDYW4ndCBmaW5kIGEgcGF0aCB0byB0aGUgdGFyZ2V0IVwiKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLyBnbyBiYWNrIHRvIGNvbGxlY3QgdGhlIGNob3NlbiBub2Rlc1xyXG4gICAgICAgIHdoaWxlKGN1cnJlbnQgIT09IG51bGwpe1xyXG4gICAgICAgICAgICBwYXRoLnVuc2hpZnQoY3VycmVudC5ub2RlKTtcclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8vIG1ha2UgaXQgaXRlcmFibGVcclxuICAgICAgICB0aGlzW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICB3aGlsZSAocGF0aC5sZW5ndGggPiAwKXtcclxuICAgICAgICAgICAgICAgIHlpZWxkIHBhdGguc2hpZnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgfVxyXG5cclxuXHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBhdGg7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIExpc3QyRCA9IHJlcXVpcmUoXCIuLi9jb21tb24vbGlzdDJkXCIpO1xyXG52YXIgTWFwTm9kZSA9IHJlcXVpcmUoXCIuL21hcG5vZGVcIik7XHJcbnZhciBQb2ludCA9IHJlcXVpcmUoXCIuLi9jb21tb24vcG9pbnRcIik7XHJcblxyXG4vKipcclxuICogSGVscGVyIGNsYXNzIGZvciBtYXAgc3RydWN0dXJlc1xyXG4gKi9cclxuY2xhc3MgU3RydWN0dXJlIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSByYW5kb20gc3RydWN0dXJlXHJcbiAgICAgKiBAcGFyYW0gcHJvcGVydGllc1xyXG4gICAgICogQHJldHVybnMge0xpc3QyRHxleHBvcnRzfG1vZHVsZS5leHBvcnRzfVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlX3JhbmRvbShwcm9wZXJ0aWVzKSB7XHJcblxyXG4gICAgICAgIGxldCBsMmQgPSBuZXcgTGlzdDJEKHByb3BlcnRpZXMuc2l6ZV94LCBwcm9wZXJ0aWVzLnNpemVfeSk7XHJcblxyXG4gICAgICAgIC8vIGZpbGwgZWFjaCBwb2ludCB3aXRoIGEgcmFuZG9tIGhlaWdodFxyXG4gICAgICAgIGwyZC5mb3JfZWFjaChmdW5jdGlvbiAoZWxlbSwgeCwgeSkge1xyXG5cclxuICAgICAgICAgICAgbGV0IGhlaWdodCA9IE1hdGgucmFuZG9tKCkgKiAxMCAtIDU7XHJcblxyXG4gICAgICAgICAgICAvLyBjaGFuY2UgZm9yIGhpZ2hsaWdodDpcclxuICAgICAgICAgICAgaWYoTWF0aC5yYW5kb20oKSogcHJvcGVydGllcy5oaWdobGlnaHRfY2hhbmNlIDwgMSkgaGVpZ2h0ICo9IDEwO1xyXG4gICAgICAgICAgICBsZXQgcG9pbnQgPSBuZXcgUG9pbnQoeCwgeSwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgbGV0IG5vZGUgPSBuZXcgTWFwTm9kZShwb2ludCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGwyZC5zZXQoeCwgeSwgbm9kZSk7XHJcblxyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgLy8gc21vb3RoIHRoZSBoZWlnaHRzIHRvIGdldCBhIG5hdHVyYWwgbG9va2luZyBtYXBcclxuICAgICAgICBsZXQgY2xlYW5fcnVucyA9IDIwO1xyXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBjbGVhbl9ydW5zOyBpKyspe1xyXG5cclxuICAgICAgICAgICAgLy8gaGFybW9uaXplIGVhY2ggbm9kZSB3aXRoIHRoZSBzdXJyb3VuZGluZyBub2Rlc1xyXG4gICAgICAgICAgICBsMmQuZm9yX2VhY2goZnVuY3Rpb24gKGVsZW0sIHgsIHkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgc3Vycm91bmRpbmcgPSBsMmQuZ2V0X3N1cnJvdW5kaW5nKHgsIHkpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGF2ZyA9IHN1cnJvdW5kaW5nLnJlZHVjZSgodmFsLCBlbGVtKSA9PiB2YWwgKyBlbGVtLnBvaW50LnosIDApIC8gc3Vycm91bmRpbmcubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGNoYW5nZSB0aGUucG9pbnQueiB0byBiZSAyMCUgY2xvc2VyIHRvIHRoZSBhdmVyYWdlXHJcbiAgICAgICAgICAgICAgICBlbGVtLnBvaW50LnogPSAoIGVsZW0ucG9pbnQueiAqIDQgKyBhdmcgKSAvIDVcclxuXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYmxvY2sgd2F0ZXIvbW91bnRhaW4gZmllbGRzXHJcbiAgICAgICAgbDJkLmZvcl9lYWNoKGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgIGlmKGVsZW0ucG9pbnQueiA8PSBwcm9wZXJ0aWVzLmdyb3VuZHdhdGVyIHx8IGVsZW0ucG9pbnQueiA+PSBwcm9wZXJ0aWVzLm1vdW50YWluKSBlbGVtLnBhc3NhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICByZXR1cm4gbDJkO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3RydWN0dXJlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmxldCBHYW1lT2JqZWN0ID0gcmVxdWlyZShcIi4uL2NvbW1vbi9nYW1lb2JqZWN0XCIpO1xyXG5sZXQgVEhSRUUgPSByZXF1aXJlKFwiLi4vLi4vbGliL3RocmVlXCIpO1xyXG5cclxubGV0IFJFUyA9IHtcclxuICAgIFwiV09PRFwiOiAxLFxyXG4gICAgXCJTVE9ORVwiOiAyXHJcbn07XHJcblxyXG5sZXQgZGVmYXVsdF9wcm9wZXJ0aWVzID0ge1xyXG4gICAgcmVzOiBcIldPT0RcIixcclxuICAgIGFtb3VudDogMTAsXHJcbiAgICBmaWVsZHM6IFtcclxuICAgICAgICB7eDogMjAsIHk6IDQwfSxcclxuICAgICAgICB7eDogMjAsIHk6IDQxfSxcclxuICAgICAgICB7eDogMjEsIHk6IDQwfSxcclxuICAgICAgICB7eDogMjEsIHk6IDQxfVxyXG4gICAgXVxyXG59O1xyXG5cclxuXHJcbmNsYXNzIFJlc291cmNlIGV4dGVuZHMgR2FtZU9iamVjdCB7XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJvcGVydGllcykge1xyXG5cclxuICAgICAgICBzdXBlcigpO1xyXG5cclxuICAgICAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllcyB8fCBkZWZhdWx0X3Byb3BlcnRpZXM7XHJcblxyXG4gICAgICAgIHRoaXMudHlwZSA9IFJFU1twcm9wZXJ0aWVzLnJlc107XHJcbiAgICAgICAgdGhpcy5hbW91bnQgPSBwcm9wZXJ0aWVzLmFtb3VudDtcclxuICAgICAgICB0aGlzLmZpZWxkcyA9IHByb3BlcnRpZXMuZmllbGRzO1xyXG5cclxuICAgICAgICB0aGlzLm1lc2ggPSB0aGlzLmdlbmVyYXRlX21lc2goKTtcclxuICAgICAgICAvL3RoaXMubW9kZWwgPSB0aGlzLmdlbmVyYXRlX21vZGVscygpO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgZ2VuZXJhdGVfbWVzaCgpIHtcclxuXHJcbiAgICAgICAgLy8gZ2VuZXJhdGUgdGhlIGdlb21ldHJ5XHJcbiAgICAgICAgbGV0IGdlb21ldHJ5ID0gdGhpcy5maWVsZHMubWFwKGZpZWxkID0+IHtcclxuXHJcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIGdlb21ldHJ5IG9iamVjdCBmb3IgZWFjaCBmaWVsZCB0aGlzIHJlc291cmNlIGlzIG9uXHJcbiAgICAgICAgICAgIGxldCBnZW8gPSBuZXcgVEhSRUUuQm94R2VvbWV0cnkoMC4yNSwgMC4yNSwgNSk7XHJcbiAgICAgICAgICAgIGdlby52ZXJ0aWNlcy5mb3JFYWNoKHZlcnQgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmVydC54ICs9IGZpZWxkLng7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0LnkgKz0gZmllbGQueTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBnZW87XHJcblxyXG4gICAgICAgICAgICAvLyBtZXJnZSBhbGwgdGhvc2UgZ2VvbWV0cmllcyBpbnRvIG9uZVxyXG4gICAgICAgIH0pLnJlZHVjZSgocHJldiwgY3VycikgPT4ge1xyXG4gICAgICAgICAgICBpZiAocHJldikgY3Vyci5tZXJnZShwcmV2KTtcclxuICAgICAgICAgICAgcmV0dXJuIGN1cnI7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGxldCBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsKHtjb2xvcjogMHhmZmZmZmZ9KTtcclxuICAgICAgICByZXR1cm4gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0b29sXHJcbiAgICAgKi9cclxuICAgIHdvcmsodG9vbCkge1xyXG5cclxuICAgIH1cclxuXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVzb3VyY2U7XHJcbiIsInZhciBNdEV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIE10RXZlbnRIYW5kbGVyKCl7XHJcblxyXG4gICAgdGhpcy5fX2NoYW5uZWxzID0ge307XHJcblxyXG4gICAgLy9ETyBOT1QgQ0hBTkdFIERVUklORyBSVU5USU1FISEhXHJcbiAgICB0aGlzLl9fZXZlbnRsaXN0UHJvcGVydHlOYW1lID0gXCJfX210X2V2dHNfX1wiO1xyXG5cclxuXHJcbiAgICB0aGlzLl9fZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbihvYmosIHZhbCwgZnVuYyl7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgdmFsLCB7XHJcbiAgICAgICAgICB2YWx1ZTogZnVuYyxcclxuICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcclxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKlxyXG4gICAgICogVGhpcyBpbml0aWFsaXplcyB3aGlsZSBsb2FkaW5nIGFuZCBzZXRzIHRoZSBwcm9wZXJ0eS1uYW1lIG9mIHRoZSBldmVudGxpc3QgZm9yIGFsbCBvYmplY3RzXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX19ldmVudEZ1bmN0aW9ucyA9IHtcclxuICAgICAgICBcIm9uXCI6IChmdW5jdGlvbihwcm9wZXJ0eU5hbWUpe1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZXZlbnROYW1lLCBmdW5jKXtcclxuICAgICAgICAgICAgICAgIHZhciBldmVudE1hcCA9IHRoaXNbcHJvcGVydHlOYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmKCFldmVudE1hcCkgdGhyb3cgVHlwZUVycm9yKFwiVGhpcyBpcyBub3QgYW4gbXQtRXZlbnRlZCBPYmplY3QhXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYoIShmdW5jIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB0aHJvdyBUeXBlRXJyb3IoXCJOZWVkIHRvIHByb3ZpZGUgRnVuY3Rpb24gT2JqZWN0IHRvIFxcXCJPTlxcXCJcIik7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGlzIHRoZSBmaXJzdCBldmVudCB3aXRoIHRoaXMgbmFtZSwgY3JlYXRlIG5ldyBhcnJheSBmb3IgdGhpcyBldmVudCB0eXBlXHJcbiAgICAgICAgICAgICAgICBpZighZXZlbnRNYXBbZXZlbnROYW1lXSkgZXZlbnRNYXBbZXZlbnROYW1lXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlkZW50aWZpZXIgPSBldmVudE1hcFtldmVudE5hbWVdLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGV2ZW50TWFwW2V2ZW50TmFtZV0ucHVzaChmdW5jKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpZGVudGlmaWVyO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pKHRoaXMuX19ldmVudGxpc3RQcm9wZXJ0eU5hbWUpLFxyXG5cclxuICAgICAgICBcImVtaXRcIjogKGZ1bmN0aW9uKHByb3BlcnR5TmFtZSl7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihldmVudE5hbWUsIGluZm9PYmope1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50TWFwID0gdGhpc1twcm9wZXJ0eU5hbWVdO1xyXG4gICAgICAgICAgICAgICAgaWYoIWV2ZW50TWFwIHx8ICEoZXZlbnRNYXAgaW5zdGFuY2VvZiBPYmplY3QpKSB0aHJvdyBUeXBlRXJyb3IoXCJUaGlzIGlzIG5vdCBhbiBtdC1FdmVudGVkIE9iamVjdCFcIik7XHJcbiAgICAgICAgICAgICAgICAvLyBhYm9ydCBpZiB0aGVyZSBhcmUgbm8gc3Vic2NyaXB0aW9ucyBvbiB0aGlzIGV2ZW50XHJcbiAgICAgICAgICAgICAgICBpZighZXZlbnRNYXBbZXZlbnROYW1lXSkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgLy8gY2FsbCBhbGwgc3Vic2NyaXB0aW9uc1xyXG4gICAgICAgICAgICAgICAgZXZlbnRNYXBbZXZlbnROYW1lXS5mb3JFYWNoKGZ1bmN0aW9uKGZ1bmMpe1xyXG4gICAgICAgICAgICAgICAgICAgICEhZnVuYyAmJiBmdW5jKGluZm9PYmopO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSkodGhpcy5fX2V2ZW50bGlzdFByb3BlcnR5TmFtZSksXHJcblxyXG4gICAgICAgIFwiaWdub3JlXCI6IChmdW5jdGlvbihwcm9wZXJ0eU5hbWUpe1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZXZlbnROYW1lLCBpZGVudGlmaWVyKXtcclxuICAgICAgICAgICAgICAgIHZhciBldmVudE1hcCA9IHRoaXNbcHJvcGVydHlOYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmKCFldmVudE1hcCApIHRocm93IFR5cGVFcnJvcihcIlRoaXMgaXMgbm90IGFuIG10LUV2ZW50ZWQgT2JqZWN0IVwiKTtcclxuICAgICAgICAgICAgICAgIGlmKCFldmVudE1hcFtldmVudE5hbWVdIHx8ICFldmVudE1hcFtldmVudE5hbWVdW2lkZW50aWZpZXJdKSB0aHJvdyBSYW5nZUVycm9yKFwiRG9uJ3QgaGF2ZSB0aGlzIGV2ZW50IVwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRGdW5jID0gZXZlbnRNYXBbZXZlbnROYW1lXVtpZGVudGlmaWVyXTtcclxuICAgICAgICAgICAgICAgIGV2ZW50TWFwW2V2ZW50TmFtZV1baWRlbnRpZmllcl0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnRGdW5jO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pKHRoaXMuX19ldmVudGxpc3RQcm9wZXJ0eU5hbWUpXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMubWFrZUV2ZW50ZWQgPSBmdW5jdGlvbihvYmope1xyXG4gICAgICAgIHRoaXMuX19kZWZpbmVQcm9wZXJ0eShvYmosIHRoaXMuX19ldmVudGxpc3RQcm9wZXJ0eU5hbWUsIHt9KTtcclxuICAgICAgICB0aGlzLl9fZGVmaW5lUHJvcGVydHkob2JqLCBcIm9uXCIsIHRoaXMuX19ldmVudEZ1bmN0aW9ucy5vbik7XHJcbiAgICAgICAgdGhpcy5fX2RlZmluZVByb3BlcnR5KG9iaiwgXCJlbWl0XCIsIHRoaXMuX19ldmVudEZ1bmN0aW9ucy5lbWl0KTtcclxuICAgICAgICB0aGlzLl9fZGVmaW5lUHJvcGVydHkob2JqLCBcImlnbm9yZVwiLCB0aGlzLl9fZXZlbnRGdW5jdGlvbnMuaWdub3JlKTtcclxuICAgIH07XHJcblxyXG59O1xyXG5cclxuaWYodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgIT09IFwidW5kZWZpbmVkXCIpIG1vZHVsZS5leHBvcnRzID0gbmV3IE10RXZlbnRIYW5kbGVyKCk7XHJcbiIsInZhciBEZWZlcnJlZCA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKCk7XHJcblx0dGhpcy5zdGF0ZSA9IERlZmVycmVkLlBFTkRJTkc7XHJcbn07XHJcblxyXG5EZWZlcnJlZC5GVUxGSUxMRUQgPSAwO1xyXG5EZWZlcnJlZC5SRUpFQ1RFRCA9IDE7XHJcbkRlZmVycmVkLlBFTkRJTkcgPSAyO1xyXG5cclxuRGVmZXJyZWQuZGVidWcgPSBmYWxzZTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGlzIGEgdXRpbGl0eS1mdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzaW5nbGUgcHJvbWlzZSBmb3IgYW4gYXJyYXkgb2YgcHJvbWlzZXMuXHJcbiAqIEl0IHVwZGF0ZXMgdGhlIHByb21pc2UgZm9yIGV2ZXJ5IHJlc29sdmVkIGRlZmVycmVkIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSBvcmlnaW5hbCBlcnJvci5cclxuICogSXQgcmVzb2x2ZXMgb25jZSBhbGwgcHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkLlxyXG4gKi9cclxuRGVmZXJyZWQud2hlbiA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBfX2RlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcblxyXG5cdC8vIGV4Y2x1ZGUgbm9uLXByb21pc2UgdmFsdWVzIGFuZCBjb252ZXJ0IGFyZ3VtZW50cyB0byBhcnJheSBpbiBvbmUgZ29cclxuXHR2YXIgcHJvbWlzZXMgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoYXJndW1lbnRzLCBmdW5jdGlvbihhcmcpIHtcclxuXHRcdHJldHVybiAoYXJnIGluc3RhbmNlb2YgUHJvbWlzZSk7XHJcblx0fSk7XHJcblxyXG5cdHZhciB0b0dvID0gcHJvbWlzZXMubGVuZ3RoO1xyXG5cclxuXHRpZiAodG9HbyA8IDEpIHRocm93IFJhbmdlRXJyb3IoXCJObyBQcm9taXNlcyBoYXZlIGJlZW4gc3VibWl0dGVkIHRvIERlZmVycmVkLndoZW4sIG5lZWQgYXQgbGVhc3Qgb25lLlwiKTtcclxuXHJcblx0Ly8gc2F2ZSB0aGUgc29sdmVkIHZhbHVlcyBmb3IgdGhlIHByb21pc2VzIGluIHRoZSBzYW1lIG9yZGVyXHJcblx0dmFyIHNvbHZlVmFsdWVzID0gW107XHJcblx0c29sdmVWYWx1ZXMubGVuZ3RoID0gdG9HbztcclxuXHJcblx0cHJvbWlzZXMuZm9yRWFjaChmdW5jdGlvbihwcm9taXNlLCBpbmRleCkge1xyXG5cclxuXHRcdC8vIGFmdGVyIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZFxyXG5cdFx0cHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XHJcblxyXG5cdFx0XHRzb2x2ZVZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcclxuXHRcdFx0X19kZWZlcnJlZC51cGRhdGUoc29sdmVWYWx1ZXMpO1xyXG5cclxuXHRcdFx0Ly8gZGVjcmVtZW50IGNvdW50ZXIgYW5kIHJlc29sdmUgaWYgd2UncmUgZG9uZVxyXG5cdFx0XHRpZiAoLS10b0dvID09PSAwKSBfX2RlZmVycmVkLnJlc29sdmUoc29sdmVWYWx1ZXMpO1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcblxyXG5cdHJldHVybiBfX2RlZmVycmVkLnByb21pc2U7XHJcbn07XHJcblxyXG5EZWZlcnJlZC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlLCBzdHJpY3QpIHtcclxuXHJcblx0Ly8gSWYgdGhlIGRlZmVycmVkIGlzIGFscmVhZHkgY2xvc2VkLCB3ZSBjaGVjayBmb3IgdGhlIGRlYnVnLWZsYWcgYW5kIHRoZSBzdHJpY3QtcGFyYW1ldGVyXHJcblx0Ly8gYW5kIGdpdmUgZmVlZGJhY2sgdG8gdGhlIGNhbGxlciBhY2NvcmRpbmdseVxyXG5cdGlmKHRoaXMuc3RhdGUgIT09IERlZmVycmVkLlBFTkRJTkcpe1xyXG5cdFx0RGVmZXJyZWQuZGVidWcgJiYgY29uc29sZS53YXJuKFwiUHJvbWlzZSBhbHJlYWR5XCIsIHRoaXMuc3RhdGUsIFwiLCBjYW4ndCByZXNvbHZlIGFnYWluXCIpO1xyXG5cdFx0aWYoc3RyaWN0KSB0aHJvdyBuZXcgRXJyb3IoXCJQcm9taXNlIGFscmVhZHlcIiwgdGhpcy5zdGF0ZSk7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHQvLyBJZiBldmVyeXRoaW5nIGlzIG5vcm1hbCAod2hhdCBpcyBub3JtYWwgYW55d2F5cz8pLCB3ZSBtYXJrIHRoZSBkZWZlcnJlZCBhbmQgaXRzIHByb21pc2UgYXMgcmVzb2x2ZWRcclxuXHR0aGlzLnN0YXRlID0gRGVmZXJyZWQuRlVMRklMTEVEO1xyXG5cdHRoaXMucHJvbWlzZS5zdGF0ZSA9IERlZmVycmVkLkZVTEZJTExFRDtcclxuXHR0aGlzLnByb21pc2UuZW5kVmFsdWUgPSB2YWx1ZTtcclxuXHJcblx0Ly8gbGFzdCB0aGluZyB0byBkbyBpcyBleGVjdXRlIGFsbCBjYWNoZWQgXCJ0aGVuXCItY2FsbHMgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVcclxuXHQvLyBOT1RFOiBjaGFpbmluZyBvZiBwcm9taXNlcyBnZXRzIGhhbmRsZWQgYnkgdGhlIHByb21pc2VzIFwidGhlblwiIGZ1bmN0aW9uXHJcblx0dGhpcy5wcm9taXNlLl9yZXNvbHZlRnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oZnVuYykge1xyXG5cdFx0ZnVuYyh2YWx1ZSk7XHJcblx0fSk7XHJcblxyXG5cdC8vIHRoZSByZWFzb24gZm9yIHJldHVybmluZyBhIGJvb2xlYW4gZGVwZW5kaW5nIG9uIHdoZXRoZXIgcmVzb2x2aW5nIHdhcyBzdWNjZXNzZnVsIGlzXHJcblx0Ly8gdGhhdCB5b3UgY2FuIHN0cmlwIG91dCB0aGUgXCJzdHJpY3QgPSB0cnVlXCIgcGFyYW1ldGVyIGFuZCBpbXByb3ZlIHBlcmZvcm1hbmNlXHJcblx0Ly8gZm9yIHByb2R1Y3Rpb24gY29kZSBieSBqdXN0IGNoZWNraW5nIGZvciB0aGUgcmV0dXJuIHZhbHVlIG9mIFwicmVzb2x2ZVwiXHJcblx0cmV0dXJuIHRydWU7XHJcblxyXG59O1xyXG5cclxuRGVmZXJyZWQucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uKGVycm9yVmFsdWUsIHN0cmljdCkge1xyXG5cclxuXHRpZih0aGlzLnN0YXRlICE9PSBEZWZlcnJlZC5QRU5ESU5HKXtcclxuXHRcdERlZmVycmVkLmRlYnVnICYmIGNvbnNvbGUud2FybihcIlByb21pc2UgYWxyZWFkeVwiLCB0aGlzLnN0YXRlLCBcIiwgY2FuJ3QgcmVzb2x2ZSBhZ2FpblwiKTtcclxuXHRcdGlmKHN0cmljdCkgdGhyb3cgbmV3IEVycm9yKFwiUHJvbWlzZSBhbHJlYWR5XCIsIHRoaXMuc3RhdGUpO1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0dGhpcy5zdGF0ZSA9IERlZmVycmVkLlJFSkVDVEVEO1xyXG5cdHRoaXMucHJvbWlzZS5zdGF0ZSA9IERlZmVycmVkLlJFSkVDVEVEO1xyXG5cdHRoaXMucHJvbWlzZS5lbmRWYWx1ZSA9IGVycm9yVmFsdWU7XHJcblx0dGhpcy5wcm9taXNlLl9yZWplY3RGdW5jdGlvbnMuZm9yRWFjaChmdW5jdGlvbihmdW5jKSB7XHJcblx0XHRmdW5jKGVycm9yVmFsdWUpO1xyXG5cdH0pO1xyXG5cclxuXHRyZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbkRlZmVycmVkLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbih2YWx1ZSwgc3RyaWN0KSB7XHJcblxyXG5cdGlmKHRoaXMuc3RhdGUgIT09IERlZmVycmVkLlBFTkRJTkcpe1xyXG5cdFx0RGVmZXJyZWQuZGVidWcgJiYgY29uc29sZS53YXJuKFwiUHJvbWlzZSBhbHJlYWR5XCIsIHRoaXMuc3RhdGUsIFwiLCBjYW4ndCByZXNvbHZlIGFnYWluXCIpO1xyXG5cdFx0aWYoc3RyaWN0KSB0aHJvdyBuZXcgRXJyb3IoXCJQcm9taXNlIGFscmVhZHlcIiwgdGhpcy5zdGF0ZSk7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHR0aGlzLnByb21pc2UuX3VwZGF0ZUZ1bmN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGZ1bmMpIHtcclxuXHRcdGZ1bmModmFsdWUpO1xyXG5cdH0pO1xyXG5cdHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuXHJcblxyXG52YXIgUHJvbWlzZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHR0aGlzLnN0YXRlID0gRGVmZXJyZWQuUEVORElORztcclxuXHJcblx0dGhpcy5lbmRWYWx1ZSA9IG51bGw7XHJcblxyXG5cdHRoaXMuX3Jlc29sdmVGdW5jdGlvbnMgPSBbXTtcclxuXHJcblx0dGhpcy5fcmVqZWN0RnVuY3Rpb25zID0gW107XHJcblxyXG5cdHRoaXMuX3VwZGF0ZUZ1bmN0aW9ucyA9IFtdO1xyXG5cclxufTtcclxuXHJcblByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvblJlc29sdmUsIG9uRXJyb3IsIG9uVXBkYXRlKSB7XHJcblxyXG5cdC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgcHJvbWlzZSBhdCB0aGUgZW5kIG9mIHRoZSBcInRoZW5cIi1jYWxsIHRvIGFsbG93IGNoYWluaW5nXHJcblx0dmFyIGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcblxyXG5cdGlmIChvblJlc29sdmUpIHtcclxuXHRcdC8vaWYgdGhlIGRlZmVycmVkIGlzIGFscmVhZHkgcmVzb2x2ZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIHJpZ2h0IG5vd1xyXG5cdFx0aWYgKHRoaXMuc3RhdGUgPT09IERlZmVycmVkLkZVTEZJTExFRCkge1xyXG5cdFx0XHREZWZlcnJlZC5kZWJ1ZyAmJiBjb25zb2xlLmluZm8oXCJQcm9taXNlIGFscmVhZHkgcmVzb2x2ZWQsIGV4ZWN1dGluZyBcXFwidGhlblxcXCIgaW1tZWRpYXRlbHlcIilcclxuXHRcdFx0Ly8gZXhlY3V0ZSB0aGUgZnVuY3Rpb24gYW5kIHVzZSBpdHMgcmV0dXJuIHZhbHVlIGFzIGRlcml2ZWQgdmFsdWUuLi5cclxuXHRcdFx0dmFyIGRlcml2ZWRWYWx1ZSA9IG9uUmVzb2x2ZSh0aGlzLmVuZFZhbHVlKTtcclxuXHRcdFx0Ly8gLi4gZm9yIHRoZSBwcm9taXNlIG9mIHRoZSBjdXJyZW50IFwidGhlblwiLWNhbGwgdG8gYWxsb3cgcHJvbWlzZS1jaGFpbmluZ1xyXG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlKGRlcml2ZWRWYWx1ZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBpZiB0aGUgZGVmZXJyZWQgaXMgc3RpbGwgcGVuZGluZywgcHV0IHRoZSByZXNvbHZlIGZ1bmN0aW9uIGluIHF1ZXVlXHJcblx0XHRcdC8vIHNvIGl0IGNhbiBiZSBleGVjdXRlZCBsYXRlciBieSB0aGUgcGFyZW50aW5nIGRlZmVycmVkXHJcblx0XHRcdHRoaXMuX3Jlc29sdmVGdW5jdGlvbnMucHVzaChmdW5jdGlvbih2YWx1ZSkge1xyXG5cdFx0XHRcdC8vIGFzIGFib3ZlLCBzYXZlIHRoZSByZXR1cm4tdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIGNhbGwgZm9yIHRoZVxyXG5cdFx0XHRcdC8vIGRlZmVycmVkL3Byb21pc2Ugb2YgdGhlIGN1cnJlbnQgXCJ0aGVuXCItY2FsbFxyXG5cdFx0XHRcdHZhciBkZXJpdmVkVmFsdWUgPSBvblJlc29sdmUodmFsdWUpO1xyXG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmUoZGVyaXZlZFZhbHVlKTtcclxuXHRcdFx0fS5iaW5kKHRoaXMpKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIFNhbWUgYXMgYWJvdmUgZm9yIG9uUmVzb2x2ZSwgc28gbm8gY29tbWVudHMgaGVyZVxyXG5cdGlmIChvbkVycm9yKSB7XHJcblx0XHRpZiAodGhpcy5zdGF0ZSA9PT0gRGVmZXJyZWQuUkVKRUNURUQpIHtcclxuXHRcdFx0RGVmZXJyZWQuZGVidWcgJiYgY29uc29sZS5pbmZvKFwiUHJvbWlzZSBhbHJlYWR5IHJlamVjdGVkLCBleGVjdXRpbmcgXFxcInRoZW5cXFwiIGltbWVkaWF0ZWx5XCIpXHJcblx0XHRcdHZhciBkZXJpdmVkRXJyb3JWYWx1ZSA9IG9uRXJyb3IodGhpcy5lbmRWYWx1ZSk7XHJcblx0XHRcdGRlZmVycmVkLnJlamVjdChkZXJpdmVkRXJyb3JWYWx1ZSk7XHJcblx0XHR9IGVsc2V7XHJcblx0XHRcdHRoaXMuX3JlamVjdEZ1bmN0aW9ucy5wdXNoKGZ1bmN0aW9uKGVycm9yVmFsdWUpIHtcclxuXHRcdFx0XHR2YXIgZGVyaXZlZEVycm9yVmFsdWUgPSBvbkVycm9yKGVycm9yVmFsdWUpO1xyXG5cdFx0XHRcdGRlZmVycmVkLnJlamVjdChkZXJpdmVkRXJyb3JWYWx1ZSk7XHJcblx0XHRcdH0uYmluZCh0aGlzKSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRpZiAob25VcGRhdGUpIHtcclxuXHRcdC8vIHdoZW4gdXBkYXRpbmcgd2UgRE9OJ1QgcGFzcyB2YWx1ZXMgdG8gdGhlIGRlcml2ZWQgcHJvbWlzZSBiZWNhdXNlXHJcblx0XHQvLyB3ZSBjYW4ndCBkbyB0aGF0IGluIGEgd2F5IHRoYXQgbWFrZXMgc2Vuc2UgZm9yIHRoZSB1c2VyXHJcblx0XHRpZih0aGlzLnN0YXRlICE9PSBEZWZlcnJlZC5QRU5ESU5HKXtcclxuXHRcdFx0RGVmZXJyZWQuZGVidWcgJiYgY29uc29sZS53YXJuKFwiVHJ5aW5nIHRvIGFkZCBvblVwZGF0ZSBmdW5jdGlvbiB0byBhbHJlYWR5IGZ1bGZpbGxlZCBwcm9taXNlXCIpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlRnVuY3Rpb25zLnB1c2goZnVuY3Rpb24odmFsdWUpIHtcclxuXHRcdFx0XHRkZWZlcnJlZC51cGRhdGUob25VcGRhdGUodmFsdWUpKTtcclxuXHRcdFx0fS5iaW5kKHRoaXMpKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG5cclxufTtcclxuXHJcbmlmKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIpIG1vZHVsZS5leHBvcnRzID0gRGVmZXJyZWQ7XHJcbiIsIi8vIEZpbGU6c3JjL1RocmVlLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG52YXIgVEhSRUUgPSB7IFJFVklTSU9OOiAnNzMnIH07XHJcblxyXG4vL1xyXG5cclxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XHJcblxyXG4gICAgZGVmaW5lKCAndGhyZWUnLCBUSFJFRSApO1xyXG5cclxufSBlbHNlIGlmICggJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBleHBvcnRzICYmICd1bmRlZmluZWQnICE9PSB0eXBlb2YgbW9kdWxlICkge1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gVEhSRUU7XHJcblxyXG59XHJcblxyXG5cclxuLy8gcG9seWZpbGxzXHJcblxyXG5pZiAoIHNlbGYucmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSB1bmRlZmluZWQgfHwgc2VsZi5jYW5jZWxBbmltYXRpb25GcmFtZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgIC8vIE1pc3NpbmcgaW4gQW5kcm9pZCBzdG9jayBicm93c2VyLlxyXG5cclxuICAgICggZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgbGFzdFRpbWUgPSAwO1xyXG4gICAgICAgIHZhciB2ZW5kb3JzID0gWyAnbXMnLCAnbW96JywgJ3dlYmtpdCcsICdvJyBdO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgeCA9IDA7IHggPCB2ZW5kb3JzLmxlbmd0aCAmJiAhIHNlbGYucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArKyB4ICkge1xyXG5cclxuICAgICAgICAgICAgc2VsZi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBzZWxmWyB2ZW5kb3JzWyB4IF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJyBdO1xyXG4gICAgICAgICAgICBzZWxmLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gc2VsZlsgdmVuZG9yc1sgeCBdICsgJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJyBdIHx8IHNlbGZbIHZlbmRvcnNbIHggXSArICdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnIF07XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBzZWxmLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gdW5kZWZpbmVkICYmIHNlbGYuc2V0VGltZW91dCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgc2VsZi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBjdXJyVGltZSA9IERhdGUubm93KCksIHRpbWVUb0NhbGwgPSBNYXRoLm1heCggMCwgMTYgLSAoIGN1cnJUaW1lIC0gbGFzdFRpbWUgKSApO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlkID0gc2VsZi5zZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCBjdXJyVGltZSArIHRpbWVUb0NhbGwgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9LCB0aW1lVG9DYWxsICk7XHJcbiAgICAgICAgICAgICAgICBsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpZDtcclxuXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBzZWxmLmNhbmNlbEFuaW1hdGlvbkZyYW1lID09PSB1bmRlZmluZWQgJiYgc2VsZi5jbGVhclRpbWVvdXQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIHNlbGYuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoIGlkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KCBpZCApO1xyXG5cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0gKSgpO1xyXG5cclxufVxyXG5cclxuLy9cclxuXHJcbmlmICggc2VsZi5wZXJmb3JtYW5jZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgIHNlbGYucGVyZm9ybWFuY2UgPSB7fTtcclxuXHJcbn1cclxuXHJcbmlmICggc2VsZi5wZXJmb3JtYW5jZS5ub3cgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAoIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gRGF0ZS5ub3coKTtcclxuXHJcbiAgICAgICAgc2VsZi5wZXJmb3JtYW5jZS5ub3cgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIHN0YXJ0O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSApKCk7XHJcblxyXG59XHJcblxyXG4vL1xyXG5cclxuaWYgKCBOdW1iZXIuRVBTSUxPTiA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgIE51bWJlci5FUFNJTE9OID0gTWF0aC5wb3coIDIsIC01MiApO1xyXG5cclxufVxyXG5cclxuLy9cclxuXHJcbmlmICggTWF0aC5zaWduID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9zaWduXHJcblxyXG4gICAgTWF0aC5zaWduID0gZnVuY3Rpb24gKCB4ICkge1xyXG5cclxuICAgICAgICByZXR1cm4gKCB4IDwgMCApID8gLSAxIDogKCB4ID4gMCApID8gMSA6ICsgeDtcclxuXHJcbiAgICB9O1xyXG5cclxufVxyXG5cclxuaWYgKCBGdW5jdGlvbi5wcm90b3R5cGUubmFtZSA9PT0gdW5kZWZpbmVkICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgIC8vIE1pc3NpbmcgaW4gSUU5LTExLlxyXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vbmFtZVxyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggRnVuY3Rpb24ucHJvdG90eXBlLCAnbmFtZScsIHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpLm1hdGNoKCAvXlxccypmdW5jdGlvblxccyooXFxTKilcXHMqXFwoLyApWyAxIF07XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9ICk7XHJcblxyXG59XHJcblxyXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTW91c2VFdmVudC5idXR0b25cclxuXHJcblRIUkVFLk1PVVNFID0geyBMRUZUOiAwLCBNSURETEU6IDEsIFJJR0hUOiAyIH07XHJcblxyXG4vLyBHTCBTVEFURSBDT05TVEFOVFNcclxuXHJcblRIUkVFLkN1bGxGYWNlTm9uZSA9IDA7XHJcblRIUkVFLkN1bGxGYWNlQmFjayA9IDE7XHJcblRIUkVFLkN1bGxGYWNlRnJvbnQgPSAyO1xyXG5USFJFRS5DdWxsRmFjZUZyb250QmFjayA9IDM7XHJcblxyXG5USFJFRS5Gcm9udEZhY2VEaXJlY3Rpb25DVyA9IDA7XHJcblRIUkVFLkZyb250RmFjZURpcmVjdGlvbkNDVyA9IDE7XHJcblxyXG4vLyBTSEFET1dJTkcgVFlQRVNcclxuXHJcblRIUkVFLkJhc2ljU2hhZG93TWFwID0gMDtcclxuVEhSRUUuUENGU2hhZG93TWFwID0gMTtcclxuVEhSRUUuUENGU29mdFNoYWRvd01hcCA9IDI7XHJcblxyXG4vLyBNQVRFUklBTCBDT05TVEFOVFNcclxuXHJcbi8vIHNpZGVcclxuXHJcblRIUkVFLkZyb250U2lkZSA9IDA7XHJcblRIUkVFLkJhY2tTaWRlID0gMTtcclxuVEhSRUUuRG91YmxlU2lkZSA9IDI7XHJcblxyXG4vLyBzaGFkaW5nXHJcblxyXG5USFJFRS5GbGF0U2hhZGluZyA9IDE7XHJcblRIUkVFLlNtb290aFNoYWRpbmcgPSAyO1xyXG5cclxuLy8gY29sb3JzXHJcblxyXG5USFJFRS5Ob0NvbG9ycyA9IDA7XHJcblRIUkVFLkZhY2VDb2xvcnMgPSAxO1xyXG5USFJFRS5WZXJ0ZXhDb2xvcnMgPSAyO1xyXG5cclxuLy8gYmxlbmRpbmcgbW9kZXNcclxuXHJcblRIUkVFLk5vQmxlbmRpbmcgPSAwO1xyXG5USFJFRS5Ob3JtYWxCbGVuZGluZyA9IDE7XHJcblRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgPSAyO1xyXG5USFJFRS5TdWJ0cmFjdGl2ZUJsZW5kaW5nID0gMztcclxuVEhSRUUuTXVsdGlwbHlCbGVuZGluZyA9IDQ7XHJcblRIUkVFLkN1c3RvbUJsZW5kaW5nID0gNTtcclxuXHJcbi8vIGN1c3RvbSBibGVuZGluZyBlcXVhdGlvbnNcclxuLy8gKG51bWJlcnMgc3RhcnQgZnJvbSAxMDAgbm90IHRvIGNsYXNoIHdpdGggb3RoZXJcclxuLy8gbWFwcGluZ3MgdG8gT3BlbkdMIGNvbnN0YW50cyBkZWZpbmVkIGluIFRleHR1cmUuanMpXHJcblxyXG5USFJFRS5BZGRFcXVhdGlvbiA9IDEwMDtcclxuVEhSRUUuU3VidHJhY3RFcXVhdGlvbiA9IDEwMTtcclxuVEhSRUUuUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24gPSAxMDI7XHJcblRIUkVFLk1pbkVxdWF0aW9uID0gMTAzO1xyXG5USFJFRS5NYXhFcXVhdGlvbiA9IDEwNDtcclxuXHJcbi8vIGN1c3RvbSBibGVuZGluZyBkZXN0aW5hdGlvbiBmYWN0b3JzXHJcblxyXG5USFJFRS5aZXJvRmFjdG9yID0gMjAwO1xyXG5USFJFRS5PbmVGYWN0b3IgPSAyMDE7XHJcblRIUkVFLlNyY0NvbG9yRmFjdG9yID0gMjAyO1xyXG5USFJFRS5PbmVNaW51c1NyY0NvbG9yRmFjdG9yID0gMjAzO1xyXG5USFJFRS5TcmNBbHBoYUZhY3RvciA9IDIwNDtcclxuVEhSRUUuT25lTWludXNTcmNBbHBoYUZhY3RvciA9IDIwNTtcclxuVEhSRUUuRHN0QWxwaGFGYWN0b3IgPSAyMDY7XHJcblRIUkVFLk9uZU1pbnVzRHN0QWxwaGFGYWN0b3IgPSAyMDc7XHJcblxyXG4vLyBjdXN0b20gYmxlbmRpbmcgc291cmNlIGZhY3RvcnNcclxuXHJcbi8vVEhSRUUuWmVyb0ZhY3RvciA9IDIwMDtcclxuLy9USFJFRS5PbmVGYWN0b3IgPSAyMDE7XHJcbi8vVEhSRUUuU3JjQWxwaGFGYWN0b3IgPSAyMDQ7XHJcbi8vVEhSRUUuT25lTWludXNTcmNBbHBoYUZhY3RvciA9IDIwNTtcclxuLy9USFJFRS5Ec3RBbHBoYUZhY3RvciA9IDIwNjtcclxuLy9USFJFRS5PbmVNaW51c0RzdEFscGhhRmFjdG9yID0gMjA3O1xyXG5USFJFRS5Ec3RDb2xvckZhY3RvciA9IDIwODtcclxuVEhSRUUuT25lTWludXNEc3RDb2xvckZhY3RvciA9IDIwOTtcclxuVEhSRUUuU3JjQWxwaGFTYXR1cmF0ZUZhY3RvciA9IDIxMDtcclxuXHJcbi8vIGRlcHRoIG1vZGVzXHJcblxyXG5USFJFRS5OZXZlckRlcHRoID0gMDtcclxuVEhSRUUuQWx3YXlzRGVwdGggPSAxO1xyXG5USFJFRS5MZXNzRGVwdGggPSAyO1xyXG5USFJFRS5MZXNzRXF1YWxEZXB0aCA9IDM7XHJcblRIUkVFLkVxdWFsRGVwdGggPSA0O1xyXG5USFJFRS5HcmVhdGVyRXF1YWxEZXB0aCA9IDU7XHJcblRIUkVFLkdyZWF0ZXJEZXB0aCA9IDY7XHJcblRIUkVFLk5vdEVxdWFsRGVwdGggPSA3O1xyXG5cclxuXHJcbi8vIFRFWFRVUkUgQ09OU1RBTlRTXHJcblxyXG5USFJFRS5NdWx0aXBseU9wZXJhdGlvbiA9IDA7XHJcblRIUkVFLk1peE9wZXJhdGlvbiA9IDE7XHJcblRIUkVFLkFkZE9wZXJhdGlvbiA9IDI7XHJcblxyXG4vLyBNYXBwaW5nIG1vZGVzXHJcblxyXG5USFJFRS5VVk1hcHBpbmcgPSAzMDA7XHJcblxyXG5USFJFRS5DdWJlUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDE7XHJcblRIUkVFLkN1YmVSZWZyYWN0aW9uTWFwcGluZyA9IDMwMjtcclxuXHJcblRIUkVFLkVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nID0gMzAzO1xyXG5USFJFRS5FcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZyA9IDMwNDtcclxuXHJcblRIUkVFLlNwaGVyaWNhbFJlZmxlY3Rpb25NYXBwaW5nID0gMzA1O1xyXG5cclxuLy8gV3JhcHBpbmcgbW9kZXNcclxuXHJcblRIUkVFLlJlcGVhdFdyYXBwaW5nID0gMTAwMDtcclxuVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZyA9IDEwMDE7XHJcblRIUkVFLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmcgPSAxMDAyO1xyXG5cclxuLy8gRmlsdGVyc1xyXG5cclxuVEhSRUUuTmVhcmVzdEZpbHRlciA9IDEwMDM7XHJcblRIUkVFLk5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyID0gMTAwNDtcclxuVEhSRUUuTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciA9IDEwMDU7XHJcblRIUkVFLkxpbmVhckZpbHRlciA9IDEwMDY7XHJcblRIUkVFLkxpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA3O1xyXG5USFJFRS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIgPSAxMDA4O1xyXG5cclxuLy8gRGF0YSB0eXBlc1xyXG5cclxuVEhSRUUuVW5zaWduZWRCeXRlVHlwZSA9IDEwMDk7XHJcblRIUkVFLkJ5dGVUeXBlID0gMTAxMDtcclxuVEhSRUUuU2hvcnRUeXBlID0gMTAxMTtcclxuVEhSRUUuVW5zaWduZWRTaG9ydFR5cGUgPSAxMDEyO1xyXG5USFJFRS5JbnRUeXBlID0gMTAxMztcclxuVEhSRUUuVW5zaWduZWRJbnRUeXBlID0gMTAxNDtcclxuVEhSRUUuRmxvYXRUeXBlID0gMTAxNTtcclxuVEhSRUUuSGFsZkZsb2F0VHlwZSA9IDEwMjU7XHJcblxyXG4vLyBQaXhlbCB0eXBlc1xyXG5cclxuLy9USFJFRS5VbnNpZ25lZEJ5dGVUeXBlID0gMTAwOTtcclxuVEhSRUUuVW5zaWduZWRTaG9ydDQ0NDRUeXBlID0gMTAxNjtcclxuVEhSRUUuVW5zaWduZWRTaG9ydDU1NTFUeXBlID0gMTAxNztcclxuVEhSRUUuVW5zaWduZWRTaG9ydDU2NVR5cGUgPSAxMDE4O1xyXG5cclxuLy8gUGl4ZWwgZm9ybWF0c1xyXG5cclxuVEhSRUUuQWxwaGFGb3JtYXQgPSAxMDE5O1xyXG5USFJFRS5SR0JGb3JtYXQgPSAxMDIwO1xyXG5USFJFRS5SR0JBRm9ybWF0ID0gMTAyMTtcclxuVEhSRUUuTHVtaW5hbmNlRm9ybWF0ID0gMTAyMjtcclxuVEhSRUUuTHVtaW5hbmNlQWxwaGFGb3JtYXQgPSAxMDIzO1xyXG4vLyBUSFJFRS5SR0JFRm9ybWF0IGhhbmRsZWQgYXMgVEhSRUUuUkdCQUZvcm1hdCBpbiBzaGFkZXJzXHJcblRIUkVFLlJHQkVGb3JtYXQgPSBUSFJFRS5SR0JBRm9ybWF0OyAvLzEwMjQ7XHJcblxyXG4vLyBERFMgLyBTVDNDIENvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXRzXHJcblxyXG5USFJFRS5SR0JfUzNUQ19EWFQxX0Zvcm1hdCA9IDIwMDE7XHJcblRIUkVFLlJHQkFfUzNUQ19EWFQxX0Zvcm1hdCA9IDIwMDI7XHJcblRIUkVFLlJHQkFfUzNUQ19EWFQzX0Zvcm1hdCA9IDIwMDM7XHJcblRIUkVFLlJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCA9IDIwMDQ7XHJcblxyXG5cclxuLy8gUFZSVEMgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdHNcclxuXHJcblRIUkVFLlJHQl9QVlJUQ180QlBQVjFfRm9ybWF0ID0gMjEwMDtcclxuVEhSRUUuUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSAyMTAxO1xyXG5USFJFRS5SR0JBX1BWUlRDXzRCUFBWMV9Gb3JtYXQgPSAyMTAyO1xyXG5USFJFRS5SR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSAyMTAzO1xyXG5cclxuLy8gTG9vcCBzdHlsZXMgZm9yIEFuaW1hdGlvbkFjdGlvblxyXG5cclxuVEhSRUUuTG9vcE9uY2UgPSAyMjAwO1xyXG5USFJFRS5Mb29wUmVwZWF0ID0gMjIwMTtcclxuVEhSRUUuTG9vcFBpbmdQb25nID0gMjIwMjtcclxuXHJcbi8vIERFUFJFQ0FURURcclxuXHJcblRIUkVFLlByb2plY3RvciA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvamVjdG9yIGhhcyBiZWVuIG1vdmVkIHRvIC9leGFtcGxlcy9qcy9yZW5kZXJlcnMvUHJvamVjdG9yLmpzLicgKTtcclxuXHJcbiAgICB0aGlzLnByb2plY3RWZWN0b3IgPSBmdW5jdGlvbiAoIHZlY3RvciwgY2FtZXJhICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5Qcm9qZWN0b3I6IC5wcm9qZWN0VmVjdG9yKCkgaXMgbm93IHZlY3Rvci5wcm9qZWN0KCkuJyApO1xyXG4gICAgICAgIHZlY3Rvci5wcm9qZWN0KCBjYW1lcmEgKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMudW5wcm9qZWN0VmVjdG9yID0gZnVuY3Rpb24gKCB2ZWN0b3IsIGNhbWVyYSApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuUHJvamVjdG9yOiAudW5wcm9qZWN0VmVjdG9yKCkgaXMgbm93IHZlY3Rvci51bnByb2plY3QoKS4nICk7XHJcbiAgICAgICAgdmVjdG9yLnVucHJvamVjdCggY2FtZXJhICk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnBpY2tpbmdSYXkgPSBmdW5jdGlvbiAoIHZlY3RvciwgY2FtZXJhICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvamVjdG9yOiAucGlja2luZ1JheSgpIGlzIG5vdyByYXljYXN0ZXIuc2V0RnJvbUNhbWVyYSgpLicgKTtcclxuXHJcbiAgICB9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLkNhbnZhc1JlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5DYW52YXNSZW5kZXJlciBoYXMgYmVlbiBtb3ZlZCB0byAvZXhhbXBsZXMvanMvcmVuZGVyZXJzL0NhbnZhc1JlbmRlcmVyLmpzJyApO1xyXG5cclxuICAgIHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XHJcbiAgICB0aGlzLmNsZWFyID0gZnVuY3Rpb24gKCkge307XHJcbiAgICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICgpIHt9O1xyXG4gICAgdGhpcy5zZXRDbGVhckNvbG9yID0gZnVuY3Rpb24gKCkge307XHJcbiAgICB0aGlzLnNldFNpemUgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL0NvbG9yLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5Db2xvciA9IGZ1bmN0aW9uICggY29sb3IgKSB7XHJcblxyXG4gICAgaWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAzICkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5mcm9tQXJyYXkoIGFyZ3VtZW50cyApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5zZXQoIGNvbG9yICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ29sb3IucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5Db2xvcixcclxuXHJcbiAgICByOiAxLCBnOiAxLCBiOiAxLFxyXG5cclxuICAgIHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgaWYgKCB2YWx1ZSBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jb3B5KCB2YWx1ZSApO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zZXRIZXgoIHZhbHVlICk7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNldFN0eWxlKCB2YWx1ZSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0SGV4OiBmdW5jdGlvbiAoIGhleCApIHtcclxuXHJcbiAgICAgICAgaGV4ID0gTWF0aC5mbG9vciggaGV4ICk7XHJcblxyXG4gICAgICAgIHRoaXMuciA9ICggaGV4ID4+IDE2ICYgMjU1ICkgLyAyNTU7XHJcbiAgICAgICAgdGhpcy5nID0gKCBoZXggPj4gOCAmIDI1NSApIC8gMjU1O1xyXG4gICAgICAgIHRoaXMuYiA9ICggaGV4ICYgMjU1ICkgLyAyNTU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0UkdCOiBmdW5jdGlvbiAoIHIsIGcsIGIgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuciA9IHI7XHJcbiAgICAgICAgdGhpcy5nID0gZztcclxuICAgICAgICB0aGlzLmIgPSBiO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldEhTTDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBodWUycmdiKCBwLCBxLCB0ICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCB0IDwgMCApIHQgKz0gMTtcclxuICAgICAgICAgICAgaWYgKCB0ID4gMSApIHQgLT0gMTtcclxuICAgICAgICAgICAgaWYgKCB0IDwgMSAvIDYgKSByZXR1cm4gcCArICggcSAtIHAgKSAqIDYgKiB0O1xyXG4gICAgICAgICAgICBpZiAoIHQgPCAxIC8gMiApIHJldHVybiBxO1xyXG4gICAgICAgICAgICBpZiAoIHQgPCAyIC8gMyApIHJldHVybiBwICsgKCBxIC0gcCApICogNiAqICggMiAvIDMgLSB0ICk7XHJcbiAgICAgICAgICAgIHJldHVybiBwO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIGgsIHMsIGwgKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBoLHMsbCByYW5nZXMgYXJlIGluIDAuMCAtIDEuMFxyXG4gICAgICAgICAgICBoID0gVEhSRUUuTWF0aC5ldWNsaWRlYW5Nb2R1bG8oIGgsIDEgKTtcclxuICAgICAgICAgICAgcyA9IFRIUkVFLk1hdGguY2xhbXAoIHMsIDAsIDEgKTtcclxuICAgICAgICAgICAgbCA9IFRIUkVFLk1hdGguY2xhbXAoIGwsIDAsIDEgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggcyA9PT0gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnIgPSB0aGlzLmcgPSB0aGlzLmIgPSBsO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IGwgPD0gMC41ID8gbCAqICggMSArIHMgKSA6IGwgKyBzIC0gKCBsICogcyApO1xyXG4gICAgICAgICAgICAgICAgdmFyIHEgPSAoIDIgKiBsICkgLSBwO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuciA9IGh1ZTJyZ2IoIHEsIHAsIGggKyAxIC8gMyApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nID0gaHVlMnJnYiggcSwgcCwgaCApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5iID0gaHVlMnJnYiggcSwgcCwgaCAtIDEgLyAzICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgc2V0U3R5bGU6IGZ1bmN0aW9uICggc3R5bGUgKSB7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZUFscGhhKCBzdHJpbmcgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHN0cmluZyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBwYXJzZUZsb2F0KCBzdHJpbmcgKSA8IDEgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQ29sb3I6IEFscGhhIGNvbXBvbmVudCBvZiAnICsgc3R5bGUgKyAnIHdpbGwgYmUgaWdub3JlZC4nICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIHZhciBtO1xyXG5cclxuICAgICAgICBpZiAoIG0gPSAvXigoPzpyZ2J8aHNsKWE/KVxcKFxccyooW15cXCldKilcXCkvLmV4ZWMoIHN0eWxlICkgKSB7XHJcblxyXG4gICAgICAgICAgICAvLyByZ2IgLyBoc2xcclxuXHJcbiAgICAgICAgICAgIHZhciBjb2xvcjtcclxuICAgICAgICAgICAgdmFyIG5hbWUgPSBtWyAxIF07XHJcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRzID0gbVsgMiBdO1xyXG5cclxuICAgICAgICAgICAgc3dpdGNoICggbmFtZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdyZ2InOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAncmdiYSc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggY29sb3IgPSAvXihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyooLFxccyooWzAtOV0qXFwuP1swLTldKylcXHMqKT8kLy5leGVjKCBjb21wb25lbnRzICkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZ2IoMjU1LDAsMCkgcmdiYSgyNTUsMCwwLDAuNSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAxIF0sIDEwICkgKSAvIDI1NTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgKSAvIDI1NTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgKSAvIDI1NTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUFscGhhKCBjb2xvclsgNSBdICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGNvbG9yID0gL14oXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqKCxcXHMqKFswLTldKlxcLj9bMC05XSspXFxzKik/JC8uZXhlYyggY29tcG9uZW50cyApICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmdiKDEwMCUsMCUsMCUpIHJnYmEoMTAwJSwwJSwwJSwwLjUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuciA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMSBdLCAxMCApICkgLyAxMDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZyA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMiBdLCAxMCApICkgLyAxMDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYiA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMyBdLCAxMCApICkgLyAxMDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVBbHBoYSggY29sb3JbIDUgXSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnaHNsJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2hzbGEnOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGNvbG9yID0gL14oWzAtOV0qXFwuP1swLTldKylcXHMqLFxccyooXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqKCxcXHMqKFswLTldKlxcLj9bMC05XSspXFxzKik/JC8uZXhlYyggY29tcG9uZW50cyApICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHNsKDEyMCw1MCUsNTAlKSBoc2xhKDEyMCw1MCUsNTAlLDAuNSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGggPSBwYXJzZUZsb2F0KCBjb2xvclsgMSBdICkgLyAzNjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgLyAxMDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsID0gcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgLyAxMDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVBbHBoYSggY29sb3JbIDUgXSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0SFNMKCBoLCBzLCBsICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIG0gPSAvXlxcIyhbQS1GYS1mMC05XSspJC8uZXhlYyggc3R5bGUgKSApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGhleCBjb2xvclxyXG5cclxuICAgICAgICAgICAgdmFyIGhleCA9IG1bIDEgXTtcclxuICAgICAgICAgICAgdmFyIHNpemUgPSBoZXgubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBzaXplID09PSAzICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vICNmZjBcclxuICAgICAgICAgICAgICAgIHRoaXMuciA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAwICkgKyBoZXguY2hhckF0KCAwICksIDE2ICkgLyAyNTU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmcgPSBwYXJzZUludCggaGV4LmNoYXJBdCggMSApICsgaGV4LmNoYXJBdCggMSApLCAxNiApIC8gMjU1O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5iID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDIgKSArIGhleC5jaGFyQXQoIDIgKSwgMTYgKSAvIDI1NTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHNpemUgPT09IDYgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gI2ZmMDAwMFxyXG4gICAgICAgICAgICAgICAgdGhpcy5yID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDAgKSArIGhleC5jaGFyQXQoIDEgKSwgMTYgKSAvIDI1NTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZyA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAyICkgKyBoZXguY2hhckF0KCAzICksIDE2ICkgLyAyNTU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmIgPSBwYXJzZUludCggaGV4LmNoYXJBdCggNCApICsgaGV4LmNoYXJBdCggNSApLCAxNiApIC8gMjU1O1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggc3R5bGUgJiYgc3R5bGUubGVuZ3RoID4gMCApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGNvbG9yIGtleXdvcmRzXHJcbiAgICAgICAgICAgIHZhciBoZXggPSBUSFJFRS5Db2xvcktleXdvcmRzWyBzdHlsZSBdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBoZXggIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyByZWRcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0SGV4KCBoZXggKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gdW5rbm93biBjb2xvclxyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQ29sb3I6IFVua25vd24gY29sb3IgJyArIHN0eWxlICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuciwgdGhpcy5nLCB0aGlzLmIgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvcHk6IGZ1bmN0aW9uICggY29sb3IgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuciA9IGNvbG9yLnI7XHJcbiAgICAgICAgdGhpcy5nID0gY29sb3IuZztcclxuICAgICAgICB0aGlzLmIgPSBjb2xvci5iO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvcHlHYW1tYVRvTGluZWFyOiBmdW5jdGlvbiAoIGNvbG9yLCBnYW1tYUZhY3RvciApIHtcclxuXHJcbiAgICAgICAgaWYgKCBnYW1tYUZhY3RvciA9PT0gdW5kZWZpbmVkICkgZ2FtbWFGYWN0b3IgPSAyLjA7XHJcblxyXG4gICAgICAgIHRoaXMuciA9IE1hdGgucG93KCBjb2xvci5yLCBnYW1tYUZhY3RvciApO1xyXG4gICAgICAgIHRoaXMuZyA9IE1hdGgucG93KCBjb2xvci5nLCBnYW1tYUZhY3RvciApO1xyXG4gICAgICAgIHRoaXMuYiA9IE1hdGgucG93KCBjb2xvci5iLCBnYW1tYUZhY3RvciApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvcHlMaW5lYXJUb0dhbW1hOiBmdW5jdGlvbiAoIGNvbG9yLCBnYW1tYUZhY3RvciApIHtcclxuXHJcbiAgICAgICAgaWYgKCBnYW1tYUZhY3RvciA9PT0gdW5kZWZpbmVkICkgZ2FtbWFGYWN0b3IgPSAyLjA7XHJcblxyXG4gICAgICAgIHZhciBzYWZlSW52ZXJzZSA9ICggZ2FtbWFGYWN0b3IgPiAwICkgPyAoIDEuMCAvIGdhbW1hRmFjdG9yICkgOiAxLjA7XHJcblxyXG4gICAgICAgIHRoaXMuciA9IE1hdGgucG93KCBjb2xvci5yLCBzYWZlSW52ZXJzZSApO1xyXG4gICAgICAgIHRoaXMuZyA9IE1hdGgucG93KCBjb2xvci5nLCBzYWZlSW52ZXJzZSApO1xyXG4gICAgICAgIHRoaXMuYiA9IE1hdGgucG93KCBjb2xvci5iLCBzYWZlSW52ZXJzZSApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvbnZlcnRHYW1tYVRvTGluZWFyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciByID0gdGhpcy5yLCBnID0gdGhpcy5nLCBiID0gdGhpcy5iO1xyXG5cclxuICAgICAgICB0aGlzLnIgPSByICogcjtcclxuICAgICAgICB0aGlzLmcgPSBnICogZztcclxuICAgICAgICB0aGlzLmIgPSBiICogYjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb252ZXJ0TGluZWFyVG9HYW1tYTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0aGlzLnIgPSBNYXRoLnNxcnQoIHRoaXMuciApO1xyXG4gICAgICAgIHRoaXMuZyA9IE1hdGguc3FydCggdGhpcy5nICk7XHJcbiAgICAgICAgdGhpcy5iID0gTWF0aC5zcXJ0KCB0aGlzLmIgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRIZXg6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuICggdGhpcy5yICogMjU1ICkgPDwgMTYgXiAoIHRoaXMuZyAqIDI1NSApIDw8IDggXiAoIHRoaXMuYiAqIDI1NSApIDw8IDA7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRIZXhTdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuICggJzAwMDAwMCcgKyB0aGlzLmdldEhleCgpLnRvU3RyaW5nKCAxNiApICkuc2xpY2UoIC0gNiApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0SFNMOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuICAgICAgICAvLyBoLHMsbCByYW5nZXMgYXJlIGluIDAuMCAtIDEuMFxyXG5cclxuICAgICAgICB2YXIgaHNsID0gb3B0aW9uYWxUYXJnZXQgfHwgeyBoOiAwLCBzOiAwLCBsOiAwIH07XHJcblxyXG4gICAgICAgIHZhciByID0gdGhpcy5yLCBnID0gdGhpcy5nLCBiID0gdGhpcy5iO1xyXG5cclxuICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXgoIHIsIGcsIGIgKTtcclxuICAgICAgICB2YXIgbWluID0gTWF0aC5taW4oIHIsIGcsIGIgKTtcclxuXHJcbiAgICAgICAgdmFyIGh1ZSwgc2F0dXJhdGlvbjtcclxuICAgICAgICB2YXIgbGlnaHRuZXNzID0gKCBtaW4gKyBtYXggKSAvIDIuMDtcclxuXHJcbiAgICAgICAgaWYgKCBtaW4gPT09IG1heCApIHtcclxuXHJcbiAgICAgICAgICAgIGh1ZSA9IDA7XHJcbiAgICAgICAgICAgIHNhdHVyYXRpb24gPSAwO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgdmFyIGRlbHRhID0gbWF4IC0gbWluO1xyXG5cclxuICAgICAgICAgICAgc2F0dXJhdGlvbiA9IGxpZ2h0bmVzcyA8PSAwLjUgPyBkZWx0YSAvICggbWF4ICsgbWluICkgOiBkZWx0YSAvICggMiAtIG1heCAtIG1pbiApO1xyXG5cclxuICAgICAgICAgICAgc3dpdGNoICggbWF4ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgcjogaHVlID0gKCBnIC0gYiApIC8gZGVsdGEgKyAoIGcgPCBiID8gNiA6IDAgKTsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIGc6IGh1ZSA9ICggYiAtIHIgKSAvIGRlbHRhICsgMjsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIGI6IGh1ZSA9ICggciAtIGcgKSAvIGRlbHRhICsgNDsgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBodWUgLz0gNjtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBoc2wuaCA9IGh1ZTtcclxuICAgICAgICBoc2wucyA9IHNhdHVyYXRpb247XHJcbiAgICAgICAgaHNsLmwgPSBsaWdodG5lc3M7XHJcblxyXG4gICAgICAgIHJldHVybiBoc2w7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRTdHlsZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gJ3JnYignICsgKCAoIHRoaXMuciAqIDI1NSApIHwgMCApICsgJywnICsgKCAoIHRoaXMuZyAqIDI1NSApIHwgMCApICsgJywnICsgKCAoIHRoaXMuYiAqIDI1NSApIHwgMCApICsgJyknO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgb2Zmc2V0SFNMOiBmdW5jdGlvbiAoIGgsIHMsIGwgKSB7XHJcblxyXG4gICAgICAgIHZhciBoc2wgPSB0aGlzLmdldEhTTCgpO1xyXG5cclxuICAgICAgICBoc2wuaCArPSBoOyBoc2wucyArPSBzOyBoc2wubCArPSBsO1xyXG5cclxuICAgICAgICB0aGlzLnNldEhTTCggaHNsLmgsIGhzbC5zLCBoc2wubCApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKCBjb2xvciApIHtcclxuXHJcbiAgICAgICAgdGhpcy5yICs9IGNvbG9yLnI7XHJcbiAgICAgICAgdGhpcy5nICs9IGNvbG9yLmc7XHJcbiAgICAgICAgdGhpcy5iICs9IGNvbG9yLmI7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYWRkQ29sb3JzOiBmdW5jdGlvbiAoIGNvbG9yMSwgY29sb3IyICkge1xyXG5cclxuICAgICAgICB0aGlzLnIgPSBjb2xvcjEuciArIGNvbG9yMi5yO1xyXG4gICAgICAgIHRoaXMuZyA9IGNvbG9yMS5nICsgY29sb3IyLmc7XHJcbiAgICAgICAgdGhpcy5iID0gY29sb3IxLmIgKyBjb2xvcjIuYjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhZGRTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcclxuXHJcbiAgICAgICAgdGhpcy5yICs9IHM7XHJcbiAgICAgICAgdGhpcy5nICs9IHM7XHJcbiAgICAgICAgdGhpcy5iICs9IHM7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbXVsdGlwbHk6IGZ1bmN0aW9uICggY29sb3IgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuciAqPSBjb2xvci5yO1xyXG4gICAgICAgIHRoaXMuZyAqPSBjb2xvci5nO1xyXG4gICAgICAgIHRoaXMuYiAqPSBjb2xvci5iO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuciAqPSBzO1xyXG4gICAgICAgIHRoaXMuZyAqPSBzO1xyXG4gICAgICAgIHRoaXMuYiAqPSBzO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGxlcnA6IGZ1bmN0aW9uICggY29sb3IsIGFscGhhICkge1xyXG5cclxuICAgICAgICB0aGlzLnIgKz0gKCBjb2xvci5yIC0gdGhpcy5yICkgKiBhbHBoYTtcclxuICAgICAgICB0aGlzLmcgKz0gKCBjb2xvci5nIC0gdGhpcy5nICkgKiBhbHBoYTtcclxuICAgICAgICB0aGlzLmIgKz0gKCBjb2xvci5iIC0gdGhpcy5iICkgKiBhbHBoYTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBlcXVhbHM6IGZ1bmN0aW9uICggYyApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuICggYy5yID09PSB0aGlzLnIgKSAmJiAoIGMuZyA9PT0gdGhpcy5nICkgJiYgKCBjLmIgPT09IHRoaXMuYiApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG4gICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLnIgPSBhcnJheVsgb2Zmc2V0IF07XHJcbiAgICAgICAgdGhpcy5nID0gYXJyYXlbIG9mZnNldCArIDEgXTtcclxuICAgICAgICB0aGlzLmIgPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcbiAgICAgICAgaWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcclxuICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCBdID0gdGhpcy5yO1xyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLmc7XHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuYjtcclxuXHJcbiAgICAgICAgcmV0dXJuIGFycmF5O1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Db2xvcktleXdvcmRzID0geyAnYWxpY2VibHVlJzogMHhGMEY4RkYsICdhbnRpcXVld2hpdGUnOiAweEZBRUJENywgJ2FxdWEnOiAweDAwRkZGRiwgJ2FxdWFtYXJpbmUnOiAweDdGRkZENCwgJ2F6dXJlJzogMHhGMEZGRkYsXHJcbiAgICAnYmVpZ2UnOiAweEY1RjVEQywgJ2Jpc3F1ZSc6IDB4RkZFNEM0LCAnYmxhY2snOiAweDAwMDAwMCwgJ2JsYW5jaGVkYWxtb25kJzogMHhGRkVCQ0QsICdibHVlJzogMHgwMDAwRkYsICdibHVldmlvbGV0JzogMHg4QTJCRTIsXHJcbiAgICAnYnJvd24nOiAweEE1MkEyQSwgJ2J1cmx5d29vZCc6IDB4REVCODg3LCAnY2FkZXRibHVlJzogMHg1RjlFQTAsICdjaGFydHJldXNlJzogMHg3RkZGMDAsICdjaG9jb2xhdGUnOiAweEQyNjkxRSwgJ2NvcmFsJzogMHhGRjdGNTAsXHJcbiAgICAnY29ybmZsb3dlcmJsdWUnOiAweDY0OTVFRCwgJ2Nvcm5zaWxrJzogMHhGRkY4REMsICdjcmltc29uJzogMHhEQzE0M0MsICdjeWFuJzogMHgwMEZGRkYsICdkYXJrYmx1ZSc6IDB4MDAwMDhCLCAnZGFya2N5YW4nOiAweDAwOEI4QixcclxuICAgICdkYXJrZ29sZGVucm9kJzogMHhCODg2MEIsICdkYXJrZ3JheSc6IDB4QTlBOUE5LCAnZGFya2dyZWVuJzogMHgwMDY0MDAsICdkYXJrZ3JleSc6IDB4QTlBOUE5LCAnZGFya2toYWtpJzogMHhCREI3NkIsICdkYXJrbWFnZW50YSc6IDB4OEIwMDhCLFxyXG4gICAgJ2RhcmtvbGl2ZWdyZWVuJzogMHg1NTZCMkYsICdkYXJrb3JhbmdlJzogMHhGRjhDMDAsICdkYXJrb3JjaGlkJzogMHg5OTMyQ0MsICdkYXJrcmVkJzogMHg4QjAwMDAsICdkYXJrc2FsbW9uJzogMHhFOTk2N0EsICdkYXJrc2VhZ3JlZW4nOiAweDhGQkM4RixcclxuICAgICdkYXJrc2xhdGVibHVlJzogMHg0ODNEOEIsICdkYXJrc2xhdGVncmF5JzogMHgyRjRGNEYsICdkYXJrc2xhdGVncmV5JzogMHgyRjRGNEYsICdkYXJrdHVycXVvaXNlJzogMHgwMENFRDEsICdkYXJrdmlvbGV0JzogMHg5NDAwRDMsXHJcbiAgICAnZGVlcHBpbmsnOiAweEZGMTQ5MywgJ2RlZXBza3libHVlJzogMHgwMEJGRkYsICdkaW1ncmF5JzogMHg2OTY5NjksICdkaW1ncmV5JzogMHg2OTY5NjksICdkb2RnZXJibHVlJzogMHgxRTkwRkYsICdmaXJlYnJpY2snOiAweEIyMjIyMixcclxuICAgICdmbG9yYWx3aGl0ZSc6IDB4RkZGQUYwLCAnZm9yZXN0Z3JlZW4nOiAweDIyOEIyMiwgJ2Z1Y2hzaWEnOiAweEZGMDBGRiwgJ2dhaW5zYm9ybyc6IDB4RENEQ0RDLCAnZ2hvc3R3aGl0ZSc6IDB4RjhGOEZGLCAnZ29sZCc6IDB4RkZENzAwLFxyXG4gICAgJ2dvbGRlbnJvZCc6IDB4REFBNTIwLCAnZ3JheSc6IDB4ODA4MDgwLCAnZ3JlZW4nOiAweDAwODAwMCwgJ2dyZWVueWVsbG93JzogMHhBREZGMkYsICdncmV5JzogMHg4MDgwODAsICdob25leWRldyc6IDB4RjBGRkYwLCAnaG90cGluayc6IDB4RkY2OUI0LFxyXG4gICAgJ2luZGlhbnJlZCc6IDB4Q0Q1QzVDLCAnaW5kaWdvJzogMHg0QjAwODIsICdpdm9yeSc6IDB4RkZGRkYwLCAna2hha2knOiAweEYwRTY4QywgJ2xhdmVuZGVyJzogMHhFNkU2RkEsICdsYXZlbmRlcmJsdXNoJzogMHhGRkYwRjUsICdsYXduZ3JlZW4nOiAweDdDRkMwMCxcclxuICAgICdsZW1vbmNoaWZmb24nOiAweEZGRkFDRCwgJ2xpZ2h0Ymx1ZSc6IDB4QUREOEU2LCAnbGlnaHRjb3JhbCc6IDB4RjA4MDgwLCAnbGlnaHRjeWFuJzogMHhFMEZGRkYsICdsaWdodGdvbGRlbnJvZHllbGxvdyc6IDB4RkFGQUQyLCAnbGlnaHRncmF5JzogMHhEM0QzRDMsXHJcbiAgICAnbGlnaHRncmVlbic6IDB4OTBFRTkwLCAnbGlnaHRncmV5JzogMHhEM0QzRDMsICdsaWdodHBpbmsnOiAweEZGQjZDMSwgJ2xpZ2h0c2FsbW9uJzogMHhGRkEwN0EsICdsaWdodHNlYWdyZWVuJzogMHgyMEIyQUEsICdsaWdodHNreWJsdWUnOiAweDg3Q0VGQSxcclxuICAgICdsaWdodHNsYXRlZ3JheSc6IDB4Nzc4ODk5LCAnbGlnaHRzbGF0ZWdyZXknOiAweDc3ODg5OSwgJ2xpZ2h0c3RlZWxibHVlJzogMHhCMEM0REUsICdsaWdodHllbGxvdyc6IDB4RkZGRkUwLCAnbGltZSc6IDB4MDBGRjAwLCAnbGltZWdyZWVuJzogMHgzMkNEMzIsXHJcbiAgICAnbGluZW4nOiAweEZBRjBFNiwgJ21hZ2VudGEnOiAweEZGMDBGRiwgJ21hcm9vbic6IDB4ODAwMDAwLCAnbWVkaXVtYXF1YW1hcmluZSc6IDB4NjZDREFBLCAnbWVkaXVtYmx1ZSc6IDB4MDAwMENELCAnbWVkaXVtb3JjaGlkJzogMHhCQTU1RDMsXHJcbiAgICAnbWVkaXVtcHVycGxlJzogMHg5MzcwREIsICdtZWRpdW1zZWFncmVlbic6IDB4M0NCMzcxLCAnbWVkaXVtc2xhdGVibHVlJzogMHg3QjY4RUUsICdtZWRpdW1zcHJpbmdncmVlbic6IDB4MDBGQTlBLCAnbWVkaXVtdHVycXVvaXNlJzogMHg0OEQxQ0MsXHJcbiAgICAnbWVkaXVtdmlvbGV0cmVkJzogMHhDNzE1ODUsICdtaWRuaWdodGJsdWUnOiAweDE5MTk3MCwgJ21pbnRjcmVhbSc6IDB4RjVGRkZBLCAnbWlzdHlyb3NlJzogMHhGRkU0RTEsICdtb2NjYXNpbic6IDB4RkZFNEI1LCAnbmF2YWpvd2hpdGUnOiAweEZGREVBRCxcclxuICAgICduYXZ5JzogMHgwMDAwODAsICdvbGRsYWNlJzogMHhGREY1RTYsICdvbGl2ZSc6IDB4ODA4MDAwLCAnb2xpdmVkcmFiJzogMHg2QjhFMjMsICdvcmFuZ2UnOiAweEZGQTUwMCwgJ29yYW5nZXJlZCc6IDB4RkY0NTAwLCAnb3JjaGlkJzogMHhEQTcwRDYsXHJcbiAgICAncGFsZWdvbGRlbnJvZCc6IDB4RUVFOEFBLCAncGFsZWdyZWVuJzogMHg5OEZCOTgsICdwYWxldHVycXVvaXNlJzogMHhBRkVFRUUsICdwYWxldmlvbGV0cmVkJzogMHhEQjcwOTMsICdwYXBheWF3aGlwJzogMHhGRkVGRDUsICdwZWFjaHB1ZmYnOiAweEZGREFCOSxcclxuICAgICdwZXJ1JzogMHhDRDg1M0YsICdwaW5rJzogMHhGRkMwQ0IsICdwbHVtJzogMHhEREEwREQsICdwb3dkZXJibHVlJzogMHhCMEUwRTYsICdwdXJwbGUnOiAweDgwMDA4MCwgJ3JlZCc6IDB4RkYwMDAwLCAncm9zeWJyb3duJzogMHhCQzhGOEYsXHJcbiAgICAncm95YWxibHVlJzogMHg0MTY5RTEsICdzYWRkbGVicm93bic6IDB4OEI0NTEzLCAnc2FsbW9uJzogMHhGQTgwNzIsICdzYW5keWJyb3duJzogMHhGNEE0NjAsICdzZWFncmVlbic6IDB4MkU4QjU3LCAnc2Vhc2hlbGwnOiAweEZGRjVFRSxcclxuICAgICdzaWVubmEnOiAweEEwNTIyRCwgJ3NpbHZlcic6IDB4QzBDMEMwLCAnc2t5Ymx1ZSc6IDB4ODdDRUVCLCAnc2xhdGVibHVlJzogMHg2QTVBQ0QsICdzbGF0ZWdyYXknOiAweDcwODA5MCwgJ3NsYXRlZ3JleSc6IDB4NzA4MDkwLCAnc25vdyc6IDB4RkZGQUZBLFxyXG4gICAgJ3NwcmluZ2dyZWVuJzogMHgwMEZGN0YsICdzdGVlbGJsdWUnOiAweDQ2ODJCNCwgJ3Rhbic6IDB4RDJCNDhDLCAndGVhbCc6IDB4MDA4MDgwLCAndGhpc3RsZSc6IDB4RDhCRkQ4LCAndG9tYXRvJzogMHhGRjYzNDcsICd0dXJxdW9pc2UnOiAweDQwRTBEMCxcclxuICAgICd2aW9sZXQnOiAweEVFODJFRSwgJ3doZWF0JzogMHhGNURFQjMsICd3aGl0ZSc6IDB4RkZGRkZGLCAnd2hpdGVzbW9rZSc6IDB4RjVGNUY1LCAneWVsbG93JzogMHhGRkZGMDAsICd5ZWxsb3dncmVlbic6IDB4OUFDRDMyIH07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL1F1YXRlcm5pb24uanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG4gKi9cclxuXHJcblRIUkVFLlF1YXRlcm5pb24gPSBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XHJcblxyXG4gICAgdGhpcy5feCA9IHggfHwgMDtcclxuICAgIHRoaXMuX3kgPSB5IHx8IDA7XHJcbiAgICB0aGlzLl96ID0geiB8fCAwO1xyXG4gICAgdGhpcy5fdyA9ICggdyAhPT0gdW5kZWZpbmVkICkgPyB3IDogMTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5RdWF0ZXJuaW9uLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuUXVhdGVybmlvbixcclxuXHJcbiAgICBnZXQgeCAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLl94O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0IHggKCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5feCA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0IHkgKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5feTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldCB5ICggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuX3kgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldCB6ICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3o7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXQgeiAoIHZhbHVlICkge1xyXG5cclxuICAgICAgICB0aGlzLl96ID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXQgdyAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLl93O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0IHcgKCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5fdyA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0OiBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuX3ggPSB4O1xyXG4gICAgICAgIHRoaXMuX3kgPSB5O1xyXG4gICAgICAgIHRoaXMuX3ogPSB6O1xyXG4gICAgICAgIHRoaXMuX3cgPSB3O1xyXG5cclxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX3cgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvcHk6IGZ1bmN0aW9uICggcXVhdGVybmlvbiApIHtcclxuXHJcbiAgICAgICAgdGhpcy5feCA9IHF1YXRlcm5pb24ueDtcclxuICAgICAgICB0aGlzLl95ID0gcXVhdGVybmlvbi55O1xyXG4gICAgICAgIHRoaXMuX3ogPSBxdWF0ZXJuaW9uLno7XHJcbiAgICAgICAgdGhpcy5fdyA9IHF1YXRlcm5pb24udztcclxuXHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0RnJvbUV1bGVyOiBmdW5jdGlvbiAoIGV1bGVyLCB1cGRhdGUgKSB7XHJcblxyXG4gICAgICAgIGlmICggZXVsZXIgaW5zdGFuY2VvZiBUSFJFRS5FdWxlciA9PT0gZmFsc2UgKSB7XHJcblxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5RdWF0ZXJuaW9uOiAuc2V0RnJvbUV1bGVyKCkgbm93IGV4cGVjdHMgYSBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBodHRwOi8vd3d3Lm1hdGh3b3Jrcy5jb20vbWF0bGFiY2VudHJhbC9maWxlZXhjaGFuZ2UvXHJcbiAgICAgICAgLy8gXHQyMDY5Ni1mdW5jdGlvbi10by1jb252ZXJ0LWJldHdlZW4tZGNtLWV1bGVyLWFuZ2xlcy1xdWF0ZXJuaW9ucy1hbmQtZXVsZXItdmVjdG9ycy9cclxuICAgICAgICAvL1x0Y29udGVudC9TcGluQ2FsYy5tXHJcblxyXG4gICAgICAgIHZhciBjMSA9IE1hdGguY29zKCBldWxlci5feCAvIDIgKTtcclxuICAgICAgICB2YXIgYzIgPSBNYXRoLmNvcyggZXVsZXIuX3kgLyAyICk7XHJcbiAgICAgICAgdmFyIGMzID0gTWF0aC5jb3MoIGV1bGVyLl96IC8gMiApO1xyXG4gICAgICAgIHZhciBzMSA9IE1hdGguc2luKCBldWxlci5feCAvIDIgKTtcclxuICAgICAgICB2YXIgczIgPSBNYXRoLnNpbiggZXVsZXIuX3kgLyAyICk7XHJcbiAgICAgICAgdmFyIHMzID0gTWF0aC5zaW4oIGV1bGVyLl96IC8gMiApO1xyXG5cclxuICAgICAgICB2YXIgb3JkZXIgPSBldWxlci5vcmRlcjtcclxuXHJcbiAgICAgICAgaWYgKCBvcmRlciA9PT0gJ1hZWicgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xyXG4gICAgICAgICAgICB0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xyXG4gICAgICAgICAgICB0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xyXG4gICAgICAgICAgICB0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1lYWicgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xyXG4gICAgICAgICAgICB0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xyXG4gICAgICAgICAgICB0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xyXG4gICAgICAgICAgICB0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pYWScgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xyXG4gICAgICAgICAgICB0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xyXG4gICAgICAgICAgICB0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xyXG4gICAgICAgICAgICB0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pZWCcgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xyXG4gICAgICAgICAgICB0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xyXG4gICAgICAgICAgICB0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xyXG4gICAgICAgICAgICB0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1laWCcgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xyXG4gICAgICAgICAgICB0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xyXG4gICAgICAgICAgICB0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xyXG4gICAgICAgICAgICB0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1haWScgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xyXG4gICAgICAgICAgICB0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xyXG4gICAgICAgICAgICB0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xyXG4gICAgICAgICAgICB0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggdXBkYXRlICE9PSBmYWxzZSApIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZyb21BeGlzQW5nbGU6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XHJcblxyXG4gICAgICAgIC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9hbmdsZVRvUXVhdGVybmlvbi9pbmRleC5odG1cclxuXHJcbiAgICAgICAgLy8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcclxuXHJcbiAgICAgICAgdmFyIGhhbGZBbmdsZSA9IGFuZ2xlIC8gMiwgcyA9IE1hdGguc2luKCBoYWxmQW5nbGUgKTtcclxuXHJcbiAgICAgICAgdGhpcy5feCA9IGF4aXMueCAqIHM7XHJcbiAgICAgICAgdGhpcy5feSA9IGF4aXMueSAqIHM7XHJcbiAgICAgICAgdGhpcy5feiA9IGF4aXMueiAqIHM7XHJcbiAgICAgICAgdGhpcy5fdyA9IE1hdGguY29zKCBoYWxmQW5nbGUgKTtcclxuXHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0RnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG4gICAgICAgIC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb1F1YXRlcm5pb24vaW5kZXguaHRtXHJcblxyXG4gICAgICAgIC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXHJcblxyXG4gICAgICAgIHZhciB0ZSA9IG0uZWxlbWVudHMsXHJcblxyXG4gICAgICAgICAgICBtMTEgPSB0ZVsgMCBdLCBtMTIgPSB0ZVsgNCBdLCBtMTMgPSB0ZVsgOCBdLFxyXG4gICAgICAgICAgICBtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdLFxyXG4gICAgICAgICAgICBtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXSxcclxuXHJcbiAgICAgICAgICAgIHRyYWNlID0gbTExICsgbTIyICsgbTMzLFxyXG4gICAgICAgICAgICBzO1xyXG5cclxuICAgICAgICBpZiAoIHRyYWNlID4gMCApIHtcclxuXHJcbiAgICAgICAgICAgIHMgPSAwLjUgLyBNYXRoLnNxcnQoIHRyYWNlICsgMS4wICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl93ID0gMC4yNSAvIHM7XHJcbiAgICAgICAgICAgIHRoaXMuX3ggPSAoIG0zMiAtIG0yMyApICogcztcclxuICAgICAgICAgICAgdGhpcy5feSA9ICggbTEzIC0gbTMxICkgKiBzO1xyXG4gICAgICAgICAgICB0aGlzLl96ID0gKCBtMjEgLSBtMTIgKSAqIHM7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIG0xMSA+IG0yMiAmJiBtMTEgPiBtMzMgKSB7XHJcblxyXG4gICAgICAgICAgICBzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMTEgLSBtMjIgLSBtMzMgKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3cgPSAoIG0zMiAtIG0yMyApIC8gcztcclxuICAgICAgICAgICAgdGhpcy5feCA9IDAuMjUgKiBzO1xyXG4gICAgICAgICAgICB0aGlzLl95ID0gKCBtMTIgKyBtMjEgKSAvIHM7XHJcbiAgICAgICAgICAgIHRoaXMuX3ogPSAoIG0xMyArIG0zMSApIC8gcztcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICggbTIyID4gbTMzICkge1xyXG5cclxuICAgICAgICAgICAgcyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTIyIC0gbTExIC0gbTMzICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl93ID0gKCBtMTMgLSBtMzEgKSAvIHM7XHJcbiAgICAgICAgICAgIHRoaXMuX3ggPSAoIG0xMiArIG0yMSApIC8gcztcclxuICAgICAgICAgICAgdGhpcy5feSA9IDAuMjUgKiBzO1xyXG4gICAgICAgICAgICB0aGlzLl96ID0gKCBtMjMgKyBtMzIgKSAvIHM7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICBzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMzMgLSBtMTEgLSBtMjIgKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3cgPSAoIG0yMSAtIG0xMiApIC8gcztcclxuICAgICAgICAgICAgdGhpcy5feCA9ICggbTEzICsgbTMxICkgLyBzO1xyXG4gICAgICAgICAgICB0aGlzLl95ID0gKCBtMjMgKyBtMzIgKSAvIHM7XHJcbiAgICAgICAgICAgIHRoaXMuX3ogPSAwLjI1ICogcztcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRGcm9tVW5pdFZlY3RvcnM6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgLy8gaHR0cDovL2xvbGVuZ2luZS5uZXQvYmxvZy8yMDE0LzAyLzI0L3F1YXRlcm5pb24tZnJvbS10d28tdmVjdG9ycy1maW5hbFxyXG5cclxuICAgICAgICAvLyBhc3N1bWVzIGRpcmVjdGlvbiB2ZWN0b3JzIHZGcm9tIGFuZCB2VG8gYXJlIG5vcm1hbGl6ZWRcclxuXHJcbiAgICAgICAgdmFyIHYxLCByO1xyXG5cclxuICAgICAgICB2YXIgRVBTID0gMC4wMDAwMDE7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIHZGcm9tLCB2VG8gKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgICAgICByID0gdkZyb20uZG90KCB2VG8gKSArIDE7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHIgPCBFUFMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgciA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBNYXRoLmFicyggdkZyb20ueCApID4gTWF0aC5hYnMoIHZGcm9tLnogKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdjEuc2V0KCAtIHZGcm9tLnksIHZGcm9tLngsIDAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2MS5zZXQoIDAsIC0gdkZyb20ueiwgdkZyb20ueSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdjEuY3Jvc3NWZWN0b3JzKCB2RnJvbSwgdlRvICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLl94ID0gdjEueDtcclxuICAgICAgICAgICAgdGhpcy5feSA9IHYxLnk7XHJcbiAgICAgICAgICAgIHRoaXMuX3ogPSB2MS56O1xyXG4gICAgICAgICAgICB0aGlzLl93ID0gcjtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBpbnZlcnNlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY29uanVnYXRlKCkubm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29uanVnYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMuX3ggKj0gLSAxO1xyXG4gICAgICAgIHRoaXMuX3kgKj0gLSAxO1xyXG4gICAgICAgIHRoaXMuX3ogKj0gLSAxO1xyXG5cclxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBkb3Q6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ggKiB2Ll94ICsgdGhpcy5feSAqIHYuX3kgKyB0aGlzLl96ICogdi5feiArIHRoaXMuX3cgKiB2Ll93O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93ICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIGwgPSB0aGlzLmxlbmd0aCgpO1xyXG5cclxuICAgICAgICBpZiAoIGwgPT09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl94ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5feSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3ogPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl93ID0gMTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIGwgPSAxIC8gbDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3ggPSB0aGlzLl94ICogbDtcclxuICAgICAgICAgICAgdGhpcy5feSA9IHRoaXMuX3kgKiBsO1xyXG4gICAgICAgICAgICB0aGlzLl96ID0gdGhpcy5feiAqIGw7XHJcbiAgICAgICAgICAgIHRoaXMuX3cgPSB0aGlzLl93ICogbDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBtdWx0aXBseTogZnVuY3Rpb24gKCBxLCBwICkge1xyXG5cclxuICAgICAgICBpZiAoIHAgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlF1YXRlcm5pb246IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5UXVhdGVybmlvbnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggcSwgcCApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoIHRoaXMsIHEgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG11bHRpcGx5UXVhdGVybmlvbnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcbiAgICAgICAgLy8gZnJvbSBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL2NvZGUvaW5kZXguaHRtXHJcblxyXG4gICAgICAgIHZhciBxYXggPSBhLl94LCBxYXkgPSBhLl95LCBxYXogPSBhLl96LCBxYXcgPSBhLl93O1xyXG4gICAgICAgIHZhciBxYnggPSBiLl94LCBxYnkgPSBiLl95LCBxYnogPSBiLl96LCBxYncgPSBiLl93O1xyXG5cclxuICAgICAgICB0aGlzLl94ID0gcWF4ICogcWJ3ICsgcWF3ICogcWJ4ICsgcWF5ICogcWJ6IC0gcWF6ICogcWJ5O1xyXG4gICAgICAgIHRoaXMuX3kgPSBxYXkgKiBxYncgKyBxYXcgKiBxYnkgKyBxYXogKiBxYnggLSBxYXggKiBxYno7XHJcbiAgICAgICAgdGhpcy5feiA9IHFheiAqIHFidyArIHFhdyAqIHFieiArIHFheCAqIHFieSAtIHFheSAqIHFieDtcclxuICAgICAgICB0aGlzLl93ID0gcWF3ICogcWJ3IC0gcWF4ICogcWJ4IC0gcWF5ICogcWJ5IC0gcWF6ICogcWJ6O1xyXG5cclxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBtdWx0aXBseVZlY3RvcjM6IGZ1bmN0aW9uICggdmVjdG9yICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5RdWF0ZXJuaW9uOiAubXVsdGlwbHlWZWN0b3IzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIGlzIG5vdyB2ZWN0b3IuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICkgaW5zdGVhZC4nICk7XHJcbiAgICAgICAgcmV0dXJuIHZlY3Rvci5hcHBseVF1YXRlcm5pb24oIHRoaXMgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNsZXJwOiBmdW5jdGlvbiAoIHFiLCB0ICkge1xyXG5cclxuICAgICAgICBpZiAoIHQgPT09IDAgKSByZXR1cm4gdGhpcztcclxuICAgICAgICBpZiAoIHQgPT09IDEgKSByZXR1cm4gdGhpcy5jb3B5KCBxYiApO1xyXG5cclxuICAgICAgICB2YXIgeCA9IHRoaXMuX3gsIHkgPSB0aGlzLl95LCB6ID0gdGhpcy5feiwgdyA9IHRoaXMuX3c7XHJcblxyXG4gICAgICAgIC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvc2xlcnAvXHJcblxyXG4gICAgICAgIHZhciBjb3NIYWxmVGhldGEgPSB3ICogcWIuX3cgKyB4ICogcWIuX3ggKyB5ICogcWIuX3kgKyB6ICogcWIuX3o7XHJcblxyXG4gICAgICAgIGlmICggY29zSGFsZlRoZXRhIDwgMCApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3cgPSAtIHFiLl93O1xyXG4gICAgICAgICAgICB0aGlzLl94ID0gLSBxYi5feDtcclxuICAgICAgICAgICAgdGhpcy5feSA9IC0gcWIuX3k7XHJcbiAgICAgICAgICAgIHRoaXMuX3ogPSAtIHFiLl96O1xyXG5cclxuICAgICAgICAgICAgY29zSGFsZlRoZXRhID0gLSBjb3NIYWxmVGhldGE7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmNvcHkoIHFiICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBjb3NIYWxmVGhldGEgPj0gMS4wICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fdyA9IHc7XHJcbiAgICAgICAgICAgIHRoaXMuX3ggPSB4O1xyXG4gICAgICAgICAgICB0aGlzLl95ID0geTtcclxuICAgICAgICAgICAgdGhpcy5feiA9IHo7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaGFsZlRoZXRhID0gTWF0aC5hY29zKCBjb3NIYWxmVGhldGEgKTtcclxuICAgICAgICB2YXIgc2luSGFsZlRoZXRhID0gTWF0aC5zcXJ0KCAxLjAgLSBjb3NIYWxmVGhldGEgKiBjb3NIYWxmVGhldGEgKTtcclxuXHJcbiAgICAgICAgaWYgKCBNYXRoLmFicyggc2luSGFsZlRoZXRhICkgPCAwLjAwMSApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3cgPSAwLjUgKiAoIHcgKyB0aGlzLl93ICk7XHJcbiAgICAgICAgICAgIHRoaXMuX3ggPSAwLjUgKiAoIHggKyB0aGlzLl94ICk7XHJcbiAgICAgICAgICAgIHRoaXMuX3kgPSAwLjUgKiAoIHkgKyB0aGlzLl95ICk7XHJcbiAgICAgICAgICAgIHRoaXMuX3ogPSAwLjUgKiAoIHogKyB0aGlzLl96ICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcmF0aW9BID0gTWF0aC5zaW4oICggMSAtIHQgKSAqIGhhbGZUaGV0YSApIC8gc2luSGFsZlRoZXRhLFxyXG4gICAgICAgICAgICByYXRpb0IgPSBNYXRoLnNpbiggdCAqIGhhbGZUaGV0YSApIC8gc2luSGFsZlRoZXRhO1xyXG5cclxuICAgICAgICB0aGlzLl93ID0gKCB3ICogcmF0aW9BICsgdGhpcy5fdyAqIHJhdGlvQiApO1xyXG4gICAgICAgIHRoaXMuX3ggPSAoIHggKiByYXRpb0EgKyB0aGlzLl94ICogcmF0aW9CICk7XHJcbiAgICAgICAgdGhpcy5feSA9ICggeSAqIHJhdGlvQSArIHRoaXMuX3kgKiByYXRpb0IgKTtcclxuICAgICAgICB0aGlzLl96ID0gKCB6ICogcmF0aW9BICsgdGhpcy5feiAqIHJhdGlvQiApO1xyXG5cclxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBlcXVhbHM6IGZ1bmN0aW9uICggcXVhdGVybmlvbiApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuICggcXVhdGVybmlvbi5feCA9PT0gdGhpcy5feCApICYmICggcXVhdGVybmlvbi5feSA9PT0gdGhpcy5feSApICYmICggcXVhdGVybmlvbi5feiA9PT0gdGhpcy5feiApICYmICggcXVhdGVybmlvbi5fdyA9PT0gdGhpcy5fdyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG4gICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLl94ID0gYXJyYXlbIG9mZnNldCBdO1xyXG4gICAgICAgIHRoaXMuX3kgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xyXG4gICAgICAgIHRoaXMuX3ogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xyXG4gICAgICAgIHRoaXMuX3cgPSBhcnJheVsgb2Zmc2V0ICsgMyBdO1xyXG5cclxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG4gICAgICAgIGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XHJcbiAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgXSA9IHRoaXMuX3g7XHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuX3k7XHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuX3o7XHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDMgXSA9IHRoaXMuX3c7XHJcblxyXG4gICAgICAgIHJldHVybiBhcnJheTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xyXG5cclxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBvbkNoYW5nZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7fVxyXG5cclxufTtcclxuXHJcblRIUkVFLlF1YXRlcm5pb24uc2xlcnAgPSBmdW5jdGlvbiAoIHFhLCBxYiwgcW0sIHQgKSB7XHJcblxyXG4gICAgcmV0dXJuIHFtLmNvcHkoIHFhICkuc2xlcnAoIHFiLCB0ICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9WZWN0b3IyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cclxuICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKi9cclxuXHJcblRIUkVFLlZlY3RvcjIgPSBmdW5jdGlvbiAoIHgsIHkgKSB7XHJcblxyXG4gICAgdGhpcy54ID0geCB8fCAwO1xyXG4gICAgdGhpcy55ID0geSB8fCAwO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlZlY3RvcjIucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5WZWN0b3IyLFxyXG5cclxuICAgIGdldCB3aWR0aCgpIHsgcmV0dXJuIHRoaXMueCB9LFxyXG4gICAgc2V0IHdpZHRoKCB2YWx1ZSApIHsgdGhpcy54ID0gdmFsdWUgfSxcclxuXHJcbiAgICBnZXQgaGVpZ2h0KCkgeyByZXR1cm4gdGhpcy55IH0sXHJcbiAgICBzZXQgaGVpZ2h0KCB2YWx1ZSApIHsgdGhpcy55ID0gdmFsdWUgfSxcclxuXHJcbiAgICAvL1xyXG5cclxuICAgIHNldDogZnVuY3Rpb24gKCB4LCB5ICkge1xyXG5cclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0WDogZnVuY3Rpb24gKCB4ICkge1xyXG5cclxuICAgICAgICB0aGlzLnggPSB4O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldFk6IGZ1bmN0aW9uICggeSApIHtcclxuXHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXgsIHZhbHVlICkge1xyXG5cclxuICAgICAgICBzd2l0Y2ggKCBpbmRleCApIHtcclxuXHJcbiAgICAgICAgICAgIGNhc2UgMDogdGhpcy54ID0gdmFsdWU7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuICAgICAgICBzd2l0Y2ggKCBpbmRleCApIHtcclxuXHJcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIHRoaXMueDtcclxuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gdGhpcy55O1xyXG4gICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMueCwgdGhpcy55ICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHYueDtcclxuICAgICAgICB0aGlzLnkgPSB2Lnk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYWRkOiBmdW5jdGlvbiAoIHYsIHcgKSB7XHJcblxyXG4gICAgICAgIGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMjogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkVmVjdG9ycyggdiwgdyApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMueCArPSB2Lng7XHJcbiAgICAgICAgdGhpcy55ICs9IHYueTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhZGRTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcclxuXHJcbiAgICAgICAgdGhpcy54ICs9IHM7XHJcbiAgICAgICAgdGhpcy55ICs9IHM7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuICAgICAgICB0aGlzLnggPSBhLnggKyBiLng7XHJcbiAgICAgICAgdGhpcy55ID0gYS55ICsgYi55O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFkZFNjYWxlZFZlY3RvcjogZnVuY3Rpb24gKCB2LCBzICkge1xyXG5cclxuICAgICAgICB0aGlzLnggKz0gdi54ICogcztcclxuICAgICAgICB0aGlzLnkgKz0gdi55ICogcztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzdWI6IGZ1bmN0aW9uICggdiwgdyApIHtcclxuXHJcbiAgICAgICAgaWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IyOiAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2LCB3ICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy54IC09IHYueDtcclxuICAgICAgICB0aGlzLnkgLT0gdi55O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHN1YlNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuICAgICAgICB0aGlzLnggLT0gcztcclxuICAgICAgICB0aGlzLnkgLT0gcztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzdWJWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IGEueCAtIGIueDtcclxuICAgICAgICB0aGlzLnkgPSBhLnkgLSBiLnk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbXVsdGlwbHk6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcbiAgICAgICAgdGhpcy54ICo9IHYueDtcclxuICAgICAgICB0aGlzLnkgKj0gdi55O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcclxuXHJcbiAgICAgICAgaWYgKCBpc0Zpbml0ZSggc2NhbGFyICkgKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCAqPSBzY2FsYXI7XHJcbiAgICAgICAgICAgIHRoaXMueSAqPSBzY2FsYXI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy54ID0gMDtcclxuICAgICAgICAgICAgdGhpcy55ID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZGl2aWRlOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCAvPSB2Lng7XHJcbiAgICAgICAgdGhpcy55IC89IHYueTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggMSAvIHNjYWxhciApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbWluOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IE1hdGgubWluKCB0aGlzLngsIHYueCApO1xyXG4gICAgICAgIHRoaXMueSA9IE1hdGgubWluKCB0aGlzLnksIHYueSApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG1heDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuICAgICAgICB0aGlzLnggPSBNYXRoLm1heCggdGhpcy54LCB2LnggKTtcclxuICAgICAgICB0aGlzLnkgPSBNYXRoLm1heCggdGhpcy55LCB2LnkgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjbGFtcDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcclxuXHJcbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIG1pbiA8IG1heCwgaWYgdGhpcyBhc3N1bXB0aW9uIGlzbid0IHRydWUgaXQgd2lsbCBub3Qgb3BlcmF0ZSBjb3JyZWN0bHlcclxuXHJcbiAgICAgICAgdGhpcy54ID0gTWF0aC5tYXgoIG1pbi54LCBNYXRoLm1pbiggbWF4LngsIHRoaXMueCApICk7XHJcbiAgICAgICAgdGhpcy55ID0gTWF0aC5tYXgoIG1pbi55LCBNYXRoLm1pbiggbWF4LnksIHRoaXMueSApICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2xhbXBTY2FsYXI6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIG1pbiwgbWF4O1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBtaW4gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBtaW4gPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG4gICAgICAgICAgICAgICAgbWF4ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG1pbi5zZXQoIG1pblZhbCwgbWluVmFsICk7XHJcbiAgICAgICAgICAgIG1heC5zZXQoIG1heFZhbCwgbWF4VmFsICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGFtcCggbWluLCBtYXggKTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgY2xhbXBMZW5ndGg6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xyXG5cclxuICAgICAgICB0aGlzLm11bHRpcGx5U2NhbGFyKCBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCBsZW5ndGggKSApIC8gbGVuZ3RoICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XHJcbiAgICAgICAgdGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2VpbDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xyXG4gICAgICAgIHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XHJcbiAgICAgICAgdGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcm91bmRUb1plcm86IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gKCB0aGlzLnggPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueCApIDogTWF0aC5mbG9vciggdGhpcy54ICk7XHJcbiAgICAgICAgdGhpcy55ID0gKCB0aGlzLnkgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueSApIDogTWF0aC5mbG9vciggdGhpcy55ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbmVnYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IC0gdGhpcy54O1xyXG4gICAgICAgIHRoaXMueSA9IC0gdGhpcy55O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRvdDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGxlbmd0aDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGxlbmd0aE1hbmhhdHRhbjogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBkaXN0YW5jZVRvOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZGlzdGFuY2VUb1NxdWFyZWQ6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcbiAgICAgICAgdmFyIGR4ID0gdGhpcy54IC0gdi54LCBkeSA9IHRoaXMueSAtIHYueTtcclxuICAgICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRMZW5ndGg6IGZ1bmN0aW9uICggbGVuZ3RoICkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggbGVuZ3RoIC8gdGhpcy5sZW5ndGgoKSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbGVycDogZnVuY3Rpb24gKCB2LCBhbHBoYSApIHtcclxuXHJcbiAgICAgICAgdGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcclxuICAgICAgICB0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGxlcnBWZWN0b3JzOiBmdW5jdGlvbiAoIHYxLCB2MiwgYWxwaGEgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuc3ViVmVjdG9ycyggdjIsIHYxICkubXVsdGlwbHlTY2FsYXIoIGFscGhhICkuYWRkKCB2MSApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGVxdWFsczogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuICAgICAgICByZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcbiAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IGFycmF5WyBvZmZzZXQgXTtcclxuICAgICAgICB0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcbiAgICAgICAgaWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcclxuICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XHJcblxyXG4gICAgICAgIHJldHVybiBhcnJheTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGZyb21BdHRyaWJ1dGU6IGZ1bmN0aW9uICggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICkge1xyXG5cclxuICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcbiAgICAgICAgaW5kZXggPSBpbmRleCAqIGF0dHJpYnV0ZS5pdGVtU2l6ZSArIG9mZnNldDtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCBdO1xyXG4gICAgICAgIHRoaXMueSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAxIF07XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcm90YXRlQXJvdW5kOiBmdW5jdGlvbiAoIGNlbnRlciwgYW5nbGUgKSB7XHJcblxyXG4gICAgICAgIHZhciBjID0gTWF0aC5jb3MoIGFuZ2xlICksIHMgPSBNYXRoLnNpbiggYW5nbGUgKTtcclxuXHJcbiAgICAgICAgdmFyIHggPSB0aGlzLnggLSBjZW50ZXIueDtcclxuICAgICAgICB2YXIgeSA9IHRoaXMueSAtIGNlbnRlci55O1xyXG5cclxuICAgICAgICB0aGlzLnggPSB4ICogYyAtIHkgKiBzICsgY2VudGVyLng7XHJcbiAgICAgICAgdGhpcy55ID0geCAqIHMgKyB5ICogYyArIGNlbnRlci55O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9WZWN0b3IzLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciAqa2lsZSAvIGh0dHA6Ly9raWxlLnN0cmF2YWdhbnphLm9yZy9cclxuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqL1xyXG5cclxuVEhSRUUuVmVjdG9yMyA9IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcclxuXHJcbiAgICB0aGlzLnggPSB4IHx8IDA7XHJcbiAgICB0aGlzLnkgPSB5IHx8IDA7XHJcbiAgICB0aGlzLnogPSB6IHx8IDA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVmVjdG9yMy5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLlZlY3RvcjMsXHJcblxyXG4gICAgc2V0OiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB0aGlzLnogPSB6O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldFg6IGZ1bmN0aW9uICggeCApIHtcclxuXHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRZOiBmdW5jdGlvbiAoIHkgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0WjogZnVuY3Rpb24gKCB6ICkge1xyXG5cclxuICAgICAgICB0aGlzLnogPSB6O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCwgdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIHN3aXRjaCAoIGluZGV4ICkge1xyXG5cclxuICAgICAgICAgICAgY2FzZSAwOiB0aGlzLnggPSB2YWx1ZTsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTogdGhpcy55ID0gdmFsdWU7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDI6IHRoaXMueiA9IHZhbHVlOyBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuICAgICAgICBzd2l0Y2ggKCBpbmRleCApIHtcclxuXHJcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIHRoaXMueDtcclxuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gdGhpcy55O1xyXG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiB0aGlzLno7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnksIHRoaXMueiApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29weTogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuICAgICAgICB0aGlzLnggPSB2Lng7XHJcbiAgICAgICAgdGhpcy55ID0gdi55O1xyXG4gICAgICAgIHRoaXMueiA9IHYuejtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhZGQ6IGZ1bmN0aW9uICggdiwgdyApIHtcclxuXHJcbiAgICAgICAgaWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRWZWN0b3JzKCB2LCB3ICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy54ICs9IHYueDtcclxuICAgICAgICB0aGlzLnkgKz0gdi55O1xyXG4gICAgICAgIHRoaXMueiArPSB2Lno7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCArPSBzO1xyXG4gICAgICAgIHRoaXMueSArPSBzO1xyXG4gICAgICAgIHRoaXMueiArPSBzO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFkZFZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gYS54ICsgYi54O1xyXG4gICAgICAgIHRoaXMueSA9IGEueSArIGIueTtcclxuICAgICAgICB0aGlzLnogPSBhLnogKyBiLno7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYWRkU2NhbGVkVmVjdG9yOiBmdW5jdGlvbiAoIHYsIHMgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCArPSB2LnggKiBzO1xyXG4gICAgICAgIHRoaXMueSArPSB2LnkgKiBzO1xyXG4gICAgICAgIHRoaXMueiArPSB2LnogKiBzO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHN1YjogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuICAgICAgICBpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYsIHcgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnggLT0gdi54O1xyXG4gICAgICAgIHRoaXMueSAtPSB2Lnk7XHJcbiAgICAgICAgdGhpcy56IC09IHYuejtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzdWJTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcclxuXHJcbiAgICAgICAgdGhpcy54IC09IHM7XHJcbiAgICAgICAgdGhpcy55IC09IHM7XHJcbiAgICAgICAgdGhpcy56IC09IHM7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuICAgICAgICB0aGlzLnggPSBhLnggLSBiLng7XHJcbiAgICAgICAgdGhpcy55ID0gYS55IC0gYi55O1xyXG4gICAgICAgIHRoaXMueiA9IGEueiAtIGIuejtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBtdWx0aXBseTogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuICAgICAgICBpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5VmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVZlY3RvcnMoIHYsIHcgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnggKj0gdi54O1xyXG4gICAgICAgIHRoaXMueSAqPSB2Lnk7XHJcbiAgICAgICAgdGhpcy56ICo9IHYuejtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XHJcblxyXG4gICAgICAgIGlmICggaXNGaW5pdGUoIHNjYWxhciApICkge1xyXG4gICAgICAgICAgICB0aGlzLnggKj0gc2NhbGFyO1xyXG4gICAgICAgICAgICB0aGlzLnkgKj0gc2NhbGFyO1xyXG4gICAgICAgICAgICB0aGlzLnogKj0gc2NhbGFyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMueiA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG11bHRpcGx5VmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuICAgICAgICB0aGlzLnggPSBhLnggKiBiLng7XHJcbiAgICAgICAgdGhpcy55ID0gYS55ICogYi55O1xyXG4gICAgICAgIHRoaXMueiA9IGEueiAqIGIuejtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhcHBseUV1bGVyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBxdWF0ZXJuaW9uO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gYXBwbHlFdWxlciggZXVsZXIgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGV1bGVyIGluc3RhbmNlb2YgVEhSRUUuRXVsZXIgPT09IGZhbHNlICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5WZWN0b3IzOiAuYXBwbHlFdWxlcigpIG5vdyBleHBlY3RzIGEgRXVsZXIgcm90YXRpb24gcmF0aGVyIHRoYW4gYSBWZWN0b3IzIGFuZCBvcmRlci4nICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIHF1YXRlcm5pb24gPT09IHVuZGVmaW5lZCApIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciApICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgYXBwbHlBeGlzQW5nbGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHF1YXRlcm5pb247XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBhcHBseUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHF1YXRlcm5pb24gPT09IHVuZGVmaW5lZCApIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKSApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIGFwcGx5TWF0cml4MzogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuICAgICAgICB2YXIgeCA9IHRoaXMueDtcclxuICAgICAgICB2YXIgeSA9IHRoaXMueTtcclxuICAgICAgICB2YXIgeiA9IHRoaXMuejtcclxuXHJcbiAgICAgICAgdmFyIGUgPSBtLmVsZW1lbnRzO1xyXG5cclxuICAgICAgICB0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgMyBdICogeSArIGVbIDYgXSAqIHo7XHJcbiAgICAgICAgdGhpcy55ID0gZVsgMSBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA3IF0gKiB6O1xyXG4gICAgICAgIHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOCBdICogejtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcbiAgICAgICAgLy8gaW5wdXQ6IFRIUkVFLk1hdHJpeDQgYWZmaW5lIG1hdHJpeFxyXG5cclxuICAgICAgICB2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcclxuXHJcbiAgICAgICAgdmFyIGUgPSBtLmVsZW1lbnRzO1xyXG5cclxuICAgICAgICB0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAgKiB6ICsgZVsgMTIgXTtcclxuICAgICAgICB0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAgKiB6ICsgZVsgMTMgXTtcclxuICAgICAgICB0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6ICsgZVsgMTQgXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhcHBseVByb2plY3Rpb246IGZ1bmN0aW9uICggbSApIHtcclxuXHJcbiAgICAgICAgLy8gaW5wdXQ6IFRIUkVFLk1hdHJpeDQgcHJvamVjdGlvbiBtYXRyaXhcclxuXHJcbiAgICAgICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XHJcblxyXG4gICAgICAgIHZhciBlID0gbS5lbGVtZW50cztcclxuICAgICAgICB2YXIgZCA9IDEgLyAoIGVbIDMgXSAqIHggKyBlWyA3IF0gKiB5ICsgZVsgMTEgXSAqIHogKyBlWyAxNSBdICk7IC8vIHBlcnNwZWN0aXZlIGRpdmlkZVxyXG5cclxuICAgICAgICB0aGlzLnggPSAoIGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICAqIHogKyBlWyAxMiBdICkgKiBkO1xyXG4gICAgICAgIHRoaXMueSA9ICggZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gICogeiArIGVbIDEzIF0gKSAqIGQ7XHJcbiAgICAgICAgdGhpcy56ID0gKCBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6ICsgZVsgMTQgXSApICogZDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhcHBseVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcclxuXHJcbiAgICAgICAgdmFyIHggPSB0aGlzLng7XHJcbiAgICAgICAgdmFyIHkgPSB0aGlzLnk7XHJcbiAgICAgICAgdmFyIHogPSB0aGlzLno7XHJcblxyXG4gICAgICAgIHZhciBxeCA9IHEueDtcclxuICAgICAgICB2YXIgcXkgPSBxLnk7XHJcbiAgICAgICAgdmFyIHF6ID0gcS56O1xyXG4gICAgICAgIHZhciBxdyA9IHEudztcclxuXHJcbiAgICAgICAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWN0b3JcclxuXHJcbiAgICAgICAgdmFyIGl4ID0gIHF3ICogeCArIHF5ICogeiAtIHF6ICogeTtcclxuICAgICAgICB2YXIgaXkgPSAgcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6O1xyXG4gICAgICAgIHZhciBpeiA9ICBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHg7XHJcbiAgICAgICAgdmFyIGl3ID0gLSBxeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XHJcblxyXG4gICAgICAgIC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcclxuXHJcbiAgICAgICAgdGhpcy54ID0gaXggKiBxdyArIGl3ICogLSBxeCArIGl5ICogLSBxeiAtIGl6ICogLSBxeTtcclxuICAgICAgICB0aGlzLnkgPSBpeSAqIHF3ICsgaXcgKiAtIHF5ICsgaXogKiAtIHF4IC0gaXggKiAtIHF6O1xyXG4gICAgICAgIHRoaXMueiA9IGl6ICogcXcgKyBpdyAqIC0gcXogKyBpeCAqIC0gcXkgLSBpeSAqIC0gcXg7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcHJvamVjdDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgbWF0cml4O1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcHJvamVjdCggY2FtZXJhICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBtYXRyaXggPT09IHVuZGVmaW5lZCApIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG4gICAgICAgICAgICBtYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIG1hdHJpeC5nZXRJbnZlcnNlKCBjYW1lcmEubWF0cml4V29ybGQgKSApO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBseVByb2plY3Rpb24oIG1hdHJpeCApO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICB1bnByb2plY3Q6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIG1hdHJpeDtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHVucHJvamVjdCggY2FtZXJhICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBtYXRyaXggPT09IHVuZGVmaW5lZCApIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG4gICAgICAgICAgICBtYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkLCBtYXRyaXguZ2V0SW52ZXJzZSggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKSApO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBseVByb2plY3Rpb24oIG1hdHJpeCApO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICB0cmFuc2Zvcm1EaXJlY3Rpb246IGZ1bmN0aW9uICggbSApIHtcclxuXHJcbiAgICAgICAgLy8gaW5wdXQ6IFRIUkVFLk1hdHJpeDQgYWZmaW5lIG1hdHJpeFxyXG4gICAgICAgIC8vIHZlY3RvciBpbnRlcnByZXRlZCBhcyBhIGRpcmVjdGlvblxyXG5cclxuICAgICAgICB2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcclxuXHJcbiAgICAgICAgdmFyIGUgPSBtLmVsZW1lbnRzO1xyXG5cclxuICAgICAgICB0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAgKiB6O1xyXG4gICAgICAgIHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICAqIHo7XHJcbiAgICAgICAgdGhpcy56ID0gZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogejtcclxuXHJcbiAgICAgICAgdGhpcy5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBkaXZpZGU6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcbiAgICAgICAgdGhpcy54IC89IHYueDtcclxuICAgICAgICB0aGlzLnkgLz0gdi55O1xyXG4gICAgICAgIHRoaXMueiAvPSB2Lno7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIDEgLyBzY2FsYXIgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG1pbjogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuICAgICAgICB0aGlzLnggPSBNYXRoLm1pbiggdGhpcy54LCB2LnggKTtcclxuICAgICAgICB0aGlzLnkgPSBNYXRoLm1pbiggdGhpcy55LCB2LnkgKTtcclxuICAgICAgICB0aGlzLnogPSBNYXRoLm1pbiggdGhpcy56LCB2LnogKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBtYXg6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gTWF0aC5tYXgoIHRoaXMueCwgdi54ICk7XHJcbiAgICAgICAgdGhpcy55ID0gTWF0aC5tYXgoIHRoaXMueSwgdi55ICk7XHJcbiAgICAgICAgdGhpcy56ID0gTWF0aC5tYXgoIHRoaXMueiwgdi56ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2xhbXA6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyBtaW4gPCBtYXgsIGlmIHRoaXMgYXNzdW1wdGlvbiBpc24ndCB0cnVlIGl0IHdpbGwgbm90IG9wZXJhdGUgY29ycmVjdGx5XHJcblxyXG4gICAgICAgIHRoaXMueCA9IE1hdGgubWF4KCBtaW4ueCwgTWF0aC5taW4oIG1heC54LCB0aGlzLnggKSApO1xyXG4gICAgICAgIHRoaXMueSA9IE1hdGgubWF4KCBtaW4ueSwgTWF0aC5taW4oIG1heC55LCB0aGlzLnkgKSApO1xyXG4gICAgICAgIHRoaXMueiA9IE1hdGgubWF4KCBtaW4ueiwgTWF0aC5taW4oIG1heC56LCB0aGlzLnogKSApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNsYW1wU2NhbGFyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBtaW4sIG1heDtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNsYW1wU2NhbGFyKCBtaW5WYWwsIG1heFZhbCApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggbWluID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgbWluID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICAgICAgICAgIG1heCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBtaW4uc2V0KCBtaW5WYWwsIG1pblZhbCwgbWluVmFsICk7XHJcbiAgICAgICAgICAgIG1heC5zZXQoIG1heFZhbCwgbWF4VmFsLCBtYXhWYWwgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsYW1wKCBtaW4sIG1heCApO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBjbGFtcExlbmd0aDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcclxuXHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XHJcblxyXG4gICAgICAgIHRoaXMubXVsdGlwbHlTY2FsYXIoIE1hdGgubWF4KCBtaW4sIE1hdGgubWluKCBtYXgsIGxlbmd0aCApICkgLyBsZW5ndGggKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBmbG9vcjogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0aGlzLnggPSBNYXRoLmZsb29yKCB0aGlzLnggKTtcclxuICAgICAgICB0aGlzLnkgPSBNYXRoLmZsb29yKCB0aGlzLnkgKTtcclxuICAgICAgICB0aGlzLnogPSBNYXRoLmZsb29yKCB0aGlzLnogKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjZWlsOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XHJcbiAgICAgICAgdGhpcy55ID0gTWF0aC5jZWlsKCB0aGlzLnkgKTtcclxuICAgICAgICB0aGlzLnogPSBNYXRoLmNlaWwoIHRoaXMueiApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJvdW5kOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xyXG4gICAgICAgIHRoaXMueSA9IE1hdGgucm91bmQoIHRoaXMueSApO1xyXG4gICAgICAgIHRoaXMueiA9IE1hdGgucm91bmQoIHRoaXMueiApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9ICggdGhpcy54IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnggKSA6IE1hdGguZmxvb3IoIHRoaXMueCApO1xyXG4gICAgICAgIHRoaXMueSA9ICggdGhpcy55IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnkgKSA6IE1hdGguZmxvb3IoIHRoaXMueSApO1xyXG4gICAgICAgIHRoaXMueiA9ICggdGhpcy56IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnogKSA6IE1hdGguZmxvb3IoIHRoaXMueiApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0aGlzLnggPSAtIHRoaXMueDtcclxuICAgICAgICB0aGlzLnkgPSAtIHRoaXMueTtcclxuICAgICAgICB0aGlzLnogPSAtIHRoaXMuejtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBkb3Q6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueSArIHRoaXMueiAqIHYuejtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLno7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBsZW5ndGg6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBsZW5ndGhNYW5oYXR0YW46IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKCB0aGlzLnggKSArIE1hdGguYWJzKCB0aGlzLnkgKSArIE1hdGguYWJzKCB0aGlzLnogKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldExlbmd0aDogZnVuY3Rpb24gKCBsZW5ndGggKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCBsZW5ndGggLyB0aGlzLmxlbmd0aCgpICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBsZXJwOiBmdW5jdGlvbiAoIHYsIGFscGhhICkge1xyXG5cclxuICAgICAgICB0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xyXG4gICAgICAgIHRoaXMueSArPSAoIHYueSAtIHRoaXMueSApICogYWxwaGE7XHJcbiAgICAgICAgdGhpcy56ICs9ICggdi56IC0gdGhpcy56ICkgKiBhbHBoYTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBsZXJwVmVjdG9yczogZnVuY3Rpb24gKCB2MSwgdjIsIGFscGhhICkge1xyXG5cclxuICAgICAgICB0aGlzLnN1YlZlY3RvcnMoIHYyLCB2MSApLm11bHRpcGx5U2NhbGFyKCBhbHBoYSApLmFkZCggdjEgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjcm9zczogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuICAgICAgICBpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5jcm9zcygpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmNyb3NzVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcm9zc1ZlY3RvcnMoIHYsIHcgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcclxuXHJcbiAgICAgICAgdGhpcy54ID0geSAqIHYueiAtIHogKiB2Lnk7XHJcbiAgICAgICAgdGhpcy55ID0geiAqIHYueCAtIHggKiB2Lno7XHJcbiAgICAgICAgdGhpcy56ID0geCAqIHYueSAtIHkgKiB2Lng7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY3Jvc3NWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG4gICAgICAgIHZhciBheCA9IGEueCwgYXkgPSBhLnksIGF6ID0gYS56O1xyXG4gICAgICAgIHZhciBieCA9IGIueCwgYnkgPSBiLnksIGJ6ID0gYi56O1xyXG5cclxuICAgICAgICB0aGlzLnggPSBheSAqIGJ6IC0gYXogKiBieTtcclxuICAgICAgICB0aGlzLnkgPSBheiAqIGJ4IC0gYXggKiBiejtcclxuICAgICAgICB0aGlzLnogPSBheCAqIGJ5IC0gYXkgKiBieDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBwcm9qZWN0T25WZWN0b3I6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHYxLCBkb3Q7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBwcm9qZWN0T25WZWN0b3IoIHZlY3RvciApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgICAgIHYxLmNvcHkoIHZlY3RvciApLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICAgICAgZG90ID0gdGhpcy5kb3QoIHYxICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb3B5KCB2MSApLm11bHRpcGx5U2NhbGFyKCBkb3QgKTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgcHJvamVjdE9uUGxhbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHYxO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcHJvamVjdE9uUGxhbmUoIHBsYW5lTm9ybWFsICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICAgICAgdjEuY29weSggdGhpcyApLnByb2plY3RPblZlY3RvciggcGxhbmVOb3JtYWwgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YiggdjEgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICByZWZsZWN0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIC8vIHJlZmxlY3QgaW5jaWRlbnQgdmVjdG9yIG9mZiBwbGFuZSBvcnRob2dvbmFsIHRvIG5vcm1hbFxyXG4gICAgICAgIC8vIG5vcm1hbCBpcyBhc3N1bWVkIHRvIGhhdmUgdW5pdCBsZW5ndGhcclxuXHJcbiAgICAgICAgdmFyIHYxO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcmVmbGVjdCggbm9ybWFsICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ViKCB2MS5jb3B5KCBub3JtYWwgKS5tdWx0aXBseVNjYWxhciggMiAqIHRoaXMuZG90KCBub3JtYWwgKSApICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgYW5nbGVUbzogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuICAgICAgICB2YXIgdGhldGEgPSB0aGlzLmRvdCggdiApIC8gKCB0aGlzLmxlbmd0aCgpICogdi5sZW5ndGgoKSApO1xyXG5cclxuICAgICAgICAvLyBjbGFtcCwgdG8gaGFuZGxlIG51bWVyaWNhbCBwcm9ibGVtc1xyXG5cclxuICAgICAgICByZXR1cm4gTWF0aC5hY29zKCBUSFJFRS5NYXRoLmNsYW1wKCB0aGV0YSwgLSAxLCAxICkgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRpc3RhbmNlVG86IGZ1bmN0aW9uICggdiApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVRvU3F1YXJlZCggdiApICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBkaXN0YW5jZVRvU3F1YXJlZDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuICAgICAgICB2YXIgZHggPSB0aGlzLnggLSB2Lng7XHJcbiAgICAgICAgdmFyIGR5ID0gdGhpcy55IC0gdi55O1xyXG4gICAgICAgIHZhciBkeiA9IHRoaXMueiAtIHYuejtcclxuXHJcbiAgICAgICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkejtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldEV1bGVyRnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoIG0sIG9yZGVyICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogLnNldEV1bGVyRnJvbVJvdGF0aW9uTWF0cml4KCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIEV1bGVyLnNldEZyb21Sb3RhdGlvbk1hdHJpeCgpIGluc3RlYWQuJyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0RXVsZXJGcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxLCBvcmRlciApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLlZlY3RvcjM6IC5zZXRFdWxlckZyb21RdWF0ZXJuaW9uKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIEV1bGVyLnNldEZyb21RdWF0ZXJuaW9uKCkgaW5zdGVhZC4nICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRQb3NpdGlvbkZyb21NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmdldFBvc2l0aW9uRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhQb3NpdGlvbigpLicgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBtICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRTY2FsZUZyb21NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmdldFNjYWxlRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhTY2FsZSgpLicgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeFNjYWxlKCBtICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRDb2x1bW5Gcm9tTWF0cml4OiBmdW5jdGlvbiAoIGluZGV4LCBtYXRyaXggKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5nZXRDb2x1bW5Gcm9tTWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0RnJvbU1hdHJpeENvbHVtbigpLicgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbiggaW5kZXgsIG1hdHJpeCApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0RnJvbU1hdHJpeFBvc2l0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IG0uZWxlbWVudHNbIDEyIF07XHJcbiAgICAgICAgdGhpcy55ID0gbS5lbGVtZW50c1sgMTMgXTtcclxuICAgICAgICB0aGlzLnogPSBtLmVsZW1lbnRzWyAxNCBdO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZyb21NYXRyaXhTY2FsZTogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuICAgICAgICB2YXIgc3ggPSB0aGlzLnNldCggbS5lbGVtZW50c1sgMCBdLCBtLmVsZW1lbnRzWyAxIF0sIG0uZWxlbWVudHNbIDIgXSApLmxlbmd0aCgpO1xyXG4gICAgICAgIHZhciBzeSA9IHRoaXMuc2V0KCBtLmVsZW1lbnRzWyA0IF0sIG0uZWxlbWVudHNbIDUgXSwgbS5lbGVtZW50c1sgNiBdICkubGVuZ3RoKCk7XHJcbiAgICAgICAgdmFyIHN6ID0gdGhpcy5zZXQoIG0uZWxlbWVudHNbIDggXSwgbS5lbGVtZW50c1sgOSBdLCBtLmVsZW1lbnRzWyAxMCBdICkubGVuZ3RoKCk7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHN4O1xyXG4gICAgICAgIHRoaXMueSA9IHN5O1xyXG4gICAgICAgIHRoaXMueiA9IHN6O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZyb21NYXRyaXhDb2x1bW46IGZ1bmN0aW9uICggaW5kZXgsIG1hdHJpeCApIHtcclxuXHJcbiAgICAgICAgdmFyIG9mZnNldCA9IGluZGV4ICogNDtcclxuXHJcbiAgICAgICAgdmFyIG1lID0gbWF0cml4LmVsZW1lbnRzO1xyXG5cclxuICAgICAgICB0aGlzLnggPSBtZVsgb2Zmc2V0IF07XHJcbiAgICAgICAgdGhpcy55ID0gbWVbIG9mZnNldCArIDEgXTtcclxuICAgICAgICB0aGlzLnogPSBtZVsgb2Zmc2V0ICsgMiBdO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGVxdWFsczogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuICAgICAgICByZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICYmICggdi56ID09PSB0aGlzLnogKSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG4gICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XHJcbiAgICAgICAgdGhpcy55ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcclxuICAgICAgICB0aGlzLnogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcbiAgICAgICAgaWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcclxuICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuejtcclxuXHJcbiAgICAgICAgcmV0dXJuIGFycmF5O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZnJvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XHJcblxyXG4gICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuICAgICAgICBpbmRleCA9IGluZGV4ICogYXR0cmlidXRlLml0ZW1TaXplICsgb2Zmc2V0O1xyXG5cclxuICAgICAgICB0aGlzLnggPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4IF07XHJcbiAgICAgICAgdGhpcy55ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCArIDEgXTtcclxuICAgICAgICB0aGlzLnogPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4ICsgMiBdO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9WZWN0b3I0LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBzdXBlcmVnZ2JlcnQgLyBodHRwOi8vd3d3LnBhdWxicnVudC5jby51ay9cclxuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqL1xyXG5cclxuVEhSRUUuVmVjdG9yNCA9IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcclxuXHJcbiAgICB0aGlzLnggPSB4IHx8IDA7XHJcbiAgICB0aGlzLnkgPSB5IHx8IDA7XHJcbiAgICB0aGlzLnogPSB6IHx8IDA7XHJcbiAgICB0aGlzLncgPSAoIHcgIT09IHVuZGVmaW5lZCApID8gdyA6IDE7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVmVjdG9yNC5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLlZlY3RvcjQsXHJcblxyXG4gICAgc2V0OiBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB0aGlzLnogPSB6O1xyXG4gICAgICAgIHRoaXMudyA9IHc7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0WDogZnVuY3Rpb24gKCB4ICkge1xyXG5cclxuICAgICAgICB0aGlzLnggPSB4O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldFk6IGZ1bmN0aW9uICggeSApIHtcclxuXHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRaOiBmdW5jdGlvbiAoIHogKSB7XHJcblxyXG4gICAgICAgIHRoaXMueiA9IHo7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0VzogZnVuY3Rpb24gKCB3ICkge1xyXG5cclxuICAgICAgICB0aGlzLncgPSB3O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCwgdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIHN3aXRjaCAoIGluZGV4ICkge1xyXG5cclxuICAgICAgICAgICAgY2FzZSAwOiB0aGlzLnggPSB2YWx1ZTsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTogdGhpcy55ID0gdmFsdWU7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDI6IHRoaXMueiA9IHZhbHVlOyBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAzOiB0aGlzLncgPSB2YWx1ZTsgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCApIHtcclxuXHJcbiAgICAgICAgc3dpdGNoICggaW5kZXggKSB7XHJcblxyXG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiB0aGlzLng7XHJcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIHRoaXMueTtcclxuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gdGhpcy56O1xyXG4gICAgICAgICAgICBjYXNlIDM6IHJldHVybiB0aGlzLnc7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnksIHRoaXMueiwgdGhpcy53ICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHYueDtcclxuICAgICAgICB0aGlzLnkgPSB2Lnk7XHJcbiAgICAgICAgdGhpcy56ID0gdi56O1xyXG4gICAgICAgIHRoaXMudyA9ICggdi53ICE9PSB1bmRlZmluZWQgKSA/IHYudyA6IDE7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYWRkOiBmdW5jdGlvbiAoIHYsIHcgKSB7XHJcblxyXG4gICAgICAgIGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yNDogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkVmVjdG9ycyggdiwgdyApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMueCArPSB2Lng7XHJcbiAgICAgICAgdGhpcy55ICs9IHYueTtcclxuICAgICAgICB0aGlzLnogKz0gdi56O1xyXG4gICAgICAgIHRoaXMudyArPSB2Lnc7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCArPSBzO1xyXG4gICAgICAgIHRoaXMueSArPSBzO1xyXG4gICAgICAgIHRoaXMueiArPSBzO1xyXG4gICAgICAgIHRoaXMudyArPSBzO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFkZFZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gYS54ICsgYi54O1xyXG4gICAgICAgIHRoaXMueSA9IGEueSArIGIueTtcclxuICAgICAgICB0aGlzLnogPSBhLnogKyBiLno7XHJcbiAgICAgICAgdGhpcy53ID0gYS53ICsgYi53O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFkZFNjYWxlZFZlY3RvcjogZnVuY3Rpb24gKCB2LCBzICkge1xyXG5cclxuICAgICAgICB0aGlzLnggKz0gdi54ICogcztcclxuICAgICAgICB0aGlzLnkgKz0gdi55ICogcztcclxuICAgICAgICB0aGlzLnogKz0gdi56ICogcztcclxuICAgICAgICB0aGlzLncgKz0gdi53ICogcztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzdWI6IGZ1bmN0aW9uICggdiwgdyApIHtcclxuXHJcbiAgICAgICAgaWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3I0OiAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2LCB3ICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy54IC09IHYueDtcclxuICAgICAgICB0aGlzLnkgLT0gdi55O1xyXG4gICAgICAgIHRoaXMueiAtPSB2Lno7XHJcbiAgICAgICAgdGhpcy53IC09IHYudztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzdWJTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcclxuXHJcbiAgICAgICAgdGhpcy54IC09IHM7XHJcbiAgICAgICAgdGhpcy55IC09IHM7XHJcbiAgICAgICAgdGhpcy56IC09IHM7XHJcbiAgICAgICAgdGhpcy53IC09IHM7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuICAgICAgICB0aGlzLnggPSBhLnggLSBiLng7XHJcbiAgICAgICAgdGhpcy55ID0gYS55IC0gYi55O1xyXG4gICAgICAgIHRoaXMueiA9IGEueiAtIGIuejtcclxuICAgICAgICB0aGlzLncgPSBhLncgLSBiLnc7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuICAgICAgICBpZiAoIGlzRmluaXRlKCBzY2FsYXIgKSApIHtcclxuICAgICAgICAgICAgdGhpcy54ICo9IHNjYWxhcjtcclxuICAgICAgICAgICAgdGhpcy55ICo9IHNjYWxhcjtcclxuICAgICAgICAgICAgdGhpcy56ICo9IHNjYWxhcjtcclxuICAgICAgICAgICAgdGhpcy53ICo9IHNjYWxhcjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnkgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnogPSAwO1xyXG4gICAgICAgICAgICB0aGlzLncgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcbiAgICAgICAgdmFyIHggPSB0aGlzLng7XHJcbiAgICAgICAgdmFyIHkgPSB0aGlzLnk7XHJcbiAgICAgICAgdmFyIHogPSB0aGlzLno7XHJcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XHJcblxyXG4gICAgICAgIHZhciBlID0gbS5lbGVtZW50cztcclxuXHJcbiAgICAgICAgdGhpcy54ID0gZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gKiB6ICsgZVsgMTIgXSAqIHc7XHJcbiAgICAgICAgdGhpcy55ID0gZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gKiB6ICsgZVsgMTMgXSAqIHc7XHJcbiAgICAgICAgdGhpcy56ID0gZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF0gKiB3O1xyXG4gICAgICAgIHRoaXMudyA9IGVbIDMgXSAqIHggKyBlWyA3IF0gKiB5ICsgZVsgMTEgXSAqIHogKyBlWyAxNSBdICogdztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggMSAvIHNjYWxhciApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0QXhpc0FuZ2xlRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcclxuXHJcbiAgICAgICAgLy8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL3F1YXRlcm5pb25Ub0FuZ2xlL2luZGV4Lmh0bVxyXG5cclxuICAgICAgICAvLyBxIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxyXG5cclxuICAgICAgICB0aGlzLncgPSAyICogTWF0aC5hY29zKCBxLncgKTtcclxuXHJcbiAgICAgICAgdmFyIHMgPSBNYXRoLnNxcnQoIDEgLSBxLncgKiBxLncgKTtcclxuXHJcbiAgICAgICAgaWYgKCBzIDwgMC4wMDAxICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy54ID0gMTtcclxuICAgICAgICAgICAgdGhpcy55ID0gMDtcclxuICAgICAgICAgICAgdGhpcy56ID0gMDtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMueCA9IHEueCAvIHM7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHEueSAvIHM7XHJcbiAgICAgICAgICAgIHRoaXMueiA9IHEueiAvIHM7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRBeGlzQW5nbGVGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcbiAgICAgICAgLy8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvQW5nbGUvaW5kZXguaHRtXHJcblxyXG4gICAgICAgIC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXHJcblxyXG4gICAgICAgIHZhciBhbmdsZSwgeCwgeSwgeixcdFx0Ly8gdmFyaWFibGVzIGZvciByZXN1bHRcclxuICAgICAgICAgICAgZXBzaWxvbiA9IDAuMDEsXHRcdC8vIG1hcmdpbiB0byBhbGxvdyBmb3Igcm91bmRpbmcgZXJyb3JzXHJcbiAgICAgICAgICAgIGVwc2lsb24yID0gMC4xLFx0XHQvLyBtYXJnaW4gdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiAwIGFuZCAxODAgZGVncmVlc1xyXG5cclxuICAgICAgICAgICAgdGUgPSBtLmVsZW1lbnRzLFxyXG5cclxuICAgICAgICAgICAgbTExID0gdGVbIDAgXSwgbTEyID0gdGVbIDQgXSwgbTEzID0gdGVbIDggXSxcclxuICAgICAgICAgICAgbTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXSxcclxuICAgICAgICAgICAgbTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF07XHJcblxyXG4gICAgICAgIGlmICggKCBNYXRoLmFicyggbTEyIC0gbTIxICkgPCBlcHNpbG9uIClcclxuICAgICAgICAgICAgJiYgKCBNYXRoLmFicyggbTEzIC0gbTMxICkgPCBlcHNpbG9uIClcclxuICAgICAgICAgICAgJiYgKCBNYXRoLmFicyggbTIzIC0gbTMyICkgPCBlcHNpbG9uICkgKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBzaW5ndWxhcml0eSBmb3VuZFxyXG4gICAgICAgICAgICAvLyBmaXJzdCBjaGVjayBmb3IgaWRlbnRpdHkgbWF0cml4IHdoaWNoIG11c3QgaGF2ZSArMSBmb3IgYWxsIHRlcm1zXHJcbiAgICAgICAgICAgIC8vIGluIGxlYWRpbmcgZGlhZ29uYWwgYW5kIHplcm8gaW4gb3RoZXIgdGVybXNcclxuXHJcbiAgICAgICAgICAgIGlmICggKCBNYXRoLmFicyggbTEyICsgbTIxICkgPCBlcHNpbG9uMiApXHJcbiAgICAgICAgICAgICAgICAmJiAoIE1hdGguYWJzKCBtMTMgKyBtMzEgKSA8IGVwc2lsb24yIClcclxuICAgICAgICAgICAgICAgICYmICggTWF0aC5hYnMoIG0yMyArIG0zMiApIDwgZXBzaWxvbjIgKVxyXG4gICAgICAgICAgICAgICAgJiYgKCBNYXRoLmFicyggbTExICsgbTIyICsgbTMzIC0gMyApIDwgZXBzaWxvbjIgKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHNpbmd1bGFyaXR5IGlzIGlkZW50aXR5IG1hdHJpeCBzbyBhbmdsZSA9IDBcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldCggMSwgMCwgMCwgMCApO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyB6ZXJvIGFuZ2xlLCBhcmJpdHJhcnkgYXhpc1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHRoaXMgc2luZ3VsYXJpdHkgaXMgYW5nbGUgPSAxODBcclxuXHJcbiAgICAgICAgICAgIGFuZ2xlID0gTWF0aC5QSTtcclxuXHJcbiAgICAgICAgICAgIHZhciB4eCA9ICggbTExICsgMSApIC8gMjtcclxuICAgICAgICAgICAgdmFyIHl5ID0gKCBtMjIgKyAxICkgLyAyO1xyXG4gICAgICAgICAgICB2YXIgenogPSAoIG0zMyArIDEgKSAvIDI7XHJcbiAgICAgICAgICAgIHZhciB4eSA9ICggbTEyICsgbTIxICkgLyA0O1xyXG4gICAgICAgICAgICB2YXIgeHogPSAoIG0xMyArIG0zMSApIC8gNDtcclxuICAgICAgICAgICAgdmFyIHl6ID0gKCBtMjMgKyBtMzIgKSAvIDQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoICggeHggPiB5eSApICYmICggeHggPiB6eiApICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG0xMSBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCB4eCA8IGVwc2lsb24gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSAwLjcwNzEwNjc4MTtcclxuICAgICAgICAgICAgICAgICAgICB6ID0gMC43MDcxMDY3ODE7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IE1hdGguc3FydCggeHggKTtcclxuICAgICAgICAgICAgICAgICAgICB5ID0geHkgLyB4O1xyXG4gICAgICAgICAgICAgICAgICAgIHogPSB4eiAvIHg7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSBlbHNlIGlmICggeXkgPiB6eiApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBtMjIgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICggeXkgPCBlcHNpbG9uICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB4ID0gMC43MDcxMDY3ODE7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgeiA9IDAuNzA3MTA2NzgxO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHkgPSBNYXRoLnNxcnQoIHl5ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IHh5IC8geTtcclxuICAgICAgICAgICAgICAgICAgICB6ID0geXogLyB5O1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbTMzIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm0gc28gYmFzZSByZXN1bHQgb24gdGhpc1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggenogPCBlcHNpbG9uICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB4ID0gMC43MDcxMDY3ODE7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IDAuNzA3MTA2NzgxO1xyXG4gICAgICAgICAgICAgICAgICAgIHogPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHogPSBNYXRoLnNxcnQoIHp6ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IHh6IC8gejtcclxuICAgICAgICAgICAgICAgICAgICB5ID0geXogLyB6O1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2V0KCB4LCB5LCB6LCBhbmdsZSApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIHJldHVybiAxODAgZGVnIHJvdGF0aW9uXHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYXMgd2UgaGF2ZSByZWFjaGVkIGhlcmUgdGhlcmUgYXJlIG5vIHNpbmd1bGFyaXRpZXMgc28gd2UgY2FuIGhhbmRsZSBub3JtYWxseVxyXG5cclxuICAgICAgICB2YXIgcyA9IE1hdGguc3FydCggKCBtMzIgLSBtMjMgKSAqICggbTMyIC0gbTIzIClcclxuICAgICAgICAgICAgKyAoIG0xMyAtIG0zMSApICogKCBtMTMgLSBtMzEgKVxyXG4gICAgICAgICAgICArICggbTIxIC0gbTEyICkgKiAoIG0yMSAtIG0xMiApICk7IC8vIHVzZWQgdG8gbm9ybWFsaXplXHJcblxyXG4gICAgICAgIGlmICggTWF0aC5hYnMoIHMgKSA8IDAuMDAxICkgcyA9IDE7XHJcblxyXG4gICAgICAgIC8vIHByZXZlbnQgZGl2aWRlIGJ5IHplcm8sIHNob3VsZCBub3QgaGFwcGVuIGlmIG1hdHJpeCBpcyBvcnRob2dvbmFsIGFuZCBzaG91bGQgYmVcclxuICAgICAgICAvLyBjYXVnaHQgYnkgc2luZ3VsYXJpdHkgdGVzdCBhYm92ZSwgYnV0IEkndmUgbGVmdCBpdCBpbiBqdXN0IGluIGNhc2VcclxuXHJcbiAgICAgICAgdGhpcy54ID0gKCBtMzIgLSBtMjMgKSAvIHM7XHJcbiAgICAgICAgdGhpcy55ID0gKCBtMTMgLSBtMzEgKSAvIHM7XHJcbiAgICAgICAgdGhpcy56ID0gKCBtMjEgLSBtMTIgKSAvIHM7XHJcbiAgICAgICAgdGhpcy53ID0gTWF0aC5hY29zKCAoIG0xMSArIG0yMiArIG0zMyAtIDEgKSAvIDIgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBtaW46IGZ1bmN0aW9uICggdiApIHtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gTWF0aC5taW4oIHRoaXMueCwgdi54ICk7XHJcbiAgICAgICAgdGhpcy55ID0gTWF0aC5taW4oIHRoaXMueSwgdi55ICk7XHJcbiAgICAgICAgdGhpcy56ID0gTWF0aC5taW4oIHRoaXMueiwgdi56ICk7XHJcbiAgICAgICAgdGhpcy53ID0gTWF0aC5taW4oIHRoaXMudywgdi53ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbWF4OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IE1hdGgubWF4KCB0aGlzLngsIHYueCApO1xyXG4gICAgICAgIHRoaXMueSA9IE1hdGgubWF4KCB0aGlzLnksIHYueSApO1xyXG4gICAgICAgIHRoaXMueiA9IE1hdGgubWF4KCB0aGlzLnosIHYueiApO1xyXG4gICAgICAgIHRoaXMudyA9IE1hdGgubWF4KCB0aGlzLncsIHYudyApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNsYW1wOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xyXG5cclxuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgbWluIDwgbWF4LCBpZiB0aGlzIGFzc3VtcHRpb24gaXNuJ3QgdHJ1ZSBpdCB3aWxsIG5vdCBvcGVyYXRlIGNvcnJlY3RseVxyXG5cclxuICAgICAgICB0aGlzLnggPSBNYXRoLm1heCggbWluLngsIE1hdGgubWluKCBtYXgueCwgdGhpcy54ICkgKTtcclxuICAgICAgICB0aGlzLnkgPSBNYXRoLm1heCggbWluLnksIE1hdGgubWluKCBtYXgueSwgdGhpcy55ICkgKTtcclxuICAgICAgICB0aGlzLnogPSBNYXRoLm1heCggbWluLnosIE1hdGgubWluKCBtYXgueiwgdGhpcy56ICkgKTtcclxuICAgICAgICB0aGlzLncgPSBNYXRoLm1heCggbWluLncsIE1hdGgubWluKCBtYXgudywgdGhpcy53ICkgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjbGFtcFNjYWxhcjogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgbWluLCBtYXg7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjbGFtcFNjYWxhciggbWluVmFsLCBtYXhWYWwgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG1pbiA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIG1pbiA9IG5ldyBUSFJFRS5WZWN0b3I0KCk7XHJcbiAgICAgICAgICAgICAgICBtYXggPSBuZXcgVEhSRUUuVmVjdG9yNCgpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbWluLnNldCggbWluVmFsLCBtaW5WYWwsIG1pblZhbCwgbWluVmFsICk7XHJcbiAgICAgICAgICAgIG1heC5zZXQoIG1heFZhbCwgbWF4VmFsLCBtYXhWYWwsIG1heFZhbCApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xhbXAoIG1pbiwgbWF4ICk7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIGZsb29yOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xyXG4gICAgICAgIHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xyXG4gICAgICAgIHRoaXMueiA9IE1hdGguZmxvb3IoIHRoaXMueiApO1xyXG4gICAgICAgIHRoaXMudyA9IE1hdGguZmxvb3IoIHRoaXMudyApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNlaWw6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gTWF0aC5jZWlsKCB0aGlzLnggKTtcclxuICAgICAgICB0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xyXG4gICAgICAgIHRoaXMueiA9IE1hdGguY2VpbCggdGhpcy56ICk7XHJcbiAgICAgICAgdGhpcy53ID0gTWF0aC5jZWlsKCB0aGlzLncgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICByb3VuZDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0aGlzLnggPSBNYXRoLnJvdW5kKCB0aGlzLnggKTtcclxuICAgICAgICB0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcclxuICAgICAgICB0aGlzLnogPSBNYXRoLnJvdW5kKCB0aGlzLnogKTtcclxuICAgICAgICB0aGlzLncgPSBNYXRoLnJvdW5kKCB0aGlzLncgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICByb3VuZFRvWmVybzogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0aGlzLnggPSAoIHRoaXMueCA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy54ICkgOiBNYXRoLmZsb29yKCB0aGlzLnggKTtcclxuICAgICAgICB0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcclxuICAgICAgICB0aGlzLnogPSAoIHRoaXMueiA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy56ICkgOiBNYXRoLmZsb29yKCB0aGlzLnogKTtcclxuICAgICAgICB0aGlzLncgPSAoIHRoaXMudyA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy53ICkgOiBNYXRoLmZsb29yKCB0aGlzLncgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBuZWdhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gLSB0aGlzLng7XHJcbiAgICAgICAgdGhpcy55ID0gLSB0aGlzLnk7XHJcbiAgICAgICAgdGhpcy56ID0gLSB0aGlzLno7XHJcbiAgICAgICAgdGhpcy53ID0gLSB0aGlzLnc7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZG90OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2LnkgKyB0aGlzLnogKiB2LnogKyB0aGlzLncgKiB2Lnc7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICsgdGhpcy53ICogdGhpcy53O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbGVuZ3RoTWFuaGF0dGFuOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICkgKyBNYXRoLmFicyggdGhpcy56ICkgKyBNYXRoLmFicyggdGhpcy53ICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRMZW5ndGg6IGZ1bmN0aW9uICggbGVuZ3RoICkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggbGVuZ3RoIC8gdGhpcy5sZW5ndGgoKSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbGVycDogZnVuY3Rpb24gKCB2LCBhbHBoYSApIHtcclxuXHJcbiAgICAgICAgdGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcclxuICAgICAgICB0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xyXG4gICAgICAgIHRoaXMueiArPSAoIHYueiAtIHRoaXMueiApICogYWxwaGE7XHJcbiAgICAgICAgdGhpcy53ICs9ICggdi53IC0gdGhpcy53ICkgKiBhbHBoYTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBsZXJwVmVjdG9yczogZnVuY3Rpb24gKCB2MSwgdjIsIGFscGhhICkge1xyXG5cclxuICAgICAgICB0aGlzLnN1YlZlY3RvcnMoIHYyLCB2MSApLm11bHRpcGx5U2NhbGFyKCBhbHBoYSApLmFkZCggdjEgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBlcXVhbHM6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSAmJiAoIHYueiA9PT0gdGhpcy56ICkgJiYgKCB2LncgPT09IHRoaXMudyApICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcbiAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IGFycmF5WyBvZmZzZXQgXTtcclxuICAgICAgICB0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xyXG4gICAgICAgIHRoaXMueiA9IGFycmF5WyBvZmZzZXQgKyAyIF07XHJcbiAgICAgICAgdGhpcy53ID0gYXJyYXlbIG9mZnNldCArIDMgXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG4gICAgICAgIGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XHJcbiAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcclxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy55O1xyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLno7XHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDMgXSA9IHRoaXMudztcclxuXHJcbiAgICAgICAgcmV0dXJuIGFycmF5O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZnJvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XHJcblxyXG4gICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuICAgICAgICBpbmRleCA9IGluZGV4ICogYXR0cmlidXRlLml0ZW1TaXplICsgb2Zmc2V0O1xyXG5cclxuICAgICAgICB0aGlzLnggPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4IF07XHJcbiAgICAgICAgdGhpcy55ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCArIDEgXTtcclxuICAgICAgICB0aGlzLnogPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4ICsgMiBdO1xyXG4gICAgICAgIHRoaXMudyA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAzIF07XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL0V1bGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICovXHJcblxyXG5USFJFRS5FdWxlciA9IGZ1bmN0aW9uICggeCwgeSwgeiwgb3JkZXIgKSB7XHJcblxyXG4gICAgdGhpcy5feCA9IHggfHwgMDtcclxuICAgIHRoaXMuX3kgPSB5IHx8IDA7XHJcbiAgICB0aGlzLl96ID0geiB8fCAwO1xyXG4gICAgdGhpcy5fb3JkZXIgPSBvcmRlciB8fCBUSFJFRS5FdWxlci5EZWZhdWx0T3JkZXI7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRXVsZXIuUm90YXRpb25PcmRlcnMgPSBbICdYWVonLCAnWVpYJywgJ1pYWScsICdYWlknLCAnWVhaJywgJ1pZWCcgXTtcclxuXHJcblRIUkVFLkV1bGVyLkRlZmF1bHRPcmRlciA9ICdYWVonO1xyXG5cclxuVEhSRUUuRXVsZXIucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5FdWxlcixcclxuXHJcbiAgICBnZXQgeCAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLl94O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0IHggKCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5feCA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0IHkgKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5feTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldCB5ICggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuX3kgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldCB6ICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3o7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXQgeiAoIHZhbHVlICkge1xyXG5cclxuICAgICAgICB0aGlzLl96ID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXQgb3JkZXIgKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5fb3JkZXI7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXQgb3JkZXIgKCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5fb3JkZXIgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldDogZnVuY3Rpb24gKCB4LCB5LCB6LCBvcmRlciApIHtcclxuXHJcbiAgICAgICAgdGhpcy5feCA9IHg7XHJcbiAgICAgICAgdGhpcy5feSA9IHk7XHJcbiAgICAgICAgdGhpcy5feiA9IHo7XHJcbiAgICAgICAgdGhpcy5fb3JkZXIgPSBvcmRlciB8fCB0aGlzLl9vcmRlcjtcclxuXHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl9vcmRlcik7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb3B5OiBmdW5jdGlvbiAoIGV1bGVyICkge1xyXG5cclxuICAgICAgICB0aGlzLl94ID0gZXVsZXIuX3g7XHJcbiAgICAgICAgdGhpcy5feSA9IGV1bGVyLl95O1xyXG4gICAgICAgIHRoaXMuX3ogPSBldWxlci5fejtcclxuICAgICAgICB0aGlzLl9vcmRlciA9IGV1bGVyLl9vcmRlcjtcclxuXHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0RnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoIG0sIG9yZGVyLCB1cGRhdGUgKSB7XHJcblxyXG4gICAgICAgIHZhciBjbGFtcCA9IFRIUkVFLk1hdGguY2xhbXA7XHJcblxyXG4gICAgICAgIC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXHJcblxyXG4gICAgICAgIHZhciB0ZSA9IG0uZWxlbWVudHM7XHJcbiAgICAgICAgdmFyIG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF07XHJcbiAgICAgICAgdmFyIG0yMSA9IHRlWyAxIF0sIG0yMiA9IHRlWyA1IF0sIG0yMyA9IHRlWyA5IF07XHJcbiAgICAgICAgdmFyIG0zMSA9IHRlWyAyIF0sIG0zMiA9IHRlWyA2IF0sIG0zMyA9IHRlWyAxMCBdO1xyXG5cclxuICAgICAgICBvcmRlciA9IG9yZGVyIHx8IHRoaXMuX29yZGVyO1xyXG5cclxuICAgICAgICBpZiAoIG9yZGVyID09PSAnWFlaJyApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3kgPSBNYXRoLmFzaW4oIGNsYW1wKCBtMTMsIC0gMSwgMSApICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIE1hdGguYWJzKCBtMTMgKSA8IDAuOTk5OTkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMzMgKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTExICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0yMiApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5feiA9IDA7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVhaJyApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3ggPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0yMywgLSAxLCAxICkgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggTWF0aC5hYnMoIG0yMyApIDwgMC45OTk5OSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0yMiApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0xMSApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5feiA9IDA7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWlhZJyApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3ggPSBNYXRoLmFzaW4oIGNsYW1wKCBtMzIsIC0gMSwgMSApICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIE1hdGguYWJzKCBtMzIgKSA8IDAuOTk5OTkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMzMgKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTIyICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTExICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWllYJyApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3kgPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0zMSwgLSAxLCAxICkgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggTWF0aC5hYnMoIG0zMSApIDwgMC45OTk5OSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMzMgKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0xMSApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl94ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTIyICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVpYJyApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3ogPSBNYXRoLmFzaW4oIGNsYW1wKCBtMjEsIC0gMSwgMSApICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIE1hdGguYWJzKCBtMjEgKSA8IDAuOTk5OTkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMjIgKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTExICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTMzICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWFpZJyApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3ogPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0xMiwgLSAxLCAxICkgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggTWF0aC5hYnMoIG0xMiApIDwgMC45OTk5OSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMjIgKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSBNYXRoLmF0YW4yKCBtMTMsIG0xMSApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0zMyApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5feSA9IDA7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5FdWxlcjogLnNldEZyb21Sb3RhdGlvbk1hdHJpeCgpIGdpdmVuIHVuc3VwcG9ydGVkIG9yZGVyOiAnICsgb3JkZXIgKVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX29yZGVyID0gb3JkZXI7XHJcblxyXG4gICAgICAgIGlmICggdXBkYXRlICE9PSBmYWxzZSApIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBtYXRyaXg7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIHEsIG9yZGVyLCB1cGRhdGUgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG1hdHJpeCA9PT0gdW5kZWZpbmVkICkgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuICAgICAgICAgICAgbWF0cml4Lm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxICk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtYXRyaXgsIG9yZGVyLCB1cGRhdGUgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBzZXRGcm9tVmVjdG9yMzogZnVuY3Rpb24gKCB2LCBvcmRlciApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KCB2LngsIHYueSwgdi56LCBvcmRlciB8fCB0aGlzLl9vcmRlciApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcmVvcmRlcjogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAvLyBXQVJOSU5HOiB0aGlzIGRpc2NhcmRzIHJldm9sdXRpb24gaW5mb3JtYXRpb24gLWJob3VzdG9uXHJcblxyXG4gICAgICAgIHZhciBxID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggbmV3T3JkZXIgKSB7XHJcblxyXG4gICAgICAgICAgICBxLnNldEZyb21FdWxlciggdGhpcyApO1xyXG4gICAgICAgICAgICB0aGlzLnNldEZyb21RdWF0ZXJuaW9uKCBxLCBuZXdPcmRlciApO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBlcXVhbHM6IGZ1bmN0aW9uICggZXVsZXIgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiAoIGV1bGVyLl94ID09PSB0aGlzLl94ICkgJiYgKCBldWxlci5feSA9PT0gdGhpcy5feSApICYmICggZXVsZXIuX3ogPT09IHRoaXMuX3ogKSAmJiAoIGV1bGVyLl9vcmRlciA9PT0gdGhpcy5fb3JkZXIgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5feCA9IGFycmF5WyAwIF07XHJcbiAgICAgICAgdGhpcy5feSA9IGFycmF5WyAxIF07XHJcbiAgICAgICAgdGhpcy5feiA9IGFycmF5WyAyIF07XHJcbiAgICAgICAgaWYgKCBhcnJheVsgMyBdICE9PSB1bmRlZmluZWQgKSB0aGlzLl9vcmRlciA9IGFycmF5WyAzIF07XHJcblxyXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcbiAgICAgICAgaWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcclxuICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCBdID0gdGhpcy5feDtcclxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy5feTtcclxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5fejtcclxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy5fb3JkZXI7XHJcblxyXG4gICAgICAgIHJldHVybiBhcnJheTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRvVmVjdG9yMzogZnVuY3Rpb24gKCBvcHRpb25hbFJlc3VsdCApIHtcclxuXHJcbiAgICAgICAgaWYgKCBvcHRpb25hbFJlc3VsdCApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25hbFJlc3VsdC5zZXQoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3ogKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBvbkNoYW5nZTogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcclxuXHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgb25DaGFuZ2VDYWxsYmFjazogZnVuY3Rpb24gKCkge31cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL0xpbmUzLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG4gKi9cclxuXHJcblRIUkVFLkxpbmUzID0gZnVuY3Rpb24gKCBzdGFydCwgZW5kICkge1xyXG5cclxuICAgIHRoaXMuc3RhcnQgPSAoIHN0YXJ0ICE9PSB1bmRlZmluZWQgKSA/IHN0YXJ0IDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgIHRoaXMuZW5kID0gKCBlbmQgIT09IHVuZGVmaW5lZCApID8gZW5kIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5MaW5lMy5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkxpbmUzLFxyXG5cclxuICAgIHNldDogZnVuY3Rpb24gKCBzdGFydCwgZW5kICkge1xyXG5cclxuICAgICAgICB0aGlzLnN0YXJ0LmNvcHkoIHN0YXJ0ICk7XHJcbiAgICAgICAgdGhpcy5lbmQuY29weSggZW5kICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29weTogZnVuY3Rpb24gKCBsaW5lICkge1xyXG5cclxuICAgICAgICB0aGlzLnN0YXJ0LmNvcHkoIGxpbmUuc3RhcnQgKTtcclxuICAgICAgICB0aGlzLmVuZC5jb3B5KCBsaW5lLmVuZCApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNlbnRlcjogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRlbHRhOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0LnN1YlZlY3RvcnMoIHRoaXMuZW5kLCB0aGlzLnN0YXJ0ICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBkaXN0YW5jZVNxOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0LmRpc3RhbmNlVG9TcXVhcmVkKCB0aGlzLmVuZCApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZGlzdGFuY2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQuZGlzdGFuY2VUbyggdGhpcy5lbmQgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGF0OiBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsdGEoIHJlc3VsdCApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLnN0YXJ0ICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjbG9zZXN0UG9pbnRUb1BvaW50UGFyYW1ldGVyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBzdGFydFAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgIHZhciBzdGFydEVuZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIHBvaW50LCBjbGFtcFRvTGluZSApIHtcclxuXHJcbiAgICAgICAgICAgIHN0YXJ0UC5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5zdGFydCApO1xyXG4gICAgICAgICAgICBzdGFydEVuZC5zdWJWZWN0b3JzKCB0aGlzLmVuZCwgdGhpcy5zdGFydCApO1xyXG5cclxuICAgICAgICAgICAgdmFyIHN0YXJ0RW5kMiA9IHN0YXJ0RW5kLmRvdCggc3RhcnRFbmQgKTtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0RW5kX3N0YXJ0UCA9IHN0YXJ0RW5kLmRvdCggc3RhcnRQICk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdCA9IHN0YXJ0RW5kX3N0YXJ0UCAvIHN0YXJ0RW5kMjtcclxuXHJcbiAgICAgICAgICAgIGlmICggY2xhbXBUb0xpbmUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdCA9IFRIUkVFLk1hdGguY2xhbXAoIHQsIDAsIDEgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0O1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBjbG9zZXN0UG9pbnRUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBjbGFtcFRvTGluZSwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG4gICAgICAgIHZhciB0ID0gdGhpcy5jbG9zZXN0UG9pbnRUb1BvaW50UGFyYW1ldGVyKCBwb2ludCwgY2xhbXBUb0xpbmUgKTtcclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmRlbHRhKCByZXN1bHQgKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy5zdGFydCApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcclxuXHJcbiAgICAgICAgdGhpcy5zdGFydC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xyXG4gICAgICAgIHRoaXMuZW5kLmFwcGx5TWF0cml4NCggbWF0cml4ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZXF1YWxzOiBmdW5jdGlvbiAoIGxpbmUgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBsaW5lLnN0YXJ0LmVxdWFscyggdGhpcy5zdGFydCApICYmIGxpbmUuZW5kLmVxdWFscyggdGhpcy5lbmQgKTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9Cb3gyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG4gKi9cclxuXHJcblRIUkVFLkJveDIgPSBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xyXG5cclxuICAgIHRoaXMubWluID0gKCBtaW4gIT09IHVuZGVmaW5lZCApID8gbWluIDogbmV3IFRIUkVFLlZlY3RvcjIoIEluZmluaXR5LCBJbmZpbml0eSApO1xyXG4gICAgdGhpcy5tYXggPSAoIG1heCAhPT0gdW5kZWZpbmVkICkgPyBtYXggOiBuZXcgVEhSRUUuVmVjdG9yMiggLSBJbmZpbml0eSwgLSBJbmZpbml0eSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkJveDIucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5Cb3gyLFxyXG5cclxuICAgIHNldDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcclxuXHJcbiAgICAgICAgdGhpcy5taW4uY29weSggbWluICk7XHJcbiAgICAgICAgdGhpcy5tYXguY29weSggbWF4ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0RnJvbVBvaW50czogZnVuY3Rpb24gKCBwb2ludHMgKSB7XHJcblxyXG4gICAgICAgIHRoaXMubWFrZUVtcHR5KCk7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmV4cGFuZEJ5UG9pbnQoIHBvaW50c1sgaSBdIClcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZyb21DZW50ZXJBbmRTaXplOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIGNlbnRlciwgc2l6ZSApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBoYWxmU2l6ZSA9IHYxLmNvcHkoIHNpemUgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XHJcbiAgICAgICAgICAgIHRoaXMubWluLmNvcHkoIGNlbnRlciApLnN1YiggaGFsZlNpemUgKTtcclxuICAgICAgICAgICAgdGhpcy5tYXguY29weSggY2VudGVyICkuYWRkKCBoYWxmU2l6ZSApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvcHk6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuICAgICAgICB0aGlzLm1pbi5jb3B5KCBib3gubWluICk7XHJcbiAgICAgICAgdGhpcy5tYXguY29weSggYm94Lm1heCApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG1ha2VFbXB0eTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0aGlzLm1pbi54ID0gdGhpcy5taW4ueSA9IEluZmluaXR5O1xyXG4gICAgICAgIHRoaXMubWF4LnggPSB0aGlzLm1heC55ID0gLSBJbmZpbml0eTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBlbXB0eTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAvLyB0aGlzIGlzIGEgbW9yZSByb2J1c3QgY2hlY2sgZm9yIGVtcHR5IHRoYW4gKCB2b2x1bWUgPD0gMCApIGJlY2F1c2Ugdm9sdW1lIGNhbiBnZXQgcG9zaXRpdmUgd2l0aCB0d28gbmVnYXRpdmUgYXhlc1xyXG5cclxuICAgICAgICByZXR1cm4gKCB0aGlzLm1heC54IDwgdGhpcy5taW4ueCApIHx8ICggdGhpcy5tYXgueSA8IHRoaXMubWluLnkgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNlbnRlcjogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLm1pbiwgdGhpcy5tYXggKS5tdWx0aXBseVNjYWxhciggMC41ICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzaXplOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0LnN1YlZlY3RvcnMoIHRoaXMubWF4LCB0aGlzLm1pbiApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZXhwYW5kQnlQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcbiAgICAgICAgdGhpcy5taW4ubWluKCBwb2ludCApO1xyXG4gICAgICAgIHRoaXMubWF4Lm1heCggcG9pbnQgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBleHBhbmRCeVZlY3RvcjogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG4gICAgICAgIHRoaXMubWluLnN1YiggdmVjdG9yICk7XHJcbiAgICAgICAgdGhpcy5tYXguYWRkKCB2ZWN0b3IgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBleHBhbmRCeVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XHJcblxyXG4gICAgICAgIHRoaXMubWluLmFkZFNjYWxhciggLSBzY2FsYXIgKTtcclxuICAgICAgICB0aGlzLm1heC5hZGRTY2FsYXIoIHNjYWxhciApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG4gICAgICAgIGlmICggcG9pbnQueCA8IHRoaXMubWluLnggfHwgcG9pbnQueCA+IHRoaXMubWF4LnggfHxcclxuICAgICAgICAgICAgcG9pbnQueSA8IHRoaXMubWluLnkgfHwgcG9pbnQueSA+IHRoaXMubWF4LnkgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb250YWluc0JveDogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG4gICAgICAgIGlmICggKCB0aGlzLm1pbi54IDw9IGJveC5taW4ueCApICYmICggYm94Lm1heC54IDw9IHRoaXMubWF4LnggKSAmJlxyXG4gICAgICAgICAgICAoIHRoaXMubWluLnkgPD0gYm94Lm1pbi55ICkgJiYgKCBib3gubWF4LnkgPD0gdGhpcy5tYXgueSApICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0UGFyYW1ldGVyOiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcbiAgICAgICAgLy8gVGhpcyBjYW4gcG90ZW50aWFsbHkgaGF2ZSBhIGRpdmlkZSBieSB6ZXJvIGlmIHRoZSBib3hcclxuICAgICAgICAvLyBoYXMgYSBzaXplIGRpbWVuc2lvbiBvZiAwLlxyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zZXQoXHJcbiAgICAgICAgICAgICggcG9pbnQueCAtIHRoaXMubWluLnggKSAvICggdGhpcy5tYXgueCAtIHRoaXMubWluLnggKSxcclxuICAgICAgICAgICAgKCBwb2ludC55IC0gdGhpcy5taW4ueSApIC8gKCB0aGlzLm1heC55IC0gdGhpcy5taW4ueSApXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGlzSW50ZXJzZWN0aW9uQm94OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcbiAgICAgICAgLy8gdXNpbmcgNiBzcGxpdHRpbmcgcGxhbmVzIHRvIHJ1bGUgb3V0IGludGVyc2VjdGlvbnMuXHJcblxyXG4gICAgICAgIGlmICggYm94Lm1heC54IDwgdGhpcy5taW4ueCB8fCBib3gubWluLnggPiB0aGlzLm1heC54IHx8XHJcbiAgICAgICAgICAgIGJveC5tYXgueSA8IHRoaXMubWluLnkgfHwgYm94Lm1pbi55ID4gdGhpcy5tYXgueSApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNsYW1wUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0LmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGNsYW1wZWRQb2ludCA9IHYxLmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xyXG4gICAgICAgICAgICByZXR1cm4gY2xhbXBlZFBvaW50LnN1YiggcG9pbnQgKS5sZW5ndGgoKTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgaW50ZXJzZWN0OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcbiAgICAgICAgdGhpcy5taW4ubWF4KCBib3gubWluICk7XHJcbiAgICAgICAgdGhpcy5tYXgubWluKCBib3gubWF4ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdW5pb246IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuICAgICAgICB0aGlzLm1pbi5taW4oIGJveC5taW4gKTtcclxuICAgICAgICB0aGlzLm1heC5tYXgoIGJveC5tYXggKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uICggb2Zmc2V0ICkge1xyXG5cclxuICAgICAgICB0aGlzLm1pbi5hZGQoIG9mZnNldCApO1xyXG4gICAgICAgIHRoaXMubWF4LmFkZCggb2Zmc2V0ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZXF1YWxzOiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIGJveC5taW4uZXF1YWxzKCB0aGlzLm1pbiApICYmIGJveC5tYXguZXF1YWxzKCB0aGlzLm1heCApO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL0JveDMuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKi9cclxuXHJcblRIUkVFLkJveDMgPSBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xyXG5cclxuICAgIHRoaXMubWluID0gKCBtaW4gIT09IHVuZGVmaW5lZCApID8gbWluIDogbmV3IFRIUkVFLlZlY3RvcjMoIEluZmluaXR5LCBJbmZpbml0eSwgSW5maW5pdHkgKTtcclxuICAgIHRoaXMubWF4ID0gKCBtYXggIT09IHVuZGVmaW5lZCApID8gbWF4IDogbmV3IFRIUkVFLlZlY3RvcjMoIC0gSW5maW5pdHksIC0gSW5maW5pdHksIC0gSW5maW5pdHkgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Cb3gzLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuQm94MyxcclxuXHJcbiAgICBzZXQ6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG4gICAgICAgIHRoaXMubWluLmNvcHkoIG1pbiApO1xyXG4gICAgICAgIHRoaXMubWF4LmNvcHkoIG1heCApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICggcG9pbnRzICkge1xyXG5cclxuICAgICAgICB0aGlzLm1ha2VFbXB0eSgpO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5leHBhbmRCeVBvaW50KCBwb2ludHNbIGkgXSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0RnJvbUNlbnRlckFuZFNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggY2VudGVyLCBzaXplICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGhhbGZTaXplID0gdjEuY29weSggc2l6ZSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubWluLmNvcHkoIGNlbnRlciApLnN1YiggaGFsZlNpemUgKTtcclxuICAgICAgICAgICAgdGhpcy5tYXguY29weSggY2VudGVyICkuYWRkKCBoYWxmU2l6ZSApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIHNldEZyb21PYmplY3Q6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgLy8gQ29tcHV0ZXMgdGhlIHdvcmxkLWF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggb2YgYW4gb2JqZWN0IChpbmNsdWRpbmcgaXRzIGNoaWxkcmVuKSxcclxuICAgICAgICAvLyBhY2NvdW50aW5nIGZvciBib3RoIHRoZSBvYmplY3QncywgYW5kIGNoaWxkcmVuJ3MsIHdvcmxkIHRyYW5zZm9ybXNcclxuXHJcbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIG9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5tYWtlRW1wdHkoKTtcclxuXHJcbiAgICAgICAgICAgIG9iamVjdC50cmF2ZXJzZSggZnVuY3Rpb24gKCBub2RlICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBnZW9tZXRyeSA9IG5vZGUuZ2VvbWV0cnk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MS5jb3B5KCB2ZXJ0aWNlc1sgaSBdICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjEuYXBwbHlNYXRyaXg0KCBub2RlLm1hdHJpeFdvcmxkICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuZXhwYW5kQnlQb2ludCggdjEgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSAmJiBnZW9tZXRyeS5hdHRyaWJ1dGVzWyAncG9zaXRpb24nIF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbnMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzWyAncG9zaXRpb24nIF0uYXJyYXk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjEuc2V0KCBwb3NpdGlvbnNbIGkgXSwgcG9zaXRpb25zWyBpICsgMSBdLCBwb3NpdGlvbnNbIGkgKyAyIF0gKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MS5hcHBseU1hdHJpeDQoIG5vZGUubWF0cml4V29ybGQgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5leHBhbmRCeVBvaW50KCB2MSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvcHk6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuICAgICAgICB0aGlzLm1pbi5jb3B5KCBib3gubWluICk7XHJcbiAgICAgICAgdGhpcy5tYXguY29weSggYm94Lm1heCApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG1ha2VFbXB0eTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0aGlzLm1pbi54ID0gdGhpcy5taW4ueSA9IHRoaXMubWluLnogPSBJbmZpbml0eTtcclxuICAgICAgICB0aGlzLm1heC54ID0gdGhpcy5tYXgueSA9IHRoaXMubWF4LnogPSAtIEluZmluaXR5O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGVtcHR5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIC8vIHRoaXMgaXMgYSBtb3JlIHJvYnVzdCBjaGVjayBmb3IgZW1wdHkgdGhhbiAoIHZvbHVtZSA8PSAwICkgYmVjYXVzZSB2b2x1bWUgY2FuIGdldCBwb3NpdGl2ZSB3aXRoIHR3byBuZWdhdGl2ZSBheGVzXHJcblxyXG4gICAgICAgIHJldHVybiAoIHRoaXMubWF4LnggPCB0aGlzLm1pbi54ICkgfHwgKCB0aGlzLm1heC55IDwgdGhpcy5taW4ueSApIHx8ICggdGhpcy5tYXgueiA8IHRoaXMubWluLnogKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNlbnRlcjogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLm1pbiwgdGhpcy5tYXggKS5tdWx0aXBseVNjYWxhciggMC41ICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzaXplOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0LnN1YlZlY3RvcnMoIHRoaXMubWF4LCB0aGlzLm1pbiApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZXhwYW5kQnlQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcbiAgICAgICAgdGhpcy5taW4ubWluKCBwb2ludCApO1xyXG4gICAgICAgIHRoaXMubWF4Lm1heCggcG9pbnQgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBleHBhbmRCeVZlY3RvcjogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG4gICAgICAgIHRoaXMubWluLnN1YiggdmVjdG9yICk7XHJcbiAgICAgICAgdGhpcy5tYXguYWRkKCB2ZWN0b3IgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBleHBhbmRCeVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XHJcblxyXG4gICAgICAgIHRoaXMubWluLmFkZFNjYWxhciggLSBzY2FsYXIgKTtcclxuICAgICAgICB0aGlzLm1heC5hZGRTY2FsYXIoIHNjYWxhciApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG4gICAgICAgIGlmICggcG9pbnQueCA8IHRoaXMubWluLnggfHwgcG9pbnQueCA+IHRoaXMubWF4LnggfHxcclxuICAgICAgICAgICAgcG9pbnQueSA8IHRoaXMubWluLnkgfHwgcG9pbnQueSA+IHRoaXMubWF4LnkgfHxcclxuICAgICAgICAgICAgcG9pbnQueiA8IHRoaXMubWluLnogfHwgcG9pbnQueiA+IHRoaXMubWF4LnogKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb250YWluc0JveDogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG4gICAgICAgIGlmICggKCB0aGlzLm1pbi54IDw9IGJveC5taW4ueCApICYmICggYm94Lm1heC54IDw9IHRoaXMubWF4LnggKSAmJlxyXG4gICAgICAgICAgICAoIHRoaXMubWluLnkgPD0gYm94Lm1pbi55ICkgJiYgKCBib3gubWF4LnkgPD0gdGhpcy5tYXgueSApICYmXHJcbiAgICAgICAgICAgICggdGhpcy5taW4ueiA8PSBib3gubWluLnogKSAmJiAoIGJveC5tYXgueiA8PSB0aGlzLm1heC56ICkgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRQYXJhbWV0ZXI6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuICAgICAgICAvLyBUaGlzIGNhbiBwb3RlbnRpYWxseSBoYXZlIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIGJveFxyXG4gICAgICAgIC8vIGhhcyBhIHNpemUgZGltZW5zaW9uIG9mIDAuXHJcblxyXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0LnNldChcclxuICAgICAgICAgICAgKCBwb2ludC54IC0gdGhpcy5taW4ueCApIC8gKCB0aGlzLm1heC54IC0gdGhpcy5taW4ueCApLFxyXG4gICAgICAgICAgICAoIHBvaW50LnkgLSB0aGlzLm1pbi55ICkgLyAoIHRoaXMubWF4LnkgLSB0aGlzLm1pbi55ICksXHJcbiAgICAgICAgICAgICggcG9pbnQueiAtIHRoaXMubWluLnogKSAvICggdGhpcy5tYXgueiAtIHRoaXMubWluLnogKVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBpc0ludGVyc2VjdGlvbkJveDogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG4gICAgICAgIC8vIHVzaW5nIDYgc3BsaXR0aW5nIHBsYW5lcyB0byBydWxlIG91dCBpbnRlcnNlY3Rpb25zLlxyXG5cclxuICAgICAgICBpZiAoIGJveC5tYXgueCA8IHRoaXMubWluLnggfHwgYm94Lm1pbi54ID4gdGhpcy5tYXgueCB8fFxyXG4gICAgICAgICAgICBib3gubWF4LnkgPCB0aGlzLm1pbi55IHx8IGJveC5taW4ueSA+IHRoaXMubWF4LnkgfHxcclxuICAgICAgICAgICAgYm94Lm1heC56IDwgdGhpcy5taW4ueiB8fCBib3gubWluLnogPiB0aGlzLm1heC56ICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2xhbXBQb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgY2xhbXBlZFBvaW50ID0gdjEuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XHJcbiAgICAgICAgICAgIHJldHVybiBjbGFtcGVkUG9pbnQuc3ViKCBwb2ludCApLmxlbmd0aCgpO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBnZXRCb3VuZGluZ1NwaGVyZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuU3BoZXJlKCk7XHJcblxyXG4gICAgICAgICAgICByZXN1bHQuY2VudGVyID0gdGhpcy5jZW50ZXIoKTtcclxuICAgICAgICAgICAgcmVzdWx0LnJhZGl1cyA9IHRoaXMuc2l6ZSggdjEgKS5sZW5ndGgoKSAqIDAuNTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIGludGVyc2VjdDogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG4gICAgICAgIHRoaXMubWluLm1heCggYm94Lm1pbiApO1xyXG4gICAgICAgIHRoaXMubWF4Lm1pbiggYm94Lm1heCApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHVuaW9uOiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcbiAgICAgICAgdGhpcy5taW4ubWluKCBib3gubWluICk7XHJcbiAgICAgICAgdGhpcy5tYXgubWF4KCBib3gubWF4ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBwb2ludHMgPSBbXHJcbiAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcbiAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcbiAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcbiAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcbiAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcbiAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcbiAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcbiAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKClcclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCBtYXRyaXggKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBOT1RFOiBJIGFtIHVzaW5nIGEgYmluYXJ5IHBhdHRlcm4gdG8gc3BlY2lmeSBhbGwgMl4zIGNvbWJpbmF0aW9ucyBiZWxvd1xyXG4gICAgICAgICAgICBwb2ludHNbIDAgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWluLnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMDBcclxuICAgICAgICAgICAgcG9pbnRzWyAxIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDAxXHJcbiAgICAgICAgICAgIHBvaW50c1sgMiBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5tYXgueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAxMFxyXG4gICAgICAgICAgICBwb2ludHNbIDMgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWF4LnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMTFcclxuICAgICAgICAgICAgcG9pbnRzWyA0IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTAwXHJcbiAgICAgICAgICAgIHBvaW50c1sgNSBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5taW4ueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDEwMVxyXG4gICAgICAgICAgICBwb2ludHNbIDYgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWF4LnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMTBcclxuICAgICAgICAgICAgcG9pbnRzWyA3IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1heC55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgIC8vIDExMVxyXG5cclxuICAgICAgICAgICAgdGhpcy5tYWtlRW1wdHkoKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uICggb2Zmc2V0ICkge1xyXG5cclxuICAgICAgICB0aGlzLm1pbi5hZGQoIG9mZnNldCApO1xyXG4gICAgICAgIHRoaXMubWF4LmFkZCggb2Zmc2V0ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZXF1YWxzOiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIGJveC5taW4uZXF1YWxzKCB0aGlzLm1pbiApICYmIGJveC5tYXguZXF1YWxzKCB0aGlzLm1heCApO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL01hdHJpeDMuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG4gKi9cclxuXHJcblRIUkVFLk1hdHJpeDMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdGhpcy5lbGVtZW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcclxuXHJcbiAgICAgICAgMSwgMCwgMCxcclxuICAgICAgICAwLCAxLCAwLFxyXG4gICAgICAgIDAsIDAsIDFcclxuXHJcbiAgICBdICk7XHJcblxyXG4gICAgaWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMCApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDM6IHRoZSBjb25zdHJ1Y3RvciBubyBsb25nZXIgcmVhZHMgYXJndW1lbnRzLiB1c2UgLnNldCgpIGluc3RlYWQuJyApO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5NYXRyaXgzLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuTWF0cml4MyxcclxuXHJcbiAgICBzZXQ6IGZ1bmN0aW9uICggbjExLCBuMTIsIG4xMywgbjIxLCBuMjIsIG4yMywgbjMxLCBuMzIsIG4zMyApIHtcclxuXHJcbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcbiAgICAgICAgdGVbIDAgXSA9IG4xMTsgdGVbIDMgXSA9IG4xMjsgdGVbIDYgXSA9IG4xMztcclxuICAgICAgICB0ZVsgMSBdID0gbjIxOyB0ZVsgNCBdID0gbjIyOyB0ZVsgNyBdID0gbjIzO1xyXG4gICAgICAgIHRlWyAyIF0gPSBuMzE7IHRlWyA1IF0gPSBuMzI7IHRlWyA4IF0gPSBuMzM7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgaWRlbnRpdHk6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdGhpcy5zZXQoXHJcblxyXG4gICAgICAgICAgICAxLCAwLCAwLFxyXG4gICAgICAgICAgICAwLCAxLCAwLFxyXG4gICAgICAgICAgICAwLCAwLCAxXHJcblxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuZnJvbUFycmF5KCB0aGlzLmVsZW1lbnRzICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb3B5OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG4gICAgICAgIHZhciBtZSA9IG0uZWxlbWVudHM7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0KFxyXG5cclxuICAgICAgICAgICAgbWVbIDAgXSwgbWVbIDMgXSwgbWVbIDYgXSxcclxuICAgICAgICAgICAgbWVbIDEgXSwgbWVbIDQgXSwgbWVbIDcgXSxcclxuICAgICAgICAgICAgbWVbIDIgXSwgbWVbIDUgXSwgbWVbIDggXVxyXG5cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG11bHRpcGx5VmVjdG9yMzogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDM6IC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4MyggbWF0cml4ICkgaW5zdGVhZC4nICk7XHJcbiAgICAgICAgcmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDMoIHRoaXMgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG11bHRpcGx5VmVjdG9yM0FycmF5OiBmdW5jdGlvbiAoIGEgKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDM6IC5tdWx0aXBseVZlY3RvcjNBcnJheSgpIGhhcyBiZWVuIHJlbmFtZWQuIFVzZSBtYXRyaXguYXBwbHlUb1ZlY3RvcjNBcnJheSggYXJyYXkgKSBpbnN0ZWFkLicgKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcHBseVRvVmVjdG9yM0FycmF5KCBhICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhcHBseVRvVmVjdG9yM0FycmF5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciB2MTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCwgbGVuZ3RoICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgaWYgKCBsZW5ndGggPT09IHVuZGVmaW5lZCApIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaiA9IG9mZnNldDsgaSA8IGxlbmd0aDsgaSArPSAzLCBqICs9IDMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdjEuZnJvbUFycmF5KCBhcnJheSwgaiApO1xyXG4gICAgICAgICAgICAgICAgdjEuYXBwbHlNYXRyaXgzKCB0aGlzICk7XHJcbiAgICAgICAgICAgICAgICB2MS50b0FycmF5KCBhcnJheSwgaiApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBhcHBseVRvQnVmZmVyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciB2MTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGFwcGx5VG9CdWZmZXIoIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGggKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICBpZiAoIGxlbmd0aCA9PT0gdW5kZWZpbmVkICkgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCAvIGJ1ZmZlci5pdGVtU2l6ZTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaiA9IG9mZnNldDsgaSA8IGxlbmd0aDsgaSArKywgaiArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2MS54ID0gYnVmZmVyLmdldFgoIGogKTtcclxuICAgICAgICAgICAgICAgIHYxLnkgPSBidWZmZXIuZ2V0WSggaiApO1xyXG4gICAgICAgICAgICAgICAgdjEueiA9IGJ1ZmZlci5nZXRaKCBqICk7XHJcblxyXG4gICAgICAgICAgICAgICAgdjEuYXBwbHlNYXRyaXgzKCB0aGlzICk7XHJcblxyXG4gICAgICAgICAgICAgICAgYnVmZmVyLnNldFhZWiggdjEueCwgdjEueSwgdjEueiApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgbXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcclxuXHJcbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcbiAgICAgICAgdGVbIDAgXSAqPSBzOyB0ZVsgMyBdICo9IHM7IHRlWyA2IF0gKj0gcztcclxuICAgICAgICB0ZVsgMSBdICo9IHM7IHRlWyA0IF0gKj0gczsgdGVbIDcgXSAqPSBzO1xyXG4gICAgICAgIHRlWyAyIF0gKj0gczsgdGVbIDUgXSAqPSBzOyB0ZVsgOCBdICo9IHM7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZGV0ZXJtaW5hbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcbiAgICAgICAgdmFyIGEgPSB0ZVsgMCBdLCBiID0gdGVbIDEgXSwgYyA9IHRlWyAyIF0sXHJcbiAgICAgICAgICAgIGQgPSB0ZVsgMyBdLCBlID0gdGVbIDQgXSwgZiA9IHRlWyA1IF0sXHJcbiAgICAgICAgICAgIGcgPSB0ZVsgNiBdLCBoID0gdGVbIDcgXSwgaSA9IHRlWyA4IF07XHJcblxyXG4gICAgICAgIHJldHVybiBhICogZSAqIGkgLSBhICogZiAqIGggLSBiICogZCAqIGkgKyBiICogZiAqIGcgKyBjICogZCAqIGggLSBjICogZSAqIGc7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRJbnZlcnNlOiBmdW5jdGlvbiAoIG1hdHJpeCwgdGhyb3dPbkludmVydGlibGUgKSB7XHJcblxyXG4gICAgICAgIC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0XHJcbiAgICAgICAgLy8gKCBiYXNlZCBvbiBodHRwOi8vY29kZS5nb29nbGUuY29tL3Avd2ViZ2wtbWpzLyApXHJcblxyXG4gICAgICAgIHZhciBtZSA9IG1hdHJpeC5lbGVtZW50cztcclxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuICAgICAgICB0ZVsgMCBdID0gICBtZVsgMTAgXSAqIG1lWyA1IF0gLSBtZVsgNiBdICogbWVbIDkgXTtcclxuICAgICAgICB0ZVsgMSBdID0gLSBtZVsgMTAgXSAqIG1lWyAxIF0gKyBtZVsgMiBdICogbWVbIDkgXTtcclxuICAgICAgICB0ZVsgMiBdID0gICBtZVsgNiBdICogbWVbIDEgXSAtIG1lWyAyIF0gKiBtZVsgNSBdO1xyXG4gICAgICAgIHRlWyAzIF0gPSAtIG1lWyAxMCBdICogbWVbIDQgXSArIG1lWyA2IF0gKiBtZVsgOCBdO1xyXG4gICAgICAgIHRlWyA0IF0gPSAgIG1lWyAxMCBdICogbWVbIDAgXSAtIG1lWyAyIF0gKiBtZVsgOCBdO1xyXG4gICAgICAgIHRlWyA1IF0gPSAtIG1lWyA2IF0gKiBtZVsgMCBdICsgbWVbIDIgXSAqIG1lWyA0IF07XHJcbiAgICAgICAgdGVbIDYgXSA9ICAgbWVbIDkgXSAqIG1lWyA0IF0gLSBtZVsgNSBdICogbWVbIDggXTtcclxuICAgICAgICB0ZVsgNyBdID0gLSBtZVsgOSBdICogbWVbIDAgXSArIG1lWyAxIF0gKiBtZVsgOCBdO1xyXG4gICAgICAgIHRlWyA4IF0gPSAgIG1lWyA1IF0gKiBtZVsgMCBdIC0gbWVbIDEgXSAqIG1lWyA0IF07XHJcblxyXG4gICAgICAgIHZhciBkZXQgPSBtZVsgMCBdICogdGVbIDAgXSArIG1lWyAxIF0gKiB0ZVsgMyBdICsgbWVbIDIgXSAqIHRlWyA2IF07XHJcblxyXG4gICAgICAgIC8vIG5vIGludmVyc2VcclxuXHJcbiAgICAgICAgaWYgKCBkZXQgPT09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbXNnID0gXCJNYXRyaXgzLmdldEludmVyc2UoKTogY2FuJ3QgaW52ZXJ0IG1hdHJpeCwgZGV0ZXJtaW5hbnQgaXMgMFwiO1xyXG5cclxuICAgICAgICAgICAgaWYgKCB0aHJvd09uSW52ZXJ0aWJsZSB8fCBmYWxzZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oIG1zZyApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5pZGVudGl0eSgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5tdWx0aXBseVNjYWxhciggMS4wIC8gZGV0ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdHJhbnNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciB0bXAsIG0gPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuICAgICAgICB0bXAgPSBtWyAxIF07IG1bIDEgXSA9IG1bIDMgXTsgbVsgMyBdID0gdG1wO1xyXG4gICAgICAgIHRtcCA9IG1bIDIgXTsgbVsgMiBdID0gbVsgNiBdOyBtWyA2IF0gPSB0bXA7XHJcbiAgICAgICAgdG1wID0gbVsgNSBdOyBtWyA1IF0gPSBtWyA3IF07IG1bIDcgXSA9IHRtcDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBmbGF0dGVuVG9BcnJheU9mZnNldDogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuICAgICAgICBhcnJheVsgb2Zmc2V0IF0gPSB0ZVsgMCBdO1xyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0ZVsgMSBdO1xyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0ZVsgMiBdO1xyXG5cclxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGVbIDMgXTtcclxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgNCBdID0gdGVbIDQgXTtcclxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgNSBdID0gdGVbIDUgXTtcclxuXHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDYgXSA9IHRlWyA2IF07XHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDcgXSA9IHRlWyA3IF07XHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDggXSAgPSB0ZVsgOCBdO1xyXG5cclxuICAgICAgICByZXR1cm4gYXJyYXk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXROb3JtYWxNYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcbiAgICAgICAgLy8gaW5wdXQ6IFRIUkVFLk1hdHJpeDRcclxuXHJcbiAgICAgICAgdGhpcy5nZXRJbnZlcnNlKCBtICkudHJhbnNwb3NlKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdHJhbnNwb3NlSW50b0FycmF5OiBmdW5jdGlvbiAoIHIgKSB7XHJcblxyXG4gICAgICAgIHZhciBtID0gdGhpcy5lbGVtZW50cztcclxuXHJcbiAgICAgICAgclsgMCBdID0gbVsgMCBdO1xyXG4gICAgICAgIHJbIDEgXSA9IG1bIDMgXTtcclxuICAgICAgICByWyAyIF0gPSBtWyA2IF07XHJcbiAgICAgICAgclsgMyBdID0gbVsgMSBdO1xyXG4gICAgICAgIHJbIDQgXSA9IG1bIDQgXTtcclxuICAgICAgICByWyA1IF0gPSBtWyA3IF07XHJcbiAgICAgICAgclsgNiBdID0gbVsgMiBdO1xyXG4gICAgICAgIHJbIDcgXSA9IG1bIDUgXTtcclxuICAgICAgICByWyA4IF0gPSBtWyA4IF07XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xyXG5cclxuICAgICAgICB0aGlzLmVsZW1lbnRzLnNldCggYXJyYXkgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0b0FycmF5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHRlWyAwIF0sIHRlWyAxIF0sIHRlWyAyIF0sXHJcbiAgICAgICAgICAgIHRlWyAzIF0sIHRlWyA0IF0sIHRlWyA1IF0sXHJcbiAgICAgICAgICAgIHRlWyA2IF0sIHRlWyA3IF0sIHRlWyA4IF1cclxuICAgICAgICBdO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL01hdHJpeDQuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xyXG4gKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xyXG4gKiBAYXV0aG9yIGpvcmRpX3JvcyAvIGh0dHA6Ly9wbGF0dHNvZnQuY29tXHJcbiAqIEBhdXRob3IgRDFwbG8xZCAvIGh0dHA6Ly9naXRodWIuY29tL0QxcGxvMWRcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciB0aW1rbmlwIC8gaHR0cDovL3d3dy5mbG9vcnBsYW5uZXIuY29tL1xyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKi9cclxuXHJcblRIUkVFLk1hdHJpeDQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdGhpcy5lbGVtZW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcclxuXHJcbiAgICAgICAgMSwgMCwgMCwgMCxcclxuICAgICAgICAwLCAxLCAwLCAwLFxyXG4gICAgICAgIDAsIDAsIDEsIDAsXHJcbiAgICAgICAgMCwgMCwgMCwgMVxyXG5cclxuICAgIF0gKTtcclxuXHJcbiAgICBpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAwICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogdGhlIGNvbnN0cnVjdG9yIG5vIGxvbmdlciByZWFkcyBhcmd1bWVudHMuIHVzZSAuc2V0KCkgaW5zdGVhZC4nICk7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcblRIUkVFLk1hdHJpeDQucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5NYXRyaXg0LFxyXG5cclxuICAgIHNldDogZnVuY3Rpb24gKCBuMTEsIG4xMiwgbjEzLCBuMTQsIG4yMSwgbjIyLCBuMjMsIG4yNCwgbjMxLCBuMzIsIG4zMywgbjM0LCBuNDEsIG40MiwgbjQzLCBuNDQgKSB7XHJcblxyXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG4gICAgICAgIHRlWyAwIF0gPSBuMTE7IHRlWyA0IF0gPSBuMTI7IHRlWyA4IF0gPSBuMTM7IHRlWyAxMiBdID0gbjE0O1xyXG4gICAgICAgIHRlWyAxIF0gPSBuMjE7IHRlWyA1IF0gPSBuMjI7IHRlWyA5IF0gPSBuMjM7IHRlWyAxMyBdID0gbjI0O1xyXG4gICAgICAgIHRlWyAyIF0gPSBuMzE7IHRlWyA2IF0gPSBuMzI7IHRlWyAxMCBdID0gbjMzOyB0ZVsgMTQgXSA9IG4zNDtcclxuICAgICAgICB0ZVsgMyBdID0gbjQxOyB0ZVsgNyBdID0gbjQyOyB0ZVsgMTEgXSA9IG40MzsgdGVbIDE1IF0gPSBuNDQ7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgaWRlbnRpdHk6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdGhpcy5zZXQoXHJcblxyXG4gICAgICAgICAgICAxLCAwLCAwLCAwLFxyXG4gICAgICAgICAgICAwLCAxLCAwLCAwLFxyXG4gICAgICAgICAgICAwLCAwLCAxLCAwLFxyXG4gICAgICAgICAgICAwLCAwLCAwLCAxXHJcblxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5NYXRyaXg0KCkuZnJvbUFycmF5KCB0aGlzLmVsZW1lbnRzICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb3B5OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG4gICAgICAgIHRoaXMuZWxlbWVudHMuc2V0KCBtLmVsZW1lbnRzICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZXh0cmFjdFBvc2l0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5leHRyYWN0UG9zaXRpb24oKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5jb3B5UG9zaXRpb24oKS4nICk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weVBvc2l0aW9uKCBtICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb3B5UG9zaXRpb246IGZ1bmN0aW9uICggbSApIHtcclxuXHJcbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICB2YXIgbWUgPSBtLmVsZW1lbnRzO1xyXG5cclxuICAgICAgICB0ZVsgMTIgXSA9IG1lWyAxMiBdO1xyXG4gICAgICAgIHRlWyAxMyBdID0gbWVbIDEzIF07XHJcbiAgICAgICAgdGVbIDE0IF0gPSBtZVsgMTQgXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBleHRyYWN0QmFzaXM6IGZ1bmN0aW9uICggeEF4aXMsIHlBeGlzLCB6QXhpcyApIHtcclxuXHJcbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcbiAgICAgICAgeEF4aXMuc2V0KCB0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdICk7XHJcbiAgICAgICAgeUF4aXMuc2V0KCB0ZVsgNCBdLCB0ZVsgNSBdLCB0ZVsgNiBdICk7XHJcbiAgICAgICAgekF4aXMuc2V0KCB0ZVsgOCBdLCB0ZVsgOSBdLCB0ZVsgMTAgXSApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG1ha2VCYXNpczogZnVuY3Rpb24gKCB4QXhpcywgeUF4aXMsIHpBeGlzICkge1xyXG5cclxuICAgICAgICB0aGlzLnNldChcclxuICAgICAgICAgICAgeEF4aXMueCwgeUF4aXMueCwgekF4aXMueCwgMCxcclxuICAgICAgICAgICAgeEF4aXMueSwgeUF4aXMueSwgekF4aXMueSwgMCxcclxuICAgICAgICAgICAgeEF4aXMueiwgeUF4aXMueiwgekF4aXMueiwgMCxcclxuICAgICAgICAgICAgMCwgICAgICAgMCwgICAgICAgMCwgICAgICAgMVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZXh0cmFjdFJvdGF0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciB2MTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggbSApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcbiAgICAgICAgICAgIHZhciBtZSA9IG0uZWxlbWVudHM7XHJcblxyXG4gICAgICAgICAgICB2YXIgc2NhbGVYID0gMSAvIHYxLnNldCggbWVbIDAgXSwgbWVbIDEgXSwgbWVbIDIgXSApLmxlbmd0aCgpO1xyXG4gICAgICAgICAgICB2YXIgc2NhbGVZID0gMSAvIHYxLnNldCggbWVbIDQgXSwgbWVbIDUgXSwgbWVbIDYgXSApLmxlbmd0aCgpO1xyXG4gICAgICAgICAgICB2YXIgc2NhbGVaID0gMSAvIHYxLnNldCggbWVbIDggXSwgbWVbIDkgXSwgbWVbIDEwIF0gKS5sZW5ndGgoKTtcclxuXHJcbiAgICAgICAgICAgIHRlWyAwIF0gPSBtZVsgMCBdICogc2NhbGVYO1xyXG4gICAgICAgICAgICB0ZVsgMSBdID0gbWVbIDEgXSAqIHNjYWxlWDtcclxuICAgICAgICAgICAgdGVbIDIgXSA9IG1lWyAyIF0gKiBzY2FsZVg7XHJcblxyXG4gICAgICAgICAgICB0ZVsgNCBdID0gbWVbIDQgXSAqIHNjYWxlWTtcclxuICAgICAgICAgICAgdGVbIDUgXSA9IG1lWyA1IF0gKiBzY2FsZVk7XHJcbiAgICAgICAgICAgIHRlWyA2IF0gPSBtZVsgNiBdICogc2NhbGVZO1xyXG5cclxuICAgICAgICAgICAgdGVbIDggXSA9IG1lWyA4IF0gKiBzY2FsZVo7XHJcbiAgICAgICAgICAgIHRlWyA5IF0gPSBtZVsgOSBdICogc2NhbGVaO1xyXG4gICAgICAgICAgICB0ZVsgMTAgXSA9IG1lWyAxMCBdICogc2NhbGVaO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIG1ha2VSb3RhdGlvbkZyb21FdWxlcjogZnVuY3Rpb24gKCBldWxlciApIHtcclxuXHJcbiAgICAgICAgaWYgKCBldWxlciBpbnN0YW5jZW9mIFRIUkVFLkV1bGVyID09PSBmYWxzZSApIHtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg6IC5tYWtlUm90YXRpb25Gcm9tRXVsZXIoKSBub3cgZXhwZWN0cyBhIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG4gICAgICAgIHZhciB4ID0gZXVsZXIueCwgeSA9IGV1bGVyLnksIHogPSBldWxlci56O1xyXG4gICAgICAgIHZhciBhID0gTWF0aC5jb3MoIHggKSwgYiA9IE1hdGguc2luKCB4ICk7XHJcbiAgICAgICAgdmFyIGMgPSBNYXRoLmNvcyggeSApLCBkID0gTWF0aC5zaW4oIHkgKTtcclxuICAgICAgICB2YXIgZSA9IE1hdGguY29zKCB6ICksIGYgPSBNYXRoLnNpbiggeiApO1xyXG5cclxuICAgICAgICBpZiAoIGV1bGVyLm9yZGVyID09PSAnWFlaJyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBhZSA9IGEgKiBlLCBhZiA9IGEgKiBmLCBiZSA9IGIgKiBlLCBiZiA9IGIgKiBmO1xyXG5cclxuICAgICAgICAgICAgdGVbIDAgXSA9IGMgKiBlO1xyXG4gICAgICAgICAgICB0ZVsgNCBdID0gLSBjICogZjtcclxuICAgICAgICAgICAgdGVbIDggXSA9IGQ7XHJcblxyXG4gICAgICAgICAgICB0ZVsgMSBdID0gYWYgKyBiZSAqIGQ7XHJcbiAgICAgICAgICAgIHRlWyA1IF0gPSBhZSAtIGJmICogZDtcclxuICAgICAgICAgICAgdGVbIDkgXSA9IC0gYiAqIGM7XHJcblxyXG4gICAgICAgICAgICB0ZVsgMiBdID0gYmYgLSBhZSAqIGQ7XHJcbiAgICAgICAgICAgIHRlWyA2IF0gPSBiZSArIGFmICogZDtcclxuICAgICAgICAgICAgdGVbIDEwIF0gPSBhICogYztcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdZWFonICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGNlID0gYyAqIGUsIGNmID0gYyAqIGYsIGRlID0gZCAqIGUsIGRmID0gZCAqIGY7XHJcblxyXG4gICAgICAgICAgICB0ZVsgMCBdID0gY2UgKyBkZiAqIGI7XHJcbiAgICAgICAgICAgIHRlWyA0IF0gPSBkZSAqIGIgLSBjZjtcclxuICAgICAgICAgICAgdGVbIDggXSA9IGEgKiBkO1xyXG5cclxuICAgICAgICAgICAgdGVbIDEgXSA9IGEgKiBmO1xyXG4gICAgICAgICAgICB0ZVsgNSBdID0gYSAqIGU7XHJcbiAgICAgICAgICAgIHRlWyA5IF0gPSAtIGI7XHJcblxyXG4gICAgICAgICAgICB0ZVsgMiBdID0gY2YgKiBiIC0gZGU7XHJcbiAgICAgICAgICAgIHRlWyA2IF0gPSBkZiArIGNlICogYjtcclxuICAgICAgICAgICAgdGVbIDEwIF0gPSBhICogYztcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWFknICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGNlID0gYyAqIGUsIGNmID0gYyAqIGYsIGRlID0gZCAqIGUsIGRmID0gZCAqIGY7XHJcblxyXG4gICAgICAgICAgICB0ZVsgMCBdID0gY2UgLSBkZiAqIGI7XHJcbiAgICAgICAgICAgIHRlWyA0IF0gPSAtIGEgKiBmO1xyXG4gICAgICAgICAgICB0ZVsgOCBdID0gZGUgKyBjZiAqIGI7XHJcblxyXG4gICAgICAgICAgICB0ZVsgMSBdID0gY2YgKyBkZSAqIGI7XHJcbiAgICAgICAgICAgIHRlWyA1IF0gPSBhICogZTtcclxuICAgICAgICAgICAgdGVbIDkgXSA9IGRmIC0gY2UgKiBiO1xyXG5cclxuICAgICAgICAgICAgdGVbIDIgXSA9IC0gYSAqIGQ7XHJcbiAgICAgICAgICAgIHRlWyA2IF0gPSBiO1xyXG4gICAgICAgICAgICB0ZVsgMTAgXSA9IGEgKiBjO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1pZWCcgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYWUgPSBhICogZSwgYWYgPSBhICogZiwgYmUgPSBiICogZSwgYmYgPSBiICogZjtcclxuXHJcbiAgICAgICAgICAgIHRlWyAwIF0gPSBjICogZTtcclxuICAgICAgICAgICAgdGVbIDQgXSA9IGJlICogZCAtIGFmO1xyXG4gICAgICAgICAgICB0ZVsgOCBdID0gYWUgKiBkICsgYmY7XHJcblxyXG4gICAgICAgICAgICB0ZVsgMSBdID0gYyAqIGY7XHJcbiAgICAgICAgICAgIHRlWyA1IF0gPSBiZiAqIGQgKyBhZTtcclxuICAgICAgICAgICAgdGVbIDkgXSA9IGFmICogZCAtIGJlO1xyXG5cclxuICAgICAgICAgICAgdGVbIDIgXSA9IC0gZDtcclxuICAgICAgICAgICAgdGVbIDYgXSA9IGIgKiBjO1xyXG4gICAgICAgICAgICB0ZVsgMTAgXSA9IGEgKiBjO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1laWCcgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYWMgPSBhICogYywgYWQgPSBhICogZCwgYmMgPSBiICogYywgYmQgPSBiICogZDtcclxuXHJcbiAgICAgICAgICAgIHRlWyAwIF0gPSBjICogZTtcclxuICAgICAgICAgICAgdGVbIDQgXSA9IGJkIC0gYWMgKiBmO1xyXG4gICAgICAgICAgICB0ZVsgOCBdID0gYmMgKiBmICsgYWQ7XHJcblxyXG4gICAgICAgICAgICB0ZVsgMSBdID0gZjtcclxuICAgICAgICAgICAgdGVbIDUgXSA9IGEgKiBlO1xyXG4gICAgICAgICAgICB0ZVsgOSBdID0gLSBiICogZTtcclxuXHJcbiAgICAgICAgICAgIHRlWyAyIF0gPSAtIGQgKiBlO1xyXG4gICAgICAgICAgICB0ZVsgNiBdID0gYWQgKiBmICsgYmM7XHJcbiAgICAgICAgICAgIHRlWyAxMCBdID0gYWMgLSBiZCAqIGY7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWFpZJyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBhYyA9IGEgKiBjLCBhZCA9IGEgKiBkLCBiYyA9IGIgKiBjLCBiZCA9IGIgKiBkO1xyXG5cclxuICAgICAgICAgICAgdGVbIDAgXSA9IGMgKiBlO1xyXG4gICAgICAgICAgICB0ZVsgNCBdID0gLSBmO1xyXG4gICAgICAgICAgICB0ZVsgOCBdID0gZCAqIGU7XHJcblxyXG4gICAgICAgICAgICB0ZVsgMSBdID0gYWMgKiBmICsgYmQ7XHJcbiAgICAgICAgICAgIHRlWyA1IF0gPSBhICogZTtcclxuICAgICAgICAgICAgdGVbIDkgXSA9IGFkICogZiAtIGJjO1xyXG5cclxuICAgICAgICAgICAgdGVbIDIgXSA9IGJjICogZiAtIGFkO1xyXG4gICAgICAgICAgICB0ZVsgNiBdID0gYiAqIGU7XHJcbiAgICAgICAgICAgIHRlWyAxMCBdID0gYmQgKiBmICsgYWM7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gbGFzdCBjb2x1bW5cclxuICAgICAgICB0ZVsgMyBdID0gMDtcclxuICAgICAgICB0ZVsgNyBdID0gMDtcclxuICAgICAgICB0ZVsgMTEgXSA9IDA7XHJcblxyXG4gICAgICAgIC8vIGJvdHRvbSByb3dcclxuICAgICAgICB0ZVsgMTIgXSA9IDA7XHJcbiAgICAgICAgdGVbIDEzIF0gPSAwO1xyXG4gICAgICAgIHRlWyAxNCBdID0gMDtcclxuICAgICAgICB0ZVsgMTUgXSA9IDE7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCkuJyApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbiggcSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcclxuXHJcbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcbiAgICAgICAgdmFyIHggPSBxLngsIHkgPSBxLnksIHogPSBxLnosIHcgPSBxLnc7XHJcbiAgICAgICAgdmFyIHgyID0geCArIHgsIHkyID0geSArIHksIHoyID0geiArIHo7XHJcbiAgICAgICAgdmFyIHh4ID0geCAqIHgyLCB4eSA9IHggKiB5MiwgeHogPSB4ICogejI7XHJcbiAgICAgICAgdmFyIHl5ID0geSAqIHkyLCB5eiA9IHkgKiB6MiwgenogPSB6ICogejI7XHJcbiAgICAgICAgdmFyIHd4ID0gdyAqIHgyLCB3eSA9IHcgKiB5Miwgd3ogPSB3ICogejI7XHJcblxyXG4gICAgICAgIHRlWyAwIF0gPSAxIC0gKCB5eSArIHp6ICk7XHJcbiAgICAgICAgdGVbIDQgXSA9IHh5IC0gd3o7XHJcbiAgICAgICAgdGVbIDggXSA9IHh6ICsgd3k7XHJcblxyXG4gICAgICAgIHRlWyAxIF0gPSB4eSArIHd6O1xyXG4gICAgICAgIHRlWyA1IF0gPSAxIC0gKCB4eCArIHp6ICk7XHJcbiAgICAgICAgdGVbIDkgXSA9IHl6IC0gd3g7XHJcblxyXG4gICAgICAgIHRlWyAyIF0gPSB4eiAtIHd5O1xyXG4gICAgICAgIHRlWyA2IF0gPSB5eiArIHd4O1xyXG4gICAgICAgIHRlWyAxMCBdID0gMSAtICggeHggKyB5eSApO1xyXG5cclxuICAgICAgICAvLyBsYXN0IGNvbHVtblxyXG4gICAgICAgIHRlWyAzIF0gPSAwO1xyXG4gICAgICAgIHRlWyA3IF0gPSAwO1xyXG4gICAgICAgIHRlWyAxMSBdID0gMDtcclxuXHJcbiAgICAgICAgLy8gYm90dG9tIHJvd1xyXG4gICAgICAgIHRlWyAxMiBdID0gMDtcclxuICAgICAgICB0ZVsgMTMgXSA9IDA7XHJcbiAgICAgICAgdGVbIDE0IF0gPSAwO1xyXG4gICAgICAgIHRlWyAxNSBdID0gMTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBsb29rQXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHgsIHksIHo7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIGV5ZSwgdGFyZ2V0LCB1cCApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggeCA9PT0gdW5kZWZpbmVkICkgeCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgICAgIGlmICggeSA9PT0gdW5kZWZpbmVkICkgeSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgICAgIGlmICggeiA9PT0gdW5kZWZpbmVkICkgeiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuICAgICAgICAgICAgei5zdWJWZWN0b3JzKCBleWUsIHRhcmdldCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCB6Lmxlbmd0aFNxKCkgPT09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgei56ID0gMTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHguY3Jvc3NWZWN0b3JzKCB1cCwgeiApLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCB4Lmxlbmd0aFNxKCkgPT09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgei54ICs9IDAuMDAwMTtcclxuICAgICAgICAgICAgICAgIHguY3Jvc3NWZWN0b3JzKCB1cCwgeiApLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgeS5jcm9zc1ZlY3RvcnMoIHosIHggKTtcclxuXHJcblxyXG4gICAgICAgICAgICB0ZVsgMCBdID0geC54OyB0ZVsgNCBdID0geS54OyB0ZVsgOCBdID0gei54O1xyXG4gICAgICAgICAgICB0ZVsgMSBdID0geC55OyB0ZVsgNSBdID0geS55OyB0ZVsgOSBdID0gei55O1xyXG4gICAgICAgICAgICB0ZVsgMiBdID0geC56OyB0ZVsgNiBdID0geS56OyB0ZVsgMTAgXSA9IHouejtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBtdWx0aXBseTogZnVuY3Rpb24gKCBtLCBuICkge1xyXG5cclxuICAgICAgICBpZiAoIG4gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5TWF0cmljZXMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggbSwgbiApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIHRoaXMsIG0gKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG11bHRpcGx5TWF0cmljZXM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcbiAgICAgICAgdmFyIGFlID0gYS5lbGVtZW50cztcclxuICAgICAgICB2YXIgYmUgPSBiLmVsZW1lbnRzO1xyXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG4gICAgICAgIHZhciBhMTEgPSBhZVsgMCBdLCBhMTIgPSBhZVsgNCBdLCBhMTMgPSBhZVsgOCBdLCBhMTQgPSBhZVsgMTIgXTtcclxuICAgICAgICB2YXIgYTIxID0gYWVbIDEgXSwgYTIyID0gYWVbIDUgXSwgYTIzID0gYWVbIDkgXSwgYTI0ID0gYWVbIDEzIF07XHJcbiAgICAgICAgdmFyIGEzMSA9IGFlWyAyIF0sIGEzMiA9IGFlWyA2IF0sIGEzMyA9IGFlWyAxMCBdLCBhMzQgPSBhZVsgMTQgXTtcclxuICAgICAgICB2YXIgYTQxID0gYWVbIDMgXSwgYTQyID0gYWVbIDcgXSwgYTQzID0gYWVbIDExIF0sIGE0NCA9IGFlWyAxNSBdO1xyXG5cclxuICAgICAgICB2YXIgYjExID0gYmVbIDAgXSwgYjEyID0gYmVbIDQgXSwgYjEzID0gYmVbIDggXSwgYjE0ID0gYmVbIDEyIF07XHJcbiAgICAgICAgdmFyIGIyMSA9IGJlWyAxIF0sIGIyMiA9IGJlWyA1IF0sIGIyMyA9IGJlWyA5IF0sIGIyNCA9IGJlWyAxMyBdO1xyXG4gICAgICAgIHZhciBiMzEgPSBiZVsgMiBdLCBiMzIgPSBiZVsgNiBdLCBiMzMgPSBiZVsgMTAgXSwgYjM0ID0gYmVbIDE0IF07XHJcbiAgICAgICAgdmFyIGI0MSA9IGJlWyAzIF0sIGI0MiA9IGJlWyA3IF0sIGI0MyA9IGJlWyAxMSBdLCBiNDQgPSBiZVsgMTUgXTtcclxuXHJcbiAgICAgICAgdGVbIDAgXSA9IGExMSAqIGIxMSArIGExMiAqIGIyMSArIGExMyAqIGIzMSArIGExNCAqIGI0MTtcclxuICAgICAgICB0ZVsgNCBdID0gYTExICogYjEyICsgYTEyICogYjIyICsgYTEzICogYjMyICsgYTE0ICogYjQyO1xyXG4gICAgICAgIHRlWyA4IF0gPSBhMTEgKiBiMTMgKyBhMTIgKiBiMjMgKyBhMTMgKiBiMzMgKyBhMTQgKiBiNDM7XHJcbiAgICAgICAgdGVbIDEyIF0gPSBhMTEgKiBiMTQgKyBhMTIgKiBiMjQgKyBhMTMgKiBiMzQgKyBhMTQgKiBiNDQ7XHJcblxyXG4gICAgICAgIHRlWyAxIF0gPSBhMjEgKiBiMTEgKyBhMjIgKiBiMjEgKyBhMjMgKiBiMzEgKyBhMjQgKiBiNDE7XHJcbiAgICAgICAgdGVbIDUgXSA9IGEyMSAqIGIxMiArIGEyMiAqIGIyMiArIGEyMyAqIGIzMiArIGEyNCAqIGI0MjtcclxuICAgICAgICB0ZVsgOSBdID0gYTIxICogYjEzICsgYTIyICogYjIzICsgYTIzICogYjMzICsgYTI0ICogYjQzO1xyXG4gICAgICAgIHRlWyAxMyBdID0gYTIxICogYjE0ICsgYTIyICogYjI0ICsgYTIzICogYjM0ICsgYTI0ICogYjQ0O1xyXG5cclxuICAgICAgICB0ZVsgMiBdID0gYTMxICogYjExICsgYTMyICogYjIxICsgYTMzICogYjMxICsgYTM0ICogYjQxO1xyXG4gICAgICAgIHRlWyA2IF0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzIgKyBhMzQgKiBiNDI7XHJcbiAgICAgICAgdGVbIDEwIF0gPSBhMzEgKiBiMTMgKyBhMzIgKiBiMjMgKyBhMzMgKiBiMzMgKyBhMzQgKiBiNDM7XHJcbiAgICAgICAgdGVbIDE0IF0gPSBhMzEgKiBiMTQgKyBhMzIgKiBiMjQgKyBhMzMgKiBiMzQgKyBhMzQgKiBiNDQ7XHJcblxyXG4gICAgICAgIHRlWyAzIF0gPSBhNDEgKiBiMTEgKyBhNDIgKiBiMjEgKyBhNDMgKiBiMzEgKyBhNDQgKiBiNDE7XHJcbiAgICAgICAgdGVbIDcgXSA9IGE0MSAqIGIxMiArIGE0MiAqIGIyMiArIGE0MyAqIGIzMiArIGE0NCAqIGI0MjtcclxuICAgICAgICB0ZVsgMTEgXSA9IGE0MSAqIGIxMyArIGE0MiAqIGIyMyArIGE0MyAqIGIzMyArIGE0NCAqIGI0MztcclxuICAgICAgICB0ZVsgMTUgXSA9IGE0MSAqIGIxNCArIGE0MiAqIGIyNCArIGE0MyAqIGIzNCArIGE0NCAqIGI0NDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBtdWx0aXBseVRvQXJyYXk6IGZ1bmN0aW9uICggYSwgYiwgciApIHtcclxuXHJcbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcbiAgICAgICAgdGhpcy5tdWx0aXBseU1hdHJpY2VzKCBhLCBiICk7XHJcblxyXG4gICAgICAgIHJbIDAgXSA9IHRlWyAwIF07IHJbIDEgXSA9IHRlWyAxIF07IHJbIDIgXSA9IHRlWyAyIF07IHJbIDMgXSA9IHRlWyAzIF07XHJcbiAgICAgICAgclsgNCBdID0gdGVbIDQgXTsgclsgNSBdID0gdGVbIDUgXTsgclsgNiBdID0gdGVbIDYgXTsgclsgNyBdID0gdGVbIDcgXTtcclxuICAgICAgICByWyA4IF0gID0gdGVbIDggXTsgclsgOSBdICA9IHRlWyA5IF07IHJbIDEwIF0gPSB0ZVsgMTAgXTsgclsgMTEgXSA9IHRlWyAxMSBdO1xyXG4gICAgICAgIHJbIDEyIF0gPSB0ZVsgMTIgXTsgclsgMTMgXSA9IHRlWyAxMyBdOyByWyAxNCBdID0gdGVbIDE0IF07IHJbIDE1IF0gPSB0ZVsgMTUgXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuICAgICAgICB0ZVsgMCBdICo9IHM7IHRlWyA0IF0gKj0gczsgdGVbIDggXSAqPSBzOyB0ZVsgMTIgXSAqPSBzO1xyXG4gICAgICAgIHRlWyAxIF0gKj0gczsgdGVbIDUgXSAqPSBzOyB0ZVsgOSBdICo9IHM7IHRlWyAxMyBdICo9IHM7XHJcbiAgICAgICAgdGVbIDIgXSAqPSBzOyB0ZVsgNiBdICo9IHM7IHRlWyAxMCBdICo9IHM7IHRlWyAxNCBdICo9IHM7XHJcbiAgICAgICAgdGVbIDMgXSAqPSBzOyB0ZVsgNyBdICo9IHM7IHRlWyAxMSBdICo9IHM7IHRlWyAxNSBdICo9IHM7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbXVsdGlwbHlWZWN0b3IzOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm11bHRpcGx5VmVjdG9yMygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtYXRyaXggKSBvciB2ZWN0b3IuYXBwbHlQcm9qZWN0aW9uKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcclxuICAgICAgICByZXR1cm4gdmVjdG9yLmFwcGx5UHJvamVjdGlvbiggdGhpcyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbXVsdGlwbHlWZWN0b3I0OiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm11bHRpcGx5VmVjdG9yNCgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcclxuICAgICAgICByZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggdGhpcyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbXVsdGlwbHlWZWN0b3IzQXJyYXk6IGZ1bmN0aW9uICggYSApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm11bHRpcGx5VmVjdG9yM0FycmF5KCkgaGFzIGJlZW4gcmVuYW1lZC4gVXNlIG1hdHJpeC5hcHBseVRvVmVjdG9yM0FycmF5KCBhcnJheSApIGluc3RlYWQuJyApO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5VG9WZWN0b3IzQXJyYXkoIGEgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFwcGx5VG9WZWN0b3IzQXJyYXk6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHYxO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0LCBsZW5ndGggKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICBpZiAoIGxlbmd0aCA9PT0gdW5kZWZpbmVkICkgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBqID0gb2Zmc2V0OyBpIDwgbGVuZ3RoOyBpICs9IDMsIGogKz0gMyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2MS5mcm9tQXJyYXkoIGFycmF5LCBqICk7XHJcbiAgICAgICAgICAgICAgICB2MS5hcHBseU1hdHJpeDQoIHRoaXMgKTtcclxuICAgICAgICAgICAgICAgIHYxLnRvQXJyYXkoIGFycmF5LCBqICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYXJyYXk7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIGFwcGx5VG9CdWZmZXI6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHYxO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gYXBwbHlUb0J1ZmZlciggYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgIGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSBidWZmZXIubGVuZ3RoIC8gYnVmZmVyLml0ZW1TaXplO1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBqID0gb2Zmc2V0OyBpIDwgbGVuZ3RoOyBpICsrLCBqICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHYxLnggPSBidWZmZXIuZ2V0WCggaiApO1xyXG4gICAgICAgICAgICAgICAgdjEueSA9IGJ1ZmZlci5nZXRZKCBqICk7XHJcbiAgICAgICAgICAgICAgICB2MS56ID0gYnVmZmVyLmdldFooIGogKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2MS5hcHBseU1hdHJpeDQoIHRoaXMgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBidWZmZXIuc2V0WFlaKCB2MS54LCB2MS55LCB2MS56ICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICByb3RhdGVBeGlzOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVBeGlzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFZlY3RvcjMudHJhbnNmb3JtRGlyZWN0aW9uKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcclxuXHJcbiAgICAgICAgdi50cmFuc2Zvcm1EaXJlY3Rpb24oIHRoaXMgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNyb3NzVmVjdG9yOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLmNyb3NzVmVjdG9yKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIGluc3RlYWQuJyApO1xyXG4gICAgICAgIHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCB0aGlzICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBkZXRlcm1pbmFudDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuICAgICAgICB2YXIgbjExID0gdGVbIDAgXSwgbjEyID0gdGVbIDQgXSwgbjEzID0gdGVbIDggXSwgbjE0ID0gdGVbIDEyIF07XHJcbiAgICAgICAgdmFyIG4yMSA9IHRlWyAxIF0sIG4yMiA9IHRlWyA1IF0sIG4yMyA9IHRlWyA5IF0sIG4yNCA9IHRlWyAxMyBdO1xyXG4gICAgICAgIHZhciBuMzEgPSB0ZVsgMiBdLCBuMzIgPSB0ZVsgNiBdLCBuMzMgPSB0ZVsgMTAgXSwgbjM0ID0gdGVbIDE0IF07XHJcbiAgICAgICAgdmFyIG40MSA9IHRlWyAzIF0sIG40MiA9IHRlWyA3IF0sIG40MyA9IHRlWyAxMSBdLCBuNDQgPSB0ZVsgMTUgXTtcclxuXHJcbiAgICAgICAgLy9UT0RPOiBtYWtlIHRoaXMgbW9yZSBlZmZpY2llbnRcclxuICAgICAgICAvLyggYmFzZWQgb24gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9tYXRyaXgvZnVuY3Rpb25zL2ludmVyc2UvZm91ckQvaW5kZXguaHRtIClcclxuXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgbjQxICogKFxyXG4gICAgICAgICAgICAgICAgKyBuMTQgKiBuMjMgKiBuMzJcclxuICAgICAgICAgICAgICAgIC0gbjEzICogbjI0ICogbjMyXHJcbiAgICAgICAgICAgICAgICAtIG4xNCAqIG4yMiAqIG4zM1xyXG4gICAgICAgICAgICAgICAgKyBuMTIgKiBuMjQgKiBuMzNcclxuICAgICAgICAgICAgICAgICsgbjEzICogbjIyICogbjM0XHJcbiAgICAgICAgICAgICAgICAtIG4xMiAqIG4yMyAqIG4zNFxyXG4gICAgICAgICAgICApICtcclxuICAgICAgICAgICAgbjQyICogKFxyXG4gICAgICAgICAgICAgICAgKyBuMTEgKiBuMjMgKiBuMzRcclxuICAgICAgICAgICAgICAgIC0gbjExICogbjI0ICogbjMzXHJcbiAgICAgICAgICAgICAgICArIG4xNCAqIG4yMSAqIG4zM1xyXG4gICAgICAgICAgICAgICAgLSBuMTMgKiBuMjEgKiBuMzRcclxuICAgICAgICAgICAgICAgICsgbjEzICogbjI0ICogbjMxXHJcbiAgICAgICAgICAgICAgICAtIG4xNCAqIG4yMyAqIG4zMVxyXG4gICAgICAgICAgICApICtcclxuICAgICAgICAgICAgbjQzICogKFxyXG4gICAgICAgICAgICAgICAgKyBuMTEgKiBuMjQgKiBuMzJcclxuICAgICAgICAgICAgICAgIC0gbjExICogbjIyICogbjM0XHJcbiAgICAgICAgICAgICAgICAtIG4xNCAqIG4yMSAqIG4zMlxyXG4gICAgICAgICAgICAgICAgKyBuMTIgKiBuMjEgKiBuMzRcclxuICAgICAgICAgICAgICAgICsgbjE0ICogbjIyICogbjMxXHJcbiAgICAgICAgICAgICAgICAtIG4xMiAqIG4yNCAqIG4zMVxyXG4gICAgICAgICAgICApICtcclxuICAgICAgICAgICAgbjQ0ICogKFxyXG4gICAgICAgICAgICAgICAgLSBuMTMgKiBuMjIgKiBuMzFcclxuICAgICAgICAgICAgICAgIC0gbjExICogbjIzICogbjMyXHJcbiAgICAgICAgICAgICAgICArIG4xMSAqIG4yMiAqIG4zM1xyXG4gICAgICAgICAgICAgICAgKyBuMTMgKiBuMjEgKiBuMzJcclxuICAgICAgICAgICAgICAgIC0gbjEyICogbjIxICogbjMzXHJcbiAgICAgICAgICAgICAgICArIG4xMiAqIG4yMyAqIG4zMVxyXG4gICAgICAgICAgICApXHJcblxyXG4gICAgICAgICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0cmFuc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICB2YXIgdG1wO1xyXG5cclxuICAgICAgICB0bXAgPSB0ZVsgMSBdOyB0ZVsgMSBdID0gdGVbIDQgXTsgdGVbIDQgXSA9IHRtcDtcclxuICAgICAgICB0bXAgPSB0ZVsgMiBdOyB0ZVsgMiBdID0gdGVbIDggXTsgdGVbIDggXSA9IHRtcDtcclxuICAgICAgICB0bXAgPSB0ZVsgNiBdOyB0ZVsgNiBdID0gdGVbIDkgXTsgdGVbIDkgXSA9IHRtcDtcclxuXHJcbiAgICAgICAgdG1wID0gdGVbIDMgXTsgdGVbIDMgXSA9IHRlWyAxMiBdOyB0ZVsgMTIgXSA9IHRtcDtcclxuICAgICAgICB0bXAgPSB0ZVsgNyBdOyB0ZVsgNyBdID0gdGVbIDEzIF07IHRlWyAxMyBdID0gdG1wO1xyXG4gICAgICAgIHRtcCA9IHRlWyAxMSBdOyB0ZVsgMTEgXSA9IHRlWyAxNCBdOyB0ZVsgMTQgXSA9IHRtcDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBmbGF0dGVuVG9BcnJheU9mZnNldDogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuICAgICAgICBhcnJheVsgb2Zmc2V0IF0gPSB0ZVsgMCBdO1xyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0ZVsgMSBdO1xyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0ZVsgMiBdO1xyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0ZVsgMyBdO1xyXG5cclxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgNCBdID0gdGVbIDQgXTtcclxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgNSBdID0gdGVbIDUgXTtcclxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgNiBdID0gdGVbIDYgXTtcclxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgNyBdID0gdGVbIDcgXTtcclxuXHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDggXSAgPSB0ZVsgOCBdO1xyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyA5IF0gID0gdGVbIDkgXTtcclxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMTAgXSA9IHRlWyAxMCBdO1xyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAxMSBdID0gdGVbIDExIF07XHJcblxyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAxMiBdID0gdGVbIDEyIF07XHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDEzIF0gPSB0ZVsgMTMgXTtcclxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMTQgXSA9IHRlWyAxNCBdO1xyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAxNSBdID0gdGVbIDE1IF07XHJcblxyXG4gICAgICAgIHJldHVybiBhcnJheTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciB2MTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLmdldFBvc2l0aW9uKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcbiAgICAgICAgICAgIHJldHVybiB2MS5zZXQoIHRlWyAxMiBdLCB0ZVsgMTMgXSwgdGVbIDE0IF0gKTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgc2V0UG9zaXRpb246IGZ1bmN0aW9uICggdiApIHtcclxuXHJcbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcbiAgICAgICAgdGVbIDEyIF0gPSB2Lng7XHJcbiAgICAgICAgdGVbIDEzIF0gPSB2Lnk7XHJcbiAgICAgICAgdGVbIDE0IF0gPSB2Lno7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0SW52ZXJzZTogZnVuY3Rpb24gKCBtLCB0aHJvd09uSW52ZXJ0aWJsZSApIHtcclxuXHJcbiAgICAgICAgLy8gYmFzZWQgb24gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9tYXRyaXgvZnVuY3Rpb25zL2ludmVyc2UvZm91ckQvaW5kZXguaHRtXHJcbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICB2YXIgbWUgPSBtLmVsZW1lbnRzO1xyXG5cclxuICAgICAgICB2YXIgbjExID0gbWVbIDAgXSwgbjEyID0gbWVbIDQgXSwgbjEzID0gbWVbIDggXSwgbjE0ID0gbWVbIDEyIF07XHJcbiAgICAgICAgdmFyIG4yMSA9IG1lWyAxIF0sIG4yMiA9IG1lWyA1IF0sIG4yMyA9IG1lWyA5IF0sIG4yNCA9IG1lWyAxMyBdO1xyXG4gICAgICAgIHZhciBuMzEgPSBtZVsgMiBdLCBuMzIgPSBtZVsgNiBdLCBuMzMgPSBtZVsgMTAgXSwgbjM0ID0gbWVbIDE0IF07XHJcbiAgICAgICAgdmFyIG40MSA9IG1lWyAzIF0sIG40MiA9IG1lWyA3IF0sIG40MyA9IG1lWyAxMSBdLCBuNDQgPSBtZVsgMTUgXTtcclxuXHJcbiAgICAgICAgdGVbIDAgXSA9IG4yMyAqIG4zNCAqIG40MiAtIG4yNCAqIG4zMyAqIG40MiArIG4yNCAqIG4zMiAqIG40MyAtIG4yMiAqIG4zNCAqIG40MyAtIG4yMyAqIG4zMiAqIG40NCArIG4yMiAqIG4zMyAqIG40NDtcclxuICAgICAgICB0ZVsgNCBdID0gbjE0ICogbjMzICogbjQyIC0gbjEzICogbjM0ICogbjQyIC0gbjE0ICogbjMyICogbjQzICsgbjEyICogbjM0ICogbjQzICsgbjEzICogbjMyICogbjQ0IC0gbjEyICogbjMzICogbjQ0O1xyXG4gICAgICAgIHRlWyA4IF0gPSBuMTMgKiBuMjQgKiBuNDIgLSBuMTQgKiBuMjMgKiBuNDIgKyBuMTQgKiBuMjIgKiBuNDMgLSBuMTIgKiBuMjQgKiBuNDMgLSBuMTMgKiBuMjIgKiBuNDQgKyBuMTIgKiBuMjMgKiBuNDQ7XHJcbiAgICAgICAgdGVbIDEyIF0gPSBuMTQgKiBuMjMgKiBuMzIgLSBuMTMgKiBuMjQgKiBuMzIgLSBuMTQgKiBuMjIgKiBuMzMgKyBuMTIgKiBuMjQgKiBuMzMgKyBuMTMgKiBuMjIgKiBuMzQgLSBuMTIgKiBuMjMgKiBuMzQ7XHJcbiAgICAgICAgdGVbIDEgXSA9IG4yNCAqIG4zMyAqIG40MSAtIG4yMyAqIG4zNCAqIG40MSAtIG4yNCAqIG4zMSAqIG40MyArIG4yMSAqIG4zNCAqIG40MyArIG4yMyAqIG4zMSAqIG40NCAtIG4yMSAqIG4zMyAqIG40NDtcclxuICAgICAgICB0ZVsgNSBdID0gbjEzICogbjM0ICogbjQxIC0gbjE0ICogbjMzICogbjQxICsgbjE0ICogbjMxICogbjQzIC0gbjExICogbjM0ICogbjQzIC0gbjEzICogbjMxICogbjQ0ICsgbjExICogbjMzICogbjQ0O1xyXG4gICAgICAgIHRlWyA5IF0gPSBuMTQgKiBuMjMgKiBuNDEgLSBuMTMgKiBuMjQgKiBuNDEgLSBuMTQgKiBuMjEgKiBuNDMgKyBuMTEgKiBuMjQgKiBuNDMgKyBuMTMgKiBuMjEgKiBuNDQgLSBuMTEgKiBuMjMgKiBuNDQ7XHJcbiAgICAgICAgdGVbIDEzIF0gPSBuMTMgKiBuMjQgKiBuMzEgLSBuMTQgKiBuMjMgKiBuMzEgKyBuMTQgKiBuMjEgKiBuMzMgLSBuMTEgKiBuMjQgKiBuMzMgLSBuMTMgKiBuMjEgKiBuMzQgKyBuMTEgKiBuMjMgKiBuMzQ7XHJcbiAgICAgICAgdGVbIDIgXSA9IG4yMiAqIG4zNCAqIG40MSAtIG4yNCAqIG4zMiAqIG40MSArIG4yNCAqIG4zMSAqIG40MiAtIG4yMSAqIG4zNCAqIG40MiAtIG4yMiAqIG4zMSAqIG40NCArIG4yMSAqIG4zMiAqIG40NDtcclxuICAgICAgICB0ZVsgNiBdID0gbjE0ICogbjMyICogbjQxIC0gbjEyICogbjM0ICogbjQxIC0gbjE0ICogbjMxICogbjQyICsgbjExICogbjM0ICogbjQyICsgbjEyICogbjMxICogbjQ0IC0gbjExICogbjMyICogbjQ0O1xyXG4gICAgICAgIHRlWyAxMCBdID0gbjEyICogbjI0ICogbjQxIC0gbjE0ICogbjIyICogbjQxICsgbjE0ICogbjIxICogbjQyIC0gbjExICogbjI0ICogbjQyIC0gbjEyICogbjIxICogbjQ0ICsgbjExICogbjIyICogbjQ0O1xyXG4gICAgICAgIHRlWyAxNCBdID0gbjE0ICogbjIyICogbjMxIC0gbjEyICogbjI0ICogbjMxIC0gbjE0ICogbjIxICogbjMyICsgbjExICogbjI0ICogbjMyICsgbjEyICogbjIxICogbjM0IC0gbjExICogbjIyICogbjM0O1xyXG4gICAgICAgIHRlWyAzIF0gPSBuMjMgKiBuMzIgKiBuNDEgLSBuMjIgKiBuMzMgKiBuNDEgLSBuMjMgKiBuMzEgKiBuNDIgKyBuMjEgKiBuMzMgKiBuNDIgKyBuMjIgKiBuMzEgKiBuNDMgLSBuMjEgKiBuMzIgKiBuNDM7XHJcbiAgICAgICAgdGVbIDcgXSA9IG4xMiAqIG4zMyAqIG40MSAtIG4xMyAqIG4zMiAqIG40MSArIG4xMyAqIG4zMSAqIG40MiAtIG4xMSAqIG4zMyAqIG40MiAtIG4xMiAqIG4zMSAqIG40MyArIG4xMSAqIG4zMiAqIG40MztcclxuICAgICAgICB0ZVsgMTEgXSA9IG4xMyAqIG4yMiAqIG40MSAtIG4xMiAqIG4yMyAqIG40MSAtIG4xMyAqIG4yMSAqIG40MiArIG4xMSAqIG4yMyAqIG40MiArIG4xMiAqIG4yMSAqIG40MyAtIG4xMSAqIG4yMiAqIG40MztcclxuICAgICAgICB0ZVsgMTUgXSA9IG4xMiAqIG4yMyAqIG4zMSAtIG4xMyAqIG4yMiAqIG4zMSArIG4xMyAqIG4yMSAqIG4zMiAtIG4xMSAqIG4yMyAqIG4zMiAtIG4xMiAqIG4yMSAqIG4zMyArIG4xMSAqIG4yMiAqIG4zMztcclxuXHJcbiAgICAgICAgdmFyIGRldCA9IG4xMSAqIHRlWyAwIF0gKyBuMjEgKiB0ZVsgNCBdICsgbjMxICogdGVbIDggXSArIG40MSAqIHRlWyAxMiBdO1xyXG5cclxuICAgICAgICBpZiAoIGRldCA9PT0gMCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBtc2cgPSBcIlRIUkVFLk1hdHJpeDQuZ2V0SW52ZXJzZSgpOiBjYW4ndCBpbnZlcnQgbWF0cml4LCBkZXRlcm1pbmFudCBpcyAwXCI7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHRocm93T25JbnZlcnRpYmxlIHx8IGZhbHNlICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggbXNnICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggbXNnICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmlkZW50aXR5KCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm11bHRpcGx5U2NhbGFyKCAxIC8gZGV0ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAudHJhbnNsYXRlKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICByb3RhdGVYOiBmdW5jdGlvbiAoIGFuZ2xlICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZVgoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJvdGF0ZVk6IGZ1bmN0aW9uICggYW5nbGUgKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAucm90YXRlWSgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcm90YXRlWjogZnVuY3Rpb24gKCBhbmdsZSApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVaKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICByb3RhdGVCeUF4aXM6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAucm90YXRlQnlBeGlzKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzY2FsZTogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgICAgIHZhciB4ID0gdi54LCB5ID0gdi55LCB6ID0gdi56O1xyXG5cclxuICAgICAgICB0ZVsgMCBdICo9IHg7IHRlWyA0IF0gKj0geTsgdGVbIDggXSAqPSB6O1xyXG4gICAgICAgIHRlWyAxIF0gKj0geDsgdGVbIDUgXSAqPSB5OyB0ZVsgOSBdICo9IHo7XHJcbiAgICAgICAgdGVbIDIgXSAqPSB4OyB0ZVsgNiBdICo9IHk7IHRlWyAxMCBdICo9IHo7XHJcbiAgICAgICAgdGVbIDMgXSAqPSB4OyB0ZVsgNyBdICo9IHk7IHRlWyAxMSBdICo9IHo7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0TWF4U2NhbGVPbkF4aXM6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcbiAgICAgICAgdmFyIHNjYWxlWFNxID0gdGVbIDAgXSAqIHRlWyAwIF0gKyB0ZVsgMSBdICogdGVbIDEgXSArIHRlWyAyIF0gKiB0ZVsgMiBdO1xyXG4gICAgICAgIHZhciBzY2FsZVlTcSA9IHRlWyA0IF0gKiB0ZVsgNCBdICsgdGVbIDUgXSAqIHRlWyA1IF0gKyB0ZVsgNiBdICogdGVbIDYgXTtcclxuICAgICAgICB2YXIgc2NhbGVaU3EgPSB0ZVsgOCBdICogdGVbIDggXSArIHRlWyA5IF0gKiB0ZVsgOSBdICsgdGVbIDEwIF0gKiB0ZVsgMTAgXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCggTWF0aC5tYXgoIHNjYWxlWFNxLCBzY2FsZVlTcSwgc2NhbGVaU3EgKSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbWFrZVRyYW5zbGF0aW9uOiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0KFxyXG5cclxuICAgICAgICAgICAgMSwgMCwgMCwgeCxcclxuICAgICAgICAgICAgMCwgMSwgMCwgeSxcclxuICAgICAgICAgICAgMCwgMCwgMSwgeixcclxuICAgICAgICAgICAgMCwgMCwgMCwgMVxyXG5cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG1ha2VSb3RhdGlvblg6IGZ1bmN0aW9uICggdGhldGEgKSB7XHJcblxyXG4gICAgICAgIHZhciBjID0gTWF0aC5jb3MoIHRoZXRhICksIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcclxuXHJcbiAgICAgICAgdGhpcy5zZXQoXHJcblxyXG4gICAgICAgICAgICAxLCAwLCAgMCwgMCxcclxuICAgICAgICAgICAgMCwgYywgLSBzLCAwLFxyXG4gICAgICAgICAgICAwLCBzLCAgYywgMCxcclxuICAgICAgICAgICAgMCwgMCwgIDAsIDFcclxuXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBtYWtlUm90YXRpb25ZOiBmdW5jdGlvbiAoIHRoZXRhICkge1xyXG5cclxuICAgICAgICB2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0KFxyXG5cclxuICAgICAgICAgICAgYywgMCwgcywgMCxcclxuICAgICAgICAgICAgMCwgMSwgMCwgMCxcclxuICAgICAgICAgICAgLSBzLCAwLCBjLCAwLFxyXG4gICAgICAgICAgICAwLCAwLCAwLCAxXHJcblxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbWFrZVJvdGF0aW9uWjogZnVuY3Rpb24gKCB0aGV0YSApIHtcclxuXHJcbiAgICAgICAgdmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xyXG5cclxuICAgICAgICB0aGlzLnNldChcclxuXHJcbiAgICAgICAgICAgIGMsIC0gcywgMCwgMCxcclxuICAgICAgICAgICAgcywgIGMsIDAsIDAsXHJcbiAgICAgICAgICAgIDAsICAwLCAxLCAwLFxyXG4gICAgICAgICAgICAwLCAgMCwgMCwgMVxyXG5cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG1ha2VSb3RhdGlvbkF4aXM6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XHJcblxyXG4gICAgICAgIC8vIEJhc2VkIG9uIGh0dHA6Ly93d3cuZ2FtZWRldi5uZXQvcmVmZXJlbmNlL2FydGljbGVzL2FydGljbGUxMTk5LmFzcFxyXG5cclxuICAgICAgICB2YXIgYyA9IE1hdGguY29zKCBhbmdsZSApO1xyXG4gICAgICAgIHZhciBzID0gTWF0aC5zaW4oIGFuZ2xlICk7XHJcbiAgICAgICAgdmFyIHQgPSAxIC0gYztcclxuICAgICAgICB2YXIgeCA9IGF4aXMueCwgeSA9IGF4aXMueSwgeiA9IGF4aXMuejtcclxuICAgICAgICB2YXIgdHggPSB0ICogeCwgdHkgPSB0ICogeTtcclxuXHJcbiAgICAgICAgdGhpcy5zZXQoXHJcblxyXG4gICAgICAgICAgICB0eCAqIHggKyBjLCB0eCAqIHkgLSBzICogeiwgdHggKiB6ICsgcyAqIHksIDAsXHJcbiAgICAgICAgICAgIHR4ICogeSArIHMgKiB6LCB0eSAqIHkgKyBjLCB0eSAqIHogLSBzICogeCwgMCxcclxuICAgICAgICAgICAgdHggKiB6IC0gcyAqIHksIHR5ICogeiArIHMgKiB4LCB0ICogeiAqIHogKyBjLCAwLFxyXG4gICAgICAgICAgICAwLCAwLCAwLCAxXHJcblxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbWFrZVNjYWxlOiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0KFxyXG5cclxuICAgICAgICAgICAgeCwgMCwgMCwgMCxcclxuICAgICAgICAgICAgMCwgeSwgMCwgMCxcclxuICAgICAgICAgICAgMCwgMCwgeiwgMCxcclxuICAgICAgICAgICAgMCwgMCwgMCwgMVxyXG5cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvbXBvc2U6IGZ1bmN0aW9uICggcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlICkge1xyXG5cclxuICAgICAgICB0aGlzLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XHJcbiAgICAgICAgdGhpcy5zY2FsZSggc2NhbGUgKTtcclxuICAgICAgICB0aGlzLnNldFBvc2l0aW9uKCBwb3NpdGlvbiApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRlY29tcG9zZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgdmVjdG9yLCBtYXRyaXg7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggdmVjdG9yID09PSB1bmRlZmluZWQgKSB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgICAgICBpZiAoIG1hdHJpeCA9PT0gdW5kZWZpbmVkICkgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG4gICAgICAgICAgICB2YXIgc3ggPSB2ZWN0b3Iuc2V0KCB0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdICkubGVuZ3RoKCk7XHJcbiAgICAgICAgICAgIHZhciBzeSA9IHZlY3Rvci5zZXQoIHRlWyA0IF0sIHRlWyA1IF0sIHRlWyA2IF0gKS5sZW5ndGgoKTtcclxuICAgICAgICAgICAgdmFyIHN6ID0gdmVjdG9yLnNldCggdGVbIDggXSwgdGVbIDkgXSwgdGVbIDEwIF0gKS5sZW5ndGgoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGlmIGRldGVybWluZSBpcyBuZWdhdGl2ZSwgd2UgbmVlZCB0byBpbnZlcnQgb25lIHNjYWxlXHJcbiAgICAgICAgICAgIHZhciBkZXQgPSB0aGlzLmRldGVybWluYW50KCk7XHJcbiAgICAgICAgICAgIGlmICggZGV0IDwgMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBzeCA9IC0gc3g7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwb3NpdGlvbi54ID0gdGVbIDEyIF07XHJcbiAgICAgICAgICAgIHBvc2l0aW9uLnkgPSB0ZVsgMTMgXTtcclxuICAgICAgICAgICAgcG9zaXRpb24ueiA9IHRlWyAxNCBdO1xyXG5cclxuICAgICAgICAgICAgLy8gc2NhbGUgdGhlIHJvdGF0aW9uIHBhcnRcclxuXHJcbiAgICAgICAgICAgIG1hdHJpeC5lbGVtZW50cy5zZXQoIHRoaXMuZWxlbWVudHMgKTsgLy8gYXQgdGhpcyBwb2ludCBtYXRyaXggaXMgaW5jb21wbGV0ZSBzbyB3ZSBjYW4ndCB1c2UgLmNvcHkoKVxyXG5cclxuICAgICAgICAgICAgdmFyIGludlNYID0gMSAvIHN4O1xyXG4gICAgICAgICAgICB2YXIgaW52U1kgPSAxIC8gc3k7XHJcbiAgICAgICAgICAgIHZhciBpbnZTWiA9IDEgLyBzejtcclxuXHJcbiAgICAgICAgICAgIG1hdHJpeC5lbGVtZW50c1sgMCBdICo9IGludlNYO1xyXG4gICAgICAgICAgICBtYXRyaXguZWxlbWVudHNbIDEgXSAqPSBpbnZTWDtcclxuICAgICAgICAgICAgbWF0cml4LmVsZW1lbnRzWyAyIF0gKj0gaW52U1g7XHJcblxyXG4gICAgICAgICAgICBtYXRyaXguZWxlbWVudHNbIDQgXSAqPSBpbnZTWTtcclxuICAgICAgICAgICAgbWF0cml4LmVsZW1lbnRzWyA1IF0gKj0gaW52U1k7XHJcbiAgICAgICAgICAgIG1hdHJpeC5lbGVtZW50c1sgNiBdICo9IGludlNZO1xyXG5cclxuICAgICAgICAgICAgbWF0cml4LmVsZW1lbnRzWyA4IF0gKj0gaW52U1o7XHJcbiAgICAgICAgICAgIG1hdHJpeC5lbGVtZW50c1sgOSBdICo9IGludlNaO1xyXG4gICAgICAgICAgICBtYXRyaXguZWxlbWVudHNbIDEwIF0gKj0gaW52U1o7XHJcblxyXG4gICAgICAgICAgICBxdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbWF0cml4ICk7XHJcblxyXG4gICAgICAgICAgICBzY2FsZS54ID0gc3g7XHJcbiAgICAgICAgICAgIHNjYWxlLnkgPSBzeTtcclxuICAgICAgICAgICAgc2NhbGUueiA9IHN6O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIG1ha2VGcnVzdHVtOiBmdW5jdGlvbiAoIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyICkge1xyXG5cclxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgICAgIHZhciB4ID0gMiAqIG5lYXIgLyAoIHJpZ2h0IC0gbGVmdCApO1xyXG4gICAgICAgIHZhciB5ID0gMiAqIG5lYXIgLyAoIHRvcCAtIGJvdHRvbSApO1xyXG5cclxuICAgICAgICB2YXIgYSA9ICggcmlnaHQgKyBsZWZ0ICkgLyAoIHJpZ2h0IC0gbGVmdCApO1xyXG4gICAgICAgIHZhciBiID0gKCB0b3AgKyBib3R0b20gKSAvICggdG9wIC0gYm90dG9tICk7XHJcbiAgICAgICAgdmFyIGMgPSAtICggZmFyICsgbmVhciApIC8gKCBmYXIgLSBuZWFyICk7XHJcbiAgICAgICAgdmFyIGQgPSAtIDIgKiBmYXIgKiBuZWFyIC8gKCBmYXIgLSBuZWFyICk7XHJcblxyXG4gICAgICAgIHRlWyAwIF0gPSB4O1x0dGVbIDQgXSA9IDA7XHR0ZVsgOCBdID0gYTtcdHRlWyAxMiBdID0gMDtcclxuICAgICAgICB0ZVsgMSBdID0gMDtcdHRlWyA1IF0gPSB5O1x0dGVbIDkgXSA9IGI7XHR0ZVsgMTMgXSA9IDA7XHJcbiAgICAgICAgdGVbIDIgXSA9IDA7XHR0ZVsgNiBdID0gMDtcdHRlWyAxMCBdID0gYztcdHRlWyAxNCBdID0gZDtcclxuICAgICAgICB0ZVsgMyBdID0gMDtcdHRlWyA3IF0gPSAwO1x0dGVbIDExIF0gPSAtIDE7XHR0ZVsgMTUgXSA9IDA7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbWFrZVBlcnNwZWN0aXZlOiBmdW5jdGlvbiAoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKSB7XHJcblxyXG4gICAgICAgIHZhciB5bWF4ID0gbmVhciAqIE1hdGgudGFuKCBUSFJFRS5NYXRoLmRlZ1RvUmFkKCBmb3YgKiAwLjUgKSApO1xyXG4gICAgICAgIHZhciB5bWluID0gLSB5bWF4O1xyXG4gICAgICAgIHZhciB4bWluID0geW1pbiAqIGFzcGVjdDtcclxuICAgICAgICB2YXIgeG1heCA9IHltYXggKiBhc3BlY3Q7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLm1ha2VGcnVzdHVtKCB4bWluLCB4bWF4LCB5bWluLCB5bWF4LCBuZWFyLCBmYXIgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG1ha2VPcnRob2dyYXBoaWM6IGZ1bmN0aW9uICggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIgKSB7XHJcblxyXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcbiAgICAgICAgdmFyIHcgPSByaWdodCAtIGxlZnQ7XHJcbiAgICAgICAgdmFyIGggPSB0b3AgLSBib3R0b207XHJcbiAgICAgICAgdmFyIHAgPSBmYXIgLSBuZWFyO1xyXG5cclxuICAgICAgICB2YXIgeCA9ICggcmlnaHQgKyBsZWZ0ICkgLyB3O1xyXG4gICAgICAgIHZhciB5ID0gKCB0b3AgKyBib3R0b20gKSAvIGg7XHJcbiAgICAgICAgdmFyIHogPSAoIGZhciArIG5lYXIgKSAvIHA7XHJcblxyXG4gICAgICAgIHRlWyAwIF0gPSAyIC8gdztcdHRlWyA0IF0gPSAwO1x0dGVbIDggXSA9IDA7XHR0ZVsgMTIgXSA9IC0geDtcclxuICAgICAgICB0ZVsgMSBdID0gMDtcdHRlWyA1IF0gPSAyIC8gaDtcdHRlWyA5IF0gPSAwO1x0dGVbIDEzIF0gPSAtIHk7XHJcbiAgICAgICAgdGVbIDIgXSA9IDA7XHR0ZVsgNiBdID0gMDtcdHRlWyAxMCBdID0gLSAyIC8gcDtcdHRlWyAxNCBdID0gLSB6O1xyXG4gICAgICAgIHRlWyAzIF0gPSAwO1x0dGVbIDcgXSA9IDA7XHR0ZVsgMTEgXSA9IDA7XHR0ZVsgMTUgXSA9IDE7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZXF1YWxzOiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcclxuXHJcbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICB2YXIgbWUgPSBtYXRyaXguZWxlbWVudHM7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDE2OyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCB0ZVsgaSBdICE9PSBtZVsgaSBdICkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xyXG5cclxuICAgICAgICB0aGlzLmVsZW1lbnRzLnNldCggYXJyYXkgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0b0FycmF5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHRlWyAwIF0sIHRlWyAxIF0sIHRlWyAyIF0sIHRlWyAzIF0sXHJcbiAgICAgICAgICAgIHRlWyA0IF0sIHRlWyA1IF0sIHRlWyA2IF0sIHRlWyA3IF0sXHJcbiAgICAgICAgICAgIHRlWyA4IF0sIHRlWyA5IF0sIHRlWyAxMCBdLCB0ZVsgMTEgXSxcclxuICAgICAgICAgICAgdGVbIDEyIF0sIHRlWyAxMyBdLCB0ZVsgMTQgXSwgdGVbIDE1IF1cclxuICAgICAgICBdO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL1JheS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICovXHJcblxyXG5USFJFRS5SYXkgPSBmdW5jdGlvbiAoIG9yaWdpbiwgZGlyZWN0aW9uICkge1xyXG5cclxuICAgIHRoaXMub3JpZ2luID0gKCBvcmlnaW4gIT09IHVuZGVmaW5lZCApID8gb3JpZ2luIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgIHRoaXMuZGlyZWN0aW9uID0gKCBkaXJlY3Rpb24gIT09IHVuZGVmaW5lZCApID8gZGlyZWN0aW9uIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5SYXkucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5SYXksXHJcblxyXG4gICAgc2V0OiBmdW5jdGlvbiAoIG9yaWdpbiwgZGlyZWN0aW9uICkge1xyXG5cclxuICAgICAgICB0aGlzLm9yaWdpbi5jb3B5KCBvcmlnaW4gKTtcclxuICAgICAgICB0aGlzLmRpcmVjdGlvbi5jb3B5KCBkaXJlY3Rpb24gKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb3B5OiBmdW5jdGlvbiAoIHJheSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5vcmlnaW4uY29weSggcmF5Lm9yaWdpbiApO1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aW9uLmNvcHkoIHJheS5kaXJlY3Rpb24gKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhdDogZnVuY3Rpb24gKCB0LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy5vcmlnaW4gKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJlY2FzdDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5vcmlnaW4uY29weSggdGhpcy5hdCggdCwgdjEgKSApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIGNsb3Nlc3RQb2ludFRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICByZXN1bHQuc3ViVmVjdG9ycyggcG9pbnQsIHRoaXMub3JpZ2luICk7XHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbkRpc3RhbmNlID0gcmVzdWx0LmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcclxuXHJcbiAgICAgICAgaWYgKCBkaXJlY3Rpb25EaXN0YW5jZSA8IDAgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMub3JpZ2luICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCBkaXJlY3Rpb25EaXN0YW5jZSApLmFkZCggdGhpcy5vcmlnaW4gKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVNxVG9Qb2ludCggcG9pbnQgKSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZGlzdGFuY2VTcVRvUG9pbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uRGlzdGFuY2UgPSB2MS5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5vcmlnaW4gKS5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XHJcblxyXG4gICAgICAgICAgICAvLyBwb2ludCBiZWhpbmQgdGhlIHJheVxyXG5cclxuICAgICAgICAgICAgaWYgKCBkaXJlY3Rpb25EaXN0YW5jZSA8IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdjEuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggZGlyZWN0aW9uRGlzdGFuY2UgKS5hZGQoIHRoaXMub3JpZ2luICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdjEuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIGRpc3RhbmNlU3FUb1NlZ21lbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlZ0NlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgdmFyIHNlZ0RpciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgdmFyIGRpZmYgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCB2MCwgdjEsIG9wdGlvbmFsUG9pbnRPblJheSwgb3B0aW9uYWxQb2ludE9uU2VnbWVudCApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGZyb20gaHR0cDovL3d3dy5nZW9tZXRyaWN0b29scy5jb20vTGliTWF0aGVtYXRpY3MvRGlzdGFuY2UvV201RGlzdFJheTNTZWdtZW50My5jcHBcclxuICAgICAgICAgICAgLy8gSXQgcmV0dXJucyB0aGUgbWluIGRpc3RhbmNlIGJldHdlZW4gdGhlIHJheSBhbmQgdGhlIHNlZ21lbnRcclxuICAgICAgICAgICAgLy8gZGVmaW5lZCBieSB2MCBhbmQgdjFcclxuICAgICAgICAgICAgLy8gSXQgY2FuIGFsc28gc2V0IHR3byBvcHRpb25hbCB0YXJnZXRzIDpcclxuICAgICAgICAgICAgLy8gLSBUaGUgY2xvc2VzdCBwb2ludCBvbiB0aGUgcmF5XHJcbiAgICAgICAgICAgIC8vIC0gVGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIHNlZ21lbnRcclxuXHJcbiAgICAgICAgICAgIHNlZ0NlbnRlci5jb3B5KCB2MCApLmFkZCggdjEgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XHJcbiAgICAgICAgICAgIHNlZ0Rpci5jb3B5KCB2MSApLnN1YiggdjAgKS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgZGlmZi5jb3B5KCB0aGlzLm9yaWdpbiApLnN1Yiggc2VnQ2VudGVyICk7XHJcblxyXG4gICAgICAgICAgICB2YXIgc2VnRXh0ZW50ID0gdjAuZGlzdGFuY2VUbyggdjEgKSAqIDAuNTtcclxuICAgICAgICAgICAgdmFyIGEwMSA9IC0gdGhpcy5kaXJlY3Rpb24uZG90KCBzZWdEaXIgKTtcclxuICAgICAgICAgICAgdmFyIGIwID0gZGlmZi5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XHJcbiAgICAgICAgICAgIHZhciBiMSA9IC0gZGlmZi5kb3QoIHNlZ0RpciApO1xyXG4gICAgICAgICAgICB2YXIgYyA9IGRpZmYubGVuZ3RoU3EoKTtcclxuICAgICAgICAgICAgdmFyIGRldCA9IE1hdGguYWJzKCAxIC0gYTAxICogYTAxICk7XHJcbiAgICAgICAgICAgIHZhciBzMCwgczEsIHNxckRpc3QsIGV4dERldDtcclxuXHJcbiAgICAgICAgICAgIGlmICggZGV0ID4gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgcmF5IGFuZCBzZWdtZW50IGFyZSBub3QgcGFyYWxsZWwuXHJcblxyXG4gICAgICAgICAgICAgICAgczAgPSBhMDEgKiBiMSAtIGIwO1xyXG4gICAgICAgICAgICAgICAgczEgPSBhMDEgKiBiMCAtIGIxO1xyXG4gICAgICAgICAgICAgICAgZXh0RGV0ID0gc2VnRXh0ZW50ICogZGV0O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggczAgPj0gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzMSA+PSAtIGV4dERldCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggczEgPD0gZXh0RGV0ICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlZ2lvbiAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNaW5pbXVtIGF0IGludGVyaW9yIHBvaW50cyBvZiByYXkgYW5kIHNlZ21lbnQuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGludkRldCA9IDEgLyBkZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCAqPSBpbnZEZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMSAqPSBpbnZEZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcXJEaXN0ID0gczAgKiAoIHMwICsgYTAxICogczEgKyAyICogYjAgKSArIHMxICogKCBhMDEgKiBzMCArIHMxICsgMiAqIGIxICkgKyBjO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWdpb24gMVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxID0gc2VnRXh0ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHMxICsgYjAgKSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlZ2lvbiA1XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzMSA9IC0gc2VnRXh0ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogczEgKyBiMCApICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHMxIDw9IC0gZXh0RGV0ICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVnaW9uIDRcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gTWF0aC5tYXgoIDAsIC0gKCAtIGEwMSAqIHNlZ0V4dGVudCArIGIwICkgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgczEgPSAoIHMwID4gMCApID8gLSBzZWdFeHRlbnQgOiBNYXRoLm1pbiggTWF0aC5tYXgoIC0gc2VnRXh0ZW50LCAtIGIxICksIHNlZ0V4dGVudCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBzMSA8PSBleHREZXQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWdpb24gM1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgczAgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzMSA9IE1hdGgubWluKCBNYXRoLm1heCggLSBzZWdFeHRlbnQsIC0gYjEgKSwgc2VnRXh0ZW50ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNxckRpc3QgPSBzMSAqICggczEgKyAyICogYjEgKSArIGM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWdpb24gMlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHNlZ0V4dGVudCArIGIwICkgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgczEgPSAoIHMwID4gMCApID8gc2VnRXh0ZW50IDogTWF0aC5taW4oIE1hdGgubWF4KCAtIHNlZ0V4dGVudCwgLSBiMSApLCBzZWdFeHRlbnQgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmF5IGFuZCBzZWdtZW50IGFyZSBwYXJhbGxlbC5cclxuXHJcbiAgICAgICAgICAgICAgICBzMSA9ICggYTAxID4gMCApID8gLSBzZWdFeHRlbnQgOiBzZWdFeHRlbnQ7XHJcbiAgICAgICAgICAgICAgICBzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogczEgKyBiMCApICk7XHJcbiAgICAgICAgICAgICAgICBzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBvcHRpb25hbFBvaW50T25SYXkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgb3B0aW9uYWxQb2ludE9uUmF5LmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIHMwICkuYWRkKCB0aGlzLm9yaWdpbiApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBvcHRpb25hbFBvaW50T25TZWdtZW50ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIG9wdGlvbmFsUG9pbnRPblNlZ21lbnQuY29weSggc2VnRGlyICkubXVsdGlwbHlTY2FsYXIoIHMxICkuYWRkKCBzZWdDZW50ZXIgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzcXJEaXN0O1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcblxyXG4gICAgaXNJbnRlcnNlY3Rpb25TcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIHNwaGVyZS5jZW50ZXIgKSA8PSBzcGhlcmUucmFkaXVzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgaW50ZXJzZWN0U3BoZXJlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIC8vIGZyb20gaHR0cDovL3d3dy5zY3JhdGNoYXBpeGVsLmNvbS9sZXNzb25zLzNkLWJhc2ljLWxlc3NvbnMvbGVzc29uLTctaW50ZXJzZWN0aW5nLXNpbXBsZS1zaGFwZXMvcmF5LXNwaGVyZS1pbnRlcnNlY3Rpb24vXHJcblxyXG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIHNwaGVyZSwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG4gICAgICAgICAgICB2MS5zdWJWZWN0b3JzKCBzcGhlcmUuY2VudGVyLCB0aGlzLm9yaWdpbiApO1xyXG5cclxuICAgICAgICAgICAgdmFyIHRjYSA9IHYxLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBkMiA9IHYxLmRvdCggdjEgKSAtIHRjYSAqIHRjYTtcclxuXHJcbiAgICAgICAgICAgIHZhciByYWRpdXMyID0gc3BoZXJlLnJhZGl1cyAqIHNwaGVyZS5yYWRpdXM7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGQyID4gcmFkaXVzMiApIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICAgICAgdmFyIHRoYyA9IE1hdGguc3FydCggcmFkaXVzMiAtIGQyICk7XHJcblxyXG4gICAgICAgICAgICAvLyB0MCA9IGZpcnN0IGludGVyc2VjdCBwb2ludCAtIGVudHJhbmNlIG9uIGZyb250IG9mIHNwaGVyZVxyXG4gICAgICAgICAgICB2YXIgdDAgPSB0Y2EgLSB0aGM7XHJcblxyXG4gICAgICAgICAgICAvLyB0MSA9IHNlY29uZCBpbnRlcnNlY3QgcG9pbnQgLSBleGl0IHBvaW50IG9uIGJhY2sgb2Ygc3BoZXJlXHJcbiAgICAgICAgICAgIHZhciB0MSA9IHRjYSArIHRoYztcclxuXHJcbiAgICAgICAgICAgIC8vIHRlc3QgdG8gc2VlIGlmIGJvdGggdDAgYW5kIHQxIGFyZSBiZWhpbmQgdGhlIHJheSAtIGlmIHNvLCByZXR1cm4gbnVsbFxyXG4gICAgICAgICAgICBpZiAoIHQwIDwgMCAmJiB0MSA8IDAgKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIC8vIHRlc3QgdG8gc2VlIGlmIHQwIGlzIGJlaGluZCB0aGUgcmF5OlxyXG4gICAgICAgICAgICAvLyBpZiBpdCBpcywgdGhlIHJheSBpcyBpbnNpZGUgdGhlIHNwaGVyZSwgc28gcmV0dXJuIHRoZSBzZWNvbmQgZXhpdCBwb2ludCBzY2FsZWQgYnkgdDEsXHJcbiAgICAgICAgICAgIC8vIGluIG9yZGVyIHRvIGFsd2F5cyByZXR1cm4gYW4gaW50ZXJzZWN0IHBvaW50IHRoYXQgaXMgaW4gZnJvbnQgb2YgdGhlIHJheS5cclxuICAgICAgICAgICAgaWYgKCB0MCA8IDAgKSByZXR1cm4gdGhpcy5hdCggdDEsIG9wdGlvbmFsVGFyZ2V0ICk7XHJcblxyXG4gICAgICAgICAgICAvLyBlbHNlIHQwIGlzIGluIGZyb250IG9mIHRoZSByYXksIHNvIHJldHVybiB0aGUgZmlyc3QgY29sbGlzaW9uIHBvaW50IHNjYWxlZCBieSB0MFxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdCggdDAsIG9wdGlvbmFsVGFyZ2V0ICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgaXNJbnRlcnNlY3Rpb25QbGFuZTogZnVuY3Rpb24gKCBwbGFuZSApIHtcclxuXHJcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHJheSBsaWVzIG9uIHRoZSBwbGFuZSBmaXJzdFxyXG5cclxuICAgICAgICB2YXIgZGlzdFRvUG9pbnQgPSBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHRoaXMub3JpZ2luICk7XHJcblxyXG4gICAgICAgIGlmICggZGlzdFRvUG9pbnQgPT09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZGVub21pbmF0b3IgPSBwbGFuZS5ub3JtYWwuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xyXG5cclxuICAgICAgICBpZiAoIGRlbm9taW5hdG9yICogZGlzdFRvUG9pbnQgPCAwICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcmF5IG9yaWdpbiBpcyBiZWhpbmQgdGhlIHBsYW5lIChhbmQgaXMgcG9pbnRpbmcgYmVoaW5kIGl0KVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBkaXN0YW5jZVRvUGxhbmU6IGZ1bmN0aW9uICggcGxhbmUgKSB7XHJcblxyXG4gICAgICAgIHZhciBkZW5vbWluYXRvciA9IHBsYW5lLm5vcm1hbC5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XHJcbiAgICAgICAgaWYgKCBkZW5vbWluYXRvciA9PT0gMCApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGxpbmUgaXMgY29wbGFuYXIsIHJldHVybiBvcmlnaW5cclxuICAgICAgICAgICAgaWYgKCBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHRoaXMub3JpZ2luICkgPT09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBOdWxsIGlzIHByZWZlcmFibGUgdG8gdW5kZWZpbmVkIHNpbmNlIHVuZGVmaW5lZCBtZWFucy4uLi4gaXQgaXMgdW5kZWZpbmVkXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdCA9IC0gKCB0aGlzLm9yaWdpbi5kb3QoIHBsYW5lLm5vcm1hbCApICsgcGxhbmUuY29uc3RhbnQgKSAvIGRlbm9taW5hdG9yO1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gaWYgdGhlIHJheSBuZXZlciBpbnRlcnNlY3RzIHRoZSBwbGFuZVxyXG5cclxuICAgICAgICByZXR1cm4gdCA+PSAwID8gdCA6ICBudWxsO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgaW50ZXJzZWN0UGxhbmU6IGZ1bmN0aW9uICggcGxhbmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuICAgICAgICB2YXIgdCA9IHRoaXMuZGlzdGFuY2VUb1BsYW5lKCBwbGFuZSApO1xyXG5cclxuICAgICAgICBpZiAoIHQgPT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5hdCggdCwgb3B0aW9uYWxUYXJnZXQgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGlzSW50ZXJzZWN0aW9uQm94OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciB2ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0Qm94KCBib3gsIHYgKSAhPT0gbnVsbDtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgaW50ZXJzZWN0Qm94OiBmdW5jdGlvbiAoIGJveCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG4gICAgICAgIC8vIGh0dHA6Ly93d3cuc2NyYXRjaGFwaXhlbC5jb20vbGVzc29ucy8zZC1iYXNpYy1sZXNzb25zL2xlc3Nvbi03LWludGVyc2VjdGluZy1zaW1wbGUtc2hhcGVzL3JheS1ib3gtaW50ZXJzZWN0aW9uL1xyXG5cclxuICAgICAgICB2YXIgdG1pbiwgdG1heCwgdHltaW4sIHR5bWF4LCB0em1pbiwgdHptYXg7XHJcblxyXG4gICAgICAgIHZhciBpbnZkaXJ4ID0gMSAvIHRoaXMuZGlyZWN0aW9uLngsXHJcbiAgICAgICAgICAgIGludmRpcnkgPSAxIC8gdGhpcy5kaXJlY3Rpb24ueSxcclxuICAgICAgICAgICAgaW52ZGlyeiA9IDEgLyB0aGlzLmRpcmVjdGlvbi56O1xyXG5cclxuICAgICAgICB2YXIgb3JpZ2luID0gdGhpcy5vcmlnaW47XHJcblxyXG4gICAgICAgIGlmICggaW52ZGlyeCA+PSAwICkge1xyXG5cclxuICAgICAgICAgICAgdG1pbiA9ICggYm94Lm1pbi54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XHJcbiAgICAgICAgICAgIHRtYXggPSAoIGJveC5tYXgueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgdG1pbiA9ICggYm94Lm1heC54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XHJcbiAgICAgICAgICAgIHRtYXggPSAoIGJveC5taW4ueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggaW52ZGlyeSA+PSAwICkge1xyXG5cclxuICAgICAgICAgICAgdHltaW4gPSAoIGJveC5taW4ueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xyXG4gICAgICAgICAgICB0eW1heCA9ICggYm94Lm1heC55IC0gb3JpZ2luLnkgKSAqIGludmRpcnk7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICB0eW1pbiA9ICggYm94Lm1heC55IC0gb3JpZ2luLnkgKSAqIGludmRpcnk7XHJcbiAgICAgICAgICAgIHR5bWF4ID0gKCBib3gubWluLnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoICggdG1pbiA+IHR5bWF4ICkgfHwgKCB0eW1pbiA+IHRtYXggKSApIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICAvLyBUaGVzZSBsaW5lcyBhbHNvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0bWluIG9yIHRtYXggaXMgTmFOXHJcbiAgICAgICAgLy8gKHJlc3VsdCBvZiAwICogSW5maW5pdHkpLiB4ICE9PSB4IHJldHVybnMgdHJ1ZSBpZiB4IGlzIE5hTlxyXG5cclxuICAgICAgICBpZiAoIHR5bWluID4gdG1pbiB8fCB0bWluICE9PSB0bWluICkgdG1pbiA9IHR5bWluO1xyXG5cclxuICAgICAgICBpZiAoIHR5bWF4IDwgdG1heCB8fCB0bWF4ICE9PSB0bWF4ICkgdG1heCA9IHR5bWF4O1xyXG5cclxuICAgICAgICBpZiAoIGludmRpcnogPj0gMCApIHtcclxuXHJcbiAgICAgICAgICAgIHR6bWluID0gKCBib3gubWluLnogLSBvcmlnaW4ueiApICogaW52ZGlyejtcclxuICAgICAgICAgICAgdHptYXggPSAoIGJveC5tYXgueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgdHptaW4gPSAoIGJveC5tYXgueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xyXG4gICAgICAgICAgICB0em1heCA9ICggYm94Lm1pbi56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCAoIHRtaW4gPiB0em1heCApIHx8ICggdHptaW4gPiB0bWF4ICkgKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgaWYgKCB0em1pbiA+IHRtaW4gfHwgdG1pbiAhPT0gdG1pbiApIHRtaW4gPSB0em1pbjtcclxuXHJcbiAgICAgICAgaWYgKCB0em1heCA8IHRtYXggfHwgdG1heCAhPT0gdG1heCApIHRtYXggPSB0em1heDtcclxuXHJcbiAgICAgICAgLy9yZXR1cm4gcG9pbnQgY2xvc2VzdCB0byB0aGUgcmF5IChwb3NpdGl2ZSBzaWRlKVxyXG5cclxuICAgICAgICBpZiAoIHRtYXggPCAwICkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmF0KCB0bWluID49IDAgPyB0bWluIDogdG1heCwgb3B0aW9uYWxUYXJnZXQgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGludGVyc2VjdFRyaWFuZ2xlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIG9mZnNldCBvcmlnaW4sIGVkZ2VzLCBhbmQgbm9ybWFsLlxyXG4gICAgICAgIHZhciBkaWZmID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICB2YXIgZWRnZTEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgIHZhciBlZGdlMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgdmFyIG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIGEsIGIsIGMsIGJhY2tmYWNlQ3VsbGluZywgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBmcm9tIGh0dHA6Ly93d3cuZ2VvbWV0cmljdG9vbHMuY29tL0xpYk1hdGhlbWF0aWNzL0ludGVyc2VjdGlvbi9XbTVJbnRyUmF5M1RyaWFuZ2xlMy5jcHBcclxuXHJcbiAgICAgICAgICAgIGVkZ2UxLnN1YlZlY3RvcnMoIGIsIGEgKTtcclxuICAgICAgICAgICAgZWRnZTIuc3ViVmVjdG9ycyggYywgYSApO1xyXG4gICAgICAgICAgICBub3JtYWwuY3Jvc3NWZWN0b3JzKCBlZGdlMSwgZWRnZTIgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNvbHZlIFEgKyB0KkQgPSBiMSpFMSArIGIyKkUyIChRID0ga0RpZmYsIEQgPSByYXkgZGlyZWN0aW9uLFxyXG4gICAgICAgICAgICAvLyBFMSA9IGtFZGdlMSwgRTIgPSBrRWRnZTIsIE4gPSBDcm9zcyhFMSxFMikpIGJ5XHJcbiAgICAgICAgICAgIC8vICAgfERvdChELE4pfCpiMSA9IHNpZ24oRG90KEQsTikpKkRvdChELENyb3NzKFEsRTIpKVxyXG4gICAgICAgICAgICAvLyAgIHxEb3QoRCxOKXwqYjIgPSBzaWduKERvdChELE4pKSpEb3QoRCxDcm9zcyhFMSxRKSlcclxuICAgICAgICAgICAgLy8gICB8RG90KEQsTil8KnQgPSAtc2lnbihEb3QoRCxOKSkqRG90KFEsTilcclxuICAgICAgICAgICAgdmFyIERkTiA9IHRoaXMuZGlyZWN0aW9uLmRvdCggbm9ybWFsICk7XHJcbiAgICAgICAgICAgIHZhciBzaWduO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBEZE4gPiAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggYmFja2ZhY2VDdWxsaW5nICkgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICBzaWduID0gMTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIERkTiA8IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgc2lnbiA9IC0gMTtcclxuICAgICAgICAgICAgICAgIERkTiA9IC0gRGROO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGRpZmYuc3ViVmVjdG9ycyggdGhpcy5vcmlnaW4sIGEgKTtcclxuICAgICAgICAgICAgdmFyIERkUXhFMiA9IHNpZ24gKiB0aGlzLmRpcmVjdGlvbi5kb3QoIGVkZ2UyLmNyb3NzVmVjdG9ycyggZGlmZiwgZWRnZTIgKSApO1xyXG5cclxuICAgICAgICAgICAgLy8gYjEgPCAwLCBubyBpbnRlcnNlY3Rpb25cclxuICAgICAgICAgICAgaWYgKCBEZFF4RTIgPCAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIERkRTF4USA9IHNpZ24gKiB0aGlzLmRpcmVjdGlvbi5kb3QoIGVkZ2UxLmNyb3NzKCBkaWZmICkgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGIyIDwgMCwgbm8gaW50ZXJzZWN0aW9uXHJcbiAgICAgICAgICAgIGlmICggRGRFMXhRIDwgMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGIxK2IyID4gMSwgbm8gaW50ZXJzZWN0aW9uXHJcbiAgICAgICAgICAgIGlmICggRGRReEUyICsgRGRFMXhRID4gRGROICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTGluZSBpbnRlcnNlY3RzIHRyaWFuZ2xlLCBjaGVjayBpZiByYXkgZG9lcy5cclxuICAgICAgICAgICAgdmFyIFFkTiA9IC0gc2lnbiAqIGRpZmYuZG90KCBub3JtYWwgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHQgPCAwLCBubyBpbnRlcnNlY3Rpb25cclxuICAgICAgICAgICAgaWYgKCBRZE4gPCAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUmF5IGludGVyc2VjdHMgdHJpYW5nbGUuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF0KCBRZE4gLyBEZE4sIG9wdGlvbmFsVGFyZ2V0ICk7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXg0ICkge1xyXG5cclxuICAgICAgICB0aGlzLmRpcmVjdGlvbi5hZGQoIHRoaXMub3JpZ2luICkuYXBwbHlNYXRyaXg0KCBtYXRyaXg0ICk7XHJcbiAgICAgICAgdGhpcy5vcmlnaW4uYXBwbHlNYXRyaXg0KCBtYXRyaXg0ICk7XHJcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24uc3ViKCB0aGlzLm9yaWdpbiApO1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGVxdWFsczogZnVuY3Rpb24gKCByYXkgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiByYXkub3JpZ2luLmVxdWFscyggdGhpcy5vcmlnaW4gKSAmJiByYXkuZGlyZWN0aW9uLmVxdWFscyggdGhpcy5kaXJlY3Rpb24gKTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9TcGhlcmUuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU3BoZXJlID0gZnVuY3Rpb24gKCBjZW50ZXIsIHJhZGl1cyApIHtcclxuXHJcbiAgICB0aGlzLmNlbnRlciA9ICggY2VudGVyICE9PSB1bmRlZmluZWQgKSA/IGNlbnRlciA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICB0aGlzLnJhZGl1cyA9ICggcmFkaXVzICE9PSB1bmRlZmluZWQgKSA/IHJhZGl1cyA6IDA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU3BoZXJlLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuU3BoZXJlLFxyXG5cclxuICAgIHNldDogZnVuY3Rpb24gKCBjZW50ZXIsIHJhZGl1cyApIHtcclxuXHJcbiAgICAgICAgdGhpcy5jZW50ZXIuY29weSggY2VudGVyICk7XHJcbiAgICAgICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0RnJvbVBvaW50czogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgYm94ID0gbmV3IFRIUkVFLkJveDMoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggcG9pbnRzLCBvcHRpb25hbENlbnRlciApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmNlbnRlcjtcclxuXHJcbiAgICAgICAgICAgIGlmICggb3B0aW9uYWxDZW50ZXIgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjZW50ZXIuY29weSggb3B0aW9uYWxDZW50ZXIgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgYm94LnNldEZyb21Qb2ludHMoIHBvaW50cyApLmNlbnRlciggY2VudGVyICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgbWF4UmFkaXVzU3EgPSAwO1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBtYXhSYWRpdXNTcSA9IE1hdGgubWF4KCBtYXhSYWRpdXNTcSwgY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludHNbIGkgXSApICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJhZGl1cyA9IE1hdGguc3FydCggbWF4UmFkaXVzU3EgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb3B5OiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5jZW50ZXIuY29weSggc3BoZXJlLmNlbnRlciApO1xyXG4gICAgICAgIHRoaXMucmFkaXVzID0gc3BoZXJlLnJhZGl1cztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBlbXB0eTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gKCB0aGlzLnJhZGl1cyA8PSAwICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb250YWluc1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuICAgICAgICByZXR1cm4gKCBwb2ludC5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5jZW50ZXIgKSA8PSAoIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuICAgICAgICByZXR1cm4gKCBwb2ludC5kaXN0YW5jZVRvKCB0aGlzLmNlbnRlciApIC0gdGhpcy5yYWRpdXMgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGludGVyc2VjdHNTcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xyXG5cclxuICAgICAgICB2YXIgcmFkaXVzU3VtID0gdGhpcy5yYWRpdXMgKyBzcGhlcmUucmFkaXVzO1xyXG5cclxuICAgICAgICByZXR1cm4gc3BoZXJlLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5jZW50ZXIgKSA8PSAoIHJhZGl1c1N1bSAqIHJhZGl1c1N1bSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2xhbXBQb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG4gICAgICAgIHZhciBkZWx0YUxlbmd0aFNxID0gdGhpcy5jZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XHJcblxyXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgIHJlc3VsdC5jb3B5KCBwb2ludCApO1xyXG5cclxuICAgICAgICBpZiAoIGRlbHRhTGVuZ3RoU3EgPiAoIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKSApIHtcclxuXHJcbiAgICAgICAgICAgIHJlc3VsdC5zdWIoIHRoaXMuY2VudGVyICkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5tdWx0aXBseVNjYWxhciggdGhpcy5yYWRpdXMgKS5hZGQoIHRoaXMuY2VudGVyICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldEJvdW5kaW5nQm94OiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuICAgICAgICB2YXIgYm94ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLkJveDMoKTtcclxuXHJcbiAgICAgICAgYm94LnNldCggdGhpcy5jZW50ZXIsIHRoaXMuY2VudGVyICk7XHJcbiAgICAgICAgYm94LmV4cGFuZEJ5U2NhbGFyKCB0aGlzLnJhZGl1cyApO1xyXG5cclxuICAgICAgICByZXR1cm4gYm94O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcclxuXHJcbiAgICAgICAgdGhpcy5jZW50ZXIuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcclxuICAgICAgICB0aGlzLnJhZGl1cyA9IHRoaXMucmFkaXVzICogbWF0cml4LmdldE1heFNjYWxlT25BeGlzKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcclxuXHJcbiAgICAgICAgdGhpcy5jZW50ZXIuYWRkKCBvZmZzZXQgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBlcXVhbHM6IGZ1bmN0aW9uICggc3BoZXJlICkge1xyXG5cclxuICAgICAgICByZXR1cm4gc3BoZXJlLmNlbnRlci5lcXVhbHMoIHRoaXMuY2VudGVyICkgJiYgKCBzcGhlcmUucmFkaXVzID09PSB0aGlzLnJhZGl1cyApO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL0ZydXN0dW0uanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXHJcbiAqL1xyXG5cclxuVEhSRUUuRnJ1c3R1bSA9IGZ1bmN0aW9uICggcDAsIHAxLCBwMiwgcDMsIHA0LCBwNSApIHtcclxuXHJcbiAgICB0aGlzLnBsYW5lcyA9IFtcclxuXHJcbiAgICAgICAgKCBwMCAhPT0gdW5kZWZpbmVkICkgPyBwMCA6IG5ldyBUSFJFRS5QbGFuZSgpLFxyXG4gICAgICAgICggcDEgIT09IHVuZGVmaW5lZCApID8gcDEgOiBuZXcgVEhSRUUuUGxhbmUoKSxcclxuICAgICAgICAoIHAyICE9PSB1bmRlZmluZWQgKSA/IHAyIDogbmV3IFRIUkVFLlBsYW5lKCksXHJcbiAgICAgICAgKCBwMyAhPT0gdW5kZWZpbmVkICkgPyBwMyA6IG5ldyBUSFJFRS5QbGFuZSgpLFxyXG4gICAgICAgICggcDQgIT09IHVuZGVmaW5lZCApID8gcDQgOiBuZXcgVEhSRUUuUGxhbmUoKSxcclxuICAgICAgICAoIHA1ICE9PSB1bmRlZmluZWQgKSA/IHA1IDogbmV3IFRIUkVFLlBsYW5lKClcclxuXHJcbiAgICBdO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkZydXN0dW0ucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5GcnVzdHVtLFxyXG5cclxuICAgIHNldDogZnVuY3Rpb24gKCBwMCwgcDEsIHAyLCBwMywgcDQsIHA1ICkge1xyXG5cclxuICAgICAgICB2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XHJcblxyXG4gICAgICAgIHBsYW5lc1sgMCBdLmNvcHkoIHAwICk7XHJcbiAgICAgICAgcGxhbmVzWyAxIF0uY29weSggcDEgKTtcclxuICAgICAgICBwbGFuZXNbIDIgXS5jb3B5KCBwMiApO1xyXG4gICAgICAgIHBsYW5lc1sgMyBdLmNvcHkoIHAzICk7XHJcbiAgICAgICAgcGxhbmVzWyA0IF0uY29weSggcDQgKTtcclxuICAgICAgICBwbGFuZXNbIDUgXS5jb3B5KCBwNSApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvcHk6IGZ1bmN0aW9uICggZnJ1c3R1bSApIHtcclxuXHJcbiAgICAgICAgdmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgcGxhbmVzWyBpIF0uY29weSggZnJ1c3R1bS5wbGFuZXNbIGkgXSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0RnJvbU1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuICAgICAgICB2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XHJcbiAgICAgICAgdmFyIG1lID0gbS5lbGVtZW50cztcclxuICAgICAgICB2YXIgbWUwID0gbWVbIDAgXSwgbWUxID0gbWVbIDEgXSwgbWUyID0gbWVbIDIgXSwgbWUzID0gbWVbIDMgXTtcclxuICAgICAgICB2YXIgbWU0ID0gbWVbIDQgXSwgbWU1ID0gbWVbIDUgXSwgbWU2ID0gbWVbIDYgXSwgbWU3ID0gbWVbIDcgXTtcclxuICAgICAgICB2YXIgbWU4ID0gbWVbIDggXSwgbWU5ID0gbWVbIDkgXSwgbWUxMCA9IG1lWyAxMCBdLCBtZTExID0gbWVbIDExIF07XHJcbiAgICAgICAgdmFyIG1lMTIgPSBtZVsgMTIgXSwgbWUxMyA9IG1lWyAxMyBdLCBtZTE0ID0gbWVbIDE0IF0sIG1lMTUgPSBtZVsgMTUgXTtcclxuXHJcbiAgICAgICAgcGxhbmVzWyAwIF0uc2V0Q29tcG9uZW50cyggbWUzIC0gbWUwLCBtZTcgLSBtZTQsIG1lMTEgLSBtZTgsIG1lMTUgLSBtZTEyICkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgcGxhbmVzWyAxIF0uc2V0Q29tcG9uZW50cyggbWUzICsgbWUwLCBtZTcgKyBtZTQsIG1lMTEgKyBtZTgsIG1lMTUgKyBtZTEyICkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgcGxhbmVzWyAyIF0uc2V0Q29tcG9uZW50cyggbWUzICsgbWUxLCBtZTcgKyBtZTUsIG1lMTEgKyBtZTksIG1lMTUgKyBtZTEzICkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgcGxhbmVzWyAzIF0uc2V0Q29tcG9uZW50cyggbWUzIC0gbWUxLCBtZTcgLSBtZTUsIG1lMTEgLSBtZTksIG1lMTUgLSBtZTEzICkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgcGxhbmVzWyA0IF0uc2V0Q29tcG9uZW50cyggbWUzIC0gbWUyLCBtZTcgLSBtZTYsIG1lMTEgLSBtZTEwLCBtZTE1IC0gbWUxNCApLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIHBsYW5lc1sgNSBdLnNldENvbXBvbmVudHMoIG1lMyArIG1lMiwgbWU3ICsgbWU2LCBtZTExICsgbWUxMCwgbWUxNSArIG1lMTQgKS5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBpbnRlcnNlY3RzT2JqZWN0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBzcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcclxuXHJcbiAgICAgICAgICAgIGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcclxuXHJcbiAgICAgICAgICAgIHNwaGVyZS5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApO1xyXG4gICAgICAgICAgICBzcGhlcmUuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcclxuXHJcbiAgICAgICAgdmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xyXG4gICAgICAgIHZhciBjZW50ZXIgPSBzcGhlcmUuY2VudGVyO1xyXG4gICAgICAgIHZhciBuZWdSYWRpdXMgPSAtIHNwaGVyZS5yYWRpdXM7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBwbGFuZXNbIGkgXS5kaXN0YW5jZVRvUG9pbnQoIGNlbnRlciApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBkaXN0YW5jZSA8IG5lZ1JhZGl1cyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBpbnRlcnNlY3RzQm94OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBwMSA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcbiAgICAgICAgICAgIHAyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgNiA7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHBsYW5lID0gcGxhbmVzWyBpIF07XHJcblxyXG4gICAgICAgICAgICAgICAgcDEueCA9IHBsYW5lLm5vcm1hbC54ID4gMCA/IGJveC5taW4ueCA6IGJveC5tYXgueDtcclxuICAgICAgICAgICAgICAgIHAyLnggPSBwbGFuZS5ub3JtYWwueCA+IDAgPyBib3gubWF4LnggOiBib3gubWluLng7XHJcbiAgICAgICAgICAgICAgICBwMS55ID0gcGxhbmUubm9ybWFsLnkgPiAwID8gYm94Lm1pbi55IDogYm94Lm1heC55O1xyXG4gICAgICAgICAgICAgICAgcDIueSA9IHBsYW5lLm5vcm1hbC55ID4gMCA/IGJveC5tYXgueSA6IGJveC5taW4ueTtcclxuICAgICAgICAgICAgICAgIHAxLnogPSBwbGFuZS5ub3JtYWwueiA+IDAgPyBib3gubWluLnogOiBib3gubWF4Lno7XHJcbiAgICAgICAgICAgICAgICBwMi56ID0gcGxhbmUubm9ybWFsLnogPiAwID8gYm94Lm1heC56IDogYm94Lm1pbi56O1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBkMSA9IHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggcDEgKTtcclxuICAgICAgICAgICAgICAgIHZhciBkMiA9IHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggcDIgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpZiBib3RoIG91dHNpZGUgcGxhbmUsIG5vIGludGVyc2VjdGlvblxyXG5cclxuICAgICAgICAgICAgICAgIGlmICggZDEgPCAwICYmIGQyIDwgMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcblxyXG4gICAgY29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcbiAgICAgICAgdmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBwbGFuZXNbIGkgXS5kaXN0YW5jZVRvUG9pbnQoIHBvaW50ICkgPCAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9QbGFuZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICovXHJcblxyXG5USFJFRS5QbGFuZSA9IGZ1bmN0aW9uICggbm9ybWFsLCBjb25zdGFudCApIHtcclxuXHJcbiAgICB0aGlzLm5vcm1hbCA9ICggbm9ybWFsICE9PSB1bmRlZmluZWQgKSA/IG5vcm1hbCA6IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICk7XHJcbiAgICB0aGlzLmNvbnN0YW50ID0gKCBjb25zdGFudCAhPT0gdW5kZWZpbmVkICkgPyBjb25zdGFudCA6IDA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGxhbmUucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5QbGFuZSxcclxuXHJcbiAgICBzZXQ6IGZ1bmN0aW9uICggbm9ybWFsLCBjb25zdGFudCApIHtcclxuXHJcbiAgICAgICAgdGhpcy5ub3JtYWwuY29weSggbm9ybWFsICk7XHJcbiAgICAgICAgdGhpcy5jb25zdGFudCA9IGNvbnN0YW50O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldENvbXBvbmVudHM6IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcclxuXHJcbiAgICAgICAgdGhpcy5ub3JtYWwuc2V0KCB4LCB5LCB6ICk7XHJcbiAgICAgICAgdGhpcy5jb25zdGFudCA9IHc7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQ6IGZ1bmN0aW9uICggbm9ybWFsLCBwb2ludCApIHtcclxuXHJcbiAgICAgICAgdGhpcy5ub3JtYWwuY29weSggbm9ybWFsICk7XHJcbiAgICAgICAgdGhpcy5jb25zdGFudCA9IC0gcG9pbnQuZG90KCB0aGlzLm5vcm1hbCApO1x0Ly8gbXVzdCBiZSB0aGlzLm5vcm1hbCwgbm90IG5vcm1hbCwgYXMgdGhpcy5ub3JtYWwgaXMgbm9ybWFsaXplZFxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZyb21Db3BsYW5hclBvaW50czogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgIHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIGEsIGIsIGMgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbm9ybWFsID0gdjEuc3ViVmVjdG9ycyggYywgYiApLmNyb3NzKCB2Mi5zdWJWZWN0b3JzKCBhLCBiICkgKS5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFE6IHNob3VsZCBhbiBlcnJvciBiZSB0aHJvd24gaWYgbm9ybWFsIGlzIHplcm8gKGUuZy4gZGVnZW5lcmF0ZSBwbGFuZSk/XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KCBub3JtYWwsIGEgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb3B5OiBmdW5jdGlvbiAoIHBsYW5lICkge1xyXG5cclxuICAgICAgICB0aGlzLm5vcm1hbC5jb3B5KCBwbGFuZS5ub3JtYWwgKTtcclxuICAgICAgICB0aGlzLmNvbnN0YW50ID0gcGxhbmUuY29uc3RhbnQ7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIC8vIE5vdGU6IHdpbGwgbGVhZCB0byBhIGRpdmlkZSBieSB6ZXJvIGlmIHRoZSBwbGFuZSBpcyBpbnZhbGlkLlxyXG5cclxuICAgICAgICB2YXIgaW52ZXJzZU5vcm1hbExlbmd0aCA9IDEuMCAvIHRoaXMubm9ybWFsLmxlbmd0aCgpO1xyXG4gICAgICAgIHRoaXMubm9ybWFsLm11bHRpcGx5U2NhbGFyKCBpbnZlcnNlTm9ybWFsTGVuZ3RoICk7XHJcbiAgICAgICAgdGhpcy5jb25zdGFudCAqPSBpbnZlcnNlTm9ybWFsTGVuZ3RoO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0aGlzLmNvbnN0YW50ICo9IC0gMTtcclxuICAgICAgICB0aGlzLm5vcm1hbC5uZWdhdGUoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLm5vcm1hbC5kb3QoIHBvaW50ICkgKyB0aGlzLmNvbnN0YW50O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZGlzdGFuY2VUb1NwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmRpc3RhbmNlVG9Qb2ludCggc3BoZXJlLmNlbnRlciApIC0gc3BoZXJlLnJhZGl1cztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHByb2plY3RQb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLm9ydGhvUG9pbnQoIHBvaW50LCBvcHRpb25hbFRhcmdldCApLnN1YiggcG9pbnQgKS5uZWdhdGUoKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG9ydGhvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuICAgICAgICB2YXIgcGVycGVuZGljdWxhck1hZ25pdHVkZSA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KCBwb2ludCApO1xyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMubm9ybWFsICkubXVsdGlwbHlTY2FsYXIoIHBlcnBlbmRpY3VsYXJNYWduaXR1ZGUgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGlzSW50ZXJzZWN0aW9uTGluZTogZnVuY3Rpb24gKCBsaW5lICkge1xyXG5cclxuICAgICAgICAvLyBOb3RlOiB0aGlzIHRlc3RzIGlmIGEgbGluZSBpbnRlcnNlY3RzIHRoZSBwbGFuZSwgbm90IHdoZXRoZXIgaXQgKG9yIGl0cyBlbmQtcG9pbnRzKSBhcmUgY29wbGFuYXIgd2l0aCBpdC5cclxuXHJcbiAgICAgICAgdmFyIHN0YXJ0U2lnbiA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KCBsaW5lLnN0YXJ0ICk7XHJcbiAgICAgICAgdmFyIGVuZFNpZ24gPSB0aGlzLmRpc3RhbmNlVG9Qb2ludCggbGluZS5lbmQgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuICggc3RhcnRTaWduIDwgMCAmJiBlbmRTaWduID4gMCApIHx8ICggZW5kU2lnbiA8IDAgJiYgc3RhcnRTaWduID4gMCApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCBsaW5lLCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGxpbmUuZGVsdGEoIHYxICk7XHJcblxyXG4gICAgICAgICAgICB2YXIgZGVub21pbmF0b3IgPSB0aGlzLm5vcm1hbC5kb3QoIGRpcmVjdGlvbiApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBkZW5vbWluYXRvciA9PT0gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBsaW5lIGlzIGNvcGxhbmFyLCByZXR1cm4gb3JpZ2luXHJcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMuZGlzdGFuY2VUb1BvaW50KCBsaW5lLnN0YXJ0ICkgPT09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuY29weSggbGluZS5zdGFydCApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVbnN1cmUgaWYgdGhpcyBpcyB0aGUgY29ycmVjdCBtZXRob2QgdG8gaGFuZGxlIHRoaXMgY2FzZS5cclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgdCA9IC0gKCBsaW5lLnN0YXJ0LmRvdCggdGhpcy5ub3JtYWwgKSArIHRoaXMuY29uc3RhbnQgKSAvIGRlbm9taW5hdG9yO1xyXG5cclxuICAgICAgICAgICAgaWYgKCB0IDwgMCB8fCB0ID4gMSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5jb3B5KCBkaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggbGluZS5zdGFydCApO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcblxyXG4gICAgY29wbGFuYXJQb2ludDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLm5vcm1hbCApLm11bHRpcGx5U2NhbGFyKCAtIHRoaXMuY29uc3RhbnQgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgIHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgdmFyIG0xID0gbmV3IFRIUkVFLk1hdHJpeDMoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggbWF0cml4LCBvcHRpb25hbE5vcm1hbE1hdHJpeCApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGNvbXB1dGUgbmV3IG5vcm1hbCBiYXNlZCBvbiB0aGVvcnkgaGVyZTpcclxuICAgICAgICAgICAgLy8gaHR0cDovL3d3dy5zb25naG8uY2Evb3BlbmdsL2dsX25vcm1hbHRyYW5zZm9ybS5odG1sXHJcbiAgICAgICAgICAgIHZhciBub3JtYWxNYXRyaXggPSBvcHRpb25hbE5vcm1hbE1hdHJpeCB8fCBtMS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xyXG4gICAgICAgICAgICB2YXIgbmV3Tm9ybWFsID0gdjEuY29weSggdGhpcy5ub3JtYWwgKS5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApO1xyXG5cclxuICAgICAgICAgICAgdmFyIG5ld0NvcGxhbmFyUG9pbnQgPSB0aGlzLmNvcGxhbmFyUG9pbnQoIHYyICk7XHJcbiAgICAgICAgICAgIG5ld0NvcGxhbmFyUG9pbnQuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoIG5ld05vcm1hbCwgbmV3Q29wbGFuYXJQb2ludCApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBvZmZzZXQgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY29uc3RhbnQgPSB0aGlzLmNvbnN0YW50IC0gb2Zmc2V0LmRvdCggdGhpcy5ub3JtYWwgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBlcXVhbHM6IGZ1bmN0aW9uICggcGxhbmUgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBwbGFuZS5ub3JtYWwuZXF1YWxzKCB0aGlzLm5vcm1hbCApICYmICggcGxhbmUuY29uc3RhbnQgPT09IHRoaXMuY29uc3RhbnQgKTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9NYXRoLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5NYXRoID0ge1xyXG5cclxuICAgIGdlbmVyYXRlVVVJRDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAvLyBodHRwOi8vd3d3LmJyb29mYS5jb20vVG9vbHMvTWF0aC51dWlkLmh0bVxyXG5cclxuICAgICAgICB2YXIgY2hhcnMgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonLnNwbGl0KCAnJyApO1xyXG4gICAgICAgIHZhciB1dWlkID0gbmV3IEFycmF5KCAzNiApO1xyXG4gICAgICAgIHZhciBybmQgPSAwLCByO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgMzY7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBpID09PSA4IHx8IGkgPT09IDEzIHx8IGkgPT09IDE4IHx8IGkgPT09IDIzICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB1dWlkWyBpIF0gPSAnLSc7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggaSA9PT0gMTQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHV1aWRbIGkgXSA9ICc0JztcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHJuZCA8PSAweDAyICkgcm5kID0gMHgyMDAwMDAwICsgKCBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwICkgfCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHIgPSBybmQgJiAweGY7XHJcbiAgICAgICAgICAgICAgICAgICAgcm5kID0gcm5kID4+IDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdXVpZFsgaSBdID0gY2hhcnNbICggaSA9PT0gMTkgKSA/ICggciAmIDB4MyApIHwgMHg4IDogciBdO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB1dWlkLmpvaW4oICcnICk7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIGNsYW1wOiBmdW5jdGlvbiAoIHZhbHVlLCBtaW4sIG1heCApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KCBtaW4sIE1hdGgubWluKCBtYXgsIHZhbHVlICkgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIGNvbXB1dGUgZXVjbGlkaWFuIG1vZHVsbyBvZiBtICUgblxyXG4gICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9kdWxvX29wZXJhdGlvblxyXG5cclxuICAgIGV1Y2xpZGVhbk1vZHVsbzogZnVuY3Rpb24gKCBuLCBtICkge1xyXG5cclxuICAgICAgICByZXR1cm4gKCAoIG4gJSBtICkgKyBtICkgJSBtO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLy8gTGluZWFyIG1hcHBpbmcgZnJvbSByYW5nZSA8YTEsIGEyPiB0byByYW5nZSA8YjEsIGIyPlxyXG5cclxuICAgIG1hcExpbmVhcjogZnVuY3Rpb24gKCB4LCBhMSwgYTIsIGIxLCBiMiApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIGIxICsgKCB4IC0gYTEgKSAqICggYjIgLSBiMSApIC8gKCBhMiAtIGExICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Ntb290aHN0ZXBcclxuXHJcbiAgICBzbW9vdGhzdGVwOiBmdW5jdGlvbiAoIHgsIG1pbiwgbWF4ICkge1xyXG5cclxuICAgICAgICBpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XHJcbiAgICAgICAgaWYgKCB4ID49IG1heCApIHJldHVybiAxO1xyXG5cclxuICAgICAgICB4ID0gKCB4IC0gbWluICkgLyAoIG1heCAtIG1pbiApO1xyXG5cclxuICAgICAgICByZXR1cm4geCAqIHggKiAoIDMgLSAyICogeCApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc21vb3RoZXJzdGVwOiBmdW5jdGlvbiAoIHgsIG1pbiwgbWF4ICkge1xyXG5cclxuICAgICAgICBpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XHJcbiAgICAgICAgaWYgKCB4ID49IG1heCApIHJldHVybiAxO1xyXG5cclxuICAgICAgICB4ID0gKCB4IC0gbWluICkgLyAoIG1heCAtIG1pbiApO1xyXG5cclxuICAgICAgICByZXR1cm4geCAqIHggKiB4ICogKCB4ICogKCB4ICogNiAtIDE1ICkgKyAxMCApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLy8gUmFuZG9tIGZsb2F0IGZyb20gPDAsIDE+IHdpdGggMTYgYml0cyBvZiByYW5kb21uZXNzXHJcbiAgICAvLyAoc3RhbmRhcmQgTWF0aC5yYW5kb20oKSBjcmVhdGVzIHJlcGV0aXRpdmUgcGF0dGVybnMgd2hlbiBhcHBsaWVkIG92ZXIgbGFyZ2VyIHNwYWNlKVxyXG5cclxuICAgIHJhbmRvbTE2OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiAoIDY1MjgwICogTWF0aC5yYW5kb20oKSArIDI1NSAqIE1hdGgucmFuZG9tKCkgKSAvIDY1NTM1O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLy8gUmFuZG9tIGludGVnZXIgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxyXG5cclxuICAgIHJhbmRJbnQ6IGZ1bmN0aW9uICggbG93LCBoaWdoICkge1xyXG5cclxuICAgICAgICByZXR1cm4gbG93ICsgTWF0aC5mbG9vciggTWF0aC5yYW5kb20oKSAqICggaGlnaCAtIGxvdyArIDEgKSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLy8gUmFuZG9tIGZsb2F0IGZyb20gPGxvdywgaGlnaD4gaW50ZXJ2YWxcclxuXHJcbiAgICByYW5kRmxvYXQ6IGZ1bmN0aW9uICggbG93LCBoaWdoICkge1xyXG5cclxuICAgICAgICByZXR1cm4gbG93ICsgTWF0aC5yYW5kb20oKSAqICggaGlnaCAtIGxvdyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLy8gUmFuZG9tIGZsb2F0IGZyb20gPC1yYW5nZS8yLCByYW5nZS8yPiBpbnRlcnZhbFxyXG5cclxuICAgIHJhbmRGbG9hdFNwcmVhZDogZnVuY3Rpb24gKCByYW5nZSApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJhbmdlICogKCAwLjUgLSBNYXRoLnJhbmRvbSgpICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBkZWdUb1JhZDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgZGVncmVlVG9SYWRpYW5zRmFjdG9yID0gTWF0aC5QSSAvIDE4MDtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggZGVncmVlcyApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBkZWdyZWVzICogZGVncmVlVG9SYWRpYW5zRmFjdG9yO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICByYWRUb0RlZzogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgcmFkaWFuVG9EZWdyZWVzRmFjdG9yID0gMTgwIC8gTWF0aC5QSTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggcmFkaWFucyApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiByYWRpYW5zICogcmFkaWFuVG9EZWdyZWVzRmFjdG9yO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBpc1Bvd2VyT2ZUd286IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiAoIHZhbHVlICYgKCB2YWx1ZSAtIDEgKSApID09PSAwICYmIHZhbHVlICE9PSAwO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbmVhcmVzdFBvd2VyT2ZUd286IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBNYXRoLnBvdyggMiwgTWF0aC5yb3VuZCggTWF0aC5sb2coIHZhbHVlICkgLyBNYXRoLkxOMiApICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBuZXh0UG93ZXJPZlR3bzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgdmFsdWUgLS07XHJcbiAgICAgICAgdmFsdWUgfD0gdmFsdWUgPj4gMTtcclxuICAgICAgICB2YWx1ZSB8PSB2YWx1ZSA+PiAyO1xyXG4gICAgICAgIHZhbHVlIHw9IHZhbHVlID4+IDQ7XHJcbiAgICAgICAgdmFsdWUgfD0gdmFsdWUgPj4gODtcclxuICAgICAgICB2YWx1ZSB8PSB2YWx1ZSA+PiAxNjtcclxuICAgICAgICB2YWx1ZSArKztcclxuXHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL1NwbGluZS5qc1xyXG5cclxuLyoqXHJcbiAqIFNwbGluZSBmcm9tIFR3ZWVuLmpzLCBzbGlnaHRseSBvcHRpbWl6ZWQgKGFuZCB0cmFzaGVkKVxyXG4gKiBodHRwOi8vc29sZS5naXRodWIuY29tL3R3ZWVuLmpzL2V4YW1wbGVzLzA1X3NwbGluZS5odG1sXHJcbiAqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU3BsaW5lID0gZnVuY3Rpb24gKCBwb2ludHMgKSB7XHJcblxyXG4gICAgdGhpcy5wb2ludHMgPSBwb2ludHM7XHJcblxyXG4gICAgdmFyIGMgPSBbXSwgdjMgPSB7IHg6IDAsIHk6IDAsIHo6IDAgfSxcclxuICAgICAgICBwb2ludCwgaW50UG9pbnQsIHdlaWdodCwgdzIsIHczLFxyXG4gICAgICAgIHBhLCBwYiwgcGMsIHBkO1xyXG5cclxuICAgIHRoaXMuaW5pdEZyb21BcnJheSA9IGZ1bmN0aW9uICggYSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5wb2ludHMgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnBvaW50c1sgaSBdID0geyB4OiBhWyBpIF1bIDAgXSwgeTogYVsgaSBdWyAxIF0sIHo6IGFbIGkgXVsgMiBdIH07XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIGsgKSB7XHJcblxyXG4gICAgICAgIHBvaW50ID0gKCB0aGlzLnBvaW50cy5sZW5ndGggLSAxICkgKiBrO1xyXG4gICAgICAgIGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcclxuICAgICAgICB3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xyXG5cclxuICAgICAgICBjWyAwIF0gPSBpbnRQb2ludCA9PT0gMCA/IGludFBvaW50IDogaW50UG9pbnQgLSAxO1xyXG4gICAgICAgIGNbIDEgXSA9IGludFBvaW50O1xyXG4gICAgICAgIGNbIDIgXSA9IGludFBvaW50ICA+IHRoaXMucG9pbnRzLmxlbmd0aCAtIDIgPyB0aGlzLnBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAxO1xyXG4gICAgICAgIGNbIDMgXSA9IGludFBvaW50ICA+IHRoaXMucG9pbnRzLmxlbmd0aCAtIDMgPyB0aGlzLnBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAyO1xyXG5cclxuICAgICAgICBwYSA9IHRoaXMucG9pbnRzWyBjWyAwIF0gXTtcclxuICAgICAgICBwYiA9IHRoaXMucG9pbnRzWyBjWyAxIF0gXTtcclxuICAgICAgICBwYyA9IHRoaXMucG9pbnRzWyBjWyAyIF0gXTtcclxuICAgICAgICBwZCA9IHRoaXMucG9pbnRzWyBjWyAzIF0gXTtcclxuXHJcbiAgICAgICAgdzIgPSB3ZWlnaHQgKiB3ZWlnaHQ7XHJcbiAgICAgICAgdzMgPSB3ZWlnaHQgKiB3MjtcclxuXHJcbiAgICAgICAgdjMueCA9IGludGVycG9sYXRlKCBwYS54LCBwYi54LCBwYy54LCBwZC54LCB3ZWlnaHQsIHcyLCB3MyApO1xyXG4gICAgICAgIHYzLnkgPSBpbnRlcnBvbGF0ZSggcGEueSwgcGIueSwgcGMueSwgcGQueSwgd2VpZ2h0LCB3MiwgdzMgKTtcclxuICAgICAgICB2My56ID0gaW50ZXJwb2xhdGUoIHBhLnosIHBiLnosIHBjLnosIHBkLnosIHdlaWdodCwgdzIsIHczICk7XHJcblxyXG4gICAgICAgIHJldHVybiB2MztcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZ2V0Q29udHJvbFBvaW50c0FycmF5ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgaSwgcCwgbCA9IHRoaXMucG9pbnRzLmxlbmd0aCxcclxuICAgICAgICAgICAgY29vcmRzID0gW107XHJcblxyXG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHAgPSB0aGlzLnBvaW50c1sgaSBdO1xyXG4gICAgICAgICAgICBjb29yZHNbIGkgXSA9IFsgcC54LCBwLnksIHAueiBdO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjb29yZHM7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBhcHByb3hpbWF0ZSBsZW5ndGggYnkgc3VtbWluZyBsaW5lYXIgc2VnbWVudHNcclxuXHJcbiAgICB0aGlzLmdldExlbmd0aCA9IGZ1bmN0aW9uICggblN1YkRpdmlzaW9ucyApIHtcclxuXHJcbiAgICAgICAgdmFyIGksIGluZGV4LCBuU2FtcGxlcywgcG9zaXRpb24sXHJcbiAgICAgICAgICAgIHBvaW50ID0gMCwgaW50UG9pbnQgPSAwLCBvbGRJbnRQb2ludCA9IDAsXHJcbiAgICAgICAgICAgIG9sZFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuICAgICAgICAgICAgdG1wVmVjID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuICAgICAgICAgICAgY2h1bmtMZW5ndGhzID0gW10sXHJcbiAgICAgICAgICAgIHRvdGFsTGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgLy8gZmlyc3QgcG9pbnQgaGFzIDAgbGVuZ3RoXHJcblxyXG4gICAgICAgIGNodW5rTGVuZ3Roc1sgMCBdID0gMDtcclxuXHJcbiAgICAgICAgaWYgKCAhIG5TdWJEaXZpc2lvbnMgKSBuU3ViRGl2aXNpb25zID0gMTAwO1xyXG5cclxuICAgICAgICBuU2FtcGxlcyA9IHRoaXMucG9pbnRzLmxlbmd0aCAqIG5TdWJEaXZpc2lvbnM7XHJcblxyXG4gICAgICAgIG9sZFBvc2l0aW9uLmNvcHkoIHRoaXMucG9pbnRzWyAwIF0gKTtcclxuXHJcbiAgICAgICAgZm9yICggaSA9IDE7IGkgPCBuU2FtcGxlczsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIGluZGV4ID0gaSAvIG5TYW1wbGVzO1xyXG5cclxuICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLmdldFBvaW50KCBpbmRleCApO1xyXG4gICAgICAgICAgICB0bXBWZWMuY29weSggcG9zaXRpb24gKTtcclxuXHJcbiAgICAgICAgICAgIHRvdGFsTGVuZ3RoICs9IHRtcFZlYy5kaXN0YW5jZVRvKCBvbGRQb3NpdGlvbiApO1xyXG5cclxuICAgICAgICAgICAgb2xkUG9zaXRpb24uY29weSggcG9zaXRpb24gKTtcclxuXHJcbiAgICAgICAgICAgIHBvaW50ID0gKCB0aGlzLnBvaW50cy5sZW5ndGggLSAxICkgKiBpbmRleDtcclxuICAgICAgICAgICAgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBpbnRQb2ludCAhPT0gb2xkSW50UG9pbnQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY2h1bmtMZW5ndGhzWyBpbnRQb2ludCBdID0gdG90YWxMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBvbGRJbnRQb2ludCA9IGludFBvaW50O1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGxhc3QgcG9pbnQgZW5kcyB3aXRoIHRvdGFsIGxlbmd0aFxyXG5cclxuICAgICAgICBjaHVua0xlbmd0aHNbIGNodW5rTGVuZ3Rocy5sZW5ndGggXSA9IHRvdGFsTGVuZ3RoO1xyXG5cclxuICAgICAgICByZXR1cm4geyBjaHVua3M6IGNodW5rTGVuZ3RocywgdG90YWw6IHRvdGFsTGVuZ3RoIH07XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnJlcGFyYW1ldHJpemVCeUFyY0xlbmd0aCA9IGZ1bmN0aW9uICggc2FtcGxpbmdDb2VmICkge1xyXG5cclxuICAgICAgICB2YXIgaSwgaixcclxuICAgICAgICAgICAgaW5kZXgsIGluZGV4Q3VycmVudCwgaW5kZXhOZXh0LFxyXG4gICAgICAgICAgICByZWFsRGlzdGFuY2UsXHJcbiAgICAgICAgICAgIHNhbXBsaW5nLCBwb3NpdGlvbixcclxuICAgICAgICAgICAgbmV3cG9pbnRzID0gW10sXHJcbiAgICAgICAgICAgIHRtcFZlYyA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcbiAgICAgICAgICAgIHNsID0gdGhpcy5nZXRMZW5ndGgoKTtcclxuXHJcbiAgICAgICAgbmV3cG9pbnRzLnB1c2goIHRtcFZlYy5jb3B5KCB0aGlzLnBvaW50c1sgMCBdICkuY2xvbmUoKSApO1xyXG5cclxuICAgICAgICBmb3IgKCBpID0gMTsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIC8vdG1wVmVjLmNvcHkoIHRoaXMucG9pbnRzWyBpIC0gMSBdICk7XHJcbiAgICAgICAgICAgIC8vbGluZWFyRGlzdGFuY2UgPSB0bXBWZWMuZGlzdGFuY2VUbyggdGhpcy5wb2ludHNbIGkgXSApO1xyXG5cclxuICAgICAgICAgICAgcmVhbERpc3RhbmNlID0gc2wuY2h1bmtzWyBpIF0gLSBzbC5jaHVua3NbIGkgLSAxIF07XHJcblxyXG4gICAgICAgICAgICBzYW1wbGluZyA9IE1hdGguY2VpbCggc2FtcGxpbmdDb2VmICogcmVhbERpc3RhbmNlIC8gc2wudG90YWwgKTtcclxuXHJcbiAgICAgICAgICAgIGluZGV4Q3VycmVudCA9ICggaSAtIDEgKSAvICggdGhpcy5wb2ludHMubGVuZ3RoIC0gMSApO1xyXG4gICAgICAgICAgICBpbmRleE5leHQgPSBpIC8gKCB0aGlzLnBvaW50cy5sZW5ndGggLSAxICk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCBqID0gMTsgaiA8IHNhbXBsaW5nIC0gMTsgaiArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpbmRleCA9IGluZGV4Q3VycmVudCArIGogKiAoIDEgLyBzYW1wbGluZyApICogKCBpbmRleE5leHQgLSBpbmRleEN1cnJlbnQgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuZ2V0UG9pbnQoIGluZGV4ICk7XHJcbiAgICAgICAgICAgICAgICBuZXdwb2ludHMucHVzaCggdG1wVmVjLmNvcHkoIHBvc2l0aW9uICkuY2xvbmUoKSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbmV3cG9pbnRzLnB1c2goIHRtcFZlYy5jb3B5KCB0aGlzLnBvaW50c1sgaSBdICkuY2xvbmUoKSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucG9pbnRzID0gbmV3cG9pbnRzO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLy8gQ2F0bXVsbC1Sb21cclxuXHJcbiAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZSggcDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0MyApIHtcclxuXHJcbiAgICAgICAgdmFyIHYwID0gKCBwMiAtIHAwICkgKiAwLjUsXHJcbiAgICAgICAgICAgIHYxID0gKCBwMyAtIHAxICkgKiAwLjU7XHJcblxyXG4gICAgICAgIHJldHVybiAoIDIgKiAoIHAxIC0gcDIgKSArIHYwICsgdjEgKSAqIHQzICsgKCAtIDMgKiAoIHAxIC0gcDIgKSAtIDIgKiB2MCAtIHYxICkgKiB0MiArIHYwICogdCArIHAxO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL1RyaWFuZ2xlLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlRyaWFuZ2xlID0gZnVuY3Rpb24gKCBhLCBiLCBjICkge1xyXG5cclxuICAgIHRoaXMuYSA9ICggYSAhPT0gdW5kZWZpbmVkICkgPyBhIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgIHRoaXMuYiA9ICggYiAhPT0gdW5kZWZpbmVkICkgPyBiIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgIHRoaXMuYyA9ICggYyAhPT0gdW5kZWZpbmVkICkgPyBjIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5UcmlhbmdsZS5ub3JtYWwgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIHYwID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCBhLCBiLCBjLCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgIHJlc3VsdC5zdWJWZWN0b3JzKCBjLCBiICk7XHJcbiAgICAgICAgdjAuc3ViVmVjdG9ycyggYSwgYiApO1xyXG4gICAgICAgIHJlc3VsdC5jcm9zcyggdjAgKTtcclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdExlbmd0aFNxID0gcmVzdWx0Lmxlbmd0aFNxKCk7XHJcbiAgICAgICAgaWYgKCByZXN1bHRMZW5ndGhTcSA+IDAgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0Lm11bHRpcGx5U2NhbGFyKCAxIC8gTWF0aC5zcXJ0KCByZXN1bHRMZW5ndGhTcSApICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zZXQoIDAsIDAsIDAgKTtcclxuXHJcbiAgICB9O1xyXG5cclxufSgpO1xyXG5cclxuLy8gc3RhdGljL2luc3RhbmNlIG1ldGhvZCB0byBjYWxjdWxhdGUgYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXNcclxuLy8gYmFzZWQgb246IGh0dHA6Ly93d3cuYmxhY2twYXduLmNvbS90ZXh0cy9wb2ludGlucG9seS9kZWZhdWx0Lmh0bWxcclxuVEhSRUUuVHJpYW5nbGUuYmFyeWNvb3JkRnJvbVBvaW50ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciB2MCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgdmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCBwb2ludCwgYSwgYiwgYywgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG4gICAgICAgIHYwLnN1YlZlY3RvcnMoIGMsIGEgKTtcclxuICAgICAgICB2MS5zdWJWZWN0b3JzKCBiLCBhICk7XHJcbiAgICAgICAgdjIuc3ViVmVjdG9ycyggcG9pbnQsIGEgKTtcclxuXHJcbiAgICAgICAgdmFyIGRvdDAwID0gdjAuZG90KCB2MCApO1xyXG4gICAgICAgIHZhciBkb3QwMSA9IHYwLmRvdCggdjEgKTtcclxuICAgICAgICB2YXIgZG90MDIgPSB2MC5kb3QoIHYyICk7XHJcbiAgICAgICAgdmFyIGRvdDExID0gdjEuZG90KCB2MSApO1xyXG4gICAgICAgIHZhciBkb3QxMiA9IHYxLmRvdCggdjIgKTtcclxuXHJcbiAgICAgICAgdmFyIGRlbm9tID0gKCBkb3QwMCAqIGRvdDExIC0gZG90MDEgKiBkb3QwMSApO1xyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgLy8gY29sbGluZWFyIG9yIHNpbmd1bGFyIHRyaWFuZ2xlXHJcbiAgICAgICAgaWYgKCBkZW5vbSA9PT0gMCApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGFyYml0cmFyeSBsb2NhdGlvbiBvdXRzaWRlIG9mIHRyaWFuZ2xlP1xyXG4gICAgICAgICAgICAvLyBub3Qgc3VyZSBpZiB0aGlzIGlzIHRoZSBiZXN0IGlkZWEsIG1heWJlIHNob3VsZCBiZSByZXR1cm5pbmcgdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuc2V0KCAtIDIsIC0gMSwgLSAxICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGludkRlbm9tID0gMSAvIGRlbm9tO1xyXG4gICAgICAgIHZhciB1ID0gKCBkb3QxMSAqIGRvdDAyIC0gZG90MDEgKiBkb3QxMiApICogaW52RGVub207XHJcbiAgICAgICAgdmFyIHYgPSAoIGRvdDAwICogZG90MTIgLSBkb3QwMSAqIGRvdDAyICkgKiBpbnZEZW5vbTtcclxuXHJcbiAgICAgICAgLy8gYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXMgbXVzdCBhbHdheXMgc3VtIHRvIDFcclxuICAgICAgICByZXR1cm4gcmVzdWx0LnNldCggMSAtIHUgLSB2LCB2LCB1ICk7XHJcblxyXG4gICAgfTtcclxuXHJcbn0oKTtcclxuXHJcblRIUkVFLlRyaWFuZ2xlLmNvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCBwb2ludCwgYSwgYiwgYyApIHtcclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFRIUkVFLlRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCggcG9pbnQsIGEsIGIsIGMsIHYxICk7XHJcblxyXG4gICAgICAgIHJldHVybiAoIHJlc3VsdC54ID49IDAgKSAmJiAoIHJlc3VsdC55ID49IDAgKSAmJiAoICggcmVzdWx0LnggKyByZXN1bHQueSApIDw9IDEgKTtcclxuXHJcbiAgICB9O1xyXG5cclxufSgpO1xyXG5cclxuVEhSRUUuVHJpYW5nbGUucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5UcmlhbmdsZSxcclxuXHJcbiAgICBzZXQ6IGZ1bmN0aW9uICggYSwgYiwgYyApIHtcclxuXHJcbiAgICAgICAgdGhpcy5hLmNvcHkoIGEgKTtcclxuICAgICAgICB0aGlzLmIuY29weSggYiApO1xyXG4gICAgICAgIHRoaXMuYy5jb3B5KCBjICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0RnJvbVBvaW50c0FuZEluZGljZXM6IGZ1bmN0aW9uICggcG9pbnRzLCBpMCwgaTEsIGkyICkge1xyXG5cclxuICAgICAgICB0aGlzLmEuY29weSggcG9pbnRzWyBpMCBdICk7XHJcbiAgICAgICAgdGhpcy5iLmNvcHkoIHBvaW50c1sgaTEgXSApO1xyXG4gICAgICAgIHRoaXMuYy5jb3B5KCBwb2ludHNbIGkyIF0gKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb3B5OiBmdW5jdGlvbiAoIHRyaWFuZ2xlICkge1xyXG5cclxuICAgICAgICB0aGlzLmEuY29weSggdHJpYW5nbGUuYSApO1xyXG4gICAgICAgIHRoaXMuYi5jb3B5KCB0cmlhbmdsZS5iICk7XHJcbiAgICAgICAgdGhpcy5jLmNvcHkoIHRyaWFuZ2xlLmMgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhcmVhOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciB2MCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgICAgIHYwLnN1YlZlY3RvcnMoIHRoaXMuYywgdGhpcy5iICk7XHJcbiAgICAgICAgICAgIHYxLnN1YlZlY3RvcnMoIHRoaXMuYSwgdGhpcy5iICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdjAuY3Jvc3MoIHYxICkubGVuZ3RoKCkgKiAwLjU7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIG1pZHBvaW50OiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0LmFkZFZlY3RvcnMoIHRoaXMuYSwgdGhpcy5iICkuYWRkKCB0aGlzLmMgKS5tdWx0aXBseVNjYWxhciggMSAvIDMgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG5vcm1hbDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIFRIUkVFLlRyaWFuZ2xlLm5vcm1hbCggdGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgb3B0aW9uYWxUYXJnZXQgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHBsYW5lOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlBsYW5lKCk7XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQuc2V0RnJvbUNvcGxhbmFyUG9pbnRzKCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBiYXJ5Y29vcmRGcm9tUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuICAgICAgICByZXR1cm4gVEhSRUUuVHJpYW5nbGUuYmFyeWNvb3JkRnJvbVBvaW50KCBwb2ludCwgdGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgb3B0aW9uYWxUYXJnZXQgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBUSFJFRS5UcmlhbmdsZS5jb250YWluc1BvaW50KCBwb2ludCwgdGhpcy5hLCB0aGlzLmIsIHRoaXMuYyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZXF1YWxzOiBmdW5jdGlvbiAoIHRyaWFuZ2xlICkge1xyXG5cclxuICAgICAgICByZXR1cm4gdHJpYW5nbGUuYS5lcXVhbHMoIHRoaXMuYSApICYmIHRyaWFuZ2xlLmIuZXF1YWxzKCB0aGlzLmIgKSAmJiB0cmlhbmdsZS5jLmVxdWFscyggdGhpcy5jICk7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2NvcmUvQ2hhbm5lbHMuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkNoYW5uZWxzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHRoaXMubWFzayA9IDE7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ2hhbm5lbHMucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5DaGFubmVscyxcclxuXHJcbiAgICBzZXQ6IGZ1bmN0aW9uICggY2hhbm5lbCApIHtcclxuXHJcbiAgICAgICAgdGhpcy5tYXNrID0gMSA8PCBjaGFubmVsO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZW5hYmxlOiBmdW5jdGlvbiAoIGNoYW5uZWwgKSB7XHJcblxyXG4gICAgICAgIHRoaXMubWFzayB8PSAxIDw8IGNoYW5uZWw7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0b2dnbGU6IGZ1bmN0aW9uICggY2hhbm5lbCApIHtcclxuXHJcbiAgICAgICAgdGhpcy5tYXNrIF49IDEgPDwgY2hhbm5lbDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRpc2FibGU6IGZ1bmN0aW9uICggY2hhbm5lbCApIHtcclxuXHJcbiAgICAgICAgdGhpcy5tYXNrICY9IH4gKCAxIDw8IGNoYW5uZWwgKTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvY29yZS9DbG9jay5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQ2xvY2sgPSBmdW5jdGlvbiAoIGF1dG9TdGFydCApIHtcclxuXHJcbiAgICB0aGlzLmF1dG9TdGFydCA9ICggYXV0b1N0YXJ0ICE9PSB1bmRlZmluZWQgKSA/IGF1dG9TdGFydCA6IHRydWU7XHJcblxyXG4gICAgdGhpcy5zdGFydFRpbWUgPSAwO1xyXG4gICAgdGhpcy5vbGRUaW1lID0gMDtcclxuICAgIHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xyXG5cclxuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkNsb2NrLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuQ2xvY2ssXHJcblxyXG4gICAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xyXG5cclxuICAgICAgICB0aGlzLm9sZFRpbWUgPSB0aGlzLnN0YXJ0VGltZTtcclxuICAgICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc3RvcDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0aGlzLmdldEVsYXBzZWRUaW1lKCk7XHJcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRFbGFwc2VkVGltZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0aGlzLmdldERlbHRhKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxhcHNlZFRpbWU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXREZWx0YTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgZGlmZiA9IDA7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5hdXRvU3RhcnQgJiYgISB0aGlzLnJ1bm5pbmcgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0KCk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLnJ1bm5pbmcgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbmV3VGltZSA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XHJcblxyXG4gICAgICAgICAgICBkaWZmID0gMC4wMDEgKiAoIG5ld1RpbWUgLSB0aGlzLm9sZFRpbWUgKTtcclxuICAgICAgICAgICAgdGhpcy5vbGRUaW1lID0gbmV3VGltZTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZWxhcHNlZFRpbWUgKz0gZGlmZjtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZGlmZjtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvY29yZS9FdmVudERpc3BhdGNoZXIuanNcclxuXHJcbi8qKlxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL2V2ZW50ZGlzcGF0Y2hlci5qcy9cclxuICovXHJcblxyXG5USFJFRS5FdmVudERpc3BhdGNoZXIgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHJcblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkV2ZW50RGlzcGF0Y2hlcixcclxuXHJcbiAgICBhcHBseTogZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG4gICAgICAgIG9iamVjdC5hZGRFdmVudExpc3RlbmVyID0gVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xyXG4gICAgICAgIG9iamVjdC5oYXNFdmVudExpc3RlbmVyID0gVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5oYXNFdmVudExpc3RlbmVyO1xyXG4gICAgICAgIG9iamVjdC5yZW1vdmVFdmVudExpc3RlbmVyID0gVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyO1xyXG4gICAgICAgIG9iamVjdC5kaXNwYXRjaEV2ZW50ID0gVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xyXG5cclxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xyXG5cclxuICAgICAgICBpZiAoIGxpc3RlbmVyc1sgdHlwZSBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBsaXN0ZW5lcnNbIHR5cGUgXSA9IFtdO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSA9PT0gLSAxICkge1xyXG5cclxuICAgICAgICAgICAgbGlzdGVuZXJzWyB0eXBlIF0ucHVzaCggbGlzdGVuZXIgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgaGFzRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcclxuXHJcbiAgICAgICAgaWYgKCBsaXN0ZW5lcnNbIHR5cGUgXSAhPT0gdW5kZWZpbmVkICYmIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgIT09IC0gMSApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm47XHJcblxyXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XHJcbiAgICAgICAgdmFyIGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbIHR5cGUgXTtcclxuXHJcbiAgICAgICAgaWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBsaXN0ZW5lckFycmF5LmluZGV4T2YoIGxpc3RlbmVyICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGluZGV4ICE9PSAtIDEgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJBcnJheS5zcGxpY2UoIGluZGV4LCAxICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm47XHJcblxyXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XHJcbiAgICAgICAgdmFyIGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbIGV2ZW50LnR5cGUgXTtcclxuXHJcbiAgICAgICAgaWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBldmVudC50YXJnZXQgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgdmFyIGFycmF5ID0gW107XHJcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lckFycmF5Lmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBhcnJheVsgaSBdID0gbGlzdGVuZXJBcnJheVsgaSBdO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGFycmF5WyBpIF0uY2FsbCggdGhpcywgZXZlbnQgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9jb3JlL1JheWNhc3Rlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXHJcbiAqIEBhdXRob3Igc3RlcGhvbWkgLyBodHRwOi8vc3RlcGhhbmVnaW5pZXIuY29tL1xyXG4gKi9cclxuXHJcbiggZnVuY3Rpb24gKCBUSFJFRSApIHtcclxuXHJcbiAgICBUSFJFRS5SYXljYXN0ZXIgPSBmdW5jdGlvbiAoIG9yaWdpbiwgZGlyZWN0aW9uLCBuZWFyLCBmYXIgKSB7XHJcblxyXG4gICAgICAgIHRoaXMucmF5ID0gbmV3IFRIUkVFLlJheSggb3JpZ2luLCBkaXJlY3Rpb24gKTtcclxuICAgICAgICAvLyBkaXJlY3Rpb24gaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkIChmb3IgYWNjdXJhdGUgZGlzdGFuY2UgY2FsY3VsYXRpb25zKVxyXG5cclxuICAgICAgICB0aGlzLm5lYXIgPSBuZWFyIHx8IDA7XHJcbiAgICAgICAgdGhpcy5mYXIgPSBmYXIgfHwgSW5maW5pdHk7XHJcblxyXG4gICAgICAgIHRoaXMucGFyYW1zID0ge1xyXG4gICAgICAgICAgICBNZXNoOiB7fSxcclxuICAgICAgICAgICAgTGluZToge30sXHJcbiAgICAgICAgICAgIExPRDoge30sXHJcbiAgICAgICAgICAgIFBvaW50czogeyB0aHJlc2hvbGQ6IDEgfSxcclxuICAgICAgICAgICAgU3ByaXRlOiB7fVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLnBhcmFtcywge1xyXG4gICAgICAgICAgICBQb2ludENsb3VkOiB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5SYXljYXN0ZXI6IHBhcmFtcy5Qb2ludENsb3VkIGhhcyBiZWVuIHJlbmFtZWQgdG8gcGFyYW1zLlBvaW50cy4nICk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuUG9pbnRzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSApO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gZGVzY1NvcnQoIGEsIGIgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaW50ZXJzZWN0T2JqZWN0KCBvYmplY3QsIHJheWNhc3RlciwgaW50ZXJzZWN0cywgcmVjdXJzaXZlICkge1xyXG5cclxuICAgICAgICBpZiAoIG9iamVjdC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcbiAgICAgICAgb2JqZWN0LnJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApO1xyXG5cclxuICAgICAgICBpZiAoIHJlY3Vyc2l2ZSA9PT0gdHJ1ZSApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IG9iamVjdC5jaGlsZHJlbjtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0T2JqZWN0KCBjaGlsZHJlblsgaSBdLCByYXljYXN0ZXIsIGludGVyc2VjdHMsIHRydWUgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvL1xyXG5cclxuICAgIFRIUkVFLlJheWNhc3Rlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5SYXljYXN0ZXIsXHJcblxyXG4gICAgICAgIGxpbmVQcmVjaXNpb246IDEsXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGRpcmVjdGlvbiBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgKGZvciBhY2N1cmF0ZSBkaXN0YW5jZSBjYWxjdWxhdGlvbnMpXHJcblxyXG4gICAgICAgICAgICB0aGlzLnJheS5zZXQoIG9yaWdpbiwgZGlyZWN0aW9uICk7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldEZyb21DYW1lcmE6IGZ1bmN0aW9uICggY29vcmRzLCBjYW1lcmEgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGNhbWVyYSBpbnN0YW5jZW9mIFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMucmF5Lm9yaWdpbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yYXkuZGlyZWN0aW9uLnNldCggY29vcmRzLngsIGNvb3Jkcy55LCAwLjUgKS51bnByb2plY3QoIGNhbWVyYSApLnN1YiggdGhpcy5yYXkub3JpZ2luICkubm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBjYW1lcmEgaW5zdGFuY2VvZiBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5yYXkub3JpZ2luLnNldCggY29vcmRzLngsIGNvb3Jkcy55LCAtIDEgKS51bnByb2plY3QoIGNhbWVyYSApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yYXkuZGlyZWN0aW9uLnNldCggMCwgMCwgLSAxICkudHJhbnNmb3JtRGlyZWN0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLlJheWNhc3RlcjogVW5zdXBwb3J0ZWQgY2FtZXJhIHR5cGUuJyApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBpbnRlcnNlY3RPYmplY3Q6IGZ1bmN0aW9uICggb2JqZWN0LCByZWN1cnNpdmUgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgaW50ZXJzZWN0T2JqZWN0KCBvYmplY3QsIHRoaXMsIGludGVyc2VjdHMsIHJlY3Vyc2l2ZSApO1xyXG5cclxuICAgICAgICAgICAgaW50ZXJzZWN0cy5zb3J0KCBkZXNjU29ydCApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGludGVyc2VjdHM7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGludGVyc2VjdE9iamVjdHM6IGZ1bmN0aW9uICggb2JqZWN0cywgcmVjdXJzaXZlICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGludGVyc2VjdHMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGlmICggQXJyYXkuaXNBcnJheSggb2JqZWN0cyApID09PSBmYWxzZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5SYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0czogb2JqZWN0cyBpcyBub3QgYW4gQXJyYXkuJyApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVyc2VjdHM7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBvYmplY3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0T2JqZWN0KCBvYmplY3RzWyBpIF0sIHRoaXMsIGludGVyc2VjdHMsIHJlY3Vyc2l2ZSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaW50ZXJzZWN0cy5zb3J0KCBkZXNjU29ydCApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGludGVyc2VjdHM7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxufSggVEhSRUUgKSApO1xyXG5cclxuLy8gRmlsZTpzcmMvY29yZS9PYmplY3QzRC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKiBAYXV0aG9yIGVsZXBoYW50YXR3b3JrIC8gd3d3LmVsZXBoYW50YXR3b3JrLmNoXHJcbiAqL1xyXG5cclxuVEhSRUUuT2JqZWN0M0QgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBUSFJFRS5PYmplY3QzRElkQ291bnQgKysgfSApO1xyXG5cclxuICAgIHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XHJcblxyXG4gICAgdGhpcy5uYW1lID0gJyc7XHJcbiAgICB0aGlzLnR5cGUgPSAnT2JqZWN0M0QnO1xyXG5cclxuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcclxuICAgIHRoaXMuY2hhbm5lbHMgPSBuZXcgVEhSRUUuQ2hhbm5lbHMoKTtcclxuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcclxuXHJcbiAgICB0aGlzLnVwID0gVEhSRUUuT2JqZWN0M0QuRGVmYXVsdFVwLmNsb25lKCk7XHJcblxyXG4gICAgdmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgIHZhciByb3RhdGlvbiA9IG5ldyBUSFJFRS5FdWxlcigpO1xyXG4gICAgdmFyIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG4gICAgdmFyIHNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDEsIDEgKTtcclxuXHJcbiAgICBmdW5jdGlvbiBvblJvdGF0aW9uQ2hhbmdlKCkge1xyXG5cclxuICAgICAgICBxdWF0ZXJuaW9uLnNldEZyb21FdWxlciggcm90YXRpb24sIGZhbHNlICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG9uUXVhdGVybmlvbkNoYW5nZSgpIHtcclxuXHJcbiAgICAgICAgcm90YXRpb24uc2V0RnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb24sIHVuZGVmaW5lZCwgZmFsc2UgKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcm90YXRpb24ub25DaGFuZ2UoIG9uUm90YXRpb25DaGFuZ2UgKTtcclxuICAgIHF1YXRlcm5pb24ub25DaGFuZ2UoIG9uUXVhdGVybmlvbkNoYW5nZSApO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLCB7XHJcbiAgICAgICAgcG9zaXRpb246IHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHBvc2l0aW9uXHJcbiAgICAgICAgfSxcclxuICAgICAgICByb3RhdGlvbjoge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogcm90YXRpb25cclxuICAgICAgICB9LFxyXG4gICAgICAgIHF1YXRlcm5pb246IHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHF1YXRlcm5pb25cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNjYWxlOiB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBzY2FsZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbW9kZWxWaWV3TWF0cml4OiB7XHJcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuTWF0cml4NCgpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBub3JtYWxNYXRyaXg6IHtcclxuICAgICAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5NYXRyaXgzKClcclxuICAgICAgICB9XHJcbiAgICB9ICk7XHJcblxyXG4gICAgdGhpcy5yb3RhdGlvbkF1dG9VcGRhdGUgPSB0cnVlO1xyXG5cclxuICAgIHRoaXMubWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuICAgIHRoaXMubWF0cml4V29ybGQgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuICAgIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IFRIUkVFLk9iamVjdDNELkRlZmF1bHRNYXRyaXhBdXRvVXBkYXRlO1xyXG4gICAgdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcclxuXHJcbiAgICB0aGlzLmNhc3RTaGFkb3cgPSBmYWxzZTtcclxuICAgIHRoaXMucmVjZWl2ZVNoYWRvdyA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHRydWU7XHJcbiAgICB0aGlzLnJlbmRlck9yZGVyID0gMDtcclxuXHJcbiAgICB0aGlzLnVzZXJEYXRhID0ge307XHJcblxyXG59O1xyXG5cclxuVEhSRUUuT2JqZWN0M0QuRGVmYXVsdFVwID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcclxuVEhSRUUuT2JqZWN0M0QuRGVmYXVsdE1hdHJpeEF1dG9VcGRhdGUgPSB0cnVlO1xyXG5cclxuVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5PYmplY3QzRCxcclxuXHJcbiAgICBnZXQgZXVsZXJPcmRlciAoKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAuZXVsZXJPcmRlciBpcyBub3cgLnJvdGF0aW9uLm9yZGVyLicgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm90YXRpb24ub3JkZXI7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXQgZXVsZXJPcmRlciAoIHZhbHVlICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLmV1bGVyT3JkZXIgaXMgbm93IC5yb3RhdGlvbi5vcmRlci4nICk7XHJcblxyXG4gICAgICAgIHRoaXMucm90YXRpb24ub3JkZXIgPSB2YWx1ZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldCB1c2VRdWF0ZXJuaW9uICgpIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC51c2VRdWF0ZXJuaW9uIGhhcyBiZWVuIHJlbW92ZWQuIFRoZSBsaWJyYXJ5IG5vdyB1c2VzIHF1YXRlcm5pb25zIGJ5IGRlZmF1bHQuJyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0IHVzZVF1YXRlcm5pb24gKCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC51c2VRdWF0ZXJuaW9uIGhhcyBiZWVuIHJlbW92ZWQuIFRoZSBsaWJyYXJ5IG5vdyB1c2VzIHF1YXRlcm5pb25zIGJ5IGRlZmF1bHQuJyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0IHJlbmRlckRlcHRoICggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAucmVuZGVyRGVwdGggaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIC5yZW5kZXJPcmRlciwgaW5zdGVhZC4nICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvL1xyXG5cclxuICAgIGFwcGx5TWF0cml4OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcclxuXHJcbiAgICAgICAgdGhpcy5tYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggbWF0cml4LCB0aGlzLm1hdHJpeCApO1xyXG5cclxuICAgICAgICB0aGlzLm1hdHJpeC5kZWNvbXBvc2UoIHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0Um90YXRpb25Gcm9tQXhpc0FuZ2xlOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xyXG5cclxuICAgICAgICAvLyBhc3N1bWVzIGF4aXMgaXMgbm9ybWFsaXplZFxyXG5cclxuICAgICAgICB0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldFJvdGF0aW9uRnJvbUV1bGVyOiBmdW5jdGlvbiAoIGV1bGVyICkge1xyXG5cclxuICAgICAgICB0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciwgdHJ1ZSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0Um90YXRpb25Gcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG4gICAgICAgIC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXHJcblxyXG4gICAgICAgIHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG0gKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcclxuXHJcbiAgICAgICAgLy8gYXNzdW1lcyBxIGlzIG5vcm1hbGl6ZWRcclxuXHJcbiAgICAgICAgdGhpcy5xdWF0ZXJuaW9uLmNvcHkoIHEgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJvdGF0ZU9uQXhpczogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAvLyByb3RhdGUgb2JqZWN0IG9uIGF4aXMgaW4gb2JqZWN0IHNwYWNlXHJcbiAgICAgICAgLy8gYXhpcyBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcclxuXHJcbiAgICAgICAgdmFyIHExID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XHJcblxyXG4gICAgICAgICAgICBxMS5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5xdWF0ZXJuaW9uLm11bHRpcGx5KCBxMSApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIHJvdGF0ZVg6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDAsIDAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggYW5nbGUgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIHYxLCBhbmdsZSApO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICByb3RhdGVZOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIGFuZ2xlICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgcm90YXRlWjogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCBhbmdsZSApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyggdjEsIGFuZ2xlICk7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIHRyYW5zbGF0ZU9uQXhpczogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAvLyB0cmFuc2xhdGUgb2JqZWN0IGJ5IGRpc3RhbmNlIGFsb25nIGF4aXMgaW4gb2JqZWN0IHNwYWNlXHJcbiAgICAgICAgLy8gYXhpcyBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcclxuXHJcbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggYXhpcywgZGlzdGFuY2UgKSB7XHJcblxyXG4gICAgICAgICAgICB2MS5jb3B5KCBheGlzICkuYXBwbHlRdWF0ZXJuaW9uKCB0aGlzLnF1YXRlcm5pb24gKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24uYWRkKCB2MS5tdWx0aXBseVNjYWxhciggZGlzdGFuY2UgKSApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBkaXN0YW5jZSwgYXhpcyApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC50cmFuc2xhdGUoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgLnRyYW5zbGF0ZU9uQXhpcyggYXhpcywgZGlzdGFuY2UgKSBpbnN0ZWFkLicgKTtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIGF4aXMsIGRpc3RhbmNlICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0cmFuc2xhdGVYOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgdHJhbnNsYXRlWTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggdjEsIGRpc3RhbmNlICk7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIHRyYW5zbGF0ZVo6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggZGlzdGFuY2UgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIHYxLCBkaXN0YW5jZSApO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBsb2NhbFRvV29ybGQ6IGZ1bmN0aW9uICggdmVjdG9yICkge1xyXG5cclxuICAgICAgICByZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgd29ybGRUb0xvY2FsOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtMS5nZXRJbnZlcnNlKCB0aGlzLm1hdHJpeFdvcmxkICkgKTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgbG9va0F0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIC8vIFRoaXMgcm91dGluZSBkb2VzIG5vdCBzdXBwb3J0IG9iamVjdHMgd2l0aCByb3RhdGVkIGFuZC9vciB0cmFuc2xhdGVkIHBhcmVudChzKVxyXG5cclxuICAgICAgICB2YXIgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG4gICAgICAgICAgICBtMS5sb29rQXQoIHZlY3RvciwgdGhpcy5wb3NpdGlvbiwgdGhpcy51cCApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbTEgKTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgYWRkOiBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcbiAgICAgICAgaWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoIGFyZ3VtZW50c1sgaSBdICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIG9iamVjdCA9PT0gdGhpcyApIHtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoIFwiVEhSRUUuT2JqZWN0M0QuYWRkOiBvYmplY3QgY2FuJ3QgYmUgYWRkZWQgYXMgYSBjaGlsZCBvZiBpdHNlbGYuXCIsIG9iamVjdCApO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk9iamVjdDNEICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBvYmplY3QucGFyZW50ICE9PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgICAgIG9iamVjdC5wYXJlbnQucmVtb3ZlKCBvYmplY3QgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG9iamVjdC5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgICAgICBvYmplY3QuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnYWRkZWQnIH0gKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaCggb2JqZWN0ICk7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCBcIlRIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5PYmplY3QzRC5cIiwgb2JqZWN0ICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmU6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuICAgICAgICBpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkge1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZSggYXJndW1lbnRzWyBpIF0gKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoIG9iamVjdCApO1xyXG5cclxuICAgICAgICBpZiAoIGluZGV4ICE9PSAtIDEgKSB7XHJcblxyXG4gICAgICAgICAgICBvYmplY3QucGFyZW50ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIG9iamVjdC5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdyZW1vdmVkJyB9ICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZSggaW5kZXgsIDEgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0Q2hpbGRCeU5hbWU6IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5nZXRDaGlsZEJ5TmFtZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdldE9iamVjdEJ5TmFtZSgpLicgKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RCeU5hbWUoIG5hbWUgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldE9iamVjdEJ5SWQ6IGZ1bmN0aW9uICggaWQgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmdldE9iamVjdEJ5UHJvcGVydHkoICdpZCcsIGlkICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRPYmplY3RCeU5hbWU6IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggJ25hbWUnLCBuYW1lICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRPYmplY3RCeVByb3BlcnR5OiBmdW5jdGlvbiAoIG5hbWUsIHZhbHVlICkge1xyXG5cclxuICAgICAgICBpZiAoIHRoaXNbIG5hbWUgXSA9PT0gdmFsdWUgKSByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlblsgaSBdO1xyXG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0gY2hpbGQuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggb2JqZWN0ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0V29ybGRQb3NpdGlvbjogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldFdvcmxkUXVhdGVybmlvbjogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgIHZhciBzY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggcG9zaXRpb24sIHJlc3VsdCwgc2NhbGUgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIGdldFdvcmxkUm90YXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuRXVsZXIoKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZ2V0V29ybGRRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnNldEZyb21RdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLCB0aGlzLnJvdGF0aW9uLm9yZGVyLCBmYWxzZSApO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBnZXRXb3JsZFNjYWxlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgdmFyIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCByZXN1bHQgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIGdldFdvcmxkRGlyZWN0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZ2V0V29ybGRRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnNldCggMCwgMCwgMSApLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICByYXljYXN0OiBmdW5jdGlvbiAoKSB7fSxcclxuXHJcbiAgICB0cmF2ZXJzZTogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcclxuXHJcbiAgICAgICAgY2FsbGJhY2soIHRoaXMgKTtcclxuXHJcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIGNoaWxkcmVuWyBpIF0udHJhdmVyc2UoIGNhbGxiYWNrICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRyYXZlcnNlVmlzaWJsZTogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cclxuICAgICAgICBjYWxsYmFjayggdGhpcyApO1xyXG5cclxuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgY2hpbGRyZW5bIGkgXS50cmF2ZXJzZVZpc2libGUoIGNhbGxiYWNrICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRyYXZlcnNlQW5jZXN0b3JzOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xyXG5cclxuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XHJcblxyXG4gICAgICAgIGlmICggcGFyZW50ICE9PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgY2FsbGJhY2soIHBhcmVudCApO1xyXG5cclxuICAgICAgICAgICAgcGFyZW50LnRyYXZlcnNlQW5jZXN0b3JzKCBjYWxsYmFjayApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVNYXRyaXg6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdGhpcy5tYXRyaXguY29tcG9zZSggdGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCB0aGlzLnNjYWxlICk7XHJcblxyXG4gICAgICAgIHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVNYXRyaXhXb3JsZDogZnVuY3Rpb24gKCBmb3JjZSApIHtcclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPT09IHRydWUgKSB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9PT0gdHJ1ZSB8fCBmb3JjZSA9PT0gdHJ1ZSApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggdGhpcy5wYXJlbnQgPT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRyaXhXb3JsZC5jb3B5KCB0aGlzLm1hdHJpeCApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXMoIHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLCB0aGlzLm1hdHJpeCApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBmb3JjZSA9IHRydWU7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIGNoaWxkcmVuXHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5bIGkgXS51cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XHJcblxyXG4gICAgICAgIHZhciBpc1Jvb3RPYmplY3QgPSAoIG1ldGEgPT09IHVuZGVmaW5lZCApO1xyXG5cclxuICAgICAgICB2YXIgb3V0cHV0ID0ge307XHJcblxyXG4gICAgICAgIC8vIG1ldGEgaXMgYSBoYXNoIHVzZWQgdG8gY29sbGVjdCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMuXHJcbiAgICAgICAgLy8gbm90IHByb3ZpZGluZyBpdCBpbXBsaWVzIHRoYXQgdGhpcyBpcyB0aGUgcm9vdCBvYmplY3RcclxuICAgICAgICAvLyBiZWluZyBzZXJpYWxpemVkLlxyXG4gICAgICAgIGlmICggaXNSb290T2JqZWN0ICkge1xyXG5cclxuICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZSBtZXRhIG9ialxyXG4gICAgICAgICAgICBtZXRhID0ge1xyXG4gICAgICAgICAgICAgICAgZ2VvbWV0cmllczoge30sXHJcbiAgICAgICAgICAgICAgICBtYXRlcmlhbHM6IHt9LFxyXG4gICAgICAgICAgICAgICAgdGV4dHVyZXM6IHt9LFxyXG4gICAgICAgICAgICAgICAgaW1hZ2VzOiB7fVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgb3V0cHV0Lm1ldGFkYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogNC40LFxyXG4gICAgICAgICAgICAgICAgdHlwZTogJ09iamVjdCcsXHJcbiAgICAgICAgICAgICAgICBnZW5lcmF0b3I6ICdPYmplY3QzRC50b0pTT04nXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gc3RhbmRhcmQgT2JqZWN0M0Qgc2VyaWFsaXphdGlvblxyXG5cclxuICAgICAgICB2YXIgb2JqZWN0ID0ge307XHJcblxyXG4gICAgICAgIG9iamVjdC51dWlkID0gdGhpcy51dWlkO1xyXG4gICAgICAgIG9iamVjdC50eXBlID0gdGhpcy50eXBlO1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBvYmplY3QubmFtZSA9IHRoaXMubmFtZTtcclxuICAgICAgICBpZiAoIEpTT04uc3RyaW5naWZ5KCB0aGlzLnVzZXJEYXRhICkgIT09ICd7fScgKSBvYmplY3QudXNlckRhdGEgPSB0aGlzLnVzZXJEYXRhO1xyXG4gICAgICAgIGlmICggdGhpcy5jYXN0U2hhZG93ID09PSB0cnVlICkgb2JqZWN0LmNhc3RTaGFkb3cgPSB0cnVlO1xyXG4gICAgICAgIGlmICggdGhpcy5yZWNlaXZlU2hhZG93ID09PSB0cnVlICkgb2JqZWN0LnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xyXG4gICAgICAgIGlmICggdGhpcy52aXNpYmxlID09PSBmYWxzZSApIG9iamVjdC52aXNpYmxlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIG9iamVjdC5tYXRyaXggPSB0aGlzLm1hdHJpeC50b0FycmF5KCk7XHJcblxyXG4gICAgICAgIC8vXHJcblxyXG4gICAgICAgIGlmICggdGhpcy5nZW9tZXRyeSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBtZXRhLmdlb21ldHJpZXNbIHRoaXMuZ2VvbWV0cnkudXVpZCBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgbWV0YS5nZW9tZXRyaWVzWyB0aGlzLmdlb21ldHJ5LnV1aWQgXSA9IHRoaXMuZ2VvbWV0cnkudG9KU09OKCBtZXRhICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBvYmplY3QuZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5LnV1aWQ7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLm1hdGVyaWFsICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG1ldGEubWF0ZXJpYWxzWyB0aGlzLm1hdGVyaWFsLnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIG1ldGEubWF0ZXJpYWxzWyB0aGlzLm1hdGVyaWFsLnV1aWQgXSA9IHRoaXMubWF0ZXJpYWwudG9KU09OKCBtZXRhICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBvYmplY3QubWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsLnV1aWQ7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9cclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDAgKSB7XHJcblxyXG4gICAgICAgICAgICBvYmplY3QuY2hpbGRyZW4gPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIG9iamVjdC5jaGlsZHJlbi5wdXNoKCB0aGlzLmNoaWxkcmVuWyBpIF0udG9KU09OKCBtZXRhICkub2JqZWN0ICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBpc1Jvb3RPYmplY3QgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgZ2VvbWV0cmllcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuZ2VvbWV0cmllcyApO1xyXG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWxzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5tYXRlcmlhbHMgKTtcclxuICAgICAgICAgICAgdmFyIHRleHR1cmVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS50ZXh0dXJlcyApO1xyXG4gICAgICAgICAgICB2YXIgaW1hZ2VzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5pbWFnZXMgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggZ2VvbWV0cmllcy5sZW5ndGggPiAwICkgb3V0cHV0Lmdlb21ldHJpZXMgPSBnZW9tZXRyaWVzO1xyXG4gICAgICAgICAgICBpZiAoIG1hdGVyaWFscy5sZW5ndGggPiAwICkgb3V0cHV0Lm1hdGVyaWFscyA9IG1hdGVyaWFscztcclxuICAgICAgICAgICAgaWYgKCB0ZXh0dXJlcy5sZW5ndGggPiAwICkgb3V0cHV0LnRleHR1cmVzID0gdGV4dHVyZXM7XHJcbiAgICAgICAgICAgIGlmICggaW1hZ2VzLmxlbmd0aCA+IDAgKSBvdXRwdXQuaW1hZ2VzID0gaW1hZ2VzO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG91dHB1dC5vYmplY3QgPSBvYmplY3Q7XHJcblxyXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XHJcblxyXG4gICAgICAgIC8vIGV4dHJhY3QgZGF0YSBmcm9tIHRoZSBjYWNoZSBoYXNoXHJcbiAgICAgICAgLy8gcmVtb3ZlIG1ldGFkYXRhIG9uIGVhY2ggaXRlbVxyXG4gICAgICAgIC8vIGFuZCByZXR1cm4gYXMgYXJyYXlcclxuICAgICAgICBmdW5jdGlvbiBleHRyYWN0RnJvbUNhY2hlICggY2FjaGUgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gW107XHJcbiAgICAgICAgICAgIGZvciAoIHZhciBrZXkgaW4gY2FjaGUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBjYWNoZVsga2V5IF07XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgZGF0YS5tZXRhZGF0YTtcclxuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKCBkYXRhICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNsb25lOiBmdW5jdGlvbiAoIHJlY3Vyc2l2ZSApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcywgcmVjdXJzaXZlICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xyXG5cclxuICAgICAgICBpZiAoIHJlY3Vyc2l2ZSA9PT0gdW5kZWZpbmVkICkgcmVjdXJzaXZlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy5uYW1lID0gc291cmNlLm5hbWU7XHJcblxyXG4gICAgICAgIHRoaXMudXAuY29weSggc291cmNlLnVwICk7XHJcblxyXG4gICAgICAgIHRoaXMucG9zaXRpb24uY29weSggc291cmNlLnBvc2l0aW9uICk7XHJcbiAgICAgICAgdGhpcy5xdWF0ZXJuaW9uLmNvcHkoIHNvdXJjZS5xdWF0ZXJuaW9uICk7XHJcbiAgICAgICAgdGhpcy5zY2FsZS5jb3B5KCBzb3VyY2Uuc2NhbGUgKTtcclxuXHJcbiAgICAgICAgdGhpcy5yb3RhdGlvbkF1dG9VcGRhdGUgPSBzb3VyY2Uucm90YXRpb25BdXRvVXBkYXRlO1xyXG5cclxuICAgICAgICB0aGlzLm1hdHJpeC5jb3B5KCBzb3VyY2UubWF0cml4ICk7XHJcbiAgICAgICAgdGhpcy5tYXRyaXhXb3JsZC5jb3B5KCBzb3VyY2UubWF0cml4V29ybGQgKTtcclxuXHJcbiAgICAgICAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gc291cmNlLm1hdHJpeEF1dG9VcGRhdGU7XHJcbiAgICAgICAgdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gc291cmNlLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU7XHJcblxyXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHNvdXJjZS52aXNpYmxlO1xyXG5cclxuICAgICAgICB0aGlzLmNhc3RTaGFkb3cgPSBzb3VyY2UuY2FzdFNoYWRvdztcclxuICAgICAgICB0aGlzLnJlY2VpdmVTaGFkb3cgPSBzb3VyY2UucmVjZWl2ZVNoYWRvdztcclxuXHJcbiAgICAgICAgdGhpcy5mcnVzdHVtQ3VsbGVkID0gc291cmNlLmZydXN0dW1DdWxsZWQ7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJPcmRlciA9IHNvdXJjZS5yZW5kZXJPcmRlcjtcclxuXHJcbiAgICAgICAgdGhpcy51c2VyRGF0YSA9IEpTT04ucGFyc2UoIEpTT04uc3RyaW5naWZ5KCBzb3VyY2UudXNlckRhdGEgKSApO1xyXG5cclxuICAgICAgICBpZiAoIHJlY3Vyc2l2ZSA9PT0gdHJ1ZSApIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHNvdXJjZS5jaGlsZHJlbi5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gc291cmNlLmNoaWxkcmVuWyBpIF07XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZCggY2hpbGQuY2xvbmUoKSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLk9iamVjdDNESWRDb3VudCA9IDA7XHJcblxyXG4vLyBGaWxlOnNyYy9jb3JlL0ZhY2UzLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5GYWNlMyA9IGZ1bmN0aW9uICggYSwgYiwgYywgbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxJbmRleCApIHtcclxuXHJcbiAgICB0aGlzLmEgPSBhO1xyXG4gICAgdGhpcy5iID0gYjtcclxuICAgIHRoaXMuYyA9IGM7XHJcblxyXG4gICAgdGhpcy5ub3JtYWwgPSBub3JtYWwgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzID8gbm9ybWFsIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgIHRoaXMudmVydGV4Tm9ybWFscyA9IEFycmF5LmlzQXJyYXkoIG5vcm1hbCApID8gbm9ybWFsIDogW107XHJcblxyXG4gICAgdGhpcy5jb2xvciA9IGNvbG9yIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgPyBjb2xvciA6IG5ldyBUSFJFRS5Db2xvcigpO1xyXG4gICAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBBcnJheS5pc0FycmF5KCBjb2xvciApID8gY29sb3IgOiBbXTtcclxuXHJcbiAgICB0aGlzLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4ICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbEluZGV4IDogMDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5GYWNlMy5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkZhY2UzLFxyXG5cclxuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuICAgICAgICB0aGlzLmEgPSBzb3VyY2UuYTtcclxuICAgICAgICB0aGlzLmIgPSBzb3VyY2UuYjtcclxuICAgICAgICB0aGlzLmMgPSBzb3VyY2UuYztcclxuXHJcbiAgICAgICAgdGhpcy5ub3JtYWwuY29weSggc291cmNlLm5vcm1hbCApO1xyXG4gICAgICAgIHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XHJcblxyXG4gICAgICAgIHRoaXMubWF0ZXJpYWxJbmRleCA9IHNvdXJjZS5tYXRlcmlhbEluZGV4O1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gc291cmNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnZlcnRleE5vcm1hbHNbIGkgXSA9IHNvdXJjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0uY2xvbmUoKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gc291cmNlLnZlcnRleENvbG9ycy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudmVydGV4Q29sb3JzWyBpIF0gPSBzb3VyY2UudmVydGV4Q29sb3JzWyBpIF0uY2xvbmUoKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvY29yZS9GYWNlNC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuRmFjZTQgPSBmdW5jdGlvbiAoIGEsIGIsIGMsIGQsIG5vcm1hbCwgY29sb3IsIG1hdGVyaWFsSW5kZXggKSB7XHJcblxyXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuRmFjZTQgaGFzIGJlZW4gcmVtb3ZlZC4gQSBUSFJFRS5GYWNlMyB3aWxsIGJlIGNyZWF0ZWQgaW5zdGVhZC4nICk7XHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBjLCBub3JtYWwsIGNvbG9yLCBtYXRlcmlhbEluZGV4ICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvY29yZS9CdWZmZXJBdHRyaWJ1dGUuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xyXG5cclxuICAgIHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XHJcblxyXG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xyXG4gICAgdGhpcy5pdGVtU2l6ZSA9IGl0ZW1TaXplO1xyXG5cclxuICAgIHRoaXMuZHluYW1pYyA9IGZhbHNlO1xyXG4gICAgdGhpcy51cGRhdGVSYW5nZSA9IHsgb2Zmc2V0OiAwLCBjb3VudDogLSAxIH07XHJcblxyXG4gICAgdGhpcy52ZXJzaW9uID0gMDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5CdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUsXHJcblxyXG4gICAgZ2V0IGxlbmd0aCgpIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlOiAubGVuZ3RoIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgLmNvdW50LicgKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcnJheS5sZW5ndGg7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXQgY291bnQoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aCAvIHRoaXMuaXRlbVNpemU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXQgbmVlZHNVcGRhdGUoIHZhbHVlICkge1xyXG5cclxuICAgICAgICBpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy52ZXJzaW9uICsrO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0RHluYW1pYzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5keW5hbWljID0gdmFsdWU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuYXJyYXkgPSBuZXcgc291cmNlLmFycmF5LmNvbnN0cnVjdG9yKCBzb3VyY2UuYXJyYXkgKTtcclxuICAgICAgICB0aGlzLml0ZW1TaXplID0gc291cmNlLml0ZW1TaXplO1xyXG5cclxuICAgICAgICB0aGlzLmR5bmFtaWMgPSBzb3VyY2UuZHluYW1pYztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb3B5QXQ6IGZ1bmN0aW9uICggaW5kZXgxLCBhdHRyaWJ1dGUsIGluZGV4MiApIHtcclxuXHJcbiAgICAgICAgaW5kZXgxICo9IHRoaXMuaXRlbVNpemU7XHJcbiAgICAgICAgaW5kZXgyICo9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5pdGVtU2l6ZTsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFycmF5WyBpbmRleDEgKyBpIF0gPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4MiArIGkgXTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvcHlBcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5hcnJheS5zZXQoIGFycmF5ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29weUNvbG9yc0FycmF5OiBmdW5jdGlvbiAoIGNvbG9ycyApIHtcclxuXHJcbiAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gY29sb3JzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgY29sb3IgPSBjb2xvcnNbIGkgXTtcclxuXHJcbiAgICAgICAgICAgIGlmICggY29sb3IgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weUNvbG9yc0FycmF5KCk6IGNvbG9yIGlzIHVuZGVmaW5lZCcsIGkgKTtcclxuICAgICAgICAgICAgICAgIGNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBhcnJheVsgb2Zmc2V0ICsrIF0gPSBjb2xvci5yO1xyXG4gICAgICAgICAgICBhcnJheVsgb2Zmc2V0ICsrIF0gPSBjb2xvci5nO1xyXG4gICAgICAgICAgICBhcnJheVsgb2Zmc2V0ICsrIF0gPSBjb2xvci5iO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29weUluZGljZXNBcnJheTogZnVuY3Rpb24gKCBpbmRpY2VzICkge1xyXG5cclxuICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5LCBvZmZzZXQgPSAwO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBpbmRpY2VzWyBpIF07XHJcblxyXG4gICAgICAgICAgICBhcnJheVsgb2Zmc2V0ICsrIF0gPSBpbmRleC5hO1xyXG4gICAgICAgICAgICBhcnJheVsgb2Zmc2V0ICsrIF0gPSBpbmRleC5iO1xyXG4gICAgICAgICAgICBhcnJheVsgb2Zmc2V0ICsrIF0gPSBpbmRleC5jO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29weVZlY3RvcjJzQXJyYXk6IGZ1bmN0aW9uICggdmVjdG9ycyApIHtcclxuXHJcbiAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gdmVjdG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHZlY3RvciA9IHZlY3RvcnNbIGkgXTtcclxuXHJcbiAgICAgICAgICAgIGlmICggdmVjdG9yID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlWZWN0b3Iyc0FycmF5KCk6IHZlY3RvciBpcyB1bmRlZmluZWQnLCBpICk7XHJcbiAgICAgICAgICAgICAgICB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLng7XHJcbiAgICAgICAgICAgIGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci55O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29weVZlY3RvcjNzQXJyYXk6IGZ1bmN0aW9uICggdmVjdG9ycyApIHtcclxuXHJcbiAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gdmVjdG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHZlY3RvciA9IHZlY3RvcnNbIGkgXTtcclxuXHJcbiAgICAgICAgICAgIGlmICggdmVjdG9yID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCk6IHZlY3RvciBpcyB1bmRlZmluZWQnLCBpICk7XHJcbiAgICAgICAgICAgICAgICB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLng7XHJcbiAgICAgICAgICAgIGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci55O1xyXG4gICAgICAgICAgICBhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IuejtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvcHlWZWN0b3I0c0FycmF5OiBmdW5jdGlvbiAoIHZlY3RvcnMgKSB7XHJcblxyXG4gICAgICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHZlY3RvcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciB2ZWN0b3IgPSB2ZWN0b3JzWyBpIF07XHJcblxyXG4gICAgICAgICAgICBpZiAoIHZlY3RvciA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5VmVjdG9yNHNBcnJheSgpOiB2ZWN0b3IgaXMgdW5kZWZpbmVkJywgaSApO1xyXG4gICAgICAgICAgICAgICAgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjQoKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci54O1xyXG4gICAgICAgICAgICBhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueTtcclxuICAgICAgICAgICAgYXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLno7XHJcbiAgICAgICAgICAgIGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci53O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0OiBmdW5jdGlvbiAoIHZhbHVlLCBvZmZzZXQgKSB7XHJcblxyXG4gICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLmFycmF5LnNldCggdmFsdWUsIG9mZnNldCApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldFg6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgXTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldFg6IGZ1bmN0aW9uICggaW5kZXgsIHggKSB7XHJcblxyXG4gICAgICAgIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSBdID0geDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRZOiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMSBdO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0WTogZnVuY3Rpb24gKCBpbmRleCwgeSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMSBdID0geTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRaOiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMiBdO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0WjogZnVuY3Rpb24gKCBpbmRleCwgeiApIHtcclxuXHJcbiAgICAgICAgdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMiBdID0gejtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRXOiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMyBdO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0VzogZnVuY3Rpb24gKCBpbmRleCwgdyApIHtcclxuXHJcbiAgICAgICAgdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMyBdID0gdztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRYWTogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSApIHtcclxuXHJcbiAgICAgICAgaW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcclxuXHJcbiAgICAgICAgdGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xyXG4gICAgICAgIHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRYWVo6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHksIHogKSB7XHJcblxyXG4gICAgICAgIGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XHJcblxyXG4gICAgICAgIHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcclxuICAgICAgICB0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XHJcbiAgICAgICAgdGhpcy5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldFhZWlc6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHksIHosIHcgKSB7XHJcblxyXG4gICAgICAgIGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XHJcblxyXG4gICAgICAgIHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcclxuICAgICAgICB0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XHJcbiAgICAgICAgdGhpcy5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xyXG4gICAgICAgIHRoaXMuYXJyYXlbIGluZGV4ICsgMyBdID0gdztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vXHJcblxyXG5USFJFRS5JbnQ4QXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBJbnQ4QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVWludDhBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcclxuXHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IFVpbnQ4QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVWludDhDbGFtcGVkQXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBVaW50OENsYW1wZWRBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5JbnQxNkF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgSW50MTZBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5VaW50MTZBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcclxuXHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IFVpbnQxNkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkludDMyQXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBJbnQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlVpbnQzMkF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgVWludDMyQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkZsb2F0NjRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcclxuXHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0NjRBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcclxuXHJcbn07XHJcblxyXG5cclxuLy8gRGVwcmVjYXRlZFxyXG5cclxuVEhSRUUuRHluYW1pY0J1ZmZlckF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xyXG5cclxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkR5bmFtaWNCdWZmZXJBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoKS5zZXREeW5hbWljKCB0cnVlICkgaW5zdGVhZC4nICk7XHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkuc2V0RHluYW1pYyggdHJ1ZSApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2NvcmUvSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXHJcbiAqL1xyXG5cclxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUsIG1lc2hQZXJBdHRyaWJ1dGUgKSB7XHJcblxyXG4gICAgVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNhbGwoIHRoaXMsIGFycmF5LCBpdGVtU2l6ZSApO1xyXG5cclxuICAgIHRoaXMubWVzaFBlckF0dHJpYnV0ZSA9IG1lc2hQZXJBdHRyaWJ1dGUgfHwgMTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSApO1xyXG5USFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlO1xyXG5cclxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG4gICAgVEhSRUUuQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuICAgIHRoaXMubWVzaFBlckF0dHJpYnV0ZSA9IHNvdXJjZS5tZXNoUGVyQXR0cmlidXRlO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2NvcmUvSW50ZXJsZWF2ZWRCdWZmZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcclxuICovXHJcblxyXG5USFJFRS5JbnRlcmxlYXZlZEJ1ZmZlciA9IGZ1bmN0aW9uICggYXJyYXksIHN0cmlkZSApIHtcclxuXHJcbiAgICB0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xyXG5cclxuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcclxuICAgIHRoaXMuc3RyaWRlID0gc3RyaWRlO1xyXG5cclxuICAgIHRoaXMuZHluYW1pYyA9IGZhbHNlO1xyXG4gICAgdGhpcy51cGRhdGVSYW5nZSA9IHsgb2Zmc2V0OiAwLCBjb3VudDogLSAxIH07XHJcblxyXG4gICAgdGhpcy52ZXJzaW9uID0gMDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5JbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkludGVybGVhdmVkQnVmZmVyLFxyXG5cclxuICAgIGdldCBsZW5ndGggKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5hcnJheS5sZW5ndGg7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXQgY291bnQgKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5hcnJheS5sZW5ndGggLyB0aGlzLnN0cmlkZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldCBuZWVkc1VwZGF0ZSggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnZlcnNpb24gKys7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXREeW5hbWljOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuICAgICAgICB0aGlzLmR5bmFtaWMgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5hcnJheSA9IG5ldyBzb3VyY2UuYXJyYXkuY29uc3RydWN0b3IoIHNvdXJjZS5hcnJheSApO1xyXG4gICAgICAgIHRoaXMuc3RyaWRlID0gc291cmNlLnN0cmlkZTtcclxuICAgICAgICB0aGlzLmR5bmFtaWMgPSBzb3VyY2UuZHluYW1pYztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvcHlBdDogZnVuY3Rpb24gKCBpbmRleDEsIGF0dHJpYnV0ZSwgaW5kZXgyICkge1xyXG5cclxuICAgICAgICBpbmRleDEgKj0gdGhpcy5zdHJpZGU7XHJcbiAgICAgICAgaW5kZXgyICo9IGF0dHJpYnV0ZS5zdHJpZGU7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuc3RyaWRlOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYXJyYXlbIGluZGV4MSArIGkgXSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXgyICsgaSBdO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0OiBmdW5jdGlvbiAoIHZhbHVlLCBvZmZzZXQgKSB7XHJcblxyXG4gICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLmFycmF5LnNldCggdmFsdWUsIG9mZnNldCApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvY29yZS9JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xyXG4gKi9cclxuXHJcblRIUkVFLkluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyID0gZnVuY3Rpb24gKCBhcnJheSwgc3RyaWRlLCBtZXNoUGVyQXR0cmlidXRlICkge1xyXG5cclxuICAgIFRIUkVFLkludGVybGVhdmVkQnVmZmVyLmNhbGwoIHRoaXMsIGFycmF5LCBzdHJpZGUgKTtcclxuXHJcbiAgICB0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBtZXNoUGVyQXR0cmlidXRlIHx8IDE7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlICk7XHJcblRIUkVFLkluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyO1xyXG5cclxuVEhSRUUuSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcbiAgICBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcbiAgICB0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBzb3VyY2UubWVzaFBlckF0dHJpYnV0ZTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9jb3JlL0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXHJcbiAqL1xyXG5cclxuVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGludGVybGVhdmVkQnVmZmVyLCBpdGVtU2l6ZSwgb2Zmc2V0ICkge1xyXG5cclxuICAgIHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XHJcblxyXG4gICAgdGhpcy5kYXRhID0gaW50ZXJsZWF2ZWRCdWZmZXI7XHJcbiAgICB0aGlzLml0ZW1TaXplID0gaXRlbVNpemU7XHJcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuXHJcbn07XHJcblxyXG5cclxuVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSxcclxuXHJcbiAgICBnZXQgbGVuZ3RoKCkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IC5sZW5ndGggaGFzIGJlZW4gZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSAuY291bnQuJyApO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldCBjb3VudCgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5hcnJheS5sZW5ndGggLyB0aGlzLmRhdGEuc3RyaWRlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0WDogZnVuY3Rpb24gKCBpbmRleCwgeCApIHtcclxuXHJcbiAgICAgICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCBdID0geDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRZOiBmdW5jdGlvbiAoIGluZGV4LCB5ICkge1xyXG5cclxuICAgICAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMSBdID0geTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRaOiBmdW5jdGlvbiAoIGluZGV4LCB6ICkge1xyXG5cclxuICAgICAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMiBdID0gejtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRXOiBmdW5jdGlvbiAoIGluZGV4LCB3ICkge1xyXG5cclxuICAgICAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMyBdID0gdztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRYOiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCBdO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0WTogZnVuY3Rpb24gKCBpbmRleCApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAxIF07XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRaOiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDIgXTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldFc6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMyBdO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0WFk6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHkgKSB7XHJcblxyXG4gICAgICAgIGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XHJcblxyXG4gICAgICAgIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xyXG4gICAgICAgIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldFhZWjogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSwgeiApIHtcclxuXHJcbiAgICAgICAgaW5kZXggPSBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldDtcclxuXHJcbiAgICAgICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XHJcbiAgICAgICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XHJcbiAgICAgICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0WFlaVzogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSwgeiwgdyApIHtcclxuXHJcbiAgICAgICAgaW5kZXggPSBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldDtcclxuXHJcbiAgICAgICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XHJcbiAgICAgICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XHJcbiAgICAgICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XHJcbiAgICAgICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDMgXSA9IHc7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9jb3JlL0dlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBraWxlIC8gaHR0cDovL2tpbGUuc3RyYXZhZ2FuemEub3JnL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICovXHJcblxyXG5USFJFRS5HZW9tZXRyeSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IFRIUkVFLkdlb21ldHJ5SWRDb3VudCArKyB9ICk7XHJcblxyXG4gICAgdGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcbiAgICB0aGlzLm5hbWUgPSAnJztcclxuICAgIHRoaXMudHlwZSA9ICdHZW9tZXRyeSc7XHJcblxyXG4gICAgdGhpcy52ZXJ0aWNlcyA9IFtdO1xyXG4gICAgdGhpcy5jb2xvcnMgPSBbXTtcclxuICAgIHRoaXMuZmFjZXMgPSBbXTtcclxuICAgIHRoaXMuZmFjZVZlcnRleFV2cyA9IFsgW10gXTtcclxuXHJcbiAgICB0aGlzLm1vcnBoVGFyZ2V0cyA9IFtdO1xyXG4gICAgdGhpcy5tb3JwaE5vcm1hbHMgPSBbXTtcclxuXHJcbiAgICB0aGlzLnNraW5XZWlnaHRzID0gW107XHJcbiAgICB0aGlzLnNraW5JbmRpY2VzID0gW107XHJcblxyXG4gICAgdGhpcy5saW5lRGlzdGFuY2VzID0gW107XHJcblxyXG4gICAgdGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XHJcbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcclxuXHJcbiAgICAvLyB1cGRhdGUgZmxhZ3NcclxuXHJcbiAgICB0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5lbGVtZW50c05lZWRVcGRhdGUgPSBmYWxzZTtcclxuICAgIHRoaXMudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XHJcbiAgICB0aGlzLmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlID0gZmFsc2U7XHJcbiAgICB0aGlzLmdyb3Vwc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkdlb21ldHJ5LFxyXG5cclxuICAgIGFwcGx5TWF0cml4OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcclxuXHJcbiAgICAgICAgdmFyIG5vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgdmVydGV4ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xyXG4gICAgICAgICAgICB2ZXJ0ZXguYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBmYWNlID0gdGhpcy5mYWNlc1sgaSBdO1xyXG4gICAgICAgICAgICBmYWNlLm5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBmYWNlLnZlcnRleE5vcm1hbHNbIGogXS5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICByb3RhdGVYOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeC1heGlzXHJcblxyXG4gICAgICAgIHZhciBtMTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVgoIGFuZ2xlICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuICAgICAgICAgICAgbTEubWFrZVJvdGF0aW9uWCggYW5nbGUgKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgcm90YXRlWTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHktYXhpc1xyXG5cclxuICAgICAgICB2YXIgbTE7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiByb3RhdGVZKCBhbmdsZSApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcbiAgICAgICAgICAgIG0xLm1ha2VSb3RhdGlvblkoIGFuZ2xlICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIHJvdGF0ZVo6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgLy8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB6LWF4aXNcclxuXHJcbiAgICAgICAgdmFyIG0xO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcm90YXRlWiggYW5nbGUgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG4gICAgICAgICAgICBtMS5tYWtlUm90YXRpb25aKCBhbmdsZSApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hcHBseU1hdHJpeCggbTEgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgLy8gdHJhbnNsYXRlIGdlb21ldHJ5XHJcblxyXG4gICAgICAgIHZhciBtMTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHRyYW5zbGF0ZSggeCwgeSwgeiApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcbiAgICAgICAgICAgIG0xLm1ha2VUcmFuc2xhdGlvbiggeCwgeSwgeiApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hcHBseU1hdHJpeCggbTEgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBzY2FsZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAvLyBzY2FsZSBnZW9tZXRyeVxyXG5cclxuICAgICAgICB2YXIgbTE7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzY2FsZSggeCwgeSwgeiApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcbiAgICAgICAgICAgIG0xLm1ha2VTY2FsZSggeCwgeSwgeiApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hcHBseU1hdHJpeCggbTEgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBsb29rQXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIG9iajtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGxvb2tBdCggdmVjdG9yICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBvYmogPT09IHVuZGVmaW5lZCApIG9iaiA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xyXG5cclxuICAgICAgICAgICAgb2JqLmxvb2tBdCggdmVjdG9yICk7XHJcblxyXG4gICAgICAgICAgICBvYmoudXBkYXRlTWF0cml4KCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFwcGx5TWF0cml4KCBvYmoubWF0cml4ICk7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIGZyb21CdWZmZXJHZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcclxuXHJcbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcclxuXHJcbiAgICAgICAgdmFyIGluZGljZXMgPSBnZW9tZXRyeS5pbmRleCAhPT0gbnVsbCA/IGdlb21ldHJ5LmluZGV4LmFycmF5IDogdW5kZWZpbmVkO1xyXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcclxuXHJcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcclxuICAgICAgICB2YXIgbm9ybWFscyA9IGF0dHJpYnV0ZXMubm9ybWFsICE9PSB1bmRlZmluZWQgPyBhdHRyaWJ1dGVzLm5vcm1hbC5hcnJheSA6IHVuZGVmaW5lZDtcclxuICAgICAgICB2YXIgY29sb3JzID0gYXR0cmlidXRlcy5jb2xvciAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy5jb2xvci5hcnJheSA6IHVuZGVmaW5lZDtcclxuICAgICAgICB2YXIgdXZzID0gYXR0cmlidXRlcy51diAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy51di5hcnJheSA6IHVuZGVmaW5lZDtcclxuICAgICAgICB2YXIgdXZzMiA9IGF0dHJpYnV0ZXMudXYyICE9PSB1bmRlZmluZWQgPyBhdHRyaWJ1dGVzLnV2Mi5hcnJheSA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgaWYgKCB1dnMyICE9PSB1bmRlZmluZWQgKSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDEgXSA9IFtdO1xyXG5cclxuICAgICAgICB2YXIgdGVtcE5vcm1hbHMgPSBbXTtcclxuICAgICAgICB2YXIgdGVtcFVWcyA9IFtdO1xyXG4gICAgICAgIHZhciB0ZW1wVVZzMiA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGogPSAwLCBrID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSArPSAzLCBqICs9IDIsIGsgKz0gNCApIHtcclxuXHJcbiAgICAgICAgICAgIHNjb3BlLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc1sgaSArIDEgXSwgdmVydGljZXNbIGkgKyAyIF0gKSApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBub3JtYWxzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGVtcE5vcm1hbHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIG5vcm1hbHNbIGkgXSwgbm9ybWFsc1sgaSArIDEgXSwgbm9ybWFsc1sgaSArIDIgXSApICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIGNvbG9ycyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHNjb3BlLmNvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yc1sgaSBdLCBjb2xvcnNbIGkgKyAxIF0sIGNvbG9yc1sgaSArIDIgXSApICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIHV2cyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHRlbXBVVnMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHV2c1sgaiBdLCB1dnNbIGogKyAxIF0gKSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCB1dnMyICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGVtcFVWczIucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHV2czJbIGogXSwgdXZzMlsgaiArIDEgXSApICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gYWRkRmFjZSggYSwgYiwgYyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciB2ZXJ0ZXhOb3JtYWxzID0gbm9ybWFscyAhPT0gdW5kZWZpbmVkID8gWyB0ZW1wTm9ybWFsc1sgYSBdLmNsb25lKCksIHRlbXBOb3JtYWxzWyBiIF0uY2xvbmUoKSwgdGVtcE5vcm1hbHNbIGMgXS5jbG9uZSgpIF0gOiBbXTtcclxuICAgICAgICAgICAgdmFyIHZlcnRleENvbG9ycyA9IGNvbG9ycyAhPT0gdW5kZWZpbmVkID8gWyBzY29wZS5jb2xvcnNbIGEgXS5jbG9uZSgpLCBzY29wZS5jb2xvcnNbIGIgXS5jbG9uZSgpLCBzY29wZS5jb2xvcnNbIGMgXS5jbG9uZSgpIF0gOiBbXTtcclxuXHJcbiAgICAgICAgICAgIHZhciBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBjLCB2ZXJ0ZXhOb3JtYWxzLCB2ZXJ0ZXhDb2xvcnMgKTtcclxuXHJcbiAgICAgICAgICAgIHNjb3BlLmZhY2VzLnB1c2goIGZhY2UgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggdXZzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgc2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdGVtcFVWc1sgYSBdLmNsb25lKCksIHRlbXBVVnNbIGIgXS5jbG9uZSgpLCB0ZW1wVVZzWyBjIF0uY2xvbmUoKSBdICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIHV2czIgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBzY29wZS5mYWNlVmVydGV4VXZzWyAxIF0ucHVzaCggWyB0ZW1wVVZzMlsgYSBdLmNsb25lKCksIHRlbXBVVnMyWyBiIF0uY2xvbmUoKSwgdGVtcFVWczJbIGMgXS5jbG9uZSgpIF0gKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKCBpbmRpY2VzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBncm91cHMubGVuZ3RoID4gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNbIGkgXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gZ3JvdXAuc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gZ3JvdXAuY291bnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBqID0gc3RhcnQsIGpsID0gc3RhcnQgKyBjb3VudDsgaiA8IGpsOyBqICs9IDMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRGYWNlKCBpbmRpY2VzWyBqIF0sIGluZGljZXNbIGogKyAxIF0sIGluZGljZXNbIGogKyAyIF0gKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkgKz0gMyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkRmFjZSggaW5kaWNlc1sgaSBdLCBpbmRpY2VzWyBpICsgMSBdLCBpbmRpY2VzWyBpICsgMiBdICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoIC8gMzsgaSArPSAzICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGFkZEZhY2UoIGksIGkgKyAxLCBpICsgMiApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcblxyXG4gICAgICAgIGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94ID0gZ2VvbWV0cnkuYm91bmRpbmdCb3guY2xvbmUoKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcclxuXHJcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuYm91bmRpbmdCb3guY2VudGVyKCkubmVnYXRlKCk7XHJcblxyXG4gICAgICAgIHRoaXMudHJhbnNsYXRlKCBvZmZzZXQueCwgb2Zmc2V0LnksIG9mZnNldC56ICk7XHJcblxyXG4gICAgICAgIHJldHVybiBvZmZzZXQ7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcclxuXHJcbiAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMuYm91bmRpbmdTcGhlcmUuY2VudGVyO1xyXG4gICAgICAgIHZhciByYWRpdXMgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cztcclxuXHJcbiAgICAgICAgdmFyIHMgPSByYWRpdXMgPT09IDAgPyAxIDogMS4wIC8gcmFkaXVzO1xyXG5cclxuICAgICAgICB2YXIgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuICAgICAgICBtYXRyaXguc2V0KFxyXG4gICAgICAgICAgICBzLCAwLCAwLCAtIHMgKiBjZW50ZXIueCxcclxuICAgICAgICAgICAgMCwgcywgMCwgLSBzICogY2VudGVyLnksXHJcbiAgICAgICAgICAgIDAsIDAsIHMsIC0gcyAqIGNlbnRlci56LFxyXG4gICAgICAgICAgICAwLCAwLCAwLCAxXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgdGhpcy5hcHBseU1hdHJpeCggbWF0cml4ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29tcHV0ZUZhY2VOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBjYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIGFiID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcbiAgICAgICAgICAgIHZhciB2QSA9IHRoaXMudmVydGljZXNbIGZhY2UuYSBdO1xyXG4gICAgICAgICAgICB2YXIgdkIgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmIgXTtcclxuICAgICAgICAgICAgdmFyIHZDID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5jIF07XHJcblxyXG4gICAgICAgICAgICBjYi5zdWJWZWN0b3JzKCB2QywgdkIgKTtcclxuICAgICAgICAgICAgYWIuc3ViVmVjdG9ycyggdkEsIHZCICk7XHJcbiAgICAgICAgICAgIGNiLmNyb3NzKCBhYiApO1xyXG5cclxuICAgICAgICAgICAgY2Iubm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgICAgICBmYWNlLm5vcm1hbC5jb3B5KCBjYiApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb21wdXRlVmVydGV4Tm9ybWFsczogZnVuY3Rpb24gKCBhcmVhV2VpZ2h0ZWQgKSB7XHJcblxyXG4gICAgICAgIHZhciB2LCB2bCwgZiwgZmwsIGZhY2UsIHZlcnRpY2VzO1xyXG5cclxuICAgICAgICB2ZXJ0aWNlcyA9IG5ldyBBcnJheSggdGhpcy52ZXJ0aWNlcy5sZW5ndGggKTtcclxuXHJcbiAgICAgICAgZm9yICggdiA9IDAsIHZsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZlcnRpY2VzWyB2IF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggYXJlYVdlaWdodGVkICkge1xyXG5cclxuICAgICAgICAgICAgLy8gdmVydGV4IG5vcm1hbHMgd2VpZ2h0ZWQgYnkgdHJpYW5nbGUgYXJlYXNcclxuICAgICAgICAgICAgLy8gaHR0cDovL3d3dy5pcXVpbGV6bGVzLm9yZy93d3cvYXJ0aWNsZXMvbm9ybWFscy9ub3JtYWxzLmh0bVxyXG5cclxuICAgICAgICAgICAgdmFyIHZBLCB2QiwgdkM7XHJcbiAgICAgICAgICAgIHZhciBjYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIGFiID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcbiAgICAgICAgICAgICAgICB2QSA9IHRoaXMudmVydGljZXNbIGZhY2UuYSBdO1xyXG4gICAgICAgICAgICAgICAgdkIgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmIgXTtcclxuICAgICAgICAgICAgICAgIHZDID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5jIF07XHJcblxyXG4gICAgICAgICAgICAgICAgY2Iuc3ViVmVjdG9ycyggdkMsIHZCICk7XHJcbiAgICAgICAgICAgICAgICBhYi5zdWJWZWN0b3JzKCB2QSwgdkIgKTtcclxuICAgICAgICAgICAgICAgIGNiLmNyb3NzKCBhYiApO1xyXG5cclxuICAgICAgICAgICAgICAgIHZlcnRpY2VzWyBmYWNlLmEgXS5hZGQoIGNiICk7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1sgZmFjZS5iIF0uYWRkKCBjYiApO1xyXG4gICAgICAgICAgICAgICAgdmVydGljZXNbIGZhY2UuYyBdLmFkZCggY2IgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1sgZmFjZS5hIF0uYWRkKCBmYWNlLm5vcm1hbCApO1xyXG4gICAgICAgICAgICAgICAgdmVydGljZXNbIGZhY2UuYiBdLmFkZCggZmFjZS5ub3JtYWwgKTtcclxuICAgICAgICAgICAgICAgIHZlcnRpY2VzWyBmYWNlLmMgXS5hZGQoIGZhY2Uubm9ybWFsICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICggdiA9IDAsIHZsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZlcnRpY2VzWyB2IF0ubm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcbiAgICAgICAgICAgIGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XHJcblxyXG4gICAgICAgICAgICB2YXIgdmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcclxuXHJcbiAgICAgICAgICAgIGlmICggdmVydGV4Tm9ybWFscy5sZW5ndGggPT09IDMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmVydGV4Tm9ybWFsc1sgMCBdLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmEgXSApO1xyXG4gICAgICAgICAgICAgICAgdmVydGV4Tm9ybWFsc1sgMSBdLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmIgXSApO1xyXG4gICAgICAgICAgICAgICAgdmVydGV4Tm9ybWFsc1sgMiBdLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmMgXSApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhOb3JtYWxzWyAwIF0gPSB2ZXJ0aWNlc1sgZmFjZS5hIF0uY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgIHZlcnRleE5vcm1hbHNbIDEgXSA9IHZlcnRpY2VzWyBmYWNlLmIgXS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgdmVydGV4Tm9ybWFsc1sgMiBdID0gdmVydGljZXNbIGZhY2UuYyBdLmNsb25lKCk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvbXB1dGVNb3JwaE5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIGksIGlsLCBmLCBmbCwgZmFjZTtcclxuXHJcbiAgICAgICAgLy8gc2F2ZSBvcmlnaW5hbCBub3JtYWxzXHJcbiAgICAgICAgLy8gLSBjcmVhdGUgdGVtcCB2YXJpYWJsZXMgb24gZmlyc3QgYWNjZXNzXHJcbiAgICAgICAgLy8gICBvdGhlcndpc2UganVzdCBjb3B5IChmb3IgZmFzdGVyIHJlcGVhdGVkIGNhbGxzKVxyXG5cclxuICAgICAgICBmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuICAgICAgICAgICAgZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcbiAgICAgICAgICAgIGlmICggISBmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGZhY2UuX19vcmlnaW5hbEZhY2VOb3JtYWwgPSBmYWNlLm5vcm1hbC5jbG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICBmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsLmNvcHkoIGZhY2Uubm9ybWFsICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoICEgZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFscyApIGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIGkgPSAwLCBpbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoICEgZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFsc1sgaSBdICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzWyBpIF0gPSBmYWNlLnZlcnRleE5vcm1hbHNbIGkgXS5jbG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbIGkgXS5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIGkgXSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB1c2UgdGVtcCBnZW9tZXRyeSB0byBjb21wdXRlIGZhY2UgYW5kIHZlcnRleCBub3JtYWxzIGZvciBlYWNoIG1vcnBoXHJcblxyXG4gICAgICAgIHZhciB0bXBHZW8gPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuICAgICAgICB0bXBHZW8uZmFjZXMgPSB0aGlzLmZhY2VzO1xyXG5cclxuICAgICAgICBmb3IgKCBpID0gMCwgaWwgPSB0aGlzLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBvbiBmaXJzdCBhY2Nlc3NcclxuXHJcbiAgICAgICAgICAgIGlmICggISB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMubW9ycGhOb3JtYWxzWyBpIF0gPSB7fTtcclxuICAgICAgICAgICAgICAgIHRoaXMubW9ycGhOb3JtYWxzWyBpIF0uZmFjZU5vcm1hbHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIHRoaXMubW9ycGhOb3JtYWxzWyBpIF0udmVydGV4Tm9ybWFscyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBkc3ROb3JtYWxzRmFjZSA9IHRoaXMubW9ycGhOb3JtYWxzWyBpIF0uZmFjZU5vcm1hbHM7XHJcbiAgICAgICAgICAgICAgICB2YXIgZHN0Tm9ybWFsc1ZlcnRleCA9IHRoaXMubW9ycGhOb3JtYWxzWyBpIF0udmVydGV4Tm9ybWFscztcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZmFjZU5vcm1hbCwgdmVydGV4Tm9ybWFscztcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmYWNlTm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhOb3JtYWxzID0geyBhOiBuZXcgVEhSRUUuVmVjdG9yMygpLCBiOiBuZXcgVEhSRUUuVmVjdG9yMygpLCBjOiBuZXcgVEhSRUUuVmVjdG9yMygpIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGRzdE5vcm1hbHNGYWNlLnB1c2goIGZhY2VOb3JtYWwgKTtcclxuICAgICAgICAgICAgICAgICAgICBkc3ROb3JtYWxzVmVydGV4LnB1c2goIHZlcnRleE5vcm1hbHMgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgbW9ycGhOb3JtYWxzID0gdGhpcy5tb3JwaE5vcm1hbHNbIGkgXTtcclxuXHJcbiAgICAgICAgICAgIC8vIHNldCB2ZXJ0aWNlcyB0byBtb3JwaCB0YXJnZXRcclxuXHJcbiAgICAgICAgICAgIHRtcEdlby52ZXJ0aWNlcyA9IHRoaXMubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXM7XHJcblxyXG4gICAgICAgICAgICAvLyBjb21wdXRlIG1vcnBoIG5vcm1hbHNcclxuXHJcbiAgICAgICAgICAgIHRtcEdlby5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuICAgICAgICAgICAgdG1wR2VvLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBzdG9yZSBtb3JwaCBub3JtYWxzXHJcblxyXG4gICAgICAgICAgICB2YXIgZmFjZU5vcm1hbCwgdmVydGV4Tm9ybWFscztcclxuXHJcbiAgICAgICAgICAgIGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcbiAgICAgICAgICAgICAgICBmYWNlTm9ybWFsID0gbW9ycGhOb3JtYWxzLmZhY2VOb3JtYWxzWyBmIF07XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhOb3JtYWxzID0gbW9ycGhOb3JtYWxzLnZlcnRleE5vcm1hbHNbIGYgXTtcclxuXHJcbiAgICAgICAgICAgICAgICBmYWNlTm9ybWFsLmNvcHkoIGZhY2Uubm9ybWFsICk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmVydGV4Tm9ybWFscy5hLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgMCBdICk7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhOb3JtYWxzLmIuY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyAxIF0gKTtcclxuICAgICAgICAgICAgICAgIHZlcnRleE5vcm1hbHMuYy5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDIgXSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJlc3RvcmUgb3JpZ2luYWwgbm9ybWFsc1xyXG5cclxuICAgICAgICBmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuICAgICAgICAgICAgZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcbiAgICAgICAgICAgIGZhY2Uubm9ybWFsID0gZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbDtcclxuICAgICAgICAgICAgZmFjZS52ZXJ0ZXhOb3JtYWxzID0gZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFscztcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29tcHV0ZVRhbmdlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkdlb21ldHJ5OiAuY29tcHV0ZVRhbmdlbnRzKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb21wdXRlTGluZURpc3RhbmNlczogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgZCA9IDA7XHJcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBpID4gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBkICs9IHZlcnRpY2VzWyBpIF0uZGlzdGFuY2VUbyggdmVydGljZXNbIGkgLSAxIF0gKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMubGluZURpc3RhbmNlc1sgaSBdID0gZDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29tcHV0ZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5ib3VuZGluZ0JveCA9PT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgVEhSRUUuQm94MygpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3guc2V0RnJvbVBvaW50cyggdGhpcy52ZXJ0aWNlcyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29tcHV0ZUJvdW5kaW5nU3BoZXJlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZS5zZXRGcm9tUG9pbnRzKCB0aGlzLnZlcnRpY2VzICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBtZXJnZTogZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0cml4LCBtYXRlcmlhbEluZGV4T2Zmc2V0ICkge1xyXG5cclxuICAgICAgICBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgPT09IGZhbHNlICkge1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLkdlb21ldHJ5Lm1lcmdlKCk6IGdlb21ldHJ5IG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5HZW9tZXRyeS4nLCBnZW9tZXRyeSApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG5vcm1hbE1hdHJpeCxcclxuICAgICAgICAgICAgdmVydGV4T2Zmc2V0ID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGgsXHJcbiAgICAgICAgICAgIHZlcnRpY2VzMSA9IHRoaXMudmVydGljZXMsXHJcbiAgICAgICAgICAgIHZlcnRpY2VzMiA9IGdlb21ldHJ5LnZlcnRpY2VzLFxyXG4gICAgICAgICAgICBmYWNlczEgPSB0aGlzLmZhY2VzLFxyXG4gICAgICAgICAgICBmYWNlczIgPSBnZW9tZXRyeS5mYWNlcyxcclxuICAgICAgICAgICAgdXZzMSA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLFxyXG4gICAgICAgICAgICB1dnMyID0gZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgMCBdO1xyXG5cclxuICAgICAgICBpZiAoIG1hdGVyaWFsSW5kZXhPZmZzZXQgPT09IHVuZGVmaW5lZCApIG1hdGVyaWFsSW5kZXhPZmZzZXQgPSAwO1xyXG5cclxuICAgICAgICBpZiAoIG1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgbm9ybWFsTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHZlcnRpY2VzXHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB2ZXJ0aWNlczIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgdmVydGV4ID0gdmVydGljZXMyWyBpIF07XHJcblxyXG4gICAgICAgICAgICB2YXIgdmVydGV4Q29weSA9IHZlcnRleC5jbG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBtYXRyaXggIT09IHVuZGVmaW5lZCApIHZlcnRleENvcHkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcclxuXHJcbiAgICAgICAgICAgIHZlcnRpY2VzMS5wdXNoKCB2ZXJ0ZXhDb3B5ICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gZmFjZXNcclxuXHJcbiAgICAgICAgZm9yICggaSA9IDAsIGlsID0gZmFjZXMyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGZhY2UgPSBmYWNlczJbIGkgXSwgZmFjZUNvcHksIG5vcm1hbCwgY29sb3IsXHJcbiAgICAgICAgICAgICAgICBmYWNlVmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscyxcclxuICAgICAgICAgICAgICAgIGZhY2VWZXJ0ZXhDb2xvcnMgPSBmYWNlLnZlcnRleENvbG9ycztcclxuXHJcbiAgICAgICAgICAgIGZhY2VDb3B5ID0gbmV3IFRIUkVFLkZhY2UzKCBmYWNlLmEgKyB2ZXJ0ZXhPZmZzZXQsIGZhY2UuYiArIHZlcnRleE9mZnNldCwgZmFjZS5jICsgdmVydGV4T2Zmc2V0ICk7XHJcbiAgICAgICAgICAgIGZhY2VDb3B5Lm5vcm1hbC5jb3B5KCBmYWNlLm5vcm1hbCApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBub3JtYWxNYXRyaXggIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBmYWNlQ29weS5ub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlVmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBub3JtYWwgPSBmYWNlVmVydGV4Tm9ybWFsc1sgaiBdLmNsb25lKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBub3JtYWxNYXRyaXggIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZhY2VDb3B5LnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmYWNlQ29weS5jb2xvci5jb3B5KCBmYWNlLmNvbG9yICk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZVZlcnRleENvbG9ycy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb2xvciA9IGZhY2VWZXJ0ZXhDb2xvcnNbIGogXTtcclxuICAgICAgICAgICAgICAgIGZhY2VDb3B5LnZlcnRleENvbG9ycy5wdXNoKCBjb2xvci5jbG9uZSgpICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmYWNlQ29weS5tYXRlcmlhbEluZGV4ID0gZmFjZS5tYXRlcmlhbEluZGV4ICsgbWF0ZXJpYWxJbmRleE9mZnNldDtcclxuXHJcbiAgICAgICAgICAgIGZhY2VzMS5wdXNoKCBmYWNlQ29weSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHV2c1xyXG5cclxuICAgICAgICBmb3IgKCBpID0gMCwgaWwgPSB1dnMyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHV2ID0gdXZzMlsgaSBdLCB1dkNvcHkgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGlmICggdXYgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSB1di5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB1dkNvcHkucHVzaCggdXZbIGogXS5jbG9uZSgpICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB1dnMxLnB1c2goIHV2Q29weSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBtZXJnZU1lc2g6IGZ1bmN0aW9uICggbWVzaCApIHtcclxuXHJcbiAgICAgICAgaWYgKCBtZXNoIGluc3RhbmNlb2YgVEhSRUUuTWVzaCA9PT0gZmFsc2UgKSB7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuR2VvbWV0cnkubWVyZ2VNZXNoKCk6IG1lc2ggbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLk1lc2guJywgbWVzaCApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbWVzaC5tYXRyaXhBdXRvVXBkYXRlICYmIG1lc2gudXBkYXRlTWF0cml4KCk7XHJcblxyXG4gICAgICAgIHRoaXMubWVyZ2UoIG1lc2guZ2VvbWV0cnksIG1lc2gubWF0cml4ICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKlxyXG4gICAgICogQ2hlY2tzIGZvciBkdXBsaWNhdGUgdmVydGljZXMgd2l0aCBoYXNobWFwLlxyXG4gICAgICogRHVwbGljYXRlZCB2ZXJ0aWNlcyBhcmUgcmVtb3ZlZFxyXG4gICAgICogYW5kIGZhY2VzJyB2ZXJ0aWNlcyBhcmUgdXBkYXRlZC5cclxuICAgICAqL1xyXG5cclxuICAgIG1lcmdlVmVydGljZXM6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHZlcnRpY2VzTWFwID0ge307IC8vIEhhc2htYXAgZm9yIGxvb2tpbmcgdXAgdmVydGljZXMgYnkgcG9zaXRpb24gY29vcmRpbmF0ZXMgKGFuZCBtYWtpbmcgc3VyZSB0aGV5IGFyZSB1bmlxdWUpXHJcbiAgICAgICAgdmFyIHVuaXF1ZSA9IFtdLCBjaGFuZ2VzID0gW107XHJcblxyXG4gICAgICAgIHZhciB2LCBrZXk7XHJcbiAgICAgICAgdmFyIHByZWNpc2lvblBvaW50cyA9IDQ7IC8vIG51bWJlciBvZiBkZWNpbWFsIHBvaW50cywgZS5nLiA0IGZvciBlcHNpbG9uIG9mIDAuMDAwMVxyXG4gICAgICAgIHZhciBwcmVjaXNpb24gPSBNYXRoLnBvdyggMTAsIHByZWNpc2lvblBvaW50cyApO1xyXG4gICAgICAgIHZhciBpLCBpbCwgZmFjZTtcclxuICAgICAgICB2YXIgaW5kaWNlcywgaiwgamw7XHJcblxyXG4gICAgICAgIGZvciAoIGkgPSAwLCBpbCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xyXG4gICAgICAgICAgICBrZXkgPSBNYXRoLnJvdW5kKCB2LnggKiBwcmVjaXNpb24gKSArICdfJyArIE1hdGgucm91bmQoIHYueSAqIHByZWNpc2lvbiApICsgJ18nICsgTWF0aC5yb3VuZCggdi56ICogcHJlY2lzaW9uICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHZlcnRpY2VzTWFwWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZlcnRpY2VzTWFwWyBrZXkgXSA9IGk7XHJcbiAgICAgICAgICAgICAgICB1bmlxdWUucHVzaCggdGhpcy52ZXJ0aWNlc1sgaSBdICk7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VzWyBpIF0gPSB1bmlxdWUubGVuZ3RoIC0gMTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnRHVwbGljYXRlIHZlcnRleCBmb3VuZC4gJywgaSwgJyBjb3VsZCBiZSB1c2luZyAnLCB2ZXJ0aWNlc01hcFtrZXldKTtcclxuICAgICAgICAgICAgICAgIGNoYW5nZXNbIGkgXSA9IGNoYW5nZXNbIHZlcnRpY2VzTWFwWyBrZXkgXSBdO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLyBpZiBmYWNlcyBhcmUgY29tcGxldGVseSBkZWdlbmVyYXRlIGFmdGVyIG1lcmdpbmcgdmVydGljZXMsIHdlXHJcbiAgICAgICAgLy8gaGF2ZSB0byByZW1vdmUgdGhlbSBmcm9tIHRoZSBnZW9tZXRyeS5cclxuICAgICAgICB2YXIgZmFjZUluZGljZXNUb1JlbW92ZSA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKCBpID0gMCwgaWwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgZmFjZSA9IHRoaXMuZmFjZXNbIGkgXTtcclxuXHJcbiAgICAgICAgICAgIGZhY2UuYSA9IGNoYW5nZXNbIGZhY2UuYSBdO1xyXG4gICAgICAgICAgICBmYWNlLmIgPSBjaGFuZ2VzWyBmYWNlLmIgXTtcclxuICAgICAgICAgICAgZmFjZS5jID0gY2hhbmdlc1sgZmFjZS5jIF07XHJcblxyXG4gICAgICAgICAgICBpbmRpY2VzID0gWyBmYWNlLmEsIGZhY2UuYiwgZmFjZS5jIF07XHJcblxyXG4gICAgICAgICAgICB2YXIgZHVwSW5kZXggPSAtIDE7XHJcblxyXG4gICAgICAgICAgICAvLyBpZiBhbnkgZHVwbGljYXRlIHZlcnRpY2VzIGFyZSBmb3VuZCBpbiBhIEZhY2UzXHJcbiAgICAgICAgICAgIC8vIHdlIGhhdmUgdG8gcmVtb3ZlIHRoZSBmYWNlIGFzIG5vdGhpbmcgY2FuIGJlIHNhdmVkXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBuID0gMDsgbiA8IDM7IG4gKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBpbmRpY2VzWyBuIF0gPT09IGluZGljZXNbICggbiArIDEgKSAlIDMgXSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZHVwSW5kZXggPSBuO1xyXG4gICAgICAgICAgICAgICAgICAgIGZhY2VJbmRpY2VzVG9SZW1vdmUucHVzaCggaSApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKCBpID0gZmFjZUluZGljZXNUb1JlbW92ZS5sZW5ndGggLSAxOyBpID49IDA7IGkgLS0gKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgaWR4ID0gZmFjZUluZGljZXNUb1JlbW92ZVsgaSBdO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5mYWNlcy5zcGxpY2UoIGlkeCwgMSApO1xyXG5cclxuICAgICAgICAgICAgZm9yICggaiA9IDAsIGpsID0gdGhpcy5mYWNlVmVydGV4VXZzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgaiBdLnNwbGljZSggaWR4LCAxICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXNlIHVuaXF1ZSBzZXQgb2YgdmVydGljZXNcclxuXHJcbiAgICAgICAgdmFyIGRpZmYgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIHVuaXF1ZS5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy52ZXJ0aWNlcyA9IHVuaXF1ZTtcclxuICAgICAgICByZXR1cm4gZGlmZjtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNvcnRGYWNlc0J5TWF0ZXJpYWxJbmRleDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgZmFjZXMgPSB0aGlzLmZhY2VzO1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBmYWNlcy5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIHRhZyBmYWNlc1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICBmYWNlc1sgaSBdLl9pZCA9IGk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gc29ydCBmYWNlc1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBtYXRlcmlhbEluZGV4U29ydCggYSwgYiApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBhLm1hdGVyaWFsSW5kZXggLSBiLm1hdGVyaWFsSW5kZXg7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZmFjZXMuc29ydCggbWF0ZXJpYWxJbmRleFNvcnQgKTtcclxuXHJcbiAgICAgICAgLy8gc29ydCB1dnNcclxuXHJcbiAgICAgICAgdmFyIHV2czEgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXTtcclxuICAgICAgICB2YXIgdXZzMiA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMSBdO1xyXG5cclxuICAgICAgICB2YXIgbmV3VXZzMSwgbmV3VXZzMjtcclxuXHJcbiAgICAgICAgaWYgKCB1dnMxICYmIHV2czEubGVuZ3RoID09PSBsZW5ndGggKSBuZXdVdnMxID0gW107XHJcbiAgICAgICAgaWYgKCB1dnMyICYmIHV2czIubGVuZ3RoID09PSBsZW5ndGggKSBuZXdVdnMyID0gW107XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBpZCA9IGZhY2VzWyBpIF0uX2lkO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBuZXdVdnMxICkgbmV3VXZzMS5wdXNoKCB1dnMxWyBpZCBdICk7XHJcbiAgICAgICAgICAgIGlmICggbmV3VXZzMiApIG5ld1V2czIucHVzaCggdXZzMlsgaWQgXSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggbmV3VXZzMSApIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdID0gbmV3VXZzMTtcclxuICAgICAgICBpZiAoIG5ld1V2czIgKSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDEgXSA9IG5ld1V2czI7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0b0pTT046IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIGRhdGEgPSB7XHJcbiAgICAgICAgICAgIG1ldGFkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiA0LjQsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnR2VvbWV0cnknLFxyXG4gICAgICAgICAgICAgICAgZ2VuZXJhdG9yOiAnR2VvbWV0cnkudG9KU09OJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gc3RhbmRhcmQgR2VvbWV0cnkgc2VyaWFsaXphdGlvblxyXG5cclxuICAgICAgICBkYXRhLnV1aWQgPSB0aGlzLnV1aWQ7XHJcbiAgICAgICAgZGF0YS50eXBlID0gdGhpcy50eXBlO1xyXG4gICAgICAgIGlmICggdGhpcy5uYW1lICE9PSAnJyApIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLnBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGtleSBpbiBwYXJhbWV0ZXJzICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggcGFyYW1ldGVyc1sga2V5IF0gIT09IHVuZGVmaW5lZCApIGRhdGFbIGtleSBdID0gcGFyYW1ldGVyc1sga2V5IF07XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdmVydGljZXMgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgdmVydGV4ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xyXG4gICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGZhY2VzID0gW107XHJcbiAgICAgICAgdmFyIG5vcm1hbHMgPSBbXTtcclxuICAgICAgICB2YXIgbm9ybWFsc0hhc2ggPSB7fTtcclxuICAgICAgICB2YXIgY29sb3JzID0gW107XHJcbiAgICAgICAgdmFyIGNvbG9yc0hhc2ggPSB7fTtcclxuICAgICAgICB2YXIgdXZzID0gW107XHJcbiAgICAgICAgdmFyIHV2c0hhc2ggPSB7fTtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5mYWNlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgZmFjZSA9IHRoaXMuZmFjZXNbIGkgXTtcclxuXHJcbiAgICAgICAgICAgIHZhciBoYXNNYXRlcmlhbCA9IGZhbHNlOyAvLyBmYWNlLm1hdGVyaWFsSW5kZXggIT09IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgdmFyIGhhc0ZhY2VVdiA9IGZhbHNlOyAvLyBkZXByZWNhdGVkXHJcbiAgICAgICAgICAgIHZhciBoYXNGYWNlVmVydGV4VXYgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXVsgaSBdICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHZhciBoYXNGYWNlTm9ybWFsID0gZmFjZS5ub3JtYWwubGVuZ3RoKCkgPiAwO1xyXG4gICAgICAgICAgICB2YXIgaGFzRmFjZVZlcnRleE5vcm1hbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGggPiAwO1xyXG4gICAgICAgICAgICB2YXIgaGFzRmFjZUNvbG9yID0gZmFjZS5jb2xvci5yICE9PSAxIHx8IGZhY2UuY29sb3IuZyAhPT0gMSB8fCBmYWNlLmNvbG9yLmIgIT09IDE7XHJcbiAgICAgICAgICAgIHZhciBoYXNGYWNlVmVydGV4Q29sb3IgPSBmYWNlLnZlcnRleENvbG9ycy5sZW5ndGggPiAwO1xyXG5cclxuICAgICAgICAgICAgdmFyIGZhY2VUeXBlID0gMDtcclxuXHJcbiAgICAgICAgICAgIGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgMCwgMCApO1xyXG4gICAgICAgICAgICBmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDEsIGhhc01hdGVyaWFsICk7XHJcbiAgICAgICAgICAgIGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgMiwgaGFzRmFjZVV2ICk7XHJcbiAgICAgICAgICAgIGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgMywgaGFzRmFjZVZlcnRleFV2ICk7XHJcbiAgICAgICAgICAgIGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgNCwgaGFzRmFjZU5vcm1hbCApO1xyXG4gICAgICAgICAgICBmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDUsIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgKTtcclxuICAgICAgICAgICAgZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA2LCBoYXNGYWNlQ29sb3IgKTtcclxuICAgICAgICAgICAgZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA3LCBoYXNGYWNlVmVydGV4Q29sb3IgKTtcclxuXHJcbiAgICAgICAgICAgIGZhY2VzLnB1c2goIGZhY2VUeXBlICk7XHJcbiAgICAgICAgICAgIGZhY2VzLnB1c2goIGZhY2UuYSwgZmFjZS5iLCBmYWNlLmMgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggaGFzRmFjZVZlcnRleFV2ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBmYWNlVmVydGV4VXZzID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF1bIGkgXTtcclxuXHJcbiAgICAgICAgICAgICAgICBmYWNlcy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgICAgIGdldFV2SW5kZXgoIGZhY2VWZXJ0ZXhVdnNbIDAgXSApLFxyXG4gICAgICAgICAgICAgICAgICAgIGdldFV2SW5kZXgoIGZhY2VWZXJ0ZXhVdnNbIDEgXSApLFxyXG4gICAgICAgICAgICAgICAgICAgIGdldFV2SW5kZXgoIGZhY2VWZXJ0ZXhVdnNbIDIgXSApXHJcbiAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBoYXNGYWNlTm9ybWFsICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGZhY2VzLnB1c2goIGdldE5vcm1hbEluZGV4KCBmYWNlLm5vcm1hbCApICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XHJcblxyXG4gICAgICAgICAgICAgICAgZmFjZXMucHVzaChcclxuICAgICAgICAgICAgICAgICAgICBnZXROb3JtYWxJbmRleCggdmVydGV4Tm9ybWFsc1sgMCBdICksXHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0Tm9ybWFsSW5kZXgoIHZlcnRleE5vcm1hbHNbIDEgXSApLFxyXG4gICAgICAgICAgICAgICAgICAgIGdldE5vcm1hbEluZGV4KCB2ZXJ0ZXhOb3JtYWxzWyAyIF0gKVxyXG4gICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggaGFzRmFjZUNvbG9yICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGZhY2VzLnB1c2goIGdldENvbG9ySW5kZXgoIGZhY2UuY29sb3IgKSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBoYXNGYWNlVmVydGV4Q29sb3IgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHZlcnRleENvbG9ycyA9IGZhY2UudmVydGV4Q29sb3JzO1xyXG5cclxuICAgICAgICAgICAgICAgIGZhY2VzLnB1c2goXHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q29sb3JJbmRleCggdmVydGV4Q29sb3JzWyAwIF0gKSxcclxuICAgICAgICAgICAgICAgICAgICBnZXRDb2xvckluZGV4KCB2ZXJ0ZXhDb2xvcnNbIDEgXSApLFxyXG4gICAgICAgICAgICAgICAgICAgIGdldENvbG9ySW5kZXgoIHZlcnRleENvbG9yc1sgMiBdIClcclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gc2V0Qml0KCB2YWx1ZSwgcG9zaXRpb24sIGVuYWJsZWQgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZW5hYmxlZCA/IHZhbHVlIHwgKCAxIDw8IHBvc2l0aW9uICkgOiB2YWx1ZSAmICggfiAoIDEgPDwgcG9zaXRpb24gKSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGdldE5vcm1hbEluZGV4KCBub3JtYWwgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgaGFzaCA9IG5vcm1hbC54LnRvU3RyaW5nKCkgKyBub3JtYWwueS50b1N0cmluZygpICsgbm9ybWFsLnoudG9TdHJpbmcoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggbm9ybWFsc0hhc2hbIGhhc2ggXSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxzSGFzaFsgaGFzaCBdO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbm9ybWFsc0hhc2hbIGhhc2ggXSA9IG5vcm1hbHMubGVuZ3RoIC8gMztcclxuICAgICAgICAgICAgbm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsc0hhc2hbIGhhc2ggXTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBnZXRDb2xvckluZGV4KCBjb2xvciApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBoYXNoID0gY29sb3Iuci50b1N0cmluZygpICsgY29sb3IuZy50b1N0cmluZygpICsgY29sb3IuYi50b1N0cmluZygpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBjb2xvcnNIYXNoWyBoYXNoIF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sb3JzSGFzaFsgaGFzaCBdO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29sb3JzSGFzaFsgaGFzaCBdID0gY29sb3JzLmxlbmd0aDtcclxuICAgICAgICAgICAgY29sb3JzLnB1c2goIGNvbG9yLmdldEhleCgpICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY29sb3JzSGFzaFsgaGFzaCBdO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGdldFV2SW5kZXgoIHV2ICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGhhc2ggPSB1di54LnRvU3RyaW5nKCkgKyB1di55LnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHV2c0hhc2hbIGhhc2ggXSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB1dnNIYXNoWyBoYXNoIF07XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB1dnNIYXNoWyBoYXNoIF0gPSB1dnMubGVuZ3RoIC8gMjtcclxuICAgICAgICAgICAgdXZzLnB1c2goIHV2LngsIHV2LnkgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB1dnNIYXNoWyBoYXNoIF07XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZGF0YS5kYXRhID0ge307XHJcblxyXG4gICAgICAgIGRhdGEuZGF0YS52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xyXG4gICAgICAgIGRhdGEuZGF0YS5ub3JtYWxzID0gbm9ybWFscztcclxuICAgICAgICBpZiAoIGNvbG9ycy5sZW5ndGggPiAwICkgZGF0YS5kYXRhLmNvbG9ycyA9IGNvbG9ycztcclxuICAgICAgICBpZiAoIHV2cy5sZW5ndGggPiAwICkgZGF0YS5kYXRhLnV2cyA9IFsgdXZzIF07IC8vIHRlbXBvcmFsIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcclxuICAgICAgICBkYXRhLmRhdGEuZmFjZXMgPSBmYWNlcztcclxuXHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcbiAgICAgICAgdGhpcy52ZXJ0aWNlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZmFjZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnMgPSBbIFtdIF07XHJcblxyXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHNvdXJjZS52ZXJ0aWNlcztcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1sgaSBdLmNsb25lKCkgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZmFjZXMgPSBzb3VyY2UuZmFjZXM7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBmYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZmFjZXMucHVzaCggZmFjZXNbIGkgXS5jbG9uZSgpICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHNvdXJjZS5mYWNlVmVydGV4VXZzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGZhY2VWZXJ0ZXhVdnMgPSBzb3VyY2UuZmFjZVZlcnRleFV2c1sgaSBdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCB0aGlzLmZhY2VWZXJ0ZXhVdnNbIGkgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgaSBdID0gW107XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZVZlcnRleFV2cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdXZzID0gZmFjZVZlcnRleFV2c1sgaiBdLCB1dnNDb3B5ID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGsgPSAwLCBrbCA9IHV2cy5sZW5ndGg7IGsgPCBrbDsgayArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHV2ID0gdXZzWyBrIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHV2c0NvcHkucHVzaCggdXYuY2xvbmUoKSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIGkgXS5wdXNoKCB1dnNDb3B5ICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLkdlb21ldHJ5SWRDb3VudCA9IDA7XHJcblxyXG4vLyBGaWxlOnNyYy9jb3JlL0RpcmVjdEdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5EaXJlY3RHZW9tZXRyeSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IFRIUkVFLkdlb21ldHJ5SWRDb3VudCArKyB9ICk7XHJcblxyXG4gICAgdGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcbiAgICB0aGlzLm5hbWUgPSAnJztcclxuICAgIHRoaXMudHlwZSA9ICdEaXJlY3RHZW9tZXRyeSc7XHJcblxyXG4gICAgdGhpcy5pbmRpY2VzID0gW107XHJcbiAgICB0aGlzLnZlcnRpY2VzID0gW107XHJcbiAgICB0aGlzLm5vcm1hbHMgPSBbXTtcclxuICAgIHRoaXMuY29sb3JzID0gW107XHJcbiAgICB0aGlzLnV2cyA9IFtdO1xyXG4gICAgdGhpcy51dnMyID0gW107XHJcblxyXG4gICAgdGhpcy5ncm91cHMgPSBbXTtcclxuXHJcbiAgICB0aGlzLm1vcnBoVGFyZ2V0cyA9IHt9O1xyXG5cclxuICAgIHRoaXMuc2tpbldlaWdodHMgPSBbXTtcclxuICAgIHRoaXMuc2tpbkluZGljZXMgPSBbXTtcclxuXHJcbiAgICAvLyB0aGlzLmxpbmVEaXN0YW5jZXMgPSBbXTtcclxuXHJcbiAgICB0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcclxuICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xyXG5cclxuICAgIC8vIHVwZGF0ZSBmbGFnc1xyXG5cclxuICAgIHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XHJcbiAgICB0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcbiAgICB0aGlzLmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuICAgIHRoaXMudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5ncm91cHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRGlyZWN0R2VvbWV0cnkucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5EaXJlY3RHZW9tZXRyeSxcclxuXHJcbiAgICBjb21wdXRlQm91bmRpbmdCb3g6IFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZS5jb21wdXRlQm91bmRpbmdCb3gsXHJcbiAgICBjb21wdXRlQm91bmRpbmdTcGhlcmU6IFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZS5jb21wdXRlQm91bmRpbmdTcGhlcmUsXHJcblxyXG4gICAgY29tcHV0ZUZhY2VOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkRpcmVjdEdlb21ldHJ5OiBjb21wdXRlRmFjZU5vcm1hbHMoKSBpcyBub3QgYSBtZXRob2Qgb2YgdGhpcyB0eXBlIG9mIGdlb21ldHJ5LicgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvbXB1dGVWZXJ0ZXhOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkRpcmVjdEdlb21ldHJ5OiBjb21wdXRlVmVydGV4Tm9ybWFscygpIGlzIG5vdCBhIG1ldGhvZCBvZiB0aGlzIHR5cGUgb2YgZ2VvbWV0cnkuJyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29tcHV0ZUdyb3VwczogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcclxuXHJcbiAgICAgICAgdmFyIGdyb3VwO1xyXG4gICAgICAgIHZhciBncm91cHMgPSBbXTtcclxuICAgICAgICB2YXIgbWF0ZXJpYWxJbmRleDtcclxuXHJcbiAgICAgICAgdmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGZhY2VzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBmYWNlID0gZmFjZXNbIGkgXTtcclxuXHJcbiAgICAgICAgICAgIC8vIG1hdGVyaWFsc1xyXG5cclxuICAgICAgICAgICAgaWYgKCBmYWNlLm1hdGVyaWFsSW5kZXggIT09IG1hdGVyaWFsSW5kZXggKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWxJbmRleCA9IGZhY2UubWF0ZXJpYWxJbmRleDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGdyb3VwICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLmNvdW50ID0gKCBpICogMyApIC0gZ3JvdXAuc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBzLnB1c2goIGdyb3VwICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGdyb3VwID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBpICogMyxcclxuICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbEluZGV4OiBtYXRlcmlhbEluZGV4XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggZ3JvdXAgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIGdyb3VwLmNvdW50ID0gKCBpICogMyApIC0gZ3JvdXAuc3RhcnQ7XHJcbiAgICAgICAgICAgIGdyb3Vwcy5wdXNoKCBncm91cCApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZ3JvdXBzID0gZ3JvdXBzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZnJvbUdlb21ldHJ5OiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xyXG5cclxuICAgICAgICB2YXIgZmFjZXMgPSBnZW9tZXRyeS5mYWNlcztcclxuICAgICAgICB2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcclxuICAgICAgICB2YXIgZmFjZVZlcnRleFV2cyA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnM7XHJcblxyXG4gICAgICAgIHZhciBoYXNGYWNlVmVydGV4VXYgPSBmYWNlVmVydGV4VXZzWyAwIF0gJiYgZmFjZVZlcnRleFV2c1sgMCBdLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgdmFyIGhhc0ZhY2VWZXJ0ZXhVdjIgPSBmYWNlVmVydGV4VXZzWyAxIF0gJiYgZmFjZVZlcnRleFV2c1sgMSBdLmxlbmd0aCA+IDA7XHJcblxyXG4gICAgICAgIC8vIG1vcnBoc1xyXG5cclxuICAgICAgICB2YXIgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzO1xyXG4gICAgICAgIHZhciBtb3JwaFRhcmdldHNMZW5ndGggPSBtb3JwaFRhcmdldHMubGVuZ3RoO1xyXG5cclxuICAgICAgICBpZiAoIG1vcnBoVGFyZ2V0c0xlbmd0aCA+IDAgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbW9ycGhUYXJnZXRzUG9zaXRpb24gPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG1vcnBoVGFyZ2V0c0xlbmd0aDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBtb3JwaFRhcmdldHNQb3NpdGlvblsgaSBdID0gW107XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLm1vcnBoVGFyZ2V0cy5wb3NpdGlvbiA9IG1vcnBoVGFyZ2V0c1Bvc2l0aW9uO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBtb3JwaE5vcm1hbHMgPSBnZW9tZXRyeS5tb3JwaE5vcm1hbHM7XHJcbiAgICAgICAgdmFyIG1vcnBoTm9ybWFsc0xlbmd0aCA9IG1vcnBoTm9ybWFscy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGlmICggbW9ycGhOb3JtYWxzTGVuZ3RoID4gMCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBtb3JwaFRhcmdldHNOb3JtYWwgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG1vcnBoTm9ybWFsc0xlbmd0aDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBtb3JwaFRhcmdldHNOb3JtYWxbIGkgXSA9IFtdO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5tb3JwaFRhcmdldHMubm9ybWFsID0gbW9ycGhUYXJnZXRzTm9ybWFsO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHNraW5zXHJcblxyXG4gICAgICAgIHZhciBza2luSW5kaWNlcyA9IGdlb21ldHJ5LnNraW5JbmRpY2VzO1xyXG4gICAgICAgIHZhciBza2luV2VpZ2h0cyA9IGdlb21ldHJ5LnNraW5XZWlnaHRzO1xyXG5cclxuICAgICAgICB2YXIgaGFzU2tpbkluZGljZXMgPSBza2luSW5kaWNlcy5sZW5ndGggPT09IHZlcnRpY2VzLmxlbmd0aDtcclxuICAgICAgICB2YXIgaGFzU2tpbldlaWdodHMgPSBza2luV2VpZ2h0cy5sZW5ndGggPT09IHZlcnRpY2VzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgLy9cclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZmFjZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cclxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1sgZmFjZS5hIF0sIHZlcnRpY2VzWyBmYWNlLmIgXSwgdmVydGljZXNbIGZhY2UuYyBdICk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcclxuXHJcbiAgICAgICAgICAgIGlmICggdmVydGV4Tm9ybWFscy5sZW5ndGggPT09IDMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5ub3JtYWxzLnB1c2goIHZlcnRleE5vcm1hbHNbIDAgXSwgdmVydGV4Tm9ybWFsc1sgMSBdLCB2ZXJ0ZXhOb3JtYWxzWyAyIF0gKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbCA9IGZhY2Uubm9ybWFsO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMubm9ybWFscy5wdXNoKCBub3JtYWwsIG5vcm1hbCwgbm9ybWFsICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgdmVydGV4Q29sb3JzID0gZmFjZS52ZXJ0ZXhDb2xvcnM7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHZlcnRleENvbG9ycy5sZW5ndGggPT09IDMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xvcnMucHVzaCggdmVydGV4Q29sb3JzWyAwIF0sIHZlcnRleENvbG9yc1sgMSBdLCB2ZXJ0ZXhDb2xvcnNbIDIgXSApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBmYWNlLmNvbG9yO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuY29sb3JzLnB1c2goIGNvbG9yLCBjb2xvciwgY29sb3IgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggaGFzRmFjZVZlcnRleFV2ID09PSB0cnVlICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXhVdnMgPSBmYWNlVmVydGV4VXZzWyAwIF1bIGkgXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHZlcnRleFV2cyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnV2cy5wdXNoKCB2ZXJ0ZXhVdnNbIDAgXSwgdmVydGV4VXZzWyAxIF0sIHZlcnRleFV2c1sgMiBdICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuRGlyZWN0R2VvbWV0cnkuZnJvbUdlb21ldHJ5KCk6IFVuZGVmaW5lZCB2ZXJ0ZXhVdiAnLCBpICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXZzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCksIG5ldyBUSFJFRS5WZWN0b3IyKCksIG5ldyBUSFJFRS5WZWN0b3IyKCkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIGhhc0ZhY2VWZXJ0ZXhVdjIgPT09IHRydWUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHZlcnRleFV2cyA9IGZhY2VWZXJ0ZXhVdnNbIDEgXVsgaSBdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggdmVydGV4VXZzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXZzMi5wdXNoKCB2ZXJ0ZXhVdnNbIDAgXSwgdmVydGV4VXZzWyAxIF0sIHZlcnRleFV2c1sgMiBdICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuRGlyZWN0R2VvbWV0cnkuZnJvbUdlb21ldHJ5KCk6IFVuZGVmaW5lZCB2ZXJ0ZXhVdjIgJywgaSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnV2czIucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoKSwgbmV3IFRIUkVFLlZlY3RvcjIoKSwgbmV3IFRIUkVFLlZlY3RvcjIoKSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIG1vcnBoc1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwgbW9ycGhUYXJnZXRzTGVuZ3RoOyBqICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBtb3JwaFRhcmdldCA9IG1vcnBoVGFyZ2V0c1sgaiBdLnZlcnRpY2VzO1xyXG5cclxuICAgICAgICAgICAgICAgIG1vcnBoVGFyZ2V0c1Bvc2l0aW9uWyBqIF0ucHVzaCggbW9ycGhUYXJnZXRbIGZhY2UuYSBdLCBtb3JwaFRhcmdldFsgZmFjZS5iIF0sIG1vcnBoVGFyZ2V0WyBmYWNlLmMgXSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwgbW9ycGhOb3JtYWxzTGVuZ3RoOyBqICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBtb3JwaE5vcm1hbCA9IG1vcnBoTm9ybWFsc1sgaiBdLnZlcnRleE5vcm1hbHNbIGkgXTtcclxuXHJcbiAgICAgICAgICAgICAgICBtb3JwaFRhcmdldHNOb3JtYWxbIGogXS5wdXNoKCBtb3JwaE5vcm1hbC5hLCBtb3JwaE5vcm1hbC5iLCBtb3JwaE5vcm1hbC5jICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBza2luc1xyXG5cclxuICAgICAgICAgICAgaWYgKCBoYXNTa2luSW5kaWNlcyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNraW5JbmRpY2VzLnB1c2goIHNraW5JbmRpY2VzWyBmYWNlLmEgXSwgc2tpbkluZGljZXNbIGZhY2UuYiBdLCBza2luSW5kaWNlc1sgZmFjZS5jIF0gKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggaGFzU2tpbldlaWdodHMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5za2luV2VpZ2h0cy5wdXNoKCBza2luV2VpZ2h0c1sgZmFjZS5hIF0sIHNraW5XZWlnaHRzWyBmYWNlLmIgXSwgc2tpbldlaWdodHNbIGZhY2UuYyBdICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jb21wdXRlR3JvdXBzKCBnZW9tZXRyeSApO1xyXG5cclxuICAgICAgICB0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZTtcclxuICAgICAgICB0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGU7XHJcbiAgICAgICAgdGhpcy5jb2xvcnNOZWVkVXBkYXRlID0gZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZTtcclxuICAgICAgICB0aGlzLnV2c05lZWRVcGRhdGUgPSBnZW9tZXRyeS51dnNOZWVkVXBkYXRlO1xyXG4gICAgICAgIHRoaXMuZ3JvdXBzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5Lmdyb3Vwc05lZWRVcGRhdGU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuRGlyZWN0R2VvbWV0cnkucHJvdG90eXBlICk7XHJcblxyXG4vLyBGaWxlOnNyYy9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5CdWZmZXJHZW9tZXRyeSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IFRIUkVFLkdlb21ldHJ5SWRDb3VudCArKyB9ICk7XHJcblxyXG4gICAgdGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcbiAgICB0aGlzLm5hbWUgPSAnJztcclxuICAgIHRoaXMudHlwZSA9ICdCdWZmZXJHZW9tZXRyeSc7XHJcblxyXG4gICAgdGhpcy5pbmRleCA9IG51bGw7XHJcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcclxuXHJcbiAgICB0aGlzLm1vcnBoQXR0cmlidXRlcyA9IHt9O1xyXG5cclxuICAgIHRoaXMuZ3JvdXBzID0gW107XHJcblxyXG4gICAgdGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XHJcbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLmRyYXdSYW5nZSA9IHsgc3RhcnQ6IDAsIGNvdW50OiBJbmZpbml0eSB9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuQnVmZmVyR2VvbWV0cnksXHJcblxyXG4gICAgYWRkSW5kZXg6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuYWRkSW5kZXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRJbmRleCgpLicgKTtcclxuICAgICAgICB0aGlzLnNldEluZGV4KCBpbmRleCApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0SW5kZXg6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXg7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRJbmRleDogZnVuY3Rpb24gKCBpbmRleCApIHtcclxuXHJcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYWRkQXR0cmlidXRlOiBmdW5jdGlvbiAoIG5hbWUsIGF0dHJpYnV0ZSApIHtcclxuXHJcbiAgICAgICAgaWYgKCBhdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUgPT09IGZhbHNlICYmIGF0dHJpYnV0ZSBpbnN0YW5jZW9mIFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlID09PSBmYWxzZSApIHtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuYWRkQXR0cmlidXRlKCkgbm93IGV4cGVjdHMgKCBuYW1lLCBhdHRyaWJ1dGUgKS4nICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggbmFtZSwgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggYXJndW1lbnRzWyAxIF0sIGFyZ3VtZW50c1sgMiBdICkgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIG5hbWUgPT09ICdpbmRleCcgKSB7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5hZGRBdHRyaWJ1dGU6IFVzZSAuc2V0SW5kZXgoKSBmb3IgaW5kZXggYXR0cmlidXRlLicgKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRJbmRleCggYXR0cmlidXRlICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF0gPSBhdHRyaWJ1dGU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRBdHRyaWJ1dGU6IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlQXR0cmlidXRlOiBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG4gICAgICAgIGRlbGV0ZSB0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldCBkcmF3Y2FsbHMoKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmRyYXdjYWxscyBoYXMgYmVlbiByZW5hbWVkIHRvIC5ncm91cHMuJyApO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdyb3VwcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldCBvZmZzZXRzKCkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLm9mZnNldHMgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ3JvdXBzLicgKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5ncm91cHM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhZGREcmF3Q2FsbDogZnVuY3Rpb24gKCBzdGFydCwgY291bnQsIGluZGV4T2Zmc2V0ICkge1xyXG5cclxuICAgICAgICBpZiAoIGluZGV4T2Zmc2V0ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZERyYXdDYWxsKCkgbm8gbG9uZ2VyIHN1cHBvcnRzIGluZGV4T2Zmc2V0LicgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZERyYXdDYWxsKCkgaXMgbm93IC5hZGRHcm91cCgpLicgKTtcclxuICAgICAgICB0aGlzLmFkZEdyb3VwKCBzdGFydCwgY291bnQgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNsZWFyRHJhd0NhbGxzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuY2xlYXJEcmF3Q2FsbHMoKSBpcyBub3cgLmNsZWFyR3JvdXBzKCkuJyApO1xyXG4gICAgICAgIHRoaXMuY2xlYXJHcm91cHMoKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFkZEdyb3VwOiBmdW5jdGlvbiAoIHN0YXJ0LCBjb3VudCwgbWF0ZXJpYWxJbmRleCApIHtcclxuXHJcbiAgICAgICAgdGhpcy5ncm91cHMucHVzaCgge1xyXG5cclxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG4gICAgICAgICAgICBjb3VudDogY291bnQsXHJcbiAgICAgICAgICAgIG1hdGVyaWFsSW5kZXg6IG1hdGVyaWFsSW5kZXggIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsSW5kZXggOiAwXHJcblxyXG4gICAgICAgIH0gKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNsZWFyR3JvdXBzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMuZ3JvdXBzID0gW107XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXREcmF3UmFuZ2U6IGZ1bmN0aW9uICggc3RhcnQsIGNvdW50ICkge1xyXG5cclxuICAgICAgICB0aGlzLmRyYXdSYW5nZS5zdGFydCA9IHN0YXJ0O1xyXG4gICAgICAgIHRoaXMuZHJhd1JhbmdlLmNvdW50ID0gY291bnQ7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhcHBseU1hdHJpeDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XHJcblxyXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuXHJcbiAgICAgICAgaWYgKCBwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgbWF0cml4LmFwcGx5VG9WZWN0b3IzQXJyYXkoIHBvc2l0aW9uLmFycmF5ICk7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbm9ybWFsID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtcclxuXHJcbiAgICAgICAgaWYgKCBub3JtYWwgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XHJcblxyXG4gICAgICAgICAgICBub3JtYWxNYXRyaXguYXBwbHlUb1ZlY3RvcjNBcnJheSggbm9ybWFsLmFycmF5ICk7XHJcbiAgICAgICAgICAgIG5vcm1hbC5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICByb3RhdGVYOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeC1heGlzXHJcblxyXG4gICAgICAgIHZhciBtMTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVgoIGFuZ2xlICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuICAgICAgICAgICAgbTEubWFrZVJvdGF0aW9uWCggYW5nbGUgKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgcm90YXRlWTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHktYXhpc1xyXG5cclxuICAgICAgICB2YXIgbTE7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiByb3RhdGVZKCBhbmdsZSApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcbiAgICAgICAgICAgIG0xLm1ha2VSb3RhdGlvblkoIGFuZ2xlICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIHJvdGF0ZVo6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgLy8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB6LWF4aXNcclxuXHJcbiAgICAgICAgdmFyIG0xO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcm90YXRlWiggYW5nbGUgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG4gICAgICAgICAgICBtMS5tYWtlUm90YXRpb25aKCBhbmdsZSApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hcHBseU1hdHJpeCggbTEgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgLy8gdHJhbnNsYXRlIGdlb21ldHJ5XHJcblxyXG4gICAgICAgIHZhciBtMTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHRyYW5zbGF0ZSggeCwgeSwgeiApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcbiAgICAgICAgICAgIG0xLm1ha2VUcmFuc2xhdGlvbiggeCwgeSwgeiApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hcHBseU1hdHJpeCggbTEgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBzY2FsZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAvLyBzY2FsZSBnZW9tZXRyeVxyXG5cclxuICAgICAgICB2YXIgbTE7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzY2FsZSggeCwgeSwgeiApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcbiAgICAgICAgICAgIG0xLm1ha2VTY2FsZSggeCwgeSwgeiApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hcHBseU1hdHJpeCggbTEgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBsb29rQXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIG9iajtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGxvb2tBdCggdmVjdG9yICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBvYmogPT09IHVuZGVmaW5lZCApIG9iaiA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xyXG5cclxuICAgICAgICAgICAgb2JqLmxvb2tBdCggdmVjdG9yICk7XHJcblxyXG4gICAgICAgICAgICBvYmoudXBkYXRlTWF0cml4KCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFwcGx5TWF0cml4KCBvYmoubWF0cml4ICk7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIGNlbnRlcjogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xyXG5cclxuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5ib3VuZGluZ0JveC5jZW50ZXIoKS5uZWdhdGUoKTtcclxuXHJcbiAgICAgICAgdGhpcy50cmFuc2xhdGUoIG9mZnNldC54LCBvZmZzZXQueSwgb2Zmc2V0LnogKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZyb21PYmplY3Q6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LnNldEZyb21PYmplY3QoKS4gQ29udmVydGluZycsIG9iamVjdCwgdGhpcyApO1xyXG5cclxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XHJcblxyXG4gICAgICAgIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRzIHx8IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmUgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCAqIDMsIDMgKTtcclxuICAgICAgICAgICAgdmFyIGNvbG9ycyA9IG5ldyBUSFJFRS5GbG9hdDMyQXR0cmlidXRlKCBnZW9tZXRyeS5jb2xvcnMubGVuZ3RoICogMywgMyApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHBvc2l0aW9ucy5jb3B5VmVjdG9yM3NBcnJheSggZ2VvbWV0cnkudmVydGljZXMgKSApO1xyXG4gICAgICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ2NvbG9yJywgY29sb3JzLmNvcHlDb2xvcnNBcnJheSggZ2VvbWV0cnkuY29sb3JzICkgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggZ2VvbWV0cnkubGluZURpc3RhbmNlcyAmJiBnZW9tZXRyeS5saW5lRGlzdGFuY2VzLmxlbmd0aCA9PT0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBsaW5lRGlzdGFuY2VzID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMubGVuZ3RoLCAxICk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdsaW5lRGlzdGFuY2UnLCBsaW5lRGlzdGFuY2VzLmNvcHlBcnJheSggZ2VvbWV0cnkubGluZURpc3RhbmNlcyApICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94ID0gZ2VvbWV0cnkuYm91bmRpbmdCb3guY2xvbmUoKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyb21HZW9tZXRyeSggZ2VvbWV0cnkgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZUZyb21PYmplY3Q6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XHJcblxyXG4gICAgICAgIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBkaXJlY3QgPSBnZW9tZXRyeS5fX2RpcmVjdEdlb21ldHJ5O1xyXG5cclxuICAgICAgICAgICAgaWYgKCBkaXJlY3QgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tR2VvbWV0cnkoIGdlb21ldHJ5ICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBkaXJlY3QudmVydGljZXNOZWVkVXBkYXRlID0gZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlO1xyXG4gICAgICAgICAgICBkaXJlY3Qubm9ybWFsc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZTtcclxuICAgICAgICAgICAgZGlyZWN0LmNvbG9yc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlO1xyXG4gICAgICAgICAgICBkaXJlY3QudXZzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LnV2c05lZWRVcGRhdGU7XHJcbiAgICAgICAgICAgIGRpcmVjdC5ncm91cHNOZWVkVXBkYXRlID0gZ2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZTtcclxuXHJcbiAgICAgICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5LnV2c05lZWRVcGRhdGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgZ2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgZ2VvbWV0cnkgPSBkaXJlY3Q7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPT09IHRydWUgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5LnZlcnRpY2VzICk7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5Lm5vcm1hbHMgKTtcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMuY29sb3I7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5jb3B5Q29sb3JzQXJyYXkoIGdlb21ldHJ5LmNvbG9ycyApO1xyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIGdlb21ldHJ5LnV2c05lZWRVcGRhdGUgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLnV2O1xyXG5cclxuICAgICAgICAgICAgaWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUuY29weVZlY3RvcjJzQXJyYXkoIGdlb21ldHJ5LnV2cyApO1xyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGdlb21ldHJ5LnV2c05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlcy5saW5lRGlzdGFuY2U7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5jb3B5QXJyYXkoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMgKTtcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBnZW9tZXRyeS5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggZ2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZSApIHtcclxuXHJcbiAgICAgICAgICAgIGdlb21ldHJ5LmNvbXB1dGVHcm91cHMoIG9iamVjdC5nZW9tZXRyeSApO1xyXG4gICAgICAgICAgICB0aGlzLmdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcclxuXHJcbiAgICAgICAgICAgIGdlb21ldHJ5Lmdyb3Vwc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGZyb21HZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcclxuXHJcbiAgICAgICAgZ2VvbWV0cnkuX19kaXJlY3RHZW9tZXRyeSA9IG5ldyBUSFJFRS5EaXJlY3RHZW9tZXRyeSgpLmZyb21HZW9tZXRyeSggZ2VvbWV0cnkgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbURpcmVjdEdlb21ldHJ5KCBnZW9tZXRyeS5fX2RpcmVjdEdlb21ldHJ5ICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBmcm9tRGlyZWN0R2VvbWV0cnk6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XHJcblxyXG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggKiAzICk7XHJcbiAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcyApICk7XHJcblxyXG4gICAgICAgIGlmICggZ2VvbWV0cnkubm9ybWFscy5sZW5ndGggPiAwICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIG5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS5ub3JtYWxzLmxlbmd0aCAqIDMgKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5Lm5vcm1hbHMgKSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggZ2VvbWV0cnkuY29sb3JzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkuY29sb3JzLmxlbmd0aCAqIDMgKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApLmNvcHlDb2xvcnNBcnJheSggZ2VvbWV0cnkuY29sb3JzICkgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIGdlb21ldHJ5LnV2cy5sZW5ndGggPiAwICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5LnV2cy5sZW5ndGggKiAyICk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKS5jb3B5VmVjdG9yMnNBcnJheSggZ2VvbWV0cnkudXZzICkgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIGdlb21ldHJ5LnV2czIubGVuZ3RoID4gMCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciB1dnMyID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkudXZzMi5sZW5ndGggKiAyICk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAndXYyJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdXZzMiwgMiApLmNvcHlWZWN0b3Iyc0FycmF5KCBnZW9tZXRyeS51dnMyICkgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIGdlb21ldHJ5LmluZGljZXMubGVuZ3RoID4gMCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBUeXBlQXJyYXkgPSBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggPiA2NTUzNSA/IFVpbnQzMkFycmF5IDogVWludDE2QXJyYXk7XHJcbiAgICAgICAgICAgIHZhciBpbmRpY2VzID0gbmV3IFR5cGVBcnJheSggZ2VvbWV0cnkuaW5kaWNlcy5sZW5ndGggKiAzICk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0SW5kZXgoIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGluZGljZXMsIDEgKS5jb3B5SW5kaWNlc0FycmF5KCBnZW9tZXRyeS5pbmRpY2VzICkgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBncm91cHNcclxuXHJcbiAgICAgICAgdGhpcy5ncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XHJcblxyXG4gICAgICAgIC8vIG1vcnBoc1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgbmFtZSBpbiBnZW9tZXRyeS5tb3JwaFRhcmdldHMgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBbXTtcclxuICAgICAgICAgICAgdmFyIG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgbmFtZSBdO1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gbW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG1vcnBoVGFyZ2V0ID0gbW9ycGhUYXJnZXRzWyBpIF07XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IG5ldyBUSFJFRS5GbG9hdDMyQXR0cmlidXRlKCBtb3JwaFRhcmdldC5sZW5ndGggKiAzLCAzICk7XHJcblxyXG4gICAgICAgICAgICAgICAgYXJyYXkucHVzaCggYXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCBtb3JwaFRhcmdldCApICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLm1vcnBoQXR0cmlidXRlc1sgbmFtZSBdID0gYXJyYXk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gc2tpbm5pbmdcclxuXHJcbiAgICAgICAgaWYgKCBnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggPiAwICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHNraW5JbmRpY2VzID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCAqIDQsIDQgKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdza2luSW5kZXgnLCBza2luSW5kaWNlcy5jb3B5VmVjdG9yNHNBcnJheSggZ2VvbWV0cnkuc2tpbkluZGljZXMgKSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoID4gMCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBza2luV2VpZ2h0cyA9IG5ldyBUSFJFRS5GbG9hdDMyQXR0cmlidXRlKCBnZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggKiA0LCA0ICk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAnc2tpbldlaWdodCcsIHNraW5XZWlnaHRzLmNvcHlWZWN0b3I0c0FycmF5KCBnZW9tZXRyeS5za2luV2VpZ2h0cyApICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9cclxuXHJcbiAgICAgICAgaWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94ID0gZ2VvbWV0cnkuYm91bmRpbmdCb3guY2xvbmUoKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvbXB1dGVCb3VuZGluZ0JveDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggdGhpcy5ib3VuZGluZ0JveCA9PT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94ID0gbmV3IFRIUkVFLkJveDMoKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbnMgPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHBvc2l0aW9ucyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgYmIgPSB0aGlzLmJvdW5kaW5nQm94O1xyXG4gICAgICAgICAgICAgICAgYmIubWFrZUVtcHR5KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArPSAzICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2ZWN0b3IuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKTtcclxuICAgICAgICAgICAgICAgICAgICBiYi5leHBhbmRCeVBvaW50KCB2ZWN0b3IgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIHBvc2l0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9ucy5sZW5ndGggPT09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5taW4uc2V0KCAwLCAwLCAwICk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94Lm1heC5zZXQoIDAsIDAsIDAgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggaXNOYU4oIHRoaXMuYm91bmRpbmdCb3gubWluLnggKSB8fCBpc05hTiggdGhpcy5ib3VuZGluZ0JveC5taW4ueSApIHx8IGlzTmFOKCB0aGlzLmJvdW5kaW5nQm94Lm1pbi56ICkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveDogQ29tcHV0ZWQgbWluL21heCBoYXZlIE5hTiB2YWx1ZXMuIFRoZSBcInBvc2l0aW9uXCIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJywgdGhpcyApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBjb21wdXRlQm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIGJveCA9IG5ldyBUSFJFRS5Cb3gzKCk7XHJcbiAgICAgICAgdmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbnMgPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHBvc2l0aW9ucyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBib3gubWFrZUVtcHR5KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMuYm91bmRpbmdTcGhlcmUuY2VudGVyO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKz0gMyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmVjdG9yLmZyb21BcnJheSggcG9zaXRpb25zLCBpICk7XHJcbiAgICAgICAgICAgICAgICAgICAgYm94LmV4cGFuZEJ5UG9pbnQoIHZlY3RvciApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBib3guY2VudGVyKCBjZW50ZXIgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBob3BpbmcgdG8gZmluZCBhIGJvdW5kaW5nU3BoZXJlIHdpdGggYSByYWRpdXMgc21hbGxlciB0aGFuIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gYm91bmRpbmdTcGhlcmUgb2YgdGhlIGJvdW5kaW5nQm94OiBzcXJ0KDMpIHNtYWxsZXIgaW4gdGhlIGJlc3QgY2FzZVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBtYXhSYWRpdXNTcSA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArPSAzICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2ZWN0b3IuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKTtcclxuICAgICAgICAgICAgICAgICAgICBtYXhSYWRpdXNTcSA9IE1hdGgubWF4KCBtYXhSYWRpdXNTcSwgY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCB2ZWN0b3IgKSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cyA9IE1hdGguc3FydCggbWF4UmFkaXVzU3EgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGlzTmFOKCB0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cyApICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk6IENvbXB1dGVkIHJhZGl1cyBpcyBOYU4uIFRoZSBcInBvc2l0aW9uXCIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJywgdGhpcyApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgY29tcHV0ZUZhY2VOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb21wdXRlVmVydGV4Tm9ybWFsczogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4O1xyXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xyXG4gICAgICAgIHZhciBncm91cHMgPSB0aGlzLmdyb3VwcztcclxuXHJcbiAgICAgICAgaWYgKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGF0dHJpYnV0ZXMubm9ybWFsID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCBwb3NpdGlvbnMubGVuZ3RoICksIDMgKSApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyByZXNldCBleGlzdGluZyBub3JtYWxzIHRvIHplcm9cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFscyA9IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBub3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBpIF0gPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBub3JtYWxzID0gYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdkEsIHZCLCB2QyxcclxuXHJcbiAgICAgICAgICAgICAgICBwQSA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcbiAgICAgICAgICAgICAgICBwQiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcbiAgICAgICAgICAgICAgICBwQyA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblxyXG4gICAgICAgICAgICAgICAgY2IgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG4gICAgICAgICAgICAgICAgYWIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICAgICAgLy8gaW5kZXhlZCBlbGVtZW50c1xyXG5cclxuICAgICAgICAgICAgaWYgKCBpbmRleCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kaWNlcyA9IGluZGV4LmFycmF5O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggZ3JvdXBzLmxlbmd0aCA9PT0gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRHcm91cCggMCwgaW5kaWNlcy5sZW5ndGggKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IGdyb3Vwcy5sZW5ndGg7IGogPCBqbDsgKysgaiApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gZ3JvdXBzWyBqIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGdyb3VwLnN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IGdyb3VwLmNvdW50O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IHN0YXJ0LCBpbCA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbDsgaSArPSAzICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdkEgPSBpbmRpY2VzWyBpICsgMCBdICogMztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdkIgPSBpbmRpY2VzWyBpICsgMSBdICogMztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdkMgPSBpbmRpY2VzWyBpICsgMiBdICogMztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBBLmZyb21BcnJheSggcG9zaXRpb25zLCB2QSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwQi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgdkIgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcEMuZnJvbUFycmF5KCBwb3NpdGlvbnMsIHZDICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYi5zdWJWZWN0b3JzKCBwQywgcEIgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWIuc3ViVmVjdG9ycyggcEEsIHBCICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiLmNyb3NzKCBhYiApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgdkEgXSArPSBjYi54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyB2QSArIDEgXSArPSBjYi55O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyB2QSArIDIgXSArPSBjYi56O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgdkIgXSArPSBjYi54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyB2QiArIDEgXSArPSBjYi55O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyB2QiArIDIgXSArPSBjYi56O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgdkMgXSArPSBjYi54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyB2QyArIDEgXSArPSBjYi55O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyB2QyArIDIgXSArPSBjYi56O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBub24taW5kZXhlZCBlbGVtZW50cyAodW5jb25uZWN0ZWQgdHJpYW5nbGUgc291cClcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHBBLmZyb21BcnJheSggcG9zaXRpb25zLCBpICk7XHJcbiAgICAgICAgICAgICAgICAgICAgcEIuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKyAzICk7XHJcbiAgICAgICAgICAgICAgICAgICAgcEMuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKyA2ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNiLnN1YlZlY3RvcnMoIHBDLCBwQiApO1xyXG4gICAgICAgICAgICAgICAgICAgIGFiLnN1YlZlY3RvcnMoIHBBLCBwQiApO1xyXG4gICAgICAgICAgICAgICAgICAgIGNiLmNyb3NzKCBhYiApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBpIF0gPSBjYi54O1xyXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIGkgKyAxIF0gPSBjYi55O1xyXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIGkgKyAyIF0gPSBjYi56O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBpICsgMyBdID0gY2IueDtcclxuICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBpICsgNCBdID0gY2IueTtcclxuICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBpICsgNSBdID0gY2IuejtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgaSArIDYgXSA9IGNiLng7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgaSArIDcgXSA9IGNiLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgaSArIDggXSA9IGNiLno7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5ub3JtYWxpemVOb3JtYWxzKCk7XHJcblxyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLm5vcm1hbC5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvbXB1dGVUYW5nZW50czogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmNvbXB1dGVUYW5nZW50cygpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29tcHV0ZU9mZnNldHM6IGZ1bmN0aW9uICggc2l6ZSApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5jb21wdXRlT2Zmc2V0cygpIGhhcyBiZWVuIHJlbW92ZWQuJylcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG1lcmdlOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBvZmZzZXQgKSB7XHJcblxyXG4gICAgICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSA9PT0gZmFsc2UgKSB7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkubWVyZ2UoKTogZ2VvbWV0cnkgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LicsIGdlb21ldHJ5ICk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBrZXkgaW4gYXR0cmlidXRlcyApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggZ2VvbWV0cnkuYXR0cmlidXRlc1sga2V5IF0gPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZTEgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcclxuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZUFycmF5MSA9IGF0dHJpYnV0ZTEuYXJyYXk7XHJcblxyXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlMiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbIGtleSBdO1xyXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlQXJyYXkyID0gYXR0cmlidXRlMi5hcnJheTtcclxuXHJcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVTaXplID0gYXR0cmlidXRlMi5pdGVtU2l6ZTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaiA9IGF0dHJpYnV0ZVNpemUgKiBvZmZzZXQ7IGkgPCBhdHRyaWJ1dGVBcnJheTIubGVuZ3RoOyBpICsrLCBqICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUFycmF5MVsgaiBdID0gYXR0cmlidXRlQXJyYXkyWyBpIF07XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBub3JtYWxpemVOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBub3JtYWxzID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcclxuXHJcbiAgICAgICAgdmFyIHgsIHksIHosIG47XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBub3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XHJcblxyXG4gICAgICAgICAgICB4ID0gbm9ybWFsc1sgaSBdO1xyXG4gICAgICAgICAgICB5ID0gbm9ybWFsc1sgaSArIDEgXTtcclxuICAgICAgICAgICAgeiA9IG5vcm1hbHNbIGkgKyAyIF07XHJcblxyXG4gICAgICAgICAgICBuID0gMS4wIC8gTWF0aC5zcXJ0KCB4ICogeCArIHkgKiB5ICsgeiAqIHogKTtcclxuXHJcbiAgICAgICAgICAgIG5vcm1hbHNbIGkgXSAqPSBuO1xyXG4gICAgICAgICAgICBub3JtYWxzWyBpICsgMSBdICo9IG47XHJcbiAgICAgICAgICAgIG5vcm1hbHNbIGkgKyAyIF0gKj0gbjtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBkYXRhID0ge1xyXG4gICAgICAgICAgICBtZXRhZGF0YToge1xyXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogNC40LFxyXG4gICAgICAgICAgICAgICAgdHlwZTogJ0J1ZmZlckdlb21ldHJ5JyxcclxuICAgICAgICAgICAgICAgIGdlbmVyYXRvcjogJ0J1ZmZlckdlb21ldHJ5LnRvSlNPTidcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIHN0YW5kYXJkIEJ1ZmZlckdlb21ldHJ5IHNlcmlhbGl6YXRpb25cclxuXHJcbiAgICAgICAgZGF0YS51dWlkID0gdGhpcy51dWlkO1xyXG4gICAgICAgIGRhdGEudHlwZSA9IHRoaXMudHlwZTtcclxuICAgICAgICBpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBkYXRhLm5hbWUgPSB0aGlzLm5hbWU7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5wYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBrZXkgaW4gcGFyYW1ldGVycyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHBhcmFtZXRlcnNbIGtleSBdICE9PSB1bmRlZmluZWQgKSBkYXRhWyBrZXkgXSA9IHBhcmFtZXRlcnNbIGtleSBdO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZGF0YS5kYXRhID0geyBhdHRyaWJ1dGVzOiB7fSB9O1xyXG5cclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4O1xyXG5cclxuICAgICAgICBpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGluZGV4LmFycmF5ICk7XHJcblxyXG4gICAgICAgICAgICBkYXRhLmRhdGEuaW5kZXggPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBpbmRleC5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLFxyXG4gICAgICAgICAgICAgICAgYXJyYXk6IGFycmF5XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBrZXkgaW4gYXR0cmlidXRlcyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcclxuXHJcbiAgICAgICAgICAgIHZhciBhcnJheSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhdHRyaWJ1dGUuYXJyYXkgKTtcclxuXHJcbiAgICAgICAgICAgIGRhdGEuZGF0YS5hdHRyaWJ1dGVzWyBrZXkgXSA9IHtcclxuICAgICAgICAgICAgICAgIGl0ZW1TaXplOiBhdHRyaWJ1dGUuaXRlbVNpemUsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBhdHRyaWJ1dGUuYXJyYXkuY29uc3RydWN0b3IubmFtZSxcclxuICAgICAgICAgICAgICAgIGFycmF5OiBhcnJheVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBncm91cHMgPSB0aGlzLmdyb3VwcztcclxuXHJcbiAgICAgICAgaWYgKCBncm91cHMubGVuZ3RoID4gMCApIHtcclxuXHJcbiAgICAgICAgICAgIGRhdGEuZGF0YS5ncm91cHMgPSBKU09OLnBhcnNlKCBKU09OLnN0cmluZ2lmeSggZ3JvdXBzICkgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYm91bmRpbmdTcGhlcmUgPSB0aGlzLmJvdW5kaW5nU3BoZXJlO1xyXG5cclxuICAgICAgICBpZiAoIGJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgZGF0YS5kYXRhLmJvdW5kaW5nU3BoZXJlID0ge1xyXG4gICAgICAgICAgICAgICAgY2VudGVyOiBib3VuZGluZ1NwaGVyZS5jZW50ZXIudG9BcnJheSgpLFxyXG4gICAgICAgICAgICAgICAgcmFkaXVzOiBib3VuZGluZ1NwaGVyZS5yYWRpdXNcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuICAgICAgICB2YXIgaW5kZXggPSBzb3VyY2UuaW5kZXg7XHJcblxyXG4gICAgICAgIGlmICggaW5kZXggIT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNldEluZGV4KCBpbmRleC5jbG9uZSgpICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBzb3VyY2UuYXR0cmlidXRlcztcclxuXHJcbiAgICAgICAgZm9yICggdmFyIG5hbWUgaW4gYXR0cmlidXRlcyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBuYW1lIF07XHJcbiAgICAgICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCBuYW1lLCBhdHRyaWJ1dGUuY2xvbmUoKSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBncm91cHMgPSBzb3VyY2UuZ3JvdXBzO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBncm91cHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xyXG4gICAgICAgICAgICB0aGlzLmFkZEdyb3VwKCBncm91cC5zdGFydCwgZ3JvdXAuY291bnQgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuQnVmZmVyR2VvbWV0cnkuTWF4SW5kZXggPSA2NTUzNTtcclxuXHJcbi8vIEZpbGU6c3JjL2NvcmUvSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcclxuICovXHJcblxyXG5USFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICBUSFJFRS5CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5JztcclxuICAgIHRoaXMubWF4SW5zdGFuY2VkQ291bnQgPSB1bmRlZmluZWQ7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5O1xyXG5cclxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmFkZEdyb3VwID0gZnVuY3Rpb24gKCBzdGFydCwgY291bnQsIGluc3RhbmNlcyApIHtcclxuXHJcbiAgICB0aGlzLmdyb3Vwcy5wdXNoKCB7XHJcblxyXG4gICAgICAgIHN0YXJ0OiBzdGFydCxcclxuICAgICAgICBjb3VudDogY291bnQsXHJcbiAgICAgICAgaW5zdGFuY2VzOiBpbnN0YW5jZXNcclxuXHJcbiAgICB9ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcbiAgICB2YXIgaW5kZXggPSBzb3VyY2UuaW5kZXg7XHJcblxyXG4gICAgaWYgKCBpbmRleCAhPT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgdGhpcy5zZXRJbmRleCggaW5kZXguY2xvbmUoKSApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB2YXIgYXR0cmlidXRlcyA9IHNvdXJjZS5hdHRyaWJ1dGVzO1xyXG5cclxuICAgIGZvciAoIHZhciBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XHJcblxyXG4gICAgICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBuYW1lIF07XHJcbiAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoIG5hbWUsIGF0dHJpYnV0ZS5jbG9uZSgpICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHZhciBncm91cHMgPSBzb3VyY2UuZ3JvdXBzO1xyXG5cclxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNbIGkgXTtcclxuICAgICAgICB0aGlzLmFkZEdyb3VwKCBncm91cC5zdGFydCwgZ3JvdXAuY291bnQsIGdyb3VwLmluc3RhbmNlcyApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuXHJcbi8vIEZpbGU6c3JjL2FuaW1hdGlvbi9BbmltYXRpb25BY3Rpb24uanNcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBBIGNsaXAgdGhhdCBoYXMgYmVlbiBleHBsaWNpdGx5IHNjaGVkdWxlZC5cclxuICpcclxuICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cclxuICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXHJcbiAqL1xyXG5cclxuVEhSRUUuQW5pbWF0aW9uQWN0aW9uID0gZnVuY3Rpb24gKCBjbGlwLCBzdGFydFRpbWUsIHRpbWVTY2FsZSwgd2VpZ2h0LCBsb29wICkge1xyXG5cclxuICAgIGlmICggY2xpcCA9PT0gdW5kZWZpbmVkICkgdGhyb3cgbmV3IEVycm9yKCAnY2xpcCBpcyBudWxsJyApO1xyXG4gICAgdGhpcy5jbGlwID0gY2xpcDtcclxuICAgIHRoaXMubG9jYWxSb290ID0gbnVsbDtcclxuICAgIHRoaXMuc3RhcnRUaW1lID0gc3RhcnRUaW1lIHx8IDA7XHJcbiAgICB0aGlzLnRpbWVTY2FsZSA9IHRpbWVTY2FsZSB8fCAxO1xyXG4gICAgdGhpcy53ZWlnaHQgPSB3ZWlnaHQgfHwgMTtcclxuICAgIHRoaXMubG9vcCA9IGxvb3AgfHwgVEhSRUUuTG9vcFJlcGVhdDtcclxuICAgIHRoaXMubG9vcENvdW50ID0gMDtcclxuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XHQvLyBhbGxvdyBmb3IgZWFzeSBkaXNhYmxpbmcgb2YgdGhlIGFjdGlvbi5cclxuXHJcbiAgICB0aGlzLmFjdGlvblRpbWUgPSAtIHRoaXMuc3RhcnRUaW1lO1xyXG4gICAgdGhpcy5jbGlwVGltZSA9IDA7XHJcblxyXG4gICAgdGhpcy5wcm9wZXJ0eUJpbmRpbmdzID0gW107XHJcbn07XHJcblxyXG4vKlxyXG4gVEhSRUUuTG9vcE9uY2UgPSAyMjAwO1xyXG4gVEhSRUUuTG9vcFJlcGVhdCA9IDIyMDE7XHJcbiBUSFJFRS5Mb29wUGluZ1BpbmcgPSAyMjAyO1xyXG4gKi9cclxuXHJcblRIUkVFLkFuaW1hdGlvbkFjdGlvbi5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkFuaW1hdGlvbkFjdGlvbixcclxuXHJcbiAgICBzZXRMb2NhbFJvb3Q6IGZ1bmN0aW9uKCBsb2NhbFJvb3QgKSB7XHJcblxyXG4gICAgICAgIHRoaXMubG9jYWxSb290ID0gbG9jYWxSb290O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZVRpbWU6IGZ1bmN0aW9uKCBjbGlwRGVsdGFUaW1lICkge1xyXG5cclxuICAgICAgICB2YXIgcHJldmlvdXNDbGlwVGltZSA9IHRoaXMuY2xpcFRpbWU7XHJcbiAgICAgICAgdmFyIHByZXZpb3VzTG9vcENvdW50ID0gdGhpcy5sb29wQ291bnQ7XHJcbiAgICAgICAgdmFyIHByZXZpb3VzQWN0aW9uVGltZSA9IHRoaXMuYWN0aW9uVGltZTtcclxuXHJcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy5jbGlwLmR1cmF0aW9uO1xyXG5cclxuICAgICAgICB0aGlzLmFjdGlvblRpbWUgPSB0aGlzLmFjdGlvblRpbWUgKyBjbGlwRGVsdGFUaW1lO1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMubG9vcCA9PT0gVEhSRUUuTG9vcE9uY2UgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmxvb3BDb3VudCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuY2xpcFRpbWUgPSBNYXRoLm1pbiggTWF0aC5tYXgoIHRoaXMuYWN0aW9uVGltZSwgMCApLCBkdXJhdGlvbiApO1xyXG5cclxuICAgICAgICAgICAgLy8gaWYgdGltZSBpcyBjaGFuZ2VkIHNpbmNlIGxhc3QgdGltZSwgc2VlIGlmIHdlIGhhdmUgaGl0IGEgc3RhcnQvZW5kIGxpbWl0XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5jbGlwVGltZSAhPT0gcHJldmlvdXNDbGlwVGltZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMuY2xpcFRpbWUgPT09IGR1cmF0aW9uICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1peGVyLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2ZpbmlzaGVkJywgYWN0aW9uOiB0aGlzLCBkaXJlY3Rpb246IDEgfSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHRoaXMuY2xpcFRpbWUgPT09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWl4ZXIuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZmluaXNoZWQnLCBhY3Rpb246IHRoaXMsIGRpcmVjdGlvbjogLTEgfSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGlwVGltZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmxvb3BDb3VudCA9IE1hdGguZmxvb3IoIHRoaXMuYWN0aW9uVGltZSAvIGR1cmF0aW9uICk7XHJcblxyXG4gICAgICAgIHZhciBuZXdDbGlwVGltZSA9IHRoaXMuYWN0aW9uVGltZSAtIHRoaXMubG9vcENvdW50ICogZHVyYXRpb247XHJcbiAgICAgICAgbmV3Q2xpcFRpbWUgPSBuZXdDbGlwVGltZSAlIGR1cmF0aW9uO1xyXG5cclxuICAgICAgICAvLyBpZiB3ZSBhcmUgcGluZyBwb25nIGxvb3BpbmcsIGVuc3VyZSB0aGF0IHdlIGdvIGJhY2t3YXJkcyB3aGVuIGFwcHJvcHJpYXRlXHJcbiAgICAgICAgaWYgKCB0aGlzLmxvb3AgPT0gVEhSRUUuTG9vcFBpbmdQb25nICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBNYXRoLmFicyggdGhpcy5sb29wQ291bnQgJSAyICkgPT09IDEgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgbmV3Q2xpcFRpbWUgPSBkdXJhdGlvbiAtIG5ld0NsaXBUaW1lO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY2xpcFRpbWUgPSBuZXdDbGlwVGltZTtcclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLmxvb3BDb3VudCAhPT0gcHJldmlvdXNMb29wQ291bnQgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLm1peGVyLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2xvb3AnLCBhY3Rpb246IHRoaXMsIGxvb3BEZWx0YTogKCB0aGlzLmxvb3BDb3VudCAtIHRoaXMubG9vcENvdW50ICkgfSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmNsaXBUaW1lO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc3luY1dpdGg6IGZ1bmN0aW9uKCBhY3Rpb24gKSB7XHJcblxyXG4gICAgICAgIHRoaXMuYWN0aW9uVGltZSA9IGFjdGlvbi5hY3Rpb25UaW1lO1xyXG4gICAgICAgIHRoaXMudGltZVNjYWxlID0gYWN0aW9uLnRpbWVTY2FsZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHdhcnBUb0R1cmF0aW9uOiBmdW5jdGlvbiggZHVyYXRpb24gKSB7XHJcblxyXG4gICAgICAgIHRoaXMudGltZVNjYWxlID0gdGhpcy5jbGlwLmR1cmF0aW9uIC8gZHVyYXRpb247XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBpbml0OiBmdW5jdGlvbiggdGltZSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5jbGlwVGltZSA9IHRpbWUgLSB0aGlzLnN0YXJ0VGltZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCBjbGlwRGVsdGFUaW1lICkge1xyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZVRpbWUoIGNsaXBEZWx0YVRpbWUgKTtcclxuXHJcbiAgICAgICAgdmFyIGNsaXBSZXN1bHRzID0gdGhpcy5jbGlwLmdldEF0KCB0aGlzLmNsaXBUaW1lICk7XHJcblxyXG4gICAgICAgIHJldHVybiBjbGlwUmVzdWx0cztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldFRpbWVTY2FsZUF0OiBmdW5jdGlvbiggdGltZSApIHtcclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLnRpbWVTY2FsZS5nZXRBdCApIHtcclxuICAgICAgICAgICAgLy8gcGFzcyBpbiB0aW1lLCBub3QgY2xpcCB0aW1lLCBhbGxvd3MgZm9yIGZhZGVpbi9mYWRlb3V0IGFjcm9zcyBtdWx0aXBsZSBsb29wcyBvZiB0aGUgY2xpcFxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50aW1lU2NhbGUuZ2V0QXQoIHRpbWUgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy50aW1lU2NhbGU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRXZWlnaHRBdDogZnVuY3Rpb24oIHRpbWUgKSB7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy53ZWlnaHQuZ2V0QXQgKSB7XHJcbiAgICAgICAgICAgIC8vIHBhc3MgaW4gdGltZSwgbm90IGNsaXAgdGltZSwgYWxsb3dzIGZvciBmYWRlaW4vZmFkZW91dCBhY3Jvc3MgbXVsdGlwbGUgbG9vcHMgb2YgdGhlIGNsaXBcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2VpZ2h0LmdldEF0KCB0aW1lICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMud2VpZ2h0O1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9hbmltYXRpb24vQW5pbWF0aW9uQ2xpcC5qc1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIFJldXNhYmxlIHNldCBvZiBUcmFja3MgdGhhdCByZXByZXNlbnQgYW4gYW5pbWF0aW9uLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xyXG4gKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cclxuICovXHJcblxyXG5USFJFRS5BbmltYXRpb25DbGlwID0gZnVuY3Rpb24gKCBuYW1lLCBkdXJhdGlvbiwgdHJhY2tzICkge1xyXG5cclxuICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICB0aGlzLnRyYWNrcyA9IHRyYWNrcztcclxuICAgIHRoaXMuZHVyYXRpb24gPSAoIGR1cmF0aW9uICE9PSB1bmRlZmluZWQgKSA/IGR1cmF0aW9uIDogLTE7XHJcblxyXG4gICAgLy8gdGhpcyBtZWFucyBpdCBzaG91bGQgZmlndXJlIG91dCBpdHMgZHVyYXRpb24gYnkgc2Nhbm5pbmcgdGhlIHRyYWNrc1xyXG4gICAgaWYgKCB0aGlzLmR1cmF0aW9uIDwgMCApIHtcclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLnRyYWNrcy5sZW5ndGg7IGkgKysgKSB7XHJcbiAgICAgICAgICAgIHZhciB0cmFjayA9IHRoaXMudHJhY2tzW2ldO1xyXG4gICAgICAgICAgICB0aGlzLmR1cmF0aW9uID0gTWF0aC5tYXgoIHRyYWNrLmtleXNbIHRyYWNrLmtleXMubGVuZ3RoIC0gMSBdLnRpbWUgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbWF5YmUgb25seSBkbyB0aGVzZSBvbiBkZW1hbmQsIGFzIGRvaW5nIHRoZW0gaGVyZSBjb3VsZCBwb3RlbnRpYWxseSBzbG93IGRvd24gbG9hZGluZ1xyXG4gICAgLy8gYnV0IGxlYXZpbmcgdGhlc2UgaGVyZSBkdXJpbmcgZGV2ZWxvcG1lbnQgYXMgdGhpcyBlbnN1cmVzIGEgbG90IG9mIHRlc3Rpbmcgb2YgdGhlc2UgZnVuY3Rpb25zXHJcbiAgICB0aGlzLnRyaW0oKTtcclxuICAgIHRoaXMub3B0aW1pemUoKTtcclxuXHJcbiAgICB0aGlzLnJlc3VsdHMgPSBbXTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BbmltYXRpb25DbGlwLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuQW5pbWF0aW9uQ2xpcCxcclxuXHJcbiAgICBnZXRBdDogZnVuY3Rpb24oIGNsaXBUaW1lICkge1xyXG5cclxuICAgICAgICBjbGlwVGltZSA9IE1hdGgubWF4KCAwLCBNYXRoLm1pbiggY2xpcFRpbWUsIHRoaXMuZHVyYXRpb24gKSApO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLnRyYWNrcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgdHJhY2sgPSB0aGlzLnRyYWNrc1sgaSBdO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5yZXN1bHRzWyBpIF0gPSB0cmFjay5nZXRBdCggY2xpcFRpbWUgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzO1xyXG4gICAgfSxcclxuXHJcbiAgICB0cmltOiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy50cmFja3MubGVuZ3RoOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy50cmFja3NbIGkgXS50cmltKCAwLCB0aGlzLmR1cmF0aW9uICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBvcHRpbWl6ZTogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudHJhY2tzWyBpIF0ub3B0aW1pemUoKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLkFuaW1hdGlvbkNsaXAuQ3JlYXRlRnJvbU1vcnBoVGFyZ2V0U2VxdWVuY2UgPSBmdW5jdGlvbiggbmFtZSwgbW9ycGhUYXJnZXRTZXF1ZW5jZSwgZnBzICkge1xyXG5cclxuXHJcbiAgICB2YXIgbnVtTW9ycGhUYXJnZXRzID0gbW9ycGhUYXJnZXRTZXF1ZW5jZS5sZW5ndGg7XHJcbiAgICB2YXIgdHJhY2tzID0gW107XHJcblxyXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbnVtTW9ycGhUYXJnZXRzOyBpICsrICkge1xyXG5cclxuICAgICAgICB2YXIga2V5cyA9IFtdO1xyXG5cclxuICAgICAgICBrZXlzLnB1c2goIHsgdGltZTogKCBpICsgbnVtTW9ycGhUYXJnZXRzIC0gMSApICUgbnVtTW9ycGhUYXJnZXRzLCB2YWx1ZTogMCB9ICk7XHJcbiAgICAgICAga2V5cy5wdXNoKCB7IHRpbWU6IGksIHZhbHVlOiAxIH0gKTtcclxuICAgICAgICBrZXlzLnB1c2goIHsgdGltZTogKCBpICsgMSApICUgbnVtTW9ycGhUYXJnZXRzLCB2YWx1ZTogMCB9ICk7XHJcblxyXG4gICAgICAgIGtleXMuc29ydCggVEhSRUUuS2V5ZnJhbWVUcmFjay5rZXlDb21wYXJlciApO1xyXG5cclxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIGtleSBhdCB0aGUgZmlyc3QgZnJhbWUsIGR1cGxpY2F0ZSBpdCBhcyB0aGUgbGFzdCBmcmFtZSBhcyB3ZWxsIGZvciBwZXJmZWN0IGxvb3AuXHJcbiAgICAgICAgaWYgKCBrZXlzWzBdLnRpbWUgPT09IDAgKSB7XHJcbiAgICAgICAgICAgIGtleXMucHVzaCgge1xyXG4gICAgICAgICAgICAgICAgdGltZTogbnVtTW9ycGhUYXJnZXRzLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGtleXNbMF0udmFsdWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0cmFja3MucHVzaCggbmV3IFRIUkVFLk51bWJlcktleWZyYW1lVHJhY2soICcubW9ycGhUYXJnZXRJbmZsdWVuY2VzWycgKyBtb3JwaFRhcmdldFNlcXVlbmNlW2ldLm5hbWUgKyAnXScsIGtleXMgKS5zY2FsZSggMS4wIC8gZnBzICkgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLkFuaW1hdGlvbkNsaXAoIG5hbWUsIC0xLCB0cmFja3MgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BbmltYXRpb25DbGlwLmZpbmRCeU5hbWUgPSBmdW5jdGlvbiggY2xpcEFycmF5LCBuYW1lICkge1xyXG5cclxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGNsaXBBcnJheS5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIGlmICggY2xpcEFycmF5W2ldLm5hbWUgPT09IG5hbWUgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY2xpcEFycmF5W2ldO1xyXG5cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQW5pbWF0aW9uQ2xpcC5DcmVhdGVDbGlwc0Zyb21Nb3JwaFRhcmdldFNlcXVlbmNlcyA9IGZ1bmN0aW9uKCBtb3JwaFRhcmdldHMsIGZwcyApIHtcclxuXHJcbiAgICB2YXIgYW5pbWF0aW9uVG9Nb3JwaFRhcmdldHMgPSB7fTtcclxuXHJcbiAgICAvLyB0ZXN0ZWQgd2l0aCBodHRwczovL3JlZ2V4MTAxLmNvbS8gb24gdHJpY2sgc2VxdWVuY2VzIHN1Y2ggZmxhbWluZ29fZmx5QV8wMDMsIGZsYW1pbmdvX3J1bjFfMDAzLCBjcmRlYXRoMDA1OVxyXG4gICAgdmFyIHBhdHRlcm4gPSAvXihbXFx3LV0qPykoW1xcZF0rKSQvO1xyXG5cclxuICAgIC8vIHNvcnQgbW9ycGggdGFyZ2V0IG5hbWVzIGludG8gYW5pbWF0aW9uIGdyb3VwcyBiYXNlZCBwYXR0ZXJucyBsaWtlIFdhbGtfMDAxLCBXYWxrXzAwMiwgUnVuXzAwMSwgUnVuXzAwMlxyXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgdmFyIG1vcnBoVGFyZ2V0ID0gbW9ycGhUYXJnZXRzWyBpIF07XHJcbiAgICAgICAgdmFyIHBhcnRzID0gbW9ycGhUYXJnZXQubmFtZS5tYXRjaCggcGF0dGVybiApO1xyXG5cclxuICAgICAgICBpZiAoIHBhcnRzICYmIHBhcnRzLmxlbmd0aCA+IDEgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbmFtZSA9IHBhcnRzWyAxIF07XHJcblxyXG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uTW9ycGhUYXJnZXRzID0gYW5pbWF0aW9uVG9Nb3JwaFRhcmdldHNbIG5hbWUgXTtcclxuICAgICAgICAgICAgaWYgKCAhIGFuaW1hdGlvbk1vcnBoVGFyZ2V0cyApIHtcclxuICAgICAgICAgICAgICAgIGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzWyBuYW1lIF0gPSBhbmltYXRpb25Nb3JwaFRhcmdldHMgPSBbXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYW5pbWF0aW9uTW9ycGhUYXJnZXRzLnB1c2goIG1vcnBoVGFyZ2V0ICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNsaXBzID0gW107XHJcblxyXG4gICAgZm9yICggdmFyIG5hbWUgaW4gYW5pbWF0aW9uVG9Nb3JwaFRhcmdldHMgKSB7XHJcblxyXG4gICAgICAgIGNsaXBzLnB1c2goIFRIUkVFLkFuaW1hdGlvbkNsaXAuQ3JlYXRlRnJvbU1vcnBoVGFyZ2V0U2VxdWVuY2UoIG5hbWUsIGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzWyBuYW1lIF0sIGZwcyApICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNsaXBzO1xyXG5cclxufTtcclxuXHJcbi8vIHBhcnNlIHRoZSBzdGFuZGFyZCBKU09OIGZvcm1hdCBmb3IgY2xpcHNcclxuVEhSRUUuQW5pbWF0aW9uQ2xpcC5wYXJzZSA9IGZ1bmN0aW9uKCBqc29uICkge1xyXG5cclxuICAgIHZhciB0cmFja3MgPSBbXTtcclxuXHJcbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBqc29uLnRyYWNrcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIHRyYWNrcy5wdXNoKCBUSFJFRS5LZXlmcmFtZVRyYWNrLnBhcnNlKCBqc29uLnRyYWNrc1tpXSApLnNjYWxlKCAxLjAgLyBqc29uLmZwcyApICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuQW5pbWF0aW9uQ2xpcCgganNvbi5uYW1lLCBqc29uLmR1cmF0aW9uLCB0cmFja3MgKTtcclxuXHJcbn07XHJcblxyXG5cclxuLy8gcGFyc2UgdGhlIGFuaW1hdGlvbi5oaWVyYXJjaHkgZm9ybWF0XHJcblRIUkVFLkFuaW1hdGlvbkNsaXAucGFyc2VBbmltYXRpb24gPSBmdW5jdGlvbiggYW5pbWF0aW9uLCBib25lcywgbm9kZU5hbWUgKSB7XHJcblxyXG4gICAgaWYgKCAhIGFuaW1hdGlvbiApIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCBcIiAgbm8gYW5pbWF0aW9uIGluIEpTT05Mb2FkZXIgZGF0YVwiICk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNvbnZlcnRUcmFjayA9IGZ1bmN0aW9uKCB0cmFja05hbWUsIGFuaW1hdGlvbktleXMsIHByb3BlcnR5TmFtZSwgdHJhY2tUeXBlLCBhbmltYXRpb25LZXlUb1ZhbHVlRnVuYyApIHtcclxuXHJcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGsgPSAwOyBrIDwgYW5pbWF0aW9uS2V5cy5sZW5ndGg7IGsgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uS2V5ID0gYW5pbWF0aW9uS2V5c1trXTtcclxuXHJcbiAgICAgICAgICAgIGlmICggYW5pbWF0aW9uS2V5W3Byb3BlcnR5TmFtZV0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goIHsgdGltZTogYW5pbWF0aW9uS2V5LnRpbWUsIHZhbHVlOiBhbmltYXRpb25LZXlUb1ZhbHVlRnVuYyggYW5pbWF0aW9uS2V5ICkgfSApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gb25seSByZXR1cm4gdHJhY2sgaWYgdGhlcmUgYXJlIGFjdHVhbGx5IGtleXMuXHJcbiAgICAgICAgaWYgKCBrZXlzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHRyYWNrVHlwZSggdHJhY2tOYW1lLCBrZXlzICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgdHJhY2tzID0gW107XHJcblxyXG4gICAgdmFyIGNsaXBOYW1lID0gYW5pbWF0aW9uLm5hbWUgfHwgJ2RlZmF1bHQnO1xyXG4gICAgdmFyIGR1cmF0aW9uID0gYW5pbWF0aW9uLmxlbmd0aCB8fCAtMTsgLy8gYXV0b21hdGljIGxlbmd0aCBkZXRlcm1pbmF0aW9uIGluIEFuaW1hdGlvbkNsaXAuXHJcbiAgICB2YXIgZnBzID0gYW5pbWF0aW9uLmZwcyB8fCAzMDtcclxuXHJcbiAgICB2YXIgaGllcmFyY2h5VHJhY2tzID0gYW5pbWF0aW9uLmhpZXJhcmNoeSB8fCBbXTtcclxuXHJcbiAgICBmb3IgKCB2YXIgaCA9IDA7IGggPCBoaWVyYXJjaHlUcmFja3MubGVuZ3RoOyBoICsrICkge1xyXG5cclxuICAgICAgICB2YXIgYW5pbWF0aW9uS2V5cyA9IGhpZXJhcmNoeVRyYWNrc1sgaCBdLmtleXM7XHJcblxyXG4gICAgICAgIC8vIHNraXAgZW1wdHkgdHJhY2tzXHJcbiAgICAgICAgaWYgKCAhIGFuaW1hdGlvbktleXMgfHwgYW5pbWF0aW9uS2V5cy5sZW5ndGggPT0gMCApIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBwcm9jZXNzIG1vcnBoIHRhcmdldHMgaW4gYSB3YXkgZXhhY3RseSBjb21wYXRpYmxlIHdpdGggQW5pbWF0aW9uSGFuZGxlci5pbml0KCBhbmltYXRpb24gKVxyXG4gICAgICAgIGlmICggYW5pbWF0aW9uS2V5c1swXS5tb3JwaFRhcmdldHMgKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBmaWd1cmUgb3V0IGFsbCBtb3JwaCB0YXJnZXRzIHVzZWQgaW4gdGhpcyB0cmFja1xyXG4gICAgICAgICAgICB2YXIgbW9ycGhUYXJnZXROYW1lcyA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKCB2YXIgayA9IDA7IGsgPCBhbmltYXRpb25LZXlzLmxlbmd0aDsgayArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGFuaW1hdGlvbktleXNba10ubW9ycGhUYXJnZXRzICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBtID0gMDsgbSA8IGFuaW1hdGlvbktleXNba10ubW9ycGhUYXJnZXRzLmxlbmd0aDsgbSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vcnBoVGFyZ2V0TmFtZXNbIGFuaW1hdGlvbktleXNba10ubW9ycGhUYXJnZXRzW21dIF0gPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBjcmVhdGUgYSB0cmFjayBmb3IgZWFjaCBtb3JwaCB0YXJnZXQgd2l0aCBhbGwgemVybyBtb3JwaFRhcmdldEluZmx1ZW5jZXMgZXhjZXB0IGZvciB0aGUga2V5cyBpbiB3aGljaCB0aGUgbW9ycGhUYXJnZXQgaXMgbmFtZWQuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBtb3JwaFRhcmdldE5hbWUgaW4gbW9ycGhUYXJnZXROYW1lcyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBtID0gMDsgbSA8IGFuaW1hdGlvbktleXNba10ubW9ycGhUYXJnZXRzLmxlbmd0aDsgbSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbktleSA9IGFuaW1hdGlvbktleXNba107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaCgge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lOiBhbmltYXRpb25LZXkudGltZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICgoIGFuaW1hdGlvbktleS5tb3JwaFRhcmdldCA9PT0gbW9ycGhUYXJnZXROYW1lICkgPyAxIDogMCApXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRyYWNrcy5wdXNoKCBuZXcgVEhSRUUuTnVtYmVyS2V5ZnJhbWVUcmFjayggbm9kZU5hbWUgKyAnLm1vcnBoVGFyZ2V0SW5mbHVlbmNlWycgKyBtb3JwaFRhcmdldE5hbWUgKyAnXScsIGtleXMgKSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZHVyYXRpb24gPSBtb3JwaFRhcmdldE5hbWVzLmxlbmd0aCAqICggZnBzIHx8IDEuMCApO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgdmFyIGJvbmVOYW1lID0gbm9kZU5hbWUgKyAnLmJvbmVzWycgKyBib25lc1sgaCBdLm5hbWUgKyAnXSc7XHJcblxyXG4gICAgICAgICAgICAvLyB0cmFjayBjb250YWlucyBwb3NpdGlvbnMuLi5cclxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uVHJhY2sgPSBjb252ZXJ0VHJhY2soIGJvbmVOYW1lICsgJy5wb3NpdGlvbicsIGFuaW1hdGlvbktleXMsICdwb3MnLCBUSFJFRS5WZWN0b3JLZXlmcmFtZVRyYWNrLCBmdW5jdGlvbiggYW5pbWF0aW9uS2V5ICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKCkuZnJvbUFycmF5KCBhbmltYXRpb25LZXkucG9zIClcclxuICAgICAgICAgICAgfSApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBwb3NpdGlvblRyYWNrICkgdHJhY2tzLnB1c2goIHBvc2l0aW9uVHJhY2sgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHRyYWNrIGNvbnRhaW5zIHF1YXRlcm5pb25zLi4uXHJcbiAgICAgICAgICAgIHZhciBxdWF0ZXJuaW9uVHJhY2sgPSBjb252ZXJ0VHJhY2soIGJvbmVOYW1lICsgJy5xdWF0ZXJuaW9uJywgYW5pbWF0aW9uS2V5cywgJ3JvdCcsIFRIUkVFLlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLCBmdW5jdGlvbiggYW5pbWF0aW9uS2V5ICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCBhbmltYXRpb25LZXkucm90LnNsZXJwICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhbmltYXRpb25LZXkucm90LmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVEhSRUUuUXVhdGVybmlvbigpLmZyb21BcnJheSggYW5pbWF0aW9uS2V5LnJvdCApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9ICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHF1YXRlcm5pb25UcmFjayApIHRyYWNrcy5wdXNoKCBxdWF0ZXJuaW9uVHJhY2sgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHRyYWNrIGNvbnRhaW5zIHF1YXRlcm5pb25zLi4uXHJcbiAgICAgICAgICAgIHZhciBzY2FsZVRyYWNrID0gY29udmVydFRyYWNrKCBib25lTmFtZSArICcuc2NhbGUnLCBhbmltYXRpb25LZXlzLCAnc2NsJywgVEhSRUUuVmVjdG9yS2V5ZnJhbWVUcmFjaywgZnVuY3Rpb24oIGFuaW1hdGlvbktleSApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMygpLmZyb21BcnJheSggYW5pbWF0aW9uS2V5LnNjbCApXHJcbiAgICAgICAgICAgIH0gKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggc2NhbGVUcmFjayApIHRyYWNrcy5wdXNoKCBzY2FsZVRyYWNrICk7XHJcblxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoIHRyYWNrcy5sZW5ndGggPT09IDAgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB2YXIgY2xpcCA9IG5ldyBUSFJFRS5BbmltYXRpb25DbGlwKCBjbGlwTmFtZSwgZHVyYXRpb24sIHRyYWNrcyApO1xyXG5cclxuICAgIHJldHVybiBjbGlwO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2FuaW1hdGlvbi9BbmltYXRpb25NaXhlci5qc1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIE1peGVzIHRvZ2V0aGVyIHRoZSBBbmltYXRpb25DbGlwcyBzY2hlZHVsZWQgYnkgQW5pbWF0aW9uQWN0aW9ucyBhbmQgYXBwbGllcyB0aGVtIHRvIHRoZSByb290IGFuZCBzdWJ0cmVlXHJcbiAqXHJcbiAqXHJcbiAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXHJcbiAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xyXG4gKi9cclxuXHJcblRIUkVFLkFuaW1hdGlvbk1peGVyID0gZnVuY3Rpb24oIHJvb3QgKSB7XHJcblxyXG4gICAgdGhpcy5yb290ID0gcm9vdDtcclxuICAgIHRoaXMudGltZSA9IDA7XHJcbiAgICB0aGlzLnRpbWVTY2FsZSA9IDEuMDtcclxuICAgIHRoaXMuYWN0aW9ucyA9IFtdO1xyXG4gICAgdGhpcy5wcm9wZXJ0eUJpbmRpbmdNYXAgPSB7fTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BbmltYXRpb25NaXhlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkFuaW1hdGlvbk1peGVyLFxyXG5cclxuICAgIGFkZEFjdGlvbjogZnVuY3Rpb24oIGFjdGlvbiApIHtcclxuXHJcbiAgICAgICAgLy8gVE9ETzogY2hlY2sgZm9yIGR1cGxpY2F0ZSBhY3Rpb24gbmFtZXM/ICBPciBwcm92aWRlIGVhY2ggYWN0aW9uIHdpdGggYSBVVUlEP1xyXG5cclxuICAgICAgICB0aGlzLmFjdGlvbnMucHVzaCggYWN0aW9uICk7XHJcbiAgICAgICAgYWN0aW9uLmluaXQoIHRoaXMudGltZSApO1xyXG4gICAgICAgIGFjdGlvbi5taXhlciA9IHRoaXM7XHJcblxyXG4gICAgICAgIHZhciB0cmFja3MgPSBhY3Rpb24uY2xpcC50cmFja3M7XHJcblxyXG4gICAgICAgIHZhciByb290ID0gYWN0aW9uLmxvY2FsUm9vdCB8fCB0aGlzLnJvb3Q7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgdHJhY2sgPSB0cmFja3NbIGkgXTtcclxuXHJcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eUJpbmRpbmdLZXkgPSByb290LnV1aWQgKyAnLScgKyB0cmFjay5uYW1lO1xyXG4gICAgICAgICAgICB2YXIgcHJvcGVydHlCaW5kaW5nID0gdGhpcy5wcm9wZXJ0eUJpbmRpbmdNYXBbIHByb3BlcnR5QmluZGluZ0tleSBdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBwcm9wZXJ0eUJpbmRpbmcgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUJpbmRpbmcgPSBuZXcgVEhSRUUuUHJvcGVydHlCaW5kaW5nKCByb290LCB0cmFjay5uYW1lICk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnR5QmluZGluZ01hcFsgcHJvcGVydHlCaW5kaW5nS2V5IF0gPSBwcm9wZXJ0eUJpbmRpbmc7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBwdXNoIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSB0cmFja3MuXHJcbiAgICAgICAgICAgIGFjdGlvbi5wcm9wZXJ0eUJpbmRpbmdzLnB1c2goIHByb3BlcnR5QmluZGluZyApO1xyXG5cclxuICAgICAgICAgICAgLy8gdHJhY2sgdXNhZ2VzIG9mIHNoYXJlZCBwcm9wZXJ0eSBiaW5kaW5ncywgYmVjYXVzZSBpZiB3ZSBsZWF2ZSB0b28gbWFueSBhcm91bmQsIHRoZSBtaXhlciBjYW4gZ2V0IHNsb3dcclxuICAgICAgICAgICAgcHJvcGVydHlCaW5kaW5nLnJlZmVyZW5jZUNvdW50ICs9IDE7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZUFsbEFjdGlvbnM6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmFjdGlvbnMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hY3Rpb25zW2ldLm1peGVyID0gbnVsbDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB1bmJpbmQgYWxsIHByb3BlcnR5IGJpbmRpbmdzXHJcbiAgICAgICAgZm9yICggdmFyIHByb3BlcnlCaW5kaW5nS2V5IGluIHRoaXMucHJvcGVydHlCaW5kaW5nTWFwICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eUJpbmRpbmdNYXBbIHByb3BlcnlCaW5kaW5nS2V5IF0udW5iaW5kKCk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5hY3Rpb25zID0gW107XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0eUJpbmRpbmdNYXAgPSB7fTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmVBY3Rpb246IGZ1bmN0aW9uKCBhY3Rpb24gKSB7XHJcblxyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuYWN0aW9ucy5pbmRleE9mKCBhY3Rpb24gKTtcclxuXHJcbiAgICAgICAgaWYgKCBpbmRleCAhPT0gLSAxICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hY3Rpb25zLnNwbGljZSggaW5kZXgsIDEgKTtcclxuICAgICAgICAgICAgYWN0aW9uLm1peGVyID0gbnVsbDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLy8gcmVtb3ZlIHVudXNlZCBwcm9wZXJ0eSBiaW5kaW5ncyBiZWNhdXNlIGlmIHdlIGxlYXZlIHRoZW0gYXJvdW5kIHRoZSBtaXhlciBjYW4gZ2V0IHNsb3dcclxuICAgICAgICB2YXIgcm9vdCA9IGFjdGlvbi5sb2NhbFJvb3QgfHwgdGhpcy5yb290O1xyXG4gICAgICAgIHZhciB0cmFja3MgPSBhY3Rpb24uY2xpcC50cmFja3M7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgdHJhY2sgPSB0cmFja3NbIGkgXTtcclxuXHJcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eUJpbmRpbmdLZXkgPSByb290LnV1aWQgKyAnLScgKyB0cmFjay5uYW1lO1xyXG4gICAgICAgICAgICB2YXIgcHJvcGVydHlCaW5kaW5nID0gdGhpcy5wcm9wZXJ0eUJpbmRpbmdNYXBbIHByb3BlcnR5QmluZGluZ0tleSBdO1xyXG5cclxuICAgICAgICAgICAgcHJvcGVydHlCaW5kaW5nLnJlZmVyZW5jZUNvdW50IC09IDE7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHByb3BlcnR5QmluZGluZy5yZWZlcmVuY2VDb3VudCA8PSAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHByb3BlcnR5QmluZGluZy51bmJpbmQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5wcm9wZXJ0eUJpbmRpbmdNYXBbIHByb3BlcnR5QmluZGluZ0tleSBdO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBjYW4gYmUgb3B0aW1pemVkIGlmIG5lZWRlZFxyXG4gICAgZmluZEFjdGlvbkJ5TmFtZTogZnVuY3Rpb24oIG5hbWUgKSB7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuYWN0aW9ucy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHRoaXMuYWN0aW9uc1tpXS5uYW1lID09PSBuYW1lICkgcmV0dXJuIHRoaXMuYWN0aW9uc1tpXTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHBsYXk6IGZ1bmN0aW9uKCBhY3Rpb24sIG9wdGlvbmFsRmFkZUluRHVyYXRpb24gKSB7XHJcblxyXG4gICAgICAgIGFjdGlvbi5zdGFydFRpbWUgPSB0aGlzLnRpbWU7XHJcbiAgICAgICAgdGhpcy5hZGRBY3Rpb24oIGFjdGlvbiApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGZhZGVPdXQ6IGZ1bmN0aW9uKCBhY3Rpb24sIGR1cmF0aW9uICkge1xyXG5cclxuICAgICAgICB2YXIga2V5cyA9IFtdO1xyXG5cclxuICAgICAgICBrZXlzLnB1c2goIHsgdGltZTogdGhpcy50aW1lLCB2YWx1ZTogMSB9ICk7XHJcbiAgICAgICAga2V5cy5wdXNoKCB7IHRpbWU6IHRoaXMudGltZSArIGR1cmF0aW9uLCB2YWx1ZTogMCB9ICk7XHJcblxyXG4gICAgICAgIGFjdGlvbi53ZWlnaHQgPSBuZXcgVEhSRUUuTnVtYmVyS2V5ZnJhbWVUcmFjayggXCJ3ZWlnaHRcIiwga2V5cyApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGZhZGVJbjogZnVuY3Rpb24oIGFjdGlvbiwgZHVyYXRpb24gKSB7XHJcblxyXG4gICAgICAgIHZhciBrZXlzID0gW107XHJcblxyXG4gICAgICAgIGtleXMucHVzaCggeyB0aW1lOiB0aGlzLnRpbWUsIHZhbHVlOiAwIH0gKTtcclxuICAgICAgICBrZXlzLnB1c2goIHsgdGltZTogdGhpcy50aW1lICsgZHVyYXRpb24sIHZhbHVlOiAxIH0gKTtcclxuXHJcbiAgICAgICAgYWN0aW9uLndlaWdodCA9IG5ldyBUSFJFRS5OdW1iZXJLZXlmcmFtZVRyYWNrKCBcIndlaWdodFwiLCBrZXlzICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgd2FycDogZnVuY3Rpb24oIGFjdGlvbiwgc3RhcnRUaW1lU2NhbGUsIGVuZFRpbWVTY2FsZSwgZHVyYXRpb24gKSB7XHJcblxyXG4gICAgICAgIHZhciBrZXlzID0gW107XHJcblxyXG4gICAgICAgIGtleXMucHVzaCggeyB0aW1lOiB0aGlzLnRpbWUsIHZhbHVlOiBzdGFydFRpbWVTY2FsZSB9ICk7XHJcbiAgICAgICAga2V5cy5wdXNoKCB7IHRpbWU6IHRoaXMudGltZSArIGR1cmF0aW9uLCB2YWx1ZTogZW5kVGltZVNjYWxlIH0gKTtcclxuXHJcbiAgICAgICAgYWN0aW9uLnRpbWVTY2FsZSA9IG5ldyBUSFJFRS5OdW1iZXJLZXlmcmFtZVRyYWNrKCBcInRpbWVTY2FsZVwiLCBrZXlzICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY3Jvc3NGYWRlOiBmdW5jdGlvbiggZmFkZU91dEFjdGlvbiwgZmFkZUluQWN0aW9uLCBkdXJhdGlvbiwgd2FycCApIHtcclxuXHJcbiAgICAgICAgdGhpcy5mYWRlT3V0KCBmYWRlT3V0QWN0aW9uLCBkdXJhdGlvbiApO1xyXG4gICAgICAgIHRoaXMuZmFkZUluKCBmYWRlSW5BY3Rpb24sIGR1cmF0aW9uICk7XHJcblxyXG4gICAgICAgIGlmICggd2FycCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBzdGFydEVuZFJhdGlvID0gZmFkZU91dEFjdGlvbi5jbGlwLmR1cmF0aW9uIC8gZmFkZUluQWN0aW9uLmNsaXAuZHVyYXRpb247XHJcbiAgICAgICAgICAgIHZhciBlbmRTdGFydFJhdGlvID0gMS4wIC8gc3RhcnRFbmRSYXRpbztcclxuXHJcbiAgICAgICAgICAgIHRoaXMud2FycCggZmFkZU91dEFjdGlvbiwgMS4wLCBzdGFydEVuZFJhdGlvLCBkdXJhdGlvbiApO1xyXG4gICAgICAgICAgICB0aGlzLndhcnAoIGZhZGVJbkFjdGlvbiwgZW5kU3RhcnRSYXRpbywgMS4wLCBkdXJhdGlvbiApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiggZGVsdGFUaW1lICkge1xyXG5cclxuICAgICAgICB2YXIgbWl4ZXJEZWx0YVRpbWUgPSBkZWx0YVRpbWUgKiB0aGlzLnRpbWVTY2FsZTtcclxuICAgICAgICB0aGlzLnRpbWUgKz0gbWl4ZXJEZWx0YVRpbWU7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuYWN0aW9ucy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYWN0aW9uID0gdGhpcy5hY3Rpb25zW2ldO1xyXG5cclxuICAgICAgICAgICAgdmFyIHdlaWdodCA9IGFjdGlvbi5nZXRXZWlnaHRBdCggdGhpcy50aW1lICk7XHJcblxyXG4gICAgICAgICAgICB2YXIgYWN0aW9uVGltZVNjYWxlID0gYWN0aW9uLmdldFRpbWVTY2FsZUF0KCB0aGlzLnRpbWUgKTtcclxuICAgICAgICAgICAgdmFyIGFjdGlvbkRlbHRhVGltZSA9IG1peGVyRGVsdGFUaW1lICogYWN0aW9uVGltZVNjYWxlO1xyXG5cclxuICAgICAgICAgICAgdmFyIGFjdGlvblJlc3VsdHMgPSBhY3Rpb24udXBkYXRlKCBhY3Rpb25EZWx0YVRpbWUgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggYWN0aW9uLndlaWdodCA8PSAwIHx8ICEgYWN0aW9uLmVuYWJsZWQgKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IGFjdGlvblJlc3VsdHMubGVuZ3RoOyBqICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gYWN0aW9uLmNsaXAudHJhY2tzW2pdLm5hbWU7XHJcblxyXG4gICAgICAgICAgICAgICAgYWN0aW9uLnByb3BlcnR5QmluZGluZ3NbIGogXS5hY2N1bXVsYXRlKCBhY3Rpb25SZXN1bHRzW2pdLCB3ZWlnaHQgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhcHBseSB0byBub2Rlc1xyXG4gICAgICAgIGZvciAoIHZhciBwcm9wZXJ0eUJpbmRpbmdLZXkgaW4gdGhpcy5wcm9wZXJ0eUJpbmRpbmdNYXAgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnR5QmluZGluZ01hcFsgcHJvcGVydHlCaW5kaW5nS2V5IF0uYXBwbHkoKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuQW5pbWF0aW9uTWl4ZXIucHJvdG90eXBlICk7XHJcblxyXG4vLyBGaWxlOnNyYy9hbmltYXRpb24vQW5pbWF0aW9uVXRpbHMuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xyXG4gKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cclxuICovXHJcblxyXG5USFJFRS5BbmltYXRpb25VdGlscyA9IHtcclxuXHJcbiAgICBnZXRFcXVhbHNGdW5jOiBmdW5jdGlvbiggZXhlbXBsYXJWYWx1ZSApIHtcclxuXHJcbiAgICAgICAgaWYgKCBleGVtcGxhclZhbHVlLmVxdWFscyApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGVxdWFsc19vYmplY3QoIGEsIGIgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5lcXVhbHMoIGIgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGVxdWFsc19wcmltaXRpdmUoIGEsIGIgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoIGEgPT09IGIgKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCBleGVtcGxhclZhbHVlICkge1xyXG5cclxuICAgICAgICB2YXIgdHlwZU5hbWUgPSB0eXBlb2YgZXhlbXBsYXJWYWx1ZTtcclxuICAgICAgICBpZiAoIHR5cGVOYW1lID09PSBcIm9iamVjdFwiICkge1xyXG4gICAgICAgICAgICBpZiAoIGV4ZW1wbGFyVmFsdWUuY2xvbmUgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhlbXBsYXJWYWx1ZS5jbG9uZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoIFwiY2FuIG5vdCBmaWd1cmUgb3V0IGhvdyB0byBjb3B5IGV4ZW1wbGFyVmFsdWVcIiwgZXhlbXBsYXJWYWx1ZSApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGV4ZW1wbGFyVmFsdWU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBsZXJwOiBmdW5jdGlvbiggYSwgYiwgYWxwaGEsIGludGVyVHJhY2sgKSB7XHJcblxyXG4gICAgICAgIHZhciBsZXJwRnVuYyA9IFRIUkVFLkFuaW1hdGlvblV0aWxzLmdldExlcnBGdW5jKCBhLCBpbnRlclRyYWNrICk7XHJcblxyXG4gICAgICAgIHJldHVybiBsZXJwRnVuYyggYSwgYiwgYWxwaGEgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGxlcnBfb2JqZWN0OiBmdW5jdGlvbiggYSwgYiwgYWxwaGEgKSB7XHJcbiAgICAgICAgcmV0dXJuIGEubGVycCggYiwgYWxwaGEgKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2xlcnBfb2JqZWN0OiBmdW5jdGlvbiggYSwgYiwgYWxwaGEgKSB7XHJcbiAgICAgICAgcmV0dXJuIGEuc2xlcnAoIGIsIGFscGhhICk7XHJcbiAgICB9LFxyXG5cclxuICAgIGxlcnBfbnVtYmVyOiBmdW5jdGlvbiggYSwgYiwgYWxwaGEgKSB7XHJcbiAgICAgICAgcmV0dXJuIGEgKiAoIDEgLSBhbHBoYSApICsgYiAqIGFscGhhO1xyXG4gICAgfSxcclxuXHJcbiAgICBsZXJwX2Jvb2xlYW46IGZ1bmN0aW9uKCBhLCBiLCBhbHBoYSApIHtcclxuICAgICAgICByZXR1cm4gKCBhbHBoYSA8IDAuNSApID8gYSA6IGI7XHJcbiAgICB9LFxyXG5cclxuICAgIGxlcnBfYm9vbGVhbl9pbW1lZGlhdGU6IGZ1bmN0aW9uKCBhLCBiLCBhbHBoYSApIHtcclxuICAgICAgICByZXR1cm4gYTtcclxuICAgIH0sXHJcblxyXG4gICAgbGVycF9zdHJpbmc6IGZ1bmN0aW9uKCBhLCBiLCBhbHBoYSApIHtcclxuICAgICAgICByZXR1cm4gKCBhbHBoYSA8IDAuNSApID8gYSA6IGI7XHJcbiAgICB9LFxyXG5cclxuICAgIGxlcnBfc3RyaW5nX2ltbWVkaWF0ZTogZnVuY3Rpb24oIGEsIGIsIGFscGhhICkge1xyXG4gICAgICAgIHJldHVybiBhO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBOT1RFOiB0aGlzIGlzIGFuIGFjY3VtdWxhdG9yIGZ1bmN0aW9uIHRoYXQgbW9kaWZpZXMgdGhlIGZpcnN0IGFyZ3VtZW50IChlLmcuIGEpLlx0VGhpcyBpcyB0byBtaW5pbWl6ZSBtZW1vcnkgYWxvY2F0aW9ucy5cclxuICAgIGdldExlcnBGdW5jOiBmdW5jdGlvbiggZXhlbXBsYXJWYWx1ZSwgaW50ZXJUcmFjayApIHtcclxuXHJcbiAgICAgICAgaWYgKCBleGVtcGxhclZhbHVlID09PSB1bmRlZmluZWQgfHwgZXhlbXBsYXJWYWx1ZSA9PT0gbnVsbCApIHRocm93IG5ldyBFcnJvciggXCJleGFtcGxhclZhbHVlIGlzIG51bGxcIiApO1xyXG5cclxuICAgICAgICB2YXIgdHlwZU5hbWUgPSB0eXBlb2YgZXhlbXBsYXJWYWx1ZTtcclxuXHJcbiAgICAgICAgc3dpdGNoKCB0eXBlTmFtZSApIHtcclxuXHJcbiAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjpcclxuICAgICAgICAgICAgICAgIGlmICggZXhlbXBsYXJWYWx1ZS5sZXJwICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUSFJFRS5BbmltYXRpb25VdGlscy5sZXJwX29iamVjdDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGV4ZW1wbGFyVmFsdWUuc2xlcnAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRIUkVFLkFuaW1hdGlvblV0aWxzLnNsZXJwX29iamVjdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFRIUkVFLkFuaW1hdGlvblV0aWxzLmxlcnBfbnVtYmVyO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcclxuICAgICAgICAgICAgICAgIGlmICggaW50ZXJUcmFjayApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVEhSRUUuQW5pbWF0aW9uVXRpbHMubGVycF9ib29sZWFuO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVEhSRUUuQW5pbWF0aW9uVXRpbHMubGVycF9ib29sZWFuX2ltbWVkaWF0ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcclxuICAgICAgICAgICAgICAgIGlmICggaW50ZXJUcmFjayApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVEhSRUUuQW5pbWF0aW9uVXRpbHMubGVycF9zdHJpbmc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUSFJFRS5BbmltYXRpb25VdGlscy5sZXJwX3N0cmluZ19pbW1lZGlhdGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvYW5pbWF0aW9uL0tleWZyYW1lVHJhY2suanNcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBBIFRyYWNrIHRoYXQgcmV0dXJucyBhIGtleWZyYW1lIGludGVycG9sYXRlZCB2YWx1ZSwgY3VycmVudGx5IGxpbmVhcmx5IGludGVycG9sYXRlZFxyXG4gKlxyXG4gKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xyXG4gKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cclxuICovXHJcblxyXG5USFJFRS5LZXlmcmFtZVRyYWNrID0gZnVuY3Rpb24gKCBuYW1lLCBrZXlzICkge1xyXG5cclxuICAgIGlmICggbmFtZSA9PT0gdW5kZWZpbmVkICkgdGhyb3cgbmV3IEVycm9yKCBcInRyYWNrIG5hbWUgaXMgdW5kZWZpbmVkXCIgKTtcclxuICAgIGlmICgga2V5cyA9PT0gdW5kZWZpbmVkIHx8IGtleXMubGVuZ3RoID09PSAwICkgdGhyb3cgbmV3IEVycm9yKCBcIm5vIGtleXMgaW4gdHJhY2sgbmFtZWQgXCIgKyBuYW1lICk7XHJcblxyXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgIHRoaXMua2V5cyA9IGtleXM7XHQvLyB0aW1lIGluIHNlY29uZHMsIHZhbHVlIGFzIHZhbHVlXHJcblxyXG4gICAgLy8gdGhlIGluZGV4IG9mIHRoZSBsYXN0IHJlc3VsdCwgdXNlZCBhcyBhIHN0YXJ0aW5nIHBvaW50IGZvciBsb2NhbCBzZWFyY2guXHJcbiAgICB0aGlzLmxhc3RJbmRleCA9IDA7XHJcblxyXG4gICAgdGhpcy52YWxpZGF0ZSgpO1xyXG4gICAgdGhpcy5vcHRpbWl6ZSgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLktleWZyYW1lVHJhY2sucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5LZXlmcmFtZVRyYWNrLFxyXG5cclxuICAgIGdldEF0OiBmdW5jdGlvbiggdGltZSApIHtcclxuXHJcblxyXG4gICAgICAgIC8vIHRoaXMgY2FuIG5vdCBnbyBoaWdoZXIgdGhhbiB0aGlzLmtleXMubGVuZ3RoLlxyXG4gICAgICAgIHdoaWxlKCAoIHRoaXMubGFzdEluZGV4IDwgdGhpcy5rZXlzLmxlbmd0aCApICYmICggdGltZSA+PSB0aGlzLmtleXNbdGhpcy5sYXN0SW5kZXhdLnRpbWUgKSApIHtcclxuICAgICAgICAgICAgdGhpcy5sYXN0SW5kZXggKys7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gdGhpcyBjYW4gbm90IGdvIGxvd2VyIHRoYW4gMC5cclxuICAgICAgICB3aGlsZSggKCB0aGlzLmxhc3RJbmRleCA+IDAgKSAmJiAoIHRpbWUgPCB0aGlzLmtleXNbdGhpcy5sYXN0SW5kZXggLSAxXS50aW1lICkgKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdEluZGV4IC0tO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLmxhc3RJbmRleCA+PSB0aGlzLmtleXMubGVuZ3RoICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zZXRSZXN1bHQoIHRoaXMua2V5c1sgdGhpcy5rZXlzLmxlbmd0aCAtIDEgXS52YWx1ZSApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5sYXN0SW5kZXggPT09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNldFJlc3VsdCggdGhpcy5rZXlzWyAwIF0udmFsdWUgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcHJldktleSA9IHRoaXMua2V5c1sgdGhpcy5sYXN0SW5kZXggLSAxIF07XHJcbiAgICAgICAgdGhpcy5zZXRSZXN1bHQoIHByZXZLZXkudmFsdWUgKTtcclxuXHJcbiAgICAgICAgLy8gaWYgdHJ1ZSwgbWVhbnMgdGhhdCBwcmV2L2N1cnJlbnQga2V5cyBhcmUgaWRlbnRpY2FsLCB0aHVzIG5vIGludGVycG9sYXRpb24gcmVxdWlyZWQuXHJcbiAgICAgICAgaWYgKCBwcmV2S2V5LmNvbnN0YW50VG9OZXh0ICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGxpbmVhciBpbnRlcnBvbGF0aW9uIHRvIHN0YXJ0IHdpdGhcclxuICAgICAgICB2YXIgY3VycmVudEtleSA9IHRoaXMua2V5c1sgdGhpcy5sYXN0SW5kZXggXTtcclxuICAgICAgICB2YXIgYWxwaGEgPSAoIHRpbWUgLSBwcmV2S2V5LnRpbWUgKSAvICggY3VycmVudEtleS50aW1lIC0gcHJldktleS50aW1lICk7XHJcbiAgICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmxlcnBWYWx1ZXMoIHRoaXMucmVzdWx0LCBjdXJyZW50S2V5LnZhbHVlLCBhbHBoYSApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQ7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBtb3ZlIGFsbCBrZXlmcmFtZXMgZWl0aGVyIGZvcndhcmRzIG9yIGJhY2t3YXJkcyBpbiB0aW1lXHJcbiAgICBzaGlmdDogZnVuY3Rpb24oIHRpbWVPZmZzZXQgKSB7XHJcblxyXG4gICAgICAgIGlmICggdGltZU9mZnNldCAhPT0gMC4wICkge1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5rZXlzLmxlbmd0aDsgaSArKyApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMua2V5c1tpXS50aW1lICs9IHRpbWVPZmZzZXQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHNjYWxlIGFsbCBrZXlmcmFtZSB0aW1lcyBieSBhIGZhY3RvciAodXNlZnVsIGZvciBmcmFtZSA8LT4gc2Vjb25kcyBjb252ZXJzaW9ucylcclxuICAgIHNjYWxlOiBmdW5jdGlvbiggdGltZVNjYWxlICkge1xyXG5cclxuICAgICAgICBpZiAoIHRpbWVTY2FsZSAhPT0gMS4wICkge1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5rZXlzLmxlbmd0aDsgaSArKyApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMua2V5c1tpXS50aW1lICo9IHRpbWVTY2FsZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLy8gcmVtb3ZlcyBrZXlmcmFtZXMgYmVmb3JlIGFuZCBhZnRlciBhbmltYXRpb24gd2l0aG91dCBjaGFuZ2luZyBhbnkgdmFsdWVzIHdpdGhpbiB0aGUgcmFuZ2UgW3N0YXJ0VGltZSwgZW5kVGltZV0uXHJcbiAgICAvLyBJTVBPUlRBTlQ6IFdlIGRvIG5vdCBzaGlmdCBhcm91bmQga2V5cyB0byB0aGUgc3RhcnQgb2YgdGhlIHRyYWNrIHRpbWUsIGJlY2F1c2UgZm9yIGludGVycG9sYXRlZCBrZXlzIHRoaXMgd2lsbCBjaGFuZ2UgdGhlaXIgdmFsdWVzXHJcbiAgICB0cmltOiBmdW5jdGlvbiggc3RhcnRUaW1lLCBlbmRUaW1lICkge1xyXG5cclxuICAgICAgICB2YXIgZmlyc3RLZXlzVG9SZW1vdmUgPSAwO1xyXG4gICAgICAgIGZvciAoIHZhciBpID0gMTsgaSA8IHRoaXMua2V5cy5sZW5ndGg7IGkgKysgKSB7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5rZXlzW2ldIDw9IHN0YXJ0VGltZSApIHtcclxuICAgICAgICAgICAgICAgIGZpcnN0S2V5c1RvUmVtb3ZlICsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbGFzdEtleXNUb1JlbW92ZSA9IDA7XHJcbiAgICAgICAgZm9yICggdmFyIGkgPSB0aGlzLmtleXMubGVuZ3RoIC0gMjsgaSA+IDA7IGkgKysgKSB7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5rZXlzW2ldID49IGVuZFRpbWUgKSB7XHJcbiAgICAgICAgICAgICAgICBsYXN0S2V5c1RvUmVtb3ZlICsrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJlbW92ZSBsYXN0IGtleXMgZmlyc3QgYmVjYXVzZSBpdCBkb2Vzbid0IGFmZmVjdCB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IGtleXMgKHRoZSBvdGhlcndheSBhcm91bmQgZG9lc24ndCB3b3JrIGFzIGVhc2lseSlcclxuICAgICAgICBpZiAoICggZmlyc3RLZXlzVG9SZW1vdmUgKyBsYXN0S2V5c1RvUmVtb3ZlICkgPiAwICkge1xyXG4gICAgICAgICAgICB0aGlzLmtleXMgPSB0aGlzLmtleXMuc3BsaWNlKCBmaXJzdEtleXNUb1JlbW92ZSwgdGhpcy5rZXlzLmxlbmd0aCAtIGxhc3RLZXlzVG9SZW1vdmUgLSBmaXJzdEtleXNUb1JlbW92ZSApOztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyogTk9URTogVGhpcyBpcyBjb21tZW50ZWQgb3V0IGJlY2F1c2Ugd2UgcmVhbGx5IHNob3VsZG4ndCBoYXZlIHRvIGhhbmRsZSB1bnNvcnRlZCBrZXkgbGlzdHNcclxuICAgICBUcmFja3Mgd2l0aCBvdXQgb2Ygb3JkZXIga2V5cyBzaG91bGQgYmUgY29uc2lkZXJlZCB0byBiZSBpbnZhbGlkLiAgLSBiaG91c3RvblxyXG4gICAgIHNvcnQ6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICB0aGlzLmtleXMuc29ydCggVEhSRUUuS2V5ZnJhbWVUcmFjay5rZXlDb21wYXJlciApO1xyXG5cclxuICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgfSwqL1xyXG5cclxuICAgIC8vIGVuc3VyZSB3ZSBkbyBub3QgZ2V0IGEgR2FyYmFnZUluR2FyYmFnZU91dCBzaXR1YXRpb24sIG1ha2Ugc3VyZSB0cmFja3MgYXJlIGF0IGxlYXN0IG1pbmltYWxseSB2aWFibGVcclxuICAgIC8vIE9uZSBjb3VsZCBldmVudHVhbGx5IGVuc3VyZSB0aGF0IGFsbCBrZXkudmFsdWVzIGluIGEgdHJhY2sgYXJlIGFsbCBvZiB0aGUgc2FtZSB0eXBlIChvdGhlcndpc2UgaW50ZXJwb2xhdGlvbiBtYWtlcyBubyBzZW5zZS4pXHJcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHZhciBwcmV2S2V5ID0gbnVsbDtcclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLmtleXMubGVuZ3RoID09PSAwICkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCBcIiAgdHJhY2sgaXMgZW1wdHksIG5vIGtleXNcIiwgdGhpcyApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmtleXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGN1cnJLZXkgPSB0aGlzLmtleXNbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAoICEgY3VycktleSApIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoIFwiICBrZXkgaXMgbnVsbCBpbiB0cmFja1wiLCB0aGlzLCBpICk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggKCB0eXBlb2YgY3VycktleS50aW1lICkgIT09ICdudW1iZXInIHx8IGlzTmFOKCBjdXJyS2V5LnRpbWUgKSApIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoIFwiICBrZXkudGltZSBpcyBub3QgYSB2YWxpZCBudW1iZXJcIiwgdGhpcywgaSwgY3VycktleSApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIGN1cnJLZXkudmFsdWUgPT09IHVuZGVmaW5lZCB8fCBjdXJyS2V5LnZhbHVlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCBcIiAga2V5LnZhbHVlIGlzIG51bGwgaW4gdHJhY2tcIiwgdGhpcywgaSwgY3VycktleSApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIHByZXZLZXkgJiYgcHJldktleS50aW1lID4gY3VycktleS50aW1lICkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvciggXCIgIGtleS50aW1lIGlzIGxlc3MgdGhhbiBwcmV2aW91cyBrZXkgdGltZSwgb3V0IG9mIG9yZGVyIGtleXNcIiwgdGhpcywgaSwgY3VycktleSwgcHJldktleSApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwcmV2S2V5ID0gY3VycktleTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIGN1cnJlbnRseSBvbmx5IHJlbW92ZXMgZXF1aXZhbGVudCBzZXF1ZW50aWFsIGtleXMgKDAsMCwwLDAsMSwxLDEsMCwwLDAsMCwwLDAsMCkgLS0+ICgwLDAsMSwxLDAsMCksIHdoaWNoIGFyZSBjb21tb24gaW4gbW9ycGggdGFyZ2V0IGFuaW1hdGlvbnNcclxuICAgIG9wdGltaXplOiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgdmFyIG5ld0tleXMgPSBbXTtcclxuICAgICAgICB2YXIgcHJldktleSA9IHRoaXMua2V5c1swXTtcclxuICAgICAgICBuZXdLZXlzLnB1c2goIHByZXZLZXkgKTtcclxuXHJcbiAgICAgICAgdmFyIGVxdWFsc0Z1bmMgPSBUSFJFRS5BbmltYXRpb25VdGlscy5nZXRFcXVhbHNGdW5jKCBwcmV2S2V5LnZhbHVlICk7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMTsgaSA8IHRoaXMua2V5cy5sZW5ndGggLSAxOyBpICsrICkge1xyXG4gICAgICAgICAgICB2YXIgY3VycktleSA9IHRoaXMua2V5c1tpXTtcclxuICAgICAgICAgICAgdmFyIG5leHRLZXkgPSB0aGlzLmtleXNbaSsxXTtcclxuXHJcbiAgICAgICAgICAgIC8vIGlmIHByZXZLZXkgJiBjdXJyS2V5IGFyZSB0aGUgc2FtZSB0aW1lLCByZW1vdmUgY3VycktleS4gIElmIHlvdSB3YW50IGltbWVkaWF0ZSBhZGphY2VudCBrZXlzLCB1c2UgYW4gZXBzaWxvbiBvZmZzZXRcclxuICAgICAgICAgICAgLy8gaXQgaXMgbm90IHBvc3NpYmxlIHRvIGhhdmUgdHdvIGtleXMgYXQgdGhlIHNhbWUgdGltZSBhcyB3ZSBzb3J0IHRoZW0uICBUaGUgc29ydCBpcyBub3Qgc3RhYmxlIG9uIGtleXMgd2l0aCB0aGUgc2FtZSB0aW1lLlxyXG4gICAgICAgICAgICBpZiAoICggcHJldktleS50aW1lID09PSBjdXJyS2V5LnRpbWUgKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBjb21wbGV0ZWx5IHVubmVjZXNzYXJ5IGtleWZyYW1lcyB0aGF0IGFyZSB0aGUgc2FtZSBhcyB0aGVpciBwcmV2IGFuZCBuZXh0IGtleXNcclxuICAgICAgICAgICAgaWYgKCB0aGlzLmNvbXBhcmVWYWx1ZXMoIHByZXZLZXkudmFsdWUsIGN1cnJLZXkudmFsdWUgKSAmJiB0aGlzLmNvbXBhcmVWYWx1ZXMoIGN1cnJLZXkudmFsdWUsIG5leHRLZXkudmFsdWUgKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGRldGVybWluZSBpZiBpbnRlcnBvbGF0aW9uIGlzIHJlcXVpcmVkXHJcbiAgICAgICAgICAgIHByZXZLZXkuY29uc3RhbnRUb05leHQgPSB0aGlzLmNvbXBhcmVWYWx1ZXMoIHByZXZLZXkudmFsdWUsIGN1cnJLZXkudmFsdWUgKTtcclxuXHJcbiAgICAgICAgICAgIG5ld0tleXMucHVzaCggY3VycktleSApO1xyXG4gICAgICAgICAgICBwcmV2S2V5ID0gY3VycktleTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbmV3S2V5cy5wdXNoKCB0aGlzLmtleXNbIHRoaXMua2V5cy5sZW5ndGggLSAxIF0gKTtcclxuXHJcbiAgICAgICAgdGhpcy5rZXlzID0gbmV3S2V5cztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcblRIUkVFLktleWZyYW1lVHJhY2sua2V5Q29tcGFyZXIgPSBmdW5jdGlvbiBrZXlDb21wYXJhdG9yKGtleTAsIGtleTEpIHtcclxuICAgIHJldHVybiBrZXkwLnRpbWUgLSBrZXkxLnRpbWU7XHJcbn07XHJcblxyXG5USFJFRS5LZXlmcmFtZVRyYWNrLnBhcnNlID0gZnVuY3Rpb24oIGpzb24gKSB7XHJcblxyXG4gICAgaWYgKCBqc29uLnR5cGUgPT09IHVuZGVmaW5lZCApIHRocm93IG5ldyBFcnJvciggXCJ0cmFjayB0eXBlIHVuZGVmaW5lZCwgY2FuIG5vdCBwYXJzZVwiICk7XHJcblxyXG4gICAgdmFyIHRyYWNrVHlwZSA9IFRIUkVFLktleWZyYW1lVHJhY2suR2V0VHJhY2tUeXBlRm9yVHlwZU5hbWUoIGpzb24udHlwZSApO1xyXG5cclxuICAgIHJldHVybiB0cmFja1R5cGUucGFyc2UoIGpzb24gKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5LZXlmcmFtZVRyYWNrLkdldFRyYWNrVHlwZUZvclR5cGVOYW1lID0gZnVuY3Rpb24oIHR5cGVOYW1lICkge1xyXG4gICAgc3dpdGNoKCB0eXBlTmFtZS50b0xvd2VyQ2FzZSgpICkge1xyXG4gICAgICAgIGNhc2UgXCJ2ZWN0b3JcIjpcclxuICAgICAgICBjYXNlIFwidmVjdG9yMlwiOlxyXG4gICAgICAgIGNhc2UgXCJ2ZWN0b3IzXCI6XHJcbiAgICAgICAgY2FzZSBcInZlY3RvcjRcIjpcclxuICAgICAgICAgICAgcmV0dXJuIFRIUkVFLlZlY3RvcktleWZyYW1lVHJhY2s7XHJcblxyXG4gICAgICAgIGNhc2UgXCJxdWF0ZXJuaW9uXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBUSFJFRS5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaztcclxuXHJcbiAgICAgICAgY2FzZSBcImludGVnZXJcIjpcclxuICAgICAgICBjYXNlIFwic2NhbGFyXCI6XHJcbiAgICAgICAgY2FzZSBcImRvdWJsZVwiOlxyXG4gICAgICAgIGNhc2UgXCJmbG9hdFwiOlxyXG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcclxuICAgICAgICAgICAgcmV0dXJuIFRIUkVFLk51bWJlcktleWZyYW1lVHJhY2s7XHJcblxyXG4gICAgICAgIGNhc2UgXCJib29sXCI6XHJcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcclxuICAgICAgICAgICAgcmV0dXJuIFRIUkVFLkJvb2xlYW5LZXlmcmFtZVRyYWNrO1xyXG5cclxuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBUSFJFRS5TdHJpbmdLZXlmcmFtZVRyYWNrO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoIFwiVW5zdXBwb3J0ZWQgdHlwZU5hbWU6IFwiICsgdHlwZU5hbWUgKTtcclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2FuaW1hdGlvbi9Qcm9wZXJ0eUJpbmRpbmcuanNcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBBIHRyYWNrIGJvdW5kIHRvIGEgcmVhbCB2YWx1ZSBpbiB0aGUgc2NlbmUgZ3JhcGguXHJcbiAqXHJcbiAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXHJcbiAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xyXG4gKi9cclxuXHJcblRIUkVFLlByb3BlcnR5QmluZGluZyA9IGZ1bmN0aW9uICggcm9vdE5vZGUsIHRyYWNrTmFtZSApIHtcclxuXHJcbiAgICB0aGlzLnJvb3ROb2RlID0gcm9vdE5vZGU7XHJcbiAgICB0aGlzLnRyYWNrTmFtZSA9IHRyYWNrTmFtZTtcclxuICAgIHRoaXMucmVmZXJlbmNlQ291bnQgPSAwO1xyXG4gICAgdGhpcy5vcmlnaW5hbFZhbHVlID0gbnVsbDsgLy8gdGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBiZWZvcmUgaXQgd2FzIGNvbnRyb2xsZWQgYnkgdGhpcyBiaW5kaW5nXHJcblxyXG4gICAgdmFyIHBhcnNlUmVzdWx0cyA9IFRIUkVFLlByb3BlcnR5QmluZGluZy5wYXJzZVRyYWNrTmFtZSggdHJhY2tOYW1lICk7XHJcblxyXG4gICAgdGhpcy5kaXJlY3RvcnlOYW1lID0gcGFyc2VSZXN1bHRzLmRpcmVjdG9yeU5hbWU7XHJcbiAgICB0aGlzLm5vZGVOYW1lID0gcGFyc2VSZXN1bHRzLm5vZGVOYW1lO1xyXG4gICAgdGhpcy5vYmplY3ROYW1lID0gcGFyc2VSZXN1bHRzLm9iamVjdE5hbWU7XHJcbiAgICB0aGlzLm9iamVjdEluZGV4ID0gcGFyc2VSZXN1bHRzLm9iamVjdEluZGV4O1xyXG4gICAgdGhpcy5wcm9wZXJ0eU5hbWUgPSBwYXJzZVJlc3VsdHMucHJvcGVydHlOYW1lO1xyXG4gICAgdGhpcy5wcm9wZXJ0eUluZGV4ID0gcGFyc2VSZXN1bHRzLnByb3BlcnR5SW5kZXg7XHJcblxyXG4gICAgdGhpcy5ub2RlID0gVEhSRUUuUHJvcGVydHlCaW5kaW5nLmZpbmROb2RlKCByb290Tm9kZSwgdGhpcy5ub2RlTmFtZSApIHx8IHJvb3ROb2RlO1xyXG5cclxuICAgIHRoaXMuY3VtdWxhdGl2ZVZhbHVlID0gbnVsbDtcclxuICAgIHRoaXMuY3VtdWxhdGl2ZVdlaWdodCA9IDA7XHJcbn07XHJcblxyXG5USFJFRS5Qcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5Qcm9wZXJ0eUJpbmRpbmcsXHJcblxyXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICB0aGlzLmN1bXVsYXRpdmVWYWx1ZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gMDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFjY3VtdWxhdGU6IGZ1bmN0aW9uKCB2YWx1ZSwgd2VpZ2h0ICkge1xyXG5cclxuICAgICAgICBpZiAoICEgdGhpcy5pc0JvdW5kICkgdGhpcy5iaW5kKCk7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5jdW11bGF0aXZlV2VpZ2h0ID09PSAwICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCB3ZWlnaHQgPiAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggdGhpcy5jdW11bGF0aXZlVmFsdWUgPT09IG51bGwgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdW11bGF0aXZlVmFsdWUgPSBUSFJFRS5BbmltYXRpb25VdGlscy5jbG9uZSggdmFsdWUgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuY3VtdWxhdGl2ZVdlaWdodCA9IHdlaWdodDtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBsZXJwQWxwaGEgPSB3ZWlnaHQgLyAoIHRoaXMuY3VtdWxhdGl2ZVdlaWdodCArIHdlaWdodCApO1xyXG4gICAgICAgICAgICB0aGlzLmN1bXVsYXRpdmVWYWx1ZSA9IHRoaXMubGVycFZhbHVlKCB0aGlzLmN1bXVsYXRpdmVWYWx1ZSwgdmFsdWUsIGxlcnBBbHBoYSApO1xyXG4gICAgICAgICAgICB0aGlzLmN1bXVsYXRpdmVXZWlnaHQgKz0gd2VpZ2h0O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB1bmJpbmQ6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICBpZiAoICEgdGhpcy5pc0JvdW5kICkgcmV0dXJuO1xyXG5cclxuICAgICAgICB0aGlzLnNldFZhbHVlKCB0aGlzLm9yaWdpbmFsVmFsdWUgKTtcclxuXHJcbiAgICAgICAgdGhpcy5zZXRWYWx1ZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5nZXRWYWx1ZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sZXJwVmFsdWUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZXF1YWxzVmFsdWUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudHJpZ2dlckRpcnR5ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmlzQm91bmQgPSBmYWxzZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIGJpbmQgdG8gdGhlIHJlYWwgcHJvcGVydHkgaW4gdGhlIHNjZW5lIGdyYXBoLCByZW1lbWJlciBvcmlnaW5hbCB2YWx1ZSwgbWVtb3JpemUgdmFyaW91cyBhY2Nlc3NvcnMgZm9yIHNwZWVkL2luZWZmaWNpZW5jeVxyXG4gICAgYmluZDogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5pc0JvdW5kICkgcmV0dXJuO1xyXG5cclxuICAgICAgICB2YXIgdGFyZ2V0T2JqZWN0ID0gdGhpcy5ub2RlO1xyXG5cclxuICAgICAgICAvLyBlbnN1cmUgdGhlcmUgaXMgYSB2YWx1ZSBub2RlXHJcbiAgICAgICAgaWYgKCAhIHRhcmdldE9iamVjdCApIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggXCIgIHRyeWluZyB0byB1cGRhdGUgbm9kZSBmb3IgdHJhY2s6IFwiICsgdGhpcy50cmFja05hbWUgKyBcIiBidXQgaXQgd2Fzbid0IGZvdW5kLlwiICk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5vYmplY3ROYW1lICkge1xyXG4gICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2Ugd2VyZSB3ZSBuZWVkIHRvIHJlYWNoIGRlZXBlciBpbnRvIHRoZSBoaWVyYXJjaHkgdG8gZ2V0IHRoZSBmYWNlIG1hdGVyaWFscy4uLi5cclxuICAgICAgICAgICAgaWYgKCB0aGlzLm9iamVjdE5hbWUgPT09IFwibWF0ZXJpYWxzXCIgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoICEgdGFyZ2V0T2JqZWN0Lm1hdGVyaWFsICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICcgIGNhbiBub3QgYmluZCB0byBtYXRlcmlhbCBhcyBub2RlIGRvZXMgbm90IGhhdmUgYSBtYXRlcmlhbCcsIHRoaXMgKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoICEgdGFyZ2V0T2JqZWN0Lm1hdGVyaWFsLm1hdGVyaWFscyApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnICBjYW4gbm90IGJpbmQgdG8gbWF0ZXJpYWwubWF0ZXJpYWxzIGFzIG5vZGUubWF0ZXJpYWwgZG9lcyBub3QgaGF2ZSBhIG1hdGVyaWFscyBhcnJheScsIHRoaXMgKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3QubWF0ZXJpYWwubWF0ZXJpYWxzO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCB0aGlzLm9iamVjdE5hbWUgPT09IFwiYm9uZXNcIiApIHtcclxuICAgICAgICAgICAgICAgIGlmICggISB0YXJnZXRPYmplY3Quc2tlbGV0b24gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvciggJyAgY2FuIG5vdCBiaW5kIHRvIGJvbmVzIGFzIG5vZGUgZG9lcyBub3QgaGF2ZSBhIHNrZWxldG9uJywgdGhpcyApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHBvdGVudGlhbCBmdXR1cmUgb3B0aW1pemF0aW9uOiBza2lwIHRoaXMgaWYgcHJvcGVydHlJbmRleCBpcyBhbHJlYWR5IGFuIGludGVnZXIsIGFuZCBjb252ZXJ0IHRoZSBpbnRlZ2VyIHN0cmluZyB0byBhIHRydWUgaW50ZWdlci5cclxuXHJcbiAgICAgICAgICAgICAgICB0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3Quc2tlbGV0b24uYm9uZXM7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gc3VwcG9ydCByZXNvbHZpbmcgbW9ycGhUYXJnZXQgbmFtZXMgaW50byBpbmRpY2VzLlxyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGFyZ2V0T2JqZWN0Lmxlbmd0aDsgaSArKyApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHRhcmdldE9iamVjdFtpXS5uYW1lID09PSB0aGlzLm9iamVjdEluZGV4ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9iamVjdEluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggdGFyZ2V0T2JqZWN0WyB0aGlzLm9iamVjdE5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICcgIGNhbiBub3QgYmluZCB0byBvYmplY3ROYW1lIG9mIG5vZGUsIHVuZGVmaW5lZCcsIHRoaXMgKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3RbIHRoaXMub2JqZWN0TmFtZSBdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIHRoaXMub2JqZWN0SW5kZXggIT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAgICAgICAgIGlmICggdGFyZ2V0T2JqZWN0WyB0aGlzLm9iamVjdEluZGV4IF0gPT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCBcIiAgdHJ5aW5nIHRvIGJpbmQgdG8gb2JqZWN0SW5kZXggb2Ygb2JqZWN0TmFtZSwgYnV0IGlzIHVuZGVmaW5lZDpcIiwgdGhpcywgdGFyZ2V0T2JqZWN0ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdFsgdGhpcy5vYmplY3RJbmRleCBdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIG1hcHBpbmdzXHJcbiAgICAgICAgdmFyIG5vZGVQcm9wZXJ0eSA9IHRhcmdldE9iamVjdFsgdGhpcy5wcm9wZXJ0eU5hbWUgXTtcclxuICAgICAgICBpZiAoICEgbm9kZVByb3BlcnR5ICkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCBcIiAgdHJ5aW5nIHRvIHVwZGF0ZSBwcm9wZXJ0eSBmb3IgdHJhY2s6IFwiICsgdGhpcy5ub2RlTmFtZSArICcuJyArIHRoaXMucHJvcGVydHlOYW1lICsgXCIgYnV0IGl0IHdhc24ndCBmb3VuZC5cIiwgdGFyZ2V0T2JqZWN0ICk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGFjY2VzcyBhIHN1YiBlbGVtZW50IG9mIHRoZSBwcm9wZXJ0eSBhcnJheSAob25seSBwcmltaXRpdmVzIGFyZSBzdXBwb3J0ZWQgcmlnaHQgbm93KVxyXG4gICAgICAgIGlmICggdGhpcy5wcm9wZXJ0eUluZGV4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHRoaXMucHJvcGVydHlOYW1lID09PSBcIm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1wiICkge1xyXG4gICAgICAgICAgICAgICAgLy8gcG90ZW50aWFsIG9wdGltaXphdGlvbiwgc2tpcCB0aGlzIGlmIHByb3BlcnR5SW5kZXggaXMgYWxyZWFkeSBhbiBpbnRlZ2VyLCBhbmQgY29udmVydCB0aGUgaW50ZWdlciBzdHJpbmcgdG8gYSB0cnVlIGludGVnZXIuXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gc3VwcG9ydCByZXNvbHZpbmcgbW9ycGhUYXJnZXQgbmFtZXMgaW50byBpbmRpY2VzLlxyXG4gICAgICAgICAgICAgICAgaWYgKCAhIHRhcmdldE9iamVjdC5nZW9tZXRyeSApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnICBjYW4gbm90IGJpbmQgdG8gbW9ycGhUYXJnZXRJbmZsdWVuY2VzIGJlY2FzdXNlIG5vZGUgZG9lcyBub3QgaGF2ZSBhIGdlb21ldHJ5JywgdGhpcyApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCAhIHRhcmdldE9iamVjdC5nZW9tZXRyeS5tb3JwaFRhcmdldHMgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvciggJyAgY2FuIG5vdCBiaW5kIHRvIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyBiZWNhc3VzZSBub2RlIGRvZXMgbm90IGhhdmUgYSBnZW9tZXRyeS5tb3JwaFRhcmdldHMnLCB0aGlzICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5ub2RlLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgKysgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0YXJnZXRPYmplY3QuZ2VvbWV0cnkubW9ycGhUYXJnZXRzW2ldLm5hbWUgPT09IHRoaXMucHJvcGVydHlJbmRleCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eUluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlID0gZnVuY3Rpb24gc2V0VmFsdWVfcHJvcGVydHlJbmRleGVkKCB2YWx1ZSApIHtcclxuICAgICAgICAgICAgICAgIGlmICggISB0aGlzLmVxdWFsc1ZhbHVlKCBub2RlUHJvcGVydHlbIHRoaXMucHJvcGVydHlJbmRleCBdLCB2YWx1ZSApICkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVQcm9wZXJ0eVsgdGhpcy5wcm9wZXJ0eUluZGV4IF0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZV9wcm9wZXJ0eUluZGV4ZWQoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZVByb3BlcnR5WyB0aGlzLnByb3BlcnR5SW5kZXggXTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG11c3QgdXNlIGNvcHkgZm9yIE9iamVjdDNELkV1bGVyL1F1YXRlcm5pb25cclxuICAgICAgICBlbHNlIGlmICggbm9kZVByb3BlcnR5LmNvcHkgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlID0gZnVuY3Rpb24gc2V0VmFsdWVfcHJvcGVydHlPYmplY3QoIHZhbHVlICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCAhIHRoaXMuZXF1YWxzVmFsdWUoIG5vZGVQcm9wZXJ0eSwgdmFsdWUgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlUHJvcGVydHkuY29weSggdmFsdWUgKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlX3Byb3BlcnR5T2JqZWN0KCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVQcm9wZXJ0eTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgcHJvcGVydHkgZGlyZWN0bHkgb24gdGhlIG5vZGUgKGRvIG5vdCB1c2Ugbm9kZVByb3BlcnR5IGFzIGl0IG1heSBub3QgYmUgYSByZWZlcmVuY2Ugb2JqZWN0KVxyXG4gICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZSA9IGZ1bmN0aW9uIHNldFZhbHVlX3Byb3BlcnR5KCB2YWx1ZSApIHtcclxuICAgICAgICAgICAgICAgIGlmICggISB0aGlzLmVxdWFsc1ZhbHVlKCB0YXJnZXRPYmplY3RbIHRoaXMucHJvcGVydHlOYW1lIF0sIHZhbHVlICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0T2JqZWN0WyB0aGlzLnByb3BlcnR5TmFtZSBdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZV9wcm9wZXJ0eSgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRPYmplY3RbIHRoaXMucHJvcGVydHlOYW1lIF07XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdHJpZ2dlciBub2RlIGRpcnR5XHJcbiAgICAgICAgaWYgKCB0YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgIT09IHVuZGVmaW5lZCApIHsgLy8gbWF0ZXJpYWxcclxuXHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckRpcnR5ID0gZnVuY3Rpb24gdHJpZ2dlckRpcnR5X25lZWRzVXBkYXRlKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCB0YXJnZXRPYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSAhPT0gdW5kZWZpbmVkICkgeyAvLyBub2RlIHRyYW5zZm9ybVxyXG5cclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyRGlydHkgPSBmdW5jdGlvbiB0cmlnZ2VyRGlydHlfbWF0cml4V29ybGROZWVkc1VwZGF0ZSgpIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMub3JpZ2luYWxWYWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcclxuXHJcbiAgICAgICAgdGhpcy5lcXVhbHNWYWx1ZSA9IFRIUkVFLkFuaW1hdGlvblV0aWxzLmdldEVxdWFsc0Z1bmMoIHRoaXMub3JpZ2luYWxWYWx1ZSApO1xyXG4gICAgICAgIHRoaXMubGVycFZhbHVlID0gVEhSRUUuQW5pbWF0aW9uVXRpbHMuZ2V0TGVycEZ1bmMoIHRoaXMub3JpZ2luYWxWYWx1ZSwgdHJ1ZSApO1xyXG5cclxuICAgICAgICB0aGlzLmlzQm91bmQgPSB0cnVlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYXBwbHk6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAvLyBmb3Igc3BlZWQgY2FwdHVyZSB0aGUgc2V0dGVyIHBhdHRlcm4gYXMgYSBjbG9zdXJlIChzb3J0IG9mIGEgbWVtb2l6YXRpb24gcGF0dGVybjogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWVtb2l6YXRpb24pXHJcbiAgICAgICAgaWYgKCAhIHRoaXMuaXNCb3VuZCApIHRoaXMuYmluZCgpO1xyXG5cclxuICAgICAgICAvLyBlYXJseSBleGl0IGlmIHRoZXJlIGlzIG5vdGhpbmcgdG8gYXBwbHkuXHJcbiAgICAgICAgaWYgKCB0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPiAwICkge1xyXG5cclxuICAgICAgICAgICAgLy8gYmxlbmQgd2l0aCBvcmlnaW5hbCB2YWx1ZVxyXG4gICAgICAgICAgICBpZiAoIHRoaXMuY3VtdWxhdGl2ZVdlaWdodCA8IDEgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHJlbWFpbmluZ1dlaWdodCA9IDEgLSB0aGlzLmN1bXVsYXRpdmVXZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVycEFscGhhID0gcmVtYWluaW5nV2VpZ2h0IC8gKCB0aGlzLmN1bXVsYXRpdmVXZWlnaHQgKyByZW1haW5pbmdXZWlnaHQgKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VtdWxhdGl2ZVZhbHVlID0gdGhpcy5sZXJwVmFsdWUoIHRoaXMuY3VtdWxhdGl2ZVZhbHVlLCB0aGlzLm9yaWdpbmFsVmFsdWUsIGxlcnBBbHBoYSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHZhbHVlQ2hhbmdlZCA9IHRoaXMuc2V0VmFsdWUoIHRoaXMuY3VtdWxhdGl2ZVZhbHVlICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHZhbHVlQ2hhbmdlZCAmJiB0aGlzLnRyaWdnZXJEaXJ0eSApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckRpcnR5KCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHJlc2V0IGFjY3VtdWxhdG9yXHJcbiAgICAgICAgICAgIHRoaXMuY3VtdWxhdGl2ZVZhbHVlID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gMDtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcblxyXG5USFJFRS5Qcm9wZXJ0eUJpbmRpbmcucGFyc2VUcmFja05hbWUgPSBmdW5jdGlvbiggdHJhY2tOYW1lICkge1xyXG5cclxuICAgIC8vIG1hdGNoZXMgc3RyaW5ncyBpbiB0aGUgZm9ybSBvZjpcclxuICAgIC8vICAgIG5vZGVOYW1lLnByb3BlcnR5XHJcbiAgICAvLyAgICBub2RlTmFtZS5wcm9wZXJ0eVthY2Nlc3Nvcl1cclxuICAgIC8vICAgIG5vZGVOYW1lLm1hdGVyaWFsLnByb3BlcnR5W2FjY2Vzc29yXVxyXG4gICAgLy8gICAgdXVpZC5wcm9wZXJ0eVthY2Nlc3Nvcl1cclxuICAgIC8vICAgIHV1aWQub2JqZWN0TmFtZVtvYmplY3RJbmRleF0ucHJvcGVydHlOYW1lW3Byb3BlcnR5SW5kZXhdXHJcbiAgICAvLyAgICBwYXJlbnROYW1lL25vZGVOYW1lLnByb3BlcnR5XHJcbiAgICAvLyAgICBwYXJlbnROYW1lL3BhcmVudE5hbWUvbm9kZU5hbWUucHJvcGVydHlbaW5kZXhdXHJcbiAgICAvL1x0ICAuYm9uZVtBcm1hdHVyZS5ERUZfY29nXS5wb3NpdGlvblxyXG4gICAgLy8gY3JlYXRlZCBhbmQgdGVzdGVkIHZpYSBodHRwczovL3JlZ2V4MTAxLmNvbS8jamF2YXNjcmlwdFxyXG5cclxuICAgIHZhciByZSA9IC9eKChbXFx3XStcXC8pKikoW1xcdy1cXGRdKyk/KFxcLihbXFx3XSspKFxcWyhbXFx3XFxkXFxbXFxdXFxfLiBdKylcXF0pPyk/KFxcLihbXFx3Ll0rKShcXFsoW1xcd1xcZFxcW1xcXVxcXy4gXSspXFxdKT8pJC87XHJcbiAgICB2YXIgbWF0Y2hlcyA9IHJlLmV4ZWModHJhY2tOYW1lKTtcclxuXHJcbiAgICBpZiAoICEgbWF0Y2hlcyApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIFwiY2Fubm90IHBhcnNlIHRyYWNrTmFtZSBhdCBhbGw6IFwiICsgdHJhY2tOYW1lICk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG1hdGNoZXMuaW5kZXggPT09IHJlLmxhc3RJbmRleCkge1xyXG4gICAgICAgIHJlLmxhc3RJbmRleCsrO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciByZXN1bHRzID0ge1xyXG4gICAgICAgIGRpcmVjdG9yeU5hbWU6IG1hdGNoZXNbMV0sXHJcbiAgICAgICAgbm9kZU5hbWU6IG1hdGNoZXNbM10sIFx0Ly8gYWxsb3dlZCB0byBiZSBudWxsLCBzcGVjaWZpZWQgcm9vdCBub2RlLlxyXG4gICAgICAgIG9iamVjdE5hbWU6IG1hdGNoZXNbNV0sXHJcbiAgICAgICAgb2JqZWN0SW5kZXg6IG1hdGNoZXNbN10sXHJcbiAgICAgICAgcHJvcGVydHlOYW1lOiBtYXRjaGVzWzldLFxyXG4gICAgICAgIHByb3BlcnR5SW5kZXg6IG1hdGNoZXNbMTFdXHQvLyBhbGxvd2VkIHRvIGJlIG51bGwsIHNwZWNpZmllcyB0aGF0IHRoZSB3aG9sZSBwcm9wZXJ0eSBpcyBzZXQuXHJcbiAgICB9O1xyXG5cclxuICAgIGlmICggcmVzdWx0cy5wcm9wZXJ0eU5hbWUgPT09IG51bGwgfHwgcmVzdWx0cy5wcm9wZXJ0eU5hbWUubGVuZ3RoID09PSAwICkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvciggXCJjYW4gbm90IHBhcnNlIHByb3BlcnR5TmFtZSBmcm9tIHRyYWNrTmFtZTogXCIgKyB0cmFja05hbWUgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0cztcclxuXHJcbn07XHJcblxyXG5USFJFRS5Qcm9wZXJ0eUJpbmRpbmcuZmluZE5vZGUgPSBmdW5jdGlvbiggcm9vdCwgbm9kZU5hbWUgKSB7XHJcblxyXG4gICAgZnVuY3Rpb24gc2VhcmNoU2tlbGV0b24oIHNrZWxldG9uICkge1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBza2VsZXRvbi5ib25lcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYm9uZSA9IHNrZWxldG9uLmJvbmVzW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBib25lLm5hbWUgPT09IG5vZGVOYW1lICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBib25lO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNlYXJjaE5vZGVTdWJ0cmVlKCBjaGlsZHJlbiApIHtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGNoaWxkcmVuW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBjaGlsZE5vZGUubmFtZSA9PT0gbm9kZU5hbWUgfHwgY2hpbGROb2RlLnV1aWQgPT09IG5vZGVOYW1lICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZE5vZGU7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gc2VhcmNoTm9kZVN1YnRyZWUoIGNoaWxkTm9kZS5jaGlsZHJlbiApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCByZXN1bHQgKSByZXR1cm4gcmVzdWx0O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvL1xyXG5cclxuICAgIGlmICggISBub2RlTmFtZSB8fCBub2RlTmFtZSA9PT0gXCJcIiB8fCBub2RlTmFtZSA9PT0gXCJyb290XCIgfHwgbm9kZU5hbWUgPT09IFwiLlwiIHx8IG5vZGVOYW1lID09PSAtMSB8fCBub2RlTmFtZSA9PT0gcm9vdC5uYW1lIHx8IG5vZGVOYW1lID09PSByb290LnV1aWQgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiByb290O1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBzZWFyY2ggaW50byBza2VsZXRvbiBib25lcy5cclxuICAgIGlmICggcm9vdC5za2VsZXRvbiApIHtcclxuXHJcbiAgICAgICAgdmFyIGJvbmUgPSBzZWFyY2hTa2VsZXRvbiggcm9vdC5za2VsZXRvbiApO1xyXG5cclxuICAgICAgICBpZiAoIGJvbmUgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYm9uZTtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHNlYXJjaCBpbnRvIG5vZGUgc3VidHJlZS5cclxuICAgIGlmICggcm9vdC5jaGlsZHJlbiApIHtcclxuXHJcbiAgICAgICAgdmFyIHN1YlRyZWVOb2RlID0gc2VhcmNoTm9kZVN1YnRyZWUoIHJvb3QuY2hpbGRyZW4gKTtcclxuXHJcbiAgICAgICAgaWYgKCBzdWJUcmVlTm9kZSApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzdWJUcmVlTm9kZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuLy8gRmlsZTpzcmMvYW5pbWF0aW9uL3RyYWNrcy9WZWN0b3JLZXlmcmFtZVRyYWNrLmpzXHJcblxyXG4vKipcclxuICpcclxuICogQSBUcmFjayB0aGF0IGludGVycG9sYXRlcyBWZWN0b3JzXHJcbiAqXHJcbiAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXHJcbiAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xyXG4gKi9cclxuXHJcblRIUkVFLlZlY3RvcktleWZyYW1lVHJhY2sgPSBmdW5jdGlvbiAoIG5hbWUsIGtleXMgKSB7XHJcblxyXG4gICAgVEhSRUUuS2V5ZnJhbWVUcmFjay5jYWxsKCB0aGlzLCBuYW1lLCBrZXlzICk7XHJcblxyXG4gICAgLy8gbG9jYWwgY2FjaGUgb2YgdmFsdWUgdHlwZSB0byBhdm9pZCBhbGxvY2F0aW9ucyBkdXJpbmcgcnVudGltZS5cclxuICAgIHRoaXMucmVzdWx0ID0gdGhpcy5rZXlzWzBdLnZhbHVlLmNsb25lKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVmVjdG9yS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuVmVjdG9yS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5WZWN0b3JLZXlmcmFtZVRyYWNrO1xyXG5cclxuVEhSRUUuVmVjdG9yS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuc2V0UmVzdWx0ID0gZnVuY3Rpb24oIHZhbHVlICkge1xyXG5cclxuICAgIHRoaXMucmVzdWx0LmNvcHkoIHZhbHVlICk7XHJcblxyXG59O1xyXG5cclxuLy8gbWVtb2l6YXRpb24gb2YgdGhlIGxlcnAgZnVuY3Rpb24gZm9yIHNwZWVkLlxyXG4vLyBOT1RFOiBEbyBub3Qgb3B0aW1pemUgYXMgYSBwcm90b3R5cGUgaW5pdGlhbGl6YXRpb24gY2xvc3VyZSwgYXMgdmFsdWUwIHdpbGwgYmUgZGlmZmVyZW50IG9uIGEgcGVyIGNsYXNzIGJhc2lzLlxyXG5USFJFRS5WZWN0b3JLZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5sZXJwVmFsdWVzID0gZnVuY3Rpb24oIHZhbHVlMCwgdmFsdWUxLCBhbHBoYSApIHtcclxuXHJcbiAgICByZXR1cm4gdmFsdWUwLmxlcnAoIHZhbHVlMSwgYWxwaGEgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5WZWN0b3JLZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5jb21wYXJlVmFsdWVzID0gZnVuY3Rpb24oIHZhbHVlMCwgdmFsdWUxICkge1xyXG5cclxuICAgIHJldHVybiB2YWx1ZTAuZXF1YWxzKCB2YWx1ZTEgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5WZWN0b3JLZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBjbG9uZWRLZXlzID0gW107XHJcblxyXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5rZXlzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgdmFyIGtleSA9IHRoaXMua2V5c1tpXTtcclxuICAgICAgICBjbG9uZWRLZXlzLnB1c2goIHtcclxuICAgICAgICAgICAgdGltZToga2V5LnRpbWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBrZXkudmFsdWUuY2xvbmUoKVxyXG4gICAgICAgIH0gKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcktleWZyYW1lVHJhY2soIHRoaXMubmFtZSwgY2xvbmVkS2V5cyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlZlY3RvcktleWZyYW1lVHJhY2sucGFyc2UgPSBmdW5jdGlvbigganNvbiApIHtcclxuXHJcbiAgICB2YXIgZWxlbWVudENvdW50ID0ganNvbi5rZXlzWzBdLnZhbHVlLmxlbmd0aDtcclxuICAgIHZhciB2YWx1ZVR5cGUgPSBUSFJFRVsgJ1ZlY3RvcicgKyBlbGVtZW50Q291bnQgXTtcclxuXHJcbiAgICB2YXIga2V5cyA9IFtdO1xyXG5cclxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGpzb24ua2V5cy5sZW5ndGg7IGkgKysgKSB7XHJcbiAgICAgICAgdmFyIGpzb25LZXkgPSBqc29uLmtleXNbaV07XHJcbiAgICAgICAga2V5cy5wdXNoKCB7XHJcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgdmFsdWVUeXBlKCkuZnJvbUFycmF5KCBqc29uS2V5LnZhbHVlICksXHJcbiAgICAgICAgICAgIHRpbWU6IGpzb25LZXkudGltZVxyXG4gICAgICAgIH0gKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcktleWZyYW1lVHJhY2soIGpzb24ubmFtZSwga2V5cyApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2FuaW1hdGlvbi90cmFja3MvUXVhdGVybmlvbktleWZyYW1lVHJhY2suanNcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBBIFRyYWNrIHRoYXQgaW50ZXJwb2xhdGVzIFF1YXRlcm5pb25cclxuICpcclxuICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cclxuICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXHJcbiAqL1xyXG5cclxuVEhSRUUuUXVhdGVybmlvbktleWZyYW1lVHJhY2sgPSBmdW5jdGlvbiAoIG5hbWUsIGtleXMgKSB7XHJcblxyXG4gICAgVEhSRUUuS2V5ZnJhbWVUcmFjay5jYWxsKCB0aGlzLCBuYW1lLCBrZXlzICk7XHJcblxyXG4gICAgLy8gbG9jYWwgY2FjaGUgb2YgdmFsdWUgdHlwZSB0byBhdm9pZCBhbGxvY2F0aW9ucyBkdXJpbmcgcnVudGltZS5cclxuICAgIHRoaXMucmVzdWx0ID0gdGhpcy5rZXlzWzBdLnZhbHVlLmNsb25lKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUXVhdGVybmlvbktleWZyYW1lVHJhY2sucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrO1xyXG5cclxuVEhSRUUuUXVhdGVybmlvbktleWZyYW1lVHJhY2sucHJvdG90eXBlLnNldFJlc3VsdCA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcclxuXHJcbiAgICB0aGlzLnJlc3VsdC5jb3B5KCB2YWx1ZSApO1xyXG5cclxufTtcclxuXHJcbi8vIG1lbW9pemF0aW9uIG9mIHRoZSBsZXJwIGZ1bmN0aW9uIGZvciBzcGVlZC5cclxuLy8gTk9URTogRG8gbm90IG9wdGltaXplIGFzIGEgcHJvdG90eXBlIGluaXRpYWxpemF0aW9uIGNsb3N1cmUsIGFzIHZhbHVlMCB3aWxsIGJlIGRpZmZlcmVudCBvbiBhIHBlciBjbGFzcyBiYXNpcy5cclxuVEhSRUUuUXVhdGVybmlvbktleWZyYW1lVHJhY2sucHJvdG90eXBlLmxlcnBWYWx1ZXMgPSBmdW5jdGlvbiggdmFsdWUwLCB2YWx1ZTEsIGFscGhhICkge1xyXG5cclxuICAgIHJldHVybiB2YWx1ZTAuc2xlcnAoIHZhbHVlMSwgYWxwaGEgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuY29tcGFyZVZhbHVlcyA9IGZ1bmN0aW9uKCB2YWx1ZTAsIHZhbHVlMSApIHtcclxuXHJcbiAgICByZXR1cm4gdmFsdWUwLmVxdWFscyggdmFsdWUxICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUXVhdGVybmlvbktleWZyYW1lVHJhY2sucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24oIHF1YXQgKSB7XHJcblxyXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5rZXlzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgdGhpcy5rZXlzW2ldLnZhbHVlLm11bHRpcGx5KCBxdWF0ICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBjbG9uZWRLZXlzID0gW107XHJcblxyXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5rZXlzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgdmFyIGtleSA9IHRoaXMua2V5c1tpXTtcclxuICAgICAgICBjbG9uZWRLZXlzLnB1c2goIHtcclxuICAgICAgICAgICAgdGltZToga2V5LnRpbWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBrZXkudmFsdWUuY2xvbmUoKVxyXG4gICAgICAgIH0gKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrKCB0aGlzLm5hbWUsIGNsb25lZEtleXMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjay5wYXJzZSA9IGZ1bmN0aW9uKCBqc29uICkge1xyXG5cclxuICAgIHZhciBrZXlzID0gW107XHJcblxyXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwganNvbi5rZXlzLmxlbmd0aDsgaSArKyApIHtcclxuICAgICAgICB2YXIganNvbktleSA9IGpzb24ua2V5c1tpXTtcclxuICAgICAgICBrZXlzLnB1c2goIHtcclxuICAgICAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCkuZnJvbUFycmF5KCBqc29uS2V5LnZhbHVlICksXHJcbiAgICAgICAgICAgIHRpbWU6IGpzb25LZXkudGltZVxyXG4gICAgICAgIH0gKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrKCBqc29uLm5hbWUsIGtleXMgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9hbmltYXRpb24vdHJhY2tzL1N0cmluZ0tleWZyYW1lVHJhY2suanNcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBBIFRyYWNrIHRoYXQgaW50ZXJwb2xhdGVzIFN0cmluZ3NcclxuICpcclxuICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cclxuICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXHJcbiAqL1xyXG5cclxuVEhSRUUuU3RyaW5nS2V5ZnJhbWVUcmFjayA9IGZ1bmN0aW9uICggbmFtZSwga2V5cyApIHtcclxuXHJcbiAgICBUSFJFRS5LZXlmcmFtZVRyYWNrLmNhbGwoIHRoaXMsIG5hbWUsIGtleXMgKTtcclxuXHJcbiAgICAvLyBsb2NhbCBjYWNoZSBvZiB2YWx1ZSB0eXBlIHRvIGF2b2lkIGFsbG9jYXRpb25zIGR1cmluZyBydW50aW1lLlxyXG4gICAgdGhpcy5yZXN1bHQgPSB0aGlzLmtleXNbMF0udmFsdWU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU3RyaW5nS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuU3RyaW5nS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TdHJpbmdLZXlmcmFtZVRyYWNrO1xyXG5cclxuVEhSRUUuU3RyaW5nS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuc2V0UmVzdWx0ID0gZnVuY3Rpb24oIHZhbHVlICkge1xyXG5cclxuICAgIHRoaXMucmVzdWx0ID0gdmFsdWU7XHJcblxyXG59O1xyXG5cclxuLy8gbWVtb2l6YXRpb24gb2YgdGhlIGxlcnAgZnVuY3Rpb24gZm9yIHNwZWVkLlxyXG4vLyBOT1RFOiBEbyBub3Qgb3B0aW1pemUgYXMgYSBwcm90b3R5cGUgaW5pdGlhbGl6YXRpb24gY2xvc3VyZSwgYXMgdmFsdWUwIHdpbGwgYmUgZGlmZmVyZW50IG9uIGEgcGVyIGNsYXNzIGJhc2lzLlxyXG5USFJFRS5TdHJpbmdLZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5sZXJwVmFsdWVzID0gZnVuY3Rpb24oIHZhbHVlMCwgdmFsdWUxLCBhbHBoYSApIHtcclxuXHJcbiAgICByZXR1cm4gKCBhbHBoYSA8IDEuMCApID8gdmFsdWUwIDogdmFsdWUxO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlN0cmluZ0tleWZyYW1lVHJhY2sucHJvdG90eXBlLmNvbXBhcmVWYWx1ZXMgPSBmdW5jdGlvbiggdmFsdWUwLCB2YWx1ZTEgKSB7XHJcblxyXG4gICAgcmV0dXJuICggdmFsdWUwID09PSB2YWx1ZTEgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TdHJpbmdLZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBjbG9uZWRLZXlzID0gW107XHJcblxyXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5rZXlzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgdmFyIGtleSA9IHRoaXMua2V5c1tpXTtcclxuICAgICAgICBjbG9uZWRLZXlzLnB1c2goIHtcclxuICAgICAgICAgICAgdGltZToga2V5LnRpbWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBrZXkudmFsdWVcclxuICAgICAgICB9ICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5TdHJpbmdLZXlmcmFtZVRyYWNrKCB0aGlzLm5hbWUsIGNsb25lZEtleXMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TdHJpbmdLZXlmcmFtZVRyYWNrLnBhcnNlID0gZnVuY3Rpb24oIGpzb24gKSB7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5TdHJpbmdLZXlmcmFtZVRyYWNrKCBqc29uLm5hbWUsIGpzb24ua2V5cyApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2FuaW1hdGlvbi90cmFja3MvQm9vbGVhbktleWZyYW1lVHJhY2suanNcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBBIFRyYWNrIHRoYXQgaW50ZXJwb2xhdGVzIEJvb2xlYW5cclxuICpcclxuICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cclxuICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXHJcbiAqL1xyXG5cclxuVEhSRUUuQm9vbGVhbktleWZyYW1lVHJhY2sgPSBmdW5jdGlvbiAoIG5hbWUsIGtleXMgKSB7XHJcblxyXG4gICAgVEhSRUUuS2V5ZnJhbWVUcmFjay5jYWxsKCB0aGlzLCBuYW1lLCBrZXlzICk7XHJcblxyXG4gICAgLy8gbG9jYWwgY2FjaGUgb2YgdmFsdWUgdHlwZSB0byBhdm9pZCBhbGxvY2F0aW9ucyBkdXJpbmcgcnVudGltZS5cclxuICAgIHRoaXMucmVzdWx0ID0gdGhpcy5rZXlzWzBdLnZhbHVlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkJvb2xlYW5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLktleWZyYW1lVHJhY2sucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5Cb29sZWFuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Cb29sZWFuS2V5ZnJhbWVUcmFjaztcclxuXHJcblRIUkVFLkJvb2xlYW5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5zZXRSZXN1bHQgPSBmdW5jdGlvbiggdmFsdWUgKSB7XHJcblxyXG4gICAgdGhpcy5yZXN1bHQgPSB2YWx1ZTtcclxuXHJcbn07XHJcblxyXG4vLyBtZW1vaXphdGlvbiBvZiB0aGUgbGVycCBmdW5jdGlvbiBmb3Igc3BlZWQuXHJcbi8vIE5PVEU6IERvIG5vdCBvcHRpbWl6ZSBhcyBhIHByb3RvdHlwZSBpbml0aWFsaXphdGlvbiBjbG9zdXJlLCBhcyB2YWx1ZTAgd2lsbCBiZSBkaWZmZXJlbnQgb24gYSBwZXIgY2xhc3MgYmFzaXMuXHJcblRIUkVFLkJvb2xlYW5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5sZXJwVmFsdWVzID0gZnVuY3Rpb24oIHZhbHVlMCwgdmFsdWUxLCBhbHBoYSApIHtcclxuXHJcbiAgICByZXR1cm4gKCBhbHBoYSA8IDEuMCApID8gdmFsdWUwIDogdmFsdWUxO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkJvb2xlYW5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5jb21wYXJlVmFsdWVzID0gZnVuY3Rpb24oIHZhbHVlMCwgdmFsdWUxICkge1xyXG5cclxuICAgIHJldHVybiAoIHZhbHVlMCA9PT0gdmFsdWUxICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQm9vbGVhbktleWZyYW1lVHJhY2sucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgdmFyIGNsb25lZEtleXMgPSBbXTtcclxuXHJcbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmtleXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuICAgICAgICB2YXIga2V5ID0gdGhpcy5rZXlzW2ldO1xyXG4gICAgICAgIGNsb25lZEtleXMucHVzaCgge1xyXG4gICAgICAgICAgICB0aW1lOiBrZXkudGltZSxcclxuICAgICAgICAgICAgdmFsdWU6IGtleS52YWx1ZVxyXG4gICAgICAgIH0gKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLkJvb2xlYW5LZXlmcmFtZVRyYWNrKCB0aGlzLm5hbWUsIGNsb25lZEtleXMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Cb29sZWFuS2V5ZnJhbWVUcmFjay5wYXJzZSA9IGZ1bmN0aW9uKCBqc29uICkge1xyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuQm9vbGVhbktleWZyYW1lVHJhY2soIGpzb24ubmFtZSwganNvbi5rZXlzICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvYW5pbWF0aW9uL3RyYWNrcy9OdW1iZXJLZXlmcmFtZVRyYWNrLmpzXHJcblxyXG4vKipcclxuICpcclxuICogQSBUcmFjayB0aGF0IGludGVycG9sYXRlcyBOdW1iZXJzXHJcbiAqXHJcbiAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXHJcbiAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xyXG4gKi9cclxuXHJcblRIUkVFLk51bWJlcktleWZyYW1lVHJhY2sgPSBmdW5jdGlvbiAoIG5hbWUsIGtleXMgKSB7XHJcblxyXG4gICAgVEhSRUUuS2V5ZnJhbWVUcmFjay5jYWxsKCB0aGlzLCBuYW1lLCBrZXlzICk7XHJcblxyXG4gICAgLy8gbG9jYWwgY2FjaGUgb2YgdmFsdWUgdHlwZSB0byBhdm9pZCBhbGxvY2F0aW9ucyBkdXJpbmcgcnVudGltZS5cclxuICAgIHRoaXMucmVzdWx0ID0gdGhpcy5rZXlzWzBdLnZhbHVlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk51bWJlcktleWZyYW1lVHJhY2sucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLk51bWJlcktleWZyYW1lVHJhY2sucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTnVtYmVyS2V5ZnJhbWVUcmFjaztcclxuXHJcblRIUkVFLk51bWJlcktleWZyYW1lVHJhY2sucHJvdG90eXBlLnNldFJlc3VsdCA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcclxuXHJcbiAgICB0aGlzLnJlc3VsdCA9IHZhbHVlO1xyXG5cclxufTtcclxuXHJcbi8vIG1lbW9pemF0aW9uIG9mIHRoZSBsZXJwIGZ1bmN0aW9uIGZvciBzcGVlZC5cclxuLy8gTk9URTogRG8gbm90IG9wdGltaXplIGFzIGEgcHJvdG90eXBlIGluaXRpYWxpemF0aW9uIGNsb3N1cmUsIGFzIHZhbHVlMCB3aWxsIGJlIGRpZmZlcmVudCBvbiBhIHBlciBjbGFzcyBiYXNpcy5cclxuVEhSRUUuTnVtYmVyS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUubGVycFZhbHVlcyA9IGZ1bmN0aW9uKCB2YWx1ZTAsIHZhbHVlMSwgYWxwaGEgKSB7XHJcblxyXG4gICAgcmV0dXJuIHZhbHVlMCAqICggMSAtIGFscGhhICkgKyB2YWx1ZTEgKiBhbHBoYTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5OdW1iZXJLZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5jb21wYXJlVmFsdWVzID0gZnVuY3Rpb24oIHZhbHVlMCwgdmFsdWUxICkge1xyXG5cclxuICAgIHJldHVybiAoIHZhbHVlMCA9PT0gdmFsdWUxICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTnVtYmVyS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgY2xvbmVkS2V5cyA9IFtdO1xyXG5cclxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMua2V5cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIHZhciBrZXkgPSB0aGlzLmtleXNbaV07XHJcbiAgICAgICAgY2xvbmVkS2V5cy5wdXNoKCB7XHJcbiAgICAgICAgICAgIHRpbWU6IGtleS50aW1lLFxyXG4gICAgICAgICAgICB2YWx1ZToga2V5LnZhbHVlXHJcbiAgICAgICAgfSApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuTnVtYmVyS2V5ZnJhbWVUcmFjayggdGhpcy5uYW1lLCBjbG9uZWRLZXlzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTnVtYmVyS2V5ZnJhbWVUcmFjay5wYXJzZSA9IGZ1bmN0aW9uKCBqc29uICkge1xyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuTnVtYmVyS2V5ZnJhbWVUcmFjaygganNvbi5uYW1lLCBqc29uLmtleXMgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9jYW1lcmFzL0NhbWVyYS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKi9cclxuXHJcblRIUkVFLkNhbWVyYSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ0NhbWVyYSc7XHJcblxyXG4gICAgdGhpcy5tYXRyaXhXb3JsZEludmVyc2UgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG4gICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblRIUkVFLkNhbWVyYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DYW1lcmE7XHJcblxyXG5USFJFRS5DYW1lcmEucHJvdG90eXBlLmdldFdvcmxkRGlyZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgIHRoaXMuZ2V0V29ybGRRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQuc2V0KCAwLCAwLCAtIDEgKS5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcclxuXHJcbiAgICB9O1xyXG5cclxufSgpO1xyXG5cclxuVEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5sb29rQXQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgLy8gVGhpcyByb3V0aW5lIGRvZXMgbm90IHN1cHBvcnQgY2FtZXJhcyB3aXRoIHJvdGF0ZWQgYW5kL29yIHRyYW5zbGF0ZWQgcGFyZW50KHMpXHJcblxyXG4gICAgdmFyIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG4gICAgICAgIG0xLmxvb2tBdCggdGhpcy5wb3NpdGlvbiwgdmVjdG9yLCB0aGlzLnVwICk7XHJcblxyXG4gICAgICAgIHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG0xICk7XHJcblxyXG4gICAgfTtcclxuXHJcbn0oKTtcclxuXHJcblRIUkVFLkNhbWVyYS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkNhbWVyYS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuICAgIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuICAgIHRoaXMubWF0cml4V29ybGRJbnZlcnNlLmNvcHkoIHNvdXJjZS5tYXRyaXhXb3JsZEludmVyc2UgKTtcclxuICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeC5jb3B5KCBzb3VyY2UucHJvamVjdGlvbk1hdHJpeCApO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2NhbWVyYXMvQ3ViZUNhbWVyYS5qc1xyXG5cclxuLyoqXHJcbiAqIENhbWVyYSBmb3IgcmVuZGVyaW5nIGN1YmUgbWFwc1xyXG4gKlx0LSByZW5kZXJzIHNjZW5lIGludG8gYXhpcy1hbGlnbmVkIGN1YmVcclxuICpcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5DdWJlQ2FtZXJhID0gZnVuY3Rpb24gKCBuZWFyLCBmYXIsIGN1YmVSZXNvbHV0aW9uICkge1xyXG5cclxuICAgIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnQ3ViZUNhbWVyYSc7XHJcblxyXG4gICAgdmFyIGZvdiA9IDkwLCBhc3BlY3QgPSAxO1xyXG5cclxuICAgIHZhciBjYW1lcmFQWCA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xyXG4gICAgY2FtZXJhUFgudXAuc2V0KCAwLCAtIDEsIDAgKTtcclxuICAgIGNhbWVyYVBYLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDAsIDAgKSApO1xyXG4gICAgdGhpcy5hZGQoIGNhbWVyYVBYICk7XHJcblxyXG4gICAgdmFyIGNhbWVyYU5YID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XHJcbiAgICBjYW1lcmFOWC51cC5zZXQoIDAsIC0gMSwgMCApO1xyXG4gICAgY2FtZXJhTlgubG9va0F0KCBuZXcgVEhSRUUuVmVjdG9yMyggLSAxLCAwLCAwICkgKTtcclxuICAgIHRoaXMuYWRkKCBjYW1lcmFOWCApO1xyXG5cclxuICAgIHZhciBjYW1lcmFQWSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xyXG4gICAgY2FtZXJhUFkudXAuc2V0KCAwLCAwLCAxICk7XHJcbiAgICBjYW1lcmFQWS5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICkgKTtcclxuICAgIHRoaXMuYWRkKCBjYW1lcmFQWSApO1xyXG5cclxuICAgIHZhciBjYW1lcmFOWSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xyXG4gICAgY2FtZXJhTlkudXAuc2V0KCAwLCAwLCAtIDEgKTtcclxuICAgIGNhbWVyYU5ZLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0gMSwgMCApICk7XHJcbiAgICB0aGlzLmFkZCggY2FtZXJhTlkgKTtcclxuXHJcbiAgICB2YXIgY2FtZXJhUFogPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcclxuICAgIGNhbWVyYVBaLnVwLnNldCggMCwgLSAxLCAwICk7XHJcbiAgICBjYW1lcmFQWi5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICkgKTtcclxuICAgIHRoaXMuYWRkKCBjYW1lcmFQWiApO1xyXG5cclxuICAgIHZhciBjYW1lcmFOWiA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xyXG4gICAgY2FtZXJhTloudXAuc2V0KCAwLCAtIDEsIDAgKTtcclxuICAgIGNhbWVyYU5aLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIC0gMSApICk7XHJcbiAgICB0aGlzLmFkZCggY2FtZXJhTlogKTtcclxuXHJcbiAgICB0aGlzLnJlbmRlclRhcmdldCA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUoIGN1YmVSZXNvbHV0aW9uLCBjdWJlUmVzb2x1dGlvbiwgeyBmb3JtYXQ6IFRIUkVFLlJHQkZvcm1hdCwgbWFnRmlsdGVyOiBUSFJFRS5MaW5lYXJGaWx0ZXIsIG1pbkZpbHRlcjogVEhSRUUuTGluZWFyRmlsdGVyIH0gKTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZUN1YmVNYXAgPSBmdW5jdGlvbiAoIHJlbmRlcmVyLCBzY2VuZSApIHtcclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLnBhcmVudCA9PT0gbnVsbCApIHRoaXMudXBkYXRlTWF0cml4V29ybGQoKTtcclxuXHJcbiAgICAgICAgdmFyIHJlbmRlclRhcmdldCA9IHRoaXMucmVuZGVyVGFyZ2V0O1xyXG4gICAgICAgIHZhciBnZW5lcmF0ZU1pcG1hcHMgPSByZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHM7XHJcblxyXG4gICAgICAgIHJlbmRlclRhcmdldC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xyXG5cclxuICAgICAgICByZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSAwO1xyXG4gICAgICAgIHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYVBYLCByZW5kZXJUYXJnZXQgKTtcclxuXHJcbiAgICAgICAgcmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMTtcclxuICAgICAgICByZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFOWCwgcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG4gICAgICAgIHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDI7XHJcbiAgICAgICAgcmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhUFksIHJlbmRlclRhcmdldCApO1xyXG5cclxuICAgICAgICByZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSAzO1xyXG4gICAgICAgIHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYU5ZLCByZW5kZXJUYXJnZXQgKTtcclxuXHJcbiAgICAgICAgcmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gNDtcclxuICAgICAgICByZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFQWiwgcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG4gICAgICAgIHJlbmRlclRhcmdldC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGdlbmVyYXRlTWlwbWFwcztcclxuXHJcbiAgICAgICAgcmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gNTtcclxuICAgICAgICByZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFOWiwgcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG4gICAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggbnVsbCApO1xyXG5cclxuICAgIH07XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ3ViZUNhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuQ3ViZUNhbWVyYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DdWJlQ2FtZXJhO1xyXG5cclxuLy8gRmlsZTpzcmMvY2FtZXJhcy9PcnRob2dyYXBoaWNDYW1lcmEuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSA9IGZ1bmN0aW9uICggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIgKSB7XHJcblxyXG4gICAgVEhSRUUuQ2FtZXJhLmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnT3J0aG9ncmFwaGljQ2FtZXJhJztcclxuXHJcbiAgICB0aGlzLnpvb20gPSAxO1xyXG5cclxuICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcbiAgICB0aGlzLnRvcCA9IHRvcDtcclxuICAgIHRoaXMuYm90dG9tID0gYm90dG9tO1xyXG5cclxuICAgIHRoaXMubmVhciA9ICggbmVhciAhPT0gdW5kZWZpbmVkICkgPyBuZWFyIDogMC4xO1xyXG4gICAgdGhpcy5mYXIgPSAoIGZhciAhPT0gdW5kZWZpbmVkICkgPyBmYXIgOiAyMDAwO1xyXG5cclxuICAgIHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DYW1lcmEucHJvdG90eXBlICk7XHJcblRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmE7XHJcblxyXG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlLnVwZGF0ZVByb2plY3Rpb25NYXRyaXggPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIGR4ID0gKCB0aGlzLnJpZ2h0IC0gdGhpcy5sZWZ0ICkgLyAoIDIgKiB0aGlzLnpvb20gKTtcclxuICAgIHZhciBkeSA9ICggdGhpcy50b3AgLSB0aGlzLmJvdHRvbSApIC8gKCAyICogdGhpcy56b29tICk7XHJcbiAgICB2YXIgY3ggPSAoIHRoaXMucmlnaHQgKyB0aGlzLmxlZnQgKSAvIDI7XHJcbiAgICB2YXIgY3kgPSAoIHRoaXMudG9wICsgdGhpcy5ib3R0b20gKSAvIDI7XHJcblxyXG4gICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VPcnRob2dyYXBoaWMoIGN4IC0gZHgsIGN4ICsgZHgsIGN5ICsgZHksIGN5IC0gZHksIHRoaXMubmVhciwgdGhpcy5mYXIgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcbiAgICBUSFJFRS5DYW1lcmEucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG4gICAgdGhpcy5sZWZ0ID0gc291cmNlLmxlZnQ7XHJcbiAgICB0aGlzLnJpZ2h0ID0gc291cmNlLnJpZ2h0O1xyXG4gICAgdGhpcy50b3AgPSBzb3VyY2UudG9wO1xyXG4gICAgdGhpcy5ib3R0b20gPSBzb3VyY2UuYm90dG9tO1xyXG4gICAgdGhpcy5uZWFyID0gc291cmNlLm5lYXI7XHJcbiAgICB0aGlzLmZhciA9IHNvdXJjZS5mYXI7XHJcblxyXG4gICAgdGhpcy56b29tID0gc291cmNlLnpvb207XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoIG1ldGEgKSB7XHJcblxyXG4gICAgdmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcclxuXHJcbiAgICBkYXRhLm9iamVjdC56b29tID0gdGhpcy56b29tO1xyXG4gICAgZGF0YS5vYmplY3QubGVmdCA9IHRoaXMubGVmdDtcclxuICAgIGRhdGEub2JqZWN0LnJpZ2h0ID0gdGhpcy5yaWdodDtcclxuICAgIGRhdGEub2JqZWN0LnRvcCA9IHRoaXMudG9wO1xyXG4gICAgZGF0YS5vYmplY3QuYm90dG9tID0gdGhpcy5ib3R0b207XHJcbiAgICBkYXRhLm9iamVjdC5uZWFyID0gdGhpcy5uZWFyO1xyXG4gICAgZGF0YS5vYmplY3QuZmFyID0gdGhpcy5mYXI7XHJcblxyXG4gICAgcmV0dXJuIGRhdGE7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvY2FtZXJhcy9QZXJzcGVjdGl2ZUNhbWVyYS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgZ3JlZ2dtYW4gLyBodHRwOi8vZ2FtZXMuZ3JlZ2dtYW4uY29tL1xyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqL1xyXG5cclxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEgPSBmdW5jdGlvbiAoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKSB7XHJcblxyXG4gICAgVEhSRUUuQ2FtZXJhLmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnUGVyc3BlY3RpdmVDYW1lcmEnO1xyXG5cclxuICAgIHRoaXMuem9vbSA9IDE7XHJcblxyXG4gICAgdGhpcy5mb3YgPSBmb3YgIT09IHVuZGVmaW5lZCA/IGZvdiA6IDUwO1xyXG4gICAgdGhpcy5hc3BlY3QgPSBhc3BlY3QgIT09IHVuZGVmaW5lZCA/IGFzcGVjdCA6IDE7XHJcbiAgICB0aGlzLm5lYXIgPSBuZWFyICE9PSB1bmRlZmluZWQgPyBuZWFyIDogMC4xO1xyXG4gICAgdGhpcy5mYXIgPSBmYXIgIT09IHVuZGVmaW5lZCA/IGZhciA6IDIwMDA7XHJcblxyXG4gICAgdGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ2FtZXJhLnByb3RvdHlwZSApO1xyXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYTtcclxuXHJcblxyXG4vKipcclxuICogVXNlcyBGb2NhbCBMZW5ndGggKGluIG1tKSB0byBlc3RpbWF0ZSBhbmQgc2V0IEZPVlxyXG4gKiAzNW1tIChmdWxsLWZyYW1lKSBjYW1lcmEgaXMgdXNlZCBpZiBmcmFtZSBzaXplIGlzIG5vdCBzcGVjaWZpZWQ7XHJcbiAqIEZvcm11bGEgYmFzZWQgb24gaHR0cDovL3d3dy5ib2JhdGtpbnMuY29tL3Bob3RvZ3JhcGh5L3RlY2huaWNhbC9maWVsZF9vZl92aWV3Lmh0bWxcclxuICovXHJcblxyXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuc2V0TGVucyA9IGZ1bmN0aW9uICggZm9jYWxMZW5ndGgsIGZyYW1lSGVpZ2h0ICkge1xyXG5cclxuICAgIGlmICggZnJhbWVIZWlnaHQgPT09IHVuZGVmaW5lZCApIGZyYW1lSGVpZ2h0ID0gMjQ7XHJcblxyXG4gICAgdGhpcy5mb3YgPSAyICogVEhSRUUuTWF0aC5yYWRUb0RlZyggTWF0aC5hdGFuKCBmcmFtZUhlaWdodCAvICggZm9jYWxMZW5ndGggKiAyICkgKSApO1xyXG4gICAgdGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcblxyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBTZXRzIGFuIG9mZnNldCBpbiBhIGxhcmdlciBmcnVzdHVtLiBUaGlzIGlzIHVzZWZ1bCBmb3IgbXVsdGktd2luZG93IG9yXHJcbiAqIG11bHRpLW1vbml0b3IvbXVsdGktbWFjaGluZSBzZXR1cHMuXHJcbiAqXHJcbiAqIEZvciBleGFtcGxlLCBpZiB5b3UgaGF2ZSAzeDIgbW9uaXRvcnMgYW5kIGVhY2ggbW9uaXRvciBpcyAxOTIweDEwODAgYW5kXHJcbiAqIHRoZSBtb25pdG9ycyBhcmUgaW4gZ3JpZCBsaWtlIHRoaXNcclxuICpcclxuICogICArLS0tKy0tLSstLS0rXHJcbiAqICAgfCBBIHwgQiB8IEMgfFxyXG4gKiAgICstLS0rLS0tKy0tLStcclxuICogICB8IEQgfCBFIHwgRiB8XHJcbiAqICAgKy0tLSstLS0rLS0tK1xyXG4gKlxyXG4gKiB0aGVuIGZvciBlYWNoIG1vbml0b3IgeW91IHdvdWxkIGNhbGwgaXQgbGlrZSB0aGlzXHJcbiAqXHJcbiAqICAgdmFyIHcgPSAxOTIwO1xyXG4gKiAgIHZhciBoID0gMTA4MDtcclxuICogICB2YXIgZnVsbFdpZHRoID0gdyAqIDM7XHJcbiAqICAgdmFyIGZ1bGxIZWlnaHQgPSBoICogMjtcclxuICpcclxuICogICAtLUEtLVxyXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDAsIGggKiAwLCB3LCBoICk7XHJcbiAqICAgLS1CLS1cclxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAxLCBoICogMCwgdywgaCApO1xyXG4gKiAgIC0tQy0tXHJcbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMiwgaCAqIDAsIHcsIGggKTtcclxuICogICAtLUQtLVxyXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDAsIGggKiAxLCB3LCBoICk7XHJcbiAqICAgLS1FLS1cclxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAxLCBoICogMSwgdywgaCApO1xyXG4gKiAgIC0tRi0tXHJcbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMiwgaCAqIDEsIHcsIGggKTtcclxuICpcclxuICogICBOb3RlIHRoZXJlIGlzIG5vIHJlYXNvbiBtb25pdG9ycyBoYXZlIHRvIGJlIHRoZSBzYW1lIHNpemUgb3IgaW4gYSBncmlkLlxyXG4gKi9cclxuXHJcblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS5zZXRWaWV3T2Zmc2V0ID0gZnVuY3Rpb24gKCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XHJcblxyXG4gICAgdGhpcy5mdWxsV2lkdGggPSBmdWxsV2lkdGg7XHJcbiAgICB0aGlzLmZ1bGxIZWlnaHQgPSBmdWxsSGVpZ2h0O1xyXG4gICAgdGhpcy54ID0geDtcclxuICAgIHRoaXMueSA9IHk7XHJcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcclxuXHJcbn07XHJcblxyXG5cclxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLnVwZGF0ZVByb2plY3Rpb25NYXRyaXggPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIGZvdiA9IFRIUkVFLk1hdGgucmFkVG9EZWcoIDIgKiBNYXRoLmF0YW4oIE1hdGgudGFuKCBUSFJFRS5NYXRoLmRlZ1RvUmFkKCB0aGlzLmZvdiApICogMC41ICkgLyB0aGlzLnpvb20gKSApO1xyXG5cclxuICAgIGlmICggdGhpcy5mdWxsV2lkdGggKSB7XHJcblxyXG4gICAgICAgIHZhciBhc3BlY3QgPSB0aGlzLmZ1bGxXaWR0aCAvIHRoaXMuZnVsbEhlaWdodDtcclxuICAgICAgICB2YXIgdG9wID0gTWF0aC50YW4oIFRIUkVFLk1hdGguZGVnVG9SYWQoIGZvdiAqIDAuNSApICkgKiB0aGlzLm5lYXI7XHJcbiAgICAgICAgdmFyIGJvdHRvbSA9IC0gdG9wO1xyXG4gICAgICAgIHZhciBsZWZ0ID0gYXNwZWN0ICogYm90dG9tO1xyXG4gICAgICAgIHZhciByaWdodCA9IGFzcGVjdCAqIHRvcDtcclxuICAgICAgICB2YXIgd2lkdGggPSBNYXRoLmFicyggcmlnaHQgLSBsZWZ0ICk7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IE1hdGguYWJzKCB0b3AgLSBib3R0b20gKTtcclxuXHJcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VGcnVzdHVtKFxyXG4gICAgICAgICAgICBsZWZ0ICsgdGhpcy54ICogd2lkdGggLyB0aGlzLmZ1bGxXaWR0aCxcclxuICAgICAgICAgICAgbGVmdCArICggdGhpcy54ICsgdGhpcy53aWR0aCApICogd2lkdGggLyB0aGlzLmZ1bGxXaWR0aCxcclxuICAgICAgICAgICAgdG9wIC0gKCB0aGlzLnkgKyB0aGlzLmhlaWdodCApICogaGVpZ2h0IC8gdGhpcy5mdWxsSGVpZ2h0LFxyXG4gICAgICAgICAgICB0b3AgLSB0aGlzLnkgKiBoZWlnaHQgLyB0aGlzLmZ1bGxIZWlnaHQsXHJcbiAgICAgICAgICAgIHRoaXMubmVhcixcclxuICAgICAgICAgICAgdGhpcy5mYXJcclxuICAgICAgICApO1xyXG5cclxuICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlUGVyc3BlY3RpdmUoIGZvdiwgdGhpcy5hc3BlY3QsIHRoaXMubmVhciwgdGhpcy5mYXIgKTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcbiAgICBUSFJFRS5DYW1lcmEucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG4gICAgdGhpcy5mb3YgPSBzb3VyY2UuZm92O1xyXG4gICAgdGhpcy5hc3BlY3QgPSBzb3VyY2UuYXNwZWN0O1xyXG4gICAgdGhpcy5uZWFyID0gc291cmNlLm5lYXI7XHJcbiAgICB0aGlzLmZhciA9IHNvdXJjZS5mYXI7XHJcblxyXG4gICAgdGhpcy56b29tID0gc291cmNlLnpvb207XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcclxuXHJcbiAgICB2YXIgZGF0YSA9IFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xyXG5cclxuICAgIGRhdGEub2JqZWN0Lnpvb20gPSB0aGlzLnpvb207XHJcbiAgICBkYXRhLm9iamVjdC5mb3YgPSB0aGlzLmZvdjtcclxuICAgIGRhdGEub2JqZWN0LmFzcGVjdCA9IHRoaXMuYXNwZWN0O1xyXG4gICAgZGF0YS5vYmplY3QubmVhciA9IHRoaXMubmVhcjtcclxuICAgIGRhdGEub2JqZWN0LmZhciA9IHRoaXMuZmFyO1xyXG5cclxuICAgIHJldHVybiBkYXRhO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2xpZ2h0cy9MaWdodC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTGlnaHQgPSBmdW5jdGlvbiAoIGNvbG9yICkge1xyXG5cclxuICAgIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnTGlnaHQnO1xyXG5cclxuICAgIHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yICk7XHJcblxyXG4gICAgdGhpcy5yZWNlaXZlU2hhZG93ID0gdW5kZWZpbmVkO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5USFJFRS5MaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MaWdodDtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBUSFJFRS5MaWdodC5wcm90b3R5cGUsIHtcclxuICAgIG9ubHlTaGFkb3c6IHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAub25seVNoYWRvdyBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgc2hhZG93Q2FtZXJhRm92OiB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG4gICAgICAgICAgICB0aGlzLnNoYWRvdy5jYW1lcmEuZm92ID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHNoYWRvd0NhbWVyYUxlZnQ6IHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhZG93LmNhbWVyYS5sZWZ0ID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHNoYWRvd0NhbWVyYVJpZ2h0OiB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG4gICAgICAgICAgICB0aGlzLnNoYWRvdy5jYW1lcmEucmlnaHQgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgc2hhZG93Q2FtZXJhVG9wOiB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG4gICAgICAgICAgICB0aGlzLnNoYWRvdy5jYW1lcmEudG9wID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHNoYWRvd0NhbWVyYUJvdHRvbToge1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuICAgICAgICAgICAgdGhpcy5zaGFkb3cuY2FtZXJhLmJvdHRvbSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBzaGFkb3dDYW1lcmFOZWFyOiB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG4gICAgICAgICAgICB0aGlzLnNoYWRvdy5jYW1lcmEubmVhciA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBzaGFkb3dDYW1lcmFGYXI6IHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhZG93LmNhbWVyYS5mYXIgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgc2hhZG93Q2FtZXJhVmlzaWJsZToge1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dDYW1lcmFWaXNpYmxlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuQ2FtZXJhSGVscGVyKCBsaWdodC5zaGFkb3cgKSBpbnN0ZWFkLicgKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgc2hhZG93Qmlhczoge1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuICAgICAgICAgICAgdGhpcy5zaGFkb3cuYmlhcyA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBzaGFkb3dEYXJrbmVzczoge1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuICAgICAgICAgICAgdGhpcy5zaGFkb3cuZGFya25lc3MgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgc2hhZG93TWFwV2lkdGg6IHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhZG93Lm1hcFNpemUud2lkdGggPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgc2hhZG93TWFwSGVpZ2h0OiB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG4gICAgICAgICAgICB0aGlzLnNoYWRvdy5tYXBTaXplLmhlaWdodCA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSApO1xyXG5cclxuVEhSRUUuTGlnaHQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcbiAgICBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcbiAgICB0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxpZ2h0LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoIG1ldGEgKSB7XHJcblxyXG4gICAgdmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcclxuXHJcbiAgICBkYXRhLm9iamVjdC5jb2xvciA9IHRoaXMuY29sb3IuZ2V0SGV4KCk7XHJcbiAgICBpZiAoIHRoaXMuZ3JvdW5kQ29sb3IgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0Lmdyb3VuZENvbG9yID0gdGhpcy5ncm91bmRDb2xvci5nZXRIZXgoKTtcclxuXHJcbiAgICBpZiAoIHRoaXMuaW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5pbnRlbnNpdHkgPSB0aGlzLmludGVuc2l0eTtcclxuICAgIGlmICggdGhpcy5kaXN0YW5jZSAhPT0gdW5kZWZpbmVkICkgZGF0YS5vYmplY3QuZGlzdGFuY2UgPSB0aGlzLmRpc3RhbmNlO1xyXG4gICAgaWYgKCB0aGlzLmFuZ2xlICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5hbmdsZSA9IHRoaXMuYW5nbGU7XHJcbiAgICBpZiAoIHRoaXMuZGVjYXkgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LmRlY2F5ID0gdGhpcy5kZWNheTtcclxuICAgIGlmICggdGhpcy5leHBvbmVudCAhPT0gdW5kZWZpbmVkICkgZGF0YS5vYmplY3QuZXhwb25lbnQgPSB0aGlzLmV4cG9uZW50O1xyXG5cclxuICAgIHJldHVybiBkYXRhO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2xpZ2h0cy9MaWdodFNoYWRvdy5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTGlnaHRTaGFkb3cgPSBmdW5jdGlvbiAoIGNhbWVyYSApIHtcclxuXHJcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcclxuXHJcbiAgICB0aGlzLmJpYXMgPSAwO1xyXG4gICAgdGhpcy5kYXJrbmVzcyA9IDE7XHJcblxyXG4gICAgdGhpcy5tYXBTaXplID0gbmV3IFRIUkVFLlZlY3RvcjIoIDUxMiwgNTEyICk7XHJcblxyXG4gICAgdGhpcy5tYXAgPSBudWxsO1xyXG4gICAgdGhpcy5tYXRyaXggPSBudWxsO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxpZ2h0U2hhZG93LnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuTGlnaHRTaGFkb3csXHJcblxyXG4gICAgY29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY2FtZXJhID0gc291cmNlLmNhbWVyYS5jbG9uZSgpO1xyXG5cclxuICAgICAgICB0aGlzLmJpYXMgPSBzb3VyY2UuYmlhcztcclxuICAgICAgICB0aGlzLmRhcmtuZXNzID0gc291cmNlLmRhcmtuZXNzO1xyXG5cclxuICAgICAgICB0aGlzLm1hcFNpemUuY29weSggc291cmNlLm1hcFNpemUgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbGlnaHRzL0FtYmllbnRMaWdodC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQW1iaWVudExpZ2h0ID0gZnVuY3Rpb24gKCBjb2xvciApIHtcclxuXHJcbiAgICBUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBjb2xvciApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdBbWJpZW50TGlnaHQnO1xyXG5cclxuICAgIHRoaXMuY2FzdFNoYWRvdyA9IHVuZGVmaW5lZDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BbWJpZW50TGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGlnaHQucHJvdG90eXBlICk7XHJcblRIUkVFLkFtYmllbnRMaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5BbWJpZW50TGlnaHQ7XHJcblxyXG4vLyBGaWxlOnNyYy9saWdodHMvRGlyZWN0aW9uYWxMaWdodC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodCA9IGZ1bmN0aW9uICggY29sb3IsIGludGVuc2l0eSApIHtcclxuXHJcbiAgICBUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBjb2xvciApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdEaXJlY3Rpb25hbExpZ2h0JztcclxuXHJcbiAgICB0aGlzLnBvc2l0aW9uLnNldCggMCwgMSwgMCApO1xyXG4gICAgdGhpcy51cGRhdGVNYXRyaXgoKTtcclxuXHJcbiAgICB0aGlzLnRhcmdldCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xyXG5cclxuICAgIHRoaXMuaW50ZW5zaXR5ID0gKCBpbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gaW50ZW5zaXR5IDogMTtcclxuXHJcbiAgICB0aGlzLnNoYWRvdyA9IG5ldyBUSFJFRS5MaWdodFNoYWRvdyggbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSggLSA1MDAsIDUwMCwgNTAwLCAtIDUwMCwgNTAsIDUwMDAgKSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGlnaHQucHJvdG90eXBlICk7XHJcblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRGlyZWN0aW9uYWxMaWdodDtcclxuXHJcblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcbiAgICBUSFJFRS5MaWdodC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcbiAgICB0aGlzLmludGVuc2l0eSA9IHNvdXJjZS5pbnRlbnNpdHk7XHJcbiAgICB0aGlzLnRhcmdldCA9IHNvdXJjZS50YXJnZXQuY2xvbmUoKTtcclxuXHJcbiAgICB0aGlzLnNoYWRvdyA9IHNvdXJjZS5zaGFkb3cuY2xvbmUoKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9saWdodHMvSGVtaXNwaGVyZUxpZ2h0LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5IZW1pc3BoZXJlTGlnaHQgPSBmdW5jdGlvbiAoIHNreUNvbG9yLCBncm91bmRDb2xvciwgaW50ZW5zaXR5ICkge1xyXG5cclxuICAgIFRIUkVFLkxpZ2h0LmNhbGwoIHRoaXMsIHNreUNvbG9yICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ0hlbWlzcGhlcmVMaWdodCc7XHJcblxyXG4gICAgdGhpcy5jYXN0U2hhZG93ID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIHRoaXMucG9zaXRpb24uc2V0KCAwLCAxLCAwICk7XHJcbiAgICB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xyXG5cclxuICAgIHRoaXMuZ3JvdW5kQ29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIGdyb3VuZENvbG9yICk7XHJcbiAgICB0aGlzLmludGVuc2l0eSA9ICggaW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSA/IGludGVuc2l0eSA6IDE7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSApO1xyXG5USFJFRS5IZW1pc3BoZXJlTGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuSGVtaXNwaGVyZUxpZ2h0O1xyXG5cclxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG4gICAgVEhSRUUuTGlnaHQucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG4gICAgdGhpcy5ncm91bmRDb2xvci5jb3B5KCBzb3VyY2UuZ3JvdW5kQ29sb3IgKTtcclxuICAgIHRoaXMuaW50ZW5zaXR5ID0gc291cmNlLmludGVuc2l0eTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9saWdodHMvUG9pbnRMaWdodC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuXHJcblRIUkVFLlBvaW50TGlnaHQgPSBmdW5jdGlvbiAoIGNvbG9yLCBpbnRlbnNpdHksIGRpc3RhbmNlLCBkZWNheSApIHtcclxuXHJcbiAgICBUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBjb2xvciApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdQb2ludExpZ2h0JztcclxuXHJcbiAgICB0aGlzLmludGVuc2l0eSA9ICggaW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSA/IGludGVuc2l0eSA6IDE7XHJcbiAgICB0aGlzLmRpc3RhbmNlID0gKCBkaXN0YW5jZSAhPT0gdW5kZWZpbmVkICkgPyBkaXN0YW5jZSA6IDA7XHJcbiAgICB0aGlzLmRlY2F5ID0gKCBkZWNheSAhPT0gdW5kZWZpbmVkICkgPyBkZWNheSA6IDE7XHQvLyBmb3IgcGh5c2ljYWxseSBjb3JyZWN0IGxpZ2h0cywgc2hvdWxkIGJlIDIuXHJcblxyXG4gICAgdGhpcy5zaGFkb3cgPSBuZXcgVEhSRUUuTGlnaHRTaGFkb3coIG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggOTAsIDEsIDEsIDUwMCApICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUG9pbnRMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcclxuVEhSRUUuUG9pbnRMaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Qb2ludExpZ2h0O1xyXG5cclxuVEhSRUUuUG9pbnRMaWdodC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuICAgIFRIUkVFLkxpZ2h0LnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuICAgIHRoaXMuaW50ZW5zaXR5ID0gc291cmNlLmludGVuc2l0eTtcclxuICAgIHRoaXMuZGlzdGFuY2UgPSBzb3VyY2UuZGlzdGFuY2U7XHJcbiAgICB0aGlzLmRlY2F5ID0gc291cmNlLmRlY2F5O1xyXG5cclxuICAgIHRoaXMuc2hhZG93ID0gc291cmNlLnNoYWRvdy5jbG9uZSgpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2xpZ2h0cy9TcG90TGlnaHQuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlNwb3RMaWdodCA9IGZ1bmN0aW9uICggY29sb3IsIGludGVuc2l0eSwgZGlzdGFuY2UsIGFuZ2xlLCBleHBvbmVudCwgZGVjYXkgKSB7XHJcblxyXG4gICAgVEhSRUUuTGlnaHQuY2FsbCggdGhpcywgY29sb3IgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnU3BvdExpZ2h0JztcclxuXHJcbiAgICB0aGlzLnBvc2l0aW9uLnNldCggMCwgMSwgMCApO1xyXG4gICAgdGhpcy51cGRhdGVNYXRyaXgoKTtcclxuXHJcbiAgICB0aGlzLnRhcmdldCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xyXG5cclxuICAgIHRoaXMuaW50ZW5zaXR5ID0gKCBpbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gaW50ZW5zaXR5IDogMTtcclxuICAgIHRoaXMuZGlzdGFuY2UgPSAoIGRpc3RhbmNlICE9PSB1bmRlZmluZWQgKSA/IGRpc3RhbmNlIDogMDtcclxuICAgIHRoaXMuYW5nbGUgPSAoIGFuZ2xlICE9PSB1bmRlZmluZWQgKSA/IGFuZ2xlIDogTWF0aC5QSSAvIDM7XHJcbiAgICB0aGlzLmV4cG9uZW50ID0gKCBleHBvbmVudCAhPT0gdW5kZWZpbmVkICkgPyBleHBvbmVudCA6IDEwO1xyXG4gICAgdGhpcy5kZWNheSA9ICggZGVjYXkgIT09IHVuZGVmaW5lZCApID8gZGVjYXkgOiAxO1x0Ly8gZm9yIHBoeXNpY2FsbHkgY29ycmVjdCBsaWdodHMsIHNob3VsZCBiZSAyLlxyXG5cclxuICAgIHRoaXMuc2hhZG93ID0gbmV3IFRIUkVFLkxpZ2h0U2hhZG93KCBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIDUwLCAxLCA1MCwgNTAwMCApICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU3BvdExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSApO1xyXG5USFJFRS5TcG90TGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU3BvdExpZ2h0O1xyXG5cclxuVEhSRUUuU3BvdExpZ2h0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG4gICAgVEhSRUUuTGlnaHQucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG4gICAgdGhpcy5pbnRlbnNpdHkgPSBzb3VyY2UuaW50ZW5zaXR5O1xyXG4gICAgdGhpcy5kaXN0YW5jZSA9IHNvdXJjZS5kaXN0YW5jZTtcclxuICAgIHRoaXMuYW5nbGUgPSBzb3VyY2UuYW5nbGU7XHJcbiAgICB0aGlzLmV4cG9uZW50ID0gc291cmNlLmV4cG9uZW50O1xyXG4gICAgdGhpcy5kZWNheSA9IHNvdXJjZS5kZWNheTtcclxuXHJcbiAgICB0aGlzLnRhcmdldCA9IHNvdXJjZS50YXJnZXQuY2xvbmUoKTtcclxuXHJcbiAgICB0aGlzLnNoYWRvdyA9IHNvdXJjZS5zaGFkb3cuY2xvbmUoKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0NhY2hlLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5DYWNoZSA9IHtcclxuXHJcbiAgICBlbmFibGVkOiBmYWxzZSxcclxuXHJcbiAgICBmaWxlczoge30sXHJcblxyXG4gICAgYWRkOiBmdW5jdGlvbiAoIGtleSwgZmlsZSApIHtcclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyggJ1RIUkVFLkNhY2hlJywgJ0FkZGluZyBrZXk6Jywga2V5ICk7XHJcblxyXG4gICAgICAgIHRoaXMuZmlsZXNbIGtleSBdID0gZmlsZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldDogZnVuY3Rpb24gKCBrZXkgKSB7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coICdUSFJFRS5DYWNoZScsICdDaGVja2luZyBrZXk6Jywga2V5ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmZpbGVzWyBrZXkgXTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZTogZnVuY3Rpb24gKCBrZXkgKSB7XHJcblxyXG4gICAgICAgIGRlbGV0ZSB0aGlzLmZpbGVzWyBrZXkgXTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMuZmlsZXMgPSB7fTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbG9hZGVycy9Mb2FkZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkxvYWRlciA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB0aGlzLm9uTG9hZFN0YXJ0ID0gZnVuY3Rpb24gKCkge307XHJcbiAgICB0aGlzLm9uTG9hZFByb2dyZXNzID0gZnVuY3Rpb24gKCkge307XHJcbiAgICB0aGlzLm9uTG9hZENvbXBsZXRlID0gZnVuY3Rpb24gKCkge307XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuTG9hZGVyLFxyXG5cclxuICAgIGNyb3NzT3JpZ2luOiB1bmRlZmluZWQsXHJcblxyXG4gICAgZXh0cmFjdFVybEJhc2U6IGZ1bmN0aW9uICggdXJsICkge1xyXG5cclxuICAgICAgICB2YXIgcGFydHMgPSB1cmwuc3BsaXQoICcvJyApO1xyXG5cclxuICAgICAgICBpZiAoIHBhcnRzLmxlbmd0aCA9PT0gMSApIHJldHVybiAnLi8nO1xyXG5cclxuICAgICAgICBwYXJ0cy5wb3AoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oICcvJyApICsgJy8nO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgaW5pdE1hdGVyaWFsczogZnVuY3Rpb24gKCBtYXRlcmlhbHMsIHRleHR1cmVQYXRoLCBjcm9zc09yaWdpbiApIHtcclxuXHJcbiAgICAgICAgdmFyIGFycmF5ID0gW107XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG1hdGVyaWFscy5sZW5ndGg7ICsrIGkgKSB7XHJcblxyXG4gICAgICAgICAgICBhcnJheVsgaSBdID0gdGhpcy5jcmVhdGVNYXRlcmlhbCggbWF0ZXJpYWxzWyBpIF0sIHRleHR1cmVQYXRoLCBjcm9zc09yaWdpbiApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhcnJheTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZU1hdGVyaWFsOiAoIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIGNvbG9yLCB0ZXh0dXJlTG9hZGVyLCBtYXRlcmlhbExvYWRlcjtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggbSwgdGV4dHVyZVBhdGgsIGNyb3NzT3JpZ2luICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkICkgY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoKTtcclxuICAgICAgICAgICAgaWYgKCB0ZXh0dXJlTG9hZGVyID09PSB1bmRlZmluZWQgKSB0ZXh0dXJlTG9hZGVyID0gbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoKTtcclxuICAgICAgICAgICAgaWYgKCBtYXRlcmlhbExvYWRlciA9PT0gdW5kZWZpbmVkICkgbWF0ZXJpYWxMb2FkZXIgPSBuZXcgVEhSRUUuTWF0ZXJpYWxMb2FkZXIoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgZnJvbSBvbGQgbWF0ZXJpYWwgZm9ybWF0XHJcblxyXG4gICAgICAgICAgICB2YXIgdGV4dHVyZXMgPSB7fTtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGxvYWRUZXh0dXJlKCBwYXRoLCByZXBlYXQsIG9mZnNldCwgd3JhcCwgYW5pc290cm9weSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZnVsbFBhdGggPSB0ZXh0dXJlUGF0aCArIHBhdGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgbG9hZGVyID0gVEhSRUUuTG9hZGVyLkhhbmRsZXJzLmdldCggZnVsbFBhdGggKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdGV4dHVyZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGxvYWRlciAhPT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZSA9IGxvYWRlci5sb2FkKCBmdWxsUGF0aCApO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmVMb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIGNyb3NzT3JpZ2luICk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZSA9IHRleHR1cmVMb2FkZXIubG9hZCggZnVsbFBhdGggKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCByZXBlYXQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5yZXBlYXQuZnJvbUFycmF5KCByZXBlYXQgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCByZXBlYXRbIDAgXSAhPT0gMSApIHRleHR1cmUud3JhcFMgPSBUSFJFRS5SZXBlYXRXcmFwcGluZztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHJlcGVhdFsgMSBdICE9PSAxICkgdGV4dHVyZS53cmFwVCA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIG9mZnNldCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLm9mZnNldC5mcm9tQXJyYXkoIG9mZnNldCApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHdyYXAgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB3cmFwWyAwIF0gPT09ICdyZXBlYXQnICkgdGV4dHVyZS53cmFwUyA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggd3JhcFsgMCBdID09PSAnbWlycm9yJyApIHRleHR1cmUud3JhcFMgPSBUSFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHdyYXBbIDEgXSA9PT0gJ3JlcGVhdCcgKSB0ZXh0dXJlLndyYXBUID0gVEhSRUUuUmVwZWF0V3JhcHBpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB3cmFwWyAxIF0gPT09ICdtaXJyb3InICkgdGV4dHVyZS53cmFwVCA9IFRIUkVFLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmc7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICggYW5pc290cm9weSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLmFuaXNvdHJvcHkgPSBhbmlzb3Ryb3B5O1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGV4dHVyZXNbIHV1aWQgXSA9IHRleHR1cmU7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHV1aWQ7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL1xyXG5cclxuICAgICAgICAgICAgdmFyIGpzb24gPSB7XHJcbiAgICAgICAgICAgICAgICB1dWlkOiBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogJ01lc2hMYW1iZXJ0TWF0ZXJpYWwnXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgbmFtZSBpbiBtICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG1bIG5hbWUgXTtcclxuXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKCBuYW1lICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0RiZ0NvbG9yJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAganNvbi5jb2xvciA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdEYmdJbmRleCc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnb3B0aWNhbERlbnNpdHknOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2lsbHVtaW5hdGlvbic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIHdlcmUgbmV2ZXIgc3VwcG9ydGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0RiZ05hbWUnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uLm5hbWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYmxlbmRpbmcnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uLmJsZW5kaW5nID0gVEhSRUVbIHZhbHVlIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbG9yRGlmZnVzZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb24uY29sb3IgPSBjb2xvci5mcm9tQXJyYXkoIHZhbHVlICkuZ2V0SGV4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbG9yU3BlY3VsYXInOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uLnNwZWN1bGFyID0gY29sb3IuZnJvbUFycmF5KCB2YWx1ZSApLmdldEhleCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb2xvckVtaXNzaXZlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAganNvbi5lbWlzc2l2ZSA9IGNvbG9yLmZyb21BcnJheSggdmFsdWUgKS5nZXRIZXgoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3BlY3VsYXJDb2VmJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAganNvbi5zaGluaW5lc3MgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2hhZGluZyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJ2Jhc2ljJyApIGpzb24udHlwZSA9ICdNZXNoQmFzaWNNYXRlcmlhbCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJ3Bob25nJyApIGpzb24udHlwZSA9ICdNZXNoUGhvbmdNYXRlcmlhbCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21hcERpZmZ1c2UnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uLm1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBEaWZmdXNlUmVwZWF0LCBtLm1hcERpZmZ1c2VPZmZzZXQsIG0ubWFwRGlmZnVzZVdyYXAsIG0ubWFwRGlmZnVzZUFuaXNvdHJvcHkgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWFwRGlmZnVzZVJlcGVhdCc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWFwRGlmZnVzZU9mZnNldCc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWFwRGlmZnVzZVdyYXAnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21hcERpZmZ1c2VBbmlzb3Ryb3B5JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWFwTGlnaHQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uLmxpZ2h0TWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcExpZ2h0UmVwZWF0LCBtLm1hcExpZ2h0T2Zmc2V0LCBtLm1hcExpZ2h0V3JhcCwgbS5tYXBMaWdodEFuaXNvdHJvcHkgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWFwTGlnaHRSZXBlYXQnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21hcExpZ2h0T2Zmc2V0JzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXBMaWdodFdyYXAnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21hcExpZ2h0QW5pc290cm9weSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21hcEFPJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAganNvbi5hb01hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBBT1JlcGVhdCwgbS5tYXBBT09mZnNldCwgbS5tYXBBT1dyYXAsIG0ubWFwQU9Bbmlzb3Ryb3B5ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21hcEFPUmVwZWF0JzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXBBT09mZnNldCc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWFwQU9XcmFwJzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXBBT0FuaXNvdHJvcHknOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXBCdW1wJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAganNvbi5idW1wTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcEJ1bXBSZXBlYXQsIG0ubWFwQnVtcE9mZnNldCwgbS5tYXBCdW1wV3JhcCwgbS5tYXBCdW1wQW5pc290cm9weSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXBCdW1wU2NhbGUnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uLmJ1bXBTY2FsZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXBCdW1wUmVwZWF0JzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXBCdW1wT2Zmc2V0JzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXBCdW1wV3JhcCc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWFwQnVtcEFuaXNvdHJvcHknOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXBOb3JtYWwnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uLm5vcm1hbE1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBOb3JtYWxSZXBlYXQsIG0ubWFwTm9ybWFsT2Zmc2V0LCBtLm1hcE5vcm1hbFdyYXAsIG0ubWFwTm9ybWFsQW5pc290cm9weSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXBOb3JtYWxGYWN0b3InOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uLm5vcm1hbFNjYWxlID0gWyB2YWx1ZSwgdmFsdWUgXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWFwTm9ybWFsUmVwZWF0JzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXBOb3JtYWxPZmZzZXQnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21hcE5vcm1hbFdyYXAnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21hcE5vcm1hbEFuaXNvdHJvcHknOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXBTcGVjdWxhcic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb24uc3BlY3VsYXJNYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwU3BlY3VsYXJSZXBlYXQsIG0ubWFwU3BlY3VsYXJPZmZzZXQsIG0ubWFwU3BlY3VsYXJXcmFwLCBtLm1hcFNwZWN1bGFyQW5pc290cm9weSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXBTcGVjdWxhclJlcGVhdCc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWFwU3BlY3VsYXJPZmZzZXQnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21hcFNwZWN1bGFyV3JhcCc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWFwU3BlY3VsYXJBbmlzb3Ryb3B5JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWFwQWxwaGEnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uLmFscGhhTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcEFscGhhUmVwZWF0LCBtLm1hcEFscGhhT2Zmc2V0LCBtLm1hcEFscGhhV3JhcCwgbS5tYXBBbHBoYUFuaXNvdHJvcHkgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWFwQWxwaGFSZXBlYXQnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21hcEFscGhhT2Zmc2V0JzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXBBbHBoYVdyYXAnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21hcEFscGhhQW5pc290cm9weSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZsaXBTaWRlZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb24uc2lkZSA9IFRIUkVFLkJhY2tTaWRlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdkb3VibGVTaWRlZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb24uc2lkZSA9IFRIUkVFLkRvdWJsZVNpZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RyYW5zcGFyZW5jeSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkxvYWRlcjogdHJhbnNwYXJlbmN5IGhhcyBiZWVuIHJlbmFtZWQgdG8gb3BhY2l0eScgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAganNvbi5vcGFjaXR5ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ29wYWNpdHknOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RyYW5zcGFyZW50JzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdkZXB0aFRlc3QnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RlcHRoV3JpdGUnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RyYW5zcGFyZW50JzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICd2aXNpYmxlJzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICd3aXJlZnJhbWUnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uWyBuYW1lIF0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndmVydGV4Q29sb3JzJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIGpzb24udmVydGV4Q29sb3JzID0gVEhSRUUuVmVydGV4Q29sb3JzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHZhbHVlID09PSAnZmFjZScgKSBqc29uLnZlcnRleENvbG9ycyA9IFRIUkVFLkZhY2VDb2xvcnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdMb2FkZXIuY3JlYXRlTWF0ZXJpYWw6IFVuc3VwcG9ydGVkJywgbmFtZSwgdmFsdWUgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIGpzb24udHlwZSAhPT0gJ01lc2hQaG9uZ01hdGVyaWFsJyApIGRlbGV0ZSBqc29uLnNwZWN1bGFyO1xyXG4gICAgICAgICAgICBpZiAoIGpzb24ub3BhY2l0eSA8IDEgKSBqc29uLnRyYW5zcGFyZW50ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIG1hdGVyaWFsTG9hZGVyLnNldFRleHR1cmVzKCB0ZXh0dXJlcyApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG1hdGVyaWFsTG9hZGVyLnBhcnNlKCBqc29uICk7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSApKClcclxuXHJcbn07XHJcblxyXG5USFJFRS5Mb2FkZXIuSGFuZGxlcnMgPSB7XHJcblxyXG4gICAgaGFuZGxlcnM6IFtdLFxyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKCByZWdleCwgbG9hZGVyICkge1xyXG5cclxuICAgICAgICB0aGlzLmhhbmRsZXJzLnB1c2goIHJlZ2V4LCBsb2FkZXIgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldDogZnVuY3Rpb24gKCBmaWxlICkge1xyXG5cclxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBsOyBpICs9IDIgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVnZXggPSBoYW5kbGVyc1sgaSBdO1xyXG4gICAgICAgICAgICB2YXIgbG9hZGVyICA9IGhhbmRsZXJzWyBpICsgMSBdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCByZWdleC50ZXN0KCBmaWxlICkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlcjtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbG9hZGVycy9YSFJMb2FkZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlhIUkxvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcclxuXHJcbiAgICB0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5YSFJMb2FkZXIucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5YSFJMb2FkZXIsXHJcblxyXG4gICAgbG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcclxuXHJcbiAgICAgICAgdmFyIGNhY2hlZCA9IFRIUkVFLkNhY2hlLmdldCggdXJsICk7XHJcblxyXG4gICAgICAgIGlmICggY2FjaGVkICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG9uTG9hZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG9uTG9hZCggY2FjaGVkICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSwgMCApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgIHJlcXVlc3Qub3BlbiggJ0dFVCcsIHVybCwgdHJ1ZSApO1xyXG5cclxuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkJywgZnVuY3Rpb24gKCBldmVudCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciByZXNwb25zZSA9IGV2ZW50LnRhcmdldC5yZXNwb25zZTtcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLkNhY2hlLmFkZCggdXJsLCByZXNwb25zZSApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBvbkxvYWQgKSBvbkxvYWQoIHJlc3BvbnNlICk7XHJcblxyXG4gICAgICAgICAgICBzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xyXG5cclxuICAgICAgICB9LCBmYWxzZSApO1xyXG5cclxuICAgICAgICBpZiAoIG9uUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lciggJ3Byb2dyZXNzJywgZnVuY3Rpb24gKCBldmVudCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBvblByb2dyZXNzKCBldmVudCApO1xyXG5cclxuICAgICAgICAgICAgfSwgZmFsc2UgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoICdlcnJvcicsIGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG9uRXJyb3IgKSBvbkVycm9yKCBldmVudCApO1xyXG5cclxuICAgICAgICAgICAgc2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xyXG5cclxuICAgICAgICB9LCBmYWxzZSApO1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMuY3Jvc3NPcmlnaW4gIT09IHVuZGVmaW5lZCApIHJlcXVlc3QuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xyXG4gICAgICAgIGlmICggdGhpcy5yZXNwb25zZVR5cGUgIT09IHVuZGVmaW5lZCApIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gdGhpcy5yZXNwb25zZVR5cGU7XHJcbiAgICAgICAgaWYgKCB0aGlzLndpdGhDcmVkZW50aWFscyAhPT0gdW5kZWZpbmVkICkgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSB0aGlzLndpdGhDcmVkZW50aWFscztcclxuXHJcbiAgICAgICAgcmVxdWVzdC5zZW5kKCBudWxsICk7XHJcblxyXG4gICAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRSZXNwb25zZVR5cGU6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIHRoaXMucmVzcG9uc2VUeXBlID0gdmFsdWU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0V2l0aENyZWRlbnRpYWxzOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuICAgICAgICB0aGlzLndpdGhDcmVkZW50aWFscyA9IHZhbHVlO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0ltYWdlTG9hZGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5JbWFnZUxvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcclxuXHJcbiAgICB0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5JbWFnZUxvYWRlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkltYWdlTG9hZGVyLFxyXG5cclxuICAgIGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XHJcblxyXG4gICAgICAgIHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG4gICAgICAgIHZhciBjYWNoZWQgPSBUSFJFRS5DYWNoZS5nZXQoIHVybCApO1xyXG5cclxuICAgICAgICBpZiAoIGNhY2hlZCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgc2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBvbkxvYWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBvbkxvYWQoIGNhY2hlZCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xyXG5cclxuICAgICAgICAgICAgICAgIH0sIDAgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgc2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2ltZycgKTtcclxuXHJcbiAgICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xyXG5cclxuICAgICAgICAgICAgVEhSRUUuQ2FjaGUuYWRkKCB1cmwsIHRoaXMgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggb25Mb2FkICkgb25Mb2FkKCB0aGlzICk7XHJcblxyXG4gICAgICAgICAgICBzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xyXG5cclxuICAgICAgICB9LCBmYWxzZSApO1xyXG5cclxuICAgICAgICBpZiAoIG9uUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdwcm9ncmVzcycsIGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgb25Qcm9ncmVzcyggZXZlbnQgKTtcclxuXHJcbiAgICAgICAgICAgIH0sIGZhbHNlICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lciggJ2Vycm9yJywgZnVuY3Rpb24gKCBldmVudCApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggb25FcnJvciApIG9uRXJyb3IoIGV2ZW50ICk7XHJcblxyXG4gICAgICAgICAgICBzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XHJcblxyXG4gICAgICAgIH0sIGZhbHNlICk7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5jcm9zc09yaWdpbiAhPT0gdW5kZWZpbmVkICkgaW1hZ2UuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xyXG5cclxuICAgICAgICBzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XHJcblxyXG4gICAgICAgIGltYWdlLnNyYyA9IHVybDtcclxuXHJcbiAgICAgICAgcmV0dXJuIGltYWdlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbG9hZGVycy9KU09OTG9hZGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5KU09OTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xyXG5cclxuICAgIGlmICggdHlwZW9mIG1hbmFnZXIgPT09ICdib29sZWFuJyApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuSlNPTkxvYWRlcjogc2hvd1N0YXR1cyBwYXJhbWV0ZXIgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIGNvbnN0cnVjdG9yLicgKTtcclxuICAgICAgICBtYW5hZ2VyID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcclxuXHJcbiAgICB0aGlzLndpdGhDcmVkZW50aWFscyA9IGZhbHNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkpTT05Mb2FkZXIucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5KU09OTG9hZGVyLFxyXG5cclxuICAgIC8vIERlcHJlY2F0ZWRcclxuXHJcbiAgICBnZXQgc3RhdHVzRG9tRWxlbWVudCAoKSB7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5fc3RhdHVzRG9tRWxlbWVudCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fc3RhdHVzRG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuSlNPTkxvYWRlcjogLnN0YXR1c0RvbUVsZW1lbnQgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXR1c0RvbUVsZW1lbnQ7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBsb2FkOiBmdW5jdGlvbiggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XHJcblxyXG4gICAgICAgIHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG4gICAgICAgIHZhciB0ZXh0dXJlUGF0aCA9IHRoaXMudGV4dHVyZVBhdGggJiYgKCB0eXBlb2YgdGhpcy50ZXh0dXJlUGF0aCA9PT0gXCJzdHJpbmdcIiApID8gdGhpcy50ZXh0dXJlUGF0aCA6IFRIUkVFLkxvYWRlci5wcm90b3R5cGUuZXh0cmFjdFVybEJhc2UoIHVybCApO1xyXG5cclxuICAgICAgICB2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlciggdGhpcy5tYW5hZ2VyICk7XHJcbiAgICAgICAgbG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XHJcbiAgICAgICAgbG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggdGhpcy53aXRoQ3JlZGVudGlhbHMgKTtcclxuICAgICAgICBsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIganNvbiA9IEpTT04ucGFyc2UoIHRleHQgKTtcclxuICAgICAgICAgICAgdmFyIG1ldGFkYXRhID0ganNvbi5tZXRhZGF0YTtcclxuXHJcbiAgICAgICAgICAgIGlmICggbWV0YWRhdGEgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIG1ldGFkYXRhLnR5cGUgPT09ICdvYmplY3QnICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuSlNPTkxvYWRlcjogJyArIHVybCArICcgc2hvdWxkIGJlIGxvYWRlZCB3aXRoIFRIUkVFLk9iamVjdExvYWRlciBpbnN0ZWFkLicgKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICggbWV0YWRhdGEudHlwZSA9PT0gJ3NjZW5lJyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLkpTT05Mb2FkZXI6ICcgKyB1cmwgKyAnIHNob3VsZCBiZSBsb2FkZWQgd2l0aCBUSFJFRS5TY2VuZUxvYWRlciBpbnN0ZWFkLicgKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHNjb3BlLnBhcnNlKCBqc29uLCB0ZXh0dXJlUGF0aCApO1xyXG4gICAgICAgICAgICBvbkxvYWQoIG9iamVjdC5nZW9tZXRyeSwgb2JqZWN0Lm1hdGVyaWFscyApO1xyXG5cclxuICAgICAgICB9ICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0VGV4dHVyZVBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIHRoaXMudGV4dHVyZVBhdGggPSB2YWx1ZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHBhcnNlOiBmdW5jdGlvbiAoIGpzb24sIHRleHR1cmVQYXRoICkge1xyXG5cclxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKSxcclxuICAgICAgICAgICAgc2NhbGUgPSAoIGpzb24uc2NhbGUgIT09IHVuZGVmaW5lZCApID8gMS4wIC8ganNvbi5zY2FsZSA6IDEuMDtcclxuXHJcbiAgICAgICAgcGFyc2VNb2RlbCggc2NhbGUgKTtcclxuXHJcbiAgICAgICAgcGFyc2VTa2luKCk7XHJcbiAgICAgICAgcGFyc2VNb3JwaGluZyggc2NhbGUgKTtcclxuICAgICAgICBwYXJzZUFuaW1hdGlvbnMoKTtcclxuXHJcbiAgICAgICAgZ2VvbWV0cnkuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcbiAgICAgICAgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlTW9kZWwoIHNjYWxlICkge1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gaXNCaXRTZXQoIHZhbHVlLCBwb3NpdGlvbiApIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgJiAoIDEgPDwgcG9zaXRpb24gKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBpLCBqLCBmaSxcclxuXHJcbiAgICAgICAgICAgICAgICBvZmZzZXQsIHpMZW5ndGgsXHJcblxyXG4gICAgICAgICAgICAgICAgY29sb3JJbmRleCwgbm9ybWFsSW5kZXgsIHV2SW5kZXgsIG1hdGVyaWFsSW5kZXgsXHJcblxyXG4gICAgICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgICAgIGlzUXVhZCxcclxuICAgICAgICAgICAgICAgIGhhc01hdGVyaWFsLFxyXG4gICAgICAgICAgICAgICAgaGFzRmFjZVZlcnRleFV2LFxyXG4gICAgICAgICAgICAgICAgaGFzRmFjZU5vcm1hbCwgaGFzRmFjZVZlcnRleE5vcm1hbCxcclxuICAgICAgICAgICAgICAgIGhhc0ZhY2VDb2xvciwgaGFzRmFjZVZlcnRleENvbG9yLFxyXG5cclxuICAgICAgICAgICAgICAgIHZlcnRleCwgZmFjZSwgZmFjZUEsIGZhY2VCLCBoZXgsIG5vcm1hbCxcclxuXHJcbiAgICAgICAgICAgICAgICB1dkxheWVyLCB1diwgdSwgdixcclxuXHJcbiAgICAgICAgICAgICAgICBmYWNlcyA9IGpzb24uZmFjZXMsXHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcyA9IGpzb24udmVydGljZXMsXHJcbiAgICAgICAgICAgICAgICBub3JtYWxzID0ganNvbi5ub3JtYWxzLFxyXG4gICAgICAgICAgICAgICAgY29sb3JzID0ganNvbi5jb2xvcnMsXHJcblxyXG4gICAgICAgICAgICAgICAgblV2TGF5ZXJzID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmICgganNvbi51dnMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBkaXNyZWdhcmQgZW1wdHkgYXJyYXlzXHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBqc29uLnV2cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgganNvbi51dnNbIGkgXS5sZW5ndGggKSBuVXZMYXllcnMgKys7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgblV2TGF5ZXJzOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF0gPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICB6TGVuZ3RoID0gdmVydGljZXMubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgd2hpbGUgKCBvZmZzZXQgPCB6TGVuZ3RoICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmVydGV4LnggPSB2ZXJ0aWNlc1sgb2Zmc2V0ICsrIF0gKiBzY2FsZTtcclxuICAgICAgICAgICAgICAgIHZlcnRleC55ID0gdmVydGljZXNbIG9mZnNldCArKyBdICogc2NhbGU7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXgueiA9IHZlcnRpY2VzWyBvZmZzZXQgKysgXSAqIHNjYWxlO1xyXG5cclxuICAgICAgICAgICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgekxlbmd0aCA9IGZhY2VzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIHdoaWxlICggb2Zmc2V0IDwgekxlbmd0aCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0eXBlID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBpc1F1YWQgICAgICAgICAgICAgID0gaXNCaXRTZXQoIHR5cGUsIDAgKTtcclxuICAgICAgICAgICAgICAgIGhhc01hdGVyaWFsICAgICAgICAgPSBpc0JpdFNldCggdHlwZSwgMSApO1xyXG4gICAgICAgICAgICAgICAgaGFzRmFjZVZlcnRleFV2ICAgICA9IGlzQml0U2V0KCB0eXBlLCAzICk7XHJcbiAgICAgICAgICAgICAgICBoYXNGYWNlTm9ybWFsICAgICAgID0gaXNCaXRTZXQoIHR5cGUsIDQgKTtcclxuICAgICAgICAgICAgICAgIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgPSBpc0JpdFNldCggdHlwZSwgNSApO1xyXG4gICAgICAgICAgICAgICAgaGFzRmFjZUNvbG9yXHQgICAgID0gaXNCaXRTZXQoIHR5cGUsIDYgKTtcclxuICAgICAgICAgICAgICAgIGhhc0ZhY2VWZXJ0ZXhDb2xvciAgPSBpc0JpdFNldCggdHlwZSwgNyApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwidHlwZVwiLCB0eXBlLCBcImJpdHNcIiwgaXNRdWFkLCBoYXNNYXRlcmlhbCwgaGFzRmFjZVZlcnRleFV2LCBoYXNGYWNlTm9ybWFsLCBoYXNGYWNlVmVydGV4Tm9ybWFsLCBoYXNGYWNlQ29sb3IsIGhhc0ZhY2VWZXJ0ZXhDb2xvcik7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBpc1F1YWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZhY2VBID0gbmV3IFRIUkVFLkZhY2UzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmFjZUEuYSA9IGZhY2VzWyBvZmZzZXQgXTtcclxuICAgICAgICAgICAgICAgICAgICBmYWNlQS5iID0gZmFjZXNbIG9mZnNldCArIDEgXTtcclxuICAgICAgICAgICAgICAgICAgICBmYWNlQS5jID0gZmFjZXNbIG9mZnNldCArIDMgXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZmFjZUIgPSBuZXcgVEhSRUUuRmFjZTMoKTtcclxuICAgICAgICAgICAgICAgICAgICBmYWNlQi5hID0gZmFjZXNbIG9mZnNldCArIDEgXTtcclxuICAgICAgICAgICAgICAgICAgICBmYWNlQi5iID0gZmFjZXNbIG9mZnNldCArIDIgXTtcclxuICAgICAgICAgICAgICAgICAgICBmYWNlQi5jID0gZmFjZXNbIG9mZnNldCArIDMgXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggaGFzTWF0ZXJpYWwgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlQS5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZUIubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gZ2V0IGZhY2UgPD0+IHV2IGluZGV4IGNvcnJlc3BvbmRlbmNlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZpID0gZ2VvbWV0cnkuZmFjZXMubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgblV2TGF5ZXJzOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV2TGF5ZXIgPSBqc29uLnV2c1sgaSBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSArIDEgXSA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGogPSAwOyBqIDwgNDsgaiArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXZJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdSA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyICsgMSBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1diA9IG5ldyBUSFJFRS5WZWN0b3IyKCB1LCB2ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaiAhPT0gMiApIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgXS5wdXNoKCB1diApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaiAhPT0gMCApIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgKyAxIF0ucHVzaCggdXYgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBoYXNGYWNlTm9ybWFsICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF0gKiAzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZUEubm9ybWFsLnNldChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgbm9ybWFsSW5kZXggXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZUIubm9ybWFsLmNvcHkoIGZhY2VBLm5vcm1hbCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggaGFzRmFjZVZlcnRleE5vcm1hbCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgNDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXSAqIDM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIG5vcm1hbEluZGV4IF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaSAhPT0gMiApIGZhY2VBLnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGkgIT09IDAgKSBmYWNlQi52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGhhc0ZhY2VDb2xvciApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhleCA9IGNvbG9yc1sgY29sb3JJbmRleCBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZUEuY29sb3Iuc2V0SGV4KCBoZXggKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZUIuY29sb3Iuc2V0SGV4KCBoZXggKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBoYXNGYWNlVmVydGV4Q29sb3IgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IDQ7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhleCA9IGNvbG9yc1sgY29sb3JJbmRleCBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaSAhPT0gMiApIGZhY2VBLnZlcnRleENvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIGhleCApICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGkgIT09IDAgKSBmYWNlQi52ZXJ0ZXhDb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCBoZXggKSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LmZhY2VzLnB1c2goIGZhY2VBICk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuZmFjZXMucHVzaCggZmFjZUIgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmFjZS5hID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZhY2UuYiA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuICAgICAgICAgICAgICAgICAgICBmYWNlLmMgPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggaGFzTWF0ZXJpYWwgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGdldCBmYWNlIDw9PiB1diBpbmRleCBjb3JyZXNwb25kZW5jZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmaSA9IGdlb21ldHJ5LmZhY2VzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBoYXNGYWNlVmVydGV4VXYgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dkxheWVyID0ganNvbi51dnNbIGkgXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0gPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBqID0gMDsgaiA8IDM7IGogKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV2SW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSB1dkxheWVyWyB1dkluZGV4ICogMiBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSB1dkxheWVyWyB1dkluZGV4ICogMiArIDEgXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXYgPSBuZXcgVEhSRUUuVmVjdG9yMiggdSwgdiApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0ucHVzaCggdXYgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBoYXNGYWNlTm9ybWFsICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF0gKiAzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZS5ub3JtYWwuc2V0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBub3JtYWxJbmRleCBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBoYXNGYWNlVmVydGV4Tm9ybWFsICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCAzOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdICogMztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgbm9ybWFsSW5kZXggXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWNlLnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggaGFzRmFjZUNvbG9yICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZS5jb2xvci5zZXRIZXgoIGNvbG9yc1sgY29sb3JJbmRleCBdICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggaGFzRmFjZVZlcnRleENvbG9yICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCAzOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWNlLnZlcnRleENvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yc1sgY29sb3JJbmRleCBdICkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5mYWNlcy5wdXNoKCBmYWNlICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBwYXJzZVNraW4oKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgaW5mbHVlbmNlc1BlclZlcnRleCA9ICgganNvbi5pbmZsdWVuY2VzUGVyVmVydGV4ICE9PSB1bmRlZmluZWQgKSA/IGpzb24uaW5mbHVlbmNlc1BlclZlcnRleCA6IDI7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGpzb24uc2tpbldlaWdodHMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5za2luV2VpZ2h0cy5sZW5ndGg7IGkgPCBsOyBpICs9IGluZmx1ZW5jZXNQZXJWZXJ0ZXggKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbi5za2luV2VpZ2h0c1sgaSBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB5ID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMSApID8ganNvbi5za2luV2VpZ2h0c1sgaSArIDEgXSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHogPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAyICkgPyBqc29uLnNraW5XZWlnaHRzWyBpICsgMiBdIDogMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdyA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDMgKSA/IGpzb24uc2tpbldlaWdodHNbIGkgKyAzIF0gOiAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5za2luV2VpZ2h0cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yNCggeCwgeSwgeiwgdyApICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBqc29uLnNraW5JbmRpY2VzICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24uc2tpbkluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArPSBpbmZsdWVuY2VzUGVyVmVydGV4ICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb24uc2tpbkluZGljZXNbIGkgXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDEgKSA/IGpzb24uc2tpbkluZGljZXNbIGkgKyAxIF0gOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMiApID8ganNvbi5za2luSW5kaWNlc1sgaSArIDIgXSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAzICkgPyBqc29uLnNraW5JbmRpY2VzWyBpICsgMyBdIDogMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuc2tpbkluZGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjQoIGEsIGIsIGMsIGQgKSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGdlb21ldHJ5LmJvbmVzID0ganNvbi5ib25lcztcclxuXHJcbiAgICAgICAgICAgIGlmICggZ2VvbWV0cnkuYm9uZXMgJiYgZ2VvbWV0cnkuYm9uZXMubGVuZ3RoID4gMCAmJiAoIGdlb21ldHJ5LnNraW5XZWlnaHRzLmxlbmd0aCAhPT0gZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoIHx8IGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCAhPT0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnV2hlbiBza2lubmluZywgbnVtYmVyIG9mIHZlcnRpY2VzICgnICsgZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICsgJyksIHNraW5JbmRpY2VzICgnICtcclxuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggKyAnKSwgYW5kIHNraW5XZWlnaHRzICgnICsgZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoICsgJykgc2hvdWxkIG1hdGNoLicgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcGFyc2VNb3JwaGluZyggc2NhbGUgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGpzb24ubW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5tb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0gPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXS5uYW1lID0ganNvbi5tb3JwaFRhcmdldHNbIGkgXS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkc3RWZXJ0aWNlcyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzcmNWZXJ0aWNlcyA9IGpzb24ubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciB2ID0gMCwgdmwgPSBzcmNWZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArPSAzICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRleC54ID0gc3JjVmVydGljZXNbIHYgXSAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXgueSA9IHNyY1ZlcnRpY2VzWyB2ICsgMSBdICogc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRleC56ID0gc3JjVmVydGljZXNbIHYgKyAyIF0gKiBzY2FsZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRzdFZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBqc29uLm1vcnBoQ29sb3JzICE9PSB1bmRlZmluZWQgJiYganNvbi5tb3JwaENvbG9ycy5sZW5ndGggPiAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkpTT05Mb2FkZXI6IFwibW9ycGhDb2xvcnNcIiBubyBsb25nZXIgc3VwcG9ydGVkLiBVc2luZyB0aGVtIGFzIGZhY2UgY29sb3JzLicgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZmFjZXMgPSBnZW9tZXRyeS5mYWNlcztcclxuICAgICAgICAgICAgICAgIHZhciBtb3JwaENvbG9ycyA9IGpzb24ubW9ycGhDb2xvcnNbIDAgXS5jb2xvcnM7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZmFjZXNbIGkgXS5jb2xvci5mcm9tQXJyYXkoIG1vcnBoQ29sb3JzLCBpICogMyApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBwYXJzZUFuaW1hdGlvbnMoKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgb3V0cHV0QW5pbWF0aW9ucyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgLy8gcGFyc2Ugb2xkIHN0eWxlIEJvbmUvSGllcmFyY2h5IGFuaW1hdGlvbnNcclxuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbnMgPSBbXTtcclxuICAgICAgICAgICAgaWYgKCBqc29uLmFuaW1hdGlvbiAhPT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9ucy5wdXNoKCBqc29uLmFuaW1hdGlvbiApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgganNvbi5hbmltYXRpb25zICE9PSB1bmRlZmluZWQgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIGpzb24uYW5pbWF0aW9ucy5sZW5ndGggKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9ucyA9IGFuaW1hdGlvbnMuY29uY2F0KCBqc29uLmFuaW1hdGlvbnMgKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9ucy5wdXNoKCBqc29uLmFuaW1hdGlvbnMgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgYW5pbWF0aW9ucy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGNsaXAgPSBUSFJFRS5BbmltYXRpb25DbGlwLnBhcnNlQW5pbWF0aW9uKCBhbmltYXRpb25zW2ldLCBnZW9tZXRyeS5ib25lcyApO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBjbGlwICkgb3V0cHV0QW5pbWF0aW9ucy5wdXNoKCBjbGlwICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBwYXJzZSBpbXBsaWNpdCBtb3JwaCBhbmltYXRpb25zXHJcbiAgICAgICAgICAgIGlmICggZ2VvbWV0cnkubW9ycGhUYXJnZXRzICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2hhdCBhbiBhcHByb3ByYWl0ZSBGUFMgaXMgZm9yIG1vcnBoIHRhcmdldCBhbmltYXRpb25zIC0tIGRlZmF1bHRpbmcgdG8gMTAsIGJ1dCByZWFsbHkgaXQgaXMgY29tcGxldGVseSBhcmJpdHJhcnkuXHJcbiAgICAgICAgICAgICAgICB2YXIgbW9ycGhBbmltYXRpb25DbGlwcyA9IFRIUkVFLkFuaW1hdGlvbkNsaXAuQ3JlYXRlQ2xpcHNGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZXMoIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cywgMTAgKTtcclxuICAgICAgICAgICAgICAgIG91dHB1dEFuaW1hdGlvbnMgPSBvdXRwdXRBbmltYXRpb25zLmNvbmNhdCggbW9ycGhBbmltYXRpb25DbGlwcyApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBvdXRwdXRBbmltYXRpb25zLmxlbmd0aCA+IDAgKSBnZW9tZXRyeS5hbmltYXRpb25zID0gb3V0cHV0QW5pbWF0aW9ucztcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKCBqc29uLm1hdGVyaWFscyA9PT0gdW5kZWZpbmVkIHx8IGpzb24ubWF0ZXJpYWxzLmxlbmd0aCA9PT0gMCApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7IGdlb21ldHJ5OiBnZW9tZXRyeSB9O1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgdmFyIG1hdGVyaWFscyA9IFRIUkVFLkxvYWRlci5wcm90b3R5cGUuaW5pdE1hdGVyaWFscygganNvbi5tYXRlcmlhbHMsIHRleHR1cmVQYXRoLCB0aGlzLmNyb3NzT3JpZ2luICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4geyBnZW9tZXRyeTogZ2VvbWV0cnksIG1hdGVyaWFsczogbWF0ZXJpYWxzIH07XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbG9hZGVycy9Mb2FkaW5nTWFuYWdlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTG9hZGluZ01hbmFnZXIgPSBmdW5jdGlvbiAoIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuICAgIHZhciBpc0xvYWRpbmcgPSBmYWxzZSwgaXRlbXNMb2FkZWQgPSAwLCBpdGVtc1RvdGFsID0gMDtcclxuXHJcbiAgICB0aGlzLm9uU3RhcnQgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLm9uTG9hZCA9IG9uTG9hZDtcclxuICAgIHRoaXMub25Qcm9ncmVzcyA9IG9uUHJvZ3Jlc3M7XHJcbiAgICB0aGlzLm9uRXJyb3IgPSBvbkVycm9yO1xyXG5cclxuICAgIHRoaXMuaXRlbVN0YXJ0ID0gZnVuY3Rpb24gKCB1cmwgKSB7XHJcblxyXG4gICAgICAgIGl0ZW1zVG90YWwgKys7XHJcblxyXG4gICAgICAgIGlmICggaXNMb2FkaW5nID09PSBmYWxzZSApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggc2NvcGUub25TdGFydCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHNjb3BlLm9uU3RhcnQoIHVybCwgaXRlbXNMb2FkZWQsIGl0ZW1zVG90YWwgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpc0xvYWRpbmcgPSB0cnVlO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5pdGVtRW5kID0gZnVuY3Rpb24gKCB1cmwgKSB7XHJcblxyXG4gICAgICAgIGl0ZW1zTG9hZGVkICsrO1xyXG5cclxuICAgICAgICBpZiAoIHNjb3BlLm9uUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIHNjb3BlLm9uUHJvZ3Jlc3MoIHVybCwgaXRlbXNMb2FkZWQsIGl0ZW1zVG90YWwgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIGl0ZW1zTG9hZGVkID09PSBpdGVtc1RvdGFsICkge1xyXG5cclxuICAgICAgICAgICAgaXNMb2FkaW5nID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHNjb3BlLm9uTG9hZCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHNjb3BlLm9uTG9hZCgpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLml0ZW1FcnJvciA9IGZ1bmN0aW9uICggdXJsICkge1xyXG5cclxuICAgICAgICBpZiAoIHNjb3BlLm9uRXJyb3IgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIHNjb3BlLm9uRXJyb3IoIHVybCApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXIgPSBuZXcgVEhSRUUuTG9hZGluZ01hbmFnZXIoKTtcclxuXHJcbi8vIEZpbGU6c3JjL2xvYWRlcnMvQnVmZmVyR2VvbWV0cnlMb2FkZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkJ1ZmZlckdlb21ldHJ5TG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xyXG5cclxuICAgIHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkJ1ZmZlckdlb21ldHJ5TG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuQnVmZmVyR2VvbWV0cnlMb2FkZXIsXHJcblxyXG4gICAgbG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcclxuXHJcbiAgICAgICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcclxuICAgICAgICBsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcclxuICAgICAgICBsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XHJcblxyXG4gICAgICAgICAgICBvbkxvYWQoIHNjb3BlLnBhcnNlKCBKU09OLnBhcnNlKCB0ZXh0ICkgKSApO1xyXG5cclxuICAgICAgICB9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcGFyc2U6IGZ1bmN0aW9uICgganNvbiApIHtcclxuXHJcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XHJcblxyXG4gICAgICAgIHZhciBpbmRleCA9IGpzb24uZGF0YS5pbmRleDtcclxuXHJcbiAgICAgICAgaWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHR5cGVkQXJyYXkgPSBuZXcgc2VsZlsgaW5kZXgudHlwZSBdKCBpbmRleC5hcnJheSApO1xyXG4gICAgICAgICAgICBnZW9tZXRyeS5zZXRJbmRleCggbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdHlwZWRBcnJheSwgMSApICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBqc29uLmRhdGEuYXR0cmlidXRlcztcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGtleSBpbiBhdHRyaWJ1dGVzICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIGtleSBdO1xyXG4gICAgICAgICAgICB2YXIgdHlwZWRBcnJheSA9IG5ldyBzZWxmWyBhdHRyaWJ1dGUudHlwZSBdKCBhdHRyaWJ1dGUuYXJyYXkgKTtcclxuXHJcbiAgICAgICAgICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSgga2V5LCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB0eXBlZEFycmF5LCBhdHRyaWJ1dGUuaXRlbVNpemUgKSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBncm91cHMgPSBqc29uLmRhdGEuZ3JvdXBzIHx8IGpzb24uZGF0YS5kcmF3Y2FsbHMgfHwganNvbi5kYXRhLm9mZnNldHM7XHJcblxyXG4gICAgICAgIGlmICggZ3JvdXBzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIG4gPSBncm91cHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xyXG5cclxuICAgICAgICAgICAgICAgIGdlb21ldHJ5LmFkZEdyb3VwKCBncm91cC5zdGFydCwgZ3JvdXAuY291bnQgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYm91bmRpbmdTcGhlcmUgPSBqc29uLmRhdGEuYm91bmRpbmdTcGhlcmU7XHJcblxyXG4gICAgICAgIGlmICggYm91bmRpbmdTcGhlcmUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBjZW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBib3VuZGluZ1NwaGVyZS5jZW50ZXIgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjZW50ZXIuZnJvbUFycmF5KCBib3VuZGluZ1NwaGVyZS5jZW50ZXIgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggY2VudGVyLCBib3VuZGluZ1NwaGVyZS5yYWRpdXMgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZ2VvbWV0cnk7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2xvYWRlcnMvTWF0ZXJpYWxMb2FkZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLk1hdGVyaWFsTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xyXG5cclxuICAgIHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xyXG4gICAgdGhpcy50ZXh0dXJlcyA9IHt9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1hdGVyaWFsTG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuTWF0ZXJpYWxMb2FkZXIsXHJcblxyXG4gICAgbG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcclxuXHJcbiAgICAgICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcclxuICAgICAgICBsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcclxuICAgICAgICBsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XHJcblxyXG4gICAgICAgICAgICBvbkxvYWQoIHNjb3BlLnBhcnNlKCBKU09OLnBhcnNlKCB0ZXh0ICkgKSApO1xyXG5cclxuICAgICAgICB9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0VGV4dHVyZXM6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIHRoaXMudGV4dHVyZXMgPSB2YWx1ZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldFRleHR1cmU6IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcbiAgICAgICAgdmFyIHRleHR1cmVzID0gdGhpcy50ZXh0dXJlcztcclxuXHJcbiAgICAgICAgaWYgKCB0ZXh0dXJlc1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5NYXRlcmlhbExvYWRlcjogVW5kZWZpbmVkIHRleHR1cmUnLCBuYW1lICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRleHR1cmVzWyBuYW1lIF07XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBwYXJzZTogZnVuY3Rpb24gKCBqc29uICkge1xyXG5cclxuICAgICAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUVbIGpzb24udHlwZSBdO1xyXG4gICAgICAgIG1hdGVyaWFsLnV1aWQgPSBqc29uLnV1aWQ7XHJcblxyXG4gICAgICAgIGlmICgganNvbi5uYW1lICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5uYW1lID0ganNvbi5uYW1lO1xyXG4gICAgICAgIGlmICgganNvbi5jb2xvciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY29sb3Iuc2V0SGV4KCBqc29uLmNvbG9yICk7XHJcbiAgICAgICAgaWYgKCBqc29uLmVtaXNzaXZlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5lbWlzc2l2ZS5zZXRIZXgoIGpzb24uZW1pc3NpdmUgKTtcclxuICAgICAgICBpZiAoIGpzb24uc3BlY3VsYXIgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNwZWN1bGFyLnNldEhleCgganNvbi5zcGVjdWxhciApO1xyXG4gICAgICAgIGlmICgganNvbi5zaGluaW5lc3MgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNoaW5pbmVzcyA9IGpzb24uc2hpbmluZXNzO1xyXG4gICAgICAgIGlmICgganNvbi51bmlmb3JtcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudW5pZm9ybXMgPSBqc29uLnVuaWZvcm1zO1xyXG4gICAgICAgIGlmICgganNvbi52ZXJ0ZXhTaGFkZXIgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnZlcnRleFNoYWRlciA9IGpzb24udmVydGV4U2hhZGVyO1xyXG4gICAgICAgIGlmICgganNvbi5mcmFnbWVudFNoYWRlciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXIgPSBqc29uLmZyYWdtZW50U2hhZGVyO1xyXG4gICAgICAgIGlmICgganNvbi52ZXJ0ZXhDb2xvcnMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnZlcnRleENvbG9ycyA9IGpzb24udmVydGV4Q29sb3JzO1xyXG4gICAgICAgIGlmICgganNvbi5zaGFkaW5nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaGFkaW5nID0ganNvbi5zaGFkaW5nO1xyXG4gICAgICAgIGlmICgganNvbi5ibGVuZGluZyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYmxlbmRpbmcgPSBqc29uLmJsZW5kaW5nO1xyXG4gICAgICAgIGlmICgganNvbi5zaWRlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaWRlID0ganNvbi5zaWRlO1xyXG4gICAgICAgIGlmICgganNvbi5vcGFjaXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5vcGFjaXR5ID0ganNvbi5vcGFjaXR5O1xyXG4gICAgICAgIGlmICgganNvbi50cmFuc3BhcmVudCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudHJhbnNwYXJlbnQgPSBqc29uLnRyYW5zcGFyZW50O1xyXG4gICAgICAgIGlmICgganNvbi5hbHBoYVRlc3QgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmFscGhhVGVzdCA9IGpzb24uYWxwaGFUZXN0O1xyXG4gICAgICAgIGlmICgganNvbi5kZXB0aFRlc3QgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRlcHRoVGVzdCA9IGpzb24uZGVwdGhUZXN0O1xyXG4gICAgICAgIGlmICgganNvbi5kZXB0aFdyaXRlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kZXB0aFdyaXRlID0ganNvbi5kZXB0aFdyaXRlO1xyXG4gICAgICAgIGlmICgganNvbi53aXJlZnJhbWUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLndpcmVmcmFtZSA9IGpzb24ud2lyZWZyYW1lO1xyXG4gICAgICAgIGlmICgganNvbi53aXJlZnJhbWVMaW5ld2lkdGggIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCA9IGpzb24ud2lyZWZyYW1lTGluZXdpZHRoO1xyXG5cclxuICAgICAgICAvLyBmb3IgUG9pbnRzTWF0ZXJpYWxcclxuICAgICAgICBpZiAoIGpzb24uc2l6ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2l6ZSA9IGpzb24uc2l6ZTtcclxuICAgICAgICBpZiAoIGpzb24uc2l6ZUF0dGVudWF0aW9uICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaXplQXR0ZW51YXRpb24gPSBqc29uLnNpemVBdHRlbnVhdGlvbjtcclxuXHJcbiAgICAgICAgLy8gbWFwc1xyXG5cclxuICAgICAgICBpZiAoIGpzb24ubWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5tYXAgPSB0aGlzLmdldFRleHR1cmUoIGpzb24ubWFwICk7XHJcblxyXG4gICAgICAgIGlmICgganNvbi5hbHBoYU1hcCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgbWF0ZXJpYWwuYWxwaGFNYXAgPSB0aGlzLmdldFRleHR1cmUoIGpzb24uYWxwaGFNYXAgKTtcclxuICAgICAgICAgICAgbWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgganNvbi5idW1wTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5idW1wTWFwID0gdGhpcy5nZXRUZXh0dXJlKCBqc29uLmJ1bXBNYXAgKTtcclxuICAgICAgICBpZiAoIGpzb24uYnVtcFNjYWxlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5idW1wU2NhbGUgPSBqc29uLmJ1bXBTY2FsZTtcclxuXHJcbiAgICAgICAgaWYgKCBqc29uLm5vcm1hbE1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubm9ybWFsTWFwID0gdGhpcy5nZXRUZXh0dXJlKCBqc29uLm5vcm1hbE1hcCApO1xyXG4gICAgICAgIGlmICgganNvbi5ub3JtYWxTY2FsZSApXHRtYXRlcmlhbC5ub3JtYWxTY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBqc29uLm5vcm1hbFNjYWxlLCBqc29uLm5vcm1hbFNjYWxlICk7XHJcblxyXG4gICAgICAgIGlmICgganNvbi5kaXNwbGFjZW1lbnRNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5kaXNwbGFjZW1lbnRNYXAgKTtcclxuICAgICAgICBpZiAoIGpzb24uZGlzcGxhY2VtZW50U2NhbGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlID0ganNvbi5kaXNwbGFjZW1lbnRTY2FsZTtcclxuICAgICAgICBpZiAoIGpzb24uZGlzcGxhY2VtZW50QmlhcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGlzcGxhY2VtZW50QmlhcyA9IGpzb24uZGlzcGxhY2VtZW50QmlhcztcclxuXHJcbiAgICAgICAgaWYgKCBqc29uLnNwZWN1bGFyTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zcGVjdWxhck1hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5zcGVjdWxhck1hcCApO1xyXG5cclxuICAgICAgICBpZiAoIGpzb24uZW52TWFwICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBtYXRlcmlhbC5lbnZNYXAgPSB0aGlzLmdldFRleHR1cmUoIGpzb24uZW52TWFwICk7XHJcbiAgICAgICAgICAgIG1hdGVyaWFsLmNvbWJpbmUgPSBUSFJFRS5NdWx0aXBseU9wZXJhdGlvbjtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIGpzb24ucmVmbGVjdGl2aXR5ICkgbWF0ZXJpYWwucmVmbGVjdGl2aXR5ID0ganNvbi5yZWZsZWN0aXZpdHk7XHJcblxyXG4gICAgICAgIGlmICgganNvbi5saWdodE1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubGlnaHRNYXAgPSB0aGlzLmdldFRleHR1cmUoIGpzb24ubGlnaHRNYXAgKTtcclxuICAgICAgICBpZiAoIGpzb24ubGlnaHRNYXBJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmxpZ2h0TWFwSW50ZW5zaXR5ID0ganNvbi5saWdodE1hcEludGVuc2l0eTtcclxuXHJcbiAgICAgICAgaWYgKCBqc29uLmFvTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hb01hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5hb01hcCApO1xyXG4gICAgICAgIGlmICgganNvbi5hb01hcEludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYW9NYXBJbnRlbnNpdHkgPSBqc29uLmFvTWFwSW50ZW5zaXR5O1xyXG5cclxuICAgICAgICAvLyBNZXNoRmFjZU1hdGVyaWFsXHJcblxyXG4gICAgICAgIGlmICgganNvbi5tYXRlcmlhbHMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubWF0ZXJpYWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwubWF0ZXJpYWxzLnB1c2goIHRoaXMucGFyc2UoIGpzb24ubWF0ZXJpYWxzWyBpIF0gKSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBtYXRlcmlhbDtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbG9hZGVycy9PYmplY3RMb2FkZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLk9iamVjdExvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcclxuXHJcbiAgICB0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcclxuICAgIHRoaXMudGV4dHVyZVBhdGggPSAnJztcclxuXHJcbn07XHJcblxyXG5USFJFRS5PYmplY3RMb2FkZXIucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5PYmplY3RMb2FkZXIsXHJcblxyXG4gICAgbG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLnRleHR1cmVQYXRoID09PSAnJyApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZVBhdGggPSB1cmwuc3Vic3RyaW5nKCAwLCB1cmwubGFzdEluZGV4T2YoICcvJyApICsgMSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG4gICAgICAgIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuWEhSTG9hZGVyKCBzY29wZS5tYW5hZ2VyICk7XHJcbiAgICAgICAgbG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XHJcbiAgICAgICAgbG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xyXG5cclxuICAgICAgICAgICAgc2NvcGUucGFyc2UoIEpTT04ucGFyc2UoIHRleHQgKSwgb25Mb2FkICk7XHJcblxyXG4gICAgICAgIH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldFRleHR1cmVQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuICAgICAgICB0aGlzLnRleHR1cmVQYXRoID0gdmFsdWU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcGFyc2U6IGZ1bmN0aW9uICgganNvbiwgb25Mb2FkICkge1xyXG5cclxuICAgICAgICB2YXIgZ2VvbWV0cmllcyA9IHRoaXMucGFyc2VHZW9tZXRyaWVzKCBqc29uLmdlb21ldHJpZXMgKTtcclxuXHJcbiAgICAgICAgdmFyIGltYWdlcyA9IHRoaXMucGFyc2VJbWFnZXMoIGpzb24uaW1hZ2VzLCBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkgb25Mb2FkKCBvYmplY3QgKTtcclxuXHJcbiAgICAgICAgfSApO1xyXG5cclxuICAgICAgICB2YXIgdGV4dHVyZXMgID0gdGhpcy5wYXJzZVRleHR1cmVzKCBqc29uLnRleHR1cmVzLCBpbWFnZXMgKTtcclxuICAgICAgICB2YXIgbWF0ZXJpYWxzID0gdGhpcy5wYXJzZU1hdGVyaWFscygganNvbi5tYXRlcmlhbHMsIHRleHR1cmVzICk7XHJcblxyXG4gICAgICAgIHZhciBvYmplY3QgPSB0aGlzLnBhcnNlT2JqZWN0KCBqc29uLm9iamVjdCwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzICk7XHJcblxyXG4gICAgICAgIGlmICgganNvbi5hbmltYXRpb25zICkge1xyXG5cclxuICAgICAgICAgICAgb2JqZWN0LmFuaW1hdGlvbnMgPSB0aGlzLnBhcnNlQW5pbWF0aW9ucygganNvbi5hbmltYXRpb25zICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBqc29uLmltYWdlcyA9PT0gdW5kZWZpbmVkIHx8IGpzb24uaW1hZ2VzLmxlbmd0aCA9PT0gMCApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggb25Mb2FkICE9PSB1bmRlZmluZWQgKSBvbkxvYWQoIG9iamVjdCApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvYmplY3Q7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBwYXJzZUdlb21ldHJpZXM6IGZ1bmN0aW9uICgganNvbiApIHtcclxuXHJcbiAgICAgICAgdmFyIGdlb21ldHJpZXMgPSB7fTtcclxuXHJcbiAgICAgICAgaWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgZ2VvbWV0cnlMb2FkZXIgPSBuZXcgVEhSRUUuSlNPTkxvYWRlcigpO1xyXG4gICAgICAgICAgICB2YXIgYnVmZmVyR2VvbWV0cnlMb2FkZXIgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnlMb2FkZXIoKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZ2VvbWV0cnk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGpzb25bIGkgXTtcclxuXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKCBkYXRhLnR5cGUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1BsYW5lR2VvbWV0cnknOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1BsYW5lQnVmZmVyR2VvbWV0cnknOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUVbIGRhdGEudHlwZSBdKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS53aWR0aFNlZ21lbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5oZWlnaHRTZWdtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0JveEdlb21ldHJ5JzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdDdWJlR2VvbWV0cnknOiAvLyBiYWNrd2FyZHMgY29tcGF0aWJsZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQm94R2VvbWV0cnkoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmRlcHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS53aWR0aFNlZ21lbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5oZWlnaHRTZWdtZW50cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZGVwdGhTZWdtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0NpcmNsZUJ1ZmZlckdlb21ldHJ5JzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkNpcmNsZUJ1ZmZlckdlb21ldHJ5KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yYWRpdXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNlZ21lbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50aGV0YVN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50aGV0YUxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0NpcmNsZUdlb21ldHJ5JzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkNpcmNsZUdlb21ldHJ5KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yYWRpdXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNlZ21lbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50aGV0YVN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50aGV0YUxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0N5bGluZGVyR2VvbWV0cnknOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucmFkaXVzVG9wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yYWRpdXNCb3R0b20sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucmFkaWFsU2VnbWVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmhlaWdodFNlZ21lbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5vcGVuRW5kZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnRoZXRhU3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnRoZXRhTGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnU3BoZXJlR2VvbWV0cnknOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJhZGl1cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEud2lkdGhTZWdtZW50cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuaGVpZ2h0U2VnbWVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnBoaVN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5waGlMZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnRoZXRhU3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnRoZXRhTGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnU3BoZXJlQnVmZmVyR2VvbWV0cnknOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnkoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJhZGl1cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEud2lkdGhTZWdtZW50cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuaGVpZ2h0U2VnbWVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnBoaVN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5waGlMZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnRoZXRhU3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnRoZXRhTGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnRG9kZWNhaGVkcm9uR2VvbWV0cnknOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuRG9kZWNhaGVkcm9uR2VvbWV0cnkoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJhZGl1cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZGV0YWlsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSWNvc2FoZWRyb25HZW9tZXRyeSc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yYWRpdXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmRldGFpbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ09jdGFoZWRyb25HZW9tZXRyeSc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5PY3RhaGVkcm9uR2VvbWV0cnkoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJhZGl1cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZGV0YWlsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVGV0cmFoZWRyb25HZW9tZXRyeSc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5UZXRyYWhlZHJvbkdlb21ldHJ5KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yYWRpdXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmRldGFpbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1JpbmdHZW9tZXRyeSc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5SaW5nR2VvbWV0cnkoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmlubmVyUmFkaXVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5vdXRlclJhZGl1cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudGhldGFTZWdtZW50cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucGhpU2VnbWVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnRoZXRhU3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnRoZXRhTGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVG9ydXNHZW9tZXRyeSc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5Ub3J1c0dlb21ldHJ5KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yYWRpdXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnR1YmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJhZGlhbFNlZ21lbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50dWJ1bGFyU2VnbWVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmFyY1xyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1RvcnVzS25vdEdlb21ldHJ5JzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRvcnVzS25vdEdlb21ldHJ5KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yYWRpdXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnR1YmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJhZGlhbFNlZ21lbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50dWJ1bGFyU2VnbWVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmhlaWdodFNjYWxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQnVmZmVyR2VvbWV0cnknOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBidWZmZXJHZW9tZXRyeUxvYWRlci5wYXJzZSggZGF0YSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0dlb21ldHJ5JzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0gZ2VvbWV0cnlMb2FkZXIucGFyc2UoIGRhdGEuZGF0YSwgdGhpcy50ZXh0dXJlUGF0aCApLmdlb21ldHJ5O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuc3VwcG9ydGVkIGdlb21ldHJ5IHR5cGUgXCInICsgZGF0YS50eXBlICsgJ1wiJyApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGdlb21ldHJ5LnV1aWQgPSBkYXRhLnV1aWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhLm5hbWUgIT09IHVuZGVmaW5lZCApIGdlb21ldHJ5Lm5hbWUgPSBkYXRhLm5hbWU7XHJcblxyXG4gICAgICAgICAgICAgICAgZ2VvbWV0cmllc1sgZGF0YS51dWlkIF0gPSBnZW9tZXRyeTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZ2VvbWV0cmllcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHBhcnNlTWF0ZXJpYWxzOiBmdW5jdGlvbiAoIGpzb24sIHRleHR1cmVzICkge1xyXG5cclxuICAgICAgICB2YXIgbWF0ZXJpYWxzID0ge307XHJcblxyXG4gICAgICAgIGlmICgganNvbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5NYXRlcmlhbExvYWRlcigpO1xyXG4gICAgICAgICAgICBsb2FkZXIuc2V0VGV4dHVyZXMoIHRleHR1cmVzICk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG1hdGVyaWFsID0gbG9hZGVyLnBhcnNlKCBqc29uWyBpIF0gKTtcclxuICAgICAgICAgICAgICAgIG1hdGVyaWFsc1sgbWF0ZXJpYWwudXVpZCBdID0gbWF0ZXJpYWw7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG1hdGVyaWFscztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHBhcnNlQW5pbWF0aW9uczogZnVuY3Rpb24gKCBqc29uICkge1xyXG5cclxuICAgICAgICB2YXIgYW5pbWF0aW9ucyA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBqc29uLmxlbmd0aDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBjbGlwID0gVEhSRUUuQW5pbWF0aW9uQ2xpcC5wYXJzZSgganNvbltpXSApO1xyXG5cclxuICAgICAgICAgICAgYW5pbWF0aW9ucy5wdXNoKCBjbGlwICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGFuaW1hdGlvbnM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBwYXJzZUltYWdlczogZnVuY3Rpb24gKCBqc29uLCBvbkxvYWQgKSB7XHJcblxyXG4gICAgICAgIHZhciBzY29wZSA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGltYWdlcyA9IHt9O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBsb2FkSW1hZ2UoIHVybCApIHtcclxuXHJcbiAgICAgICAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgc2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcclxuXHJcbiAgICAgICAgICAgIH0gKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIGpzb24gIT09IHVuZGVmaW5lZCAmJiBqc29uLmxlbmd0aCA+IDAgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbWFuYWdlciA9IG5ldyBUSFJFRS5Mb2FkaW5nTWFuYWdlciggb25Mb2FkICk7XHJcblxyXG4gICAgICAgICAgICB2YXIgbG9hZGVyID0gbmV3IFRIUkVFLkltYWdlTG9hZGVyKCBtYW5hZ2VyICk7XHJcbiAgICAgICAgICAgIGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBpbWFnZSA9IGpzb25bIGkgXTtcclxuICAgICAgICAgICAgICAgIHZhciBwYXRoID0gL14oXFwvXFwvKXwoW2Etel0rOihcXC9cXC8pPykvaS50ZXN0KCBpbWFnZS51cmwgKSA/IGltYWdlLnVybCA6IHNjb3BlLnRleHR1cmVQYXRoICsgaW1hZ2UudXJsO1xyXG5cclxuICAgICAgICAgICAgICAgIGltYWdlc1sgaW1hZ2UudXVpZCBdID0gbG9hZEltYWdlKCBwYXRoICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGltYWdlcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHBhcnNlVGV4dHVyZXM6IGZ1bmN0aW9uICgganNvbiwgaW1hZ2VzICkge1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBwYXJzZUNvbnN0YW50KCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggdHlwZW9mKCB2YWx1ZSApID09PSAnbnVtYmVyJyApIHJldHVybiB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlci5wYXJzZVRleHR1cmU6IENvbnN0YW50IHNob3VsZCBiZSBpbiBudW1lcmljIGZvcm0uJywgdmFsdWUgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBUSFJFRVsgdmFsdWUgXTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdGV4dHVyZXMgPSB7fTtcclxuXHJcbiAgICAgICAgaWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBqc29uWyBpIF07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhLmltYWdlID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogTm8gXCJpbWFnZVwiIHNwZWNpZmllZCBmb3InLCBkYXRhLnV1aWQgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBpbWFnZXNbIGRhdGEuaW1hZ2UgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBpbWFnZScsIGRhdGEuaW1hZ2UgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuVGV4dHVyZSggaW1hZ2VzWyBkYXRhLmltYWdlIF0gKTtcclxuICAgICAgICAgICAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIHRleHR1cmUudXVpZCA9IGRhdGEudXVpZDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGRhdGEubmFtZSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5uYW1lID0gZGF0YS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhLm1hcHBpbmcgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubWFwcGluZyA9IHBhcnNlQ29uc3RhbnQoIGRhdGEubWFwcGluZyApO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhLm9mZnNldCAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5vZmZzZXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggZGF0YS5vZmZzZXRbIDAgXSwgZGF0YS5vZmZzZXRbIDEgXSApO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhLnJlcGVhdCAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5yZXBlYXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggZGF0YS5yZXBlYXRbIDAgXSwgZGF0YS5yZXBlYXRbIDEgXSApO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhLm1pbkZpbHRlciAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5taW5GaWx0ZXIgPSBwYXJzZUNvbnN0YW50KCBkYXRhLm1pbkZpbHRlciApO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhLm1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5tYWdGaWx0ZXIgPSBwYXJzZUNvbnN0YW50KCBkYXRhLm1hZ0ZpbHRlciApO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhLmFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCApIHRleHR1cmUuYW5pc290cm9weSA9IGRhdGEuYW5pc290cm9weTtcclxuICAgICAgICAgICAgICAgIGlmICggQXJyYXkuaXNBcnJheSggZGF0YS53cmFwICkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUud3JhcFMgPSBwYXJzZUNvbnN0YW50KCBkYXRhLndyYXBbIDAgXSApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUud3JhcFQgPSBwYXJzZUNvbnN0YW50KCBkYXRhLndyYXBbIDEgXSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlc1sgZGF0YS51dWlkIF0gPSB0ZXh0dXJlO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0dXJlcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHBhcnNlT2JqZWN0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCBkYXRhLCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgb2JqZWN0O1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0R2VvbWV0cnkoIG5hbWUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBnZW9tZXRyaWVzWyBuYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgZ2VvbWV0cnknLCBuYW1lICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBnZW9tZXRyaWVzWyBuYW1lIF07XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRNYXRlcmlhbCggbmFtZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIG5hbWUgPT09IHVuZGVmaW5lZCApIHJldHVybiB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBtYXRlcmlhbHNbIG5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBtYXRlcmlhbCcsIG5hbWUgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGVyaWFsc1sgbmFtZSBdO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc3dpdGNoICggZGF0YS50eXBlICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ1NjZW5lJzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLlNjZW5lKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ1BlcnNwZWN0aXZlQ2FtZXJhJzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBkYXRhLmZvdiwgZGF0YS5hc3BlY3QsIGRhdGEubmVhciwgZGF0YS5mYXIgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnT3J0aG9ncmFwaGljQ2FtZXJhJzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSggZGF0YS5sZWZ0LCBkYXRhLnJpZ2h0LCBkYXRhLnRvcCwgZGF0YS5ib3R0b20sIGRhdGEubmVhciwgZGF0YS5mYXIgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnQW1iaWVudExpZ2h0JzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLkFtYmllbnRMaWdodCggZGF0YS5jb2xvciApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdEaXJlY3Rpb25hbExpZ2h0JzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ1BvaW50TGlnaHQnOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSBuZXcgVEhSRUUuUG9pbnRMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHksIGRhdGEuZGlzdGFuY2UsIGRhdGEuZGVjYXkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnU3BvdExpZ2h0JzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLlNwb3RMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHksIGRhdGEuZGlzdGFuY2UsIGRhdGEuYW5nbGUsIGRhdGEuZXhwb25lbnQsIGRhdGEuZGVjYXkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnSGVtaXNwaGVyZUxpZ2h0JzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLkhlbWlzcGhlcmVMaWdodCggZGF0YS5jb2xvciwgZGF0YS5ncm91bmRDb2xvciwgZGF0YS5pbnRlbnNpdHkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnTWVzaCc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5NZXNoKCBnZXRHZW9tZXRyeSggZGF0YS5nZW9tZXRyeSApLCBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ0xPRCc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5MT0QoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnTGluZSc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5MaW5lKCBnZXRHZW9tZXRyeSggZGF0YS5nZW9tZXRyeSApLCBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApLCBkYXRhLm1vZGUgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnUG9pbnRDbG91ZCc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdQb2ludHMnOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSBuZXcgVEhSRUUuUG9pbnRzKCBnZXRHZW9tZXRyeSggZGF0YS5nZW9tZXRyeSApLCBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ1Nwcml0ZSc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5TcHJpdGUoIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnR3JvdXAnOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSBuZXcgVEhSRUUuR3JvdXAoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBvYmplY3QudXVpZCA9IGRhdGEudXVpZDtcclxuXHJcbiAgICAgICAgICAgIGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSBvYmplY3QubmFtZSA9IGRhdGEubmFtZTtcclxuICAgICAgICAgICAgaWYgKCBkYXRhLm1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIG1hdHJpeC5mcm9tQXJyYXkoIGRhdGEubWF0cml4ICk7XHJcbiAgICAgICAgICAgICAgICBtYXRyaXguZGVjb21wb3NlKCBvYmplY3QucG9zaXRpb24sIG9iamVjdC5xdWF0ZXJuaW9uLCBvYmplY3Quc2NhbGUgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhLnBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSBvYmplY3QucG9zaXRpb24uZnJvbUFycmF5KCBkYXRhLnBvc2l0aW9uICk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIGRhdGEucm90YXRpb24gIT09IHVuZGVmaW5lZCApIG9iamVjdC5yb3RhdGlvbi5mcm9tQXJyYXkoIGRhdGEucm90YXRpb24gKTtcclxuICAgICAgICAgICAgICAgIGlmICggZGF0YS5zY2FsZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnNjYWxlLmZyb21BcnJheSggZGF0YS5zY2FsZSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBkYXRhLmNhc3RTaGFkb3cgIT09IHVuZGVmaW5lZCApIG9iamVjdC5jYXN0U2hhZG93ID0gZGF0YS5jYXN0U2hhZG93O1xyXG4gICAgICAgICAgICBpZiAoIGRhdGEucmVjZWl2ZVNoYWRvdyAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnJlY2VpdmVTaGFkb3cgPSBkYXRhLnJlY2VpdmVTaGFkb3c7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGRhdGEudmlzaWJsZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnZpc2libGUgPSBkYXRhLnZpc2libGU7XHJcbiAgICAgICAgICAgIGlmICggZGF0YS51c2VyRGF0YSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnVzZXJEYXRhID0gZGF0YS51c2VyRGF0YTtcclxuXHJcbiAgICAgICAgICAgIGlmICggZGF0YS5jaGlsZHJlbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBjaGlsZCBpbiBkYXRhLmNoaWxkcmVuICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuYWRkKCB0aGlzLnBhcnNlT2JqZWN0KCBkYXRhLmNoaWxkcmVuWyBjaGlsZCBdLCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMgKSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggZGF0YS50eXBlID09PSAnTE9EJyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbGV2ZWxzID0gZGF0YS5sZXZlbHM7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGwgPSAwOyBsIDwgbGV2ZWxzLmxlbmd0aDsgbCArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxldmVsID0gbGV2ZWxzWyBsIF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gb2JqZWN0LmdldE9iamVjdEJ5UHJvcGVydHkoICd1dWlkJywgbGV2ZWwub2JqZWN0ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggY2hpbGQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5hZGRMZXZlbCggY2hpbGQsIGxldmVsLmRpc3RhbmNlICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSgpXHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbG9hZGVycy9UZXh0dXJlTG9hZGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5UZXh0dXJlTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xyXG5cclxuICAgIHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlRleHR1cmVMb2FkZXIucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5UZXh0dXJlTG9hZGVyLFxyXG5cclxuICAgIGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XHJcblxyXG4gICAgICAgIHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoKTtcclxuXHJcbiAgICAgICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5JbWFnZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XHJcbiAgICAgICAgbG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XHJcbiAgICAgICAgbG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBpbWFnZSApIHtcclxuXHJcbiAgICAgICAgICAgIHRleHR1cmUuaW1hZ2UgPSBpbWFnZTtcclxuICAgICAgICAgICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIG9uTG9hZCggdGV4dHVyZSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbG9hZGVycy9DdWJlVGV4dHVyZUxvYWRlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQ3ViZVRleHR1cmVMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XHJcblxyXG4gICAgdGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ3ViZVRleHR1cmVMb2FkZXIucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5DdWJlVGV4dHVyZUxvYWRlcixcclxuXHJcbiAgICBsb2FkOiBmdW5jdGlvbiAoIHVybHMsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcbiAgICAgICAgdmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuQ3ViZVRleHR1cmUoIFtdICk7XHJcblxyXG4gICAgICAgIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuSW1hZ2VMb2FkZXIoKTtcclxuICAgICAgICBsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcclxuXHJcbiAgICAgICAgdmFyIGxvYWRlZCA9IDA7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGxvYWRUZXh0dXJlKCBpICkge1xyXG5cclxuICAgICAgICAgICAgbG9hZGVyLmxvYWQoIHVybHNbIGkgXSwgZnVuY3Rpb24gKCBpbWFnZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLmltYWdlc1sgaSBdID0gaW1hZ2U7XHJcblxyXG4gICAgICAgICAgICAgICAgbG9hZGVkICsrO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggbG9hZGVkID09PSA2ICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9LCB1bmRlZmluZWQsIG9uRXJyb3IgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB1cmxzLmxlbmd0aDsgKysgaSApIHtcclxuXHJcbiAgICAgICAgICAgIGxvYWRUZXh0dXJlKCBpICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0JpbmFyeVRleHR1cmVMb2FkZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIE5pa29zIE0uIC8gaHR0cHM6Ly9naXRodWIuY29tL2ZvbzEyMy9cclxuICpcclxuICogQWJzdHJhY3QgQmFzZSBjbGFzcyB0byBsb2FkIGdlbmVyaWMgYmluYXJ5IHRleHR1cmVzIGZvcm1hdHMgKHJnYmUsIGhkciwgLi4uKVxyXG4gKi9cclxuXHJcblRIUkVFLkRhdGFUZXh0dXJlTG9hZGVyID0gVEhSRUUuQmluYXJ5VGV4dHVyZUxvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcclxuXHJcbiAgICB0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcclxuXHJcbiAgICAvLyBvdmVycmlkZSBpbiBzdWIgY2xhc3Nlc1xyXG4gICAgdGhpcy5fcGFyc2VyID0gbnVsbDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5CaW5hcnlUZXh0dXJlTG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuQmluYXJ5VGV4dHVyZUxvYWRlcixcclxuXHJcbiAgICBsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xyXG5cclxuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuICAgICAgICB2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5EYXRhVGV4dHVyZSgpO1xyXG5cclxuICAgICAgICB2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlciggdGhpcy5tYW5hZ2VyICk7XHJcbiAgICAgICAgbG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XHJcbiAgICAgICAgbG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2FycmF5YnVmZmVyJyApO1xyXG5cclxuICAgICAgICBsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciB0ZXhEYXRhID0gc2NvcGUuX3BhcnNlciggYnVmZmVyICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoICEgdGV4RGF0YSApIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGlmICggdW5kZWZpbmVkICE9PSB0ZXhEYXRhLmltYWdlICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHRleHR1cmUuaW1hZ2UgPSB0ZXhEYXRhLmltYWdlO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIGlmICggdW5kZWZpbmVkICE9PSB0ZXhEYXRhLmRhdGEgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGV4dHVyZS5pbWFnZS53aWR0aCA9IHRleERhdGEud2lkdGg7XHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLmltYWdlLmhlaWdodCA9IHRleERhdGEuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdGV4dHVyZS5pbWFnZS5kYXRhID0gdGV4RGF0YS5kYXRhO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGV4dHVyZS53cmFwUyA9IHVuZGVmaW5lZCAhPT0gdGV4RGF0YS53cmFwUyA/IHRleERhdGEud3JhcFMgOiBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nO1xyXG4gICAgICAgICAgICB0ZXh0dXJlLndyYXBUID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLndyYXBUID8gdGV4RGF0YS53cmFwVCA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XHJcblxyXG4gICAgICAgICAgICB0ZXh0dXJlLm1hZ0ZpbHRlciA9IHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5tYWdGaWx0ZXIgPyB0ZXhEYXRhLm1hZ0ZpbHRlciA6IFRIUkVFLkxpbmVhckZpbHRlcjtcclxuICAgICAgICAgICAgdGV4dHVyZS5taW5GaWx0ZXIgPSB1bmRlZmluZWQgIT09IHRleERhdGEubWluRmlsdGVyID8gdGV4RGF0YS5taW5GaWx0ZXIgOiBUSFJFRS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI7XHJcblxyXG4gICAgICAgICAgICB0ZXh0dXJlLmFuaXNvdHJvcHkgPSB1bmRlZmluZWQgIT09IHRleERhdGEuYW5pc290cm9weSA/IHRleERhdGEuYW5pc290cm9weSA6IDE7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5mb3JtYXQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGV4dHVyZS5mb3JtYXQgPSB0ZXhEYXRhLmZvcm1hdDtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEudHlwZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLnR5cGUgPSB0ZXhEYXRhLnR5cGU7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5taXBtYXBzICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHRleHR1cmUubWlwbWFwcyA9IHRleERhdGEubWlwbWFwcztcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggMSA9PT0gdGV4RGF0YS5taXBtYXBDb3VudCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLm1pbkZpbHRlciA9IFRIUkVFLkxpbmVhckZpbHRlcjtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUsIHRleERhdGEgKTtcclxuXHJcbiAgICAgICAgfSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xyXG5cclxuXHJcbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0NvbXByZXNzZWRUZXh0dXJlTG9hZGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICpcclxuICogQWJzdHJhY3QgQmFzZSBjbGFzcyB0byBibG9jayBiYXNlZCB0ZXh0dXJlcyBsb2FkZXIgKGRkcywgcHZyLCAuLi4pXHJcbiAqL1xyXG5cclxuVEhSRUUuQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XHJcblxyXG4gICAgdGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XHJcblxyXG4gICAgLy8gb3ZlcnJpZGUgaW4gc3ViIGNsYXNzZXNcclxuICAgIHRoaXMuX3BhcnNlciA9IG51bGw7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLkNvbXByZXNzZWRUZXh0dXJlTG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIsXHJcblxyXG4gICAgbG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcclxuXHJcbiAgICAgICAgdmFyIGltYWdlcyA9IFtdO1xyXG5cclxuICAgICAgICB2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5Db21wcmVzc2VkVGV4dHVyZSgpO1xyXG4gICAgICAgIHRleHR1cmUuaW1hZ2UgPSBpbWFnZXM7XHJcblxyXG4gICAgICAgIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuWEhSTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcclxuICAgICAgICBsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcclxuICAgICAgICBsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XHJcblxyXG4gICAgICAgIGlmICggQXJyYXkuaXNBcnJheSggdXJsICkgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbG9hZGVkID0gMDtcclxuXHJcbiAgICAgICAgICAgIHZhciBsb2FkVGV4dHVyZSA9IGZ1bmN0aW9uICggaSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBsb2FkZXIubG9hZCggdXJsWyBpIF0sIGZ1bmN0aW9uICggYnVmZmVyICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4RGF0YXMgPSBzY29wZS5fcGFyc2VyKCBidWZmZXIsIHRydWUgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyBpIF0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0ZXhEYXRhcy53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0ZXhEYXRhcy5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogdGV4RGF0YXMuZm9ybWF0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaXBtYXBzOiB0ZXhEYXRhcy5taXBtYXBzXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbG9hZGVkICs9IDE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggbG9hZGVkID09PSA2ICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0ZXhEYXRhcy5taXBtYXBDb3VudCA9PT0gMSApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLm1pbkZpbHRlciA9IFRIUkVFLkxpbmVhckZpbHRlcjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUuZm9ybWF0ID0gdGV4RGF0YXMuZm9ybWF0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggb25Mb2FkICkgb25Mb2FkKCB0ZXh0dXJlICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XHJcblxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHVybC5sZW5ndGg7IGkgPCBpbDsgKysgaSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBsb2FkVGV4dHVyZSggaSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgLy8gY29tcHJlc3NlZCBjdWJlbWFwIHRleHR1cmUgc3RvcmVkIGluIGEgc2luZ2xlIEREUyBmaWxlXHJcblxyXG4gICAgICAgICAgICBsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdGV4RGF0YXMgPSBzY29wZS5fcGFyc2VyKCBidWZmZXIsIHRydWUgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHRleERhdGFzLmlzQ3ViZW1hcCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZhY2VzID0gdGV4RGF0YXMubWlwbWFwcy5sZW5ndGggLyB0ZXhEYXRhcy5taXBtYXBDb3VudDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGYgPSAwOyBmIDwgZmFjZXM7IGYgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZXNbIGYgXSA9IHsgbWlwbWFwcyA6IFtdIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0ZXhEYXRhcy5taXBtYXBDb3VudDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZXNbIGYgXS5taXBtYXBzLnB1c2goIHRleERhdGFzLm1pcG1hcHNbIGYgKiB0ZXhEYXRhcy5taXBtYXBDb3VudCArIGkgXSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyBmIF0uZm9ybWF0ID0gdGV4RGF0YXMuZm9ybWF0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyBmIF0ud2lkdGggPSB0ZXhEYXRhcy53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlc1sgZiBdLmhlaWdodCA9IHRleERhdGFzLmhlaWdodDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUuaW1hZ2Uud2lkdGggPSB0ZXhEYXRhcy53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLmltYWdlLmhlaWdodCA9IHRleERhdGFzLmhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLm1pcG1hcHMgPSB0ZXhEYXRhcy5taXBtYXBzO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHRleERhdGFzLm1pcG1hcENvdW50ID09PSAxICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLm1pbkZpbHRlciA9IFRIUkVFLkxpbmVhckZpbHRlcjtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGV4dHVyZS5mb3JtYXQgPSB0ZXhEYXRhcy5mb3JtYXQ7XHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xyXG5cclxuICAgICAgICAgICAgfSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL01hdGVyaWFsLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5NYXRlcmlhbCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IFRIUkVFLk1hdGVyaWFsSWRDb3VudCArKyB9ICk7XHJcblxyXG4gICAgdGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcbiAgICB0aGlzLm5hbWUgPSAnJztcclxuICAgIHRoaXMudHlwZSA9ICdNYXRlcmlhbCc7XHJcblxyXG4gICAgdGhpcy5zaWRlID0gVEhSRUUuRnJvbnRTaWRlO1xyXG5cclxuICAgIHRoaXMub3BhY2l0eSA9IDE7XHJcbiAgICB0aGlzLnRyYW5zcGFyZW50ID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5ibGVuZGluZyA9IFRIUkVFLk5vcm1hbEJsZW5kaW5nO1xyXG5cclxuICAgIHRoaXMuYmxlbmRTcmMgPSBUSFJFRS5TcmNBbHBoYUZhY3RvcjtcclxuICAgIHRoaXMuYmxlbmREc3QgPSBUSFJFRS5PbmVNaW51c1NyY0FscGhhRmFjdG9yO1xyXG4gICAgdGhpcy5ibGVuZEVxdWF0aW9uID0gVEhSRUUuQWRkRXF1YXRpb247XHJcbiAgICB0aGlzLmJsZW5kU3JjQWxwaGEgPSBudWxsO1xyXG4gICAgdGhpcy5ibGVuZERzdEFscGhhID0gbnVsbDtcclxuICAgIHRoaXMuYmxlbmRFcXVhdGlvbkFscGhhID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLmRlcHRoRnVuYyA9IFRIUkVFLkxlc3NFcXVhbERlcHRoO1xyXG4gICAgdGhpcy5kZXB0aFRlc3QgPSB0cnVlO1xyXG4gICAgdGhpcy5kZXB0aFdyaXRlID0gdHJ1ZTtcclxuXHJcbiAgICB0aGlzLmNvbG9yV3JpdGUgPSB0cnVlO1xyXG5cclxuICAgIHRoaXMucHJlY2lzaW9uID0gbnVsbDsgLy8gb3ZlcnJpZGUgdGhlIHJlbmRlcmVyJ3MgZGVmYXVsdCBwcmVjaXNpb24gZm9yIHRoaXMgbWF0ZXJpYWxcclxuXHJcbiAgICB0aGlzLnBvbHlnb25PZmZzZXQgPSBmYWxzZTtcclxuICAgIHRoaXMucG9seWdvbk9mZnNldEZhY3RvciA9IDA7XHJcbiAgICB0aGlzLnBvbHlnb25PZmZzZXRVbml0cyA9IDA7XHJcblxyXG4gICAgdGhpcy5hbHBoYVRlc3QgPSAwO1xyXG5cclxuICAgIHRoaXMub3ZlcmRyYXcgPSAwOyAvLyBPdmVyZHJhd24gcGl4ZWxzICh0eXBpY2FsbHkgYmV0d2VlbiAwIGFuZCAxKSBmb3IgZml4aW5nIGFudGlhbGlhc2luZyBnYXBzIGluIENhbnZhc1JlbmRlcmVyXHJcblxyXG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcclxuXHJcbiAgICB0aGlzLl9uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5NYXRlcmlhbCxcclxuXHJcbiAgICBnZXQgbmVlZHNVcGRhdGUgKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5fbmVlZHNVcGRhdGU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXQgbmVlZHNVcGRhdGUgKCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgaWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudXBkYXRlKCk7XHJcblxyXG4gICAgICAgIHRoaXMuX25lZWRzVXBkYXRlID0gdmFsdWU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRWYWx1ZXM6IGZ1bmN0aW9uICggdmFsdWVzICkge1xyXG5cclxuICAgICAgICBpZiAoIHZhbHVlcyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIga2V5IGluIHZhbHVlcyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHZhbHVlc1sga2V5IF07XHJcblxyXG4gICAgICAgICAgICBpZiAoIG5ld1ZhbHVlID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCBcIlRIUkVFLk1hdGVyaWFsOiAnXCIgKyBrZXkgKyBcIicgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZC5cIiApO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgY3VycmVudFZhbHVlID0gdGhpc1sga2V5IF07XHJcblxyXG4gICAgICAgICAgICBpZiAoIGN1cnJlbnRWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggXCJUSFJFRS5cIiArIHRoaXMudHlwZSArIFwiOiAnXCIgKyBrZXkgKyBcIicgaXMgbm90IGEgcHJvcGVydHkgb2YgdGhpcyBtYXRlcmlhbC5cIiApO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIGN1cnJlbnRWYWx1ZSBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZS5zZXQoIG5ld1ZhbHVlICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBjdXJyZW50VmFsdWUgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzICYmIG5ld1ZhbHVlIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUuY29weSggbmV3VmFsdWUgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGtleSA9PT0gJ292ZXJkcmF3JyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgb3ZlcmRyYXcgaXMgYmFja3dhcmRzLWNvbXBhdGlibGUgd2l0aCBsZWdhY3kgYm9vbGVhbiB0eXBlXHJcbiAgICAgICAgICAgICAgICB0aGlzWyBrZXkgXSA9IE51bWJlciggbmV3VmFsdWUgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpc1sga2V5IF0gPSBuZXdWYWx1ZTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XHJcblxyXG4gICAgICAgIHZhciBkYXRhID0ge1xyXG4gICAgICAgICAgICBtZXRhZGF0YToge1xyXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogNC40LFxyXG4gICAgICAgICAgICAgICAgdHlwZTogJ01hdGVyaWFsJyxcclxuICAgICAgICAgICAgICAgIGdlbmVyYXRvcjogJ01hdGVyaWFsLnRvSlNPTidcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIHN0YW5kYXJkIE1hdGVyaWFsIHNlcmlhbGl6YXRpb25cclxuICAgICAgICBkYXRhLnV1aWQgPSB0aGlzLnV1aWQ7XHJcbiAgICAgICAgZGF0YS50eXBlID0gdGhpcy50eXBlO1xyXG4gICAgICAgIGlmICggdGhpcy5uYW1lICE9PSAnJyApIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLmNvbG9yIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgKSBkYXRhLmNvbG9yID0gdGhpcy5jb2xvci5nZXRIZXgoKTtcclxuICAgICAgICBpZiAoIHRoaXMuZW1pc3NpdmUgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciApIGRhdGEuZW1pc3NpdmUgPSB0aGlzLmVtaXNzaXZlLmdldEhleCgpO1xyXG4gICAgICAgIGlmICggdGhpcy5zcGVjdWxhciBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yICkgZGF0YS5zcGVjdWxhciA9IHRoaXMuc3BlY3VsYXIuZ2V0SGV4KCk7XHJcbiAgICAgICAgaWYgKCB0aGlzLnNoaW5pbmVzcyAhPT0gdW5kZWZpbmVkICkgZGF0YS5zaGluaW5lc3MgPSB0aGlzLnNoaW5pbmVzcztcclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLm1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSBkYXRhLm1hcCA9IHRoaXMubWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XHJcbiAgICAgICAgaWYgKCB0aGlzLmFscGhhTWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIGRhdGEuYWxwaGFNYXAgPSB0aGlzLmFscGhhTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XHJcbiAgICAgICAgaWYgKCB0aGlzLmxpZ2h0TWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIGRhdGEubGlnaHRNYXAgPSB0aGlzLmxpZ2h0TWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XHJcbiAgICAgICAgaWYgKCB0aGlzLmJ1bXBNYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkge1xyXG5cclxuICAgICAgICAgICAgZGF0YS5idW1wTWFwID0gdGhpcy5idW1wTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XHJcbiAgICAgICAgICAgIGRhdGEuYnVtcFNjYWxlID0gdGhpcy5idW1wU2NhbGU7XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIHRoaXMubm9ybWFsTWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIHtcclxuXHJcbiAgICAgICAgICAgIGRhdGEubm9ybWFsTWFwID0gdGhpcy5ub3JtYWxNYXAudG9KU09OKCBtZXRhICkudXVpZDtcclxuICAgICAgICAgICAgZGF0YS5ub3JtYWxTY2FsZSA9IHRoaXMubm9ybWFsU2NhbGU7IC8vIFJlbW92ZWQgZm9yIG5vdywgY2F1c2VzIGlzc3VlIGluIGVkaXRvciB1aS5qc1xyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCB0aGlzLmRpc3BsYWNlbWVudE1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSB7XHJcblxyXG4gICAgICAgICAgICBkYXRhLmRpc3BsYWNlbWVudE1hcCA9IHRoaXMuZGlzcGxhY2VtZW50TWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XHJcbiAgICAgICAgICAgIGRhdGEuZGlzcGxhY2VtZW50U2NhbGUgPSB0aGlzLmRpc3BsYWNlbWVudFNjYWxlO1xyXG4gICAgICAgICAgICBkYXRhLmRpc3BsYWNlbWVudEJpYXMgPSB0aGlzLmRpc3BsYWNlbWVudEJpYXM7XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIHRoaXMuc3BlY3VsYXJNYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkgZGF0YS5zcGVjdWxhck1hcCA9IHRoaXMuc3BlY3VsYXJNYXAudG9KU09OKCBtZXRhICkudXVpZDtcclxuICAgICAgICBpZiAoIHRoaXMuZW52TWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIHtcclxuXHJcbiAgICAgICAgICAgIGRhdGEuZW52TWFwID0gdGhpcy5lbnZNYXAudG9KU09OKCBtZXRhICkudXVpZDtcclxuICAgICAgICAgICAgZGF0YS5yZWZsZWN0aXZpdHkgPSB0aGlzLnJlZmxlY3Rpdml0eTsgLy8gU2NhbGUgYmVoaW5kIGVudk1hcFxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5zaXplICE9PSB1bmRlZmluZWQgKSBkYXRhLnNpemUgPSB0aGlzLnNpemU7XHJcbiAgICAgICAgaWYgKCB0aGlzLnNpemVBdHRlbnVhdGlvbiAhPT0gdW5kZWZpbmVkICkgZGF0YS5zaXplQXR0ZW51YXRpb24gPSB0aGlzLnNpemVBdHRlbnVhdGlvbjtcclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLnZlcnRleENvbG9ycyAhPT0gdW5kZWZpbmVkICYmIHRoaXMudmVydGV4Q29sb3JzICE9PSBUSFJFRS5Ob0NvbG9ycyApIGRhdGEudmVydGV4Q29sb3JzID0gdGhpcy52ZXJ0ZXhDb2xvcnM7XHJcbiAgICAgICAgaWYgKCB0aGlzLnNoYWRpbmcgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnNoYWRpbmcgIT09IFRIUkVFLlNtb290aFNoYWRpbmcgKSBkYXRhLnNoYWRpbmcgPSB0aGlzLnNoYWRpbmc7XHJcbiAgICAgICAgaWYgKCB0aGlzLmJsZW5kaW5nICE9PSB1bmRlZmluZWQgJiYgdGhpcy5ibGVuZGluZyAhPT0gVEhSRUUuTm9ybWFsQmxlbmRpbmcgKSBkYXRhLmJsZW5kaW5nID0gdGhpcy5ibGVuZGluZztcclxuICAgICAgICBpZiAoIHRoaXMuc2lkZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuc2lkZSAhPT0gVEhSRUUuRnJvbnRTaWRlICkgZGF0YS5zaWRlID0gdGhpcy5zaWRlO1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMub3BhY2l0eSA8IDEgKSBkYXRhLm9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XHJcbiAgICAgICAgaWYgKCB0aGlzLnRyYW5zcGFyZW50ID09PSB0cnVlICkgZGF0YS50cmFuc3BhcmVudCA9IHRoaXMudHJhbnNwYXJlbnQ7XHJcbiAgICAgICAgaWYgKCB0aGlzLmFscGhhVGVzdCA+IDAgKSBkYXRhLmFscGhhVGVzdCA9IHRoaXMuYWxwaGFUZXN0O1xyXG4gICAgICAgIGlmICggdGhpcy53aXJlZnJhbWUgPT09IHRydWUgKSBkYXRhLndpcmVmcmFtZSA9IHRoaXMud2lyZWZyYW1lO1xyXG4gICAgICAgIGlmICggdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPiAxICkgZGF0YS53aXJlZnJhbWVMaW5ld2lkdGggPSB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aDtcclxuXHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5uYW1lID0gc291cmNlLm5hbWU7XHJcblxyXG4gICAgICAgIHRoaXMuc2lkZSA9IHNvdXJjZS5zaWRlO1xyXG5cclxuICAgICAgICB0aGlzLm9wYWNpdHkgPSBzb3VyY2Uub3BhY2l0eTtcclxuICAgICAgICB0aGlzLnRyYW5zcGFyZW50ID0gc291cmNlLnRyYW5zcGFyZW50O1xyXG5cclxuICAgICAgICB0aGlzLmJsZW5kaW5nID0gc291cmNlLmJsZW5kaW5nO1xyXG5cclxuICAgICAgICB0aGlzLmJsZW5kU3JjID0gc291cmNlLmJsZW5kU3JjO1xyXG4gICAgICAgIHRoaXMuYmxlbmREc3QgPSBzb3VyY2UuYmxlbmREc3Q7XHJcbiAgICAgICAgdGhpcy5ibGVuZEVxdWF0aW9uID0gc291cmNlLmJsZW5kRXF1YXRpb247XHJcbiAgICAgICAgdGhpcy5ibGVuZFNyY0FscGhhID0gc291cmNlLmJsZW5kU3JjQWxwaGE7XHJcbiAgICAgICAgdGhpcy5ibGVuZERzdEFscGhhID0gc291cmNlLmJsZW5kRHN0QWxwaGE7XHJcbiAgICAgICAgdGhpcy5ibGVuZEVxdWF0aW9uQWxwaGEgPSBzb3VyY2UuYmxlbmRFcXVhdGlvbkFscGhhO1xyXG5cclxuICAgICAgICB0aGlzLmRlcHRoRnVuYyA9IHNvdXJjZS5kZXB0aEZ1bmM7XHJcbiAgICAgICAgdGhpcy5kZXB0aFRlc3QgPSBzb3VyY2UuZGVwdGhUZXN0O1xyXG4gICAgICAgIHRoaXMuZGVwdGhXcml0ZSA9IHNvdXJjZS5kZXB0aFdyaXRlO1xyXG5cclxuICAgICAgICB0aGlzLnByZWNpc2lvbiA9IHNvdXJjZS5wcmVjaXNpb247XHJcblxyXG4gICAgICAgIHRoaXMucG9seWdvbk9mZnNldCA9IHNvdXJjZS5wb2x5Z29uT2Zmc2V0O1xyXG4gICAgICAgIHRoaXMucG9seWdvbk9mZnNldEZhY3RvciA9IHNvdXJjZS5wb2x5Z29uT2Zmc2V0RmFjdG9yO1xyXG4gICAgICAgIHRoaXMucG9seWdvbk9mZnNldFVuaXRzID0gc291cmNlLnBvbHlnb25PZmZzZXRVbml0cztcclxuXHJcbiAgICAgICAgdGhpcy5hbHBoYVRlc3QgPSBzb3VyY2UuYWxwaGFUZXN0O1xyXG5cclxuICAgICAgICB0aGlzLm92ZXJkcmF3ID0gc291cmNlLm92ZXJkcmF3O1xyXG5cclxuICAgICAgICB0aGlzLnZpc2libGUgPSBzb3VyY2UudmlzaWJsZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICd1cGRhdGUnIH0gKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBEZXByZWNhdGVkXHJcblxyXG4gICAgZ2V0IHdyYXBBcm91bmQgKCkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS4nICsgdGhpcy50eXBlICsgJzogLndyYXBBcm91bmQgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXQgd3JhcEFyb3VuZCAoIGJvb2xlYW4gKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLicgKyB0aGlzLnR5cGUgKyAnOiAud3JhcEFyb3VuZCBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldCB3cmFwUkdCICgpIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuJyArIHRoaXMudHlwZSArICc6IC53cmFwUkdCIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG4gICAgICAgIHJldHVybiBuZXcgVEhSRUUuQ29sb3IoKTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5NYXRlcmlhbElkQ291bnQgPSAwO1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL0xpbmVCYXNpY01hdGVyaWFsLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICogIGNvbG9yOiA8aGV4PixcclxuICogIG9wYWNpdHk6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXHJcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcclxuICogIGRlcHRoV3JpdGU6IDxib29sPixcclxuICpcclxuICogIGxpbmV3aWR0aDogPGZsb2F0PixcclxuICogIGxpbmVjYXA6IFwicm91bmRcIixcclxuICogIGxpbmVqb2luOiBcInJvdW5kXCIsXHJcbiAqXHJcbiAqICB2ZXJ0ZXhDb2xvcnM6IDxib29sPlxyXG4gKlxyXG4gKiAgZm9nOiA8Ym9vbD5cclxuICogfVxyXG4gKi9cclxuXHJcblRIUkVFLkxpbmVCYXNpY01hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuICAgIFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnTGluZUJhc2ljTWF0ZXJpYWwnO1xyXG5cclxuICAgIHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XHJcblxyXG4gICAgdGhpcy5saW5ld2lkdGggPSAxO1xyXG4gICAgdGhpcy5saW5lY2FwID0gJ3JvdW5kJztcclxuICAgIHRoaXMubGluZWpvaW4gPSAncm91bmQnO1xyXG5cclxuICAgIHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7XHJcblxyXG4gICAgdGhpcy5mb2cgPSB0cnVlO1xyXG5cclxuICAgIHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblRIUkVFLkxpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsO1xyXG5cclxuVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcbiAgICBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcbiAgICB0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xyXG5cclxuICAgIHRoaXMubGluZXdpZHRoID0gc291cmNlLmxpbmV3aWR0aDtcclxuICAgIHRoaXMubGluZWNhcCA9IHNvdXJjZS5saW5lY2FwO1xyXG4gICAgdGhpcy5saW5lam9pbiA9IHNvdXJjZS5saW5lam9pbjtcclxuXHJcbiAgICB0aGlzLnZlcnRleENvbG9ycyA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnM7XHJcblxyXG4gICAgdGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGVyaWFscy9MaW5lRGFzaGVkTWF0ZXJpYWwuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKiAgY29sb3I6IDxoZXg+LFxyXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcclxuICpcclxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcclxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxyXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxyXG4gKlxyXG4gKiAgbGluZXdpZHRoOiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgc2NhbGU6IDxmbG9hdD4sXHJcbiAqICBkYXNoU2l6ZTogPGZsb2F0PixcclxuICogIGdhcFNpemU6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICB2ZXJ0ZXhDb2xvcnM6IDxib29sPlxyXG4gKlxyXG4gKiAgZm9nOiA8Ym9vbD5cclxuICogfVxyXG4gKi9cclxuXHJcblRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcclxuXHJcbiAgICBUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ0xpbmVEYXNoZWRNYXRlcmlhbCc7XHJcblxyXG4gICAgdGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcclxuXHJcbiAgICB0aGlzLmxpbmV3aWR0aCA9IDE7XHJcblxyXG4gICAgdGhpcy5zY2FsZSA9IDE7XHJcbiAgICB0aGlzLmRhc2hTaXplID0gMztcclxuICAgIHRoaXMuZ2FwU2l6ZSA9IDE7XHJcblxyXG4gICAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLmZvZyA9IHRydWU7XHJcblxyXG4gICAgdGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWw7XHJcblxyXG5USFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcbiAgICBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcbiAgICB0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xyXG5cclxuICAgIHRoaXMubGluZXdpZHRoID0gc291cmNlLmxpbmV3aWR0aDtcclxuXHJcbiAgICB0aGlzLnNjYWxlID0gc291cmNlLnNjYWxlO1xyXG4gICAgdGhpcy5kYXNoU2l6ZSA9IHNvdXJjZS5kYXNoU2l6ZTtcclxuICAgIHRoaXMuZ2FwU2l6ZSA9IHNvdXJjZS5nYXBTaXplO1xyXG5cclxuICAgIHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcclxuXHJcbiAgICB0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL01lc2hCYXNpY01hdGVyaWFsLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICogIGNvbG9yOiA8aGV4PixcclxuICogIG9wYWNpdHk6IDxmbG9hdD4sXHJcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBhb01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICogIGFvTWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XHJcbiAqXHJcbiAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKlxyXG4gKiAgZW52TWFwOiBuZXcgVEhSRUUuVGV4dHVyZUN1YmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxyXG4gKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXHJcbiAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXHJcbiAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBzaGFkaW5nOiBUSFJFRS5TbW9vdGhTaGFkaW5nLFxyXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxyXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXHJcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcclxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcclxuICpcclxuICogIHZlcnRleENvbG9yczogVEhSRUUuTm9Db2xvcnMgLyBUSFJFRS5WZXJ0ZXhDb2xvcnMgLyBUSFJFRS5GYWNlQ29sb3JzLFxyXG4gKlxyXG4gKiAgc2tpbm5pbmc6IDxib29sPixcclxuICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxyXG4gKlxyXG4gKiAgZm9nOiA8Ym9vbD5cclxuICogfVxyXG4gKi9cclxuXHJcblRIUkVFLk1lc2hCYXNpY01hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuICAgIFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnTWVzaEJhc2ljTWF0ZXJpYWwnO1xyXG5cclxuICAgIHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGVtaXNzaXZlXHJcblxyXG4gICAgdGhpcy5tYXAgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuYW9NYXAgPSBudWxsO1xyXG4gICAgdGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcclxuXHJcbiAgICB0aGlzLnNwZWN1bGFyTWFwID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLmFscGhhTWFwID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLmVudk1hcCA9IG51bGw7XHJcbiAgICB0aGlzLmNvbWJpbmUgPSBUSFJFRS5NdWx0aXBseU9wZXJhdGlvbjtcclxuICAgIHRoaXMucmVmbGVjdGl2aXR5ID0gMTtcclxuICAgIHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcclxuXHJcbiAgICB0aGlzLmZvZyA9IHRydWU7XHJcblxyXG4gICAgdGhpcy5zaGFkaW5nID0gVEhSRUUuU21vb3RoU2hhZGluZztcclxuXHJcbiAgICB0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xyXG4gICAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xyXG4gICAgdGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcclxuICAgIHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xyXG5cclxuICAgIHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7XHJcblxyXG4gICAgdGhpcy5za2lubmluZyA9IGZhbHNlO1xyXG4gICAgdGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1lc2hCYXNpY01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5USFJFRS5NZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbDtcclxuXHJcblRIUkVFLk1lc2hCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG4gICAgVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG4gICAgdGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcclxuXHJcbiAgICB0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XHJcblxyXG4gICAgdGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcclxuICAgIHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBzb3VyY2UuYW9NYXBJbnRlbnNpdHk7XHJcblxyXG4gICAgdGhpcy5zcGVjdWxhck1hcCA9IHNvdXJjZS5zcGVjdWxhck1hcDtcclxuXHJcbiAgICB0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xyXG5cclxuICAgIHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcclxuICAgIHRoaXMuY29tYmluZSA9IHNvdXJjZS5jb21iaW5lO1xyXG4gICAgdGhpcy5yZWZsZWN0aXZpdHkgPSBzb3VyY2UucmVmbGVjdGl2aXR5O1xyXG4gICAgdGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xyXG5cclxuICAgIHRoaXMuZm9nID0gc291cmNlLmZvZztcclxuXHJcbiAgICB0aGlzLnNoYWRpbmcgPSBzb3VyY2Uuc2hhZGluZztcclxuXHJcbiAgICB0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XHJcbiAgICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XHJcbiAgICB0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBzb3VyY2Uud2lyZWZyYW1lTGluZWNhcDtcclxuICAgIHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XHJcblxyXG4gICAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xyXG5cclxuICAgIHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XHJcbiAgICB0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL01lc2hMYW1iZXJ0TWF0ZXJpYWwuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKiAgY29sb3I6IDxoZXg+LFxyXG4gKiAgZW1pc3NpdmU6IDxoZXg+LFxyXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcclxuICpcclxuICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIHNwZWN1bGFyTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKlxyXG4gKiAgYWxwaGFNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBlbnZNYXA6IG5ldyBUSFJFRS5UZXh0dXJlQ3ViZSggW3Bvc3gsIG5lZ3gsIHBvc3ksIG5lZ3ksIHBvc3osIG5lZ3pdICksXHJcbiAqICBjb21iaW5lOiBUSFJFRS5NdWx0aXBseSxcclxuICogIHJlZmxlY3Rpdml0eTogPGZsb2F0PixcclxuICogIHJlZnJhY3Rpb25SYXRpbzogPGZsb2F0PixcclxuICpcclxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcclxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxyXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxyXG4gKlxyXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXHJcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLk5vQ29sb3JzIC8gVEhSRUUuVmVydGV4Q29sb3JzIC8gVEhSRUUuRmFjZUNvbG9ycyxcclxuICpcclxuICogIHNraW5uaW5nOiA8Ym9vbD4sXHJcbiAqICBtb3JwaFRhcmdldHM6IDxib29sPixcclxuICogIG1vcnBoTm9ybWFsczogPGJvb2w+LFxyXG4gKlxyXG4gKlx0Zm9nOiA8Ym9vbD5cclxuICogfVxyXG4gKi9cclxuXHJcblRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG4gICAgVEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdNZXNoTGFtYmVydE1hdGVyaWFsJztcclxuXHJcbiAgICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApOyAvLyBkaWZmdXNlXHJcbiAgICB0aGlzLmVtaXNzaXZlID0gbmV3IFRIUkVFLkNvbG9yKCAweDAwMDAwMCApO1xyXG5cclxuICAgIHRoaXMubWFwID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLnNwZWN1bGFyTWFwID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLmFscGhhTWFwID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLmVudk1hcCA9IG51bGw7XHJcbiAgICB0aGlzLmNvbWJpbmUgPSBUSFJFRS5NdWx0aXBseU9wZXJhdGlvbjtcclxuICAgIHRoaXMucmVmbGVjdGl2aXR5ID0gMTtcclxuICAgIHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcclxuXHJcbiAgICB0aGlzLmZvZyA9IHRydWU7XHJcblxyXG4gICAgdGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcclxuICAgIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcclxuICAgIHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XHJcbiAgICB0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcclxuXHJcbiAgICB0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xyXG5cclxuICAgIHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcclxuICAgIHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XHJcbiAgICB0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsO1xyXG5cclxuVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuICAgIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuICAgIHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XHJcbiAgICB0aGlzLmVtaXNzaXZlLmNvcHkoIHNvdXJjZS5lbWlzc2l2ZSApO1xyXG5cclxuICAgIHRoaXMubWFwID0gc291cmNlLm1hcDtcclxuXHJcbiAgICB0aGlzLnNwZWN1bGFyTWFwID0gc291cmNlLnNwZWN1bGFyTWFwO1xyXG5cclxuICAgIHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XHJcblxyXG4gICAgdGhpcy5lbnZNYXAgPSBzb3VyY2UuZW52TWFwO1xyXG4gICAgdGhpcy5jb21iaW5lID0gc291cmNlLmNvbWJpbmU7XHJcbiAgICB0aGlzLnJlZmxlY3Rpdml0eSA9IHNvdXJjZS5yZWZsZWN0aXZpdHk7XHJcbiAgICB0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IHNvdXJjZS5yZWZyYWN0aW9uUmF0aW87XHJcblxyXG4gICAgdGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xyXG5cclxuICAgIHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcclxuICAgIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcclxuICAgIHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xyXG4gICAgdGhpcy53aXJlZnJhbWVMaW5lam9pbiA9IHNvdXJjZS53aXJlZnJhbWVMaW5lam9pbjtcclxuXHJcbiAgICB0aGlzLnZlcnRleENvbG9ycyA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnM7XHJcblxyXG4gICAgdGhpcy5za2lubmluZyA9IHNvdXJjZS5za2lubmluZztcclxuICAgIHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcclxuICAgIHRoaXMubW9ycGhOb3JtYWxzID0gc291cmNlLm1vcnBoTm9ybWFscztcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTWVzaFBob25nTWF0ZXJpYWwuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKiAgY29sb3I6IDxoZXg+LFxyXG4gKiAgZW1pc3NpdmU6IDxoZXg+LFxyXG4gKiAgc3BlY3VsYXI6IDxoZXg+LFxyXG4gKiAgc2hpbmluZXNzOiA8ZmxvYXQ+LFxyXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcclxuICpcclxuICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIGxpZ2h0TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKiAgbGlnaHRNYXBJbnRlbnNpdHk6IDxmbG9hdD5cclxuICpcclxuICogIGFvTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKiAgYW9NYXBJbnRlbnNpdHk6IDxmbG9hdD5cclxuICpcclxuICogIGVtaXNzaXZlTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKlxyXG4gKiAgYnVtcE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICogIGJ1bXBTY2FsZTogPGZsb2F0PixcclxuICpcclxuICogIG5vcm1hbE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICogIG5vcm1hbFNjYWxlOiA8VmVjdG9yMj4sXHJcbiAqXHJcbiAqICBkaXNwbGFjZW1lbnRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqICBkaXNwbGFjZW1lbnRTY2FsZTogPGZsb2F0PixcclxuICogIGRpc3BsYWNlbWVudEJpYXM6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKlxyXG4gKiAgZW52TWFwOiBuZXcgVEhSRUUuVGV4dHVyZUN1YmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxyXG4gKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXHJcbiAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXHJcbiAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBzaGFkaW5nOiBUSFJFRS5TbW9vdGhTaGFkaW5nLFxyXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxyXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXHJcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcclxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcclxuICpcclxuICogIHZlcnRleENvbG9yczogVEhSRUUuTm9Db2xvcnMgLyBUSFJFRS5WZXJ0ZXhDb2xvcnMgLyBUSFJFRS5GYWNlQ29sb3JzLFxyXG4gKlxyXG4gKiAgc2tpbm5pbmc6IDxib29sPixcclxuICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxyXG4gKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD4sXHJcbiAqXHJcbiAqXHRmb2c6IDxib29sPlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG4gICAgVEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdNZXNoUGhvbmdNYXRlcmlhbCc7XHJcblxyXG4gICAgdGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTsgLy8gZGlmZnVzZVxyXG4gICAgdGhpcy5lbWlzc2l2ZSA9IG5ldyBUSFJFRS5Db2xvciggMHgwMDAwMDAgKTtcclxuICAgIHRoaXMuc3BlY3VsYXIgPSBuZXcgVEhSRUUuQ29sb3IoIDB4MTExMTExICk7XHJcbiAgICB0aGlzLnNoaW5pbmVzcyA9IDMwO1xyXG5cclxuICAgIHRoaXMubWV0YWwgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLm1hcCA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5saWdodE1hcCA9IG51bGw7XHJcbiAgICB0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gMS4wO1xyXG5cclxuICAgIHRoaXMuYW9NYXAgPSBudWxsO1xyXG4gICAgdGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcclxuXHJcbiAgICB0aGlzLmVtaXNzaXZlTWFwID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLmJ1bXBNYXAgPSBudWxsO1xyXG4gICAgdGhpcy5idW1wU2NhbGUgPSAxO1xyXG5cclxuICAgIHRoaXMubm9ybWFsTWFwID0gbnVsbDtcclxuICAgIHRoaXMubm9ybWFsU2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApO1xyXG5cclxuICAgIHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcclxuICAgIHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xyXG4gICAgdGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gMDtcclxuXHJcbiAgICB0aGlzLnNwZWN1bGFyTWFwID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLmFscGhhTWFwID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLmVudk1hcCA9IG51bGw7XHJcbiAgICB0aGlzLmNvbWJpbmUgPSBUSFJFRS5NdWx0aXBseU9wZXJhdGlvbjtcclxuICAgIHRoaXMucmVmbGVjdGl2aXR5ID0gMTtcclxuICAgIHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcclxuXHJcbiAgICB0aGlzLmZvZyA9IHRydWU7XHJcblxyXG4gICAgdGhpcy5zaGFkaW5nID0gVEhSRUUuU21vb3RoU2hhZGluZztcclxuXHJcbiAgICB0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xyXG4gICAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xyXG4gICAgdGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcclxuICAgIHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xyXG5cclxuICAgIHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7XHJcblxyXG4gICAgdGhpcy5za2lubmluZyA9IGZhbHNlO1xyXG4gICAgdGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcclxuICAgIHRoaXMubW9ycGhOb3JtYWxzID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5NZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTWVzaFBob25nTWF0ZXJpYWw7XHJcblxyXG5USFJFRS5NZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuICAgIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuICAgIHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XHJcbiAgICB0aGlzLmVtaXNzaXZlLmNvcHkoIHNvdXJjZS5lbWlzc2l2ZSApO1xyXG4gICAgdGhpcy5zcGVjdWxhci5jb3B5KCBzb3VyY2Uuc3BlY3VsYXIgKTtcclxuICAgIHRoaXMuc2hpbmluZXNzID0gc291cmNlLnNoaW5pbmVzcztcclxuXHJcbiAgICB0aGlzLm1ldGFsID0gc291cmNlLm1ldGFsO1xyXG5cclxuICAgIHRoaXMubWFwID0gc291cmNlLm1hcDtcclxuXHJcbiAgICB0aGlzLmxpZ2h0TWFwID0gc291cmNlLmxpZ2h0TWFwO1xyXG4gICAgdGhpcy5saWdodE1hcEludGVuc2l0eSA9IHNvdXJjZS5saWdodE1hcEludGVuc2l0eTtcclxuXHJcbiAgICB0aGlzLmFvTWFwID0gc291cmNlLmFvTWFwO1xyXG4gICAgdGhpcy5hb01hcEludGVuc2l0eSA9IHNvdXJjZS5hb01hcEludGVuc2l0eTtcclxuXHJcbiAgICB0aGlzLmVtaXNzaXZlTWFwID0gc291cmNlLmVtaXNzaXZlTWFwO1xyXG5cclxuICAgIHRoaXMuYnVtcE1hcCA9IHNvdXJjZS5idW1wTWFwO1xyXG4gICAgdGhpcy5idW1wU2NhbGUgPSBzb3VyY2UuYnVtcFNjYWxlO1xyXG5cclxuICAgIHRoaXMubm9ybWFsTWFwID0gc291cmNlLm5vcm1hbE1hcDtcclxuICAgIHRoaXMubm9ybWFsU2NhbGUuY29weSggc291cmNlLm5vcm1hbFNjYWxlICk7XHJcblxyXG4gICAgdGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xyXG4gICAgdGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcclxuICAgIHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xyXG5cclxuICAgIHRoaXMuc3BlY3VsYXJNYXAgPSBzb3VyY2Uuc3BlY3VsYXJNYXA7XHJcblxyXG4gICAgdGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcclxuXHJcbiAgICB0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XHJcbiAgICB0aGlzLmNvbWJpbmUgPSBzb3VyY2UuY29tYmluZTtcclxuICAgIHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcclxuICAgIHRoaXMucmVmcmFjdGlvblJhdGlvID0gc291cmNlLnJlZnJhY3Rpb25SYXRpbztcclxuXHJcbiAgICB0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XHJcblxyXG4gICAgdGhpcy5zaGFkaW5nID0gc291cmNlLnNoYWRpbmc7XHJcblxyXG4gICAgdGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xyXG4gICAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xyXG4gICAgdGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XHJcbiAgICB0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xyXG5cclxuICAgIHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcclxuXHJcbiAgICB0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xyXG4gICAgdGhpcy5tb3JwaFRhcmdldHMgPSBzb3VyY2UubW9ycGhUYXJnZXRzO1xyXG4gICAgdGhpcy5tb3JwaE5vcm1hbHMgPSBzb3VyY2UubW9ycGhOb3JtYWxzO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGVyaWFscy9NZXNoRGVwdGhNYXRlcmlhbC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxyXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXHJcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcclxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG4gICAgVEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdNZXNoRGVwdGhNYXRlcmlhbCc7XHJcblxyXG4gICAgdGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcclxuICAgIHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XHJcbiAgICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XHJcblxyXG4gICAgdGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5NZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWw7XHJcblxyXG5USFJFRS5NZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuICAgIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuICAgIHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcclxuICAgIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTWVzaE5vcm1hbE1hdGVyaWFsLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICogIG9wYWNpdHk6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBzaGFkaW5nOiBUSFJFRS5GbGF0U2hhZGluZyxcclxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcclxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxyXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxyXG4gKlxyXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXHJcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD5cclxuICogfVxyXG4gKi9cclxuXHJcblRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcclxuXHJcbiAgICBUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzLCBwYXJhbWV0ZXJzICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ01lc2hOb3JtYWxNYXRlcmlhbCc7XHJcblxyXG4gICAgdGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcclxuICAgIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcclxuXHJcbiAgICB0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5USFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsO1xyXG5cclxuVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG4gICAgVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG4gICAgdGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xyXG4gICAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGVyaWFscy9NdWx0aU1hdGVyaWFsLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5NdWx0aU1hdGVyaWFsID0gZnVuY3Rpb24gKCBtYXRlcmlhbHMgKSB7XHJcblxyXG4gICAgdGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnTXVsdGlNYXRlcmlhbCc7XHJcblxyXG4gICAgdGhpcy5tYXRlcmlhbHMgPSBtYXRlcmlhbHMgaW5zdGFuY2VvZiBBcnJheSA/IG1hdGVyaWFscyA6IFtdO1xyXG5cclxuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTXVsdGlNYXRlcmlhbC5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLk11bHRpTWF0ZXJpYWwsXHJcblxyXG4gICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBvdXRwdXQgPSB7XHJcbiAgICAgICAgICAgIG1ldGFkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiA0LjIsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnbWF0ZXJpYWwnLFxyXG4gICAgICAgICAgICAgICAgZ2VuZXJhdG9yOiAnTWF0ZXJpYWxFeHBvcnRlcidcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdXVpZDogdGhpcy51dWlkLFxyXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXHJcbiAgICAgICAgICAgIG1hdGVyaWFsczogW11cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLm1hdGVyaWFscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgb3V0cHV0Lm1hdGVyaWFscy5wdXNoKCB0aGlzLm1hdGVyaWFsc1sgaSBdLnRvSlNPTigpICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb3V0cHV0LnZpc2libGUgPSB0aGlzLnZpc2libGU7XHJcblxyXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLm1hdGVyaWFscy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICBtYXRlcmlhbC5tYXRlcmlhbHMucHVzaCggdGhpcy5tYXRlcmlhbHNbIGkgXS5jbG9uZSgpICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbWF0ZXJpYWwudmlzaWJsZSA9IHRoaXMudmlzaWJsZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG1hdGVyaWFsO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxyXG5cclxuVEhSRUUuTWVzaEZhY2VNYXRlcmlhbCA9IFRIUkVFLk11bHRpTWF0ZXJpYWw7XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvUG9pbnRzTWF0ZXJpYWwuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKiAgY29sb3I6IDxoZXg+LFxyXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcclxuICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIHNpemU6IDxmbG9hdD4sXHJcbiAqICBzaXplQXR0ZW51YXRpb246IDxib29sPixcclxuICpcclxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcclxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxyXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxyXG4gKlxyXG4gKiAgdmVydGV4Q29sb3JzOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICBmb2c6IDxib29sPlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuVEhSRUUuUG9pbnRzTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG4gICAgVEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdQb2ludHNNYXRlcmlhbCc7XHJcblxyXG4gICAgdGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcclxuXHJcbiAgICB0aGlzLm1hcCA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5zaXplID0gMTtcclxuICAgIHRoaXMuc2l6ZUF0dGVudWF0aW9uID0gdHJ1ZTtcclxuXHJcbiAgICB0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xyXG5cclxuICAgIHRoaXMuZm9nID0gdHJ1ZTtcclxuXHJcbiAgICB0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBvaW50c01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5USFJFRS5Qb2ludHNNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Qb2ludHNNYXRlcmlhbDtcclxuXHJcblRIUkVFLlBvaW50c01hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG4gICAgVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG4gICAgdGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcclxuXHJcbiAgICB0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XHJcblxyXG4gICAgdGhpcy5zaXplID0gc291cmNlLnNpemU7XHJcbiAgICB0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHNvdXJjZS5zaXplQXR0ZW51YXRpb247XHJcblxyXG4gICAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xyXG5cclxuICAgIHRoaXMuZm9nID0gc291cmNlLmZvZztcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxyXG5cclxuVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlBvaW50Q2xvdWRNYXRlcmlhbCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50c01hdGVyaWFsLicgKTtcclxuICAgIHJldHVybiBuZXcgVEhSRUUuUG9pbnRzTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5QYXJ0aWNsZUJhc2ljTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuUGFydGljbGVCYXNpY01hdGVyaWFsIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzTWF0ZXJpYWwuJyApO1xyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5Qb2ludHNNYXRlcmlhbCggcGFyYW1ldGVycyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBhcnRpY2xlU3lzdGVtTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuUGFydGljbGVTeXN0ZW1NYXRlcmlhbCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50c01hdGVyaWFsLicgKTtcclxuICAgIHJldHVybiBuZXcgVEhSRUUuUG9pbnRzTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvU2hhZGVyTWF0ZXJpYWwuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKiAgZGVmaW5lczogeyBcImxhYmVsXCIgOiBcInZhbHVlXCIgfSxcclxuICogIHVuaWZvcm1zOiB7IFwicGFyYW1ldGVyMVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sIFwicGFyYW1ldGVyMlwiOiB7IHR5cGU6IFwiaVwiIHZhbHVlMjogMiB9IH0sXHJcbiAqXHJcbiAqICBmcmFnbWVudFNoYWRlcjogPHN0cmluZz4sXHJcbiAqICB2ZXJ0ZXhTaGFkZXI6IDxzdHJpbmc+LFxyXG4gKlxyXG4gKiAgc2hhZGluZzogVEhSRUUuU21vb3RoU2hhZGluZyxcclxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcclxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxyXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxyXG4gKlxyXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXHJcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBsaWdodHM6IDxib29sPixcclxuICpcclxuICogIHZlcnRleENvbG9yczogVEhSRUUuTm9Db2xvcnMgLyBUSFJFRS5WZXJ0ZXhDb2xvcnMgLyBUSFJFRS5GYWNlQ29sb3JzLFxyXG4gKlxyXG4gKiAgc2tpbm5pbmc6IDxib29sPixcclxuICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxyXG4gKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD4sXHJcbiAqXHJcbiAqXHRmb2c6IDxib29sPlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuVEhSRUUuU2hhZGVyTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG4gICAgVEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdTaGFkZXJNYXRlcmlhbCc7XHJcblxyXG4gICAgdGhpcy5kZWZpbmVzID0ge307XHJcbiAgICB0aGlzLnVuaWZvcm1zID0ge307XHJcblxyXG4gICAgdGhpcy52ZXJ0ZXhTaGFkZXIgPSAndm9pZCBtYWluKCkge1xcblxcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcXG59JztcclxuICAgIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSAndm9pZCBtYWluKCkge1xcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIDEuMCwgMC4wLCAwLjAsIDEuMCApO1xcbn0nO1xyXG5cclxuICAgIHRoaXMuc2hhZGluZyA9IFRIUkVFLlNtb290aFNoYWRpbmc7XHJcblxyXG4gICAgdGhpcy5saW5ld2lkdGggPSAxO1xyXG5cclxuICAgIHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XHJcbiAgICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XHJcblxyXG4gICAgdGhpcy5mb2cgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBzY2VuZSBmb2dcclxuXHJcbiAgICB0aGlzLmxpZ2h0cyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHNjZW5lIGxpZ2h0c1xyXG5cclxuICAgIHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7IC8vIHNldCB0byB1c2UgXCJjb2xvclwiIGF0dHJpYnV0ZSBzdHJlYW1cclxuXHJcbiAgICB0aGlzLnNraW5uaW5nID0gZmFsc2U7IC8vIHNldCB0byB1c2Ugc2tpbm5pbmcgYXR0cmlidXRlIHN0cmVhbXNcclxuXHJcbiAgICB0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIG1vcnBoIHRhcmdldHNcclxuICAgIHRoaXMubW9ycGhOb3JtYWxzID0gZmFsc2U7IC8vIHNldCB0byB1c2UgbW9ycGggbm9ybWFsc1xyXG5cclxuICAgIHRoaXMuZGVyaXZhdGl2ZXMgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBkZXJpdmF0aXZlc1xyXG5cclxuICAgIC8vIFdoZW4gcmVuZGVyZWQgZ2VvbWV0cnkgZG9lc24ndCBpbmNsdWRlIHRoZXNlIGF0dHJpYnV0ZXMgYnV0IHRoZSBtYXRlcmlhbCBkb2VzLFxyXG4gICAgLy8gdXNlIHRoZXNlIGRlZmF1bHQgdmFsdWVzIGluIFdlYkdMLiBUaGlzIGF2b2lkcyBlcnJvcnMgd2hlbiBidWZmZXIgZGF0YSBpcyBtaXNzaW5nLlxyXG4gICAgdGhpcy5kZWZhdWx0QXR0cmlidXRlVmFsdWVzID0ge1xyXG4gICAgICAgICdjb2xvcic6IFsgMSwgMSwgMSBdLFxyXG4gICAgICAgICd1dic6IFsgMCwgMCBdLFxyXG4gICAgICAgICd1djInOiBbIDAsIDAgXVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmluZGV4MEF0dHJpYnV0ZU5hbWUgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgaWYgKCBwYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgIGlmICggcGFyYW1ldGVycy5hdHRyaWJ1dGVzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuU2hhZGVyTWF0ZXJpYWw6IGF0dHJpYnV0ZXMgc2hvdWxkIG5vdyBiZSBkZWZpbmVkIGluIFRIUkVFLkJ1ZmZlckdlb21ldHJ5IGluc3RlYWQuJyApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcblRIUkVFLlNoYWRlck1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5USFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TaGFkZXJNYXRlcmlhbDtcclxuXHJcblRIUkVFLlNoYWRlck1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG4gICAgVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG4gICAgdGhpcy5mcmFnbWVudFNoYWRlciA9IHNvdXJjZS5mcmFnbWVudFNoYWRlcjtcclxuICAgIHRoaXMudmVydGV4U2hhZGVyID0gc291cmNlLnZlcnRleFNoYWRlcjtcclxuXHJcbiAgICB0aGlzLnVuaWZvcm1zID0gVEhSRUUuVW5pZm9ybXNVdGlscy5jbG9uZSggc291cmNlLnVuaWZvcm1zICk7XHJcblxyXG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gc291cmNlLmF0dHJpYnV0ZXM7XHJcbiAgICB0aGlzLmRlZmluZXMgPSBzb3VyY2UuZGVmaW5lcztcclxuXHJcbiAgICB0aGlzLnNoYWRpbmcgPSBzb3VyY2Uuc2hhZGluZztcclxuXHJcbiAgICB0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XHJcbiAgICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XHJcblxyXG4gICAgdGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xyXG5cclxuICAgIHRoaXMubGlnaHRzID0gc291cmNlLmxpZ2h0cztcclxuXHJcbiAgICB0aGlzLnZlcnRleENvbG9ycyA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnM7XHJcblxyXG4gICAgdGhpcy5za2lubmluZyA9IHNvdXJjZS5za2lubmluZztcclxuXHJcbiAgICB0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XHJcbiAgICB0aGlzLm1vcnBoTm9ybWFscyA9IHNvdXJjZS5tb3JwaE5vcm1hbHM7XHJcblxyXG4gICAgdGhpcy5kZXJpdmF0aXZlcyA9IHNvdXJjZS5kZXJpdmF0aXZlcztcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG5USFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCBtZXRhICkge1xyXG5cclxuICAgIHZhciBkYXRhID0gVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XHJcblxyXG4gICAgZGF0YS51bmlmb3JtcyA9IHRoaXMudW5pZm9ybXM7XHJcbiAgICBkYXRhLmF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XHJcbiAgICBkYXRhLnZlcnRleFNoYWRlciA9IHRoaXMudmVydGV4U2hhZGVyO1xyXG4gICAgZGF0YS5mcmFnbWVudFNoYWRlciA9IHRoaXMuZnJhZ21lbnRTaGFkZXI7XHJcblxyXG4gICAgcmV0dXJuIGRhdGE7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL1Jhd1NoYWRlck1hdGVyaWFsLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5SYXdTaGFkZXJNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcclxuXHJcbiAgICBUSFJFRS5TaGFkZXJNYXRlcmlhbC5jYWxsKCB0aGlzLCBwYXJhbWV0ZXJzICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ1Jhd1NoYWRlck1hdGVyaWFsJztcclxuXHJcbn07XHJcblxyXG5USFJFRS5SYXdTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuVEhSRUUuUmF3U2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUmF3U2hhZGVyTWF0ZXJpYWw7XHJcbi8vIEZpbGU6c3JjL21hdGVyaWFscy9TcHJpdGVNYXRlcmlhbC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqICBjb2xvcjogPGhleD4sXHJcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxyXG4gKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKlxyXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxyXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXHJcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXHJcbiAqXHJcbiAqXHR1dk9mZnNldDogbmV3IFRIUkVFLlZlY3RvcjIoKSxcclxuICpcdHV2U2NhbGU6IG5ldyBUSFJFRS5WZWN0b3IyKCksXHJcbiAqXHJcbiAqICBmb2c6IDxib29sPlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuVEhSRUUuU3ByaXRlTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG4gICAgVEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdTcHJpdGVNYXRlcmlhbCc7XHJcblxyXG4gICAgdGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcclxuICAgIHRoaXMubWFwID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLnJvdGF0aW9uID0gMDtcclxuXHJcbiAgICB0aGlzLmZvZyA9IGZhbHNlO1xyXG5cclxuICAgIC8vIHNldCBwYXJhbWV0ZXJzXHJcblxyXG4gICAgdGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TcHJpdGVNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuVEhSRUUuU3ByaXRlTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU3ByaXRlTWF0ZXJpYWw7XHJcblxyXG5USFJFRS5TcHJpdGVNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuICAgIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuICAgIHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XHJcbiAgICB0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XHJcblxyXG4gICAgdGhpcy5yb3RhdGlvbiA9IHNvdXJjZS5yb3RhdGlvbjtcclxuXHJcbiAgICB0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvdGV4dHVyZXMvVGV4dHVyZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3Igc3ppbWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL3N6aW1lay9cclxuICovXHJcblxyXG5USFJFRS5UZXh0dXJlID0gZnVuY3Rpb24gKCBpbWFnZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICkge1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogVEhSRUUuVGV4dHVyZUlkQ291bnQgKysgfSApO1xyXG5cclxuICAgIHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XHJcblxyXG4gICAgdGhpcy5uYW1lID0gJyc7XHJcbiAgICB0aGlzLnNvdXJjZUZpbGUgPSAnJztcclxuXHJcbiAgICB0aGlzLmltYWdlID0gaW1hZ2UgIT09IHVuZGVmaW5lZCA/IGltYWdlIDogVEhSRUUuVGV4dHVyZS5ERUZBVUxUX0lNQUdFO1xyXG4gICAgdGhpcy5taXBtYXBzID0gW107XHJcblxyXG4gICAgdGhpcy5tYXBwaW5nID0gbWFwcGluZyAhPT0gdW5kZWZpbmVkID8gbWFwcGluZyA6IFRIUkVFLlRleHR1cmUuREVGQVVMVF9NQVBQSU5HO1xyXG5cclxuICAgIHRoaXMud3JhcFMgPSB3cmFwUyAhPT0gdW5kZWZpbmVkID8gd3JhcFMgOiBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nO1xyXG4gICAgdGhpcy53cmFwVCA9IHdyYXBUICE9PSB1bmRlZmluZWQgPyB3cmFwVCA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XHJcblxyXG4gICAgdGhpcy5tYWdGaWx0ZXIgPSBtYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1hZ0ZpbHRlciA6IFRIUkVFLkxpbmVhckZpbHRlcjtcclxuICAgIHRoaXMubWluRmlsdGVyID0gbWluRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtaW5GaWx0ZXIgOiBUSFJFRS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI7XHJcblxyXG4gICAgdGhpcy5hbmlzb3Ryb3B5ID0gYW5pc290cm9weSAhPT0gdW5kZWZpbmVkID8gYW5pc290cm9weSA6IDE7XHJcblxyXG4gICAgdGhpcy5mb3JtYXQgPSBmb3JtYXQgIT09IHVuZGVmaW5lZCA/IGZvcm1hdCA6IFRIUkVFLlJHQkFGb3JtYXQ7XHJcbiAgICB0aGlzLnR5cGUgPSB0eXBlICE9PSB1bmRlZmluZWQgPyB0eXBlIDogVEhSRUUuVW5zaWduZWRCeXRlVHlwZTtcclxuXHJcbiAgICB0aGlzLm9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IyKCAwLCAwICk7XHJcbiAgICB0aGlzLnJlcGVhdCA9IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICk7XHJcblxyXG4gICAgdGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSB0cnVlO1xyXG4gICAgdGhpcy5wcmVtdWx0aXBseUFscGhhID0gZmFsc2U7XHJcbiAgICB0aGlzLmZsaXBZID0gdHJ1ZTtcclxuICAgIHRoaXMudW5wYWNrQWxpZ25tZW50ID0gNDsgLy8gdmFsaWQgdmFsdWVzOiAxLCAyLCA0LCA4IChzZWUgaHR0cDovL3d3dy5raHJvbm9zLm9yZy9vcGVuZ2xlcy9zZGsvZG9jcy9tYW4veGh0bWwvZ2xQaXhlbFN0b3JlaS54bWwpXHJcblxyXG4gICAgdGhpcy52ZXJzaW9uID0gMDtcclxuICAgIHRoaXMub25VcGRhdGUgPSBudWxsO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlRleHR1cmUuREVGQVVMVF9JTUFHRSA9IHVuZGVmaW5lZDtcclxuVEhSRUUuVGV4dHVyZS5ERUZBVUxUX01BUFBJTkcgPSBUSFJFRS5VVk1hcHBpbmc7XHJcblxyXG5USFJFRS5UZXh0dXJlLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuVGV4dHVyZSxcclxuXHJcbiAgICBzZXQgbmVlZHNVcGRhdGUgKCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgaWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudmVyc2lvbiArKztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuICAgICAgICB0aGlzLmltYWdlID0gc291cmNlLmltYWdlO1xyXG4gICAgICAgIHRoaXMubWlwbWFwcyA9IHNvdXJjZS5taXBtYXBzLnNsaWNlKCAwICk7XHJcblxyXG4gICAgICAgIHRoaXMubWFwcGluZyA9IHNvdXJjZS5tYXBwaW5nO1xyXG5cclxuICAgICAgICB0aGlzLndyYXBTID0gc291cmNlLndyYXBTO1xyXG4gICAgICAgIHRoaXMud3JhcFQgPSBzb3VyY2Uud3JhcFQ7XHJcblxyXG4gICAgICAgIHRoaXMubWFnRmlsdGVyID0gc291cmNlLm1hZ0ZpbHRlcjtcclxuICAgICAgICB0aGlzLm1pbkZpbHRlciA9IHNvdXJjZS5taW5GaWx0ZXI7XHJcblxyXG4gICAgICAgIHRoaXMuYW5pc290cm9weSA9IHNvdXJjZS5hbmlzb3Ryb3B5O1xyXG5cclxuICAgICAgICB0aGlzLmZvcm1hdCA9IHNvdXJjZS5mb3JtYXQ7XHJcbiAgICAgICAgdGhpcy50eXBlID0gc291cmNlLnR5cGU7XHJcblxyXG4gICAgICAgIHRoaXMub2Zmc2V0LmNvcHkoIHNvdXJjZS5vZmZzZXQgKTtcclxuICAgICAgICB0aGlzLnJlcGVhdC5jb3B5KCBzb3VyY2UucmVwZWF0ICk7XHJcblxyXG4gICAgICAgIHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gc291cmNlLmdlbmVyYXRlTWlwbWFwcztcclxuICAgICAgICB0aGlzLnByZW11bHRpcGx5QWxwaGEgPSBzb3VyY2UucHJlbXVsdGlwbHlBbHBoYTtcclxuICAgICAgICB0aGlzLmZsaXBZID0gc291cmNlLmZsaXBZO1xyXG4gICAgICAgIHRoaXMudW5wYWNrQWxpZ25tZW50ID0gc291cmNlLnVucGFja0FsaWdubWVudDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcclxuXHJcbiAgICAgICAgaWYgKCBtZXRhLnRleHR1cmVzWyB0aGlzLnV1aWQgXSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG1ldGEudGV4dHVyZXNbIHRoaXMudXVpZCBdO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGdldERhdGFVUkwoIGltYWdlICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGNhbnZhcztcclxuXHJcbiAgICAgICAgICAgIGlmICggaW1hZ2UudG9EYXRhVVJMICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FudmFzID0gaW1hZ2U7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XHJcbiAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSBpbWFnZS53aWR0aDtcclxuICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FudmFzLmdldENvbnRleHQoICcyZCcgKS5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0ICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIGNhbnZhcy53aWR0aCA+IDIwNDggfHwgY2FudmFzLmhlaWdodCA+IDIwNDggKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoICdpbWFnZS9qcGVnJywgMC42ICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKCAnaW1hZ2UvcG5nJyApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBvdXRwdXQgPSB7XHJcbiAgICAgICAgICAgIG1ldGFkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiA0LjQsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnVGV4dHVyZScsXHJcbiAgICAgICAgICAgICAgICBnZW5lcmF0b3I6ICdUZXh0dXJlLnRvSlNPTidcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHV1aWQ6IHRoaXMudXVpZCxcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG5cclxuICAgICAgICAgICAgbWFwcGluZzogdGhpcy5tYXBwaW5nLFxyXG5cclxuICAgICAgICAgICAgcmVwZWF0OiBbIHRoaXMucmVwZWF0LngsIHRoaXMucmVwZWF0LnkgXSxcclxuICAgICAgICAgICAgb2Zmc2V0OiBbIHRoaXMub2Zmc2V0LngsIHRoaXMub2Zmc2V0LnkgXSxcclxuICAgICAgICAgICAgd3JhcDogWyB0aGlzLndyYXBTLCB0aGlzLndyYXBUIF0sXHJcblxyXG4gICAgICAgICAgICBtaW5GaWx0ZXI6IHRoaXMubWluRmlsdGVyLFxyXG4gICAgICAgICAgICBtYWdGaWx0ZXI6IHRoaXMubWFnRmlsdGVyLFxyXG4gICAgICAgICAgICBhbmlzb3Ryb3B5OiB0aGlzLmFuaXNvdHJvcHlcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMuaW1hZ2UgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFRPRE86IE1vdmUgdG8gVEhSRUUuSW1hZ2VcclxuXHJcbiAgICAgICAgICAgIHZhciBpbWFnZSA9IHRoaXMuaW1hZ2U7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGltYWdlLnV1aWQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpbWFnZS51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTsgLy8gVUdIXHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIG1ldGEuaW1hZ2VzWyBpbWFnZS51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBtZXRhLmltYWdlc1sgaW1hZ2UudXVpZCBdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHV1aWQ6IGltYWdlLnV1aWQsXHJcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBnZXREYXRhVVJMKCBpbWFnZSApXHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgb3V0cHV0LmltYWdlID0gaW1hZ2UudXVpZDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBtZXRhLnRleHR1cmVzWyB0aGlzLnV1aWQgXSA9IG91dHB1dDtcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0cmFuc2Zvcm1VdjogZnVuY3Rpb24gKCB1diApIHtcclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLm1hcHBpbmcgIT09IFRIUkVFLlVWTWFwcGluZyApICByZXR1cm47XHJcblxyXG4gICAgICAgIHV2Lm11bHRpcGx5KCB0aGlzLnJlcGVhdCApO1xyXG4gICAgICAgIHV2LmFkZCggdGhpcy5vZmZzZXQgKTtcclxuXHJcbiAgICAgICAgaWYgKCB1di54IDwgMCB8fCB1di54ID4gMSApIHtcclxuXHJcbiAgICAgICAgICAgIHN3aXRjaCAoIHRoaXMud3JhcFMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5SZXBlYXRXcmFwcGluZzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdXYueCA9IHV2LnggLSBNYXRoLmZsb29yKCB1di54ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICB1di54ID0gdXYueCA8IDAgPyAwIDogMTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggTWF0aC5hYnMoIE1hdGguZmxvb3IoIHV2LnggKSAlIDIgKSA9PT0gMSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHV2LnggPSBNYXRoLmNlaWwoIHV2LnggKSAtIHV2Lng7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1di54ID0gdXYueCAtIE1hdGguZmxvb3IoIHV2LnggKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggdXYueSA8IDAgfHwgdXYueSA+IDEgKSB7XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKCB0aGlzLndyYXBUICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuUmVwZWF0V3JhcHBpbmc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHV2LnkgPSB1di55IC0gTWF0aC5mbG9vciggdXYueSApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdXYueSA9IHV2LnkgPCAwID8gMCA6IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIE1hdGguYWJzKCBNYXRoLmZsb29yKCB1di55ICkgJSAyICkgPT09IDEgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1di55ID0gTWF0aC5jZWlsKCB1di55ICkgLSB1di55O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdXYueSA9IHV2LnkgLSBNYXRoLmZsb29yKCB1di55ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIHRoaXMuZmxpcFkgKSB7XHJcblxyXG4gICAgICAgICAgICB1di55ID0gMSAtIHV2Lnk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLlRleHR1cmVJZENvdW50ID0gMDtcclxuXHJcbi8vIEZpbGU6c3JjL3RleHR1cmVzL0NhbnZhc1RleHR1cmUuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkNhbnZhc1RleHR1cmUgPSBmdW5jdGlvbiAoIGNhbnZhcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICkge1xyXG5cclxuICAgIFRIUkVFLlRleHR1cmUuY2FsbCggdGhpcywgY2FudmFzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcclxuXHJcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DYW52YXNUZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlRleHR1cmUucHJvdG90eXBlICk7XHJcblRIUkVFLkNhbnZhc1RleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ2FudmFzVGV4dHVyZTtcclxuXHJcbi8vIEZpbGU6c3JjL3RleHR1cmVzL0N1YmVUZXh0dXJlLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5DdWJlVGV4dHVyZSA9IGZ1bmN0aW9uICggaW1hZ2VzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKSB7XHJcblxyXG4gICAgbWFwcGluZyA9IG1hcHBpbmcgIT09IHVuZGVmaW5lZCA/IG1hcHBpbmcgOiBUSFJFRS5DdWJlUmVmbGVjdGlvbk1hcHBpbmc7XHJcblxyXG4gICAgVEhSRUUuVGV4dHVyZS5jYWxsKCB0aGlzLCBpbWFnZXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xyXG5cclxuICAgIHRoaXMuaW1hZ2VzID0gaW1hZ2VzO1xyXG4gICAgdGhpcy5mbGlwWSA9IGZhbHNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkN1YmVUZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlRleHR1cmUucHJvdG90eXBlICk7XHJcblRIUkVFLkN1YmVUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkN1YmVUZXh0dXJlO1xyXG5cclxuVEhSRUUuQ3ViZVRleHR1cmUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcbiAgICBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuICAgIHRoaXMuaW1hZ2VzID0gc291cmNlLmltYWdlcztcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuXHJcbn07XHJcbi8vIEZpbGU6c3JjL3RleHR1cmVzL0NvbXByZXNzZWRUZXh0dXJlLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5Db21wcmVzc2VkVGV4dHVyZSA9IGZ1bmN0aW9uICggbWlwbWFwcywgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBhbmlzb3Ryb3B5ICkge1xyXG5cclxuICAgIFRIUkVFLlRleHR1cmUuY2FsbCggdGhpcywgbnVsbCwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XHJcblxyXG4gICAgdGhpcy5pbWFnZSA9IHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xyXG4gICAgdGhpcy5taXBtYXBzID0gbWlwbWFwcztcclxuXHJcbiAgICAvLyBubyBmbGlwcGluZyBmb3IgY3ViZSB0ZXh0dXJlc1xyXG4gICAgLy8gKGFsc28gZmxpcHBpbmcgZG9lc24ndCB3b3JrIGZvciBjb21wcmVzc2VkIHRleHR1cmVzIClcclxuXHJcbiAgICB0aGlzLmZsaXBZID0gZmFsc2U7XHJcblxyXG4gICAgLy8gY2FuJ3QgZ2VuZXJhdGUgbWlwbWFwcyBmb3IgY29tcHJlc3NlZCB0ZXh0dXJlc1xyXG4gICAgLy8gbWlwcyBtdXN0IGJlIGVtYmVkZGVkIGluIEREUyBmaWxlc1xyXG5cclxuICAgIHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgKTtcclxuVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ29tcHJlc3NlZFRleHR1cmU7XHJcblxyXG4vLyBGaWxlOnNyYy90ZXh0dXJlcy9EYXRhVGV4dHVyZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuRGF0YVRleHR1cmUgPSBmdW5jdGlvbiAoIGRhdGEsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgYW5pc290cm9weSApIHtcclxuXHJcbiAgICBUSFJFRS5UZXh0dXJlLmNhbGwoIHRoaXMsIG51bGwsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xyXG5cclxuICAgIHRoaXMuaW1hZ2UgPSB7IGRhdGE6IGRhdGEsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcclxuXHJcbiAgICB0aGlzLm1hZ0ZpbHRlciA9IG1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWFnRmlsdGVyIDogVEhSRUUuTmVhcmVzdEZpbHRlcjtcclxuICAgIHRoaXMubWluRmlsdGVyID0gbWluRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtaW5GaWx0ZXIgOiBUSFJFRS5OZWFyZXN0RmlsdGVyO1xyXG5cclxuICAgIHRoaXMuZmxpcFkgPSBmYWxzZTtcclxuICAgIHRoaXMuZ2VuZXJhdGVNaXBtYXBzICA9IGZhbHNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkRhdGFUZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlRleHR1cmUucHJvdG90eXBlICk7XHJcblRIUkVFLkRhdGFUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkRhdGFUZXh0dXJlO1xyXG5cclxuLy8gRmlsZTpzcmMvdGV4dHVyZXMvVmlkZW9UZXh0dXJlLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5WaWRlb1RleHR1cmUgPSBmdW5jdGlvbiAoIHZpZGVvLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKSB7XHJcblxyXG4gICAgVEhSRUUuVGV4dHVyZS5jYWxsKCB0aGlzLCB2aWRlbywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XHJcblxyXG4gICAgdGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcclxuXHJcbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcclxuXHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCB1cGRhdGUgKTtcclxuXHJcbiAgICAgICAgaWYgKCB2aWRlby5yZWFkeVN0YXRlID09PSB2aWRlby5IQVZFX0VOT1VHSF9EQVRBICkge1xyXG5cclxuICAgICAgICAgICAgc2NvcGUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZSgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlZpZGVvVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xyXG5USFJFRS5WaWRlb1RleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuVmlkZW9UZXh0dXJlO1xyXG5cclxuLy8gRmlsZTpzcmMvb2JqZWN0cy9Hcm91cC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuR3JvdXAgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdHcm91cCc7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuR3JvdXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblRIUkVFLkdyb3VwLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkdyb3VwO1xyXG4vLyBGaWxlOnNyYy9vYmplY3RzL1BvaW50cy5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuUG9pbnRzID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XHJcblxyXG4gICAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdQb2ludHMnO1xyXG5cclxuICAgIHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkID8gZ2VvbWV0cnkgOiBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuICAgIHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWwgOiBuZXcgVEhSRUUuUG9pbnRzTWF0ZXJpYWwoIHsgY29sb3I6IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZiB9ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUG9pbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5USFJFRS5Qb2ludHMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUG9pbnRzO1xyXG5cclxuVEhSRUUuUG9pbnRzLnByb3RvdHlwZS5yYXljYXN0ID0gKCBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIGludmVyc2VNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG4gICAgdmFyIHJheSA9IG5ldyBUSFJFRS5SYXkoKTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xyXG5cclxuICAgICAgICB2YXIgb2JqZWN0ID0gdGhpcztcclxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XHJcbiAgICAgICAgdmFyIHRocmVzaG9sZCA9IHJheWNhc3Rlci5wYXJhbXMuUG9pbnRzLnRocmVzaG9sZDtcclxuXHJcbiAgICAgICAgaW52ZXJzZU1hdHJpeC5nZXRJbnZlcnNlKCB0aGlzLm1hdHJpeFdvcmxkICk7XHJcbiAgICAgICAgcmF5LmNvcHkoIHJheWNhc3Rlci5yYXkgKS5hcHBseU1hdHJpeDQoIGludmVyc2VNYXRyaXggKTtcclxuXHJcbiAgICAgICAgaWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggcmF5LmlzSW50ZXJzZWN0aW9uQm94KCBnZW9tZXRyeS5ib3VuZGluZ0JveCApID09PSBmYWxzZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGxvY2FsVGhyZXNob2xkID0gdGhyZXNob2xkIC8gKCAoIHRoaXMuc2NhbGUueCArIHRoaXMuc2NhbGUueSArIHRoaXMuc2NhbGUueiApIC8gMyApO1xyXG4gICAgICAgIHZhciBsb2NhbFRocmVzaG9sZFNxID0gbG9jYWxUaHJlc2hvbGQgKiBsb2NhbFRocmVzaG9sZDtcclxuICAgICAgICB2YXIgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB0ZXN0UG9pbnQoIHBvaW50LCBpbmRleCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciByYXlQb2ludERpc3RhbmNlU3EgPSByYXkuZGlzdGFuY2VTcVRvUG9pbnQoIHBvaW50ICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHJheVBvaW50RGlzdGFuY2VTcSA8IGxvY2FsVGhyZXNob2xkU3EgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGludGVyc2VjdFBvaW50ID0gcmF5LmNsb3Nlc3RQb2ludFRvUG9pbnQoIHBvaW50ICk7XHJcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RQb2ludC5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyc2VjdFBvaW50ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RzLnB1c2goIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlVG9SYXk6IE1hdGguc3FydCggcmF5UG9pbnREaXN0YW5jZVNxICksXHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGludGVyc2VjdFBvaW50LmNsb25lKCksXHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgIGZhY2U6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBvYmplY3RcclxuXHJcbiAgICAgICAgICAgICAgICB9ICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XHJcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcclxuICAgICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBpbmRpY2VzID0gaW5kZXguYXJyYXk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IGluZGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gaW5kaWNlc1sgaSBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYSAqIDMgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGVzdFBvaW50KCBwb3NpdGlvbiwgYSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gcG9zaXRpb25zLmxlbmd0aCAvIDM7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSAqIDMgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGVzdFBvaW50KCBwb3NpdGlvbiwgaSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0ZXN0UG9pbnQoIHZlcnRpY2VzWyBpIF0sIGkgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG59KCkgKTtcclxuXHJcblRIUkVFLlBvaW50cy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICkuY29weSggdGhpcyApO1xyXG5cclxufTtcclxuXHJcbi8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcblxyXG5USFJFRS5Qb2ludENsb3VkID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XHJcblxyXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuUG9pbnRDbG91ZCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50cy4nICk7XHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLlBvaW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGFydGljbGVTeXN0ZW0gPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcclxuXHJcbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5QYXJ0aWNsZVN5c3RlbSBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50cy4nICk7XHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLlBvaW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvb2JqZWN0cy9MaW5lLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5MaW5lID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG1vZGUgKSB7XHJcblxyXG4gICAgaWYgKCBtb2RlID09PSAxICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5MaW5lOiBwYXJhbWV0ZXIgVEhSRUUuTGluZVBpZWNlcyBubyBsb25nZXIgc3VwcG9ydGVkLiBDcmVhdGVkIFRIUkVFLkxpbmVTZWdtZW50cyBpbnN0ZWFkLicgKTtcclxuICAgICAgICByZXR1cm4gbmV3IFRIUkVFLkxpbmVTZWdtZW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnTGluZSc7XHJcblxyXG4gICAgdGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5ICE9PSB1bmRlZmluZWQgPyBnZW9tZXRyeSA6IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG4gICAgdGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbCA6IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmIH0gKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5MaW5lLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5USFJFRS5MaW5lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxpbmU7XHJcblxyXG5USFJFRS5MaW5lLnByb3RvdHlwZS5yYXljYXN0ID0gKCBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIGludmVyc2VNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG4gICAgdmFyIHJheSA9IG5ldyBUSFJFRS5SYXkoKTtcclxuICAgIHZhciBzcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCk7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcclxuXHJcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IHJheWNhc3Rlci5saW5lUHJlY2lzaW9uO1xyXG4gICAgICAgIHZhciBwcmVjaXNpb25TcSA9IHByZWNpc2lvbiAqIHByZWNpc2lvbjtcclxuXHJcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcclxuXHJcbiAgICAgICAgaWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG5cclxuICAgICAgICAvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZSBkaXN0YW5jZSB0byByYXlcclxuXHJcbiAgICAgICAgc3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XHJcbiAgICAgICAgc3BoZXJlLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xyXG5cclxuICAgICAgICBpZiAoIHJheWNhc3Rlci5yYXkuaXNJbnRlcnNlY3Rpb25TcGhlcmUoIHNwaGVyZSApID09PSBmYWxzZSApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnZlcnNlTWF0cml4LmdldEludmVyc2UoIHRoaXMubWF0cml4V29ybGQgKTtcclxuICAgICAgICByYXkuY29weSggcmF5Y2FzdGVyLnJheSApLmFwcGx5TWF0cml4NCggaW52ZXJzZU1hdHJpeCApO1xyXG5cclxuICAgICAgICB2YXIgdlN0YXJ0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICB2YXIgdkVuZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgdmFyIGludGVyU2VnbWVudCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgdmFyIGludGVyUmF5ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICB2YXIgc3RlcCA9IHRoaXMgaW5zdGFuY2VvZiBUSFJFRS5MaW5lU2VnbWVudHMgPyAyIDogMTtcclxuXHJcbiAgICAgICAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XHJcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcclxuXHJcbiAgICAgICAgICAgIGlmICggaW5kZXggIT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGluZGljZXMgPSBpbmRleC5hcnJheTtcclxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGluZGljZXMubGVuZ3RoIC0gMTsgaSA8IGw7IGkgKz0gc3RlcCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBpbmRpY2VzWyBpIF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBpbmRpY2VzWyBpICsgMSBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2U3RhcnQuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGEgKiAzICk7XHJcbiAgICAgICAgICAgICAgICAgICAgdkVuZC5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYiAqIDMgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3RTcSA9IHJheS5kaXN0YW5jZVNxVG9TZWdtZW50KCB2U3RhcnQsIHZFbmQsIGludGVyUmF5LCBpbnRlclNlZ21lbnQgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBkaXN0U3EgPiBwcmVjaXNpb25TcSApIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpbnRlclJheS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTsgLy9Nb3ZlIGJhY2sgdG8gd29ybGQgc3BhY2UgZm9yIGRpc3RhbmNlIGNhbGN1bGF0aW9uXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyUmF5ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0cy5wdXNoKCB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoYXQgZG8gd2Ugd2FudD8gaW50ZXJzZWN0aW9uIHBvaW50IG9uIHRoZSByYXkgb3Igb24gdGhlIHNlZ21lbnQ/P1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludDogcmF5Y2FzdGVyLnJheS5hdCggZGlzdGFuY2UgKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGludGVyU2VnbWVudC5jbG9uZSgpLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZTogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZUluZGV4OiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXNcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gcG9zaXRpb25zLmxlbmd0aCAvIDMgLSAxOyBpIDwgbDsgaSArPSBzdGVwICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2U3RhcnQuZnJvbUFycmF5KCBwb3NpdGlvbnMsIDMgKiBpICk7XHJcbiAgICAgICAgICAgICAgICAgICAgdkVuZC5mcm9tQXJyYXkoIHBvc2l0aW9ucywgMyAqIGkgKyAzICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXN0U3EgPSByYXkuZGlzdGFuY2VTcVRvU2VnbWVudCggdlN0YXJ0LCB2RW5kLCBpbnRlclJheSwgaW50ZXJTZWdtZW50ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggZGlzdFNxID4gcHJlY2lzaW9uU3EgKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJSYXkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7IC8vTW92ZSBiYWNrIHRvIHdvcmxkIHNwYWNlIGZvciBkaXN0YW5jZSBjYWxjdWxhdGlvblxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlclJheSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdHMucHVzaCgge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGF0IGRvIHdlIHdhbnQ/IGludGVyc2VjdGlvbiBwb2ludCBvbiB0aGUgcmF5IG9yIG9uIHRoZSBzZWdtZW50Pz9cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnQ6IHJheWNhc3Rlci5yYXkuYXQoIGRpc3RhbmNlICksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBpbnRlclNlZ21lbnQuY2xvbmUoKS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2U6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2VJbmRleDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcclxuICAgICAgICAgICAgdmFyIG5iVmVydGljZXMgPSB2ZXJ0aWNlcy5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBuYlZlcnRpY2VzIC0gMTsgaSArPSBzdGVwICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBkaXN0U3EgPSByYXkuZGlzdGFuY2VTcVRvU2VnbWVudCggdmVydGljZXNbIGkgXSwgdmVydGljZXNbIGkgKyAxIF0sIGludGVyUmF5LCBpbnRlclNlZ21lbnQgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGRpc3RTcSA+IHByZWNpc2lvblNxICkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgaW50ZXJSYXkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7IC8vTW92ZSBiYWNrIHRvIHdvcmxkIHNwYWNlIGZvciBkaXN0YW5jZSBjYWxjdWxhdGlvblxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyUmF5ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGludGVyc2VjdHMucHVzaCgge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hhdCBkbyB3ZSB3YW50PyBpbnRlcnNlY3Rpb24gcG9pbnQgb24gdGhlIHJheSBvciBvbiB0aGUgc2VnbWVudD8/XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnQ6IHJheWNhc3Rlci5yYXkuYXQoIGRpc3RhbmNlICksXHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGludGVyU2VnbWVudC5jbG9uZSgpLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApLFxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxyXG4gICAgICAgICAgICAgICAgICAgIGZhY2U6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgZmFjZUluZGV4OiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogdGhpc1xyXG5cclxuICAgICAgICAgICAgICAgIH0gKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG59KCkgKTtcclxuXHJcblRIUkVFLkxpbmUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApLmNvcHkoIHRoaXMgKTtcclxuXHJcbn07XHJcblxyXG4vLyBERVBSRUNBVEVEXHJcblxyXG5USFJFRS5MaW5lU3RyaXAgPSAwO1xyXG5USFJFRS5MaW5lUGllY2VzID0gMTtcclxuXHJcbi8vIEZpbGU6c3JjL29iamVjdHMvTGluZVNlZ21lbnRzLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5MaW5lU2VnbWVudHMgPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcclxuXHJcbiAgICBUSFJFRS5MaW5lLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdMaW5lU2VnbWVudHMnO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lLnByb3RvdHlwZSApO1xyXG5USFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGluZVNlZ21lbnRzO1xyXG5cclxuLy8gRmlsZTpzcmMvb2JqZWN0cy9NZXNoLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBqb25vYnIxIC8gaHR0cDovL2pvbm9icjEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLk1lc2ggPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcclxuXHJcbiAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ01lc2gnO1xyXG5cclxuICAgIHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkID8gZ2VvbWV0cnkgOiBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuICAgIHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWwgOiBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZiB9ICk7XHJcblxyXG4gICAgdGhpcy51cGRhdGVNb3JwaFRhcmdldHMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5NZXNoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5USFJFRS5NZXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk1lc2g7XHJcblxyXG5USFJFRS5NZXNoLnByb3RvdHlwZS51cGRhdGVNb3JwaFRhcmdldHMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgaWYgKCB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG4gICAgICAgIHRoaXMubW9ycGhUYXJnZXRCYXNlID0gLSAxO1xyXG4gICAgICAgIHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gW107XHJcbiAgICAgICAgdGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnkgPSB7fTtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIG0gPSAwLCBtbCA9IHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aDsgbSA8IG1sOyBtICsrICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMucHVzaCggMCApO1xyXG4gICAgICAgICAgICB0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgdGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHNbIG0gXS5uYW1lIF0gPSBtO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcblRIUkVFLk1lc2gucHJvdG90eXBlLmdldE1vcnBoVGFyZ2V0SW5kZXhCeU5hbWUgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG4gICAgaWYgKCB0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgbmFtZSBdICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgbmFtZSBdO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5NZXNoLmdldE1vcnBoVGFyZ2V0SW5kZXhCeU5hbWU6IG1vcnBoIHRhcmdldCAnICsgbmFtZSArICcgZG9lcyBub3QgZXhpc3QuIFJldHVybmluZyAwLicgKTtcclxuXHJcbiAgICByZXR1cm4gMDtcclxuXHJcbn07XHJcblxyXG5cclxuVEhSRUUuTWVzaC5wcm90b3R5cGUucmF5Y2FzdCA9ICggZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBpbnZlcnNlTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuICAgIHZhciByYXkgPSBuZXcgVEhSRUUuUmF5KCk7XHJcbiAgICB2YXIgc3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSgpO1xyXG5cclxuICAgIHZhciB2QSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICB2YXIgdkIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgdmFyIHZDID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICB2YXIgdGVtcEEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgdmFyIHRlbXBCID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgIHZhciB0ZW1wQyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgdmFyIHV2QSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcbiAgICB2YXIgdXZCID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuICAgIHZhciB1dkMgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cclxuICAgIHZhciBiYXJ5Y29vcmQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgIHZhciBpbnRlcnNlY3Rpb25Qb2ludCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICB2YXIgaW50ZXJzZWN0aW9uUG9pbnRXb3JsZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgZnVuY3Rpb24gdXZJbnRlcnNlY3Rpb24oIHBvaW50LCBwMSwgcDIsIHAzLCB1djEsIHV2MiwgdXYzICkge1xyXG5cclxuICAgICAgICBUSFJFRS5UcmlhbmdsZS5iYXJ5Y29vcmRGcm9tUG9pbnQoIHBvaW50LCBwMSwgcDIsIHAzLCBiYXJ5Y29vcmQgKTtcclxuXHJcbiAgICAgICAgdXYxLm11bHRpcGx5U2NhbGFyKCBiYXJ5Y29vcmQueCApO1xyXG4gICAgICAgIHV2Mi5tdWx0aXBseVNjYWxhciggYmFyeWNvb3JkLnkgKTtcclxuICAgICAgICB1djMubXVsdGlwbHlTY2FsYXIoIGJhcnljb29yZC56ICk7XHJcblxyXG4gICAgICAgIHV2MS5hZGQoIHV2MiApLmFkZCggdXYzICk7XHJcblxyXG4gICAgICAgIHJldHVybiB1djEuY2xvbmUoKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2hlY2tJbnRlcnNlY3Rpb24oIG9iamVjdCwgcmF5Y2FzdGVyLCByYXksIHBBLCBwQiwgcEMsIHBvaW50ICl7XHJcblxyXG4gICAgICAgIHZhciBpbnRlcnNlY3Q7XHJcbiAgICAgICAgdmFyIG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xyXG5cclxuICAgICAgICBpZiAoIG1hdGVyaWFsLnNpZGUgPT09IFRIUkVFLkJhY2tTaWRlICkge1xyXG5cclxuICAgICAgICAgICAgaW50ZXJzZWN0ID0gcmF5LmludGVyc2VjdFRyaWFuZ2xlKCBwQywgcEIsIHBBLCB0cnVlLCBwb2ludCApO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgaW50ZXJzZWN0ID0gcmF5LmludGVyc2VjdFRyaWFuZ2xlKCBwQSwgcEIsIHBDLCBtYXRlcmlhbC5zaWRlICE9PSBUSFJFRS5Eb3VibGVTaWRlLCBwb2ludCApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggaW50ZXJzZWN0ID09PSBudWxsICkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIGludGVyc2VjdGlvblBvaW50V29ybGQuY29weSggcG9pbnQgKTtcclxuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG4gICAgICAgIHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyc2VjdGlvblBvaW50V29ybGQgKTtcclxuXHJcbiAgICAgICAgaWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UsXHJcbiAgICAgICAgICAgIHBvaW50OiBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmNsb25lKCksXHJcbiAgICAgICAgICAgIG9iamVjdDogb2JqZWN0XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2hlY2tCdWZmZXJHZW9tZXRyeUludGVyc2VjdGlvbiggb2JqZWN0LCByYXljYXN0ZXIsIHJheSwgcG9zaXRpb25zLCB1dnMsIGEsIGIsIGMgKSB7XHJcblxyXG4gICAgICAgIHZBLmZyb21BcnJheSggcG9zaXRpb25zLCBhICogMyApO1xyXG4gICAgICAgIHZCLmZyb21BcnJheSggcG9zaXRpb25zLCBiICogMyApO1xyXG4gICAgICAgIHZDLmZyb21BcnJheSggcG9zaXRpb25zLCBjICogMyApO1xyXG5cclxuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gY2hlY2tJbnRlcnNlY3Rpb24oIG9iamVjdCwgcmF5Y2FzdGVyLCByYXksIHZBLCB2QiwgdkMsIGludGVyc2VjdGlvblBvaW50ICk7XHJcblxyXG4gICAgICAgIGlmICggaW50ZXJzZWN0aW9uICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCB1dnMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdXZBLmZyb21BcnJheSggdXZzLCBhICogMiApO1xyXG4gICAgICAgICAgICAgICAgdXZCLmZyb21BcnJheSggdXZzLCBiICogMiApO1xyXG4gICAgICAgICAgICAgICAgdXZDLmZyb21BcnJheSggdXZzLCBjICogMiApO1xyXG5cclxuICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbi51diA9IHV2SW50ZXJzZWN0aW9uKCBpbnRlcnNlY3Rpb25Qb2ludCwgIHZBLCB2QiwgdkMsICB1dkEsIHV2QiwgdXZDICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb24uZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgYywgVEhSRUUuVHJpYW5nbGUubm9ybWFsKCB2QSwgdkIsIHZDICkgKTtcclxuICAgICAgICAgICAgaW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IGE7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGludGVyc2VjdGlvbjtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcclxuXHJcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcclxuICAgICAgICB2YXIgbWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsO1xyXG5cclxuICAgICAgICBpZiAoIG1hdGVyaWFsID09PSB1bmRlZmluZWQgKSByZXR1cm47XHJcblxyXG4gICAgICAgIC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlIGRpc3RhbmNlIHRvIHJheVxyXG5cclxuICAgICAgICBpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG4gICAgICAgIHZhciBtYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4V29ybGQ7XHJcblxyXG4gICAgICAgIHNwaGVyZS5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApO1xyXG4gICAgICAgIHNwaGVyZS5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XHJcblxyXG4gICAgICAgIGlmICggcmF5Y2FzdGVyLnJheS5pc0ludGVyc2VjdGlvblNwaGVyZSggc3BoZXJlICkgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyBDaGVjayBib3VuZGluZ0JveCBiZWZvcmUgY29udGludWluZ1xyXG5cclxuICAgICAgICBpbnZlcnNlTWF0cml4LmdldEludmVyc2UoIG1hdHJpeFdvcmxkICk7XHJcbiAgICAgICAgcmF5LmNvcHkoIHJheWNhc3Rlci5yYXkgKS5hcHBseU1hdHJpeDQoIGludmVyc2VNYXRyaXggKTtcclxuXHJcbiAgICAgICAgaWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggcmF5LmlzSW50ZXJzZWN0aW9uQm94KCBnZW9tZXRyeS5ib3VuZGluZ0JveCApID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdXZzLCBpbnRlcnNlY3Rpb247XHJcblxyXG4gICAgICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBhLCBiLCBjO1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcclxuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xyXG4gICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcclxuXHJcbiAgICAgICAgICAgIGlmICggYXR0cmlidXRlcy51diAhPT0gdW5kZWZpbmVkICl7XHJcblxyXG4gICAgICAgICAgICAgICAgdXZzID0gYXR0cmlidXRlcy51di5hcnJheTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggaW5kZXggIT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGluZGljZXMgPSBpbmRleC5hcnJheTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IGluZGljZXNbIGkgXTtcclxuICAgICAgICAgICAgICAgICAgICBiID0gaW5kaWNlc1sgaSArIDEgXTtcclxuICAgICAgICAgICAgICAgICAgICBjID0gaW5kaWNlc1sgaSArIDIgXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uID0gY2hlY2tCdWZmZXJHZW9tZXRyeUludGVyc2VjdGlvbiggdGhpcywgcmF5Y2FzdGVyLCByYXksIHBvc2l0aW9ucywgdXZzLCBhLCBiLCBjICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggaW50ZXJzZWN0aW9uICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IE1hdGguZmxvb3IoIGkgLyAzICk7IC8vIHRyaWFuZ2xlIG51bWJlciBpbiBpbmRpY2VzIGJ1ZmZlciBzZW1hbnRpY3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3Rpb24gKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBsOyBpICs9IDkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGEgPSBpIC8gMztcclxuICAgICAgICAgICAgICAgICAgICBiID0gYSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgYyA9IGEgKyAyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb24gPSBjaGVja0J1ZmZlckdlb21ldHJ5SW50ZXJzZWN0aW9uKCB0aGlzLCByYXljYXN0ZXIsIHJheSwgcG9zaXRpb25zLCB1dnMsIGEsIGIsIGMgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpbnRlcnNlY3Rpb24gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb24uaW5kZXggPSBhOyAvLyB0cmlhbmdsZSBudW1iZXIgaW4gcG9zaXRpb25zIGJ1ZmZlciBzZW1hbnRpY3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3Rpb24gKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBmdkEsIGZ2QiwgZnZDO1xyXG4gICAgICAgICAgICB2YXIgaXNGYWNlTWF0ZXJpYWwgPSBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWw7XHJcbiAgICAgICAgICAgIHZhciBtYXRlcmlhbHMgPSBpc0ZhY2VNYXRlcmlhbCA9PT0gdHJ1ZSA/IG1hdGVyaWFsLm1hdGVyaWFscyA6IG51bGw7XHJcblxyXG4gICAgICAgICAgICB2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcclxuICAgICAgICAgICAgdmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XHJcbiAgICAgICAgICAgIHZhciBmYWNlVmVydGV4VXZzID0gZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgMCBdO1xyXG4gICAgICAgICAgICBpZiAoIGZhY2VWZXJ0ZXhVdnMubGVuZ3RoID4gMCApIHV2cyA9IGZhY2VWZXJ0ZXhVdnM7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgZiA9IDAsIGZsID0gZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGZhY2UgPSBmYWNlc1sgZiBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZhY2VNYXRlcmlhbCA9IGlzRmFjZU1hdGVyaWFsID09PSB0cnVlID8gbWF0ZXJpYWxzWyBmYWNlLm1hdGVyaWFsSW5kZXggXSA6IG1hdGVyaWFsO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggZmFjZU1hdGVyaWFsID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBmdkEgPSB2ZXJ0aWNlc1sgZmFjZS5hIF07XHJcbiAgICAgICAgICAgICAgICBmdkIgPSB2ZXJ0aWNlc1sgZmFjZS5iIF07XHJcbiAgICAgICAgICAgICAgICBmdkMgPSB2ZXJ0aWNlc1sgZmFjZS5jIF07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBmYWNlTWF0ZXJpYWwubW9ycGhUYXJnZXRzID09PSB0cnVlICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtb3JwaEluZmx1ZW5jZXMgPSB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdkEuc2V0KCAwLCAwLCAwICk7XHJcbiAgICAgICAgICAgICAgICAgICAgdkIuc2V0KCAwLCAwLCAwICk7XHJcbiAgICAgICAgICAgICAgICAgICAgdkMuc2V0KCAwLCAwLCAwICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciB0ID0gMCwgdGwgPSBtb3JwaFRhcmdldHMubGVuZ3RoOyB0IDwgdGw7IHQgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5mbHVlbmNlID0gbW9ycGhJbmZsdWVuY2VzWyB0IF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGluZmx1ZW5jZSA9PT0gMCApIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldHMgPSBtb3JwaFRhcmdldHNbIHQgXS52ZXJ0aWNlcztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZBLmFkZFNjYWxlZFZlY3RvciggdGVtcEEuc3ViVmVjdG9ycyggdGFyZ2V0c1sgZmFjZS5hIF0sIGZ2QSApLCBpbmZsdWVuY2UgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdkIuYWRkU2NhbGVkVmVjdG9yKCB0ZW1wQi5zdWJWZWN0b3JzKCB0YXJnZXRzWyBmYWNlLmIgXSwgZnZCICksIGluZmx1ZW5jZSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2Qy5hZGRTY2FsZWRWZWN0b3IoIHRlbXBDLnN1YlZlY3RvcnMoIHRhcmdldHNbIGZhY2UuYyBdLCBmdkMgKSwgaW5mbHVlbmNlICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdkEuYWRkKCBmdkEgKTtcclxuICAgICAgICAgICAgICAgICAgICB2Qi5hZGQoIGZ2QiApO1xyXG4gICAgICAgICAgICAgICAgICAgIHZDLmFkZCggZnZDICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZ2QSA9IHZBO1xyXG4gICAgICAgICAgICAgICAgICAgIGZ2QiA9IHZCO1xyXG4gICAgICAgICAgICAgICAgICAgIGZ2QyA9IHZDO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb24gPSBjaGVja0ludGVyc2VjdGlvbiggdGhpcywgcmF5Y2FzdGVyLCByYXksIGZ2QSwgZnZCLCBmdkMsIGludGVyc2VjdGlvblBvaW50ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBpbnRlcnNlY3Rpb24gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggdXZzICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHV2c19mID0gdXZzWyBmIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHV2QS5jb3B5KCB1dnNfZlsgMCBdICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHV2Qi5jb3B5KCB1dnNfZlsgMSBdICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHV2Qy5jb3B5KCB1dnNfZlsgMiBdICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb24udXYgPSB1dkludGVyc2VjdGlvbiggaW50ZXJzZWN0aW9uUG9pbnQsIGZ2QSwgZnZCLCBmdkMsIHV2QSwgdXZCLCB1dkMgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb24uZmFjZSA9IGZhY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IGY7XHJcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3Rpb24gKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxufSgpICk7XHJcblxyXG5USFJFRS5NZXNoLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwgKS5jb3B5KCB0aGlzICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvb2JqZWN0cy9Cb25lLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXHJcbiAqL1xyXG5cclxuVEhSRUUuQm9uZSA9IGZ1bmN0aW9uICggc2tpbiApIHtcclxuXHJcbiAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ0JvbmUnO1xyXG5cclxuICAgIHRoaXMuc2tpbiA9IHNraW47XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQm9uZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuQm9uZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Cb25lO1xyXG5cclxuVEhSRUUuQm9uZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuICAgIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuICAgIHRoaXMuc2tpbiA9IHNvdXJjZS5za2luO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL29iamVjdHMvU2tlbGV0b24uanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1pY2hhZWwgZ3VlcnJlcm8gLyBodHRwOi8vcmVhbGl0eW1lbHRkb3duLmNvbVxyXG4gKiBAYXV0aG9yIGlrZXJyIC8gaHR0cDovL3Zlcm9sZC5jb21cclxuICovXHJcblxyXG5USFJFRS5Ta2VsZXRvbiA9IGZ1bmN0aW9uICggYm9uZXMsIGJvbmVJbnZlcnNlcywgdXNlVmVydGV4VGV4dHVyZSApIHtcclxuXHJcbiAgICB0aGlzLnVzZVZlcnRleFRleHR1cmUgPSB1c2VWZXJ0ZXhUZXh0dXJlICE9PSB1bmRlZmluZWQgPyB1c2VWZXJ0ZXhUZXh0dXJlIDogdHJ1ZTtcclxuXHJcbiAgICB0aGlzLmlkZW50aXR5TWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcbiAgICAvLyBjb3B5IHRoZSBib25lIGFycmF5XHJcblxyXG4gICAgYm9uZXMgPSBib25lcyB8fCBbXTtcclxuXHJcbiAgICB0aGlzLmJvbmVzID0gYm9uZXMuc2xpY2UoIDAgKTtcclxuXHJcbiAgICAvLyBjcmVhdGUgYSBib25lIHRleHR1cmUgb3IgYW4gYXJyYXkgb2YgZmxvYXRzXHJcblxyXG4gICAgaWYgKCB0aGlzLnVzZVZlcnRleFRleHR1cmUgKSB7XHJcblxyXG4gICAgICAgIC8vIGxheW91dCAoMSBtYXRyaXggPSA0IHBpeGVscylcclxuICAgICAgICAvLyAgICAgIFJHQkEgUkdCQSBSR0JBIFJHQkEgKD0+IGNvbHVtbjEsIGNvbHVtbjIsIGNvbHVtbjMsIGNvbHVtbjQpXHJcbiAgICAgICAgLy8gIHdpdGggIDh4OCAgcGl4ZWwgdGV4dHVyZSBtYXggICAxNiBib25lcyAqIDQgcGl4ZWxzID0gICg4ICogOClcclxuICAgICAgICAvLyAgICAgICAxNngxNiBwaXhlbCB0ZXh0dXJlIG1heCAgIDY0IGJvbmVzICogNCBwaXhlbHMgPSAoMTYgKiAxNilcclxuICAgICAgICAvLyAgICAgICAzMngzMiBwaXhlbCB0ZXh0dXJlIG1heCAgMjU2IGJvbmVzICogNCBwaXhlbHMgPSAoMzIgKiAzMilcclxuICAgICAgICAvLyAgICAgICA2NHg2NCBwaXhlbCB0ZXh0dXJlIG1heCAxMDI0IGJvbmVzICogNCBwaXhlbHMgPSAoNjQgKiA2NClcclxuXHJcblxyXG4gICAgICAgIHZhciBzaXplID0gTWF0aC5zcXJ0KCB0aGlzLmJvbmVzLmxlbmd0aCAqIDQgKTsgLy8gNCBwaXhlbHMgbmVlZGVkIGZvciAxIG1hdHJpeFxyXG4gICAgICAgIHNpemUgPSBUSFJFRS5NYXRoLm5leHRQb3dlck9mVHdvKCBNYXRoLmNlaWwoIHNpemUgKSApO1xyXG4gICAgICAgIHNpemUgPSBNYXRoLm1heCggc2l6ZSwgNCApO1xyXG5cclxuICAgICAgICB0aGlzLmJvbmVUZXh0dXJlV2lkdGggPSBzaXplO1xyXG4gICAgICAgIHRoaXMuYm9uZVRleHR1cmVIZWlnaHQgPSBzaXplO1xyXG5cclxuICAgICAgICB0aGlzLmJvbmVNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIHRoaXMuYm9uZVRleHR1cmVXaWR0aCAqIHRoaXMuYm9uZVRleHR1cmVIZWlnaHQgKiA0ICk7IC8vIDQgZmxvYXRzIHBlciBSR0JBIHBpeGVsXHJcbiAgICAgICAgdGhpcy5ib25lVGV4dHVyZSA9IG5ldyBUSFJFRS5EYXRhVGV4dHVyZSggdGhpcy5ib25lTWF0cmljZXMsIHRoaXMuYm9uZVRleHR1cmVXaWR0aCwgdGhpcy5ib25lVGV4dHVyZUhlaWdodCwgVEhSRUUuUkdCQUZvcm1hdCwgVEhSRUUuRmxvYXRUeXBlICk7XHJcblxyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgdGhpcy5ib25lTWF0cmljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCAxNiAqIHRoaXMuYm9uZXMubGVuZ3RoICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vIHVzZSB0aGUgc3VwcGxpZWQgYm9uZSBpbnZlcnNlcyBvciBjYWxjdWxhdGUgdGhlIGludmVyc2VzXHJcblxyXG4gICAgaWYgKCBib25lSW52ZXJzZXMgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVJbnZlcnNlcygpO1xyXG5cclxuICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5ib25lcy5sZW5ndGggPT09IGJvbmVJbnZlcnNlcy5sZW5ndGggKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmJvbmVJbnZlcnNlcyA9IGJvbmVJbnZlcnNlcy5zbGljZSggMCApO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuU2tlbGV0b24gYm9uSW52ZXJzZXMgaXMgdGhlIHdyb25nIGxlbmd0aC4nICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmJvbmVJbnZlcnNlcyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBiIDwgYmw7IGIgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5ib25lSW52ZXJzZXMucHVzaCggbmV3IFRIUkVFLk1hdHJpeDQoKSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcblRIUkVFLlNrZWxldG9uLnByb3RvdHlwZS5jYWxjdWxhdGVJbnZlcnNlcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB0aGlzLmJvbmVJbnZlcnNlcyA9IFtdO1xyXG5cclxuICAgIGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xyXG5cclxuICAgICAgICB2YXIgaW52ZXJzZSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5ib25lc1sgYiBdICkge1xyXG5cclxuICAgICAgICAgICAgaW52ZXJzZS5nZXRJbnZlcnNlKCB0aGlzLmJvbmVzWyBiIF0ubWF0cml4V29ybGQgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmJvbmVJbnZlcnNlcy5wdXNoKCBpbnZlcnNlICk7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcblRIUkVFLlNrZWxldG9uLnByb3RvdHlwZS5wb3NlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBib25lO1xyXG5cclxuICAgIC8vIHJlY292ZXIgdGhlIGJpbmQtdGltZSB3b3JsZCBtYXRyaWNlc1xyXG5cclxuICAgIGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xyXG5cclxuICAgICAgICBib25lID0gdGhpcy5ib25lc1sgYiBdO1xyXG5cclxuICAgICAgICBpZiAoIGJvbmUgKSB7XHJcblxyXG4gICAgICAgICAgICBib25lLm1hdHJpeFdvcmxkLmdldEludmVyc2UoIHRoaXMuYm9uZUludmVyc2VzWyBiIF0gKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBjb21wdXRlIHRoZSBsb2NhbCBtYXRyaWNlcywgcG9zaXRpb25zLCByb3RhdGlvbnMgYW5kIHNjYWxlc1xyXG5cclxuICAgIGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xyXG5cclxuICAgICAgICBib25lID0gdGhpcy5ib25lc1sgYiBdO1xyXG5cclxuICAgICAgICBpZiAoIGJvbmUgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGJvbmUucGFyZW50ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGJvbmUubWF0cml4LmdldEludmVyc2UoIGJvbmUucGFyZW50Lm1hdHJpeFdvcmxkICk7XHJcbiAgICAgICAgICAgICAgICBib25lLm1hdHJpeC5tdWx0aXBseSggYm9uZS5tYXRyaXhXb3JsZCApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICBib25lLm1hdHJpeC5jb3B5KCBib25lLm1hdHJpeFdvcmxkICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBib25lLm1hdHJpeC5kZWNvbXBvc2UoIGJvbmUucG9zaXRpb24sIGJvbmUucXVhdGVybmlvbiwgYm9uZS5zY2FsZSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcblRIUkVFLlNrZWxldG9uLnByb3RvdHlwZS51cGRhdGUgPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgb2Zmc2V0TWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xyXG5cclxuICAgICAgICAvLyBmbGF0dGVuIGJvbmUgbWF0cmljZXMgdG8gYXJyYXlcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBiIDwgYmw7IGIgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBjb21wdXRlIHRoZSBvZmZzZXQgYmV0d2VlbiB0aGUgY3VycmVudCBhbmQgdGhlIG9yaWdpbmFsIHRyYW5zZm9ybVxyXG5cclxuICAgICAgICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuYm9uZXNbIGIgXSA/IHRoaXMuYm9uZXNbIGIgXS5tYXRyaXhXb3JsZCA6IHRoaXMuaWRlbnRpdHlNYXRyaXg7XHJcblxyXG4gICAgICAgICAgICBvZmZzZXRNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggbWF0cml4LCB0aGlzLmJvbmVJbnZlcnNlc1sgYiBdICk7XHJcbiAgICAgICAgICAgIG9mZnNldE1hdHJpeC5mbGF0dGVuVG9BcnJheU9mZnNldCggdGhpcy5ib25lTWF0cmljZXMsIGIgKiAxNiApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggdGhpcy51c2VWZXJ0ZXhUZXh0dXJlICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5ib25lVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxufSApKCk7XHJcblxyXG5USFJFRS5Ta2VsZXRvbi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5Ta2VsZXRvbiggdGhpcy5ib25lcywgdGhpcy5ib25lSW52ZXJzZXMsIHRoaXMudXNlVmVydGV4VGV4dHVyZSApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL29iamVjdHMvU2tpbm5lZE1lc2guanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIGlrZXJyIC8gaHR0cDovL3Zlcm9sZC5jb21cclxuICovXHJcblxyXG5USFJFRS5Ta2lubmVkTWVzaCA9IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFsLCB1c2VWZXJ0ZXhUZXh0dXJlICkge1xyXG5cclxuICAgIFRIUkVFLk1lc2guY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ1NraW5uZWRNZXNoJztcclxuXHJcbiAgICB0aGlzLmJpbmRNb2RlID0gXCJhdHRhY2hlZFwiO1xyXG4gICAgdGhpcy5iaW5kTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuICAgIHRoaXMuYmluZE1hdHJpeEludmVyc2UgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuICAgIC8vIGluaXQgYm9uZXNcclxuXHJcbiAgICAvLyBUT0RPOiByZW1vdmUgYm9uZSBjcmVhdGlvbiBhcyB0aGVyZSBpcyBubyByZWFzb24gKG90aGVyIHRoYW5cclxuICAgIC8vIGNvbnZlbmllbmNlKSBmb3IgVEhSRUUuU2tpbm5lZE1lc2ggdG8gZG8gdGhpcy5cclxuXHJcbiAgICB2YXIgYm9uZXMgPSBbXTtcclxuXHJcbiAgICBpZiAoIHRoaXMuZ2VvbWV0cnkgJiYgdGhpcy5nZW9tZXRyeS5ib25lcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICB2YXIgYm9uZSwgZ2JvbmU7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmdlb21ldHJ5LmJvbmVzLmxlbmd0aDsgYiA8IGJsOyArKyBiICkge1xyXG5cclxuICAgICAgICAgICAgZ2JvbmUgPSB0aGlzLmdlb21ldHJ5LmJvbmVzWyBiIF07XHJcblxyXG4gICAgICAgICAgICBib25lID0gbmV3IFRIUkVFLkJvbmUoIHRoaXMgKTtcclxuICAgICAgICAgICAgYm9uZXMucHVzaCggYm9uZSApO1xyXG5cclxuICAgICAgICAgICAgYm9uZS5uYW1lID0gZ2JvbmUubmFtZTtcclxuICAgICAgICAgICAgYm9uZS5wb3NpdGlvbi5mcm9tQXJyYXkoIGdib25lLnBvcyApO1xyXG4gICAgICAgICAgICBib25lLnF1YXRlcm5pb24uZnJvbUFycmF5KCBnYm9uZS5yb3RxICk7XHJcbiAgICAgICAgICAgIGlmICggZ2JvbmUuc2NsICE9PSB1bmRlZmluZWQgKSBib25lLnNjYWxlLmZyb21BcnJheSggZ2JvbmUuc2NsICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuZ2VvbWV0cnkuYm9uZXMubGVuZ3RoOyBiIDwgYmw7ICsrIGIgKSB7XHJcblxyXG4gICAgICAgICAgICBnYm9uZSA9IHRoaXMuZ2VvbWV0cnkuYm9uZXNbIGIgXTtcclxuXHJcbiAgICAgICAgICAgIGlmICggZ2JvbmUucGFyZW50ICE9PSAtIDEgJiYgZ2JvbmUucGFyZW50ICE9PSBudWxsKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgYm9uZXNbIGdib25lLnBhcmVudCBdLmFkZCggYm9uZXNbIGIgXSApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZCggYm9uZXNbIGIgXSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubm9ybWFsaXplU2tpbldlaWdodHMoKTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XHJcbiAgICB0aGlzLmJpbmQoIG5ldyBUSFJFRS5Ta2VsZXRvbiggYm9uZXMsIHVuZGVmaW5lZCwgdXNlVmVydGV4VGV4dHVyZSApLCB0aGlzLm1hdHJpeFdvcmxkICk7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1lc2gucHJvdG90eXBlICk7XHJcblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNraW5uZWRNZXNoO1xyXG5cclxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiggc2tlbGV0b24sIGJpbmRNYXRyaXggKSB7XHJcblxyXG4gICAgdGhpcy5za2VsZXRvbiA9IHNrZWxldG9uO1xyXG5cclxuICAgIGlmICggYmluZE1hdHJpeCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XHJcblxyXG4gICAgICAgIHRoaXMuc2tlbGV0b24uY2FsY3VsYXRlSW52ZXJzZXMoKTtcclxuXHJcbiAgICAgICAgYmluZE1hdHJpeCA9IHRoaXMubWF0cml4V29ybGQ7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuYmluZE1hdHJpeC5jb3B5KCBiaW5kTWF0cml4ICk7XHJcbiAgICB0aGlzLmJpbmRNYXRyaXhJbnZlcnNlLmdldEludmVyc2UoIGJpbmRNYXRyaXggKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUucG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB0aGlzLnNrZWxldG9uLnBvc2UoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUubm9ybWFsaXplU2tpbldlaWdodHMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgaWYgKCB0aGlzLmdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHN3ID0gdGhpcy5nZW9tZXRyeS5za2luV2VpZ2h0c1sgaSBdO1xyXG5cclxuICAgICAgICAgICAgdmFyIHNjYWxlID0gMS4wIC8gc3cubGVuZ3RoTWFuaGF0dGFuKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHNjYWxlICE9PSBJbmZpbml0eSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBzdy5tdWx0aXBseVNjYWxhciggc2NhbGUgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgc3cuc2V0KCAxICk7IC8vIHRoaXMgd2lsbCBiZSBub3JtYWxpemVkIGJ5IHRoZSBzaGFkZXIgYW55d2F5XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBza2lubmluZyB3ZWlnaHRzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZCBmb3IgVEhSRUUuQnVmZmVyR2VvbWV0cnlcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkID0gZnVuY3Rpb24oIGZvcmNlICkge1xyXG5cclxuICAgIFRIUkVFLk1lc2gucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkLmNhbGwoIHRoaXMsIHRydWUgKTtcclxuXHJcbiAgICBpZiAoIHRoaXMuYmluZE1vZGUgPT09IFwiYXR0YWNoZWRcIiApIHtcclxuXHJcbiAgICAgICAgdGhpcy5iaW5kTWF0cml4SW52ZXJzZS5nZXRJbnZlcnNlKCB0aGlzLm1hdHJpeFdvcmxkICk7XHJcblxyXG4gICAgfSBlbHNlIGlmICggdGhpcy5iaW5kTW9kZSA9PT0gXCJkZXRhY2hlZFwiICkge1xyXG5cclxuICAgICAgICB0aGlzLmJpbmRNYXRyaXhJbnZlcnNlLmdldEludmVyc2UoIHRoaXMuYmluZE1hdHJpeCApO1xyXG5cclxuICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlNraW5uZWRNZXNoIHVucmVjb2duaXplZCBiaW5kTW9kZTogJyArIHRoaXMuYmluZE1vZGUgKTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsLCB0aGlzLnVzZVZlcnRleFRleHR1cmUgKS5jb3B5KCB0aGlzICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvb2JqZWN0cy9MT0QuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkxPRCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ0xPRCc7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcclxuICAgICAgICBsZXZlbHM6IHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IFtdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBvYmplY3RzOiB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkxPRDogLm9iamVjdHMgaGFzIGJlZW4gcmVuYW1lZCB0byAubGV2ZWxzLicgKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxldmVscztcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9ICk7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLkxPRC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuTE9ELnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxPRDtcclxuXHJcblRIUkVFLkxPRC5wcm90b3R5cGUuYWRkTGV2ZWwgPSBmdW5jdGlvbiAoIG9iamVjdCwgZGlzdGFuY2UgKSB7XHJcblxyXG4gICAgaWYgKCBkaXN0YW5jZSA9PT0gdW5kZWZpbmVkICkgZGlzdGFuY2UgPSAwO1xyXG5cclxuICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoIGRpc3RhbmNlICk7XHJcblxyXG4gICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xyXG5cclxuICAgIGZvciAoIHZhciBsID0gMDsgbCA8IGxldmVscy5sZW5ndGg7IGwgKysgKSB7XHJcblxyXG4gICAgICAgIGlmICggZGlzdGFuY2UgPCBsZXZlbHNbIGwgXS5kaXN0YW5jZSApIHtcclxuXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGxldmVscy5zcGxpY2UoIGwsIDAsIHsgZGlzdGFuY2U6IGRpc3RhbmNlLCBvYmplY3Q6IG9iamVjdCB9ICk7XHJcblxyXG4gICAgdGhpcy5hZGQoIG9iamVjdCApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxPRC5wcm90b3R5cGUuZ2V0T2JqZWN0Rm9yRGlzdGFuY2UgPSBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xyXG5cclxuICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcclxuXHJcbiAgICBmb3IgKCB2YXIgaSA9IDEsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgaWYgKCBkaXN0YW5jZSA8IGxldmVsc1sgaSBdLmRpc3RhbmNlICkge1xyXG5cclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGxldmVsc1sgaSAtIDEgXS5vYmplY3Q7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTE9ELnByb3RvdHlwZS5yYXljYXN0ID0gKCBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIG1hdHJpeFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xyXG5cclxuICAgICAgICBtYXRyaXhQb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHJcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggbWF0cml4UG9zaXRpb24gKTtcclxuXHJcbiAgICAgICAgdGhpcy5nZXRPYmplY3RGb3JEaXN0YW5jZSggZGlzdGFuY2UgKS5yYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKTtcclxuXHJcbiAgICB9O1xyXG5cclxufSgpICk7XHJcblxyXG5USFJFRS5MT0QucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgdmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCBjYW1lcmEgKSB7XHJcblxyXG4gICAgICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcclxuXHJcbiAgICAgICAgaWYgKCBsZXZlbHMubGVuZ3RoID4gMSApIHtcclxuXHJcbiAgICAgICAgICAgIHYxLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XHJcbiAgICAgICAgICAgIHYyLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xyXG5cclxuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gdjEuZGlzdGFuY2VUbyggdjIgKTtcclxuXHJcbiAgICAgICAgICAgIGxldmVsc1sgMCBdLm9iamVjdC52aXNpYmxlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMSwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggZGlzdGFuY2UgPj0gbGV2ZWxzWyBpIF0uZGlzdGFuY2UgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxldmVsc1sgaSAtIDEgXS5vYmplY3QudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldmVsc1sgaSBdLm9iamVjdC52aXNpYmxlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKCA7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGxldmVsc1sgaSBdLm9iamVjdC52aXNpYmxlID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxufSgpO1xyXG5cclxuVEhSRUUuTE9ELnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG4gICAgVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlLCBmYWxzZSApO1xyXG5cclxuICAgIHZhciBsZXZlbHMgPSBzb3VyY2UubGV2ZWxzO1xyXG5cclxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbIGkgXTtcclxuXHJcbiAgICAgICAgdGhpcy5hZGRMZXZlbCggbGV2ZWwub2JqZWN0LmNsb25lKCksIGxldmVsLmRpc3RhbmNlICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxPRC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCBtZXRhICkge1xyXG5cclxuICAgIHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XHJcblxyXG4gICAgZGF0YS5vYmplY3QubGV2ZWxzID0gW107XHJcblxyXG4gICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xyXG5cclxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbIGkgXTtcclxuXHJcbiAgICAgICAgZGF0YS5vYmplY3QubGV2ZWxzLnB1c2goIHtcclxuICAgICAgICAgICAgb2JqZWN0OiBsZXZlbC5vYmplY3QudXVpZCxcclxuICAgICAgICAgICAgZGlzdGFuY2U6IGxldmVsLmRpc3RhbmNlXHJcbiAgICAgICAgfSApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGF0YTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9vYmplY3RzL1Nwcml0ZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU3ByaXRlID0gKCBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoIFsgMCwgMSwgMiwgIDAsIDIsIDMgXSApO1xyXG4gICAgdmFyIHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggWyAtIDAuNSwgLSAwLjUsIDAsICAgMC41LCAtIDAuNSwgMCwgICAwLjUsIDAuNSwgMCwgICAtIDAuNSwgMC41LCAwIF0gKTtcclxuICAgIHZhciB1dnMgPSBuZXcgRmxvYXQzMkFycmF5KCBbIDAsIDAsICAgMSwgMCwgICAxLCAxLCAgIDAsIDEgXSApO1xyXG5cclxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xyXG4gICAgZ2VvbWV0cnkuc2V0SW5kZXgoIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGluZGljZXMsIDEgKSApO1xyXG4gICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XHJcbiAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIFNwcml0ZSggbWF0ZXJpYWwgKSB7XHJcblxyXG4gICAgICAgIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICAgICAgdGhpcy50eXBlID0gJ1Nwcml0ZSc7XHJcblxyXG4gICAgICAgIHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcclxuICAgICAgICB0aGlzLm1hdGVyaWFsID0gKCBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkICkgPyBtYXRlcmlhbCA6IG5ldyBUSFJFRS5TcHJpdGVNYXRlcmlhbCgpO1xyXG5cclxuICAgIH07XHJcblxyXG59ICkoKTtcclxuXHJcblRIUkVFLlNwcml0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuU3ByaXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwcml0ZTtcclxuXHJcblRIUkVFLlNwcml0ZS5wcm90b3R5cGUucmF5Y2FzdCA9ICggZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBtYXRyaXhQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcclxuXHJcbiAgICAgICAgbWF0cml4UG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XHJcblxyXG4gICAgICAgIHZhciBkaXN0YW5jZVNxID0gcmF5Y2FzdGVyLnJheS5kaXN0YW5jZVNxVG9Qb2ludCggbWF0cml4UG9zaXRpb24gKTtcclxuICAgICAgICB2YXIgZ3Vlc3NTaXplU3EgPSB0aGlzLnNjYWxlLnggKiB0aGlzLnNjYWxlLnk7XHJcblxyXG4gICAgICAgIGlmICggZGlzdGFuY2VTcSA+IGd1ZXNzU2l6ZVNxICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVyc2VjdHMucHVzaCgge1xyXG5cclxuICAgICAgICAgICAgZGlzdGFuY2U6IE1hdGguc3FydCggZGlzdGFuY2VTcSApLFxyXG4gICAgICAgICAgICBwb2ludDogdGhpcy5wb3NpdGlvbixcclxuICAgICAgICAgICAgZmFjZTogbnVsbCxcclxuICAgICAgICAgICAgb2JqZWN0OiB0aGlzXHJcblxyXG4gICAgICAgIH0gKTtcclxuXHJcbiAgICB9O1xyXG5cclxufSgpICk7XHJcblxyXG5USFJFRS5TcHJpdGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5tYXRlcmlhbCApLmNvcHkoIHRoaXMgKTtcclxuXHJcbn07XHJcblxyXG4vLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxyXG5cclxuVEhSRUUuUGFydGljbGUgPSBUSFJFRS5TcHJpdGU7XHJcblxyXG4vLyBGaWxlOnNyYy9vYmplY3RzL0xlbnNGbGFyZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTGVuc0ZsYXJlID0gZnVuY3Rpb24gKCB0ZXh0dXJlLCBzaXplLCBkaXN0YW5jZSwgYmxlbmRpbmcsIGNvbG9yICkge1xyXG5cclxuICAgIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICB0aGlzLmxlbnNGbGFyZXMgPSBbXTtcclxuXHJcbiAgICB0aGlzLnBvc2l0aW9uU2NyZWVuID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgIHRoaXMuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgaWYgKCB0ZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkKCB0ZXh0dXJlLCBzaXplLCBkaXN0YW5jZSwgYmxlbmRpbmcsIGNvbG9yICk7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcblRIUkVFLkxlbnNGbGFyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuTGVuc0ZsYXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxlbnNGbGFyZTtcclxuXHJcblxyXG4vKlxyXG4gKiBBZGQ6IGFkZHMgYW5vdGhlciBmbGFyZVxyXG4gKi9cclxuXHJcblRIUkVFLkxlbnNGbGFyZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKCB0ZXh0dXJlLCBzaXplLCBkaXN0YW5jZSwgYmxlbmRpbmcsIGNvbG9yLCBvcGFjaXR5ICkge1xyXG5cclxuICAgIGlmICggc2l6ZSA9PT0gdW5kZWZpbmVkICkgc2l6ZSA9IC0gMTtcclxuICAgIGlmICggZGlzdGFuY2UgPT09IHVuZGVmaW5lZCApIGRpc3RhbmNlID0gMDtcclxuICAgIGlmICggb3BhY2l0eSA9PT0gdW5kZWZpbmVkICkgb3BhY2l0eSA9IDE7XHJcbiAgICBpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSBjb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcclxuICAgIGlmICggYmxlbmRpbmcgPT09IHVuZGVmaW5lZCApIGJsZW5kaW5nID0gVEhSRUUuTm9ybWFsQmxlbmRpbmc7XHJcblxyXG4gICAgZGlzdGFuY2UgPSBNYXRoLm1pbiggZGlzdGFuY2UsIE1hdGgubWF4KCAwLCBkaXN0YW5jZSApICk7XHJcblxyXG4gICAgdGhpcy5sZW5zRmxhcmVzLnB1c2goIHtcclxuICAgICAgICB0ZXh0dXJlOiB0ZXh0dXJlLFx0Ly8gVEhSRUUuVGV4dHVyZVxyXG4gICAgICAgIHNpemU6IHNpemUsIFx0XHQvLyBzaXplIGluIHBpeGVscyAoLTEgPSB1c2UgdGV4dHVyZS53aWR0aClcclxuICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UsIFx0Ly8gZGlzdGFuY2UgKDAtMSkgZnJvbSBsaWdodCBzb3VyY2UgKDA9YXQgbGlnaHQgc291cmNlKVxyXG4gICAgICAgIHg6IDAsIHk6IDAsIHo6IDAsXHQvLyBzY3JlZW4gcG9zaXRpb24gKC0xID0+IDEpIHogPSAwIGlzIGluIGZyb250IHogPSAxIGlzIGJhY2tcclxuICAgICAgICBzY2FsZTogMSwgXHRcdC8vIHNjYWxlXHJcbiAgICAgICAgcm90YXRpb246IDAsIFx0XHQvLyByb3RhdGlvblxyXG4gICAgICAgIG9wYWNpdHk6IG9wYWNpdHksXHQvLyBvcGFjaXR5XHJcbiAgICAgICAgY29sb3I6IGNvbG9yLFx0XHQvLyBjb2xvclxyXG4gICAgICAgIGJsZW5kaW5nOiBibGVuZGluZ1x0Ly8gYmxlbmRpbmdcclxuICAgIH0gKTtcclxuXHJcbn07XHJcblxyXG4vKlxyXG4gKiBVcGRhdGUgbGVucyBmbGFyZXMgdXBkYXRlIHBvc2l0aW9ucyBvbiBhbGwgZmxhcmVzIGJhc2VkIG9uIHRoZSBzY3JlZW4gcG9zaXRpb25cclxuICogU2V0IG15TGVuc0ZsYXJlLmN1c3RvbVVwZGF0ZUNhbGxiYWNrIHRvIGFsdGVyIHRoZSBmbGFyZXMgaW4geW91ciBwcm9qZWN0IHNwZWNpZmljIHdheS5cclxuICovXHJcblxyXG5USFJFRS5MZW5zRmxhcmUucHJvdG90eXBlLnVwZGF0ZUxlbnNGbGFyZXMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIGYsIGZsID0gdGhpcy5sZW5zRmxhcmVzLmxlbmd0aDtcclxuICAgIHZhciBmbGFyZTtcclxuICAgIHZhciB2ZWNYID0gLSB0aGlzLnBvc2l0aW9uU2NyZWVuLnggKiAyO1xyXG4gICAgdmFyIHZlY1kgPSAtIHRoaXMucG9zaXRpb25TY3JlZW4ueSAqIDI7XHJcblxyXG4gICAgZm9yICggZiA9IDA7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcbiAgICAgICAgZmxhcmUgPSB0aGlzLmxlbnNGbGFyZXNbIGYgXTtcclxuXHJcbiAgICAgICAgZmxhcmUueCA9IHRoaXMucG9zaXRpb25TY3JlZW4ueCArIHZlY1ggKiBmbGFyZS5kaXN0YW5jZTtcclxuICAgICAgICBmbGFyZS55ID0gdGhpcy5wb3NpdGlvblNjcmVlbi55ICsgdmVjWSAqIGZsYXJlLmRpc3RhbmNlO1xyXG5cclxuICAgICAgICBmbGFyZS53YW50ZWRSb3RhdGlvbiA9IGZsYXJlLnggKiBNYXRoLlBJICogMC4yNTtcclxuICAgICAgICBmbGFyZS5yb3RhdGlvbiArPSAoIGZsYXJlLndhbnRlZFJvdGF0aW9uIC0gZmxhcmUucm90YXRpb24gKSAqIDAuMjU7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcblRIUkVFLkxlbnNGbGFyZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuICAgIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuICAgIHRoaXMucG9zaXRpb25TY3JlZW4uY29weSggc291cmNlLnBvc2l0aW9uU2NyZWVuICk7XHJcbiAgICB0aGlzLmN1c3RvbVVwZGF0ZUNhbGxiYWNrID0gc291cmNlLmN1c3RvbVVwZGF0ZUNhbGxiYWNrO1xyXG5cclxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHNvdXJjZS5sZW5zRmxhcmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIHRoaXMubGVuc0ZsYXJlcy5wdXNoKCBzb3VyY2UubGVuc0ZsYXJlc1sgaSBdICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3NjZW5lcy9TY2VuZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU2NlbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdTY2VuZSc7XHJcblxyXG4gICAgdGhpcy5mb2cgPSBudWxsO1xyXG4gICAgdGhpcy5vdmVycmlkZU1hdGVyaWFsID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLmF1dG9VcGRhdGUgPSB0cnVlOyAvLyBjaGVja2VkIGJ5IHRoZSByZW5kZXJlclxyXG5cclxufTtcclxuXHJcblRIUkVFLlNjZW5lLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5USFJFRS5TY2VuZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TY2VuZTtcclxuXHJcblRIUkVFLlNjZW5lLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG4gICAgVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG4gICAgaWYgKCBzb3VyY2UuZm9nICE9PSBudWxsICkgdGhpcy5mb2cgPSBzb3VyY2UuZm9nLmNsb25lKCk7XHJcbiAgICBpZiAoIHNvdXJjZS5vdmVycmlkZU1hdGVyaWFsICE9PSBudWxsICkgdGhpcy5vdmVycmlkZU1hdGVyaWFsID0gc291cmNlLm92ZXJyaWRlTWF0ZXJpYWwuY2xvbmUoKTtcclxuXHJcbiAgICB0aGlzLmF1dG9VcGRhdGUgPSBzb3VyY2UuYXV0b1VwZGF0ZTtcclxuICAgIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhBdXRvVXBkYXRlO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3NjZW5lcy9Gb2cuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkZvZyA9IGZ1bmN0aW9uICggY29sb3IsIG5lYXIsIGZhciApIHtcclxuXHJcbiAgICB0aGlzLm5hbWUgPSAnJztcclxuXHJcbiAgICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCBjb2xvciApO1xyXG5cclxuICAgIHRoaXMubmVhciA9ICggbmVhciAhPT0gdW5kZWZpbmVkICkgPyBuZWFyIDogMTtcclxuICAgIHRoaXMuZmFyID0gKCBmYXIgIT09IHVuZGVmaW5lZCApID8gZmFyIDogMTAwMDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Gb2cucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuRm9nKCB0aGlzLmNvbG9yLmdldEhleCgpLCB0aGlzLm5lYXIsIHRoaXMuZmFyICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvc2NlbmVzL0ZvZ0V4cDIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkZvZ0V4cDIgPSBmdW5jdGlvbiAoIGNvbG9yLCBkZW5zaXR5ICkge1xyXG5cclxuICAgIHRoaXMubmFtZSA9ICcnO1xyXG5cclxuICAgIHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yICk7XHJcbiAgICB0aGlzLmRlbnNpdHkgPSAoIGRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gZGVuc2l0eSA6IDAuMDAwMjU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRm9nRXhwMi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5Gb2dFeHAyKCB0aGlzLmNvbG9yLmdldEhleCgpLCB0aGlzLmRlbnNpdHkgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay5qc1xyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmsgPSB7fTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2FscGhhbWFwX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnYWxwaGFtYXBfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9BTFBIQU1BUFxcblxcblx0ZGlmZnVzZUNvbG9yLmEgKj0gdGV4dHVyZTJEKCBhbHBoYU1hcCwgdlV2ICkuZztcXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2FscGhhbWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdhbHBoYW1hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfQUxQSEFNQVBcXG5cXG5cdHVuaWZvcm0gc2FtcGxlcjJEIGFscGhhTWFwO1xcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYWxwaGF0ZXN0X2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnYWxwaGF0ZXN0X2ZyYWdtZW50J10gPSBcIiNpZmRlZiBBTFBIQVRFU1RcXG5cXG5cdGlmICggZGlmZnVzZUNvbG9yLmEgPCBBTFBIQVRFU1QgKSBkaXNjYXJkO1xcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYW9tYXBfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdhb21hcF9mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0FPTUFQXFxuXFxuXHR0b3RhbEFtYmllbnRMaWdodCAqPSAoIHRleHR1cmUyRCggYW9NYXAsIHZVdjIgKS5yIC0gMS4wICkgKiBhb01hcEludGVuc2l0eSArIDEuMDtcXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2FvbWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdhb21hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfQU9NQVBcXG5cXG5cdHVuaWZvcm0gc2FtcGxlcjJEIGFvTWFwO1xcblx0dW5pZm9ybSBmbG9hdCBhb01hcEludGVuc2l0eTtcXG5cXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2JlZ2luX3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2JlZ2luX3ZlcnRleCddID0gXCJcXG52ZWMzIHRyYW5zZm9ybWVkID0gdmVjMyggcG9zaXRpb24gKTtcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2JlZ2lubm9ybWFsX3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2JlZ2lubm9ybWFsX3ZlcnRleCddID0gXCJcXG52ZWMzIG9iamVjdE5vcm1hbCA9IHZlYzMoIG5vcm1hbCApO1xcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYnVtcG1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnYnVtcG1hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfQlVNUE1BUFxcblxcblx0dW5pZm9ybSBzYW1wbGVyMkQgYnVtcE1hcDtcXG5cdHVuaWZvcm0gZmxvYXQgYnVtcFNjYWxlO1xcblxcblxcblxcblx0dmVjMiBkSGR4eV9md2QoKSB7XFxuXFxuXHRcdHZlYzIgZFNUZHggPSBkRmR4KCB2VXYgKTtcXG5cdFx0dmVjMiBkU1RkeSA9IGRGZHkoIHZVdiApO1xcblxcblx0XHRmbG9hdCBIbGwgPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZVdiApLng7XFxuXHRcdGZsb2F0IGRCeCA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICsgZFNUZHggKS54IC0gSGxsO1xcblx0XHRmbG9hdCBkQnkgPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZVdiArIGRTVGR5ICkueCAtIEhsbDtcXG5cXG5cdFx0cmV0dXJuIHZlYzIoIGRCeCwgZEJ5ICk7XFxuXFxuXHR9XFxuXFxuXHR2ZWMzIHBlcnR1cmJOb3JtYWxBcmIoIHZlYzMgc3VyZl9wb3MsIHZlYzMgc3VyZl9ub3JtLCB2ZWMyIGRIZHh5ICkge1xcblxcblx0XHR2ZWMzIHZTaWdtYVggPSBkRmR4KCBzdXJmX3BvcyApO1xcblx0XHR2ZWMzIHZTaWdtYVkgPSBkRmR5KCBzdXJmX3BvcyApO1xcblx0XHR2ZWMzIHZOID0gc3VyZl9ub3JtO1xcblx0XHR2ZWMzIFIxID0gY3Jvc3MoIHZTaWdtYVksIHZOICk7XFxuXHRcdHZlYzMgUjIgPSBjcm9zcyggdk4sIHZTaWdtYVggKTtcXG5cXG5cdFx0ZmxvYXQgZkRldCA9IGRvdCggdlNpZ21hWCwgUjEgKTtcXG5cXG5cdFx0dmVjMyB2R3JhZCA9IHNpZ24oIGZEZXQgKSAqICggZEhkeHkueCAqIFIxICsgZEhkeHkueSAqIFIyICk7XFxuXHRcdHJldHVybiBub3JtYWxpemUoIGFicyggZkRldCApICogc3VyZl9ub3JtIC0gdkdyYWQgKTtcXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2NvbG9yX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnY29sb3JfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9DT0xPUlxcblxcblx0ZGlmZnVzZUNvbG9yLnJnYiAqPSB2Q29sb3I7XFxuXFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jb2xvcl9wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnY29sb3JfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0NPTE9SXFxuXFxuXHR2YXJ5aW5nIHZlYzMgdkNvbG9yO1xcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvY29sb3JfcGFyc192ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdjb2xvcl9wYXJzX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX0NPTE9SXFxuXFxuXHR2YXJ5aW5nIHZlYzMgdkNvbG9yO1xcblxcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvY29sb3JfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnY29sb3JfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfQ09MT1JcXG5cXG5cdHZDb2xvci54eXogPSBjb2xvci54eXo7XFxuXFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jb21tb24uZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdjb21tb24nXSA9IFwiI2RlZmluZSBQSSAzLjE0MTU5XFxuI2RlZmluZSBQSTIgNi4yODMxOFxcbiNkZWZpbmUgUkVDSVBST0NBTF9QSTIgMC4xNTkxNTQ5NFxcbiNkZWZpbmUgTE9HMiAxLjQ0MjY5NVxcbiNkZWZpbmUgRVBTSUxPTiAxZS02XFxuXFxuI2RlZmluZSBzYXR1cmF0ZShhKSBjbGFtcCggYSwgMC4wLCAxLjAgKVxcbiNkZWZpbmUgd2hpdGVDb21wbGltZW50KGEpICggMS4wIC0gc2F0dXJhdGUoIGEgKSApXFxuXFxudmVjMyB0cmFuc2Zvcm1EaXJlY3Rpb24oIGluIHZlYzMgbm9ybWFsLCBpbiBtYXQ0IG1hdHJpeCApIHtcXG5cXG5cdHJldHVybiBub3JtYWxpemUoICggbWF0cml4ICogdmVjNCggbm9ybWFsLCAwLjAgKSApLnh5eiApO1xcblxcbn1cXG5cXG52ZWMzIGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIGluIHZlYzMgbm9ybWFsLCBpbiBtYXQ0IG1hdHJpeCApIHtcXG5cXG5cdHJldHVybiBub3JtYWxpemUoICggdmVjNCggbm9ybWFsLCAwLjAgKSAqIG1hdHJpeCApLnh5eiApO1xcblxcbn1cXG5cXG52ZWMzIHByb2plY3RPblBsYW5lKGluIHZlYzMgcG9pbnQsIGluIHZlYzMgcG9pbnRPblBsYW5lLCBpbiB2ZWMzIHBsYW5lTm9ybWFsICkge1xcblxcblx0ZmxvYXQgZGlzdGFuY2UgPSBkb3QoIHBsYW5lTm9ybWFsLCBwb2ludCAtIHBvaW50T25QbGFuZSApO1xcblxcblx0cmV0dXJuIC0gZGlzdGFuY2UgKiBwbGFuZU5vcm1hbCArIHBvaW50O1xcblxcbn1cXG5cXG5mbG9hdCBzaWRlT2ZQbGFuZSggaW4gdmVjMyBwb2ludCwgaW4gdmVjMyBwb2ludE9uUGxhbmUsIGluIHZlYzMgcGxhbmVOb3JtYWwgKSB7XFxuXFxuXHRyZXR1cm4gc2lnbiggZG90KCBwb2ludCAtIHBvaW50T25QbGFuZSwgcGxhbmVOb3JtYWwgKSApO1xcblxcbn1cXG5cXG52ZWMzIGxpbmVQbGFuZUludGVyc2VjdCggaW4gdmVjMyBwb2ludE9uTGluZSwgaW4gdmVjMyBsaW5lRGlyZWN0aW9uLCBpbiB2ZWMzIHBvaW50T25QbGFuZSwgaW4gdmVjMyBwbGFuZU5vcm1hbCApIHtcXG5cXG5cdHJldHVybiBsaW5lRGlyZWN0aW9uICogKCBkb3QoIHBsYW5lTm9ybWFsLCBwb2ludE9uUGxhbmUgLSBwb2ludE9uTGluZSApIC8gZG90KCBwbGFuZU5vcm1hbCwgbGluZURpcmVjdGlvbiApICkgKyBwb2ludE9uTGluZTtcXG5cXG59XFxuXFxuZmxvYXQgY2FsY0xpZ2h0QXR0ZW51YXRpb24oIGZsb2F0IGxpZ2h0RGlzdGFuY2UsIGZsb2F0IGN1dG9mZkRpc3RhbmNlLCBmbG9hdCBkZWNheUV4cG9uZW50ICkge1xcblxcblx0aWYgKCBkZWNheUV4cG9uZW50ID4gMC4wICkge1xcblxcblx0ICByZXR1cm4gcG93KCBzYXR1cmF0ZSggLWxpZ2h0RGlzdGFuY2UgLyBjdXRvZmZEaXN0YW5jZSArIDEuMCApLCBkZWNheUV4cG9uZW50ICk7XFxuXFxuXHR9XFxuXFxuXHRyZXR1cm4gMS4wO1xcblxcbn1cXG5cXG52ZWMzIEZfU2NobGljayggaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBpbiBmbG9hdCBkb3RMSCApIHtcXG5cXG5cXG5cdGZsb2F0IGZyZXNuZWwgPSBleHAyKCAoIC01LjU1NDM3ICogZG90TEggLSA2Ljk4MzE2ICkgKiBkb3RMSCApO1xcblxcblx0cmV0dXJuICggMS4wIC0gc3BlY3VsYXJDb2xvciApICogZnJlc25lbCArIHNwZWN1bGFyQ29sb3I7XFxuXFxufVxcblxcbmZsb2F0IEdfQmxpbm5QaG9uZ19JbXBsaWNpdCggLyogaW4gZmxvYXQgZG90TkwsIGluIGZsb2F0IGRvdE5WICovICkge1xcblxcblxcblx0cmV0dXJuIDAuMjU7XFxuXFxufVxcblxcbmZsb2F0IERfQmxpbm5QaG9uZyggaW4gZmxvYXQgc2hpbmluZXNzLCBpbiBmbG9hdCBkb3ROSCApIHtcXG5cXG5cXG5cdHJldHVybiAoIHNoaW5pbmVzcyAqIDAuNSArIDEuMCApICogcG93KCBkb3ROSCwgc2hpbmluZXNzICk7XFxuXFxufVxcblxcbnZlYzMgQlJERl9CbGlublBob25nKCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGluIGZsb2F0IHNoaW5pbmVzcywgaW4gdmVjMyBub3JtYWwsIGluIHZlYzMgbGlnaHREaXIsIGluIHZlYzMgdmlld0RpciApIHtcXG5cXG5cdHZlYzMgaGFsZkRpciA9IG5vcm1hbGl6ZSggbGlnaHREaXIgKyB2aWV3RGlyICk7XFxuXFxuXHRmbG9hdCBkb3ROSCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgaGFsZkRpciApICk7XFxuXHRmbG9hdCBkb3RMSCA9IHNhdHVyYXRlKCBkb3QoIGxpZ2h0RGlyLCBoYWxmRGlyICkgKTtcXG5cXG5cdHZlYzMgRiA9IEZfU2NobGljayggc3BlY3VsYXJDb2xvciwgZG90TEggKTtcXG5cXG5cdGZsb2F0IEcgPSBHX0JsaW5uUGhvbmdfSW1wbGljaXQoIC8qIGRvdE5MLCBkb3ROViAqLyApO1xcblxcblx0ZmxvYXQgRCA9IERfQmxpbm5QaG9uZyggc2hpbmluZXNzLCBkb3ROSCApO1xcblxcblx0cmV0dXJuIEYgKiBHICogRDtcXG5cXG59XFxuXFxudmVjMyBpbnB1dFRvTGluZWFyKCBpbiB2ZWMzIGEgKSB7XFxuXFxuXHQjaWZkZWYgR0FNTUFfSU5QVVRcXG5cXG5cdFx0cmV0dXJuIHBvdyggYSwgdmVjMyggZmxvYXQoIEdBTU1BX0ZBQ1RPUiApICkgKTtcXG5cXG5cdCNlbHNlXFxuXFxuXHRcdHJldHVybiBhO1xcblxcblx0I2VuZGlmXFxuXFxufVxcblxcbnZlYzMgbGluZWFyVG9PdXRwdXQoIGluIHZlYzMgYSApIHtcXG5cXG5cdCNpZmRlZiBHQU1NQV9PVVRQVVRcXG5cXG5cdFx0cmV0dXJuIHBvdyggYSwgdmVjMyggMS4wIC8gZmxvYXQoIEdBTU1BX0ZBQ1RPUiApICkgKTtcXG5cXG5cdCNlbHNlXFxuXFxuXHRcdHJldHVybiBhO1xcblxcblx0I2VuZGlmXFxuXFxufVxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZGVmYXVsdG5vcm1hbF92ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdkZWZhdWx0bm9ybWFsX3ZlcnRleCddID0gXCIjaWZkZWYgRkxJUF9TSURFRFxcblxcblx0b2JqZWN0Tm9ybWFsID0gLW9iamVjdE5vcm1hbDtcXG5cXG4jZW5kaWZcXG5cXG52ZWMzIHRyYW5zZm9ybWVkTm9ybWFsID0gbm9ybWFsTWF0cml4ICogb2JqZWN0Tm9ybWFsO1xcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZGlzcGxhY2VtZW50bWFwX3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2Rpc3BsYWNlbWVudG1hcF92ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVBcXG5cXG5cdHRyYW5zZm9ybWVkICs9IG5vcm1hbCAqICggdGV4dHVyZTJEKCBkaXNwbGFjZW1lbnRNYXAsIHV2ICkueCAqIGRpc3BsYWNlbWVudFNjYWxlICsgZGlzcGxhY2VtZW50QmlhcyApO1xcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQXFxuXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBkaXNwbGFjZW1lbnRNYXA7XFxuXHR1bmlmb3JtIGZsb2F0IGRpc3BsYWNlbWVudFNjYWxlO1xcblx0dW5pZm9ybSBmbG9hdCBkaXNwbGFjZW1lbnRCaWFzO1xcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW1pc3NpdmVtYXBfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdlbWlzc2l2ZW1hcF9mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0VNSVNTSVZFTUFQXFxuXFxuXHR2ZWM0IGVtaXNzaXZlQ29sb3IgPSB0ZXh0dXJlMkQoIGVtaXNzaXZlTWFwLCB2VXYgKTtcXG5cXG5cdGVtaXNzaXZlQ29sb3IucmdiID0gaW5wdXRUb0xpbmVhciggZW1pc3NpdmVDb2xvci5yZ2IgKTtcXG5cXG5cdHRvdGFsRW1pc3NpdmVMaWdodCAqPSBlbWlzc2l2ZUNvbG9yLnJnYjtcXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2VtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfRU1JU1NJVkVNQVBcXG5cXG5cdHVuaWZvcm0gc2FtcGxlcjJEIGVtaXNzaXZlTWFwO1xcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW52bWFwX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnZW52bWFwX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfRU5WTUFQXFxuXFxuXHQjaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKVxcblxcblx0XHR2ZWMzIGNhbWVyYVRvVmVydGV4ID0gbm9ybWFsaXplKCB2V29ybGRQb3NpdGlvbiAtIGNhbWVyYVBvc2l0aW9uICk7XFxuXFxuXHRcdHZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBub3JtYWwsIHZpZXdNYXRyaXggKTtcXG5cXG5cdFx0I2lmZGVmIEVOVk1BUF9NT0RFX1JFRkxFQ1RJT05cXG5cXG5cdFx0XHR2ZWMzIHJlZmxlY3RWZWMgPSByZWZsZWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwgKTtcXG5cXG5cdFx0I2Vsc2VcXG5cXG5cdFx0XHR2ZWMzIHJlZmxlY3RWZWMgPSByZWZyYWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1xcblxcblx0XHQjZW5kaWZcXG5cXG5cdCNlbHNlXFxuXFxuXHRcdHZlYzMgcmVmbGVjdFZlYyA9IHZSZWZsZWN0O1xcblxcblx0I2VuZGlmXFxuXFxuXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXHRcdGZsb2F0IGZsaXBOb3JtYWwgPSAoIGZsb2F0KCBnbF9Gcm9udEZhY2luZyApICogMi4wIC0gMS4wICk7XFxuXHQjZWxzZVxcblx0XHRmbG9hdCBmbGlwTm9ybWFsID0gMS4wO1xcblx0I2VuZGlmXFxuXFxuXHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxcblx0XHR2ZWM0IGVudkNvbG9yID0gdGV4dHVyZUN1YmUoIGVudk1hcCwgZmxpcE5vcm1hbCAqIHZlYzMoIGZsaXBFbnZNYXAgKiByZWZsZWN0VmVjLngsIHJlZmxlY3RWZWMueXogKSApO1xcblxcblx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfRVFVSVJFQyApXFxuXHRcdHZlYzIgc2FtcGxlVVY7XFxuXHRcdHNhbXBsZVVWLnkgPSBzYXR1cmF0ZSggZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueSAqIDAuNSArIDAuNSApO1xcblx0XHRzYW1wbGVVVi54ID0gYXRhbiggZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueiwgZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueCApICogUkVDSVBST0NBTF9QSTIgKyAwLjU7XFxuXHRcdHZlYzQgZW52Q29sb3IgPSB0ZXh0dXJlMkQoIGVudk1hcCwgc2FtcGxlVVYgKTtcXG5cXG5cdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX1NQSEVSRSApXFxuXHRcdHZlYzMgcmVmbGVjdFZpZXcgPSBmbGlwTm9ybWFsICogbm9ybWFsaXplKCh2aWV3TWF0cml4ICogdmVjNCggcmVmbGVjdFZlYywgMC4wICkpLnh5eiArIHZlYzMoMC4wLDAuMCwxLjApKTtcXG5cdFx0dmVjNCBlbnZDb2xvciA9IHRleHR1cmUyRCggZW52TWFwLCByZWZsZWN0Vmlldy54eSAqIDAuNSArIDAuNSApO1xcblx0I2VuZGlmXFxuXFxuXHRlbnZDb2xvci54eXogPSBpbnB1dFRvTGluZWFyKCBlbnZDb2xvci54eXogKTtcXG5cXG5cdCNpZmRlZiBFTlZNQVBfQkxFTkRJTkdfTVVMVElQTFlcXG5cXG5cdFx0b3V0Z29pbmdMaWdodCA9IG1peCggb3V0Z29pbmdMaWdodCwgb3V0Z29pbmdMaWdodCAqIGVudkNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1xcblxcblx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX0JMRU5ESU5HX01JWCApXFxuXFxuXHRcdG91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIGVudkNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1xcblxcblx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX0JMRU5ESU5HX0FERCApXFxuXFxuXHRcdG91dGdvaW5nTGlnaHQgKz0gZW52Q29sb3IueHl6ICogc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eTtcXG5cXG5cdCNlbmRpZlxcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW52bWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdlbnZtYXBfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0VOVk1BUFxcblxcblx0dW5pZm9ybSBmbG9hdCByZWZsZWN0aXZpdHk7XFxuXHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxcblx0XHR1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDtcXG5cdCNlbHNlXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIGVudk1hcDtcXG5cdCNlbmRpZlxcblx0dW5pZm9ybSBmbG9hdCBmbGlwRW52TWFwO1xcblxcblx0I2lmIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HIClcXG5cXG5cdFx0dW5pZm9ybSBmbG9hdCByZWZyYWN0aW9uUmF0aW87XFxuXFxuXHQjZWxzZVxcblxcblx0XHR2YXJ5aW5nIHZlYzMgdlJlZmxlY3Q7XFxuXFxuXHQjZW5kaWZcXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2Vudm1hcF9wYXJzX3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2Vudm1hcF9wYXJzX3ZlcnRleCddID0gXCIjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmICEgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSAmJiAhIGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSAmJiAhIGRlZmluZWQoIFBIT05HIClcXG5cXG5cdHZhcnlpbmcgdmVjMyB2UmVmbGVjdDtcXG5cXG5cdHVuaWZvcm0gZmxvYXQgcmVmcmFjdGlvblJhdGlvO1xcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW52bWFwX3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2Vudm1hcF92ZXJ0ZXgnXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiAhIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgJiYgISBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgJiYgISBkZWZpbmVkKCBQSE9ORyApXFxuXFxuXHR2ZWMzIGNhbWVyYVRvVmVydGV4ID0gbm9ybWFsaXplKCB3b3JsZFBvc2l0aW9uLnh5eiAtIGNhbWVyYVBvc2l0aW9uICk7XFxuXFxuXHR2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggdHJhbnNmb3JtZWROb3JtYWwsIHZpZXdNYXRyaXggKTtcXG5cXG5cdCNpZmRlZiBFTlZNQVBfTU9ERV9SRUZMRUNUSU9OXFxuXFxuXHRcdHZSZWZsZWN0ID0gcmVmbGVjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsICk7XFxuXFxuXHQjZWxzZVxcblxcblx0XHR2UmVmbGVjdCA9IHJlZnJhY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7XFxuXFxuXHQjZW5kaWZcXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2ZvZ19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2ZvZ19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0ZPR1xcblxcblx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cXG5cdFx0ZmxvYXQgZGVwdGggPSBnbF9GcmFnRGVwdGhFWFQgLyBnbF9GcmFnQ29vcmQudztcXG5cXG5cdCNlbHNlXFxuXFxuXHRcdGZsb2F0IGRlcHRoID0gZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudztcXG5cXG5cdCNlbmRpZlxcblxcblx0I2lmZGVmIEZPR19FWFAyXFxuXFxuXHRcdGZsb2F0IGZvZ0ZhY3RvciA9IHdoaXRlQ29tcGxpbWVudCggZXhwMiggLSBmb2dEZW5zaXR5ICogZm9nRGVuc2l0eSAqIGRlcHRoICogZGVwdGggKiBMT0cyICkgKTtcXG5cXG5cdCNlbHNlXFxuXFxuXHRcdGZsb2F0IGZvZ0ZhY3RvciA9IHNtb290aHN0ZXAoIGZvZ05lYXIsIGZvZ0ZhciwgZGVwdGggKTtcXG5cXG5cdCNlbmRpZlxcblx0XFxuXHRvdXRnb2luZ0xpZ2h0ID0gbWl4KCBvdXRnb2luZ0xpZ2h0LCBmb2dDb2xvciwgZm9nRmFjdG9yICk7XFxuXFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9mb2dfcGFyc19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2ZvZ19wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfRk9HXFxuXFxuXHR1bmlmb3JtIHZlYzMgZm9nQ29sb3I7XFxuXFxuXHQjaWZkZWYgRk9HX0VYUDJcXG5cXG5cdFx0dW5pZm9ybSBmbG9hdCBmb2dEZW5zaXR5O1xcblxcblx0I2Vsc2VcXG5cXG5cdFx0dW5pZm9ybSBmbG9hdCBmb2dOZWFyO1xcblx0XHR1bmlmb3JtIGZsb2F0IGZvZ0ZhcjtcXG5cdCNlbmRpZlxcblxcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvaGVtaWxpZ2h0X2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnaGVtaWxpZ2h0X2ZyYWdtZW50J10gPSBcIiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXFxuXFxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfSEVNSV9MSUdIVFM7IGkgKysgKSB7XFxuXFxuXHRcdHZlYzMgbGlnaHREaXIgPSBoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25bIGkgXTtcXG5cXG5cdFx0ZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggbm9ybWFsLCBsaWdodERpciApO1xcblxcblx0XHRmbG9hdCBoZW1pRGlmZnVzZVdlaWdodCA9IDAuNSAqIGRvdFByb2R1Y3QgKyAwLjU7XFxuXFxuXHRcdHZlYzMgbGlnaHRDb2xvciA9IG1peCggaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JbIGkgXSwgaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3JbIGkgXSwgaGVtaURpZmZ1c2VXZWlnaHQgKTtcXG5cXG5cdFx0dG90YWxBbWJpZW50TGlnaHQgKz0gbGlnaHRDb2xvcjtcXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0bWFwX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRtYXBfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9MSUdIVE1BUFxcblxcblx0dG90YWxBbWJpZW50TGlnaHQgKz0gdGV4dHVyZTJEKCBsaWdodE1hcCwgdlV2MiApLnh5eiAqIGxpZ2h0TWFwSW50ZW5zaXR5O1xcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRtYXBfcGFyc19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0bWFwX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9MSUdIVE1BUFxcblxcblx0dW5pZm9ybSBzYW1wbGVyMkQgbGlnaHRNYXA7XFxuXHR1bmlmb3JtIGZsb2F0IGxpZ2h0TWFwSW50ZW5zaXR5O1xcblxcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX2xhbWJlcnRfcGFyc192ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodHNfbGFtYmVydF9wYXJzX3ZlcnRleCddID0gXCIjaWYgTUFYX0RJUl9MSUdIVFMgPiAwXFxuXFxuXHR1bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodENvbG9yWyBNQVhfRElSX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIE1BWF9ESVJfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9IRU1JX0xJR0hUUyA+IDBcXG5cXG5cdHVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgTUFYX0hFTUlfTElHSFRTIF07XFxuXHR1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JbIE1BWF9IRU1JX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodERpcmVjdGlvblsgTUFYX0hFTUlfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXFxuXFxuXHR1bmlmb3JtIHZlYzMgcG9pbnRMaWdodENvbG9yWyBNQVhfUE9JTlRfTElHSFRTIF07XFxuXHR1bmlmb3JtIHZlYzMgcG9pbnRMaWdodFBvc2l0aW9uWyBNQVhfUE9JTlRfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHBvaW50TGlnaHREaXN0YW5jZVsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBwb2ludExpZ2h0RGVjYXlbIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX1NQT1RfTElHSFRTID4gMFxcblxcblx0dW5pZm9ybSB2ZWMzIHNwb3RMaWdodENvbG9yWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gdmVjMyBzcG90TGlnaHRQb3NpdGlvblsgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIHZlYzMgc3BvdExpZ2h0RGlyZWN0aW9uWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RGlzdGFuY2VbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBzcG90TGlnaHRBbmdsZUNvc1sgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHNwb3RMaWdodEV4cG9uZW50WyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RGVjYXlbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX2xhbWJlcnRfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX2xhbWJlcnRfdmVydGV4J10gPSBcInZMaWdodEZyb250ID0gdmVjMyggMC4wICk7XFxuXFxuI2lmZGVmIERPVUJMRV9TSURFRFxcblxcblx0dkxpZ2h0QmFjayA9IHZlYzMoIDAuMCApO1xcblxcbiNlbmRpZlxcblxcbnZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1xcblxcbiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFxcblxcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTUFYX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcXG5cXG5cdFx0dmVjMyBsaWdodENvbG9yID0gcG9pbnRMaWdodENvbG9yWyBpIF07XFxuXFxuXHRcdHZlYzMgbFZlY3RvciA9IHBvaW50TGlnaHRQb3NpdGlvblsgaSBdIC0gbXZQb3NpdGlvbi54eXo7XFxuXHRcdHZlYzMgbGlnaHREaXIgPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcXG5cXG5cXG5cdFx0ZmxvYXQgYXR0ZW51YXRpb24gPSBjYWxjTGlnaHRBdHRlbnVhdGlvbiggbGVuZ3RoKCBsVmVjdG9yICksIHBvaW50TGlnaHREaXN0YW5jZVsgaSBdLCBwb2ludExpZ2h0RGVjYXlbIGkgXSApO1xcblxcblxcblx0XHRmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCBub3JtYWwsIGxpZ2h0RGlyICk7XFxuXFxuXHRcdHZMaWdodEZyb250ICs9IGxpZ2h0Q29sb3IgKiBhdHRlbnVhdGlvbiAqIHNhdHVyYXRlKCBkb3RQcm9kdWN0ICk7XFxuXFxuXHRcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXG5cdFx0XHR2TGlnaHRCYWNrICs9IGxpZ2h0Q29sb3IgKiBhdHRlbnVhdGlvbiAqIHNhdHVyYXRlKCAtIGRvdFByb2R1Y3QgKTtcXG5cXG5cdFx0I2VuZGlmXFxuXFxuXHR9XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcXG5cXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE1BWF9TUE9UX0xJR0hUUzsgaSArKyApIHtcXG5cXG5cdFx0dmVjMyBsaWdodENvbG9yID0gc3BvdExpZ2h0Q29sb3JbIGkgXTtcXG5cXG5cdFx0dmVjMyBsaWdodFBvc2l0aW9uID0gc3BvdExpZ2h0UG9zaXRpb25bIGkgXTtcXG5cdFx0dmVjMyBsVmVjdG9yID0gbGlnaHRQb3NpdGlvbiAtIG12UG9zaXRpb24ueHl6O1xcblx0XHR2ZWMzIGxpZ2h0RGlyID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XFxuXFxuXHRcdGZsb2F0IHNwb3RFZmZlY3QgPSBkb3QoIHNwb3RMaWdodERpcmVjdGlvblsgaSBdLCBsaWdodERpciApO1xcblxcblx0XHRpZiAoIHNwb3RFZmZlY3QgPiBzcG90TGlnaHRBbmdsZUNvc1sgaSBdICkge1xcblxcblx0XHRcdHNwb3RFZmZlY3QgPSBzYXR1cmF0ZSggcG93KCBzYXR1cmF0ZSggc3BvdEVmZmVjdCApLCBzcG90TGlnaHRFeHBvbmVudFsgaSBdICkgKTtcXG5cXG5cXG5cdFx0XHRmbG9hdCBhdHRlbnVhdGlvbiA9IGNhbGNMaWdodEF0dGVudWF0aW9uKCBsZW5ndGgoIGxWZWN0b3IgKSwgc3BvdExpZ2h0RGlzdGFuY2VbIGkgXSwgc3BvdExpZ2h0RGVjYXlbIGkgXSApO1xcblxcblx0XHRcdGF0dGVudWF0aW9uICo9IHNwb3RFZmZlY3Q7XFxuXFxuXFxuXHRcdFx0ZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggbm9ybWFsLCBsaWdodERpciApO1xcblxcblx0XHRcdHZMaWdodEZyb250ICs9IGxpZ2h0Q29sb3IgKiBhdHRlbnVhdGlvbiAqIHNhdHVyYXRlKCBkb3RQcm9kdWN0ICk7XFxuXFxuXHRcdFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcblx0XHRcdFx0dkxpZ2h0QmFjayArPSBsaWdodENvbG9yICogYXR0ZW51YXRpb24gKiBzYXR1cmF0ZSggLSBkb3RQcm9kdWN0ICk7XFxuXFxuXHRcdFx0I2VuZGlmXFxuXFxuXHRcdH1cXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX0RJUl9MSUdIVFMgPiAwXFxuXFxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfRElSX0xJR0hUUzsgaSArKyApIHtcXG5cXG5cdFx0dmVjMyBsaWdodENvbG9yID0gZGlyZWN0aW9uYWxMaWdodENvbG9yWyBpIF07XFxuXFxuXHRcdHZlYzMgbGlnaHREaXIgPSBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uWyBpIF07XFxuXFxuXFxuXHRcdGZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKTtcXG5cXG5cdFx0dkxpZ2h0RnJvbnQgKz0gbGlnaHRDb2xvciAqIHNhdHVyYXRlKCBkb3RQcm9kdWN0ICk7XFxuXFxuXHRcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXG5cdFx0XHR2TGlnaHRCYWNrICs9IGxpZ2h0Q29sb3IgKiBzYXR1cmF0ZSggLSBkb3RQcm9kdWN0ICk7XFxuXFxuXHRcdCNlbmRpZlxcblxcblx0fVxcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXFxuXFxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfSEVNSV9MSUdIVFM7IGkgKysgKSB7XFxuXFxuXHRcdHZlYzMgbGlnaHREaXIgPSBoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25bIGkgXTtcXG5cXG5cXG5cdFx0ZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggbm9ybWFsLCBsaWdodERpciApO1xcblxcblx0XHRmbG9hdCBoZW1pRGlmZnVzZVdlaWdodCA9IDAuNSAqIGRvdFByb2R1Y3QgKyAwLjU7XFxuXFxuXHRcdHZMaWdodEZyb250ICs9IG1peCggaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JbIGkgXSwgaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3JbIGkgXSwgaGVtaURpZmZ1c2VXZWlnaHQgKTtcXG5cXG5cdFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcblx0XHRcdGZsb2F0IGhlbWlEaWZmdXNlV2VpZ2h0QmFjayA9IC0gMC41ICogZG90UHJvZHVjdCArIDAuNTtcXG5cXG5cdFx0XHR2TGlnaHRCYWNrICs9IG1peCggaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JbIGkgXSwgaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3JbIGkgXSwgaGVtaURpZmZ1c2VXZWlnaHRCYWNrICk7XFxuXFxuXHRcdCNlbmRpZlxcblxcblx0fVxcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX3Bob25nX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX3Bob25nX2ZyYWdtZW50J10gPSBcInZlYzMgdmlld0RpciA9IG5vcm1hbGl6ZSggdlZpZXdQb3NpdGlvbiApO1xcblxcbnZlYzMgdG90YWxEaWZmdXNlTGlnaHQgPSB2ZWMzKCAwLjAgKTtcXG52ZWMzIHRvdGFsU3BlY3VsYXJMaWdodCA9IHZlYzMoIDAuMCApO1xcblxcbiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFxcblxcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTUFYX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcXG5cXG5cdFx0dmVjMyBsaWdodENvbG9yID0gcG9pbnRMaWdodENvbG9yWyBpIF07XFxuXFxuXHRcdHZlYzMgbGlnaHRQb3NpdGlvbiA9IHBvaW50TGlnaHRQb3NpdGlvblsgaSBdO1xcblx0XHR2ZWMzIGxWZWN0b3IgPSBsaWdodFBvc2l0aW9uICsgdlZpZXdQb3NpdGlvbi54eXo7XFxuXHRcdHZlYzMgbGlnaHREaXIgPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcXG5cXG5cXG5cdFx0ZmxvYXQgYXR0ZW51YXRpb24gPSBjYWxjTGlnaHRBdHRlbnVhdGlvbiggbGVuZ3RoKCBsVmVjdG9yICksIHBvaW50TGlnaHREaXN0YW5jZVsgaSBdLCBwb2ludExpZ2h0RGVjYXlbIGkgXSApO1xcblxcblxcblx0XHRmbG9hdCBjb3NpbmVUZXJtID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBsaWdodERpciApICk7XFxuXFxuXHRcdHRvdGFsRGlmZnVzZUxpZ2h0ICs9IGxpZ2h0Q29sb3IgKiBhdHRlbnVhdGlvbiAqIGNvc2luZVRlcm07XFxuXFxuXFxuXHRcdHZlYzMgYnJkZiA9IEJSREZfQmxpbm5QaG9uZyggc3BlY3VsYXIsIHNoaW5pbmVzcywgbm9ybWFsLCBsaWdodERpciwgdmlld0RpciApO1xcblxcblx0XHR0b3RhbFNwZWN1bGFyTGlnaHQgKz0gYnJkZiAqIHNwZWN1bGFyU3RyZW5ndGggKiBsaWdodENvbG9yICogYXR0ZW51YXRpb24gKiBjb3NpbmVUZXJtO1xcblxcblxcblx0fVxcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXFxuXFxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxuXFxuXHRcdHZlYzMgbGlnaHRDb2xvciA9IHNwb3RMaWdodENvbG9yWyBpIF07XFxuXFxuXHRcdHZlYzMgbGlnaHRQb3NpdGlvbiA9IHNwb3RMaWdodFBvc2l0aW9uWyBpIF07XFxuXHRcdHZlYzMgbFZlY3RvciA9IGxpZ2h0UG9zaXRpb24gKyB2Vmlld1Bvc2l0aW9uLnh5ejtcXG5cdFx0dmVjMyBsaWdodERpciA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcblxcblx0XHRmbG9hdCBzcG90RWZmZWN0ID0gZG90KCBzcG90TGlnaHREaXJlY3Rpb25bIGkgXSwgbGlnaHREaXIgKTtcXG5cXG5cdFx0aWYgKCBzcG90RWZmZWN0ID4gc3BvdExpZ2h0QW5nbGVDb3NbIGkgXSApIHtcXG5cXG5cdFx0XHRzcG90RWZmZWN0ID0gc2F0dXJhdGUoIHBvdyggc2F0dXJhdGUoIHNwb3RFZmZlY3QgKSwgc3BvdExpZ2h0RXhwb25lbnRbIGkgXSApICk7XFxuXFxuXFxuXHRcdFx0ZmxvYXQgYXR0ZW51YXRpb24gPSBjYWxjTGlnaHRBdHRlbnVhdGlvbiggbGVuZ3RoKCBsVmVjdG9yICksIHNwb3RMaWdodERpc3RhbmNlWyBpIF0sIHNwb3RMaWdodERlY2F5WyBpIF0gKTtcXG5cXG5cdFx0XHRhdHRlbnVhdGlvbiAqPSBzcG90RWZmZWN0O1xcblxcblxcblx0XHRcdGZsb2F0IGNvc2luZVRlcm0gPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGxpZ2h0RGlyICkgKTtcXG5cXG5cdFx0XHR0b3RhbERpZmZ1c2VMaWdodCArPSBsaWdodENvbG9yICogYXR0ZW51YXRpb24gKiBjb3NpbmVUZXJtO1xcblxcblxcblx0XHRcdHZlYzMgYnJkZiA9IEJSREZfQmxpbm5QaG9uZyggc3BlY3VsYXIsIHNoaW5pbmVzcywgbm9ybWFsLCBsaWdodERpciwgdmlld0RpciApO1xcblxcblx0XHRcdHRvdGFsU3BlY3VsYXJMaWdodCArPSBicmRmICogc3BlY3VsYXJTdHJlbmd0aCAqIGxpZ2h0Q29sb3IgKiBhdHRlbnVhdGlvbiAqIGNvc2luZVRlcm07XFxuXFxuXHRcdH1cXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX0RJUl9MSUdIVFMgPiAwXFxuXFxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfRElSX0xJR0hUUzsgaSArKyApIHtcXG5cXG5cdFx0dmVjMyBsaWdodENvbG9yID0gZGlyZWN0aW9uYWxMaWdodENvbG9yWyBpIF07XFxuXFxuXHRcdHZlYzMgbGlnaHREaXIgPSBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uWyBpIF07XFxuXFxuXFxuXHRcdGZsb2F0IGNvc2luZVRlcm0gPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGxpZ2h0RGlyICkgKTtcXG5cXG5cdFx0dG90YWxEaWZmdXNlTGlnaHQgKz0gbGlnaHRDb2xvciAqIGNvc2luZVRlcm07XFxuXFxuXFxuXHRcdHZlYzMgYnJkZiA9IEJSREZfQmxpbm5QaG9uZyggc3BlY3VsYXIsIHNoaW5pbmVzcywgbm9ybWFsLCBsaWdodERpciwgdmlld0RpciApO1xcblxcblx0XHR0b3RhbFNwZWN1bGFyTGlnaHQgKz0gYnJkZiAqIHNwZWN1bGFyU3RyZW5ndGggKiBsaWdodENvbG9yICogY29zaW5lVGVybTtcXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQnXSA9IFwidW5pZm9ybSB2ZWMzIGFtYmllbnRMaWdodENvbG9yO1xcblxcbiNpZiBNQVhfRElSX0xJR0hUUyA+IDBcXG5cXG5cdHVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIE1BWF9ESVJfTElHSFRTIF07XFxuXHR1bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblsgTUFYX0RJUl9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX0hFTUlfTElHSFRTID4gMFxcblxcblx0dW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBNQVhfSEVNSV9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclsgTUFYX0hFTUlfTElHSFRTIF07XFxuXHR1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uWyBNQVhfSEVNSV9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX1BPSU5UX0xJR0hUUyA+IDBcXG5cXG5cdHVuaWZvcm0gdmVjMyBwb2ludExpZ2h0Q29sb3JbIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG5cXG5cdHVuaWZvcm0gdmVjMyBwb2ludExpZ2h0UG9zaXRpb25bIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gZmxvYXQgcG9pbnRMaWdodERpc3RhbmNlWyBNQVhfUE9JTlRfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHBvaW50TGlnaHREZWNheVsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXFxuXFxuXHR1bmlmb3JtIHZlYzMgc3BvdExpZ2h0Q29sb3JbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIHNwb3RMaWdodFBvc2l0aW9uWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gdmVjMyBzcG90TGlnaHREaXJlY3Rpb25bIE1BWF9TUE9UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBzcG90TGlnaHRBbmdsZUNvc1sgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHNwb3RMaWdodEV4cG9uZW50WyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RGlzdGFuY2VbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBzcG90TGlnaHREZWNheVsgTUFYX1NQT1RfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDAgfHwgZGVmaW5lZCggVVNFX0VOVk1BUCApXFxuXFxuXHR2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuXFxuI2VuZGlmXFxuXFxudmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuXFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcblxcblx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodHNfcGhvbmdfcGFyc192ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodHNfcGhvbmdfcGFyc192ZXJ0ZXgnXSA9IFwiI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDAgfHwgZGVmaW5lZCggVVNFX0VOVk1BUCApXFxuXFxuXHR2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXFxuXFxuXHR1bmlmb3JtIHZlYzMgcG9pbnRMaWdodFBvc2l0aW9uWyBNQVhfUE9JTlRfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodHNfcGhvbmdfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX3Bob25nX3ZlcnRleCddID0gXCIjaWYgTUFYX1NQT1RfTElHSFRTID4gMCB8fCBkZWZpbmVkKCBVU0VfRU5WTUFQIClcXG5cXG5cdHZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7XFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnQnXSA9IFwiXFxuXHRvdXRnb2luZ0xpZ2h0ID0gbGluZWFyVG9PdXRwdXQoIG91dGdvaW5nTGlnaHQgKTtcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xvZ2RlcHRoYnVmX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbG9nZGVwdGhidWZfZnJhZ21lbnQnXSA9IFwiI2lmIGRlZmluZWQoVVNFX0xPR0RFUFRIQlVGKSAmJiBkZWZpbmVkKFVTRV9MT0dERVBUSEJVRl9FWFQpXFxuXFxuXHRnbF9GcmFnRGVwdGhFWFQgPSBsb2cyKHZGcmFnRGVwdGgpICogbG9nRGVwdGhCdWZGQyAqIDAuNTtcXG5cXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXG5cXG5cdHVuaWZvcm0gZmxvYXQgbG9nRGVwdGhCdWZGQztcXG5cXG5cdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxuXFxuXHRcdHZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcXG5cXG5cdCNlbmRpZlxcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbG9nZGVwdGhidWZfcGFyc192ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxuXFxuXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFxcblxcblx0XHR2YXJ5aW5nIGZsb2F0IHZGcmFnRGVwdGg7XFxuXFxuXHQjZW5kaWZcXG5cXG5cdHVuaWZvcm0gZmxvYXQgbG9nRGVwdGhCdWZGQztcXG5cXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xvZ2RlcHRoYnVmX3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xvZ2RlcHRoYnVmX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxuXFxuXHRnbF9Qb3NpdGlvbi56ID0gbG9nMihtYXgoIEVQU0lMT04sIGdsX1Bvc2l0aW9uLncgKyAxLjAgKSkgKiBsb2dEZXB0aEJ1ZkZDO1xcblxcblx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cXG5cdFx0dkZyYWdEZXB0aCA9IDEuMCArIGdsX1Bvc2l0aW9uLnc7XFxuXFxuI2Vsc2VcXG5cXG5cdFx0Z2xfUG9zaXRpb24ueiA9IChnbF9Qb3NpdGlvbi56IC0gMS4wKSAqIGdsX1Bvc2l0aW9uLnc7XFxuXFxuXHQjZW5kaWZcXG5cXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21hcF9mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ21hcF9mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX01BUFxcblxcblx0dmVjNCB0ZXhlbENvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVdiApO1xcblxcblx0dGV4ZWxDb2xvci54eXogPSBpbnB1dFRvTGluZWFyKCB0ZXhlbENvbG9yLnh5eiApO1xcblxcblx0ZGlmZnVzZUNvbG9yICo9IHRleGVsQ29sb3I7XFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tYXBfcGFyc19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ21hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfTUFQXFxuXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XFxuXFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tYXBfcGFydGljbGVfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtYXBfcGFydGljbGVfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9NQVBcXG5cXG5cdGRpZmZ1c2VDb2xvciAqPSB0ZXh0dXJlMkQoIG1hcCwgdmVjMiggZ2xfUG9pbnRDb29yZC54LCAxLjAgLSBnbF9Qb2ludENvb3JkLnkgKSAqIG9mZnNldFJlcGVhdC56dyArIG9mZnNldFJlcGVhdC54eSApO1xcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX01BUFxcblxcblx0dW5pZm9ybSB2ZWM0IG9mZnNldFJlcGVhdDtcXG5cdHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21vcnBobm9ybWFsX3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ21vcnBobm9ybWFsX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX01PUlBITk9STUFMU1xcblxcblx0b2JqZWN0Tm9ybWFsICs9ICggbW9ycGhOb3JtYWwwIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDAgXTtcXG5cdG9iamVjdE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMSAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAxIF07XFxuXHRvYmplY3ROb3JtYWwgKz0gKCBtb3JwaE5vcm1hbDIgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMiBdO1xcblx0b2JqZWN0Tm9ybWFsICs9ICggbW9ycGhOb3JtYWwzIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDMgXTtcXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21vcnBodGFyZ2V0X3BhcnNfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFNcXG5cXG5cdCNpZm5kZWYgVVNFX01PUlBITk9STUFMU1xcblxcblx0dW5pZm9ybSBmbG9hdCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDggXTtcXG5cXG5cdCNlbHNlXFxuXFxuXHR1bmlmb3JtIGZsb2F0IG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNCBdO1xcblxcblx0I2VuZGlmXFxuXFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tb3JwaHRhcmdldF92ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtb3JwaHRhcmdldF92ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFNcXG5cXG5cdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQwIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMCBdO1xcblx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDEgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAxIF07XFxuXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0MiAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDIgXTtcXG5cdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQzIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMyBdO1xcblxcblx0I2lmbmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxuXFxuXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0NCAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDQgXTtcXG5cdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ1IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNSBdO1xcblx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDYgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA2IF07XFxuXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0NyAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDcgXTtcXG5cXG5cdCNlbmRpZlxcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbm9ybWFsX3Bob25nX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbm9ybWFsX3Bob25nX2ZyYWdtZW50J10gPSBcIiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXG5cdHZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCB2Tm9ybWFsICk7XFxuXFxuXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXHRcdG5vcm1hbCA9IG5vcm1hbCAqICggLTEuMCArIDIuMCAqIGZsb2F0KCBnbF9Gcm9udEZhY2luZyApICk7XFxuXFxuXHQjZW5kaWZcXG5cXG4jZWxzZVxcblxcblx0dmVjMyBmZHggPSBkRmR4KCB2Vmlld1Bvc2l0aW9uICk7XFxuXHR2ZWMzIGZkeSA9IGRGZHkoIHZWaWV3UG9zaXRpb24gKTtcXG5cdHZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCBjcm9zcyggZmR4LCBmZHkgKSApO1xcblxcbiNlbmRpZlxcblxcbiNpZmRlZiBVU0VfTk9STUFMTUFQXFxuXFxuXHRub3JtYWwgPSBwZXJ0dXJiTm9ybWFsMkFyYiggLXZWaWV3UG9zaXRpb24sIG5vcm1hbCApO1xcblxcbiNlbGlmIGRlZmluZWQoIFVTRV9CVU1QTUFQIClcXG5cXG5cdG5vcm1hbCA9IHBlcnR1cmJOb3JtYWxBcmIoIC12Vmlld1Bvc2l0aW9uLCBub3JtYWwsIGRIZHh5X2Z3ZCgpICk7XFxuXFxuI2VuZGlmXFxuXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9ub3JtYWxtYXBfcGFyc19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ25vcm1hbG1hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfTk9STUFMTUFQXFxuXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBub3JtYWxNYXA7XFxuXHR1bmlmb3JtIHZlYzIgbm9ybWFsU2NhbGU7XFxuXFxuXFxuXHR2ZWMzIHBlcnR1cmJOb3JtYWwyQXJiKCB2ZWMzIGV5ZV9wb3MsIHZlYzMgc3VyZl9ub3JtICkge1xcblxcblx0XHR2ZWMzIHEwID0gZEZkeCggZXllX3Bvcy54eXogKTtcXG5cdFx0dmVjMyBxMSA9IGRGZHkoIGV5ZV9wb3MueHl6ICk7XFxuXHRcdHZlYzIgc3QwID0gZEZkeCggdlV2LnN0ICk7XFxuXHRcdHZlYzIgc3QxID0gZEZkeSggdlV2LnN0ICk7XFxuXFxuXHRcdHZlYzMgUyA9IG5vcm1hbGl6ZSggcTAgKiBzdDEudCAtIHExICogc3QwLnQgKTtcXG5cdFx0dmVjMyBUID0gbm9ybWFsaXplKCAtcTAgKiBzdDEucyArIHExICogc3QwLnMgKTtcXG5cdFx0dmVjMyBOID0gbm9ybWFsaXplKCBzdXJmX25vcm0gKTtcXG5cXG5cdFx0dmVjMyBtYXBOID0gdGV4dHVyZTJEKCBub3JtYWxNYXAsIHZVdiApLnh5eiAqIDIuMCAtIDEuMDtcXG5cdFx0bWFwTi54eSA9IG5vcm1hbFNjYWxlICogbWFwTi54eTtcXG5cdFx0bWF0MyB0c24gPSBtYXQzKCBTLCBULCBOICk7XFxuXHRcdHJldHVybiBub3JtYWxpemUoIHRzbiAqIG1hcE4gKTtcXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3Byb2plY3RfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAncHJvamVjdF92ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcblx0dmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogc2tpbm5lZDtcXG5cXG4jZWxzZVxcblxcblx0dmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApO1xcblxcbiNlbmRpZlxcblxcbmdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zaGFkb3dtYXBfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdzaGFkb3dtYXBfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE1BWF9TSEFET1dTOyBpICsrICkge1xcblxcblx0XHRmbG9hdCB0ZXhlbFNpemVZID0gIDEuMCAvIHNoYWRvd01hcFNpemVbIGkgXS55O1xcblxcblx0XHRmbG9hdCBzaGFkb3cgPSAwLjA7XFxuXFxuI2lmIGRlZmluZWQoIFBPSU5UX0xJR0hUX1NIQURPV1MgKVxcblxcblx0XHRib29sIGlzUG9pbnRMaWdodCA9IHNoYWRvd0RhcmtuZXNzWyBpIF0gPCAwLjA7XFxuXFxuXHRcdGlmICggaXNQb2ludExpZ2h0ICkge1xcblxcblx0XHRcdGZsb2F0IHJlYWxTaGFkb3dEYXJrbmVzcyA9IGFicyggc2hhZG93RGFya25lc3NbIGkgXSApO1xcblxcblx0XHRcdHZlYzMgbGlnaHRUb1Bvc2l0aW9uID0gdlNoYWRvd0Nvb3JkWyBpIF0ueHl6O1xcblxcblx0I2lmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRiApIHx8IGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRl9TT0ZUIClcXG5cXG5cdFx0XHR2ZWMzIGJkM0QgPSBub3JtYWxpemUoIGxpZ2h0VG9Qb3NpdGlvbiApO1xcblx0XHRcdGZsb2F0IGRwID0gbGVuZ3RoKCBsaWdodFRvUG9zaXRpb24gKTtcXG5cXG5cdFx0XHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblxcblxcblx0I2lmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRiApXFxuXHRcdFx0Y29uc3QgZmxvYXQgRHIgPSAxLjI1O1xcblx0I2VsaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQgKVxcblx0XHRcdGNvbnN0IGZsb2F0IERyID0gMi4yNTtcXG5cdCNlbmRpZlxcblxcblx0XHRcdGZsb2F0IG9zID0gRHIgKiAgMi4wICogdGV4ZWxTaXplWTtcXG5cXG5cdFx0XHRjb25zdCB2ZWMzIEdzZCA9IHZlYzMoIC0gMSwgMCwgMSApO1xcblxcblx0XHRcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC56enogKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXHRcdFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNEICsgR3NkLnp4eiAqIG9zLCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cdFx0XHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QgKyBHc2QueHh6ICogb3MsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblx0XHRcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC54enogKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXHRcdFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNEICsgR3NkLnp6eCAqIG9zLCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cdFx0XHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QgKyBHc2Quenh4ICogb3MsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblx0XHRcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC54eHggKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXHRcdFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNEICsgR3NkLnh6eCAqIG9zLCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cdFx0XHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QgKyBHc2Quenp5ICogb3MsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblx0XHRcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC56eHkgKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXFxuXHRcdFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNEICsgR3NkLnh4eSAqIG9zLCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cdFx0XHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QgKyBHc2QueHp5ICogb3MsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblx0XHRcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC56eXogKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXHRcdFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNEICsgR3NkLnh5eiAqIG9zLCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cdFx0XHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QgKyBHc2Quenl4ICogb3MsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblx0XHRcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC54eXggKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXHRcdFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNEICsgR3NkLnl6eiAqIG9zLCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cdFx0XHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QgKyBHc2QueXh6ICogb3MsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblx0XHRcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC55eHggKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXHRcdFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNEICsgR3NkLnl6eCAqIG9zLCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cXG5cdFx0XHRzaGFkb3cgKj0gcmVhbFNoYWRvd0RhcmtuZXNzICogKCAxLjAgLyAyMS4wICk7XFxuXFxuXHQjZWxzZSBcXG5cdFx0XHR2ZWMzIGJkM0QgPSBub3JtYWxpemUoIGxpZ2h0VG9Qb3NpdGlvbiApO1xcblx0XHRcdGZsb2F0IGRwID0gbGVuZ3RoKCBsaWdodFRvUG9zaXRpb24gKTtcXG5cXG5cdFx0XHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblxcblx0XHRcdHNoYWRvdyAqPSByZWFsU2hhZG93RGFya25lc3M7XFxuXFxuXHQjZW5kaWZcXG5cXG5cdFx0fSBlbHNlIHtcXG5cXG4jZW5kaWYgXFxuXHRcdFx0ZmxvYXQgdGV4ZWxTaXplWCA9ICAxLjAgLyBzaGFkb3dNYXBTaXplWyBpIF0ueDtcXG5cXG5cdFx0XHR2ZWMzIHNoYWRvd0Nvb3JkID0gdlNoYWRvd0Nvb3JkWyBpIF0ueHl6IC8gdlNoYWRvd0Nvb3JkWyBpIF0udztcXG5cXG5cXG5cdFx0XHRidmVjNCBpbkZydXN0dW1WZWMgPSBidmVjNCAoIHNoYWRvd0Nvb3JkLnggPj0gMC4wLCBzaGFkb3dDb29yZC54IDw9IDEuMCwgc2hhZG93Q29vcmQueSA+PSAwLjAsIHNoYWRvd0Nvb3JkLnkgPD0gMS4wICk7XFxuXHRcdFx0Ym9vbCBpbkZydXN0dW0gPSBhbGwoIGluRnJ1c3R1bVZlYyApO1xcblxcblx0XHRcdGJ2ZWMyIGZydXN0dW1UZXN0VmVjID0gYnZlYzIoIGluRnJ1c3R1bSwgc2hhZG93Q29vcmQueiA8PSAxLjAgKTtcXG5cXG5cdFx0XHRib29sIGZydXN0dW1UZXN0ID0gYWxsKCBmcnVzdHVtVGVzdFZlYyApO1xcblxcblx0XHRcdGlmICggZnJ1c3R1bVRlc3QgKSB7XFxuXFxuXHQjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGIClcXG5cXG5cXG5cdFx0XHRcdC8qXFxuXHRcdFx0XHRcdGZvciAoIGZsb2F0IHkgPSAtMS4yNTsgeSA8PSAxLjI1OyB5ICs9IDEuMjUgKVxcblx0XHRcdFx0XHRcdGZvciAoIGZsb2F0IHggPSAtMS4yNTsgeCA8PSAxLjI1OyB4ICs9IDEuMjUgKSB7XFxuXHRcdFx0XHRcdFx0XHR2ZWM0IHJnYmFEZXB0aCA9IHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHZlYzIoIHggKiB4UGl4ZWxPZmZzZXQsIHkgKiB5UGl4ZWxPZmZzZXQgKSArIHNoYWRvd0Nvb3JkLnh5ICk7XFxuXHRcdFx0XHRcdFx0XHRmbG9hdCBmRGVwdGggPSB1bnBhY2tEZXB0aCggcmdiYURlcHRoICk7XFxuXHRcdFx0XHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKVxcblx0XHRcdFx0XHRcdFx0XHRzaGFkb3cgKz0gMS4wO1xcblx0XHRcdFx0XHR9XFxuXHRcdFx0XHRcdHNoYWRvdyAvPSA5LjA7XFxuXHRcdFx0XHQqL1xcblxcblx0XHRcdFx0c2hhZG93Q29vcmQueiArPSBzaGFkb3dCaWFzWyBpIF07XFxuXFxuXHRcdFx0XHRjb25zdCBmbG9hdCBTaGFkb3dEZWx0YSA9IDEuMCAvIDkuMDtcXG5cXG5cdFx0XHRcdGZsb2F0IHhQaXhlbE9mZnNldCA9IHRleGVsU2l6ZVg7XFxuXHRcdFx0XHRmbG9hdCB5UGl4ZWxPZmZzZXQgPSB0ZXhlbFNpemVZO1xcblxcblx0XHRcdFx0ZmxvYXQgZHgwID0gLSAxLjI1ICogeFBpeGVsT2Zmc2V0O1xcblx0XHRcdFx0ZmxvYXQgZHkwID0gLSAxLjI1ICogeVBpeGVsT2Zmc2V0O1xcblx0XHRcdFx0ZmxvYXQgZHgxID0gMS4yNSAqIHhQaXhlbE9mZnNldDtcXG5cdFx0XHRcdGZsb2F0IGR5MSA9IDEuMjUgKiB5UGl4ZWxPZmZzZXQ7XFxuXFxuXHRcdFx0XHRmbG9hdCBmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MCApICkgKTtcXG5cdFx0XHRcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBTaGFkb3dEZWx0YTtcXG5cXG5cdFx0XHRcdGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkwICkgKSApO1xcblx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IFNoYWRvd0RlbHRhO1xcblxcblx0XHRcdFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTAgKSApICk7XFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gU2hhZG93RGVsdGE7XFxuXFxuXHRcdFx0XHRmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIDAuMCApICkgKTtcXG5cdFx0XHRcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBTaGFkb3dEZWx0YTtcXG5cXG5cdFx0XHRcdGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSApICk7XFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gU2hhZG93RGVsdGE7XFxuXFxuXHRcdFx0XHRmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIDAuMCApICkgKTtcXG5cdFx0XHRcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBTaGFkb3dEZWx0YTtcXG5cXG5cdFx0XHRcdGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkxICkgKSApO1xcblx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IFNoYWRvd0RlbHRhO1xcblxcblx0XHRcdFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTEgKSApICk7XFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gU2hhZG93RGVsdGE7XFxuXFxuXHRcdFx0XHRmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MSApICkgKTtcXG5cdFx0XHRcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBTaGFkb3dEZWx0YTtcXG5cXG5cdFx0XHRcdHNoYWRvdyAqPSBzaGFkb3dEYXJrbmVzc1sgaSBdO1xcblxcblx0I2VsaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQgKVxcblxcblxcblx0XHRcdFx0c2hhZG93Q29vcmQueiArPSBzaGFkb3dCaWFzWyBpIF07XFxuXFxuXHRcdFx0XHRmbG9hdCB4UGl4ZWxPZmZzZXQgPSB0ZXhlbFNpemVYO1xcblx0XHRcdFx0ZmxvYXQgeVBpeGVsT2Zmc2V0ID0gdGV4ZWxTaXplWTtcXG5cXG5cdFx0XHRcdGZsb2F0IGR4MCA9IC0gMS4wICogeFBpeGVsT2Zmc2V0O1xcblx0XHRcdFx0ZmxvYXQgZHkwID0gLSAxLjAgKiB5UGl4ZWxPZmZzZXQ7XFxuXHRcdFx0XHRmbG9hdCBkeDEgPSAxLjAgKiB4UGl4ZWxPZmZzZXQ7XFxuXHRcdFx0XHRmbG9hdCBkeTEgPSAxLjAgKiB5UGl4ZWxPZmZzZXQ7XFxuXFxuXHRcdFx0XHRtYXQzIHNoYWRvd0tlcm5lbDtcXG5cdFx0XHRcdG1hdDMgZGVwdGhLZXJuZWw7XFxuXFxuXHRcdFx0XHRkZXB0aEtlcm5lbFsgMCBdWyAwIF0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MCApICkgKTtcXG5cdFx0XHRcdGRlcHRoS2VybmVsWyAwIF1bIDEgXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgMC4wICkgKSApO1xcblx0XHRcdFx0ZGVwdGhLZXJuZWxbIDAgXVsgMiBdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTEgKSApICk7XFxuXHRcdFx0XHRkZXB0aEtlcm5lbFsgMSBdWyAwIF0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MCApICkgKTtcXG5cdFx0XHRcdGRlcHRoS2VybmVsWyAxIF1bIDEgXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSApICk7XFxuXHRcdFx0XHRkZXB0aEtlcm5lbFsgMSBdWyAyIF0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MSApICkgKTtcXG5cdFx0XHRcdGRlcHRoS2VybmVsWyAyIF1bIDAgXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkwICkgKSApO1xcblx0XHRcdFx0ZGVwdGhLZXJuZWxbIDIgXVsgMSBdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCAwLjAgKSApICk7XFxuXHRcdFx0XHRkZXB0aEtlcm5lbFsgMiBdWyAyIF0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MSApICkgKTtcXG5cXG5cdFx0XHRcdHZlYzMgc2hhZG93WiA9IHZlYzMoIHNoYWRvd0Nvb3JkLnogKTtcXG5cdFx0XHRcdHNoYWRvd0tlcm5lbFsgMCBdID0gdmVjMyggbGVzc1RoYW4oIGRlcHRoS2VybmVsWyAwIF0sIHNoYWRvd1ogKSApO1xcblx0XHRcdFx0c2hhZG93S2VybmVsWyAwIF0gKj0gdmVjMyggMC4yNSApO1xcblxcblx0XHRcdFx0c2hhZG93S2VybmVsWyAxIF0gPSB2ZWMzKCBsZXNzVGhhbiggZGVwdGhLZXJuZWxbIDEgXSwgc2hhZG93WiApICk7XFxuXHRcdFx0XHRzaGFkb3dLZXJuZWxbIDEgXSAqPSB2ZWMzKCAwLjI1ICk7XFxuXFxuXHRcdFx0XHRzaGFkb3dLZXJuZWxbIDIgXSA9IHZlYzMoIGxlc3NUaGFuKCBkZXB0aEtlcm5lbFsgMiBdLCBzaGFkb3daICkgKTtcXG5cdFx0XHRcdHNoYWRvd0tlcm5lbFsgMiBdICo9IHZlYzMoIDAuMjUgKTtcXG5cXG5cdFx0XHRcdHZlYzIgZnJhY3Rpb25hbENvb3JkID0gMS4wIC0gZnJhY3QoIHNoYWRvd0Nvb3JkLnh5ICogc2hhZG93TWFwU2l6ZVsgaSBdLnh5ICk7XFxuXFxuXHRcdFx0XHRzaGFkb3dLZXJuZWxbIDAgXSA9IG1peCggc2hhZG93S2VybmVsWyAxIF0sIHNoYWRvd0tlcm5lbFsgMCBdLCBmcmFjdGlvbmFsQ29vcmQueCApO1xcblx0XHRcdFx0c2hhZG93S2VybmVsWyAxIF0gPSBtaXgoIHNoYWRvd0tlcm5lbFsgMiBdLCBzaGFkb3dLZXJuZWxbIDEgXSwgZnJhY3Rpb25hbENvb3JkLnggKTtcXG5cXG5cdFx0XHRcdHZlYzQgc2hhZG93VmFsdWVzO1xcblx0XHRcdFx0c2hhZG93VmFsdWVzLnggPSBtaXgoIHNoYWRvd0tlcm5lbFsgMCBdWyAxIF0sIHNoYWRvd0tlcm5lbFsgMCBdWyAwIF0sIGZyYWN0aW9uYWxDb29yZC55ICk7XFxuXHRcdFx0XHRzaGFkb3dWYWx1ZXMueSA9IG1peCggc2hhZG93S2VybmVsWyAwIF1bIDIgXSwgc2hhZG93S2VybmVsWyAwIF1bIDEgXSwgZnJhY3Rpb25hbENvb3JkLnkgKTtcXG5cdFx0XHRcdHNoYWRvd1ZhbHVlcy56ID0gbWl4KCBzaGFkb3dLZXJuZWxbIDEgXVsgMSBdLCBzaGFkb3dLZXJuZWxbIDEgXVsgMCBdLCBmcmFjdGlvbmFsQ29vcmQueSApO1xcblx0XHRcdFx0c2hhZG93VmFsdWVzLncgPSBtaXgoIHNoYWRvd0tlcm5lbFsgMSBdWyAyIF0sIHNoYWRvd0tlcm5lbFsgMSBdWyAxIF0sIGZyYWN0aW9uYWxDb29yZC55ICk7XFxuXFxuXHRcdFx0XHRzaGFkb3cgPSBkb3QoIHNoYWRvd1ZhbHVlcywgdmVjNCggMS4wICkgKSAqIHNoYWRvd0RhcmtuZXNzWyBpIF07XFxuXFxuXHQjZWxzZSBcXG5cdFx0XHRcdHNoYWRvd0Nvb3JkLnogKz0gc2hhZG93Qmlhc1sgaSBdO1xcblxcblx0XHRcdFx0dmVjNCByZ2JhRGVwdGggPSB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSApO1xcblx0XHRcdFx0ZmxvYXQgZkRlcHRoID0gdW5wYWNrRGVwdGgoIHJnYmFEZXB0aCApO1xcblxcblx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56IClcXG5cdFx0XHRcdFx0c2hhZG93ID0gc2hhZG93RGFya25lc3NbIGkgXTtcXG5cXG5cdCNlbmRpZlxcblxcblx0XHRcdH1cXG5cXG4jaWZkZWYgU0hBRE9XTUFQX0RFQlVHXFxuXFxuXHRcdFx0aWYgKCBpbkZydXN0dW0gKSB7XFxuXFxuXHRcdFx0XHRpZiAoIGkgPT0gMCApIHtcXG5cXG5cdFx0XHRcdFx0b3V0Z29pbmdMaWdodCAqPSB2ZWMzKCAxLjAsIDAuNSwgMC4wICk7XFxuXFxuXHRcdFx0XHR9IGVsc2UgaWYgKCBpID09IDEgKSB7XFxuXFxuXHRcdFx0XHRcdG91dGdvaW5nTGlnaHQgKj0gdmVjMyggMC4wLCAxLjAsIDAuOCApO1xcblxcblx0XHRcdFx0fSBlbHNlIHtcXG5cXG5cdFx0XHRcdFx0b3V0Z29pbmdMaWdodCAqPSB2ZWMzKCAwLjAsIDAuNSwgMS4wICk7XFxuXFxuXHRcdFx0XHR9XFxuXFxuXHRcdFx0fVxcblxcbiNlbmRpZlxcblxcbiNpZiBkZWZpbmVkKCBQT0lOVF9MSUdIVF9TSEFET1dTIClcXG5cXG5cdFx0fVxcblxcbiNlbmRpZlxcblxcblx0XHRzaGFkb3dNYXNrID0gc2hhZG93TWFzayAqIHZlYzMoIDEuMCAtIHNoYWRvdyApO1xcblxcblx0fVxcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2hhZG93bWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdzaGFkb3dtYXBfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcblx0dW5pZm9ybSBzYW1wbGVyMkQgc2hhZG93TWFwWyBNQVhfU0hBRE9XUyBdO1xcblx0dW5pZm9ybSB2ZWMyIHNoYWRvd01hcFNpemVbIE1BWF9TSEFET1dTIF07XFxuXFxuXHR1bmlmb3JtIGZsb2F0IHNoYWRvd0RhcmtuZXNzWyBNQVhfU0hBRE9XUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBzaGFkb3dCaWFzWyBNQVhfU0hBRE9XUyBdO1xcblxcblx0dmFyeWluZyB2ZWM0IHZTaGFkb3dDb29yZFsgTUFYX1NIQURPV1MgXTtcXG5cXG5cdGZsb2F0IHVucGFja0RlcHRoKCBjb25zdCBpbiB2ZWM0IHJnYmFfZGVwdGggKSB7XFxuXFxuXHRcdGNvbnN0IHZlYzQgYml0X3NoaWZ0ID0gdmVjNCggMS4wIC8gKCAyNTYuMCAqIDI1Ni4wICogMjU2LjAgKSwgMS4wIC8gKCAyNTYuMCAqIDI1Ni4wICksIDEuMCAvIDI1Ni4wLCAxLjAgKTtcXG5cdFx0ZmxvYXQgZGVwdGggPSBkb3QoIHJnYmFfZGVwdGgsIGJpdF9zaGlmdCApO1xcblx0XHRyZXR1cm4gZGVwdGg7XFxuXFxuXHR9XFxuXFxuXHQjaWYgZGVmaW5lZChQT0lOVF9MSUdIVF9TSEFET1dTKVxcblxcblxcblx0XHR2b2lkIGFkanVzdFNoYWRvd1ZhbHVlMUsoIGNvbnN0IGZsb2F0IHRlc3REZXB0aCwgY29uc3QgdmVjNCB0ZXh0dXJlRGF0YSwgY29uc3QgZmxvYXQgYmlhcywgaW5vdXQgZmxvYXQgc2hhZG93VmFsdWUgKSB7XFxuXFxuXHRcdFx0Y29uc3QgdmVjNCBiaXRTaCA9IHZlYzQoIDEuMCAvICggMjU2LjAgKiAyNTYuMCAqIDI1Ni4wICksIDEuMCAvICggMjU2LjAgKiAyNTYuMCApLCAxLjAgLyAyNTYuMCwgMS4wICk7XFxuXHRcdFx0aWYgKCB0ZXN0RGVwdGggPj0gZG90KCB0ZXh0dXJlRGF0YSwgYml0U2ggKSAqIDEwMDAuMCArIGJpYXMgKVxcblx0XHRcdFx0c2hhZG93VmFsdWUgKz0gMS4wO1xcblxcblx0XHR9XFxuXFxuXFxuXHRcdHZlYzIgY3ViZVRvVVYoIHZlYzMgdiwgZmxvYXQgdGV4ZWxTaXplWSApIHtcXG5cXG5cXG5cdFx0XHR2ZWMzIGFic1YgPSBhYnMoIHYgKTtcXG5cXG5cXG5cdFx0XHRmbG9hdCBzY2FsZVRvQ3ViZSA9IDEuMCAvIG1heCggYWJzVi54LCBtYXgoIGFic1YueSwgYWJzVi56ICkgKTtcXG5cdFx0XHRhYnNWICo9IHNjYWxlVG9DdWJlO1xcblxcblxcblx0XHRcdHYgKj0gc2NhbGVUb0N1YmUgKiAoIDEuMCAtIDIuMCAqIHRleGVsU2l6ZVkgKTtcXG5cXG5cXG5cXG5cdFx0XHR2ZWMyIHBsYW5hciA9IHYueHk7XFxuXFxuXHRcdFx0ZmxvYXQgYWxtb3N0QVRleGVsID0gMS41ICogdGV4ZWxTaXplWTtcXG5cdFx0XHRmbG9hdCBhbG1vc3RPbmUgPSAxLjAgLSBhbG1vc3RBVGV4ZWw7XFxuXFxuXHRcdFx0aWYgKCBhYnNWLnogPj0gYWxtb3N0T25lICkge1xcblxcblx0XHRcdFx0aWYgKCB2LnogPiAwLjAgKVxcblx0XHRcdFx0XHRwbGFuYXIueCA9IDQuMCAtIHYueDtcXG5cXG5cdFx0XHR9IGVsc2UgaWYgKCBhYnNWLnggPj0gYWxtb3N0T25lICkge1xcblxcblx0XHRcdFx0ZmxvYXQgc2lnblggPSBzaWduKCB2LnggKTtcXG5cdFx0XHRcdHBsYW5hci54ID0gdi56ICogc2lnblggKyAyLjAgKiBzaWduWDtcXG5cXG5cdFx0XHR9IGVsc2UgaWYgKCBhYnNWLnkgPj0gYWxtb3N0T25lICkge1xcblxcblx0XHRcdFx0ZmxvYXQgc2lnblkgPSBzaWduKCB2LnkgKTtcXG5cdFx0XHRcdHBsYW5hci54ID0gdi54ICsgMi4wICogc2lnblkgKyAyLjA7XFxuXHRcdFx0XHRwbGFuYXIueSA9IHYueiAqIHNpZ25ZIC0gMi4wO1xcblxcblx0XHRcdH1cXG5cXG5cXG5cdFx0XHRyZXR1cm4gdmVjMiggMC4xMjUsIDAuMjUgKSAqIHBsYW5hciArIHZlYzIoIDAuMzc1LCAwLjc1ICk7XFxuXFxuXHRcdH1cXG5cXG5cdCNlbmRpZlxcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2hhZG93bWFwX3BhcnNfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnc2hhZG93bWFwX3BhcnNfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFxuXHR1bmlmb3JtIGZsb2F0IHNoYWRvd0RhcmtuZXNzWyBNQVhfU0hBRE9XUyBdO1xcblx0dW5pZm9ybSBtYXQ0IHNoYWRvd01hdHJpeFsgTUFYX1NIQURPV1MgXTtcXG5cdHZhcnlpbmcgdmVjNCB2U2hhZG93Q29vcmRbIE1BWF9TSEFET1dTIF07XFxuXFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zaGFkb3dtYXBfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnc2hhZG93bWFwX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTUFYX1NIQURPV1M7IGkgKysgKSB7XFxuXFxuXHRcdFx0dlNoYWRvd0Nvb3JkWyBpIF0gPSBzaGFkb3dNYXRyaXhbIGkgXSAqIHdvcmxkUG9zaXRpb247XFxuXFxuXHR9XFxuXFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9za2luYmFzZV92ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdza2luYmFzZV92ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcblx0bWF0NCBib25lTWF0WCA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC54ICk7XFxuXHRtYXQ0IGJvbmVNYXRZID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnkgKTtcXG5cdG1hdDQgYm9uZU1hdFogPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueiApO1xcblx0bWF0NCBib25lTWF0VyA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC53ICk7XFxuXFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9za2lubmluZ19wYXJzX3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NraW5uaW5nX3BhcnNfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXG5cdHVuaWZvcm0gbWF0NCBiaW5kTWF0cml4O1xcblx0dW5pZm9ybSBtYXQ0IGJpbmRNYXRyaXhJbnZlcnNlO1xcblxcblx0I2lmZGVmIEJPTkVfVEVYVFVSRVxcblxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCBib25lVGV4dHVyZTtcXG5cdFx0dW5pZm9ybSBpbnQgYm9uZVRleHR1cmVXaWR0aDtcXG5cdFx0dW5pZm9ybSBpbnQgYm9uZVRleHR1cmVIZWlnaHQ7XFxuXFxuXHRcdG1hdDQgZ2V0Qm9uZU1hdHJpeCggY29uc3QgaW4gZmxvYXQgaSApIHtcXG5cXG5cdFx0XHRmbG9hdCBqID0gaSAqIDQuMDtcXG5cdFx0XHRmbG9hdCB4ID0gbW9kKCBqLCBmbG9hdCggYm9uZVRleHR1cmVXaWR0aCApICk7XFxuXHRcdFx0ZmxvYXQgeSA9IGZsb29yKCBqIC8gZmxvYXQoIGJvbmVUZXh0dXJlV2lkdGggKSApO1xcblxcblx0XHRcdGZsb2F0IGR4ID0gMS4wIC8gZmxvYXQoIGJvbmVUZXh0dXJlV2lkdGggKTtcXG5cdFx0XHRmbG9hdCBkeSA9IDEuMCAvIGZsb2F0KCBib25lVGV4dHVyZUhlaWdodCApO1xcblxcblx0XHRcdHkgPSBkeSAqICggeSArIDAuNSApO1xcblxcblx0XHRcdHZlYzQgdjEgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDAuNSApLCB5ICkgKTtcXG5cdFx0XHR2ZWM0IHYyID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAxLjUgKSwgeSApICk7XFxuXHRcdFx0dmVjNCB2MyA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMi41ICksIHkgKSApO1xcblx0XHRcdHZlYzQgdjQgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDMuNSApLCB5ICkgKTtcXG5cXG5cdFx0XHRtYXQ0IGJvbmUgPSBtYXQ0KCB2MSwgdjIsIHYzLCB2NCApO1xcblxcblx0XHRcdHJldHVybiBib25lO1xcblxcblx0XHR9XFxuXFxuXHQjZWxzZVxcblxcblx0XHR1bmlmb3JtIG1hdDQgYm9uZUdsb2JhbE1hdHJpY2VzWyBNQVhfQk9ORVMgXTtcXG5cXG5cdFx0bWF0NCBnZXRCb25lTWF0cml4KCBjb25zdCBpbiBmbG9hdCBpICkge1xcblxcblx0XHRcdG1hdDQgYm9uZSA9IGJvbmVHbG9iYWxNYXRyaWNlc1sgaW50KGkpIF07XFxuXHRcdFx0cmV0dXJuIGJvbmU7XFxuXFxuXHRcdH1cXG5cXG5cdCNlbmRpZlxcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2tpbm5pbmdfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnc2tpbm5pbmdfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXG5cdHZlYzQgc2tpblZlcnRleCA9IGJpbmRNYXRyaXggKiB2ZWM0KCB0cmFuc2Zvcm1lZCwgMS4wICk7XFxuXFxuXHR2ZWM0IHNraW5uZWQgPSB2ZWM0KCAwLjAgKTtcXG5cdHNraW5uZWQgKz0gYm9uZU1hdFggKiBza2luVmVydGV4ICogc2tpbldlaWdodC54O1xcblx0c2tpbm5lZCArPSBib25lTWF0WSAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnk7XFxuXHRza2lubmVkICs9IGJvbmVNYXRaICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQuejtcXG5cdHNraW5uZWQgKz0gYm9uZU1hdFcgKiBza2luVmVydGV4ICogc2tpbldlaWdodC53O1xcblx0c2tpbm5lZCAgPSBiaW5kTWF0cml4SW52ZXJzZSAqIHNraW5uZWQ7XFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9za2lubm9ybWFsX3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NraW5ub3JtYWxfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXG5cdG1hdDQgc2tpbk1hdHJpeCA9IG1hdDQoIDAuMCApO1xcblx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnggKiBib25lTWF0WDtcXG5cdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC55ICogYm9uZU1hdFk7XFxuXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQueiAqIGJvbmVNYXRaO1xcblx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LncgKiBib25lTWF0VztcXG5cdHNraW5NYXRyaXggID0gYmluZE1hdHJpeEludmVyc2UgKiBza2luTWF0cml4ICogYmluZE1hdHJpeDtcXG5cXG5cdG9iamVjdE5vcm1hbCA9IHZlYzQoIHNraW5NYXRyaXggKiB2ZWM0KCBvYmplY3ROb3JtYWwsIDAuMCApICkueHl6O1xcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc3BlY3VsYXJtYXBfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdzcGVjdWxhcm1hcF9mcmFnbWVudCddID0gXCJmbG9hdCBzcGVjdWxhclN0cmVuZ3RoO1xcblxcbiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVBcXG5cXG5cdHZlYzQgdGV4ZWxTcGVjdWxhciA9IHRleHR1cmUyRCggc3BlY3VsYXJNYXAsIHZVdiApO1xcblx0c3BlY3VsYXJTdHJlbmd0aCA9IHRleGVsU3BlY3VsYXIucjtcXG5cXG4jZWxzZVxcblxcblx0c3BlY3VsYXJTdHJlbmd0aCA9IDEuMDtcXG5cXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVBcXG5cXG5cdHVuaWZvcm0gc2FtcGxlcjJEIHNwZWN1bGFyTWFwO1xcblxcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvdXYyX3BhcnNfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICd1djJfcGFyc19mcmFnbWVudCddID0gXCIjaWYgZGVmaW5lZCggVVNFX0xJR0hUTUFQICkgfHwgZGVmaW5lZCggVVNFX0FPTUFQIClcXG5cXG5cdHZhcnlpbmcgdmVjMiB2VXYyO1xcblxcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvdXYyX3BhcnNfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAndXYyX3BhcnNfdmVydGV4J10gPSBcIiNpZiBkZWZpbmVkKCBVU0VfTElHSFRNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU9NQVAgKVxcblxcblx0YXR0cmlidXRlIHZlYzIgdXYyO1xcblx0dmFyeWluZyB2ZWMyIHZVdjI7XFxuXFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay91djJfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAndXYyX3ZlcnRleCddID0gXCIjaWYgZGVmaW5lZCggVVNFX0xJR0hUTUFQICkgfHwgZGVmaW5lZCggVVNFX0FPTUFQIClcXG5cXG5cdHZVdjIgPSB1djI7XFxuXFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay91dl9wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAndXZfcGFyc19mcmFnbWVudCddID0gXCIjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFVTRV9TUEVDVUxBUk1BUCApIHx8IGRlZmluZWQoIFVTRV9BTFBIQU1BUCApIHx8IGRlZmluZWQoIFVTRV9FTUlTU0lWRU1BUCApXFxuXFxuXHR2YXJ5aW5nIHZlYzIgdlV2O1xcblxcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvdXZfcGFyc192ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICd1dl9wYXJzX3ZlcnRleCddID0gXCIjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFVTRV9TUEVDVUxBUk1BUCApIHx8IGRlZmluZWQoIFVTRV9BTFBIQU1BUCApIHx8IGRlZmluZWQoIFVTRV9FTUlTU0lWRU1BUCApXFxuXFxuXHR2YXJ5aW5nIHZlYzIgdlV2O1xcblx0dW5pZm9ybSB2ZWM0IG9mZnNldFJlcGVhdDtcXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3V2X3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ3V2X3ZlcnRleCddID0gXCIjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFVTRV9TUEVDVUxBUk1BUCApIHx8IGRlZmluZWQoIFVTRV9BTFBIQU1BUCApIHx8IGRlZmluZWQoIFVTRV9FTUlTU0lWRU1BUCApXFxuXFxuXHR2VXYgPSB1diAqIG9mZnNldFJlcGVhdC56dyArIG9mZnNldFJlcGVhdC54eTtcXG5cXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3dvcmxkcG9zX3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ3dvcmxkcG9zX3ZlcnRleCddID0gXCIjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApIHx8IGRlZmluZWQoIFBIT05HICkgfHwgZGVmaW5lZCggTEFNQkVSVCApIHx8IGRlZmluZWQgKCBVU0VfU0hBRE9XTUFQIClcXG5cXG5cdCNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXG5cdFx0dmVjNCB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiBza2lubmVkO1xcblxcblx0I2Vsc2VcXG5cXG5cdFx0dmVjNCB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiB2ZWM0KCB0cmFuc2Zvcm1lZCwgMS4wICk7XFxuXFxuXHQjZW5kaWZcXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1VuaWZvcm1zVXRpbHMuanNcclxuXHJcbi8qKlxyXG4gKiBVbmlmb3JtIFV0aWxpdGllc1xyXG4gKi9cclxuXHJcblRIUkVFLlVuaWZvcm1zVXRpbHMgPSB7XHJcblxyXG4gICAgbWVyZ2U6IGZ1bmN0aW9uICggdW5pZm9ybXMgKSB7XHJcblxyXG4gICAgICAgIHZhciBtZXJnZWQgPSB7fTtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIHUgPSAwOyB1IDwgdW5pZm9ybXMubGVuZ3RoOyB1ICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHRtcCA9IHRoaXMuY2xvbmUoIHVuaWZvcm1zWyB1IF0gKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBwIGluIHRtcCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBtZXJnZWRbIHAgXSA9IHRtcFsgcCBdO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBtZXJnZWQ7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjbG9uZTogZnVuY3Rpb24gKCB1bmlmb3Jtc19zcmMgKSB7XHJcblxyXG4gICAgICAgIHZhciB1bmlmb3Jtc19kc3QgPSB7fTtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIHUgaW4gdW5pZm9ybXNfc3JjICkge1xyXG5cclxuICAgICAgICAgICAgdW5pZm9ybXNfZHN0WyB1IF0gPSB7fTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBwIGluIHVuaWZvcm1zX3NyY1sgdSBdICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBwYXJhbWV0ZXJfc3JjID0gdW5pZm9ybXNfc3JjWyB1IF1bIHAgXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IyIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMgfHxcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yNCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5NYXRyaXgzIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLk1hdHJpeDQgfHxcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXNfZHN0WyB1IF1bIHAgXSA9IHBhcmFtZXRlcl9zcmMuY2xvbmUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCBwYXJhbWV0ZXJfc3JjICkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm1zX2RzdFsgdSBdWyBwIF0gPSBwYXJhbWV0ZXJfc3JjLnNsaWNlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXNfZHN0WyB1IF1bIHAgXSA9IHBhcmFtZXRlcl9zcmM7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB1bmlmb3Jtc19kc3Q7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1VuaWZvcm1zTGliLmpzXHJcblxyXG4vKipcclxuICogVW5pZm9ybXMgbGlicmFyeSBmb3Igc2hhcmVkIHdlYmdsIHNoYWRlcnNcclxuICovXHJcblxyXG5USFJFRS5Vbmlmb3Jtc0xpYiA9IHtcclxuXHJcbiAgICBjb21tb246IHtcclxuXHJcbiAgICAgICAgXCJkaWZmdXNlXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGVlZWVlZSApIH0sXHJcbiAgICAgICAgXCJvcGFjaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXHJcblxyXG4gICAgICAgIFwibWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG4gICAgICAgIFwib2Zmc2V0UmVwZWF0XCIgOiB7IHR5cGU6IFwidjRcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3I0KCAwLCAwLCAxLCAxICkgfSxcclxuXHJcbiAgICAgICAgXCJzcGVjdWxhck1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcclxuICAgICAgICBcImFscGhhTWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG5cclxuICAgICAgICBcImVudk1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcclxuICAgICAgICBcImZsaXBFbnZNYXBcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAtIDEgfSxcclxuICAgICAgICBcInJlZmxlY3Rpdml0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LFxyXG4gICAgICAgIFwicmVmcmFjdGlvblJhdGlvXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC45OCB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhb21hcDoge1xyXG5cclxuICAgICAgICBcImFvTWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG4gICAgICAgIFwiYW9NYXBJbnRlbnNpdHlcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBsaWdodG1hcDoge1xyXG5cclxuICAgICAgICBcImxpZ2h0TWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG4gICAgICAgIFwibGlnaHRNYXBJbnRlbnNpdHlcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBlbWlzc2l2ZW1hcDoge1xyXG5cclxuICAgICAgICBcImVtaXNzaXZlTWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYnVtcG1hcDoge1xyXG5cclxuICAgICAgICBcImJ1bXBNYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcbiAgICAgICAgXCJidW1wU2NhbGVcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG5vcm1hbG1hcDoge1xyXG5cclxuICAgICAgICBcIm5vcm1hbE1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcclxuICAgICAgICBcIm5vcm1hbFNjYWxlXCIgOiB7IHR5cGU6IFwidjJcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICkgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZGlzcGxhY2VtZW50bWFwOiB7XHJcblxyXG4gICAgICAgIFwiZGlzcGxhY2VtZW50TWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG4gICAgICAgIFwiZGlzcGxhY2VtZW50U2NhbGVcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXHJcbiAgICAgICAgXCJkaXNwbGFjZW1lbnRCaWFzXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMCB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBmb2cgOiB7XHJcblxyXG4gICAgICAgIFwiZm9nRGVuc2l0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuMDAwMjUgfSxcclxuICAgICAgICBcImZvZ05lYXJcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXHJcbiAgICAgICAgXCJmb2dGYXJcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAyMDAwIH0sXHJcbiAgICAgICAgXCJmb2dDb2xvclwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKSB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBsaWdodHM6IHtcclxuXHJcbiAgICAgICAgXCJhbWJpZW50TGlnaHRDb2xvclwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxyXG5cclxuICAgICAgICBcImRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25cIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcclxuICAgICAgICBcImRpcmVjdGlvbmFsTGlnaHRDb2xvclwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxyXG5cclxuICAgICAgICBcImhlbWlzcGhlcmVMaWdodERpcmVjdGlvblwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxyXG4gICAgICAgIFwiaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3JcIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcclxuICAgICAgICBcImhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXHJcblxyXG4gICAgICAgIFwicG9pbnRMaWdodENvbG9yXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXHJcbiAgICAgICAgXCJwb2ludExpZ2h0UG9zaXRpb25cIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcclxuICAgICAgICBcInBvaW50TGlnaHREaXN0YW5jZVwiIDogeyB0eXBlOiBcImZ2MVwiLCB2YWx1ZTogW10gfSxcclxuICAgICAgICBcInBvaW50TGlnaHREZWNheVwiIDogeyB0eXBlOiBcImZ2MVwiLCB2YWx1ZTogW10gfSxcclxuXHJcbiAgICAgICAgXCJzcG90TGlnaHRDb2xvclwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxyXG4gICAgICAgIFwic3BvdExpZ2h0UG9zaXRpb25cIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcclxuICAgICAgICBcInNwb3RMaWdodERpcmVjdGlvblwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxyXG4gICAgICAgIFwic3BvdExpZ2h0RGlzdGFuY2VcIiA6IHsgdHlwZTogXCJmdjFcIiwgdmFsdWU6IFtdIH0sXHJcbiAgICAgICAgXCJzcG90TGlnaHRBbmdsZUNvc1wiIDogeyB0eXBlOiBcImZ2MVwiLCB2YWx1ZTogW10gfSxcclxuICAgICAgICBcInNwb3RMaWdodEV4cG9uZW50XCIgOiB7IHR5cGU6IFwiZnYxXCIsIHZhbHVlOiBbXSB9LFxyXG4gICAgICAgIFwic3BvdExpZ2h0RGVjYXlcIiA6IHsgdHlwZTogXCJmdjFcIiwgdmFsdWU6IFtdIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHBvaW50czoge1xyXG5cclxuICAgICAgICBcInBzQ29sb3JcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4ZWVlZWVlICkgfSxcclxuICAgICAgICBcIm9wYWNpdHlcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSxcclxuICAgICAgICBcInNpemVcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSxcclxuICAgICAgICBcInNjYWxlXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXHJcbiAgICAgICAgXCJtYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcbiAgICAgICAgXCJvZmZzZXRSZXBlYXRcIiA6IHsgdHlwZTogXCJ2NFwiLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjQoIDAsIDAsIDEsIDEgKSB9LFxyXG5cclxuICAgICAgICBcImZvZ0RlbnNpdHlcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjAwMDI1IH0sXHJcbiAgICAgICAgXCJmb2dOZWFyXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxyXG4gICAgICAgIFwiZm9nRmFyXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMjAwMCB9LFxyXG4gICAgICAgIFwiZm9nQ29sb3JcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICkgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2hhZG93bWFwOiB7XHJcblxyXG4gICAgICAgIFwic2hhZG93TWFwXCI6IHsgdHlwZTogXCJ0dlwiLCB2YWx1ZTogW10gfSxcclxuICAgICAgICBcInNoYWRvd01hcFNpemVcIjogeyB0eXBlOiBcInYydlwiLCB2YWx1ZTogW10gfSxcclxuXHJcbiAgICAgICAgXCJzaGFkb3dCaWFzXCIgOiB7IHR5cGU6IFwiZnYxXCIsIHZhbHVlOiBbXSB9LFxyXG4gICAgICAgIFwic2hhZG93RGFya25lc3NcIjogeyB0eXBlOiBcImZ2MVwiLCB2YWx1ZTogW10gfSxcclxuXHJcbiAgICAgICAgXCJzaGFkb3dNYXRyaXhcIiA6IHsgdHlwZTogXCJtNHZcIiwgdmFsdWU6IFtdIH1cclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyTGliLmpzXHJcblxyXG4vKipcclxuICogV2ViZ2wgU2hhZGVyIExpYnJhcnkgZm9yIHRocmVlLmpzXHJcbiAqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqL1xyXG5cclxuXHJcblRIUkVFLlNoYWRlckxpYiA9IHtcclxuXHJcbiAgICAnYmFzaWMnOiB7XHJcblxyXG4gICAgICAgIHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJjb21tb25cIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJhb21hcFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImZvZ1wiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcInNoYWRvd21hcFwiIF1cclxuXHJcbiAgICAgICAgXSApLFxyXG5cclxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3BhcnNfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3BhcnNfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc192ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl92ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbmJhc2VfdmVydGV4XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFwiXHQjaWZkZWYgVVNFX0VOVk1BUFwiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5ub3JtYWxfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGhub3JtYWxfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJkZWZhdWx0bm9ybWFsX3ZlcnRleFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcIlx0I2VuZGlmXCIsXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJiZWdpbl92ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ192ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJwcm9qZWN0X3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ3b3JsZHBvc192ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3ZlcnRleFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcIn1cIlxyXG5cclxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKSxcclxuXHJcbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcbiAgICAgICAgICAgIFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XCIsXHJcbiAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3BhcnNfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfcGFyc19mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGFtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFvbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcclxuXHJcbiAgICAgICAgICAgIFwiXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTtcIixcclxuICAgICAgICAgICAgXCJcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1wiLFxyXG4gICAgICAgICAgICBcIlx0dmVjMyB0b3RhbEFtYmllbnRMaWdodCA9IHZlYzMoIDEuMCApO1wiLCAvLyBoYXJkd2lyZWRcclxuICAgICAgICAgICAgXCJcdHZlYzMgc2hhZG93TWFzayA9IHZlYzMoIDEuMCApO1wiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGF0ZXN0X2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhb21hcF9mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9mcmFnbWVudFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcIlx0b3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2IgKiB0b3RhbEFtYmllbnRMaWdodCAqIHNoYWRvd01hc2s7XCIsXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfZnJhZ21lbnRcIiBdLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19mcmFnbWVudFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcIlx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcIixcclxuXHJcbiAgICAgICAgICAgIFwifVwiXHJcblxyXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApXHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAnbGFtYmVydCc6IHtcclxuXHJcbiAgICAgICAgdW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImNvbW1vblwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImZvZ1wiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImxpZ2h0c1wiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcInNoYWRvd21hcFwiIF0sXHJcblxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcImVtaXNzaXZlXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweDAwMDAwMCApIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICBdICksXHJcblxyXG4gICAgICAgIHZlcnRleFNoYWRlcjogW1xyXG5cclxuICAgICAgICAgICAgXCIjZGVmaW5lIExBTUJFUlRcIixcclxuXHJcbiAgICAgICAgICAgIFwidmFyeWluZyB2ZWMzIHZMaWdodEZyb250O1wiLFxyXG5cclxuICAgICAgICAgICAgXCIjaWZkZWYgRE9VQkxFX1NJREVEXCIsXHJcblxyXG4gICAgICAgICAgICBcIlx0dmFyeWluZyB2ZWMzIHZMaWdodEJhY2s7XCIsXHJcblxyXG4gICAgICAgICAgICBcIiNlbmRpZlwiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXZfcGFyc192ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfcGFyc192ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc192ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfbGFtYmVydF9wYXJzX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXZfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3ZlcnRleFwiIF0sXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJiZWdpbm5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaG5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2luYmFzZV92ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubm9ybWFsX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRub3JtYWxfdmVydGV4XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2luX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInByb2plY3RfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIndvcmxkcG9zX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF92ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfbGFtYmVydF92ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfdmVydGV4XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFwifVwiXHJcblxyXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApLFxyXG5cclxuICAgICAgICBmcmFnbWVudFNoYWRlcjogW1xyXG5cclxuICAgICAgICAgICAgXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcIixcclxuICAgICAgICAgICAgXCJ1bmlmb3JtIHZlYzMgZW1pc3NpdmU7XCIsXHJcbiAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxyXG5cclxuICAgICAgICAgICAgXCJ1bmlmb3JtIHZlYzMgYW1iaWVudExpZ2h0Q29sb3I7XCIsXHJcblxyXG4gICAgICAgICAgICBcInZhcnlpbmcgdmVjMyB2TGlnaHRGcm9udDtcIixcclxuXHJcbiAgICAgICAgICAgIFwiI2lmZGVmIERPVUJMRV9TSURFRFwiLFxyXG5cclxuICAgICAgICAgICAgXCJcdHZhcnlpbmcgdmVjMyB2TGlnaHRCYWNrO1wiLFxyXG5cclxuICAgICAgICAgICAgXCIjZW5kaWZcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcclxuXHJcbiAgICAgICAgICAgIFwiXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTtcIixcdC8vIG91dGdvaW5nIGxpZ2h0IGRvZXMgbm90IGhhdmUgYW4gYWxwaGEsIHRoZSBzdXJmYWNlIGRvZXNcclxuICAgICAgICAgICAgXCJcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1wiLFxyXG4gICAgICAgICAgICBcIlx0dmVjMyB0b3RhbEFtYmllbnRMaWdodCA9IGFtYmllbnRMaWdodENvbG9yO1wiLFxyXG4gICAgICAgICAgICBcIlx0dmVjMyBzaGFkb3dNYXNrID0gdmVjMyggMS4wICk7XCIsXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGFtYXBfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYXRlc3RfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9mcmFnbWVudFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcIlx0I2lmZGVmIERPVUJMRV9TSURFRFwiLFxyXG5cclxuICAgICAgICAgICAgXCJcdFx0aWYgKCBnbF9Gcm9udEZhY2luZyApXCIsXHJcbiAgICAgICAgICAgIFwiXHRcdFx0b3V0Z29pbmdMaWdodCArPSBkaWZmdXNlQ29sb3IucmdiICogKCB2TGlnaHRGcm9udCAqIHNoYWRvd01hc2sgKyB0b3RhbEFtYmllbnRMaWdodCApICsgZW1pc3NpdmU7XCIsXHJcbiAgICAgICAgICAgIFwiXHRcdGVsc2VcIixcclxuICAgICAgICAgICAgXCJcdFx0XHRvdXRnb2luZ0xpZ2h0ICs9IGRpZmZ1c2VDb2xvci5yZ2IgKiAoIHZMaWdodEJhY2sgKiBzaGFkb3dNYXNrICsgdG90YWxBbWJpZW50TGlnaHQgKSArIGVtaXNzaXZlO1wiLFxyXG5cclxuICAgICAgICAgICAgXCJcdCNlbHNlXCIsXHJcblxyXG4gICAgICAgICAgICBcIlx0XHRvdXRnb2luZ0xpZ2h0ICs9IGRpZmZ1c2VDb2xvci5yZ2IgKiAoIHZMaWdodEZyb250ICogc2hhZG93TWFzayArIHRvdGFsQW1iaWVudExpZ2h0ICkgKyBlbWlzc2l2ZTtcIixcclxuXHJcbiAgICAgICAgICAgIFwiXHQjZW5kaWZcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9mcmFnbWVudFwiIF0sXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsaW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnRcIiBdLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFwiXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1wiLFxyXG5cclxuICAgICAgICAgICAgXCJ9XCJcclxuXHJcbiAgICAgICAgXS5qb2luKCBcIlxcblwiIClcclxuXHJcbiAgICB9LFxyXG5cclxuICAgICdwaG9uZyc6IHtcclxuXHJcbiAgICAgICAgdW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImNvbW1vblwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImFvbWFwXCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwibGlnaHRtYXBcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJlbWlzc2l2ZW1hcFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImJ1bXBtYXBcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJub3JtYWxtYXBcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJkaXNwbGFjZW1lbnRtYXBcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJmb2dcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJsaWdodHNcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJzaGFkb3dtYXBcIiBdLFxyXG5cclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJlbWlzc2l2ZVwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHgwMDAwMDAgKSB9LFxyXG4gICAgICAgICAgICAgICAgXCJzcGVjdWxhclwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHgxMTExMTEgKSB9LFxyXG4gICAgICAgICAgICAgICAgXCJzaGluaW5lc3NcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDMwIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICBdICksXHJcblxyXG4gICAgICAgIHZlcnRleFNoYWRlcjogW1xyXG5cclxuICAgICAgICAgICAgXCIjZGVmaW5lIFBIT05HXCIsXHJcblxyXG4gICAgICAgICAgICBcInZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1wiLFxyXG5cclxuICAgICAgICAgICAgXCIjaWZuZGVmIEZMQVRfU0hBREVEXCIsXHJcblxyXG4gICAgICAgICAgICBcIlx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XCIsXHJcblxyXG4gICAgICAgICAgICBcIiNlbmRpZlwiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXZfcGFyc192ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfcGFyc192ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc192ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfcGhvbmdfcGFyc192ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfcGFyc192ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc192ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml92ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5ub3JtYWxfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGhub3JtYWxfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbmJhc2VfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJkZWZhdWx0bm9ybWFsX3ZlcnRleFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcIiNpZm5kZWYgRkxBVF9TSEFERURcIiwgLy8gTm9ybWFsIGNvbXB1dGVkIHdpdGggZGVyaXZhdGl2ZXMgd2hlbiBGTEFUX1NIQURFRFxyXG5cclxuICAgICAgICAgICAgXCJcdHZOb3JtYWwgPSBub3JtYWxpemUoIHRyYW5zZm9ybWVkTm9ybWFsICk7XCIsXHJcblxyXG4gICAgICAgICAgICBcIiNlbmRpZlwiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5fdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGlzcGxhY2VtZW50bWFwX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInByb2plY3RfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFwiXHR2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejtcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIndvcmxkcG9zX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF92ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfcGhvbmdfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3ZlcnRleFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcIn1cIlxyXG5cclxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKSxcclxuXHJcbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcbiAgICAgICAgICAgIFwiI2RlZmluZSBQSE9OR1wiLFxyXG5cclxuICAgICAgICAgICAgXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcIixcclxuICAgICAgICAgICAgXCJ1bmlmb3JtIHZlYzMgZW1pc3NpdmU7XCIsXHJcbiAgICAgICAgICAgIFwidW5pZm9ybSB2ZWMzIHNwZWN1bGFyO1wiLFxyXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgc2hpbmluZXNzO1wiLFxyXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhb21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImJ1bXBtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG4gICAgICAgICAgICBcIlx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XCIsXHJcbiAgICAgICAgICAgIFwiXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcIixcclxuICAgICAgICAgICAgXCJcdHZlYzMgdG90YWxBbWJpZW50TGlnaHQgPSBhbWJpZW50TGlnaHRDb2xvcjtcIixcclxuICAgICAgICAgICAgXCJcdHZlYzMgdG90YWxFbWlzc2l2ZUxpZ2h0ID0gZW1pc3NpdmU7XCIsXHJcbiAgICAgICAgICAgIFwiXHR2ZWMzIHNoYWRvd01hc2sgPSB2ZWMzKCAxLjAgKTtcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYW1hcF9mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhdGVzdF9mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibm9ybWFsX3Bob25nX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJoZW1pbGlnaHRfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhb21hcF9mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImVtaXNzaXZlbWFwX2ZyYWdtZW50XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19waG9uZ19mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9mcmFnbWVudFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcInRvdGFsRGlmZnVzZUxpZ2h0ICo9IHNoYWRvd01hc2s7XCIsXHJcbiAgICAgICAgICAgIFwidG90YWxTcGVjdWxhckxpZ2h0ICo9IHNoYWRvd01hc2s7XCIsXHJcblxyXG4gICAgICAgICAgICBcIiNpZmRlZiBNRVRBTFwiLFxyXG5cclxuICAgICAgICAgICAgXCJcdG91dGdvaW5nTGlnaHQgKz0gZGlmZnVzZUNvbG9yLnJnYiAqICggdG90YWxEaWZmdXNlTGlnaHQgKyB0b3RhbEFtYmllbnRMaWdodCApICogc3BlY3VsYXIgKyB0b3RhbFNwZWN1bGFyTGlnaHQgKyB0b3RhbEVtaXNzaXZlTGlnaHQ7XCIsXHJcblxyXG4gICAgICAgICAgICBcIiNlbHNlXCIsXHJcblxyXG4gICAgICAgICAgICBcIlx0b3V0Z29pbmdMaWdodCArPSBkaWZmdXNlQ29sb3IucmdiICogKCB0b3RhbERpZmZ1c2VMaWdodCArIHRvdGFsQW1iaWVudExpZ2h0ICkgKyB0b3RhbFNwZWN1bGFyTGlnaHQgKyB0b3RhbEVtaXNzaXZlTGlnaHQ7XCIsXHJcblxyXG4gICAgICAgICAgICBcIiNlbmRpZlwiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX2ZyYWdtZW50XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxpbmVhcl90b19nYW1tYV9mcmFnbWVudFwiIF0sXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfZnJhZ21lbnRcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XCIsXHJcblxyXG4gICAgICAgICAgICBcIn1cIlxyXG5cclxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgJ3BvaW50cyc6IHtcclxuXHJcbiAgICAgICAgdW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcInBvaW50c1wiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcInNoYWRvd21hcFwiIF1cclxuXHJcbiAgICAgICAgXSApLFxyXG5cclxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcbiAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCBzaXplO1wiLFxyXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgc2NhbGU7XCIsXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFwiXHR2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXHJcblxyXG4gICAgICAgICAgICBcIlx0I2lmZGVmIFVTRV9TSVpFQVRURU5VQVRJT05cIixcclxuICAgICAgICAgICAgXCJcdFx0Z2xfUG9pbnRTaXplID0gc2l6ZSAqICggc2NhbGUgLyBsZW5ndGgoIG12UG9zaXRpb24ueHl6ICkgKTtcIixcclxuICAgICAgICAgICAgXCJcdCNlbHNlXCIsXHJcbiAgICAgICAgICAgIFwiXHRcdGdsX1BvaW50U2l6ZSA9IHNpemU7XCIsXHJcbiAgICAgICAgICAgIFwiXHQjZW5kaWZcIixcclxuXHJcbiAgICAgICAgICAgIFwiXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1wiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwid29ybGRwb3NfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3ZlcnRleFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcIn1cIlxyXG5cclxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKSxcclxuXHJcbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcbiAgICAgICAgICAgIFwidW5pZm9ybSB2ZWMzIHBzQ29sb3I7XCIsXHJcbiAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG4gICAgICAgICAgICBcIlx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XCIsXHJcbiAgICAgICAgICAgIFwiXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIHBzQ29sb3IsIG9wYWNpdHkgKTtcIixcclxuICAgICAgICAgICAgXCJcdHZlYzMgc2hhZG93TWFzayA9IHZlYzMoIDEuMCApO1wiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFydGljbGVfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhdGVzdF9mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9mcmFnbWVudFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcIlx0b3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2IgKiBzaGFkb3dNYXNrO1wiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFwiXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1wiLFxyXG5cclxuICAgICAgICAgICAgXCJ9XCJcclxuXHJcbiAgICAgICAgXS5qb2luKCBcIlxcblwiIClcclxuXHJcbiAgICB9LFxyXG5cclxuICAgICdkYXNoZWQnOiB7XHJcblxyXG4gICAgICAgIHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJjb21tb25cIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJmb2dcIiBdLFxyXG5cclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJzY2FsZVwiICAgIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfSxcclxuICAgICAgICAgICAgICAgIFwiZGFzaFNpemVcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXHJcbiAgICAgICAgICAgICAgICBcInRvdGFsU2l6ZVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMiB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgXSApLFxyXG5cclxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcbiAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCBzY2FsZTtcIixcclxuICAgICAgICAgICAgXCJhdHRyaWJ1dGUgZmxvYXQgbGluZURpc3RhbmNlO1wiLFxyXG5cclxuICAgICAgICAgICAgXCJ2YXJ5aW5nIGZsb2F0IHZMaW5lRGlzdGFuY2U7XCIsXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFwiXHR2TGluZURpc3RhbmNlID0gc2NhbGUgKiBsaW5lRGlzdGFuY2U7XCIsXHJcblxyXG4gICAgICAgICAgICBcIlx0dmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxyXG4gICAgICAgICAgICBcIlx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcIn1cIlxyXG5cclxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKSxcclxuXHJcbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcbiAgICAgICAgICAgIFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XCIsXHJcbiAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxyXG5cclxuICAgICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IGRhc2hTaXplO1wiLFxyXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgdG90YWxTaXplO1wiLFxyXG5cclxuICAgICAgICAgICAgXCJ2YXJ5aW5nIGZsb2F0IHZMaW5lRGlzdGFuY2U7XCIsXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuICAgICAgICAgICAgXCJcdGlmICggbW9kKCB2TGluZURpc3RhbmNlLCB0b3RhbFNpemUgKSA+IGRhc2hTaXplICkge1wiLFxyXG5cclxuICAgICAgICAgICAgXCJcdFx0ZGlzY2FyZDtcIixcclxuXHJcbiAgICAgICAgICAgIFwiXHR9XCIsXHJcblxyXG4gICAgICAgICAgICBcIlx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XCIsXHJcbiAgICAgICAgICAgIFwiXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJcdG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiO1wiLCAvLyBzaW1wbGUgc2hhZGVyXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfZnJhZ21lbnRcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XCIsXHJcblxyXG4gICAgICAgICAgICBcIn1cIlxyXG5cclxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgJ2RlcHRoJzoge1xyXG5cclxuICAgICAgICB1bmlmb3Jtczoge1xyXG5cclxuICAgICAgICAgICAgXCJtTmVhclwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXHJcbiAgICAgICAgICAgIFwibUZhclwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDIwMDAuMCB9LFxyXG4gICAgICAgICAgICBcIm9wYWNpdHlcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfVxyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJiZWdpbl92ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJwcm9qZWN0X3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcIn1cIlxyXG5cclxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKSxcclxuXHJcbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcbiAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCBtTmVhcjtcIixcclxuICAgICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IG1GYXI7XCIsXHJcbiAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFwiXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFwiLFxyXG5cclxuICAgICAgICAgICAgXCJcdFx0ZmxvYXQgZGVwdGggPSBnbF9GcmFnRGVwdGhFWFQgLyBnbF9GcmFnQ29vcmQudztcIixcclxuXHJcbiAgICAgICAgICAgIFwiXHQjZWxzZVwiLFxyXG5cclxuICAgICAgICAgICAgXCJcdFx0ZmxvYXQgZGVwdGggPSBnbF9GcmFnQ29vcmQueiAvIGdsX0ZyYWdDb29yZC53O1wiLFxyXG5cclxuICAgICAgICAgICAgXCJcdCNlbmRpZlwiLFxyXG5cclxuICAgICAgICAgICAgXCJcdGZsb2F0IGNvbG9yID0gMS4wIC0gc21vb3Roc3RlcCggbU5lYXIsIG1GYXIsIGRlcHRoICk7XCIsXHJcbiAgICAgICAgICAgIFwiXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCB2ZWMzKCBjb2xvciApLCBvcGFjaXR5ICk7XCIsXHJcblxyXG4gICAgICAgICAgICBcIn1cIlxyXG5cclxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgJ25vcm1hbCc6IHtcclxuXHJcbiAgICAgICAgdW5pZm9ybXM6IHtcclxuXHJcbiAgICAgICAgICAgIFwib3BhY2l0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHZlcnRleFNoYWRlcjogW1xyXG5cclxuICAgICAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG4gICAgICAgICAgICBcIlx0dk5vcm1hbCA9IG5vcm1hbGl6ZSggbm9ybWFsTWF0cml4ICogbm9ybWFsICk7XCIsXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJiZWdpbl92ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJwcm9qZWN0X3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcIn1cIlxyXG5cclxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKSxcclxuXHJcbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcbiAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxyXG4gICAgICAgICAgICBcInZhcnlpbmcgdmVjMyB2Tm9ybWFsO1wiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcclxuXHJcbiAgICAgICAgICAgIFwiXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCAwLjUgKiBub3JtYWxpemUoIHZOb3JtYWwgKSArIDAuNSwgb3BhY2l0eSApO1wiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJ9XCJcclxuXHJcbiAgICAgICAgXS5qb2luKCBcIlxcblwiIClcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAvL1x0Q3ViZSBtYXAgc2hhZGVyXHJcbiAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuICAgICdjdWJlJzoge1xyXG5cclxuICAgICAgICB1bmlmb3JtczogeyBcInRDdWJlXCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcbiAgICAgICAgICAgIFwidEZsaXBcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IC0gMSB9IH0sXHJcblxyXG4gICAgICAgIHZlcnRleFNoYWRlcjogW1xyXG5cclxuICAgICAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XCIsXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcclxuXHJcbiAgICAgICAgICAgIFwiXHR2V29ybGRQb3NpdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbiggcG9zaXRpb24sIG1vZGVsTWF0cml4ICk7XCIsXHJcblxyXG4gICAgICAgICAgICBcIlx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFwifVwiXHJcblxyXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApLFxyXG5cclxuICAgICAgICBmcmFnbWVudFNoYWRlcjogW1xyXG5cclxuICAgICAgICAgICAgXCJ1bmlmb3JtIHNhbXBsZXJDdWJlIHRDdWJlO1wiLFxyXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgdEZsaXA7XCIsXHJcblxyXG4gICAgICAgICAgICBcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG4gICAgICAgICAgICBcIlx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZUN1YmUoIHRDdWJlLCB2ZWMzKCB0RmxpcCAqIHZXb3JsZFBvc2l0aW9uLngsIHZXb3JsZFBvc2l0aW9uLnl6ICkgKTtcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFwifVwiXHJcblxyXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApXHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgLy9cdEN1YmUgbWFwIHNoYWRlclxyXG4gICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcbiAgICAnZXF1aXJlY3QnOiB7XHJcblxyXG4gICAgICAgIHVuaWZvcm1zOiB7IFwidEVxdWlyZWN0XCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcbiAgICAgICAgICAgIFwidEZsaXBcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IC0gMSB9IH0sXHJcblxyXG4gICAgICAgIHZlcnRleFNoYWRlcjogW1xyXG5cclxuICAgICAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XCIsXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcclxuXHJcbiAgICAgICAgICAgIFwiXHR2V29ybGRQb3NpdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbiggcG9zaXRpb24sIG1vZGVsTWF0cml4ICk7XCIsXHJcblxyXG4gICAgICAgICAgICBcIlx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFwifVwiXHJcblxyXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApLFxyXG5cclxuICAgICAgICBmcmFnbWVudFNoYWRlcjogW1xyXG5cclxuICAgICAgICAgICAgXCJ1bmlmb3JtIHNhbXBsZXIyRCB0RXF1aXJlY3Q7XCIsXHJcbiAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCB0RmxpcDtcIixcclxuXHJcbiAgICAgICAgICAgIFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1wiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcclxuXHJcbiAgICAgICAgICAgIC8vIFwiXHRnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlQ3ViZSggdEN1YmUsIHZlYzMoIHRGbGlwICogdldvcmxkUG9zaXRpb24ueCwgdldvcmxkUG9zaXRpb24ueXogKSApO1wiLFxyXG4gICAgICAgICAgICBcInZlYzMgZGlyZWN0aW9uID0gbm9ybWFsaXplKCB2V29ybGRQb3NpdGlvbiApO1wiLFxyXG4gICAgICAgICAgICBcInZlYzIgc2FtcGxlVVY7XCIsXHJcbiAgICAgICAgICAgIFwic2FtcGxlVVYueSA9IHNhdHVyYXRlKCB0RmxpcCAqIGRpcmVjdGlvbi55ICogLTAuNSArIDAuNSApO1wiLFxyXG4gICAgICAgICAgICBcInNhbXBsZVVWLnggPSBhdGFuKCBkaXJlY3Rpb24ueiwgZGlyZWN0aW9uLnggKSAqIFJFQ0lQUk9DQUxfUEkyICsgMC41O1wiLFxyXG4gICAgICAgICAgICBcImdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggdEVxdWlyZWN0LCBzYW1wbGVVViApO1wiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJ9XCJcclxuXHJcbiAgICAgICAgXS5qb2luKCBcIlxcblwiIClcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qIERlcHRoIGVuY29kaW5nIGludG8gUkdCQSB0ZXh0dXJlXHJcbiAgICAgKlxyXG4gICAgICogYmFzZWQgb24gU3BpZGVyR0wgc2hhZG93IG1hcCBleGFtcGxlXHJcbiAgICAgKiBodHRwOi8vc3BpZGVyZ2wub3JnL2V4YW1wbGUucGhwP2lkPTZcclxuICAgICAqXHJcbiAgICAgKiBvcmlnaW5hbGx5IGZyb21cclxuICAgICAqIGh0dHA6Ly93d3cuZ2FtZWRldi5uZXQvdG9waWMvNDQyMTM4LXBhY2tpbmctYS1mbG9hdC1pbnRvLWEtYThyOGc4YjgtdGV4dHVyZS1zaGFkZXIvcGFnZV9fd2hpY2hwYWdlX18xJTI1RUYlMjVCRiUyNUJEXHJcbiAgICAgKlxyXG4gICAgICogc2VlIGFsc29cclxuICAgICAqIGh0dHA6Ly9hcmFzLXAuaW5mby9ibG9nLzIwMDkvMDcvMzAvZW5jb2RpbmctZmxvYXRzLXRvLXJnYmEtdGhlLWZpbmFsL1xyXG4gICAgICovXHJcblxyXG4gICAgJ2RlcHRoUkdCQSc6IHtcclxuXHJcbiAgICAgICAgdW5pZm9ybXM6IHt9LFxyXG5cclxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfcGFyc192ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJiZWdpbl92ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ192ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJwcm9qZWN0X3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcIn1cIlxyXG5cclxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKSxcclxuXHJcbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJ2ZWM0IHBhY2tfZGVwdGgoIGNvbnN0IGluIGZsb2F0IGRlcHRoICkge1wiLFxyXG5cclxuICAgICAgICAgICAgXCJcdGNvbnN0IHZlYzQgYml0X3NoaWZ0ID0gdmVjNCggMjU2LjAgKiAyNTYuMCAqIDI1Ni4wLCAyNTYuMCAqIDI1Ni4wLCAyNTYuMCwgMS4wICk7XCIsXHJcbiAgICAgICAgICAgIFwiXHRjb25zdCB2ZWM0IGJpdF9tYXNrID0gdmVjNCggMC4wLCAxLjAgLyAyNTYuMCwgMS4wIC8gMjU2LjAsIDEuMCAvIDI1Ni4wICk7XCIsXHJcbiAgICAgICAgICAgIFwiXHR2ZWM0IHJlcyA9IG1vZCggZGVwdGggKiBiaXRfc2hpZnQgKiB2ZWM0KCAyNTUgKSwgdmVjNCggMjU2ICkgKSAvIHZlYzQoIDI1NSApO1wiLCAvLyBcIlx0dmVjNCByZXMgPSBmcmFjdCggZGVwdGggKiBiaXRfc2hpZnQgKTtcIixcclxuICAgICAgICAgICAgXCJcdHJlcyAtPSByZXMueHh5eiAqIGJpdF9tYXNrO1wiLFxyXG4gICAgICAgICAgICBcIlx0cmV0dXJuIHJlcztcIixcclxuXHJcbiAgICAgICAgICAgIFwifVwiLFxyXG5cclxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcIlx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcIixcclxuXHJcbiAgICAgICAgICAgIFwiXHRcdGdsX0ZyYWdEYXRhWyAwIF0gPSBwYWNrX2RlcHRoKCBnbF9GcmFnRGVwdGhFWFQgKTtcIixcclxuXHJcbiAgICAgICAgICAgIFwiXHQjZWxzZVwiLFxyXG5cclxuICAgICAgICAgICAgXCJcdFx0Z2xfRnJhZ0RhdGFbIDAgXSA9IHBhY2tfZGVwdGgoIGdsX0ZyYWdDb29yZC56ICk7XCIsXHJcblxyXG4gICAgICAgICAgICBcIlx0I2VuZGlmXCIsXHJcblxyXG4gICAgICAgICAgICAvL1wiZ2xfRnJhZ0RhdGFbIDAgXSA9IHBhY2tfZGVwdGgoIGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLncgKTtcIixcclxuICAgICAgICAgICAgLy9cImZsb2F0IHogPSAoICggZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudyApIC0gMy4wICkgLyAoIDQwMDAuMCAtIDMuMCApO1wiLFxyXG4gICAgICAgICAgICAvL1wiZ2xfRnJhZ0RhdGFbIDAgXSA9IHBhY2tfZGVwdGgoIHogKTtcIixcclxuICAgICAgICAgICAgLy9cImdsX0ZyYWdEYXRhWyAwIF0gPSB2ZWM0KCB6LCB6LCB6LCAxLjAgKTtcIixcclxuXHJcbiAgICAgICAgICAgIFwifVwiXHJcblxyXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApXHJcblxyXG4gICAgfSxcclxuXHJcblxyXG4gICAgJ2Rpc3RhbmNlUkdCQSc6IHtcclxuXHJcbiAgICAgICAgdW5pZm9ybXM6IHtcclxuXHJcbiAgICAgICAgICAgIFwibGlnaHRQb3NcIjogeyB0eXBlOiBcInYzXCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMCApIH1cclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdmVydGV4U2hhZGVyOiBbXHJcblxyXG4gICAgICAgICAgICBcInZhcnlpbmcgdmVjNCB2V29ybGRQb3NpdGlvbjtcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2luYmFzZV92ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJiZWdpbl92ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ192ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJwcm9qZWN0X3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIndvcmxkcG9zX3ZlcnRleFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcInZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbjtcIixcclxuXHJcbiAgICAgICAgICAgIFwifVwiXHJcblxyXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApLFxyXG5cclxuICAgICAgICBmcmFnbWVudFNoYWRlcjogW1xyXG5cclxuICAgICAgICAgICAgXCJ1bmlmb3JtIHZlYzMgbGlnaHRQb3M7XCIsXHJcbiAgICAgICAgICAgIFwidmFyeWluZyB2ZWM0IHZXb3JsZFBvc2l0aW9uO1wiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuXHJcbiAgICAgICAgICAgIFwidmVjNCBwYWNrMUsgKCBmbG9hdCBkZXB0aCApIHtcIixcclxuXHJcbiAgICAgICAgICAgIFwiICAgZGVwdGggLz0gMTAwMC4wO1wiLFxyXG4gICAgICAgICAgICBcIiAgIGNvbnN0IHZlYzQgYml0U2ggPSB2ZWM0KCAyNTYuMCAqIDI1Ni4wICogMjU2LjAsIDI1Ni4wICogMjU2LjAsIDI1Ni4wLCAxLjAgKTtcIixcclxuICAgICAgICAgICAgXCJcdGNvbnN0IHZlYzQgYml0TXNrID0gdmVjNCggMC4wLCAxLjAgLyAyNTYuMCwgMS4wIC8gMjU2LjAsIDEuMCAvIDI1Ni4wICk7XCIsXHJcbiAgICAgICAgICAgIFwiXHR2ZWM0IHJlcyA9IGZyYWN0KCBkZXB0aCAqIGJpdFNoICk7XCIsXHJcbiAgICAgICAgICAgIFwiXHRyZXMgLT0gcmVzLnh4eXogKiBiaXRNc2s7XCIsXHJcbiAgICAgICAgICAgIFwiXHRyZXR1cm4gcmVzOyBcIixcclxuXHJcbiAgICAgICAgICAgIFwifVwiLFxyXG5cclxuICAgICAgICAgICAgXCJmbG9hdCB1bnBhY2sxSyAoIHZlYzQgY29sb3IgKSB7XCIsXHJcblxyXG4gICAgICAgICAgICBcIlx0Y29uc3QgdmVjNCBiaXRTaCA9IHZlYzQoIDEuMCAvICggMjU2LjAgKiAyNTYuMCAqIDI1Ni4wICksIDEuMCAvICggMjU2LjAgKiAyNTYuMCApLCAxLjAgLyAyNTYuMCwgMS4wICk7XCIsXHJcbiAgICAgICAgICAgIFwiXHRyZXR1cm4gZG90KCBjb2xvciwgYml0U2ggKSAqIDEwMDAuMDtcIixcclxuXHJcbiAgICAgICAgICAgIFwifVwiLFxyXG5cclxuICAgICAgICAgICAgXCJ2b2lkIG1haW4gKCkge1wiLFxyXG5cclxuICAgICAgICAgICAgXCJcdGdsX0ZyYWdDb2xvciA9IHBhY2sxSyggbGVuZ3RoKCB2V29ybGRQb3NpdGlvbi54eXogLSBsaWdodFBvcy54eXogKSApO1wiLFxyXG5cclxuICAgICAgICAgICAgXCJ9XCJcclxuXHJcbiAgICAgICAgXS5qb2luKCBcIlxcblwiIClcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL1dlYkdMUmVuZGVyZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIHN6aW1layAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zemltZWsvXHJcbiAqL1xyXG5cclxuVEhSRUUuV2ViR0xSZW5kZXJlciA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcclxuXHJcbiAgICBjb25zb2xlLmxvZyggJ1RIUkVFLldlYkdMUmVuZGVyZXInLCBUSFJFRS5SRVZJU0lPTiApO1xyXG5cclxuICAgIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xyXG5cclxuICAgIHZhciBfY2FudmFzID0gcGFyYW1ldGVycy5jYW52YXMgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY2FudmFzIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKSxcclxuICAgICAgICBfY29udGV4dCA9IHBhcmFtZXRlcnMuY29udGV4dCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5jb250ZXh0IDogbnVsbCxcclxuXHJcbiAgICAgICAgX3dpZHRoID0gX2NhbnZhcy53aWR0aCxcclxuICAgICAgICBfaGVpZ2h0ID0gX2NhbnZhcy5oZWlnaHQsXHJcblxyXG4gICAgICAgIHBpeGVsUmF0aW8gPSAxLFxyXG5cclxuICAgICAgICBfYWxwaGEgPSBwYXJhbWV0ZXJzLmFscGhhICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmFscGhhIDogZmFsc2UsXHJcbiAgICAgICAgX2RlcHRoID0gcGFyYW1ldGVycy5kZXB0aCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5kZXB0aCA6IHRydWUsXHJcbiAgICAgICAgX3N0ZW5jaWwgPSBwYXJhbWV0ZXJzLnN0ZW5jaWwgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuc3RlbmNpbCA6IHRydWUsXHJcbiAgICAgICAgX2FudGlhbGlhcyA9IHBhcmFtZXRlcnMuYW50aWFsaWFzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmFudGlhbGlhcyA6IGZhbHNlLFxyXG4gICAgICAgIF9wcmVtdWx0aXBsaWVkQWxwaGEgPSBwYXJhbWV0ZXJzLnByZW11bHRpcGxpZWRBbHBoYSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVtdWx0aXBsaWVkQWxwaGEgOiB0cnVlLFxyXG4gICAgICAgIF9wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgPSBwYXJhbWV0ZXJzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgOiBmYWxzZSxcclxuXHJcbiAgICAgICAgX2NsZWFyQ29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICksXHJcbiAgICAgICAgX2NsZWFyQWxwaGEgPSAwO1xyXG5cclxuICAgIHZhciBsaWdodHMgPSBbXTtcclxuXHJcbiAgICB2YXIgb3BhcXVlT2JqZWN0cyA9IFtdO1xyXG4gICAgdmFyIG9wYXF1ZU9iamVjdHNMYXN0SW5kZXggPSAtIDE7XHJcbiAgICB2YXIgdHJhbnNwYXJlbnRPYmplY3RzID0gW107XHJcbiAgICB2YXIgdHJhbnNwYXJlbnRPYmplY3RzTGFzdEluZGV4ID0gLSAxO1xyXG5cclxuICAgIHZhciBtb3JwaEluZmx1ZW5jZXMgPSBuZXcgRmxvYXQzMkFycmF5KCA4ICk7XHJcblxyXG5cclxuICAgIHZhciBzcHJpdGVzID0gW107XHJcbiAgICB2YXIgbGVuc0ZsYXJlcyA9IFtdO1xyXG5cclxuICAgIC8vIHB1YmxpYyBwcm9wZXJ0aWVzXHJcblxyXG4gICAgdGhpcy5kb21FbGVtZW50ID0gX2NhbnZhcztcclxuICAgIHRoaXMuY29udGV4dCA9IG51bGw7XHJcblxyXG4gICAgLy8gY2xlYXJpbmdcclxuXHJcbiAgICB0aGlzLmF1dG9DbGVhciA9IHRydWU7XHJcbiAgICB0aGlzLmF1dG9DbGVhckNvbG9yID0gdHJ1ZTtcclxuICAgIHRoaXMuYXV0b0NsZWFyRGVwdGggPSB0cnVlO1xyXG4gICAgdGhpcy5hdXRvQ2xlYXJTdGVuY2lsID0gdHJ1ZTtcclxuXHJcbiAgICAvLyBzY2VuZSBncmFwaFxyXG5cclxuICAgIHRoaXMuc29ydE9iamVjdHMgPSB0cnVlO1xyXG5cclxuICAgIC8vIHBoeXNpY2FsbHkgYmFzZWQgc2hhZGluZ1xyXG5cclxuICAgIHRoaXMuZ2FtbWFGYWN0b3IgPSAyLjA7XHQvLyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcclxuICAgIHRoaXMuZ2FtbWFJbnB1dCA9IGZhbHNlO1xyXG4gICAgdGhpcy5nYW1tYU91dHB1dCA9IGZhbHNlO1xyXG5cclxuICAgIC8vIG1vcnBoc1xyXG5cclxuICAgIHRoaXMubWF4TW9ycGhUYXJnZXRzID0gODtcclxuICAgIHRoaXMubWF4TW9ycGhOb3JtYWxzID0gNDtcclxuXHJcbiAgICAvLyBmbGFnc1xyXG5cclxuICAgIHRoaXMuYXV0b1NjYWxlQ3ViZW1hcHMgPSB0cnVlO1xyXG5cclxuICAgIC8vIGludGVybmFsIHByb3BlcnRpZXNcclxuXHJcbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxyXG5cclxuICAgIC8vIGludGVybmFsIHN0YXRlIGNhY2hlXHJcblxyXG4gICAgICAgIF9jdXJyZW50UHJvZ3JhbSA9IG51bGwsXHJcbiAgICAgICAgX2N1cnJlbnRGcmFtZWJ1ZmZlciA9IG51bGwsXHJcbiAgICAgICAgX2N1cnJlbnRNYXRlcmlhbElkID0gLSAxLFxyXG4gICAgICAgIF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtID0gJycsXHJcbiAgICAgICAgX2N1cnJlbnRDYW1lcmEgPSBudWxsLFxyXG5cclxuICAgICAgICBfdXNlZFRleHR1cmVVbml0cyA9IDAsXHJcblxyXG4gICAgICAgIF92aWV3cG9ydFggPSAwLFxyXG4gICAgICAgIF92aWV3cG9ydFkgPSAwLFxyXG4gICAgICAgIF92aWV3cG9ydFdpZHRoID0gX2NhbnZhcy53aWR0aCxcclxuICAgICAgICBfdmlld3BvcnRIZWlnaHQgPSBfY2FudmFzLmhlaWdodCxcclxuICAgICAgICBfY3VycmVudFdpZHRoID0gMCxcclxuICAgICAgICBfY3VycmVudEhlaWdodCA9IDAsXHJcblxyXG4gICAgLy8gZnJ1c3R1bVxyXG5cclxuICAgICAgICBfZnJ1c3R1bSA9IG5ldyBUSFJFRS5GcnVzdHVtKCksXHJcblxyXG4gICAgLy8gY2FtZXJhIG1hdHJpY2VzIGNhY2hlXHJcblxyXG4gICAgICAgIF9wcm9qU2NyZWVuTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKSxcclxuXHJcbiAgICAgICAgX3ZlY3RvcjMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cclxuICAgIC8vIGxpZ2h0IGFycmF5cyBjYWNoZVxyXG5cclxuICAgICAgICBfZGlyZWN0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHJcbiAgICAgICAgX2xpZ2h0c05lZWRVcGRhdGUgPSB0cnVlLFxyXG5cclxuICAgICAgICBfbGlnaHRzID0ge1xyXG5cclxuICAgICAgICAgICAgYW1iaWVudDogWyAwLCAwLCAwIF0sXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbmFsOiB7IGxlbmd0aDogMCwgY29sb3JzOiBbXSwgcG9zaXRpb25zOiBbXSB9LFxyXG4gICAgICAgICAgICBwb2ludDogeyBsZW5ndGg6IDAsIGNvbG9yczogW10sIHBvc2l0aW9uczogW10sIGRpc3RhbmNlczogW10sIGRlY2F5czogW10gfSxcclxuICAgICAgICAgICAgc3BvdDogeyBsZW5ndGg6IDAsIGNvbG9yczogW10sIHBvc2l0aW9uczogW10sIGRpc3RhbmNlczogW10sIGRpcmVjdGlvbnM6IFtdLCBhbmdsZXNDb3M6IFtdLCBleHBvbmVudHM6IFtdLCBkZWNheXM6IFtdIH0sXHJcbiAgICAgICAgICAgIGhlbWk6IHsgbGVuZ3RoOiAwLCBza3lDb2xvcnM6IFtdLCBncm91bmRDb2xvcnM6IFtdLCBwb3NpdGlvbnM6IFtdIH1cclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAvLyBpbmZvXHJcblxyXG4gICAgICAgIF9pbmZvTWVtb3J5ID0ge1xyXG5cclxuICAgICAgICAgICAgZ2VvbWV0cmllczogMCxcclxuICAgICAgICAgICAgdGV4dHVyZXM6IDBcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2luZm9SZW5kZXIgPSB7XHJcblxyXG4gICAgICAgICAgICBjYWxsczogMCxcclxuICAgICAgICAgICAgdmVydGljZXM6IDAsXHJcbiAgICAgICAgICAgIGZhY2VzOiAwLFxyXG4gICAgICAgICAgICBwb2ludHM6IDBcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB0aGlzLmluZm8gPSB7XHJcblxyXG4gICAgICAgIHJlbmRlcjogX2luZm9SZW5kZXIsXHJcbiAgICAgICAgbWVtb3J5OiBfaW5mb01lbW9yeSxcclxuICAgICAgICBwcm9ncmFtczogbnVsbFxyXG5cclxuICAgIH07XHJcblxyXG5cclxuICAgIC8vIGluaXRpYWxpemVcclxuXHJcbiAgICB2YXIgX2dsO1xyXG5cclxuICAgIHRyeSB7XHJcblxyXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0ge1xyXG4gICAgICAgICAgICBhbHBoYTogX2FscGhhLFxyXG4gICAgICAgICAgICBkZXB0aDogX2RlcHRoLFxyXG4gICAgICAgICAgICBzdGVuY2lsOiBfc3RlbmNpbCxcclxuICAgICAgICAgICAgYW50aWFsaWFzOiBfYW50aWFsaWFzLFxyXG4gICAgICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IF9wcmVtdWx0aXBsaWVkQWxwaGEsXHJcbiAgICAgICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogX3ByZXNlcnZlRHJhd2luZ0J1ZmZlclxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIF9nbCA9IF9jb250ZXh0IHx8IF9jYW52YXMuZ2V0Q29udGV4dCggJ3dlYmdsJywgYXR0cmlidXRlcyApIHx8IF9jYW52YXMuZ2V0Q29udGV4dCggJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIGF0dHJpYnV0ZXMgKTtcclxuXHJcbiAgICAgICAgaWYgKCBfZ2wgPT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIF9jYW52YXMuZ2V0Q29udGV4dCggJ3dlYmdsJyApICE9PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHRocm93ICdFcnJvciBjcmVhdGluZyBXZWJHTCBjb250ZXh0IHdpdGggeW91ciBzZWxlY3RlZCBhdHRyaWJ1dGVzLic7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIHRocm93ICdFcnJvciBjcmVhdGluZyBXZWJHTCBjb250ZXh0Lic7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCAnd2ViZ2xjb250ZXh0bG9zdCcsIG9uQ29udGV4dExvc3QsIGZhbHNlICk7XHJcblxyXG4gICAgfSBjYXRjaCAoIGVycm9yICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogJyArIGVycm9yICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHZhciBleHRlbnNpb25zID0gbmV3IFRIUkVFLldlYkdMRXh0ZW5zaW9ucyggX2dsICk7XHJcblxyXG4gICAgZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdCcgKTtcclxuICAgIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyApO1xyXG4gICAgZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0JyApO1xyXG4gICAgZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhcicgKTtcclxuICAgIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJyApO1xyXG4gICAgZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xyXG5cclxuICAgIGlmICggZXh0ZW5zaW9ucy5nZXQoICdPRVNfZWxlbWVudF9pbmRleF91aW50JyApICkge1xyXG5cclxuICAgICAgICBUSFJFRS5CdWZmZXJHZW9tZXRyeS5NYXhJbmRleCA9IDQyOTQ5NjcyOTY7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHZhciBjYXBhYmlsaXRpZXMgPSBuZXcgVEhSRUUuV2ViR0xDYXBhYmlsaXRpZXMoIF9nbCwgZXh0ZW5zaW9ucywgcGFyYW1ldGVycyApO1xyXG5cclxuICAgIHZhciBzdGF0ZSA9IG5ldyBUSFJFRS5XZWJHTFN0YXRlKCBfZ2wsIGV4dGVuc2lvbnMsIHBhcmFtVGhyZWVUb0dMICk7XHJcbiAgICB2YXIgcHJvcGVydGllcyA9IG5ldyBUSFJFRS5XZWJHTFByb3BlcnRpZXMoKTtcclxuICAgIHZhciBvYmplY3RzID0gbmV3IFRIUkVFLldlYkdMT2JqZWN0cyggX2dsLCBwcm9wZXJ0aWVzLCB0aGlzLmluZm8gKTtcclxuICAgIHZhciBwcm9ncmFtQ2FjaGUgPSBuZXcgVEhSRUUuV2ViR0xQcm9ncmFtcyggdGhpcywgY2FwYWJpbGl0aWVzICk7XHJcblxyXG4gICAgdGhpcy5pbmZvLnByb2dyYW1zID0gcHJvZ3JhbUNhY2hlLnByb2dyYW1zO1xyXG5cclxuICAgIHZhciBidWZmZXJSZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTEJ1ZmZlclJlbmRlcmVyKCBfZ2wsIGV4dGVuc2lvbnMsIF9pbmZvUmVuZGVyICk7XHJcbiAgICB2YXIgaW5kZXhlZEJ1ZmZlclJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMSW5kZXhlZEJ1ZmZlclJlbmRlcmVyKCBfZ2wsIGV4dGVuc2lvbnMsIF9pbmZvUmVuZGVyICk7XHJcblxyXG4gICAgLy9cclxuXHJcbiAgICBmdW5jdGlvbiBnbENsZWFyQ29sb3IoIHIsIGcsIGIsIGEgKSB7XHJcblxyXG4gICAgICAgIGlmICggX3ByZW11bHRpcGxpZWRBbHBoYSA9PT0gdHJ1ZSApIHtcclxuXHJcbiAgICAgICAgICAgIHIgKj0gYTsgZyAqPSBhOyBiICo9IGE7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgX2dsLmNsZWFyQ29sb3IoIHIsIGcsIGIsIGEgKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2V0RGVmYXVsdEdMU3RhdGUoKSB7XHJcblxyXG4gICAgICAgIHN0YXRlLmluaXQoKTtcclxuXHJcbiAgICAgICAgX2dsLnZpZXdwb3J0KCBfdmlld3BvcnRYLCBfdmlld3BvcnRZLCBfdmlld3BvcnRXaWR0aCwgX3ZpZXdwb3J0SGVpZ2h0ICk7XHJcblxyXG4gICAgICAgIGdsQ2xlYXJDb2xvciggX2NsZWFyQ29sb3IuciwgX2NsZWFyQ29sb3IuZywgX2NsZWFyQ29sb3IuYiwgX2NsZWFyQWxwaGEgKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVzZXRHTFN0YXRlKCkge1xyXG5cclxuICAgICAgICBfY3VycmVudFByb2dyYW0gPSBudWxsO1xyXG4gICAgICAgIF9jdXJyZW50Q2FtZXJhID0gbnVsbDtcclxuXHJcbiAgICAgICAgX2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSAnJztcclxuICAgICAgICBfY3VycmVudE1hdGVyaWFsSWQgPSAtIDE7XHJcblxyXG4gICAgICAgIF9saWdodHNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgc3RhdGUucmVzZXQoKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgc2V0RGVmYXVsdEdMU3RhdGUoKTtcclxuXHJcbiAgICB0aGlzLmNvbnRleHQgPSBfZ2w7XHJcbiAgICB0aGlzLmNhcGFiaWxpdGllcyA9IGNhcGFiaWxpdGllcztcclxuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XHJcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XHJcblxyXG4gICAgLy8gc2hhZG93IG1hcFxyXG5cclxuICAgIHZhciBzaGFkb3dNYXAgPSBuZXcgVEhSRUUuV2ViR0xTaGFkb3dNYXAoIHRoaXMsIGxpZ2h0cywgb2JqZWN0cyApO1xyXG5cclxuICAgIHRoaXMuc2hhZG93TWFwID0gc2hhZG93TWFwO1xyXG5cclxuXHJcbiAgICAvLyBQbHVnaW5zXHJcblxyXG4gICAgdmFyIHNwcml0ZVBsdWdpbiA9IG5ldyBUSFJFRS5TcHJpdGVQbHVnaW4oIHRoaXMsIHNwcml0ZXMgKTtcclxuICAgIHZhciBsZW5zRmxhcmVQbHVnaW4gPSBuZXcgVEhSRUUuTGVuc0ZsYXJlUGx1Z2luKCB0aGlzLCBsZW5zRmxhcmVzICk7XHJcblxyXG4gICAgLy8gQVBJXHJcblxyXG4gICAgdGhpcy5nZXRDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gX2dsO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5nZXRDb250ZXh0QXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIF9nbC5nZXRDb250ZXh0QXR0cmlidXRlcygpO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5mb3JjZUNvbnRleHRMb3NzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICBleHRlbnNpb25zLmdldCggJ1dFQkdMX2xvc2VfY29udGV4dCcgKS5sb3NlQ29udGV4dCgpO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5nZXRNYXhBbmlzb3Ryb3B5ID0gKCBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciB2YWx1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGdldE1heEFuaXNvdHJvcHkoKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSByZXR1cm4gdmFsdWU7XHJcblxyXG4gICAgICAgICAgICB2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IF9nbC5nZXRQYXJhbWV0ZXIoIGV4dGVuc2lvbi5NQVhfVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAwO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSApKCk7XHJcblxyXG4gICAgdGhpcy5nZXRQcmVjaXNpb24gPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBjYXBhYmlsaXRpZXMucHJlY2lzaW9uO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5nZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gcGl4ZWxSYXRpbztcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHBpeGVsUmF0aW8gPSB2YWx1ZTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZ2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgd2lkdGg6IF93aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBfaGVpZ2h0XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc2V0U2l6ZSA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCwgdXBkYXRlU3R5bGUgKSB7XHJcblxyXG4gICAgICAgIF93aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIF9oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gICAgICAgIF9jYW52YXMud2lkdGggPSB3aWR0aCAqIHBpeGVsUmF0aW87XHJcbiAgICAgICAgX2NhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiBwaXhlbFJhdGlvO1xyXG5cclxuICAgICAgICBpZiAoIHVwZGF0ZVN0eWxlICE9PSBmYWxzZSApIHtcclxuXHJcbiAgICAgICAgICAgIF9jYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XHJcbiAgICAgICAgICAgIF9jYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnNldFZpZXdwb3J0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnNldFZpZXdwb3J0ID0gZnVuY3Rpb24gKCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xyXG5cclxuICAgICAgICBfdmlld3BvcnRYID0geCAqIHBpeGVsUmF0aW87XHJcbiAgICAgICAgX3ZpZXdwb3J0WSA9IHkgKiBwaXhlbFJhdGlvO1xyXG5cclxuICAgICAgICBfdmlld3BvcnRXaWR0aCA9IHdpZHRoICogcGl4ZWxSYXRpbztcclxuICAgICAgICBfdmlld3BvcnRIZWlnaHQgPSBoZWlnaHQgKiBwaXhlbFJhdGlvO1xyXG5cclxuICAgICAgICBfZ2wudmlld3BvcnQoIF92aWV3cG9ydFgsIF92aWV3cG9ydFksIF92aWV3cG9ydFdpZHRoLCBfdmlld3BvcnRIZWlnaHQgKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZ2V0Vmlld3BvcnQgPSBmdW5jdGlvbiAoIGRpbWVuc2lvbnMgKSB7XHJcblxyXG4gICAgICAgIGRpbWVuc2lvbnMueCA9IF92aWV3cG9ydFggLyBwaXhlbFJhdGlvO1xyXG4gICAgICAgIGRpbWVuc2lvbnMueSA9IF92aWV3cG9ydFkgLyBwaXhlbFJhdGlvO1xyXG5cclxuICAgICAgICBkaW1lbnNpb25zLnogPSBfdmlld3BvcnRXaWR0aCAvIHBpeGVsUmF0aW87XHJcbiAgICAgICAgZGltZW5zaW9ucy53ID0gX3ZpZXdwb3J0SGVpZ2h0IC8gcGl4ZWxSYXRpbztcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc2V0U2Npc3NvciA9IGZ1bmN0aW9uICggeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcclxuXHJcbiAgICAgICAgX2dsLnNjaXNzb3IoXHJcbiAgICAgICAgICAgIHggKiBwaXhlbFJhdGlvLFxyXG4gICAgICAgICAgICB5ICogcGl4ZWxSYXRpbyxcclxuICAgICAgICAgICAgd2lkdGggKiBwaXhlbFJhdGlvLFxyXG4gICAgICAgICAgICBoZWlnaHQgKiBwaXhlbFJhdGlvXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZW5hYmxlU2Npc3NvclRlc3QgPSBmdW5jdGlvbiAoIGJvb2xlYW4gKSB7XHJcblxyXG4gICAgICAgIHN0YXRlLnNldFNjaXNzb3JUZXN0KCBib29sZWFuICk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBDbGVhcmluZ1xyXG5cclxuICAgIHRoaXMuZ2V0Q2xlYXJDb2xvciA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIF9jbGVhckNvbG9yO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zZXRDbGVhckNvbG9yID0gZnVuY3Rpb24gKCBjb2xvciwgYWxwaGEgKSB7XHJcblxyXG4gICAgICAgIF9jbGVhckNvbG9yLnNldCggY29sb3IgKTtcclxuXHJcbiAgICAgICAgX2NsZWFyQWxwaGEgPSBhbHBoYSAhPT0gdW5kZWZpbmVkID8gYWxwaGEgOiAxO1xyXG5cclxuICAgICAgICBnbENsZWFyQ29sb3IoIF9jbGVhckNvbG9yLnIsIF9jbGVhckNvbG9yLmcsIF9jbGVhckNvbG9yLmIsIF9jbGVhckFscGhhICk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmdldENsZWFyQWxwaGEgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBfY2xlYXJBbHBoYTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc2V0Q2xlYXJBbHBoYSA9IGZ1bmN0aW9uICggYWxwaGEgKSB7XHJcblxyXG4gICAgICAgIF9jbGVhckFscGhhID0gYWxwaGE7XHJcblxyXG4gICAgICAgIGdsQ2xlYXJDb2xvciggX2NsZWFyQ29sb3IuciwgX2NsZWFyQ29sb3IuZywgX2NsZWFyQ29sb3IuYiwgX2NsZWFyQWxwaGEgKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuY2xlYXIgPSBmdW5jdGlvbiAoIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCApIHtcclxuXHJcbiAgICAgICAgdmFyIGJpdHMgPSAwO1xyXG5cclxuICAgICAgICBpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgfHwgY29sb3IgKSBiaXRzIHw9IF9nbC5DT0xPUl9CVUZGRVJfQklUO1xyXG4gICAgICAgIGlmICggZGVwdGggPT09IHVuZGVmaW5lZCB8fCBkZXB0aCApIGJpdHMgfD0gX2dsLkRFUFRIX0JVRkZFUl9CSVQ7XHJcbiAgICAgICAgaWYgKCBzdGVuY2lsID09PSB1bmRlZmluZWQgfHwgc3RlbmNpbCApIGJpdHMgfD0gX2dsLlNURU5DSUxfQlVGRkVSX0JJVDtcclxuXHJcbiAgICAgICAgX2dsLmNsZWFyKCBiaXRzICk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmNsZWFyQ29sb3IgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIF9nbC5jbGVhciggX2dsLkNPTE9SX0JVRkZFUl9CSVQgKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuY2xlYXJEZXB0aCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgX2dsLmNsZWFyKCBfZ2wuREVQVEhfQlVGRkVSX0JJVCApO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5jbGVhclN0ZW5jaWwgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIF9nbC5jbGVhciggX2dsLlNURU5DSUxfQlVGRkVSX0JJVCApO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5jbGVhclRhcmdldCA9IGZ1bmN0aW9uICggcmVuZGVyVGFyZ2V0LCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0UmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcclxuICAgICAgICB0aGlzLmNsZWFyKCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFJlc2V0XHJcblxyXG4gICAgdGhpcy5yZXNldEdMU3RhdGUgPSByZXNldEdMU3RhdGU7XHJcblxyXG4gICAgdGhpcy5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIF9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3dlYmdsY29udGV4dGxvc3QnLCBvbkNvbnRleHRMb3N0LCBmYWxzZSApO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLy8gRXZlbnRzXHJcblxyXG4gICAgZnVuY3Rpb24gb25Db250ZXh0TG9zdCggZXZlbnQgKSB7XHJcblxyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgIHJlc2V0R0xTdGF0ZSgpO1xyXG4gICAgICAgIHNldERlZmF1bHRHTFN0YXRlKCk7XHJcblxyXG4gICAgICAgIHByb3BlcnRpZXMuY2xlYXIoKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIG9uVGV4dHVyZURpc3Bvc2UoIGV2ZW50ICkge1xyXG5cclxuICAgICAgICB2YXIgdGV4dHVyZSA9IGV2ZW50LnRhcmdldDtcclxuXHJcbiAgICAgICAgdGV4dHVyZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UgKTtcclxuXHJcbiAgICAgICAgZGVhbGxvY2F0ZVRleHR1cmUoIHRleHR1cmUgKTtcclxuXHJcbiAgICAgICAgX2luZm9NZW1vcnkudGV4dHVyZXMgLS07XHJcblxyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBvblJlbmRlclRhcmdldERpc3Bvc2UoIGV2ZW50ICkge1xyXG5cclxuICAgICAgICB2YXIgcmVuZGVyVGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xyXG5cclxuICAgICAgICByZW5kZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblJlbmRlclRhcmdldERpc3Bvc2UgKTtcclxuXHJcbiAgICAgICAgZGVhbGxvY2F0ZVJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG4gICAgICAgIF9pbmZvTWVtb3J5LnRleHR1cmVzIC0tO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBvbk1hdGVyaWFsRGlzcG9zZSggZXZlbnQgKSB7XHJcblxyXG4gICAgICAgIHZhciBtYXRlcmlhbCA9IGV2ZW50LnRhcmdldDtcclxuXHJcbiAgICAgICAgbWF0ZXJpYWwucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbk1hdGVyaWFsRGlzcG9zZSApO1xyXG5cclxuICAgICAgICBkZWFsbG9jYXRlTWF0ZXJpYWwoIG1hdGVyaWFsICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vIEJ1ZmZlciBkZWFsbG9jYXRpb25cclxuXHJcbiAgICBmdW5jdGlvbiBkZWFsbG9jYXRlVGV4dHVyZSggdGV4dHVyZSApIHtcclxuXHJcbiAgICAgICAgdmFyIHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKTtcclxuXHJcbiAgICAgICAgaWYgKCB0ZXh0dXJlLmltYWdlICYmIHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBjdWJlIHRleHR1cmVcclxuXHJcbiAgICAgICAgICAgIF9nbC5kZWxldGVUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlICk7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAvLyAyRCB0ZXh0dXJlXHJcblxyXG4gICAgICAgICAgICBpZiAoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xJbml0ID09PSB1bmRlZmluZWQgKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBfZ2wuZGVsZXRlVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyByZW1vdmUgYWxsIHdlYmdsIHByb3BlcnRpZXNcclxuICAgICAgICBwcm9wZXJ0aWVzLmRlbGV0ZSggdGV4dHVyZSApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkZWFsbG9jYXRlUmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKSB7XHJcblxyXG4gICAgICAgIHZhciByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApO1xyXG4gICAgICAgIHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApO1xyXG5cclxuICAgICAgICBpZiAoICEgcmVuZGVyVGFyZ2V0IHx8IHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlID09PSB1bmRlZmluZWQgKSByZXR1cm47XHJcblxyXG4gICAgICAgIF9nbC5kZWxldGVUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xyXG5cclxuICAgICAgICBpZiAoIHJlbmRlclRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgX2dsLmRlbGV0ZUZyYW1lYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdICk7XHJcbiAgICAgICAgICAgICAgICBfZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXJbIGkgXSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgX2dsLmRlbGV0ZUZyYW1lYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciApO1xyXG4gICAgICAgICAgICBfZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXIgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcm9wZXJ0aWVzLmRlbGV0ZSggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKTtcclxuICAgICAgICBwcm9wZXJ0aWVzLmRlbGV0ZSggcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRlYWxsb2NhdGVNYXRlcmlhbCggbWF0ZXJpYWwgKSB7XHJcblxyXG4gICAgICAgIHJlbGVhc2VNYXRlcmlhbFByb2dyYW1SZWZlcmVuY2UoIG1hdGVyaWFsICk7XHJcblxyXG4gICAgICAgIHByb3BlcnRpZXMuZGVsZXRlKCBtYXRlcmlhbCApO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gcmVsZWFzZU1hdGVyaWFsUHJvZ3JhbVJlZmVyZW5jZSggbWF0ZXJpYWwgKSB7XHJcblxyXG4gICAgICAgIHZhciBwcm9ncmFtSW5mbyA9IHByb3BlcnRpZXMuZ2V0KCBtYXRlcmlhbCApLnByb2dyYW07XHJcblxyXG4gICAgICAgIG1hdGVyaWFsLnByb2dyYW0gPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIGlmICggcHJvZ3JhbUluZm8gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIHByb2dyYW1DYWNoZS5yZWxlYXNlUHJvZ3JhbSggcHJvZ3JhbUluZm8gKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBCdWZmZXIgcmVuZGVyaW5nXHJcblxyXG4gICAgdGhpcy5yZW5kZXJCdWZmZXJJbW1lZGlhdGUgPSBmdW5jdGlvbiAoIG9iamVjdCwgcHJvZ3JhbSwgbWF0ZXJpYWwgKSB7XHJcblxyXG4gICAgICAgIHN0YXRlLmluaXRBdHRyaWJ1dGVzKCk7XHJcblxyXG4gICAgICAgIHZhciBidWZmZXJzID0gcHJvcGVydGllcy5nZXQoIG9iamVjdCApO1xyXG5cclxuICAgICAgICBpZiAoIG9iamVjdC5oYXNQb3NpdGlvbnMgJiYgISBidWZmZXJzLnBvc2l0aW9uICkgYnVmZmVycy5wb3NpdGlvbiA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgICAgICBpZiAoIG9iamVjdC5oYXNOb3JtYWxzICYmICEgYnVmZmVycy5ub3JtYWwgKSBidWZmZXJzLm5vcm1hbCA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgICAgICBpZiAoIG9iamVjdC5oYXNVdnMgJiYgISBidWZmZXJzLnV2ICkgYnVmZmVycy51diA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgICAgICBpZiAoIG9iamVjdC5oYXNDb2xvcnMgJiYgISBidWZmZXJzLmNvbG9yICkgYnVmZmVycy5jb2xvciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHJcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBwcm9ncmFtLmdldEF0dHJpYnV0ZXMoKTtcclxuXHJcbiAgICAgICAgaWYgKCBvYmplY3QuaGFzUG9zaXRpb25zICkge1xyXG5cclxuICAgICAgICAgICAgX2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcnMucG9zaXRpb24gKTtcclxuICAgICAgICAgICAgX2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5wb3NpdGlvbkFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XHJcblxyXG4gICAgICAgICAgICBzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMucG9zaXRpb24gKTtcclxuICAgICAgICAgICAgX2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMucG9zaXRpb24sIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIG9iamVjdC5oYXNOb3JtYWxzICkge1xyXG5cclxuICAgICAgICAgICAgX2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcnMubm9ybWFsICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG1hdGVyaWFsLnR5cGUgIT09ICdNZXNoUGhvbmdNYXRlcmlhbCcgJiYgbWF0ZXJpYWwuc2hhZGluZyA9PT0gVEhSRUUuRmxhdFNoYWRpbmcgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gb2JqZWN0LmNvdW50ICogMzsgaSA8IGw7IGkgKz0gOSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFycmF5ID0gb2JqZWN0Lm5vcm1hbEFycmF5O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbnggPSAoIGFycmF5WyBpICsgMCBdICsgYXJyYXlbIGkgKyAzIF0gKyBhcnJheVsgaSArIDYgXSApIC8gMztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbnkgPSAoIGFycmF5WyBpICsgMSBdICsgYXJyYXlbIGkgKyA0IF0gKyBhcnJheVsgaSArIDcgXSApIC8gMztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbnogPSAoIGFycmF5WyBpICsgMiBdICsgYXJyYXlbIGkgKyA1IF0gKyBhcnJheVsgaSArIDggXSApIC8gMztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbIGkgKyAwIF0gPSBueDtcclxuICAgICAgICAgICAgICAgICAgICBhcnJheVsgaSArIDEgXSA9IG55O1xyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5WyBpICsgMiBdID0gbno7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5WyBpICsgMyBdID0gbng7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbIGkgKyA0IF0gPSBueTtcclxuICAgICAgICAgICAgICAgICAgICBhcnJheVsgaSArIDUgXSA9IG56O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBhcnJheVsgaSArIDYgXSA9IG54O1xyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5WyBpICsgNyBdID0gbnk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbIGkgKyA4IF0gPSBuejtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0Lm5vcm1hbEFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XHJcblxyXG4gICAgICAgICAgICBzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMubm9ybWFsICk7XHJcblxyXG4gICAgICAgICAgICBfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5ub3JtYWwsIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIG9iamVjdC5oYXNVdnMgJiYgbWF0ZXJpYWwubWFwICkge1xyXG5cclxuICAgICAgICAgICAgX2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcnMudXYgKTtcclxuICAgICAgICAgICAgX2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC51dkFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XHJcblxyXG4gICAgICAgICAgICBzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMudXYgKTtcclxuXHJcbiAgICAgICAgICAgIF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnV2LCAyLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBvYmplY3QuaGFzQ29sb3JzICYmIG1hdGVyaWFsLnZlcnRleENvbG9ycyAhPT0gVEhSRUUuTm9Db2xvcnMgKSB7XHJcblxyXG4gICAgICAgICAgICBfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgYnVmZmVycy5jb2xvciApO1xyXG4gICAgICAgICAgICBfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0LmNvbG9yQXJyYXksIF9nbC5EWU5BTUlDX0RSQVcgKTtcclxuXHJcbiAgICAgICAgICAgIHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5jb2xvciApO1xyXG5cclxuICAgICAgICAgICAgX2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMuY29sb3IsIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF0ZS5kaXNhYmxlVW51c2VkQXR0cmlidXRlcygpO1xyXG5cclxuICAgICAgICBfZ2wuZHJhd0FycmF5cyggX2dsLlRSSUFOR0xFUywgMCwgb2JqZWN0LmNvdW50ICk7XHJcblxyXG4gICAgICAgIG9iamVjdC5jb3VudCA9IDA7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnJlbmRlckJ1ZmZlckRpcmVjdCA9IGZ1bmN0aW9uICggY2FtZXJhLCBsaWdodHMsIGZvZywgZ2VvbWV0cnksIG1hdGVyaWFsLCBvYmplY3QsIGdyb3VwICkge1xyXG5cclxuICAgICAgICBzZXRNYXRlcmlhbCggbWF0ZXJpYWwgKTtcclxuXHJcbiAgICAgICAgdmFyIHByb2dyYW0gPSBzZXRQcm9ncmFtKCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBtYXRlcmlhbCwgb2JqZWN0ICk7XHJcblxyXG4gICAgICAgIHZhciB1cGRhdGVCdWZmZXJzID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGdlb21ldHJ5UHJvZ3JhbSA9IGdlb21ldHJ5LmlkICsgJ18nICsgcHJvZ3JhbS5pZCArICdfJyArIG1hdGVyaWFsLndpcmVmcmFtZTtcclxuXHJcbiAgICAgICAgaWYgKCBnZW9tZXRyeVByb2dyYW0gIT09IF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtICkge1xyXG5cclxuICAgICAgICAgICAgX2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSBnZW9tZXRyeVByb2dyYW07XHJcbiAgICAgICAgICAgIHVwZGF0ZUJ1ZmZlcnMgPSB0cnVlO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIG1vcnBoIHRhcmdldHNcclxuXHJcbiAgICAgICAgdmFyIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyA9IG9iamVjdC5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XHJcblxyXG4gICAgICAgIGlmICggbW9ycGhUYXJnZXRJbmZsdWVuY2VzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYWN0aXZlSW5mbHVlbmNlcyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gbW9ycGhUYXJnZXRJbmZsdWVuY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGluZmx1ZW5jZSA9IG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdO1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlSW5mbHVlbmNlcy5wdXNoKCBbIGluZmx1ZW5jZSwgaSBdICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBhY3RpdmVJbmZsdWVuY2VzLnNvcnQoIG51bWVyaWNhbFNvcnQgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggYWN0aXZlSW5mbHVlbmNlcy5sZW5ndGggPiA4ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGFjdGl2ZUluZmx1ZW5jZXMubGVuZ3RoID0gODtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBtb3JwaEF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXM7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBhY3RpdmVJbmZsdWVuY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGluZmx1ZW5jZSA9IGFjdGl2ZUluZmx1ZW5jZXNbIGkgXTtcclxuICAgICAgICAgICAgICAgIG1vcnBoSW5mbHVlbmNlc1sgaSBdID0gaW5mbHVlbmNlWyAwIF07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBpbmZsdWVuY2VbIDAgXSAhPT0gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gaW5mbHVlbmNlWyAxIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggbWF0ZXJpYWwubW9ycGhUYXJnZXRzID09PSB0cnVlICYmIG1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiApIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ21vcnBoVGFyZ2V0JyArIGksIG1vcnBoQXR0cmlidXRlcy5wb3NpdGlvblsgaW5kZXggXSApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggbWF0ZXJpYWwubW9ycGhOb3JtYWxzID09PSB0cnVlICYmIG1vcnBoQXR0cmlidXRlcy5ub3JtYWwgKSBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdtb3JwaE5vcm1hbCcgKyBpLCBtb3JwaEF0dHJpYnV0ZXMubm9ybWFsWyBpbmRleCBdICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRlcmlhbC5tb3JwaFRhcmdldHMgPT09IHRydWUgKSBnZW9tZXRyeS5yZW1vdmVBdHRyaWJ1dGUoICdtb3JwaFRhcmdldCcgKyBpICk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRlcmlhbC5tb3JwaE5vcm1hbHMgPT09IHRydWUgKSBnZW9tZXRyeS5yZW1vdmVBdHRyaWJ1dGUoICdtb3JwaE5vcm1hbCcgKyBpICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHVuaWZvcm1zID0gcHJvZ3JhbS5nZXRVbmlmb3JtcygpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCB1bmlmb3Jtcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMgIT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0xZnYoIHVuaWZvcm1zLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcywgbW9ycGhJbmZsdWVuY2VzICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB1cGRhdGVCdWZmZXJzID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL1xyXG5cclxuICAgICAgICB2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcclxuICAgICAgICB2YXIgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cclxuICAgICAgICBpZiAoIG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZSApIHtcclxuXHJcbiAgICAgICAgICAgIGluZGV4ID0gb2JqZWN0cy5nZXRXaXJlZnJhbWVBdHRyaWJ1dGUoIGdlb21ldHJ5ICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHJlbmRlcmVyO1xyXG5cclxuICAgICAgICBpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgcmVuZGVyZXIgPSBpbmRleGVkQnVmZmVyUmVuZGVyZXI7XHJcbiAgICAgICAgICAgIHJlbmRlcmVyLnNldEluZGV4KCBpbmRleCApO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgcmVuZGVyZXIgPSBidWZmZXJSZW5kZXJlcjtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSB7XHJcblxyXG4gICAgICAgICAgICBzZXR1cFZlcnRleEF0dHJpYnV0ZXMoIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBpbmRleCAhPT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBfZ2wuYmluZEJ1ZmZlciggX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBvYmplY3RzLmdldEF0dHJpYnV0ZUJ1ZmZlciggaW5kZXggKSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vXHJcblxyXG4gICAgICAgIHZhciBkYXRhU3RhcnQgPSAwO1xyXG4gICAgICAgIHZhciBkYXRhQ291bnQgPSBJbmZpbml0eTtcclxuXHJcbiAgICAgICAgaWYgKCBpbmRleCAhPT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgIGRhdGFDb3VudCA9IGluZGV4LmNvdW50XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBkYXRhQ291bnQgPSBwb3NpdGlvbi5jb3VudDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcmFuZ2VTdGFydCA9IGdlb21ldHJ5LmRyYXdSYW5nZS5zdGFydDtcclxuICAgICAgICB2YXIgcmFuZ2VDb3VudCA9IGdlb21ldHJ5LmRyYXdSYW5nZS5jb3VudDtcclxuXHJcbiAgICAgICAgdmFyIGdyb3VwU3RhcnQgPSBncm91cCAhPT0gbnVsbCA/IGdyb3VwLnN0YXJ0IDogMDtcclxuICAgICAgICB2YXIgZ3JvdXBDb3VudCA9IGdyb3VwICE9PSBudWxsID8gZ3JvdXAuY291bnQgOiBJbmZpbml0eTtcclxuXHJcbiAgICAgICAgdmFyIGRyYXdTdGFydCA9IE1hdGgubWF4KCBkYXRhU3RhcnQsIHJhbmdlU3RhcnQsIGdyb3VwU3RhcnQgKTtcclxuICAgICAgICB2YXIgZHJhd0VuZCA9IE1hdGgubWluKCBkYXRhU3RhcnQgKyBkYXRhQ291bnQsIHJhbmdlU3RhcnQgKyByYW5nZUNvdW50LCBncm91cFN0YXJ0ICsgZ3JvdXBDb3VudCApIC0gMTtcclxuXHJcbiAgICAgICAgdmFyIGRyYXdDb3VudCA9IE1hdGgubWF4KCAwLCBkcmF3RW5kIC0gZHJhd1N0YXJ0ICsgMSApO1xyXG5cclxuICAgICAgICAvL1xyXG5cclxuICAgICAgICBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5zZXRMaW5lV2lkdGgoIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCAqIHBpeGVsUmF0aW8gKTtcclxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnNldE1vZGUoIF9nbC5MSU5FUyApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZW5kZXJlci5zZXRNb2RlKCBfZ2wuVFJJQU5HTEVTICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgJiYgZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPiAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlckluc3RhbmNlcyggZ2VvbWV0cnkgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyKCBkcmF3U3RhcnQsIGRyYXdDb3VudCApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGxpbmVXaWR0aCA9IG1hdGVyaWFsLmxpbmV3aWR0aDtcclxuXHJcbiAgICAgICAgICAgIGlmICggbGluZVdpZHRoID09PSB1bmRlZmluZWQgKSBsaW5lV2lkdGggPSAxOyAvLyBOb3QgdXNpbmcgTGluZSpNYXRlcmlhbFxyXG5cclxuICAgICAgICAgICAgc3RhdGUuc2V0TGluZVdpZHRoKCBsaW5lV2lkdGggKiBwaXhlbFJhdGlvICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmVTZWdtZW50cyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZW5kZXJlci5zZXRNb2RlKCBfZ2wuTElORVMgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuc2V0TW9kZSggX2dsLkxJTkVfU1RSSVAgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlciggZHJhd1N0YXJ0LCBkcmF3Q291bnQgKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRzICkge1xyXG5cclxuICAgICAgICAgICAgcmVuZGVyZXIuc2V0TW9kZSggX2dsLlBPSU5UUyApO1xyXG4gICAgICAgICAgICByZW5kZXJlci5yZW5kZXIoIGRyYXdTdGFydCwgZHJhd0NvdW50ICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHNldHVwVmVydGV4QXR0cmlidXRlcyggbWF0ZXJpYWwsIHByb2dyYW0sIGdlb21ldHJ5LCBzdGFydEluZGV4ICkge1xyXG5cclxuICAgICAgICB2YXIgZXh0ZW5zaW9uO1xyXG5cclxuICAgICAgICBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgKSB7XHJcblxyXG4gICAgICAgICAgICBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5zZXR1cFZlcnRleEF0dHJpYnV0ZXM6IHVzaW5nIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IGJ1dCBoYXJkd2FyZSBkb2VzIG5vdCBzdXBwb3J0IGV4dGVuc2lvbiBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzLicgKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIHN0YXJ0SW5kZXggPT09IHVuZGVmaW5lZCApIHN0YXJ0SW5kZXggPSAwO1xyXG5cclxuICAgICAgICBzdGF0ZS5pbml0QXR0cmlidXRlcygpO1xyXG5cclxuICAgICAgICB2YXIgZ2VvbWV0cnlBdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcclxuXHJcbiAgICAgICAgdmFyIHByb2dyYW1BdHRyaWJ1dGVzID0gcHJvZ3JhbS5nZXRBdHRyaWJ1dGVzKCk7XHJcblxyXG4gICAgICAgIHZhciBtYXRlcmlhbERlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMgPSBtYXRlcmlhbC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgbmFtZSBpbiBwcm9ncmFtQXR0cmlidXRlcyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBwcm9ncmFtQXR0cmlidXRlID0gcHJvZ3JhbUF0dHJpYnV0ZXNbIG5hbWUgXTtcclxuXHJcbiAgICAgICAgICAgIGlmICggcHJvZ3JhbUF0dHJpYnV0ZSA+PSAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBnZW9tZXRyeUF0dHJpYnV0ZSA9IGdlb21ldHJ5QXR0cmlidXRlc1sgbmFtZSBdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpemUgPSBnZW9tZXRyeUF0dHJpYnV0ZS5pdGVtU2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gb2JqZWN0cy5nZXRBdHRyaWJ1dGVCdWZmZXIoIGdlb21ldHJ5QXR0cmlidXRlICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gZ2VvbWV0cnlBdHRyaWJ1dGUuZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0cmlkZSA9IGRhdGEuc3RyaWRlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gZ2VvbWV0cnlBdHRyaWJ1dGUub2Zmc2V0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBkYXRhIGluc3RhbmNlb2YgVEhSRUUuSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvciggcHJvZ3JhbUF0dHJpYnV0ZSwgZGF0YS5tZXNoUGVyQXR0cmlidXRlLCBleHRlbnNpb24gKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID0gZGF0YS5tZXNoUGVyQXR0cmlidXRlICogZGF0YS5jb3VudDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggcHJvZ3JhbUF0dHJpYnV0ZSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgX2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlciApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZ2wudmVydGV4QXR0cmliUG9pbnRlciggcHJvZ3JhbUF0dHJpYnV0ZSwgc2l6ZSwgX2dsLkZMT0FULCBmYWxzZSwgc3RyaWRlICogZGF0YS5hcnJheS5CWVRFU19QRVJfRUxFTUVOVCwgKCBzdGFydEluZGV4ICogc3RyaWRlICsgb2Zmc2V0ICkgKiBkYXRhLmFycmF5LkJZVEVTX1BFUl9FTEVNRU5UICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGdlb21ldHJ5QXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IoIHByb2dyYW1BdHRyaWJ1dGUsIGdlb21ldHJ5QXR0cmlidXRlLm1lc2hQZXJBdHRyaWJ1dGUsIGV4dGVuc2lvbiApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPSBnZW9tZXRyeUF0dHJpYnV0ZS5tZXNoUGVyQXR0cmlidXRlICogZ2VvbWV0cnlBdHRyaWJ1dGUuY291bnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIHByb2dyYW1BdHRyaWJ1dGUgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIHByb2dyYW1BdHRyaWJ1dGUsIHNpemUsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIHN0YXJ0SW5kZXggKiBzaXplICogNCApOyAvLyA0IGJ5dGVzIHBlciBGbG9hdDMyXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBtYXRlcmlhbERlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gbWF0ZXJpYWxEZWZhdWx0QXR0cmlidXRlVmFsdWVzWyBuYW1lIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoIHZhbHVlLmxlbmd0aCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2dsLnZlcnRleEF0dHJpYjJmdiggcHJvZ3JhbUF0dHJpYnV0ZSwgdmFsdWUgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2dsLnZlcnRleEF0dHJpYjNmdiggcHJvZ3JhbUF0dHJpYnV0ZSwgdmFsdWUgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2dsLnZlcnRleEF0dHJpYjRmdiggcHJvZ3JhbUF0dHJpYnV0ZSwgdmFsdWUgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9nbC52ZXJ0ZXhBdHRyaWIxZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhdGUuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gU29ydGluZ1xyXG5cclxuICAgIGZ1bmN0aW9uIG51bWVyaWNhbFNvcnQgKCBhLCBiICkge1xyXG5cclxuICAgICAgICByZXR1cm4gYlsgMCBdIC0gYVsgMCBdO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwYWludGVyU29ydFN0YWJsZSAoIGEsIGIgKSB7XHJcblxyXG4gICAgICAgIGlmICggYS5vYmplY3QucmVuZGVyT3JkZXIgIT09IGIub2JqZWN0LnJlbmRlck9yZGVyICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGEub2JqZWN0LnJlbmRlck9yZGVyIC0gYi5vYmplY3QucmVuZGVyT3JkZXI7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIGEubWF0ZXJpYWwuaWQgIT09IGIubWF0ZXJpYWwuaWQgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYS5tYXRlcmlhbC5pZCAtIGIubWF0ZXJpYWwuaWQ7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIGEueiAhPT0gYi56ICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGEueiAtIGIuejtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBhLmlkIC0gYi5pZDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZXZlcnNlUGFpbnRlclNvcnRTdGFibGUgKCBhLCBiICkge1xyXG5cclxuICAgICAgICBpZiAoIGEub2JqZWN0LnJlbmRlck9yZGVyICE9PSBiLm9iamVjdC5yZW5kZXJPcmRlciApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBhLm9iamVjdC5yZW5kZXJPcmRlciAtIGIub2JqZWN0LnJlbmRlck9yZGVyO1xyXG5cclxuICAgICAgICB9IGlmICggYS56ICE9PSBiLnogKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYi56IC0gYS56O1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGEuaWQgLSBiLmlkO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbmRlcmluZ1xyXG5cclxuICAgIHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhLCByZW5kZXJUYXJnZXQsIGZvcmNlQ2xlYXIgKSB7XHJcblxyXG4gICAgICAgIGlmICggY2FtZXJhIGluc3RhbmNlb2YgVEhSRUUuQ2FtZXJhID09PSBmYWxzZSApIHtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlbmRlcjogY2FtZXJhIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5DYW1lcmEuJyApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGZvZyA9IHNjZW5lLmZvZztcclxuXHJcbiAgICAgICAgLy8gcmVzZXQgY2FjaGluZyBmb3IgdGhpcyBmcmFtZVxyXG5cclxuICAgICAgICBfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9ICcnO1xyXG4gICAgICAgIF9jdXJyZW50TWF0ZXJpYWxJZCA9IC0gMTtcclxuICAgICAgICBfY3VycmVudENhbWVyYSA9IG51bGw7XHJcbiAgICAgICAgX2xpZ2h0c05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxuICAgICAgICAvLyB1cGRhdGUgc2NlbmUgZ3JhcGhcclxuXHJcbiAgICAgICAgaWYgKCBzY2VuZS5hdXRvVXBkYXRlID09PSB0cnVlICkgc2NlbmUudXBkYXRlTWF0cml4V29ybGQoKTtcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIGNhbWVyYSBtYXRyaWNlcyBhbmQgZnJ1c3R1bVxyXG5cclxuICAgICAgICBpZiAoIGNhbWVyYS5wYXJlbnQgPT09IG51bGwgKSBjYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcclxuXHJcbiAgICAgICAgY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCBjYW1lcmEubWF0cml4V29ybGQgKTtcclxuXHJcbiAgICAgICAgX3Byb2pTY3JlZW5NYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcclxuICAgICAgICBfZnJ1c3R1bS5zZXRGcm9tTWF0cml4KCBfcHJvalNjcmVlbk1hdHJpeCApO1xyXG5cclxuICAgICAgICBsaWdodHMubGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgb3BhcXVlT2JqZWN0c0xhc3RJbmRleCA9IC0gMTtcclxuICAgICAgICB0cmFuc3BhcmVudE9iamVjdHNMYXN0SW5kZXggPSAtIDE7XHJcblxyXG4gICAgICAgIHNwcml0ZXMubGVuZ3RoID0gMDtcclxuICAgICAgICBsZW5zRmxhcmVzLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgIHByb2plY3RPYmplY3QoIHNjZW5lLCBjYW1lcmEgKTtcclxuXHJcbiAgICAgICAgb3BhcXVlT2JqZWN0cy5sZW5ndGggPSBvcGFxdWVPYmplY3RzTGFzdEluZGV4ICsgMTtcclxuICAgICAgICB0cmFuc3BhcmVudE9iamVjdHMubGVuZ3RoID0gdHJhbnNwYXJlbnRPYmplY3RzTGFzdEluZGV4ICsgMTtcclxuXHJcbiAgICAgICAgaWYgKCBfdGhpcy5zb3J0T2JqZWN0cyA9PT0gdHJ1ZSApIHtcclxuXHJcbiAgICAgICAgICAgIG9wYXF1ZU9iamVjdHMuc29ydCggcGFpbnRlclNvcnRTdGFibGUgKTtcclxuICAgICAgICAgICAgdHJhbnNwYXJlbnRPYmplY3RzLnNvcnQoIHJldmVyc2VQYWludGVyU29ydFN0YWJsZSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vXHJcblxyXG4gICAgICAgIHNoYWRvd01hcC5yZW5kZXIoIHNjZW5lICk7XHJcblxyXG4gICAgICAgIC8vXHJcblxyXG4gICAgICAgIF9pbmZvUmVuZGVyLmNhbGxzID0gMDtcclxuICAgICAgICBfaW5mb1JlbmRlci52ZXJ0aWNlcyA9IDA7XHJcbiAgICAgICAgX2luZm9SZW5kZXIuZmFjZXMgPSAwO1xyXG4gICAgICAgIF9pbmZvUmVuZGVyLnBvaW50cyA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0UmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLmF1dG9DbGVhciB8fCBmb3JjZUNsZWFyICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jbGVhciggdGhpcy5hdXRvQ2xlYXJDb2xvciwgdGhpcy5hdXRvQ2xlYXJEZXB0aCwgdGhpcy5hdXRvQ2xlYXJTdGVuY2lsICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9cclxuXHJcbiAgICAgICAgaWYgKCBzY2VuZS5vdmVycmlkZU1hdGVyaWFsICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIG92ZXJyaWRlTWF0ZXJpYWwgPSBzY2VuZS5vdmVycmlkZU1hdGVyaWFsO1xyXG5cclxuICAgICAgICAgICAgcmVuZGVyT2JqZWN0cyggb3BhcXVlT2JqZWN0cywgY2FtZXJhLCBsaWdodHMsIGZvZywgb3ZlcnJpZGVNYXRlcmlhbCApO1xyXG4gICAgICAgICAgICByZW5kZXJPYmplY3RzKCB0cmFuc3BhcmVudE9iamVjdHMsIGNhbWVyYSwgbGlnaHRzLCBmb2csIG92ZXJyaWRlTWF0ZXJpYWwgKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIC8vIG9wYXF1ZSBwYXNzIChmcm9udC10by1iYWNrIG9yZGVyKVxyXG5cclxuICAgICAgICAgICAgc3RhdGUuc2V0QmxlbmRpbmcoIFRIUkVFLk5vQmxlbmRpbmcgKTtcclxuICAgICAgICAgICAgcmVuZGVyT2JqZWN0cyggb3BhcXVlT2JqZWN0cywgY2FtZXJhLCBsaWdodHMsIGZvZyApO1xyXG5cclxuICAgICAgICAgICAgLy8gdHJhbnNwYXJlbnQgcGFzcyAoYmFjay10by1mcm9udCBvcmRlcilcclxuXHJcbiAgICAgICAgICAgIHJlbmRlck9iamVjdHMoIHRyYW5zcGFyZW50T2JqZWN0cywgY2FtZXJhLCBsaWdodHMsIGZvZyApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGN1c3RvbSByZW5kZXIgcGx1Z2lucyAocG9zdCBwYXNzKVxyXG5cclxuICAgICAgICBzcHJpdGVQbHVnaW4ucmVuZGVyKCBzY2VuZSwgY2FtZXJhICk7XHJcbiAgICAgICAgbGVuc0ZsYXJlUGx1Z2luLnJlbmRlciggc2NlbmUsIGNhbWVyYSwgX2N1cnJlbnRXaWR0aCwgX2N1cnJlbnRIZWlnaHQgKTtcclxuXHJcbiAgICAgICAgLy8gR2VuZXJhdGUgbWlwbWFwIGlmIHdlJ3JlIHVzaW5nIGFueSBraW5kIG9mIG1pcG1hcCBmaWx0ZXJpbmdcclxuXHJcbiAgICAgICAgaWYgKCByZW5kZXJUYXJnZXQgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgdGV4dHVyZSA9IHJlbmRlclRhcmdldC50ZXh0dXJlO1xyXG4gICAgICAgICAgICB2YXIgaXNUYXJnZXRQb3dlck9mVHdvID0gaXNQb3dlck9mVHdvKCByZW5kZXJUYXJnZXQgKTtcclxuICAgICAgICAgICAgaWYgKCB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyAmJiBpc1RhcmdldFBvd2VyT2ZUd28gJiYgdGV4dHVyZS5taW5GaWx0ZXIgIT09IFRIUkVFLk5lYXJlc3RGaWx0ZXIgJiYgdGV4dHVyZS5taW5GaWx0ZXIgIT09IFRIUkVFLkxpbmVhckZpbHRlciApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB1cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXAoIHJlbmRlclRhcmdldCApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEVuc3VyZSBkZXB0aCBidWZmZXIgd3JpdGluZyBpcyBlbmFibGVkIHNvIGl0IGNhbiBiZSBjbGVhcmVkIG9uIG5leHQgcmVuZGVyXHJcblxyXG4gICAgICAgIHN0YXRlLnNldERlcHRoVGVzdCggdHJ1ZSApO1xyXG4gICAgICAgIHN0YXRlLnNldERlcHRoV3JpdGUoIHRydWUgKTtcclxuICAgICAgICBzdGF0ZS5zZXRDb2xvcldyaXRlKCB0cnVlICk7XHJcblxyXG4gICAgICAgIC8vIF9nbC5maW5pc2goKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHB1c2hSZW5kZXJJdGVtKCBvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgeiwgZ3JvdXAgKSB7XHJcblxyXG4gICAgICAgIHZhciBhcnJheSwgaW5kZXg7XHJcblxyXG4gICAgICAgIC8vIGFsbG9jYXRlIHRoZSBuZXh0IHBvc2l0aW9uIGluIHRoZSBhcHByb3ByaWF0ZSBhcnJheVxyXG5cclxuICAgICAgICBpZiAoIG1hdGVyaWFsLnRyYW5zcGFyZW50ICkge1xyXG5cclxuICAgICAgICAgICAgYXJyYXkgPSB0cmFuc3BhcmVudE9iamVjdHM7XHJcbiAgICAgICAgICAgIGluZGV4ID0gKysgdHJhbnNwYXJlbnRPYmplY3RzTGFzdEluZGV4O1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgYXJyYXkgPSBvcGFxdWVPYmplY3RzO1xyXG4gICAgICAgICAgICBpbmRleCA9ICsrIG9wYXF1ZU9iamVjdHNMYXN0SW5kZXg7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcmVjeWNsZSBleGlzdGluZyByZW5kZXIgaXRlbSBvciBncm93IHRoZSBhcnJheVxyXG5cclxuICAgICAgICB2YXIgcmVuZGVySXRlbSA9IGFycmF5WyBpbmRleCBdO1xyXG5cclxuICAgICAgICBpZiAoIHJlbmRlckl0ZW0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIHJlbmRlckl0ZW0uaWQgPSBvYmplY3QuaWQ7XHJcbiAgICAgICAgICAgIHJlbmRlckl0ZW0ub2JqZWN0ID0gb2JqZWN0O1xyXG4gICAgICAgICAgICByZW5kZXJJdGVtLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XHJcbiAgICAgICAgICAgIHJlbmRlckl0ZW0ubWF0ZXJpYWwgPSBtYXRlcmlhbDtcclxuICAgICAgICAgICAgcmVuZGVySXRlbS56ID0gX3ZlY3RvcjMuejtcclxuICAgICAgICAgICAgcmVuZGVySXRlbS5ncm91cCA9IGdyb3VwO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgcmVuZGVySXRlbSA9IHtcclxuICAgICAgICAgICAgICAgIGlkOiBvYmplY3QuaWQsXHJcbiAgICAgICAgICAgICAgICBvYmplY3Q6IG9iamVjdCxcclxuICAgICAgICAgICAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeSxcclxuICAgICAgICAgICAgICAgIG1hdGVyaWFsOiBtYXRlcmlhbCxcclxuICAgICAgICAgICAgICAgIHo6IF92ZWN0b3IzLnosXHJcbiAgICAgICAgICAgICAgICBncm91cDogZ3JvdXBcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIGFzc2VydCggaW5kZXggPT09IGFycmF5Lmxlbmd0aCApO1xyXG4gICAgICAgICAgICBhcnJheS5wdXNoKCByZW5kZXJJdGVtICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvamVjdE9iamVjdCggb2JqZWN0LCBjYW1lcmEgKSB7XHJcblxyXG4gICAgICAgIGlmICggb2JqZWN0LnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cclxuICAgICAgICBpZiAoICggb2JqZWN0LmNoYW5uZWxzLm1hc2sgJiBjYW1lcmEuY2hhbm5lbHMubWFzayApICE9PSAwICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaWdodCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBsaWdodHMucHVzaCggb2JqZWN0ICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5TcHJpdGUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgc3ByaXRlcy5wdXNoKCBvYmplY3QgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxlbnNGbGFyZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBsZW5zRmxhcmVzLnB1c2goIG9iamVjdCApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggX3RoaXMuc29ydE9iamVjdHMgPT09IHRydWUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3ZlY3RvcjMuYXBwbHlQcm9qZWN0aW9uKCBfcHJvalNjcmVlbk1hdHJpeCApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBwdXNoUmVuZGVySXRlbSggb2JqZWN0LCBudWxsLCBvYmplY3QubWF0ZXJpYWwsIF92ZWN0b3IzLnosIG51bGwgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggfHwgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZSB8fCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludHMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Ta2lubmVkTWVzaCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnNrZWxldG9uLnVwZGF0ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIG9iamVjdC5mcnVzdHVtQ3VsbGVkID09PSBmYWxzZSB8fCBfZnJ1c3R1bS5pbnRlcnNlY3RzT2JqZWN0KCBvYmplY3QgKSA9PT0gdHJ1ZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGVyaWFsLnZpc2libGUgPT09IHRydWUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIF90aGlzLnNvcnRPYmplY3RzID09PSB0cnVlICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdmVjdG9yMy5hcHBseVByb2plY3Rpb24oIF9wcm9qU2NyZWVuTWF0cml4ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSBvYmplY3RzLnVwZGF0ZSggb2JqZWN0ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaEZhY2VNYXRlcmlhbCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGVyaWFscyA9IG1hdGVyaWFsLm1hdGVyaWFscztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBncm91cHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gZ3JvdXBzWyBpIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbHNbIGdyb3VwLm1hdGVyaWFsSW5kZXggXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBncm91cE1hdGVyaWFsLnZpc2libGUgPT09IHRydWUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoUmVuZGVySXRlbSggb2JqZWN0LCBnZW9tZXRyeSwgZ3JvdXBNYXRlcmlhbCwgX3ZlY3RvcjMueiwgZ3JvdXAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaFJlbmRlckl0ZW0oIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBfdmVjdG9yMy56LCBudWxsICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gb2JqZWN0LmNoaWxkcmVuO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgcHJvamVjdE9iamVjdCggY2hpbGRyZW5bIGkgXSwgY2FtZXJhICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVuZGVyT2JqZWN0cyggcmVuZGVyTGlzdCwgY2FtZXJhLCBsaWdodHMsIGZvZywgb3ZlcnJpZGVNYXRlcmlhbCApIHtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gcmVuZGVyTGlzdC5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlbmRlckl0ZW0gPSByZW5kZXJMaXN0WyBpIF07XHJcblxyXG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0gcmVuZGVySXRlbS5vYmplY3Q7XHJcbiAgICAgICAgICAgIHZhciBnZW9tZXRyeSA9IHJlbmRlckl0ZW0uZ2VvbWV0cnk7XHJcbiAgICAgICAgICAgIHZhciBtYXRlcmlhbCA9IG92ZXJyaWRlTWF0ZXJpYWwgPT09IHVuZGVmaW5lZCA/IHJlbmRlckl0ZW0ubWF0ZXJpYWwgOiBvdmVycmlkZU1hdGVyaWFsO1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSByZW5kZXJJdGVtLmdyb3VwO1xyXG5cclxuICAgICAgICAgICAgb2JqZWN0Lm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBvYmplY3QubWF0cml4V29ybGQgKTtcclxuICAgICAgICAgICAgb2JqZWN0Lm5vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIG9iamVjdC5tb2RlbFZpZXdNYXRyaXggKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHNldE1hdGVyaWFsKCBtYXRlcmlhbCApO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBwcm9ncmFtID0gc2V0UHJvZ3JhbSggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApO1xyXG5cclxuICAgICAgICAgICAgICAgIF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtID0gJyc7XHJcblxyXG4gICAgICAgICAgICAgICAgb2JqZWN0LnJlbmRlciggZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlckJ1ZmZlckltbWVkaWF0ZSggb2JqZWN0LCBwcm9ncmFtLCBtYXRlcmlhbCApO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgX3RoaXMucmVuZGVyQnVmZmVyRGlyZWN0KCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG9iamVjdCwgZ3JvdXAgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpbml0TWF0ZXJpYWwoIG1hdGVyaWFsLCBsaWdodHMsIGZvZywgb2JqZWN0ICkge1xyXG5cclxuICAgICAgICB2YXIgbWF0ZXJpYWxQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIG1hdGVyaWFsICk7XHJcblxyXG4gICAgICAgIHZhciBwYXJhbWV0ZXJzID0gcHJvZ3JhbUNhY2hlLmdldFBhcmFtZXRlcnMoIG1hdGVyaWFsLCBsaWdodHMsIGZvZywgb2JqZWN0ICk7XHJcbiAgICAgICAgdmFyIGNvZGUgPSBwcm9ncmFtQ2FjaGUuZ2V0UHJvZ3JhbUNvZGUoIG1hdGVyaWFsLCBwYXJhbWV0ZXJzICk7XHJcblxyXG4gICAgICAgIHZhciBwcm9ncmFtID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW07XHJcbiAgICAgICAgdmFyIHByb2dyYW1DaGFuZ2UgPSB0cnVlO1xyXG5cclxuICAgICAgICBpZiAoIHByb2dyYW0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIG5ldyBtYXRlcmlhbFxyXG4gICAgICAgICAgICBtYXRlcmlhbC5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uTWF0ZXJpYWxEaXNwb3NlICk7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIHByb2dyYW0uY29kZSAhPT0gY29kZSApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGNoYW5nZWQgZ2xzbCBvciBwYXJhbWV0ZXJzXHJcbiAgICAgICAgICAgIHJlbGVhc2VNYXRlcmlhbFByb2dyYW1SZWZlcmVuY2UoIG1hdGVyaWFsICk7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIHBhcmFtZXRlcnMuc2hhZGVySUQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIHNhbWUgZ2xzbCBhbmQgdW5pZm9ybSBsaXN0XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIC8vIG9ubHkgcmVidWlsZCB1bmlmb3JtIGxpc3RcclxuICAgICAgICAgICAgcHJvZ3JhbUNoYW5nZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggcHJvZ3JhbUNoYW5nZSApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggcGFyYW1ldGVycy5zaGFkZXJJRCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2hhZGVyID0gVEhSRUUuU2hhZGVyTGliWyBwYXJhbWV0ZXJzLnNoYWRlcklEIF07XHJcblxyXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWxQcm9wZXJ0aWVzLl9fd2ViZ2xTaGFkZXIgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbWF0ZXJpYWwudHlwZSxcclxuICAgICAgICAgICAgICAgICAgICB1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5jbG9uZSggc2hhZGVyLnVuaWZvcm1zICksXHJcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4U2hhZGVyOiBzaGFkZXIudmVydGV4U2hhZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyOiBzaGFkZXIuZnJhZ21lbnRTaGFkZXJcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIG1hdGVyaWFsUHJvcGVydGllcy5fX3dlYmdsU2hhZGVyID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG1hdGVyaWFsLnR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXM6IG1hdGVyaWFsLnVuaWZvcm1zLFxyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRleFNoYWRlcjogbWF0ZXJpYWwudmVydGV4U2hhZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyOiBtYXRlcmlhbC5mcmFnbWVudFNoYWRlclxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG1hdGVyaWFsLl9fd2ViZ2xTaGFkZXIgPSBtYXRlcmlhbFByb3BlcnRpZXMuX193ZWJnbFNoYWRlcjtcclxuXHJcbiAgICAgICAgICAgIHByb2dyYW0gPSBwcm9ncmFtQ2FjaGUuYWNxdWlyZVByb2dyYW0oIG1hdGVyaWFsLCBwYXJhbWV0ZXJzLCBjb2RlICk7XHJcblxyXG4gICAgICAgICAgICBtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbSA9IHByb2dyYW07XHJcbiAgICAgICAgICAgIG1hdGVyaWFsLnByb2dyYW0gPSBwcm9ncmFtO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gcHJvZ3JhbS5nZXRBdHRyaWJ1dGVzKCk7XHJcblxyXG4gICAgICAgIGlmICggbWF0ZXJpYWwubW9ycGhUYXJnZXRzICkge1xyXG5cclxuICAgICAgICAgICAgbWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzID0gMDtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IF90aGlzLm1heE1vcnBoVGFyZ2V0czsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGF0dHJpYnV0ZXNbICdtb3JwaFRhcmdldCcgKyBpIF0gPj0gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzICsrO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIG1hdGVyaWFsLm1vcnBoTm9ybWFscyApIHtcclxuXHJcbiAgICAgICAgICAgIG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoTm9ybWFscyA9IDA7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IF90aGlzLm1heE1vcnBoTm9ybWFsczsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGF0dHJpYnV0ZXNbICdtb3JwaE5vcm1hbCcgKyBpIF0gPj0gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhOb3JtYWxzICsrO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXNMaXN0ID0gW107XHJcblxyXG4gICAgICAgIHZhciB1bmlmb3JtTG9jYXRpb25zID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW0uZ2V0VW5pZm9ybXMoKTtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIHUgaW4gbWF0ZXJpYWxQcm9wZXJ0aWVzLl9fd2ViZ2xTaGFkZXIudW5pZm9ybXMgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbG9jYXRpb24gPSB1bmlmb3JtTG9jYXRpb25zWyB1IF07XHJcblxyXG4gICAgICAgICAgICBpZiAoIGxvY2F0aW9uICkge1xyXG5cclxuICAgICAgICAgICAgICAgIG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3Jtc0xpc3QucHVzaCggWyBtYXRlcmlhbFByb3BlcnRpZXMuX193ZWJnbFNoYWRlci51bmlmb3Jtc1sgdSBdLCBsb2NhdGlvbiBdICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2V0TWF0ZXJpYWwoIG1hdGVyaWFsICkge1xyXG5cclxuICAgICAgICBzZXRNYXRlcmlhbEZhY2VzKCBtYXRlcmlhbCApO1xyXG5cclxuICAgICAgICBpZiAoIG1hdGVyaWFsLnRyYW5zcGFyZW50ID09PSB0cnVlICkge1xyXG5cclxuICAgICAgICAgICAgc3RhdGUuc2V0QmxlbmRpbmcoIG1hdGVyaWFsLmJsZW5kaW5nLCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uLCBtYXRlcmlhbC5ibGVuZFNyYywgbWF0ZXJpYWwuYmxlbmREc3QsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb25BbHBoYSwgbWF0ZXJpYWwuYmxlbmRTcmNBbHBoYSwgbWF0ZXJpYWwuYmxlbmREc3RBbHBoYSApO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgc3RhdGUuc2V0QmxlbmRpbmcoIFRIUkVFLk5vQmxlbmRpbmcgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF0ZS5zZXREZXB0aEZ1bmMoIG1hdGVyaWFsLmRlcHRoRnVuYyApO1xyXG4gICAgICAgIHN0YXRlLnNldERlcHRoVGVzdCggbWF0ZXJpYWwuZGVwdGhUZXN0ICk7XHJcbiAgICAgICAgc3RhdGUuc2V0RGVwdGhXcml0ZSggbWF0ZXJpYWwuZGVwdGhXcml0ZSApO1xyXG4gICAgICAgIHN0YXRlLnNldENvbG9yV3JpdGUoIG1hdGVyaWFsLmNvbG9yV3JpdGUgKTtcclxuICAgICAgICBzdGF0ZS5zZXRQb2x5Z29uT2Zmc2V0KCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0LCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0RmFjdG9yLCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0VW5pdHMgKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2V0TWF0ZXJpYWxGYWNlcyggbWF0ZXJpYWwgKSB7XHJcblxyXG4gICAgICAgIG1hdGVyaWFsLnNpZGUgIT09IFRIUkVFLkRvdWJsZVNpZGUgPyBzdGF0ZS5lbmFibGUoIF9nbC5DVUxMX0ZBQ0UgKSA6IHN0YXRlLmRpc2FibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcclxuICAgICAgICBzdGF0ZS5zZXRGbGlwU2lkZWQoIG1hdGVyaWFsLnNpZGUgPT09IFRIUkVFLkJhY2tTaWRlICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldFByb2dyYW0oIGNhbWVyYSwgbGlnaHRzLCBmb2csIG1hdGVyaWFsLCBvYmplY3QgKSB7XHJcblxyXG4gICAgICAgIF91c2VkVGV4dHVyZVVuaXRzID0gMDtcclxuXHJcbiAgICAgICAgdmFyIG1hdGVyaWFsUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCBtYXRlcmlhbCApO1xyXG5cclxuICAgICAgICBpZiAoIG1hdGVyaWFsLm5lZWRzVXBkYXRlIHx8ICEgbWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW0gKSB7XHJcblxyXG4gICAgICAgICAgICBpbml0TWF0ZXJpYWwoIG1hdGVyaWFsLCBsaWdodHMsIGZvZywgb2JqZWN0ICk7XHJcbiAgICAgICAgICAgIG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHJlZnJlc2hQcm9ncmFtID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIHJlZnJlc2hNYXRlcmlhbCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciByZWZyZXNoTGlnaHRzID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHZhciBwcm9ncmFtID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW0sXHJcbiAgICAgICAgICAgIHBfdW5pZm9ybXMgPSBwcm9ncmFtLmdldFVuaWZvcm1zKCksXHJcbiAgICAgICAgICAgIG1fdW5pZm9ybXMgPSBtYXRlcmlhbFByb3BlcnRpZXMuX193ZWJnbFNoYWRlci51bmlmb3JtcztcclxuXHJcbiAgICAgICAgaWYgKCBwcm9ncmFtLmlkICE9PSBfY3VycmVudFByb2dyYW0gKSB7XHJcblxyXG4gICAgICAgICAgICBfZ2wudXNlUHJvZ3JhbSggcHJvZ3JhbS5wcm9ncmFtICk7XHJcbiAgICAgICAgICAgIF9jdXJyZW50UHJvZ3JhbSA9IHByb2dyYW0uaWQ7XHJcblxyXG4gICAgICAgICAgICByZWZyZXNoUHJvZ3JhbSA9IHRydWU7XHJcbiAgICAgICAgICAgIHJlZnJlc2hNYXRlcmlhbCA9IHRydWU7XHJcbiAgICAgICAgICAgIHJlZnJlc2hMaWdodHMgPSB0cnVlO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggbWF0ZXJpYWwuaWQgIT09IF9jdXJyZW50TWF0ZXJpYWxJZCApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggX2N1cnJlbnRNYXRlcmlhbElkID09PSAtIDEgKSByZWZyZXNoTGlnaHRzID0gdHJ1ZTtcclxuICAgICAgICAgICAgX2N1cnJlbnRNYXRlcmlhbElkID0gbWF0ZXJpYWwuaWQ7XHJcblxyXG4gICAgICAgICAgICByZWZyZXNoTWF0ZXJpYWwgPSB0cnVlO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggcmVmcmVzaFByb2dyYW0gfHwgY2FtZXJhICE9PSBfY3VycmVudENhbWVyYSApIHtcclxuXHJcbiAgICAgICAgICAgIF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLnByb2plY3Rpb25NYXRyaXgsIGZhbHNlLCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5lbGVtZW50cyApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBjYXBhYmlsaXRpZXMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTFmKCBwX3VuaWZvcm1zLmxvZ0RlcHRoQnVmRkMsIDIuMCAvICggTWF0aC5sb2coIGNhbWVyYS5mYXIgKyAxLjAgKSAvIE1hdGguTE4yICkgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICBpZiAoIGNhbWVyYSAhPT0gX2N1cnJlbnRDYW1lcmEgKSBfY3VycmVudENhbWVyYSA9IGNhbWVyYTtcclxuXHJcbiAgICAgICAgICAgIC8vIGxvYWQgbWF0ZXJpYWwgc3BlY2lmaWMgdW5pZm9ybXNcclxuICAgICAgICAgICAgLy8gKHNoYWRlciBtYXRlcmlhbCBhbHNvIGdldHMgdGhlbSBmb3IgdGhlIHNha2Ugb2YgZ2VuZXJpY2l0eSlcclxuXHJcbiAgICAgICAgICAgIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5TaGFkZXJNYXRlcmlhbCB8fFxyXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCB8fFxyXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwuZW52TWFwICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggcF91bmlmb3Jtcy5jYW1lcmFQb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xyXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtM2YoIHBfdW5pZm9ybXMuY2FtZXJhUG9zaXRpb24sIF92ZWN0b3IzLngsIF92ZWN0b3IzLnksIF92ZWN0b3IzLnogKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgfHxcclxuICAgICAgICAgICAgICAgIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCB8fFxyXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCB8fFxyXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5TaGFkZXJNYXRlcmlhbCB8fFxyXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwuc2tpbm5pbmcgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBwX3VuaWZvcm1zLnZpZXdNYXRyaXggIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMudmlld01hdHJpeCwgZmFsc2UsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UuZWxlbWVudHMgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gc2tpbm5pbmcgdW5pZm9ybXMgbXVzdCBiZSBzZXQgZXZlbiBpZiBtYXRlcmlhbCBkaWRuJ3QgY2hhbmdlXHJcbiAgICAgICAgLy8gYXV0by1zZXR0aW5nIG9mIHRleHR1cmUgdW5pdCBmb3IgYm9uZSB0ZXh0dXJlIG11c3QgZ28gYmVmb3JlIG90aGVyIHRleHR1cmVzXHJcbiAgICAgICAgLy8gbm90IHN1cmUgd2h5LCBidXQgb3RoZXJ3aXNlIHdlaXJkIHRoaW5ncyBoYXBwZW5cclxuXHJcbiAgICAgICAgaWYgKCBtYXRlcmlhbC5za2lubmluZyApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggb2JqZWN0LmJpbmRNYXRyaXggJiYgcF91bmlmb3Jtcy5iaW5kTWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMuYmluZE1hdHJpeCwgZmFsc2UsIG9iamVjdC5iaW5kTWF0cml4LmVsZW1lbnRzICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIG9iamVjdC5iaW5kTWF0cml4SW52ZXJzZSAmJiBwX3VuaWZvcm1zLmJpbmRNYXRyaXhJbnZlcnNlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMuYmluZE1hdHJpeEludmVyc2UsIGZhbHNlLCBvYmplY3QuYmluZE1hdHJpeEludmVyc2UuZWxlbWVudHMgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggY2FwYWJpbGl0aWVzLmZsb2F0VmVydGV4VGV4dHVyZXMgJiYgb2JqZWN0LnNrZWxldG9uICYmIG9iamVjdC5za2VsZXRvbi51c2VWZXJ0ZXhUZXh0dXJlICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggcF91bmlmb3Jtcy5ib25lVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dHVyZVVuaXQgPSBnZXRUZXh0dXJlVW5pdCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTFpKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldFRleHR1cmUoIG9iamVjdC5za2VsZXRvbi5ib25lVGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlV2lkdGggIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0xaSggcF91bmlmb3Jtcy5ib25lVGV4dHVyZVdpZHRoLCBvYmplY3Quc2tlbGV0b24uYm9uZVRleHR1cmVXaWR0aCApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHBfdW5pZm9ybXMuYm9uZVRleHR1cmVIZWlnaHQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0xaSggcF91bmlmb3Jtcy5ib25lVGV4dHVyZUhlaWdodCwgb2JqZWN0LnNrZWxldG9uLmJvbmVUZXh0dXJlSGVpZ2h0ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSBlbHNlIGlmICggb2JqZWN0LnNrZWxldG9uICYmIG9iamVjdC5za2VsZXRvbi5ib25lTWF0cmljZXMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBwX3VuaWZvcm1zLmJvbmVHbG9iYWxNYXRyaWNlcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybU1hdHJpeDRmdiggcF91bmlmb3Jtcy5ib25lR2xvYmFsTWF0cmljZXMsIGZhbHNlLCBvYmplY3Quc2tlbGV0b24uYm9uZU1hdHJpY2VzICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggcmVmcmVzaE1hdGVyaWFsICkge1xyXG5cclxuICAgICAgICAgICAgLy8gcmVmcmVzaCB1bmlmb3JtcyBjb21tb24gdG8gc2V2ZXJhbCBtYXRlcmlhbHNcclxuXHJcbiAgICAgICAgICAgIGlmICggZm9nICYmIG1hdGVyaWFsLmZvZyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZWZyZXNoVW5pZm9ybXNGb2coIG1fdW5pZm9ybXMsIGZvZyApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsIHx8XHJcbiAgICAgICAgICAgICAgICBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcclxuICAgICAgICAgICAgICAgIG1hdGVyaWFsLmxpZ2h0cyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIF9saWdodHNOZWVkVXBkYXRlICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoTGlnaHRzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBzZXR1cExpZ2h0cyggbGlnaHRzLCBjYW1lcmEgKTtcclxuICAgICAgICAgICAgICAgICAgICBfbGlnaHRzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHJlZnJlc2hMaWdodHMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hVbmlmb3Jtc0xpZ2h0cyggbV91bmlmb3JtcywgX2xpZ2h0cyApO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcmtVbmlmb3Jtc0xpZ2h0c05lZWRzVXBkYXRlKCBtX3VuaWZvcm1zLCB0cnVlICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbWFya1VuaWZvcm1zTGlnaHRzTmVlZHNVcGRhdGUoIG1fdW5pZm9ybXMsIGZhbHNlICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsIHx8XHJcbiAgICAgICAgICAgICAgICBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcclxuICAgICAgICAgICAgICAgIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcmVmcmVzaFVuaWZvcm1zQ29tbW9uKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gcmVmcmVzaCBzaW5nbGUgbWF0ZXJpYWwgc3BlY2lmaWMgdW5pZm9ybXNcclxuXHJcbiAgICAgICAgICAgIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZWZyZXNoVW5pZm9ybXNMaW5lKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcmVmcmVzaFVuaWZvcm1zTGluZSggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuICAgICAgICAgICAgICAgIHJlZnJlc2hVbmlmb3Jtc0Rhc2goIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50c01hdGVyaWFsICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHJlZnJlc2hVbmlmb3Jtc1BhcnRpY2xlKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZWZyZXNoVW5pZm9ybXNQaG9uZyggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgbV91bmlmb3Jtcy5tTmVhci52YWx1ZSA9IGNhbWVyYS5uZWFyO1xyXG4gICAgICAgICAgICAgICAgbV91bmlmb3Jtcy5tRmFyLnZhbHVlID0gY2FtZXJhLmZhcjtcclxuICAgICAgICAgICAgICAgIG1fdW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBtX3VuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBvYmplY3QucmVjZWl2ZVNoYWRvdyAmJiAhIG1hdGVyaWFsLl9zaGFkb3dQYXNzICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHJlZnJlc2hVbmlmb3Jtc1NoYWRvdyggbV91bmlmb3JtcywgbGlnaHRzLCBjYW1lcmEgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGxvYWQgY29tbW9uIHVuaWZvcm1zXHJcblxyXG4gICAgICAgICAgICBsb2FkVW5pZm9ybXNHZW5lcmljKCBtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXNMaXN0ICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbG9hZFVuaWZvcm1zTWF0cmljZXMoIHBfdW5pZm9ybXMsIG9iamVjdCApO1xyXG5cclxuICAgICAgICBpZiAoIHBfdW5pZm9ybXMubW9kZWxNYXRyaXggIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLm1vZGVsTWF0cml4LCBmYWxzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkLmVsZW1lbnRzICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHByb2dyYW07XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vIFVuaWZvcm1zIChyZWZyZXNoIHVuaWZvcm1zIG9iamVjdHMpXHJcblxyXG4gICAgZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zQ29tbW9uICggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xyXG5cclxuICAgICAgICB1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcclxuXHJcbiAgICAgICAgdW5pZm9ybXMuZGlmZnVzZS52YWx1ZSA9IG1hdGVyaWFsLmNvbG9yO1xyXG5cclxuICAgICAgICBpZiAoIG1hdGVyaWFsLmVtaXNzaXZlICkge1xyXG5cclxuICAgICAgICAgICAgdW5pZm9ybXMuZW1pc3NpdmUudmFsdWUgPSBtYXRlcmlhbC5lbWlzc2l2ZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB1bmlmb3Jtcy5tYXAudmFsdWUgPSBtYXRlcmlhbC5tYXA7XHJcbiAgICAgICAgdW5pZm9ybXMuc3BlY3VsYXJNYXAudmFsdWUgPSBtYXRlcmlhbC5zcGVjdWxhck1hcDtcclxuICAgICAgICB1bmlmb3Jtcy5hbHBoYU1hcC52YWx1ZSA9IG1hdGVyaWFsLmFscGhhTWFwO1xyXG5cclxuICAgICAgICBpZiAoIG1hdGVyaWFsLmFvTWFwICkge1xyXG5cclxuICAgICAgICAgICAgdW5pZm9ybXMuYW9NYXAudmFsdWUgPSBtYXRlcmlhbC5hb01hcDtcclxuICAgICAgICAgICAgdW5pZm9ybXMuYW9NYXBJbnRlbnNpdHkudmFsdWUgPSBtYXRlcmlhbC5hb01hcEludGVuc2l0eTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB1diByZXBlYXQgYW5kIG9mZnNldCBzZXR0aW5nIHByaW9yaXRpZXNcclxuICAgICAgICAvLyAxLiBjb2xvciBtYXBcclxuICAgICAgICAvLyAyLiBzcGVjdWxhciBtYXBcclxuICAgICAgICAvLyAzLiBub3JtYWwgbWFwXHJcbiAgICAgICAgLy8gNC4gYnVtcCBtYXBcclxuICAgICAgICAvLyA1LiBhbHBoYSBtYXBcclxuICAgICAgICAvLyA2LiBlbWlzc2l2ZSBtYXBcclxuXHJcbiAgICAgICAgdmFyIHV2U2NhbGVNYXA7XHJcblxyXG4gICAgICAgIGlmICggbWF0ZXJpYWwubWFwICkge1xyXG5cclxuICAgICAgICAgICAgdXZTY2FsZU1hcCA9IG1hdGVyaWFsLm1hcDtcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICggbWF0ZXJpYWwuc3BlY3VsYXJNYXAgKSB7XHJcblxyXG4gICAgICAgICAgICB1dlNjYWxlTWFwID0gbWF0ZXJpYWwuc3BlY3VsYXJNYXA7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCApIHtcclxuXHJcbiAgICAgICAgICAgIHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXA7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIG1hdGVyaWFsLm5vcm1hbE1hcCApIHtcclxuXHJcbiAgICAgICAgICAgIHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5ub3JtYWxNYXA7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIG1hdGVyaWFsLmJ1bXBNYXAgKSB7XHJcblxyXG4gICAgICAgICAgICB1dlNjYWxlTWFwID0gbWF0ZXJpYWwuYnVtcE1hcDtcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICggbWF0ZXJpYWwuYWxwaGFNYXAgKSB7XHJcblxyXG4gICAgICAgICAgICB1dlNjYWxlTWFwID0gbWF0ZXJpYWwuYWxwaGFNYXA7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIG1hdGVyaWFsLmVtaXNzaXZlTWFwICkge1xyXG5cclxuICAgICAgICAgICAgdXZTY2FsZU1hcCA9IG1hdGVyaWFsLmVtaXNzaXZlTWFwO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggdXZTY2FsZU1hcCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCB1dlNjYWxlTWFwIGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQgKSB1dlNjYWxlTWFwID0gdXZTY2FsZU1hcC50ZXh0dXJlO1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdXZTY2FsZU1hcC5vZmZzZXQ7XHJcbiAgICAgICAgICAgIHZhciByZXBlYXQgPSB1dlNjYWxlTWFwLnJlcGVhdDtcclxuXHJcbiAgICAgICAgICAgIHVuaWZvcm1zLm9mZnNldFJlcGVhdC52YWx1ZS5zZXQoIG9mZnNldC54LCBvZmZzZXQueSwgcmVwZWF0LngsIHJlcGVhdC55ICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdW5pZm9ybXMuZW52TWFwLnZhbHVlID0gbWF0ZXJpYWwuZW52TWFwO1xyXG4gICAgICAgIHVuaWZvcm1zLmZsaXBFbnZNYXAudmFsdWUgPSAoIG1hdGVyaWFsLmVudk1hcCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApID8gMSA6IC0gMTtcclxuXHJcbiAgICAgICAgdW5pZm9ybXMucmVmbGVjdGl2aXR5LnZhbHVlID0gbWF0ZXJpYWwucmVmbGVjdGl2aXR5O1xyXG4gICAgICAgIHVuaWZvcm1zLnJlZnJhY3Rpb25SYXRpby52YWx1ZSA9IG1hdGVyaWFsLnJlZnJhY3Rpb25SYXRpbztcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zTGluZSAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcclxuXHJcbiAgICAgICAgdW5pZm9ybXMuZGlmZnVzZS52YWx1ZSA9IG1hdGVyaWFsLmNvbG9yO1xyXG4gICAgICAgIHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNEYXNoICggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xyXG5cclxuICAgICAgICB1bmlmb3Jtcy5kYXNoU2l6ZS52YWx1ZSA9IG1hdGVyaWFsLmRhc2hTaXplO1xyXG4gICAgICAgIHVuaWZvcm1zLnRvdGFsU2l6ZS52YWx1ZSA9IG1hdGVyaWFsLmRhc2hTaXplICsgbWF0ZXJpYWwuZ2FwU2l6ZTtcclxuICAgICAgICB1bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IG1hdGVyaWFsLnNjYWxlO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQYXJ0aWNsZSAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcclxuXHJcbiAgICAgICAgdW5pZm9ybXMucHNDb2xvci52YWx1ZSA9IG1hdGVyaWFsLmNvbG9yO1xyXG4gICAgICAgIHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xyXG4gICAgICAgIHVuaWZvcm1zLnNpemUudmFsdWUgPSBtYXRlcmlhbC5zaXplO1xyXG4gICAgICAgIHVuaWZvcm1zLnNjYWxlLnZhbHVlID0gX2NhbnZhcy5oZWlnaHQgLyAyLjA7IC8vIFRPRE86IENhY2hlIHRoaXMuXHJcblxyXG4gICAgICAgIHVuaWZvcm1zLm1hcC52YWx1ZSA9IG1hdGVyaWFsLm1hcDtcclxuXHJcbiAgICAgICAgaWYgKCBtYXRlcmlhbC5tYXAgIT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gbWF0ZXJpYWwubWFwLm9mZnNldDtcclxuICAgICAgICAgICAgdmFyIHJlcGVhdCA9IG1hdGVyaWFsLm1hcC5yZXBlYXQ7XHJcblxyXG4gICAgICAgICAgICB1bmlmb3Jtcy5vZmZzZXRSZXBlYXQudmFsdWUuc2V0KCBvZmZzZXQueCwgb2Zmc2V0LnksIHJlcGVhdC54LCByZXBlYXQueSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0ZvZyAoIHVuaWZvcm1zLCBmb2cgKSB7XHJcblxyXG4gICAgICAgIHVuaWZvcm1zLmZvZ0NvbG9yLnZhbHVlID0gZm9nLmNvbG9yO1xyXG5cclxuICAgICAgICBpZiAoIGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZyApIHtcclxuXHJcbiAgICAgICAgICAgIHVuaWZvcm1zLmZvZ05lYXIudmFsdWUgPSBmb2cubmVhcjtcclxuICAgICAgICAgICAgdW5pZm9ybXMuZm9nRmFyLnZhbHVlID0gZm9nLmZhcjtcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICggZm9nIGluc3RhbmNlb2YgVEhSRUUuRm9nRXhwMiApIHtcclxuXHJcbiAgICAgICAgICAgIHVuaWZvcm1zLmZvZ0RlbnNpdHkudmFsdWUgPSBmb2cuZGVuc2l0eTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQaG9uZyAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcclxuXHJcbiAgICAgICAgdW5pZm9ybXMuc3BlY3VsYXIudmFsdWUgPSBtYXRlcmlhbC5zcGVjdWxhcjtcclxuICAgICAgICB1bmlmb3Jtcy5zaGluaW5lc3MudmFsdWUgPSBNYXRoLm1heCggbWF0ZXJpYWwuc2hpbmluZXNzLCAxZS00ICk7IC8vIHRvIHByZXZlbnQgcG93KCAwLjAsIDAuMCApXHJcblxyXG4gICAgICAgIGlmICggbWF0ZXJpYWwubGlnaHRNYXAgKSB7XHJcblxyXG4gICAgICAgICAgICB1bmlmb3Jtcy5saWdodE1hcC52YWx1ZSA9IG1hdGVyaWFsLmxpZ2h0TWFwO1xyXG4gICAgICAgICAgICB1bmlmb3Jtcy5saWdodE1hcEludGVuc2l0eS52YWx1ZSA9IG1hdGVyaWFsLmxpZ2h0TWFwSW50ZW5zaXR5O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggbWF0ZXJpYWwuZW1pc3NpdmVNYXAgKSB7XHJcblxyXG4gICAgICAgICAgICB1bmlmb3Jtcy5lbWlzc2l2ZU1hcC52YWx1ZSA9IG1hdGVyaWFsLmVtaXNzaXZlTWFwO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggbWF0ZXJpYWwuYnVtcE1hcCApIHtcclxuXHJcbiAgICAgICAgICAgIHVuaWZvcm1zLmJ1bXBNYXAudmFsdWUgPSBtYXRlcmlhbC5idW1wTWFwO1xyXG4gICAgICAgICAgICB1bmlmb3Jtcy5idW1wU2NhbGUudmFsdWUgPSBtYXRlcmlhbC5idW1wU2NhbGU7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBtYXRlcmlhbC5ub3JtYWxNYXAgKSB7XHJcblxyXG4gICAgICAgICAgICB1bmlmb3Jtcy5ub3JtYWxNYXAudmFsdWUgPSBtYXRlcmlhbC5ub3JtYWxNYXA7XHJcbiAgICAgICAgICAgIHVuaWZvcm1zLm5vcm1hbFNjYWxlLnZhbHVlLmNvcHkoIG1hdGVyaWFsLm5vcm1hbFNjYWxlICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgKSB7XHJcblxyXG4gICAgICAgICAgICB1bmlmb3Jtcy5kaXNwbGFjZW1lbnRNYXAudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXA7XHJcbiAgICAgICAgICAgIHVuaWZvcm1zLmRpc3BsYWNlbWVudFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGU7XHJcbiAgICAgICAgICAgIHVuaWZvcm1zLmRpc3BsYWNlbWVudEJpYXMudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0xpZ2h0cyAoIHVuaWZvcm1zLCBsaWdodHMgKSB7XHJcblxyXG4gICAgICAgIHVuaWZvcm1zLmFtYmllbnRMaWdodENvbG9yLnZhbHVlID0gbGlnaHRzLmFtYmllbnQ7XHJcblxyXG4gICAgICAgIHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHRDb2xvci52YWx1ZSA9IGxpZ2h0cy5kaXJlY3Rpb25hbC5jb2xvcnM7XHJcbiAgICAgICAgdW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvbi52YWx1ZSA9IGxpZ2h0cy5kaXJlY3Rpb25hbC5wb3NpdGlvbnM7XHJcblxyXG4gICAgICAgIHVuaWZvcm1zLnBvaW50TGlnaHRDb2xvci52YWx1ZSA9IGxpZ2h0cy5wb2ludC5jb2xvcnM7XHJcbiAgICAgICAgdW5pZm9ybXMucG9pbnRMaWdodFBvc2l0aW9uLnZhbHVlID0gbGlnaHRzLnBvaW50LnBvc2l0aW9ucztcclxuICAgICAgICB1bmlmb3Jtcy5wb2ludExpZ2h0RGlzdGFuY2UudmFsdWUgPSBsaWdodHMucG9pbnQuZGlzdGFuY2VzO1xyXG4gICAgICAgIHVuaWZvcm1zLnBvaW50TGlnaHREZWNheS52YWx1ZSA9IGxpZ2h0cy5wb2ludC5kZWNheXM7XHJcblxyXG4gICAgICAgIHVuaWZvcm1zLnNwb3RMaWdodENvbG9yLnZhbHVlID0gbGlnaHRzLnNwb3QuY29sb3JzO1xyXG4gICAgICAgIHVuaWZvcm1zLnNwb3RMaWdodFBvc2l0aW9uLnZhbHVlID0gbGlnaHRzLnNwb3QucG9zaXRpb25zO1xyXG4gICAgICAgIHVuaWZvcm1zLnNwb3RMaWdodERpc3RhbmNlLnZhbHVlID0gbGlnaHRzLnNwb3QuZGlzdGFuY2VzO1xyXG4gICAgICAgIHVuaWZvcm1zLnNwb3RMaWdodERpcmVjdGlvbi52YWx1ZSA9IGxpZ2h0cy5zcG90LmRpcmVjdGlvbnM7XHJcbiAgICAgICAgdW5pZm9ybXMuc3BvdExpZ2h0QW5nbGVDb3MudmFsdWUgPSBsaWdodHMuc3BvdC5hbmdsZXNDb3M7XHJcbiAgICAgICAgdW5pZm9ybXMuc3BvdExpZ2h0RXhwb25lbnQudmFsdWUgPSBsaWdodHMuc3BvdC5leHBvbmVudHM7XHJcbiAgICAgICAgdW5pZm9ybXMuc3BvdExpZ2h0RGVjYXkudmFsdWUgPSBsaWdodHMuc3BvdC5kZWNheXM7XHJcblxyXG4gICAgICAgIHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodFNreUNvbG9yLnZhbHVlID0gbGlnaHRzLmhlbWkuc2t5Q29sb3JzO1xyXG4gICAgICAgIHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yLnZhbHVlID0gbGlnaHRzLmhlbWkuZ3JvdW5kQ29sb3JzO1xyXG4gICAgICAgIHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodERpcmVjdGlvbi52YWx1ZSA9IGxpZ2h0cy5oZW1pLnBvc2l0aW9ucztcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgdW5pZm9ybXMgYXJlIG1hcmtlZCBhcyBjbGVhbiwgdGhleSBkb24ndCBuZWVkIHRvIGJlIGxvYWRlZCB0byB0aGUgR1BVLlxyXG5cclxuICAgIGZ1bmN0aW9uIG1hcmtVbmlmb3Jtc0xpZ2h0c05lZWRzVXBkYXRlICggdW5pZm9ybXMsIHZhbHVlICkge1xyXG5cclxuICAgICAgICB1bmlmb3Jtcy5hbWJpZW50TGlnaHRDb2xvci5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xyXG5cclxuICAgICAgICB1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0Q29sb3IubmVlZHNVcGRhdGUgPSB2YWx1ZTtcclxuICAgICAgICB1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uLm5lZWRzVXBkYXRlID0gdmFsdWU7XHJcblxyXG4gICAgICAgIHVuaWZvcm1zLnBvaW50TGlnaHRDb2xvci5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xyXG4gICAgICAgIHVuaWZvcm1zLnBvaW50TGlnaHRQb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xyXG4gICAgICAgIHVuaWZvcm1zLnBvaW50TGlnaHREaXN0YW5jZS5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xyXG4gICAgICAgIHVuaWZvcm1zLnBvaW50TGlnaHREZWNheS5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xyXG5cclxuICAgICAgICB1bmlmb3Jtcy5zcG90TGlnaHRDb2xvci5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xyXG4gICAgICAgIHVuaWZvcm1zLnNwb3RMaWdodFBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdmFsdWU7XHJcbiAgICAgICAgdW5pZm9ybXMuc3BvdExpZ2h0RGlzdGFuY2UubmVlZHNVcGRhdGUgPSB2YWx1ZTtcclxuICAgICAgICB1bmlmb3Jtcy5zcG90TGlnaHREaXJlY3Rpb24ubmVlZHNVcGRhdGUgPSB2YWx1ZTtcclxuICAgICAgICB1bmlmb3Jtcy5zcG90TGlnaHRBbmdsZUNvcy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xyXG4gICAgICAgIHVuaWZvcm1zLnNwb3RMaWdodEV4cG9uZW50Lm5lZWRzVXBkYXRlID0gdmFsdWU7XHJcbiAgICAgICAgdW5pZm9ybXMuc3BvdExpZ2h0RGVjYXkubmVlZHNVcGRhdGUgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgdW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3IubmVlZHNVcGRhdGUgPSB2YWx1ZTtcclxuICAgICAgICB1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvci5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xyXG4gICAgICAgIHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodERpcmVjdGlvbi5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNTaGFkb3cgKCB1bmlmb3JtcywgbGlnaHRzLCBjYW1lcmEgKSB7XHJcblxyXG4gICAgICAgIGlmICggdW5pZm9ybXMuc2hhZG93TWF0cml4ICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGogPSAwO1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IGxpZ2h0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbGlnaHQgPSBsaWdodHNbIGkgXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGxpZ2h0LmNhc3RTaGFkb3cgPT09IHRydWUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludExpZ2h0IHx8IGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuU3BvdExpZ2h0IHx8IGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaGFkb3cgPSBsaWdodC5zaGFkb3c7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgcG9pbnQgbGlnaHRzIHdlIHNldCB0aGUgc2hhZG93IG1hdHJpeCB0byBiZSBhIHRyYW5zbGF0aW9uLW9ubHkgbWF0cml4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlcXVhbCB0byBpbnZlcnNlIG9mIHRoZSBsaWdodCdzIHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICkubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFkb3cubWF0cml4LmlkZW50aXR5KCkuc2V0UG9zaXRpb24oIF92ZWN0b3IzICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHBvaW50IGxpZ2h0cyB3ZSBzZXQgdGhlIHNpZ24gb2YgdGhlIHNoYWRvd0RhcmtuZXNzIHVuaWZvcm0gdG8gYmUgbmVnYXRpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm1zLnNoYWRvd0RhcmtuZXNzLnZhbHVlWyBqIF0gPSAtIHNoYWRvdy5kYXJrbmVzcztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXMuc2hhZG93RGFya25lc3MudmFsdWVbIGogXSA9IHNoYWRvdy5kYXJrbmVzcztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm1zLnNoYWRvd01hdHJpeC52YWx1ZVsgaiBdID0gc2hhZG93Lm1hdHJpeDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXMuc2hhZG93TWFwLnZhbHVlWyBqIF0gPSBzaGFkb3cubWFwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3Jtcy5zaGFkb3dNYXBTaXplLnZhbHVlWyBqIF0gPSBzaGFkb3cubWFwU2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXMuc2hhZG93Qmlhcy52YWx1ZVsgaiBdID0gc2hhZG93LmJpYXM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqICsrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vIFVuaWZvcm1zIChsb2FkIHRvIEdQVSlcclxuXHJcbiAgICBmdW5jdGlvbiBsb2FkVW5pZm9ybXNNYXRyaWNlcyAoIHVuaWZvcm1zLCBvYmplY3QgKSB7XHJcblxyXG4gICAgICAgIF9nbC51bmlmb3JtTWF0cml4NGZ2KCB1bmlmb3Jtcy5tb2RlbFZpZXdNYXRyaXgsIGZhbHNlLCBvYmplY3QubW9kZWxWaWV3TWF0cml4LmVsZW1lbnRzICk7XHJcblxyXG4gICAgICAgIGlmICggdW5pZm9ybXMubm9ybWFsTWF0cml4ICkge1xyXG5cclxuICAgICAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXgzZnYoIHVuaWZvcm1zLm5vcm1hbE1hdHJpeCwgZmFsc2UsIG9iamVjdC5ub3JtYWxNYXRyaXguZWxlbWVudHMgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRUZXh0dXJlVW5pdCgpIHtcclxuXHJcbiAgICAgICAgdmFyIHRleHR1cmVVbml0ID0gX3VzZWRUZXh0dXJlVW5pdHM7XHJcblxyXG4gICAgICAgIGlmICggdGV4dHVyZVVuaXQgPj0gY2FwYWJpbGl0aWVzLm1heFRleHR1cmVzICkge1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnV2ViR0xSZW5kZXJlcjogdHJ5aW5nIHRvIHVzZSAnICsgdGV4dHVyZVVuaXQgKyAnIHRleHR1cmUgdW5pdHMgd2hpbGUgdGhpcyBHUFUgc3VwcG9ydHMgb25seSAnICsgY2FwYWJpbGl0aWVzLm1heFRleHR1cmVzICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgX3VzZWRUZXh0dXJlVW5pdHMgKz0gMTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRleHR1cmVVbml0O1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsb2FkVW5pZm9ybXNHZW5lcmljICggdW5pZm9ybXMgKSB7XHJcblxyXG4gICAgICAgIHZhciB0ZXh0dXJlLCB0ZXh0dXJlVW5pdDtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IHVuaWZvcm1zLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHVuaWZvcm0gPSB1bmlmb3Jtc1sgaiBdWyAwIF07XHJcblxyXG4gICAgICAgICAgICAvLyBuZWVkc1VwZGF0ZSBwcm9wZXJ0eSBpcyBub3QgYWRkZWQgdG8gYWxsIHVuaWZvcm1zLlxyXG4gICAgICAgICAgICBpZiAoIHVuaWZvcm0ubmVlZHNVcGRhdGUgPT09IGZhbHNlICkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICB2YXIgdHlwZSA9IHVuaWZvcm0udHlwZTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdW5pZm9ybS52YWx1ZTtcclxuICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gdW5pZm9ybXNbIGogXVsgMSBdO1xyXG5cclxuICAgICAgICAgICAgc3dpdGNoICggdHlwZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICcxaSc6XHJcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0xaSggbG9jYXRpb24sIHZhbHVlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnMWYnOlxyXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtMWYoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJzJmJzpcclxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTJmKCBsb2NhdGlvbiwgdmFsdWVbIDAgXSwgdmFsdWVbIDEgXSApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJzNmJzpcclxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTNmKCBsb2NhdGlvbiwgdmFsdWVbIDAgXSwgdmFsdWVbIDEgXSwgdmFsdWVbIDIgXSApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJzRmJzpcclxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTRmKCBsb2NhdGlvbiwgdmFsdWVbIDAgXSwgdmFsdWVbIDEgXSwgdmFsdWVbIDIgXSwgdmFsdWVbIDMgXSApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJzFpdic6XHJcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0xaXYoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJzNpdic6XHJcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0zaXYoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJzFmdic6XHJcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0xZnYoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJzJmdic6XHJcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0yZnYoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJzNmdic6XHJcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0zZnYoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJzRmdic6XHJcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm00ZnYoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ01hdHJpeDNmdic6XHJcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXgzZnYoIGxvY2F0aW9uLCBmYWxzZSwgdmFsdWUgKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdNYXRyaXg0ZnYnOlxyXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtTWF0cml4NGZ2KCBsb2NhdGlvbiwgZmFsc2UsIHZhbHVlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9cclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdpJzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIGludGVnZXJcclxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTFpKCBsb2NhdGlvbiwgdmFsdWUgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnZic6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBmbG9hdFxyXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtMWYoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICd2Mic6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBUSFJFRS5WZWN0b3IyXHJcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0yZiggbG9jYXRpb24sIHZhbHVlLngsIHZhbHVlLnkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAndjMnOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBzaW5nbGUgVEhSRUUuVmVjdG9yM1xyXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtM2YoIGxvY2F0aW9uLCB2YWx1ZS54LCB2YWx1ZS55LCB2YWx1ZS56ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ3Y0JzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIFRIUkVFLlZlY3RvcjRcclxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTRmKCBsb2NhdGlvbiwgdmFsdWUueCwgdmFsdWUueSwgdmFsdWUueiwgdmFsdWUudyApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdjJzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIFRIUkVFLkNvbG9yXHJcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0zZiggbG9jYXRpb24sIHZhbHVlLnIsIHZhbHVlLmcsIHZhbHVlLmIgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnaXYxJzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZmxhdCBhcnJheSBvZiBpbnRlZ2VycyAoSlMgb3IgdHlwZWQgYXJyYXkpXHJcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0xaXYoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdpdic6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZsYXQgYXJyYXkgb2YgaW50ZWdlcnMgd2l0aCAzIHggTiBzaXplIChKUyBvciB0eXBlZCBhcnJheSlcclxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTNpdiggbG9jYXRpb24sIHZhbHVlICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ2Z2MSc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZsYXQgYXJyYXkgb2YgZmxvYXRzIChKUyBvciB0eXBlZCBhcnJheSlcclxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTFmdiggbG9jYXRpb24sIHZhbHVlICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ2Z2JzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZmxhdCBhcnJheSBvZiBmbG9hdHMgd2l0aCAzIHggTiBzaXplIChKUyBvciB0eXBlZCBhcnJheSlcclxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTNmdiggbG9jYXRpb24sIHZhbHVlICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ3Yydic6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFycmF5IG9mIFRIUkVFLlZlY3RvcjJcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB1bmlmb3JtLl9hcnJheSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCAyICogdmFsdWUubGVuZ3RoICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpMiA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKyssIGkyICs9IDIgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheVsgaTIgKyAwIF0gPSB2YWx1ZVsgaSBdLng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5WyBpMiArIDEgXSA9IHZhbHVlWyBpIF0ueTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTJmdiggbG9jYXRpb24sIHVuaWZvcm0uX2FycmF5ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ3Yzdic6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFycmF5IG9mIFRIUkVFLlZlY3RvcjNcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB1bmlmb3JtLl9hcnJheSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCAzICogdmFsdWUubGVuZ3RoICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpMyA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKyssIGkzICs9IDMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheVsgaTMgKyAwIF0gPSB2YWx1ZVsgaSBdLng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5WyBpMyArIDEgXSA9IHZhbHVlWyBpIF0ueTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbIGkzICsgMiBdID0gdmFsdWVbIGkgXS56O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtM2Z2KCBsb2NhdGlvbiwgdW5pZm9ybS5fYXJyYXkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAndjR2JzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXJyYXkgb2YgVEhSRUUuVmVjdG9yNFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDQgKiB2YWx1ZS5sZW5ndGggKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGk0ID0gMCwgaWwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBpbDsgaSArKywgaTQgKz0gNCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5WyBpNCArIDAgXSA9IHZhbHVlWyBpIF0ueDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbIGk0ICsgMSBdID0gdmFsdWVbIGkgXS55O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheVsgaTQgKyAyIF0gPSB2YWx1ZVsgaSBdLno7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5WyBpNCArIDMgXSA9IHZhbHVlWyBpIF0udztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTRmdiggbG9jYXRpb24sIHVuaWZvcm0uX2FycmF5ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ20zJzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIFRIUkVFLk1hdHJpeDNcclxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybU1hdHJpeDNmdiggbG9jYXRpb24sIGZhbHNlLCB2YWx1ZS5lbGVtZW50cyApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdtM3YnOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBhcnJheSBvZiBUSFJFRS5NYXRyaXgzXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggdW5pZm9ybS5fYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggOSAqIHZhbHVlLmxlbmd0aCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlWyBpIF0uZmxhdHRlblRvQXJyYXlPZmZzZXQoIHVuaWZvcm0uX2FycmF5LCBpICogOSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtTWF0cml4M2Z2KCBsb2NhdGlvbiwgZmFsc2UsIHVuaWZvcm0uX2FycmF5ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ200JzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIFRIUkVFLk1hdHJpeDRcclxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybU1hdHJpeDRmdiggbG9jYXRpb24sIGZhbHNlLCB2YWx1ZS5lbGVtZW50cyApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdtNHYnOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBhcnJheSBvZiBUSFJFRS5NYXRyaXg0XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggdW5pZm9ybS5fYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggMTYgKiB2YWx1ZS5sZW5ndGggKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVsgaSBdLmZsYXR0ZW5Ub0FycmF5T2Zmc2V0KCB1bmlmb3JtLl9hcnJheSwgaSAqIDE2ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXg0ZnYoIGxvY2F0aW9uLCBmYWxzZSwgdW5pZm9ybS5fYXJyYXkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAndCc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBUSFJFRS5UZXh0dXJlICgyZCBvciBjdWJlKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZVVuaXQgPSBnZXRUZXh0dXJlVW5pdCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTFpKCBsb2NhdGlvbiwgdGV4dHVyZVVuaXQgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhIHRleHR1cmUgKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuQ3ViZVRleHR1cmUgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKCBBcnJheS5pc0FycmF5KCB0ZXh0dXJlLmltYWdlICkgJiYgdGV4dHVyZS5pbWFnZS5sZW5ndGggPT09IDYgKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXByZXNzZWRUZXh0dXJlIGNhbiBoYXZlIEFycmF5IGluIGltYWdlIDovXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDdWJlVGV4dHVyZSggdGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEN1YmVUZXh0dXJlRHluYW1pYyggdGV4dHVyZS50ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRUZXh0dXJlKCB0ZXh0dXJlLnRleHR1cmUsIHRleHR1cmVVbml0ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRUZXh0dXJlKCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ3R2JzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXJyYXkgb2YgVEhSRUUuVGV4dHVyZSAoMmQgb3IgY3ViZSlcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB1bmlmb3JtLl9hcnJheSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXkgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdW5pZm9ybS52YWx1ZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5WyBpIF0gPSBnZXRUZXh0dXJlVW5pdCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtMWl2KCBsb2NhdGlvbiwgdW5pZm9ybS5fYXJyYXkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHVuaWZvcm0udmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlID0gdW5pZm9ybS52YWx1ZVsgaSBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlVW5pdCA9IHVuaWZvcm0uX2FycmF5WyBpIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICEgdGV4dHVyZSApIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuQ3ViZVRleHR1cmUgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICggdGV4dHVyZS5pbWFnZSBpbnN0YW5jZW9mIEFycmF5ICYmIHRleHR1cmUuaW1hZ2UubGVuZ3RoID09PSA2ICkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHJlc3NlZFRleHR1cmUgY2FuIGhhdmUgQXJyYXkgaW4gaW1hZ2UgOi9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRDdWJlVGV4dHVyZSggdGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHRleHR1cmUgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRUZXh0dXJlKCB0ZXh0dXJlLnRleHR1cmUsIHRleHR1cmVVbml0ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEN1YmVUZXh0dXJlRHluYW1pYyggdGV4dHVyZS50ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRUZXh0dXJlKCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFVua25vd24gdW5pZm9ybSB0eXBlOiAnICsgdHlwZSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldENvbG9yTGluZWFyKCBhcnJheSwgb2Zmc2V0LCBjb2xvciwgaW50ZW5zaXR5ICkge1xyXG5cclxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMCBdID0gY29sb3IuciAqIGludGVuc2l0eTtcclxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMSBdID0gY29sb3IuZyAqIGludGVuc2l0eTtcclxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMiBdID0gY29sb3IuYiAqIGludGVuc2l0eTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2V0dXBMaWdodHMgKCBsaWdodHMsIGNhbWVyYSApIHtcclxuXHJcbiAgICAgICAgdmFyIGwsIGxsLCBsaWdodCxcclxuICAgICAgICAgICAgciA9IDAsIGcgPSAwLCBiID0gMCxcclxuICAgICAgICAgICAgY29sb3IsIHNreUNvbG9yLCBncm91bmRDb2xvcixcclxuICAgICAgICAgICAgaW50ZW5zaXR5LFxyXG4gICAgICAgICAgICBkaXN0YW5jZSxcclxuXHJcbiAgICAgICAgICAgIHpsaWdodHMgPSBfbGlnaHRzLFxyXG5cclxuICAgICAgICAgICAgdmlld01hdHJpeCA9IGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsXHJcblxyXG4gICAgICAgICAgICBkaXJDb2xvcnMgPSB6bGlnaHRzLmRpcmVjdGlvbmFsLmNvbG9ycyxcclxuICAgICAgICAgICAgZGlyUG9zaXRpb25zID0gemxpZ2h0cy5kaXJlY3Rpb25hbC5wb3NpdGlvbnMsXHJcblxyXG4gICAgICAgICAgICBwb2ludENvbG9ycyA9IHpsaWdodHMucG9pbnQuY29sb3JzLFxyXG4gICAgICAgICAgICBwb2ludFBvc2l0aW9ucyA9IHpsaWdodHMucG9pbnQucG9zaXRpb25zLFxyXG4gICAgICAgICAgICBwb2ludERpc3RhbmNlcyA9IHpsaWdodHMucG9pbnQuZGlzdGFuY2VzLFxyXG4gICAgICAgICAgICBwb2ludERlY2F5cyA9IHpsaWdodHMucG9pbnQuZGVjYXlzLFxyXG5cclxuICAgICAgICAgICAgc3BvdENvbG9ycyA9IHpsaWdodHMuc3BvdC5jb2xvcnMsXHJcbiAgICAgICAgICAgIHNwb3RQb3NpdGlvbnMgPSB6bGlnaHRzLnNwb3QucG9zaXRpb25zLFxyXG4gICAgICAgICAgICBzcG90RGlzdGFuY2VzID0gemxpZ2h0cy5zcG90LmRpc3RhbmNlcyxcclxuICAgICAgICAgICAgc3BvdERpcmVjdGlvbnMgPSB6bGlnaHRzLnNwb3QuZGlyZWN0aW9ucyxcclxuICAgICAgICAgICAgc3BvdEFuZ2xlc0NvcyA9IHpsaWdodHMuc3BvdC5hbmdsZXNDb3MsXHJcbiAgICAgICAgICAgIHNwb3RFeHBvbmVudHMgPSB6bGlnaHRzLnNwb3QuZXhwb25lbnRzLFxyXG4gICAgICAgICAgICBzcG90RGVjYXlzID0gemxpZ2h0cy5zcG90LmRlY2F5cyxcclxuXHJcbiAgICAgICAgICAgIGhlbWlTa3lDb2xvcnMgPSB6bGlnaHRzLmhlbWkuc2t5Q29sb3JzLFxyXG4gICAgICAgICAgICBoZW1pR3JvdW5kQ29sb3JzID0gemxpZ2h0cy5oZW1pLmdyb3VuZENvbG9ycyxcclxuICAgICAgICAgICAgaGVtaVBvc2l0aW9ucyA9IHpsaWdodHMuaGVtaS5wb3NpdGlvbnMsXHJcblxyXG4gICAgICAgICAgICBkaXJMZW5ndGggPSAwLFxyXG4gICAgICAgICAgICBwb2ludExlbmd0aCA9IDAsXHJcbiAgICAgICAgICAgIHNwb3RMZW5ndGggPSAwLFxyXG4gICAgICAgICAgICBoZW1pTGVuZ3RoID0gMCxcclxuXHJcbiAgICAgICAgICAgIGRpckNvdW50ID0gMCxcclxuICAgICAgICAgICAgcG9pbnRDb3VudCA9IDAsXHJcbiAgICAgICAgICAgIHNwb3RDb3VudCA9IDAsXHJcbiAgICAgICAgICAgIGhlbWlDb3VudCA9IDAsXHJcblxyXG4gICAgICAgICAgICBkaXJPZmZzZXQgPSAwLFxyXG4gICAgICAgICAgICBwb2ludE9mZnNldCA9IDAsXHJcbiAgICAgICAgICAgIHNwb3RPZmZzZXQgPSAwLFxyXG4gICAgICAgICAgICBoZW1pT2Zmc2V0ID0gMDtcclxuXHJcbiAgICAgICAgZm9yICggbCA9IDAsIGxsID0gbGlnaHRzLmxlbmd0aDsgbCA8IGxsOyBsICsrICkge1xyXG5cclxuICAgICAgICAgICAgbGlnaHQgPSBsaWdodHNbIGwgXTtcclxuXHJcbiAgICAgICAgICAgIGNvbG9yID0gbGlnaHQuY29sb3I7XHJcbiAgICAgICAgICAgIGludGVuc2l0eSA9IGxpZ2h0LmludGVuc2l0eTtcclxuICAgICAgICAgICAgZGlzdGFuY2UgPSBsaWdodC5kaXN0YW5jZTtcclxuXHJcbiAgICAgICAgICAgIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5BbWJpZW50TGlnaHQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCAhIGxpZ2h0LnZpc2libGUgKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICByICs9IGNvbG9yLnI7XHJcbiAgICAgICAgICAgICAgICBnICs9IGNvbG9yLmc7XHJcbiAgICAgICAgICAgICAgICBiICs9IGNvbG9yLmI7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZGlyQ291bnQgKz0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoICEgbGlnaHQudmlzaWJsZSApIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIF9kaXJlY3Rpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xyXG4gICAgICAgICAgICAgICAgX3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcclxuICAgICAgICAgICAgICAgIF9kaXJlY3Rpb24uc3ViKCBfdmVjdG9yMyApO1xyXG4gICAgICAgICAgICAgICAgX2RpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24oIHZpZXdNYXRyaXggKTtcclxuXHJcbiAgICAgICAgICAgICAgICBkaXJPZmZzZXQgPSBkaXJMZW5ndGggKiAzO1xyXG5cclxuICAgICAgICAgICAgICAgIGRpclBvc2l0aW9uc1sgZGlyT2Zmc2V0ICsgMCBdID0gX2RpcmVjdGlvbi54O1xyXG4gICAgICAgICAgICAgICAgZGlyUG9zaXRpb25zWyBkaXJPZmZzZXQgKyAxIF0gPSBfZGlyZWN0aW9uLnk7XHJcbiAgICAgICAgICAgICAgICBkaXJQb3NpdGlvbnNbIGRpck9mZnNldCArIDIgXSA9IF9kaXJlY3Rpb24uejtcclxuXHJcbiAgICAgICAgICAgICAgICBzZXRDb2xvckxpbmVhciggZGlyQ29sb3JzLCBkaXJPZmZzZXQsIGNvbG9yLCBpbnRlbnNpdHkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBkaXJMZW5ndGggKz0gMTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBwb2ludENvdW50ICs9IDE7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCAhIGxpZ2h0LnZpc2libGUgKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBwb2ludE9mZnNldCA9IHBvaW50TGVuZ3RoICogMztcclxuXHJcbiAgICAgICAgICAgICAgICBzZXRDb2xvckxpbmVhciggcG9pbnRDb2xvcnMsIHBvaW50T2Zmc2V0LCBjb2xvciwgaW50ZW5zaXR5ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgX3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xyXG4gICAgICAgICAgICAgICAgX3ZlY3RvcjMuYXBwbHlNYXRyaXg0KCB2aWV3TWF0cml4ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgcG9pbnRQb3NpdGlvbnNbIHBvaW50T2Zmc2V0ICsgMCBdID0gX3ZlY3RvcjMueDtcclxuICAgICAgICAgICAgICAgIHBvaW50UG9zaXRpb25zWyBwb2ludE9mZnNldCArIDEgXSA9IF92ZWN0b3IzLnk7XHJcbiAgICAgICAgICAgICAgICBwb2ludFBvc2l0aW9uc1sgcG9pbnRPZmZzZXQgKyAyIF0gPSBfdmVjdG9yMy56O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGRpc3RhbmNlIGlzIDAgaWYgZGVjYXkgaXMgMCwgYmVjYXVzZSB0aGVyZSBpcyBubyBhdHRlbnVhdGlvbiBhdCBhbGwuXHJcbiAgICAgICAgICAgICAgICBwb2ludERpc3RhbmNlc1sgcG9pbnRMZW5ndGggXSA9IGRpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgcG9pbnREZWNheXNbIHBvaW50TGVuZ3RoIF0gPSAoIGxpZ2h0LmRpc3RhbmNlID09PSAwICkgPyAwLjAgOiBsaWdodC5kZWNheTtcclxuXHJcbiAgICAgICAgICAgICAgICBwb2ludExlbmd0aCArPSAxO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5TcG90TGlnaHQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgc3BvdENvdW50ICs9IDE7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCAhIGxpZ2h0LnZpc2libGUgKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBzcG90T2Zmc2V0ID0gc3BvdExlbmd0aCAqIDM7XHJcblxyXG4gICAgICAgICAgICAgICAgc2V0Q29sb3JMaW5lYXIoIHNwb3RDb2xvcnMsIHNwb3RPZmZzZXQsIGNvbG9yLCBpbnRlbnNpdHkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBfZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcclxuICAgICAgICAgICAgICAgIF92ZWN0b3IzLmNvcHkoIF9kaXJlY3Rpb24gKS5hcHBseU1hdHJpeDQoIHZpZXdNYXRyaXggKTtcclxuXHJcbiAgICAgICAgICAgICAgICBzcG90UG9zaXRpb25zWyBzcG90T2Zmc2V0ICsgMCBdID0gX3ZlY3RvcjMueDtcclxuICAgICAgICAgICAgICAgIHNwb3RQb3NpdGlvbnNbIHNwb3RPZmZzZXQgKyAxIF0gPSBfdmVjdG9yMy55O1xyXG4gICAgICAgICAgICAgICAgc3BvdFBvc2l0aW9uc1sgc3BvdE9mZnNldCArIDIgXSA9IF92ZWN0b3IzLno7XHJcblxyXG4gICAgICAgICAgICAgICAgc3BvdERpc3RhbmNlc1sgc3BvdExlbmd0aCBdID0gZGlzdGFuY2U7XHJcblxyXG4gICAgICAgICAgICAgICAgX3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcclxuICAgICAgICAgICAgICAgIF9kaXJlY3Rpb24uc3ViKCBfdmVjdG9yMyApO1xyXG4gICAgICAgICAgICAgICAgX2RpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24oIHZpZXdNYXRyaXggKTtcclxuXHJcbiAgICAgICAgICAgICAgICBzcG90RGlyZWN0aW9uc1sgc3BvdE9mZnNldCArIDAgXSA9IF9kaXJlY3Rpb24ueDtcclxuICAgICAgICAgICAgICAgIHNwb3REaXJlY3Rpb25zWyBzcG90T2Zmc2V0ICsgMSBdID0gX2RpcmVjdGlvbi55O1xyXG4gICAgICAgICAgICAgICAgc3BvdERpcmVjdGlvbnNbIHNwb3RPZmZzZXQgKyAyIF0gPSBfZGlyZWN0aW9uLno7XHJcblxyXG4gICAgICAgICAgICAgICAgc3BvdEFuZ2xlc0Nvc1sgc3BvdExlbmd0aCBdID0gTWF0aC5jb3MoIGxpZ2h0LmFuZ2xlICk7XHJcbiAgICAgICAgICAgICAgICBzcG90RXhwb25lbnRzWyBzcG90TGVuZ3RoIF0gPSBsaWdodC5leHBvbmVudDtcclxuICAgICAgICAgICAgICAgIHNwb3REZWNheXNbIHNwb3RMZW5ndGggXSA9ICggbGlnaHQuZGlzdGFuY2UgPT09IDAgKSA/IDAuMCA6IGxpZ2h0LmRlY2F5O1xyXG5cclxuICAgICAgICAgICAgICAgIHNwb3RMZW5ndGggKz0gMTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuSGVtaXNwaGVyZUxpZ2h0ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGhlbWlDb3VudCArPSAxO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggISBsaWdodC52aXNpYmxlICkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgX2RpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XHJcbiAgICAgICAgICAgICAgICBfZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbiggdmlld01hdHJpeCApO1xyXG5cclxuICAgICAgICAgICAgICAgIGhlbWlPZmZzZXQgPSBoZW1pTGVuZ3RoICogMztcclxuXHJcbiAgICAgICAgICAgICAgICBoZW1pUG9zaXRpb25zWyBoZW1pT2Zmc2V0ICsgMCBdID0gX2RpcmVjdGlvbi54O1xyXG4gICAgICAgICAgICAgICAgaGVtaVBvc2l0aW9uc1sgaGVtaU9mZnNldCArIDEgXSA9IF9kaXJlY3Rpb24ueTtcclxuICAgICAgICAgICAgICAgIGhlbWlQb3NpdGlvbnNbIGhlbWlPZmZzZXQgKyAyIF0gPSBfZGlyZWN0aW9uLno7XHJcblxyXG4gICAgICAgICAgICAgICAgc2t5Q29sb3IgPSBsaWdodC5jb2xvcjtcclxuICAgICAgICAgICAgICAgIGdyb3VuZENvbG9yID0gbGlnaHQuZ3JvdW5kQ29sb3I7XHJcblxyXG4gICAgICAgICAgICAgICAgc2V0Q29sb3JMaW5lYXIoIGhlbWlTa3lDb2xvcnMsIGhlbWlPZmZzZXQsIHNreUNvbG9yLCBpbnRlbnNpdHkgKTtcclxuICAgICAgICAgICAgICAgIHNldENvbG9yTGluZWFyKCBoZW1pR3JvdW5kQ29sb3JzLCBoZW1pT2Zmc2V0LCBncm91bmRDb2xvciwgaW50ZW5zaXR5ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgaGVtaUxlbmd0aCArPSAxO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIG51bGwgZXZlbnR1YWwgcmVtYWlucyBmcm9tIHJlbW92ZWQgbGlnaHRzXHJcbiAgICAgICAgLy8gKHRoaXMgaXMgdG8gYXZvaWQgaWYgaW4gc2hhZGVyKVxyXG5cclxuICAgICAgICBmb3IgKCBsID0gZGlyTGVuZ3RoICogMywgbGwgPSBNYXRoLm1heCggZGlyQ29sb3JzLmxlbmd0aCwgZGlyQ291bnQgKiAzICk7IGwgPCBsbDsgbCArKyApIGRpckNvbG9yc1sgbCBdID0gMC4wO1xyXG4gICAgICAgIGZvciAoIGwgPSBwb2ludExlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIHBvaW50Q29sb3JzLmxlbmd0aCwgcG9pbnRDb3VudCAqIDMgKTsgbCA8IGxsOyBsICsrICkgcG9pbnRDb2xvcnNbIGwgXSA9IDAuMDtcclxuICAgICAgICBmb3IgKCBsID0gc3BvdExlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIHNwb3RDb2xvcnMubGVuZ3RoLCBzcG90Q291bnQgKiAzICk7IGwgPCBsbDsgbCArKyApIHNwb3RDb2xvcnNbIGwgXSA9IDAuMDtcclxuICAgICAgICBmb3IgKCBsID0gaGVtaUxlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIGhlbWlTa3lDb2xvcnMubGVuZ3RoLCBoZW1pQ291bnQgKiAzICk7IGwgPCBsbDsgbCArKyApIGhlbWlTa3lDb2xvcnNbIGwgXSA9IDAuMDtcclxuICAgICAgICBmb3IgKCBsID0gaGVtaUxlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIGhlbWlHcm91bmRDb2xvcnMubGVuZ3RoLCBoZW1pQ291bnQgKiAzICk7IGwgPCBsbDsgbCArKyApIGhlbWlHcm91bmRDb2xvcnNbIGwgXSA9IDAuMDtcclxuXHJcbiAgICAgICAgemxpZ2h0cy5kaXJlY3Rpb25hbC5sZW5ndGggPSBkaXJMZW5ndGg7XHJcbiAgICAgICAgemxpZ2h0cy5wb2ludC5sZW5ndGggPSBwb2ludExlbmd0aDtcclxuICAgICAgICB6bGlnaHRzLnNwb3QubGVuZ3RoID0gc3BvdExlbmd0aDtcclxuICAgICAgICB6bGlnaHRzLmhlbWkubGVuZ3RoID0gaGVtaUxlbmd0aDtcclxuXHJcbiAgICAgICAgemxpZ2h0cy5hbWJpZW50WyAwIF0gPSByO1xyXG4gICAgICAgIHpsaWdodHMuYW1iaWVudFsgMSBdID0gZztcclxuICAgICAgICB6bGlnaHRzLmFtYmllbnRbIDIgXSA9IGI7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vIEdMIHN0YXRlIHNldHRpbmdcclxuXHJcbiAgICB0aGlzLnNldEZhY2VDdWxsaW5nID0gZnVuY3Rpb24gKCBjdWxsRmFjZSwgZnJvbnRGYWNlRGlyZWN0aW9uICkge1xyXG5cclxuICAgICAgICBpZiAoIGN1bGxGYWNlID09PSBUSFJFRS5DdWxsRmFjZU5vbmUgKSB7XHJcblxyXG4gICAgICAgICAgICBzdGF0ZS5kaXNhYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGZyb250RmFjZURpcmVjdGlvbiA9PT0gVEhSRUUuRnJvbnRGYWNlRGlyZWN0aW9uQ1cgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgX2dsLmZyb250RmFjZSggX2dsLkNXICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIF9nbC5mcm9udEZhY2UoIF9nbC5DQ1cgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggY3VsbEZhY2UgPT09IFRIUkVFLkN1bGxGYWNlQmFjayApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBfZ2wuY3VsbEZhY2UoIF9nbC5CQUNLICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBjdWxsRmFjZSA9PT0gVEhSRUUuQ3VsbEZhY2VGcm9udCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBfZ2wuY3VsbEZhY2UoIF9nbC5GUk9OVCApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICBfZ2wuY3VsbEZhY2UoIF9nbC5GUk9OVF9BTkRfQkFDSyApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc3RhdGUuZW5hYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFRleHR1cmVzXHJcblxyXG4gICAgZnVuY3Rpb24gc2V0VGV4dHVyZVBhcmFtZXRlcnMgKCB0ZXh0dXJlVHlwZSwgdGV4dHVyZSwgaXNJbWFnZVBvd2VyT2ZUd28gKSB7XHJcblxyXG4gICAgICAgIHZhciBleHRlbnNpb247XHJcblxyXG4gICAgICAgIGlmICggaXNJbWFnZVBvd2VyT2ZUd28gKSB7XHJcblxyXG4gICAgICAgICAgICBfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfUywgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUud3JhcFMgKSApO1xyXG4gICAgICAgICAgICBfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfVCwgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUud3JhcFQgKSApO1xyXG5cclxuICAgICAgICAgICAgX2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5tYWdGaWx0ZXIgKSApO1xyXG4gICAgICAgICAgICBfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01JTl9GSUxURVIsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLm1pbkZpbHRlciApICk7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICBfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfUywgX2dsLkNMQU1QX1RPX0VER0UgKTtcclxuICAgICAgICAgICAgX2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1QsIF9nbC5DTEFNUF9UT19FREdFICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHRleHR1cmUud3JhcFMgIT09IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcgfHwgdGV4dHVyZS53cmFwVCAhPT0gVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIGlzIG5vdCBwb3dlciBvZiB0d28uIFRleHR1cmUud3JhcFMgYW5kIFRleHR1cmUud3JhcFQgc2hvdWxkIGJlIHNldCB0byBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nLicsIHRleHR1cmUgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZmlsdGVyRmFsbGJhY2soIHRleHR1cmUubWFnRmlsdGVyICkgKTtcclxuICAgICAgICAgICAgX2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBmaWx0ZXJGYWxsYmFjayggdGV4dHVyZS5taW5GaWx0ZXIgKSApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gVEhSRUUuTmVhcmVzdEZpbHRlciAmJiB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gVEhSRUUuTGluZWFyRmlsdGVyICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgaXMgbm90IHBvd2VyIG9mIHR3by4gVGV4dHVyZS5taW5GaWx0ZXIgc2hvdWxkIGJlIHNldCB0byBUSFJFRS5OZWFyZXN0RmlsdGVyIG9yIFRIUkVFLkxpbmVhckZpbHRlci4nLCB0ZXh0dXJlICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICk7XHJcblxyXG4gICAgICAgIGlmICggZXh0ZW5zaW9uICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCB0ZXh0dXJlLnR5cGUgPT09IFRIUkVFLkZsb2F0VHlwZSAmJiBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicgKSA9PT0gbnVsbCApIHJldHVybjtcclxuICAgICAgICAgICAgaWYgKCB0ZXh0dXJlLnR5cGUgPT09IFRIUkVFLkhhbGZGbG9hdFR5cGUgJiYgZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhcicgKSA9PT0gbnVsbCApIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGlmICggdGV4dHVyZS5hbmlzb3Ryb3B5ID4gMSB8fCBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApLl9fY3VycmVudEFuaXNvdHJvcHkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgX2dsLnRleFBhcmFtZXRlcmYoIHRleHR1cmVUeXBlLCBleHRlbnNpb24uVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQsIE1hdGgubWluKCB0ZXh0dXJlLmFuaXNvdHJvcHksIF90aGlzLmdldE1heEFuaXNvdHJvcHkoKSApICk7XHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApLl9fY3VycmVudEFuaXNvdHJvcHkgPSB0ZXh0dXJlLmFuaXNvdHJvcHk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdXBsb2FkVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMsIHRleHR1cmUsIHNsb3QgKSB7XHJcblxyXG4gICAgICAgIGlmICggdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbEluaXQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xJbml0ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIHRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XHJcblxyXG4gICAgICAgICAgICB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XHJcblxyXG4gICAgICAgICAgICBfaW5mb01lbW9yeS50ZXh0dXJlcyArKztcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XHJcbiAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xyXG5cclxuICAgICAgICBfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0ZXh0dXJlLmZsaXBZICk7XHJcbiAgICAgICAgX2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0ZXh0dXJlLnByZW11bHRpcGx5QWxwaGEgKTtcclxuICAgICAgICBfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfQUxJR05NRU5ULCB0ZXh0dXJlLnVucGFja0FsaWdubWVudCApO1xyXG5cclxuICAgICAgICB0ZXh0dXJlLmltYWdlID0gY2xhbXBUb01heFNpemUoIHRleHR1cmUuaW1hZ2UsIGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlU2l6ZSApO1xyXG5cclxuICAgICAgICBpZiAoIHRleHR1cmVOZWVkc1Bvd2VyT2ZUd28oIHRleHR1cmUgKSAmJiBpc1Bvd2VyT2ZUd28oIHRleHR1cmUuaW1hZ2UgKSA9PT0gZmFsc2UgKSB7XHJcblxyXG4gICAgICAgICAgICB0ZXh0dXJlLmltYWdlID0gbWFrZVBvd2VyT2ZUd28oIHRleHR1cmUuaW1hZ2UgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaW1hZ2UgPSB0ZXh0dXJlLmltYWdlLFxyXG4gICAgICAgICAgICBpc0ltYWdlUG93ZXJPZlR3byA9IGlzUG93ZXJPZlR3byggaW1hZ2UgKSxcclxuICAgICAgICAgICAgZ2xGb3JtYXQgPSBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5mb3JtYXQgKSxcclxuICAgICAgICAgICAgZ2xUeXBlID0gcGFyYW1UaHJlZVRvR0woIHRleHR1cmUudHlwZSApO1xyXG5cclxuICAgICAgICBzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfMkQsIHRleHR1cmUsIGlzSW1hZ2VQb3dlck9mVHdvICk7XHJcblxyXG4gICAgICAgIHZhciBtaXBtYXAsIG1pcG1hcHMgPSB0ZXh0dXJlLm1pcG1hcHM7XHJcblxyXG4gICAgICAgIGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLkRhdGFUZXh0dXJlICkge1xyXG5cclxuICAgICAgICAgICAgLy8gdXNlIG1hbnVhbGx5IGNyZWF0ZWQgbWlwbWFwcyBpZiBhdmFpbGFibGVcclxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1hbnVhbCBtaXBtYXBzXHJcbiAgICAgICAgICAgIC8vIHNldCAwIGxldmVsIG1pcG1hcCBhbmQgdGhlbiB1c2UgR0wgdG8gZ2VuZXJhdGUgb3RoZXIgbWlwbWFwIGxldmVsc1xyXG5cclxuICAgICAgICAgICAgaWYgKCBtaXBtYXBzLmxlbmd0aCA+IDAgJiYgaXNJbWFnZVBvd2VyT2ZUd28gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IG1pcG1hcHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG1pcG1hcCA9IG1pcG1hcHNbIGkgXTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgc3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIDAsIGdsRm9ybWF0LCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZS5kYXRhICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIHRleHR1cmUgaW5zdGFuY2VvZiBUSFJFRS5Db21wcmVzc2VkVGV4dHVyZSApIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIG1pcG1hcCA9IG1pcG1hcHNbIGkgXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHRleHR1cmUuZm9ybWF0ICE9PSBUSFJFRS5SR0JBRm9ybWF0ICYmIHRleHR1cmUuZm9ybWF0ICE9PSBUSFJFRS5SR0JGb3JtYXQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggc3RhdGUuZ2V0Q29tcHJlc3NlZFRleHR1cmVGb3JtYXRzKCkuaW5kZXhPZiggZ2xGb3JtYXQgKSA+IC0gMSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmNvbXByZXNzZWRUZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgbWlwbWFwLmRhdGEgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIGxvYWQgdW5zdXBwb3J0ZWQgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdCBpbiAudXBsb2FkVGV4dHVyZSgpXCIgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIC8vIHJlZ3VsYXIgVGV4dHVyZSAoaW1hZ2UsIHZpZGVvLCBjYW52YXMpXHJcblxyXG4gICAgICAgICAgICAvLyB1c2UgbWFudWFsbHkgY3JlYXRlZCBtaXBtYXBzIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbWFudWFsIG1pcG1hcHNcclxuICAgICAgICAgICAgLy8gc2V0IDAgbGV2ZWwgbWlwbWFwIGFuZCB0aGVuIHVzZSBHTCB0byBnZW5lcmF0ZSBvdGhlciBtaXBtYXAgbGV2ZWxzXHJcblxyXG4gICAgICAgICAgICBpZiAoIG1pcG1hcHMubGVuZ3RoID4gMCAmJiBpc0ltYWdlUG93ZXJPZlR3byApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbWlwbWFwID0gbWlwbWFwc1sgaSBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBnbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgdGV4dHVyZS5pbWFnZSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgJiYgaXNJbWFnZVBvd2VyT2ZUd28gKSBfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFXzJEICk7XHJcblxyXG4gICAgICAgIHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiA9IHRleHR1cmUudmVyc2lvbjtcclxuXHJcbiAgICAgICAgaWYgKCB0ZXh0dXJlLm9uVXBkYXRlICkgdGV4dHVyZS5vblVwZGF0ZSggdGV4dHVyZSApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNldFRleHR1cmUgPSBmdW5jdGlvbiAoIHRleHR1cmUsIHNsb3QgKSB7XHJcblxyXG4gICAgICAgIHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICk7XHJcblxyXG4gICAgICAgIGlmICggdGV4dHVyZS52ZXJzaW9uID4gMCAmJiB0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gIT09IHRleHR1cmUudmVyc2lvbiApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBpbWFnZSA9IHRleHR1cmUuaW1hZ2U7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGltYWdlID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBtYXJrZWQgZm9yIHVwZGF0ZSBidXQgaW1hZ2UgaXMgdW5kZWZpbmVkJywgdGV4dHVyZSApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBpbWFnZS5jb21wbGV0ZSA9PT0gZmFsc2UgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBtYXJrZWQgZm9yIHVwZGF0ZSBidXQgaW1hZ2UgaXMgaW5jb21wbGV0ZScsIHRleHR1cmUgKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHVwbG9hZFRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlLCBzbG90ICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xyXG4gICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGNsYW1wVG9NYXhTaXplICggaW1hZ2UsIG1heFNpemUgKSB7XHJcblxyXG4gICAgICAgIGlmICggaW1hZ2Uud2lkdGggPiBtYXhTaXplIHx8IGltYWdlLmhlaWdodCA+IG1heFNpemUgKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBXYXJuaW5nOiBTY2FsaW5nIHRocm91Z2ggdGhlIGNhbnZhcyB3aWxsIG9ubHkgd29yayB3aXRoIGltYWdlcyB0aGF0IHVzZVxyXG4gICAgICAgICAgICAvLyBwcmVtdWx0aXBsaWVkIGFscGhhLlxyXG5cclxuICAgICAgICAgICAgdmFyIHNjYWxlID0gbWF4U2l6ZSAvIE1hdGgubWF4KCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0ICk7XHJcblxyXG4gICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcclxuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gTWF0aC5mbG9vciggaW1hZ2Uud2lkdGggKiBzY2FsZSApO1xyXG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gTWF0aC5mbG9vciggaW1hZ2UuaGVpZ2h0ICogc2NhbGUgKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcclxuICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQgKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IGltYWdlIGlzIHRvbyBiaWcgKCcgKyBpbWFnZS53aWR0aCArICd4JyArIGltYWdlLmhlaWdodCArICcpLiBSZXNpemVkIHRvICcgKyBjYW52YXMud2lkdGggKyAneCcgKyBjYW52YXMuaGVpZ2h0LCBpbWFnZSApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNhbnZhcztcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gaW1hZ2U7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzUG93ZXJPZlR3byggaW1hZ2UgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBUSFJFRS5NYXRoLmlzUG93ZXJPZlR3byggaW1hZ2Uud2lkdGggKSAmJiBUSFJFRS5NYXRoLmlzUG93ZXJPZlR3byggaW1hZ2UuaGVpZ2h0ICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRleHR1cmVOZWVkc1Bvd2VyT2ZUd28oIHRleHR1cmUgKSB7XHJcblxyXG4gICAgICAgIGlmICggdGV4dHVyZS53cmFwUyAhPT0gVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZyB8fCB0ZXh0dXJlLndyYXBUICE9PSBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nICkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgaWYgKCB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gVEhSRUUuTmVhcmVzdEZpbHRlciAmJiB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gVEhSRUUuTGluZWFyRmlsdGVyICkgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbWFrZVBvd2VyT2ZUd28oIGltYWdlICkge1xyXG5cclxuICAgICAgICBpZiAoIGltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCB8fCBpbWFnZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50ICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XHJcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IFRIUkVFLk1hdGgubmVhcmVzdFBvd2VyT2ZUd28oIGltYWdlLndpZHRoICk7XHJcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBUSFJFRS5NYXRoLm5lYXJlc3RQb3dlck9mVHdvKCBpbWFnZS5oZWlnaHQgKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcclxuICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQgKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IGltYWdlIGlzIG5vdCBwb3dlciBvZiB0d28gKCcgKyBpbWFnZS53aWR0aCArICd4JyArIGltYWdlLmhlaWdodCArICcpLiBSZXNpemVkIHRvICcgKyBjYW52YXMud2lkdGggKyAneCcgKyBjYW52YXMuaGVpZ2h0LCBpbWFnZSApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNhbnZhcztcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gaW1hZ2U7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldEN1YmVUZXh0dXJlICggdGV4dHVyZSwgc2xvdCApIHtcclxuXHJcbiAgICAgICAgdmFyIHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKTtcclxuXHJcbiAgICAgICAgaWYgKCB0ZXh0dXJlLmltYWdlLmxlbmd0aCA9PT0gNiApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggdGV4dHVyZS52ZXJzaW9uID4gMCAmJiB0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gIT09IHRleHR1cmUudmVyc2lvbiApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoICEgdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9pbmZvTWVtb3J5LnRleHR1cmVzICsrO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0ZXh0dXJlLmZsaXBZICk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGlzQ29tcHJlc3NlZCA9IHRleHR1cmUgaW5zdGFuY2VvZiBUSFJFRS5Db21wcmVzc2VkVGV4dHVyZTtcclxuICAgICAgICAgICAgICAgIHZhciBpc0RhdGFUZXh0dXJlID0gdGV4dHVyZS5pbWFnZVsgMCBdIGluc3RhbmNlb2YgVEhSRUUuRGF0YVRleHR1cmU7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGN1YmVJbWFnZSA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggX3RoaXMuYXV0b1NjYWxlQ3ViZW1hcHMgJiYgISBpc0NvbXByZXNzZWQgJiYgISBpc0RhdGFUZXh0dXJlICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY3ViZUltYWdlWyBpIF0gPSBjbGFtcFRvTWF4U2l6ZSggdGV4dHVyZS5pbWFnZVsgaSBdLCBjYXBhYmlsaXRpZXMubWF4Q3ViZW1hcFNpemUgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1YmVJbWFnZVsgaSBdID0gaXNEYXRhVGV4dHVyZSA/IHRleHR1cmUuaW1hZ2VbIGkgXS5pbWFnZSA6IHRleHR1cmUuaW1hZ2VbIGkgXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgaW1hZ2UgPSBjdWJlSW1hZ2VbIDAgXSxcclxuICAgICAgICAgICAgICAgICAgICBpc0ltYWdlUG93ZXJPZlR3byA9IGlzUG93ZXJPZlR3byggaW1hZ2UgKSxcclxuICAgICAgICAgICAgICAgICAgICBnbEZvcm1hdCA9IHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLmZvcm1hdCApLFxyXG4gICAgICAgICAgICAgICAgICAgIGdsVHlwZSA9IHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLnR5cGUgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmUsIGlzSW1hZ2VQb3dlck9mVHdvICk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhIGlzQ29tcHJlc3NlZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaXNEYXRhVGV4dHVyZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgMCwgZ2xGb3JtYXQsIGN1YmVJbWFnZVsgaSBdLndpZHRoLCBjdWJlSW1hZ2VbIGkgXS5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIGN1YmVJbWFnZVsgaSBdLmRhdGEgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIGdsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCBjdWJlSW1hZ2VbIGkgXSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1pcG1hcCwgbWlwbWFwcyA9IGN1YmVJbWFnZVsgaSBdLm1pcG1hcHM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gbWlwbWFwcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaXBtYXAgPSBtaXBtYXBzWyBqIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0ZXh0dXJlLmZvcm1hdCAhPT0gVEhSRUUuUkdCQUZvcm1hdCAmJiB0ZXh0dXJlLmZvcm1hdCAhPT0gVEhSRUUuUkdCRm9ybWF0ICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHN0YXRlLmdldENvbXByZXNzZWRUZXh0dXJlRm9ybWF0cygpLmluZGV4T2YoIGdsRm9ybWF0ICkgPiAtIDEgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jb21wcmVzc2VkVGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIGosIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIG1pcG1hcC5kYXRhICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oIFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byBsb2FkIHVuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXQgaW4gLnNldEN1YmVUZXh0dXJlKClcIiApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIGosIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcC5kYXRhICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICggdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgJiYgaXNJbWFnZVBvd2VyT2ZUd28gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfQ1VCRV9NQVAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uID0gdGV4dHVyZS52ZXJzaW9uO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggdGV4dHVyZS5vblVwZGF0ZSApIHRleHR1cmUub25VcGRhdGUoIHRleHR1cmUgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xyXG4gICAgICAgICAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2V0Q3ViZVRleHR1cmVEeW5hbWljICggdGV4dHVyZSwgc2xvdCApIHtcclxuXHJcbiAgICAgICAgc3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xyXG4gICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKS5fX3dlYmdsVGV4dHVyZSApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW5kZXIgdGFyZ2V0c1xyXG5cclxuICAgIGZ1bmN0aW9uIHNldHVwRnJhbWVCdWZmZXIgKCBmcmFtZWJ1ZmZlciwgcmVuZGVyVGFyZ2V0LCB0ZXh0dXJlVGFyZ2V0ICkge1xyXG5cclxuICAgICAgICBfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyICk7XHJcbiAgICAgICAgX2dsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgdGV4dHVyZVRhcmdldCwgcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldC50ZXh0dXJlICkuX193ZWJnbFRleHR1cmUsIDAgKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2V0dXBSZW5kZXJCdWZmZXIgKCByZW5kZXJidWZmZXIsIHJlbmRlclRhcmdldCApIHtcclxuXHJcbiAgICAgICAgX2dsLmJpbmRSZW5kZXJidWZmZXIoIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xyXG5cclxuICAgICAgICBpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciAmJiAhIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xyXG5cclxuICAgICAgICAgICAgX2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIF9nbC5SRU5ERVJCVUZGRVIsIF9nbC5ERVBUSF9DT01QT05FTlQxNiwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XHJcbiAgICAgICAgICAgIF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XHJcblxyXG4gICAgICAgICAgICAvKiBGb3Igc29tZSByZWFzb24gdGhpcyBpcyBub3Qgd29ya2luZy4gRGVmYXVsdGluZyB0byBSR0JBNC5cclxuICAgICAgICAgICAgIH0gZWxzZSBpZiAoICEgcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xyXG5cclxuICAgICAgICAgICAgIF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBfZ2wuUkVOREVSQlVGRkVSLCBfZ2wuU1RFTkNJTF9JTkRFWDgsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCApO1xyXG4gICAgICAgICAgICAgX2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5TVEVOQ0lMX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xyXG4gICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xyXG5cclxuICAgICAgICAgICAgX2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIF9nbC5SRU5ERVJCVUZGRVIsIF9nbC5ERVBUSF9TVEVOQ0lMLCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcclxuICAgICAgICAgICAgX2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgX2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIF9nbC5SRU5ERVJCVUZGRVIsIF9nbC5SR0JBNCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zZXRSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCApIHtcclxuXHJcbiAgICAgICAgdmFyIGlzQ3ViZSA9ICggcmVuZGVyVGFyZ2V0IGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICk7XHJcblxyXG4gICAgICAgIGlmICggcmVuZGVyVGFyZ2V0ICYmIHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKS5fX3dlYmdsRnJhbWVidWZmZXIgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApO1xyXG4gICAgICAgICAgICB2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyID09PSB1bmRlZmluZWQgKSByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyID09PSB1bmRlZmluZWQgKSByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICByZW5kZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblJlbmRlclRhcmdldERpc3Bvc2UgKTtcclxuXHJcbiAgICAgICAgICAgIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlID0gX2dsLmNyZWF0ZVRleHR1cmUoKTtcclxuXHJcbiAgICAgICAgICAgIF9pbmZvTWVtb3J5LnRleHR1cmVzICsrO1xyXG5cclxuICAgICAgICAgICAgLy8gU2V0dXAgdGV4dHVyZSwgY3JlYXRlIHJlbmRlciBhbmQgZnJhbWUgYnVmZmVyc1xyXG5cclxuICAgICAgICAgICAgdmFyIGlzVGFyZ2V0UG93ZXJPZlR3byA9IGlzUG93ZXJPZlR3byggcmVuZGVyVGFyZ2V0ICksXHJcbiAgICAgICAgICAgICAgICBnbEZvcm1hdCA9IHBhcmFtVGhyZWVUb0dMKCByZW5kZXJUYXJnZXQudGV4dHVyZS5mb3JtYXQgKSxcclxuICAgICAgICAgICAgICAgIGdsVHlwZSA9IHBhcmFtVGhyZWVUb0dMKCByZW5kZXJUYXJnZXQudGV4dHVyZS50eXBlICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGlzQ3ViZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciA9IFtdO1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsUmVuZGVyYnVmZmVyID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xyXG5cclxuICAgICAgICAgICAgICAgIHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgcmVuZGVyVGFyZ2V0LnRleHR1cmUsIGlzVGFyZ2V0UG93ZXJPZlR3byApO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0gPSBfZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXJbIGkgXSA9IF9nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgMCwgZ2xGb3JtYXQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbnVsbCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzZXR1cEZyYW1lQnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdLCByZW5kZXJUYXJnZXQsIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpICk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBSZW5kZXJCdWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbFJlbmRlcmJ1ZmZlclsgaSBdLCByZW5kZXJUYXJnZXQgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCByZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgJiYgaXNUYXJnZXRQb3dlck9mVHdvICkgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciA9IF9nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggcmVuZGVyVGFyZ2V0LnNoYXJlRGVwdGhGcm9tICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXIgPSByZW5kZXJUYXJnZXQuc2hhcmVEZXB0aEZyb20uX193ZWJnbFJlbmRlcmJ1ZmZlcjtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXIgPSBfZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcclxuICAgICAgICAgICAgICAgIHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV8yRCwgcmVuZGVyVGFyZ2V0LnRleHR1cmUsIGlzVGFyZ2V0UG93ZXJPZlR3byApO1xyXG5cclxuICAgICAgICAgICAgICAgIHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBnbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBudWxsICk7XHJcblxyXG4gICAgICAgICAgICAgICAgc2V0dXBGcmFtZUJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgX2dsLlRFWFRVUkVfMkQgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHJlbmRlclRhcmdldC5zaGFyZURlcHRoRnJvbSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgISByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsUmVuZGVyYnVmZmVyICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciAmJiByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXIgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwUmVuZGVyQnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXIsIHJlbmRlclRhcmdldCApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHJlbmRlclRhcmdldC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyAmJiBpc1RhcmdldFBvd2VyT2ZUd28gKSBfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFXzJEICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSZWxlYXNlIGV2ZXJ5dGhpbmdcclxuXHJcbiAgICAgICAgICAgIGlmICggaXNDdWJlICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgbnVsbCApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIG51bGwgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIF9nbC5iaW5kUmVuZGVyYnVmZmVyKCBfZ2wuUkVOREVSQlVGRkVSLCBudWxsICk7XHJcbiAgICAgICAgICAgIF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgbnVsbCApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBmcmFtZWJ1ZmZlciwgd2lkdGgsIGhlaWdodCwgdngsIHZ5O1xyXG5cclxuICAgICAgICBpZiAoIHJlbmRlclRhcmdldCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBpc0N1YmUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZnJhbWVidWZmZXIgPSByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlclsgcmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlIF07XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIGZyYW1lYnVmZmVyID0gcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXI7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB3aWR0aCA9IHJlbmRlclRhcmdldC53aWR0aDtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gcmVuZGVyVGFyZ2V0LmhlaWdodDtcclxuXHJcbiAgICAgICAgICAgIHZ4ID0gMDtcclxuICAgICAgICAgICAgdnkgPSAwO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgZnJhbWVidWZmZXIgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgd2lkdGggPSBfdmlld3BvcnRXaWR0aDtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gX3ZpZXdwb3J0SGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgdnggPSBfdmlld3BvcnRYO1xyXG4gICAgICAgICAgICB2eSA9IF92aWV3cG9ydFk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBmcmFtZWJ1ZmZlciAhPT0gX2N1cnJlbnRGcmFtZWJ1ZmZlciApIHtcclxuXHJcbiAgICAgICAgICAgIF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgKTtcclxuICAgICAgICAgICAgX2dsLnZpZXdwb3J0KCB2eCwgdnksIHdpZHRoLCBoZWlnaHQgKTtcclxuXHJcbiAgICAgICAgICAgIF9jdXJyZW50RnJhbWVidWZmZXIgPSBmcmFtZWJ1ZmZlcjtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIGlzQ3ViZSApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApO1xyXG4gICAgICAgICAgICBfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgcmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlLCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSwgMCApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF9jdXJyZW50V2lkdGggPSB3aWR0aDtcclxuICAgICAgICBfY3VycmVudEhlaWdodCA9IGhlaWdodDtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMucmVhZFJlbmRlclRhcmdldFBpeGVscyA9IGZ1bmN0aW9uICggcmVuZGVyVGFyZ2V0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBidWZmZXIgKSB7XHJcblxyXG4gICAgICAgIGlmICggcmVuZGVyVGFyZ2V0IGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQgPT09IGZhbHNlICkge1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBUSFJFRS5XZWJHTFJlbmRlclRhcmdldC4nICk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZnJhbWVidWZmZXIgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICkuX193ZWJnbEZyYW1lYnVmZmVyO1xyXG5cclxuICAgICAgICBpZiAoIGZyYW1lYnVmZmVyICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3RvcmUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGlmICggZnJhbWVidWZmZXIgIT09IF9jdXJyZW50RnJhbWVidWZmZXIgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgX2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciApO1xyXG5cclxuICAgICAgICAgICAgICAgIHJlc3RvcmUgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdHJ5IHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdGV4dHVyZSA9IHJlbmRlclRhcmdldC50ZXh0dXJlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggdGV4dHVyZS5mb3JtYXQgIT09IFRIUkVFLlJHQkFGb3JtYXRcclxuICAgICAgICAgICAgICAgICAgICAmJiBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5mb3JtYXQgKSAhPT0gX2dsLmdldFBhcmFtZXRlciggX2dsLklNUExFTUVOVEFUSU9OX0NPTE9SX1JFQURfRk9STUFUICkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgaW4gUkdCQSBvciBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIGZvcm1hdC4nICk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHRleHR1cmUudHlwZSAhPT0gVEhSRUUuVW5zaWduZWRCeXRlVHlwZVxyXG4gICAgICAgICAgICAgICAgICAgICYmIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLnR5cGUgKSAhPT0gX2dsLmdldFBhcmFtZXRlciggX2dsLklNUExFTUVOVEFUSU9OX0NPTE9SX1JFQURfVFlQRSApXHJcbiAgICAgICAgICAgICAgICAgICAgJiYgISAoIHRleHR1cmUudHlwZSA9PT0gVEhSRUUuRmxvYXRUeXBlICYmIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0JyApIClcclxuICAgICAgICAgICAgICAgICAgICAmJiAhICggdGV4dHVyZS50eXBlID09PSBUSFJFRS5IYWxmRmxvYXRUeXBlICYmIGV4dGVuc2lvbnMuZ2V0KCAnRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0JyApICkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgaW4gVW5zaWduZWRCeXRlVHlwZSBvciBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIHR5cGUuJyApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBfZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyggX2dsLkZSQU1FQlVGRkVSICkgPT09IF9nbC5GUkFNRUJVRkZFUl9DT01QTEVURSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX2dsLnJlYWRQaXhlbHMoIHgsIHksIHdpZHRoLCBoZWlnaHQsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLmZvcm1hdCApLCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS50eXBlICksIGJ1ZmZlciApO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlYWRQaXhlbHMgZnJvbSByZW5kZXJUYXJnZXQgZmFpbGVkLiBGcmFtZWJ1ZmZlciBub3QgY29tcGxldGUuJyApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gZmluYWxseSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCByZXN0b3JlICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9jdXJyZW50RnJhbWVidWZmZXIgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCggcmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuICAgICAgICB2YXIgdGFyZ2V0ID0gcmVuZGVyVGFyZ2V0IGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlID8gX2dsLlRFWFRVUkVfQ1VCRV9NQVAgOiBfZ2wuVEVYVFVSRV8yRDtcclxuICAgICAgICB2YXIgdGV4dHVyZSA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApLl9fd2ViZ2xUZXh0dXJlO1xyXG5cclxuICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggdGFyZ2V0LCB0ZXh0dXJlICk7XHJcbiAgICAgICAgX2dsLmdlbmVyYXRlTWlwbWFwKCB0YXJnZXQgKTtcclxuICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggdGFyZ2V0LCBudWxsICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vIEZhbGxiYWNrIGZpbHRlcnMgZm9yIG5vbi1wb3dlci1vZi0yIHRleHR1cmVzXHJcblxyXG4gICAgZnVuY3Rpb24gZmlsdGVyRmFsbGJhY2sgKCBmICkge1xyXG5cclxuICAgICAgICBpZiAoIGYgPT09IFRIUkVFLk5lYXJlc3RGaWx0ZXIgfHwgZiA9PT0gVEhSRUUuTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgfHwgZiA9PT0gVEhSRUUuTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBfZ2wuTkVBUkVTVDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gX2dsLkxJTkVBUjtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWFwIHRocmVlLmpzIGNvbnN0YW50cyB0byBXZWJHTCBjb25zdGFudHNcclxuXHJcbiAgICBmdW5jdGlvbiBwYXJhbVRocmVlVG9HTCAoIHAgKSB7XHJcblxyXG4gICAgICAgIHZhciBleHRlbnNpb247XHJcblxyXG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuUmVwZWF0V3JhcHBpbmcgKSByZXR1cm4gX2dsLlJFUEVBVDtcclxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcgKSByZXR1cm4gX2dsLkNMQU1QX1RPX0VER0U7XHJcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nICkgcmV0dXJuIF9nbC5NSVJST1JFRF9SRVBFQVQ7XHJcblxyXG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuTmVhcmVzdEZpbHRlciApIHJldHVybiBfZ2wuTkVBUkVTVDtcclxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLk5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyICkgcmV0dXJuIF9nbC5ORUFSRVNUX01JUE1BUF9ORUFSRVNUO1xyXG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciApIHJldHVybiBfZ2wuTkVBUkVTVF9NSVBNQVBfTElORUFSO1xyXG5cclxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLkxpbmVhckZpbHRlciApIHJldHVybiBfZ2wuTElORUFSO1xyXG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlciApIHJldHVybiBfZ2wuTElORUFSX01JUE1BUF9ORUFSRVNUO1xyXG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyICkgcmV0dXJuIF9nbC5MSU5FQVJfTUlQTUFQX0xJTkVBUjtcclxuXHJcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9CWVRFO1xyXG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuVW5zaWduZWRTaG9ydDQ0NDRUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9TSE9SVF80XzRfNF80O1xyXG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuVW5zaWduZWRTaG9ydDU1NTFUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9TSE9SVF81XzVfNV8xO1xyXG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuVW5zaWduZWRTaG9ydDU2NVR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX1NIT1JUXzVfNl81O1xyXG5cclxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLkJ5dGVUeXBlICkgcmV0dXJuIF9nbC5CWVRFO1xyXG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuU2hvcnRUeXBlICkgcmV0dXJuIF9nbC5TSE9SVDtcclxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkU2hvcnRUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9TSE9SVDtcclxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLkludFR5cGUgKSByZXR1cm4gX2dsLklOVDtcclxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkSW50VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfSU5UO1xyXG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuRmxvYXRUeXBlICkgcmV0dXJuIF9nbC5GTE9BVDtcclxuXHJcbiAgICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0JyApO1xyXG5cclxuICAgICAgICBpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggcCA9PT0gVEhSRUUuSGFsZkZsb2F0VHlwZSApIHJldHVybiBleHRlbnNpb24uSEFMRl9GTE9BVF9PRVM7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5BbHBoYUZvcm1hdCApIHJldHVybiBfZ2wuQUxQSEE7XHJcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5SR0JGb3JtYXQgKSByZXR1cm4gX2dsLlJHQjtcclxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlJHQkFGb3JtYXQgKSByZXR1cm4gX2dsLlJHQkE7XHJcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5MdW1pbmFuY2VGb3JtYXQgKSByZXR1cm4gX2dsLkxVTUlOQU5DRTtcclxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLkx1bWluYW5jZUFscGhhRm9ybWF0ICkgcmV0dXJuIF9nbC5MVU1JTkFOQ0VfQUxQSEE7XHJcblxyXG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuQWRkRXF1YXRpb24gKSByZXR1cm4gX2dsLkZVTkNfQUREO1xyXG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuU3VidHJhY3RFcXVhdGlvbiApIHJldHVybiBfZ2wuRlVOQ19TVUJUUkFDVDtcclxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uICkgcmV0dXJuIF9nbC5GVU5DX1JFVkVSU0VfU1VCVFJBQ1Q7XHJcblxyXG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuWmVyb0ZhY3RvciApIHJldHVybiBfZ2wuWkVSTztcclxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLk9uZUZhY3RvciApIHJldHVybiBfZ2wuT05FO1xyXG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuU3JjQ29sb3JGYWN0b3IgKSByZXR1cm4gX2dsLlNSQ19DT0xPUjtcclxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLk9uZU1pbnVzU3JjQ29sb3JGYWN0b3IgKSByZXR1cm4gX2dsLk9ORV9NSU5VU19TUkNfQ09MT1I7XHJcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5TcmNBbHBoYUZhY3RvciApIHJldHVybiBfZ2wuU1JDX0FMUEhBO1xyXG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuT25lTWludXNTcmNBbHBoYUZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX1NSQ19BTFBIQTtcclxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLkRzdEFscGhhRmFjdG9yICkgcmV0dXJuIF9nbC5EU1RfQUxQSEE7XHJcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5PbmVNaW51c0RzdEFscGhhRmFjdG9yICkgcmV0dXJuIF9nbC5PTkVfTUlOVVNfRFNUX0FMUEhBO1xyXG5cclxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLkRzdENvbG9yRmFjdG9yICkgcmV0dXJuIF9nbC5EU1RfQ09MT1I7XHJcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5PbmVNaW51c0RzdENvbG9yRmFjdG9yICkgcmV0dXJuIF9nbC5PTkVfTUlOVVNfRFNUX0NPTE9SO1xyXG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuU3JjQWxwaGFTYXR1cmF0ZUZhY3RvciApIHJldHVybiBfZ2wuU1JDX0FMUEhBX1NBVFVSQVRFO1xyXG5cclxuICAgICAgICBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApO1xyXG5cclxuICAgICAgICBpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggcCA9PT0gVEhSRUUuUkdCX1MzVENfRFhUMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX1MzVENfRFhUMV9FWFQ7XHJcbiAgICAgICAgICAgIGlmICggcCA9PT0gVEhSRUUuUkdCQV9TM1RDX0RYVDFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQxX0VYVDtcclxuICAgICAgICAgICAgaWYgKCBwID09PSBUSFJFRS5SR0JBX1MzVENfRFhUM19Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDNfRVhUO1xyXG4gICAgICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFQ7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICk7XHJcblxyXG4gICAgICAgIGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBwID09PSBUSFJFRS5SR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUFZSVENfNEJQUFYxX0lNRztcclxuICAgICAgICAgICAgaWYgKCBwID09PSBUSFJFRS5SR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUFZSVENfMkJQUFYxX0lNRztcclxuICAgICAgICAgICAgaWYgKCBwID09PSBUSFJFRS5SR0JBX1BWUlRDXzRCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9QVlJUQ180QlBQVjFfSU1HO1xyXG4gICAgICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzJCUFBWMV9JTUc7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdFWFRfYmxlbmRfbWlubWF4JyApO1xyXG5cclxuICAgICAgICBpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggcCA9PT0gVEhSRUUuTWluRXF1YXRpb24gKSByZXR1cm4gZXh0ZW5zaW9uLk1JTl9FWFQ7XHJcbiAgICAgICAgICAgIGlmICggcCA9PT0gVEhSRUUuTWF4RXF1YXRpb24gKSByZXR1cm4gZXh0ZW5zaW9uLk1BWF9FWFQ7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vIERFUFJFQ0FURURcclxuXHJcbiAgICB0aGlzLnN1cHBvcnRzRmxvYXRUZXh0dXJlcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzRmxvYXRUZXh0dXJlcygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ09FU190ZXh0dXJlX2Zsb2F0XFwnICkuJyApO1xyXG4gICAgICAgIHJldHVybiBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0JyApO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zdXBwb3J0c0hhbGZGbG9hdFRleHR1cmVzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNIYWxmRmxvYXRUZXh0dXJlcygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ09FU190ZXh0dXJlX2hhbGZfZmxvYXRcXCcgKS4nICk7XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcgKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc3VwcG9ydHNTdGFuZGFyZERlcml2YXRpdmVzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNTdGFuZGFyZERlcml2YXRpdmVzKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzXFwnICkuJyApO1xyXG4gICAgICAgIHJldHVybiBleHRlbnNpb25zLmdldCggJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcycgKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVMzVEMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUzNUQygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjXFwnICkuJyApO1xyXG4gICAgICAgIHJldHVybiBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUFZSVEMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUFZSVEMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGNcXCcgKS4nICk7XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zdXBwb3J0c0JsZW5kTWluTWF4ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNCbGVuZE1pbk1heCgpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ0VYVF9ibGVuZF9taW5tYXhcXCcgKS4nICk7XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbnMuZ2V0KCAnRVhUX2JsZW5kX21pbm1heCcgKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNhcGFiaWxpdGllcy52ZXJ0ZXhUZXh0dXJlcztcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc3VwcG9ydHNJbnN0YW5jZWRBcnJheXMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0luc3RhbmNlZEFycmF5cygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ0FOR0xFX2luc3RhbmNlZF9hcnJheXNcXCcgKS4nICk7XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8vXHJcblxyXG4gICAgdGhpcy5pbml0TWF0ZXJpYWwgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5pbml0TWF0ZXJpYWwoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuYWRkUHJlUGx1Z2luID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuYWRkUHJlUGx1Z2luKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmFkZFBvc3RQbHVnaW4gPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5hZGRQb3N0UGx1Z2luKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZVNoYWRvd01hcCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnVwZGF0ZVNoYWRvd01hcCgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcclxuICAgICAgICBzaGFkb3dNYXBFbmFibGVkOiB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBzaGFkb3dNYXAuZW5hYmxlZDtcclxuXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwRW5hYmxlZCBpcyBub3cgLnNoYWRvd01hcC5lbmFibGVkLicgKTtcclxuICAgICAgICAgICAgICAgIHNoYWRvd01hcC5lbmFibGVkID0gdmFsdWU7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaGFkb3dNYXBUeXBlOiB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBzaGFkb3dNYXAudHlwZTtcclxuXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwVHlwZSBpcyBub3cgLnNoYWRvd01hcC50eXBlLicgKTtcclxuICAgICAgICAgICAgICAgIHNoYWRvd01hcC50eXBlID0gdmFsdWU7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaGFkb3dNYXBDdWxsRmFjZToge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hhZG93TWFwLmN1bGxGYWNlO1xyXG5cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXBDdWxsRmFjZSBpcyBub3cgLnNoYWRvd01hcC5jdWxsRmFjZS4nICk7XHJcbiAgICAgICAgICAgICAgICBzaGFkb3dNYXAuY3VsbEZhY2UgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNoYWRvd01hcERlYnVnOiB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBzaGFkb3dNYXAuZGVidWc7XHJcblxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcERlYnVnIGlzIG5vdyAuc2hhZG93TWFwLmRlYnVnLicgKTtcclxuICAgICAgICAgICAgICAgIHNoYWRvd01hcC5kZWJ1ZyA9IHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0gKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvV2ViR0xSZW5kZXJUYXJnZXQuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIHN6aW1layAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zemltZWsvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKSB7XHJcblxyXG4gICAgdGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICBpZiAoIG9wdGlvbnMubWluRmlsdGVyID09PSB1bmRlZmluZWQgKSBvcHRpb25zLm1pbkZpbHRlciA9IFRIUkVFLkxpbmVhckZpbHRlcjtcclxuXHJcbiAgICB0aGlzLnRleHR1cmUgPSBuZXcgVEhSRUUuVGV4dHVyZSggdW5kZWZpbmVkLCB1bmRlZmluZWQsIG9wdGlvbnMud3JhcFMsIG9wdGlvbnMud3JhcFQsIG9wdGlvbnMubWFnRmlsdGVyLCBvcHRpb25zLm1pbkZpbHRlciwgb3B0aW9ucy5mb3JtYXQsIG9wdGlvbnMudHlwZSwgb3B0aW9ucy5hbmlzb3Ryb3B5ICk7XHJcblxyXG4gICAgdGhpcy5kZXB0aEJ1ZmZlciA9IG9wdGlvbnMuZGVwdGhCdWZmZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGVwdGhCdWZmZXIgOiB0cnVlO1xyXG4gICAgdGhpcy5zdGVuY2lsQnVmZmVyID0gb3B0aW9ucy5zdGVuY2lsQnVmZmVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0ZW5jaWxCdWZmZXIgOiB0cnVlO1xyXG5cclxuICAgIHRoaXMuc2hhcmVEZXB0aEZyb20gPSBvcHRpb25zLnNoYXJlRGVwdGhGcm9tICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnNoYXJlRGVwdGhGcm9tIDogbnVsbDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5XZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LFxyXG5cclxuICAgIGdldCB3cmFwUygpIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC53cmFwUyBpcyBub3cgLnRleHR1cmUud3JhcFMuJyApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlLndyYXBTO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0IHdyYXBTKCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC53cmFwUyBpcyBub3cgLnRleHR1cmUud3JhcFMuJyApO1xyXG5cclxuICAgICAgICB0aGlzLnRleHR1cmUud3JhcFMgPSB2YWx1ZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldCB3cmFwVCgpIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC53cmFwVCBpcyBub3cgLnRleHR1cmUud3JhcFQuJyApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlLndyYXBUO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0IHdyYXBUKCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC53cmFwVCBpcyBub3cgLnRleHR1cmUud3JhcFQuJyApO1xyXG5cclxuICAgICAgICB0aGlzLnRleHR1cmUud3JhcFQgPSB2YWx1ZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldCBtYWdGaWx0ZXIoKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAubWFnRmlsdGVyIGlzIG5vdyAudGV4dHVyZS5tYWdGaWx0ZXIuJyApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlLm1hZ0ZpbHRlcjtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldCBtYWdGaWx0ZXIoIHZhbHVlICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm1hZ0ZpbHRlciBpcyBub3cgLnRleHR1cmUubWFnRmlsdGVyLicgKTtcclxuXHJcbiAgICAgICAgdGhpcy50ZXh0dXJlLm1hZ0ZpbHRlciA9IHZhbHVlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0IG1pbkZpbHRlcigpIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5taW5GaWx0ZXIgaXMgbm93IC50ZXh0dXJlLm1pbkZpbHRlci4nICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnRleHR1cmUubWluRmlsdGVyO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0IG1pbkZpbHRlciggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAubWluRmlsdGVyIGlzIG5vdyAudGV4dHVyZS5taW5GaWx0ZXIuJyApO1xyXG5cclxuICAgICAgICB0aGlzLnRleHR1cmUubWluRmlsdGVyID0gdmFsdWU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXQgYW5pc290cm9weSgpIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5hbmlzb3Ryb3B5IGlzIG5vdyAudGV4dHVyZS5hbmlzb3Ryb3B5LicgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZS5hbmlzb3Ryb3B5O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0IGFuaXNvdHJvcHkoIHZhbHVlICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmFuaXNvdHJvcHkgaXMgbm93IC50ZXh0dXJlLmFuaXNvdHJvcHkuJyApO1xyXG5cclxuICAgICAgICB0aGlzLnRleHR1cmUuYW5pc290cm9weSA9IHZhbHVlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0IG9mZnNldCgpIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5vZmZzZXQgaXMgbm93IC50ZXh0dXJlLm9mZnNldC4nICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnRleHR1cmUub2Zmc2V0O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0IG9mZnNldCggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAub2Zmc2V0IGlzIG5vdyAudGV4dHVyZS5vZmZzZXQuJyApO1xyXG5cclxuICAgICAgICB0aGlzLnRleHR1cmUub2Zmc2V0ID0gdmFsdWU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXQgcmVwZWF0KCkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLnJlcGVhdCBpcyBub3cgLnRleHR1cmUucmVwZWF0LicgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZS5yZXBlYXQ7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXQgcmVwZWF0KCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5yZXBlYXQgaXMgbm93IC50ZXh0dXJlLnJlcGVhdC4nICk7XHJcblxyXG4gICAgICAgIHRoaXMudGV4dHVyZS5yZXBlYXQgPSB2YWx1ZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldCBmb3JtYXQoKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuZm9ybWF0IGlzIG5vdyAudGV4dHVyZS5mb3JtYXQuJyApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlLmZvcm1hdDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldCBmb3JtYXQoIHZhbHVlICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmZvcm1hdCBpcyBub3cgLnRleHR1cmUuZm9ybWF0LicgKTtcclxuXHJcbiAgICAgICAgdGhpcy50ZXh0dXJlLmZvcm1hdCA9IHZhbHVlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0IHR5cGUoKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAudHlwZSBpcyBub3cgLnRleHR1cmUudHlwZS4nICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnRleHR1cmUudHlwZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldCB0eXBlKCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC50eXBlIGlzIG5vdyAudGV4dHVyZS50eXBlLicgKTtcclxuXHJcbiAgICAgICAgdGhpcy50ZXh0dXJlLnR5cGUgPSB2YWx1ZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldCBnZW5lcmF0ZU1pcG1hcHMoKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuZ2VuZXJhdGVNaXBtYXBzIGlzIG5vdyAudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMuJyApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldCBnZW5lcmF0ZU1pcG1hcHMoIHZhbHVlICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmdlbmVyYXRlTWlwbWFwcyBpcyBub3cgLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzLicgKTtcclxuXHJcbiAgICAgICAgdGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IHZhbHVlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLy9cclxuXHJcbiAgICBzZXRTaXplOiBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQgKSB7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy53aWR0aCAhPT0gd2lkdGggfHwgdGhpcy5oZWlnaHQgIT09IGhlaWdodCApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG4gICAgICAgIHRoaXMud2lkdGggPSBzb3VyY2Uud2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBzb3VyY2UuaGVpZ2h0O1xyXG5cclxuICAgICAgICB0aGlzLnRleHR1cmUgPSBzb3VyY2UudGV4dHVyZS5jbG9uZSgpO1xyXG5cclxuICAgICAgICB0aGlzLmRlcHRoQnVmZmVyID0gc291cmNlLmRlcHRoQnVmZmVyO1xyXG4gICAgICAgIHRoaXMuc3RlbmNpbEJ1ZmZlciA9IHNvdXJjZS5zdGVuY2lsQnVmZmVyO1xyXG5cclxuICAgICAgICB0aGlzLnNoYXJlRGVwdGhGcm9tID0gc291cmNlLnNoYXJlRGVwdGhGcm9tO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LnByb3RvdHlwZSApO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL1dlYkdMUmVuZGVyVGFyZ2V0Q3ViZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb21cclxuICovXHJcblxyXG5USFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKSB7XHJcblxyXG4gICAgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQuY2FsbCggdGhpcywgd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApO1xyXG5cclxuICAgIHRoaXMuYWN0aXZlQ3ViZUZhY2UgPSAwOyAvLyBQWCAwLCBOWCAxLCBQWSAyLCBOWSAzLCBQWiA0LCBOWiA1XHJcblxyXG59O1xyXG5cclxuVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LnByb3RvdHlwZSApO1xyXG5USFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMQnVmZmVyUmVuZGVyZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLldlYkdMQnVmZmVyUmVuZGVyZXIgPSBmdW5jdGlvbiAoIF9nbCwgZXh0ZW5zaW9ucywgX2luZm9SZW5kZXIgKSB7XHJcblxyXG4gICAgdmFyIG1vZGU7XHJcblxyXG4gICAgZnVuY3Rpb24gc2V0TW9kZSggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIG1vZGUgPSB2YWx1ZTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVuZGVyKCBzdGFydCwgY291bnQgKSB7XHJcblxyXG4gICAgICAgIF9nbC5kcmF3QXJyYXlzKCBtb2RlLCBzdGFydCwgY291bnQgKTtcclxuXHJcbiAgICAgICAgX2luZm9SZW5kZXIuY2FsbHMgKys7XHJcbiAgICAgICAgX2luZm9SZW5kZXIudmVydGljZXMgKz0gY291bnQ7XHJcbiAgICAgICAgaWYgKCBtb2RlID09PSBfZ2wuVFJJQU5HTEVTICkgX2luZm9SZW5kZXIuZmFjZXMgKz0gY291bnQgLyAzO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZW5kZXJJbnN0YW5jZXMoIGdlb21ldHJ5ICkge1xyXG5cclxuICAgICAgICB2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xyXG5cclxuICAgICAgICBpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTEJ1ZmZlclJlbmRlcmVyOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nICk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cclxuICAgICAgICBpZiAoIHBvc2l0aW9uIGluc3RhbmNlb2YgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XHJcblxyXG4gICAgICAgICAgICBleHRlbnNpb24uZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKCBtb2RlLCAwLCBwb3NpdGlvbi5kYXRhLmNvdW50LCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCApO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgZXh0ZW5zaW9uLmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRSggbW9kZSwgMCwgcG9zaXRpb24uY291bnQsIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zZXRNb2RlID0gc2V0TW9kZTtcclxuICAgIHRoaXMucmVuZGVyID0gcmVuZGVyO1xyXG4gICAgdGhpcy5yZW5kZXJJbnN0YW5jZXMgPSByZW5kZXJJbnN0YW5jZXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMSW5kZXhlZEJ1ZmZlclJlbmRlcmVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5XZWJHTEluZGV4ZWRCdWZmZXJSZW5kZXJlciA9IGZ1bmN0aW9uICggX2dsLCBleHRlbnNpb25zLCBfaW5mb1JlbmRlciApIHtcclxuXHJcbiAgICB2YXIgbW9kZTtcclxuXHJcbiAgICBmdW5jdGlvbiBzZXRNb2RlKCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgbW9kZSA9IHZhbHVlO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB2YXIgdHlwZSwgc2l6ZTtcclxuXHJcbiAgICBmdW5jdGlvbiBzZXRJbmRleCggaW5kZXggKSB7XHJcblxyXG4gICAgICAgIGlmICggaW5kZXguYXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSAmJiBleHRlbnNpb25zLmdldCggJ09FU19lbGVtZW50X2luZGV4X3VpbnQnICkgKSB7XHJcblxyXG4gICAgICAgICAgICB0eXBlID0gX2dsLlVOU0lHTkVEX0lOVDtcclxuICAgICAgICAgICAgc2l6ZSA9IDQ7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICB0eXBlID0gX2dsLlVOU0lHTkVEX1NIT1JUO1xyXG4gICAgICAgICAgICBzaXplID0gMjtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZW5kZXIoIHN0YXJ0LCBjb3VudCApIHtcclxuXHJcbiAgICAgICAgX2dsLmRyYXdFbGVtZW50cyggbW9kZSwgY291bnQsIHR5cGUsIHN0YXJ0ICogc2l6ZSApO1xyXG5cclxuICAgICAgICBfaW5mb1JlbmRlci5jYWxscyArKztcclxuICAgICAgICBfaW5mb1JlbmRlci52ZXJ0aWNlcyArPSBjb3VudDtcclxuICAgICAgICBpZiAoIG1vZGUgPT09IF9nbC5UUklBTkdMRVMgKSBfaW5mb1JlbmRlci5mYWNlcyArPSBjb3VudCAvIDM7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlbmRlckluc3RhbmNlcyggZ2VvbWV0cnkgKSB7XHJcblxyXG4gICAgICAgIHZhciBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XHJcblxyXG4gICAgICAgIGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMQnVmZmVyUmVuZGVyZXI6IHVzaW5nIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IGJ1dCBoYXJkd2FyZSBkb2VzIG5vdCBzdXBwb3J0IGV4dGVuc2lvbiBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzLicgKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xyXG5cclxuICAgICAgICBleHRlbnNpb24uZHJhd0VsZW1lbnRzSW5zdGFuY2VkQU5HTEUoIG1vZGUsIGluZGV4LmFycmF5Lmxlbmd0aCwgdHlwZSwgMCwgZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zZXRNb2RlID0gc2V0TW9kZTtcclxuICAgIHRoaXMuc2V0SW5kZXggPSBzZXRJbmRleDtcclxuICAgIHRoaXMucmVuZGVyID0gcmVuZGVyO1xyXG4gICAgdGhpcy5yZW5kZXJJbnN0YW5jZXMgPSByZW5kZXJJbnN0YW5jZXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMRXh0ZW5zaW9ucy5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuV2ViR0xFeHRlbnNpb25zID0gZnVuY3Rpb24gKCBnbCApIHtcclxuXHJcbiAgICB2YXIgZXh0ZW5zaW9ucyA9IHt9O1xyXG5cclxuICAgIHRoaXMuZ2V0ID0gZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuICAgICAgICBpZiAoIGV4dGVuc2lvbnNbIG5hbWUgXSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGV4dGVuc2lvbnNbIG5hbWUgXTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZXh0ZW5zaW9uO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKCBuYW1lICkge1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJzpcclxuICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdNT1pfRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ1dFQktJVF9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJzpcclxuICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ01PWl9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdXRUJLSVRfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Yyc6XHJcbiAgICAgICAgICAgICAgICBleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggbmFtZSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogJyArIG5hbWUgKyAnIGV4dGVuc2lvbiBub3Qgc3VwcG9ydGVkLicgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBleHRlbnNpb25zWyBuYW1lIF0gPSBleHRlbnNpb247XHJcblxyXG4gICAgICAgIHJldHVybiBleHRlbnNpb247XHJcblxyXG4gICAgfTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xDYXBhYmlsaXRpZXMuanNcclxuXHJcblRIUkVFLldlYkdMQ2FwYWJpbGl0aWVzID0gZnVuY3Rpb24gKCBnbCwgZXh0ZW5zaW9ucywgcGFyYW1ldGVycyApIHtcclxuXHJcbiAgICBmdW5jdGlvbiBnZXRNYXhQcmVjaXNpb24oIHByZWNpc2lvbiApIHtcclxuXHJcbiAgICAgICAgaWYgKCBwcmVjaXNpb24gPT09ICdoaWdocCcgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggZ2wuVkVSVEVYX1NIQURFUiwgZ2wuSElHSF9GTE9BVCApLnByZWNpc2lvbiA+IDAgJiZcclxuICAgICAgICAgICAgICAgIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5ISUdIX0ZMT0FUICkucHJlY2lzaW9uID4gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpZ2hwJztcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHByZWNpc2lvbiA9ICdtZWRpdW1wJztcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIHByZWNpc2lvbiA9PT0gJ21lZGl1bXAnICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIGdsLlZFUlRFWF9TSEFERVIsIGdsLk1FRElVTV9GTE9BVCApLnByZWNpc2lvbiA+IDAgJiZcclxuICAgICAgICAgICAgICAgIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5NRURJVU1fRkxPQVQgKS5wcmVjaXNpb24gPiAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiAnbWVkaXVtcCc7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuICdsb3dwJztcclxuXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5nZXRNYXhQcmVjaXNpb24gPSBnZXRNYXhQcmVjaXNpb247XHJcblxyXG4gICAgdGhpcy5wcmVjaXNpb24gPSBwYXJhbWV0ZXJzLnByZWNpc2lvbiAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVjaXNpb24gOiAnaGlnaHAnLFxyXG4gICAgICAgIHRoaXMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA9IHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyIDogZmFsc2U7XHJcblxyXG4gICAgdGhpcy5tYXhUZXh0dXJlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcclxuICAgIHRoaXMubWF4VmVydGV4VGV4dHVyZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9WRVJURVhfVEVYVFVSRV9JTUFHRV9VTklUUyApO1xyXG4gICAgdGhpcy5tYXhUZXh0dXJlU2l6ZSA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1RFWFRVUkVfU0laRSApO1xyXG4gICAgdGhpcy5tYXhDdWJlbWFwU2l6ZSA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRSApO1xyXG5cclxuICAgIHRoaXMubWF4QXR0cmlidXRlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9BVFRSSUJTICk7XHJcbiAgICB0aGlzLm1heFZlcnRleFVuaWZvcm1zID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkVSVEVYX1VOSUZPUk1fVkVDVE9SUyApO1xyXG4gICAgdGhpcy5tYXhWYXJ5aW5ncyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZBUllJTkdfVkVDVE9SUyApO1xyXG4gICAgdGhpcy5tYXhGcmFnbWVudFVuaWZvcm1zID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfRlJBR01FTlRfVU5JRk9STV9WRUNUT1JTICk7XHJcblxyXG4gICAgdGhpcy52ZXJ0ZXhUZXh0dXJlcyA9IHRoaXMubWF4VmVydGV4VGV4dHVyZXMgPiAwO1xyXG4gICAgdGhpcy5mbG9hdEZyYWdtZW50VGV4dHVyZXMgPSAhISBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0JyApO1xyXG4gICAgdGhpcy5mbG9hdFZlcnRleFRleHR1cmVzID0gdGhpcy52ZXJ0ZXhUZXh0dXJlcyAmJiB0aGlzLmZsb2F0RnJhZ21lbnRUZXh0dXJlcztcclxuXHJcbiAgICB2YXIgX21heFByZWNpc2lvbiA9IGdldE1heFByZWNpc2lvbiggdGhpcy5wcmVjaXNpb24gKTtcclxuXHJcbiAgICBpZiAoIF9tYXhQcmVjaXNpb24gIT09IHRoaXMucHJlY2lzaW9uICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOicsIHRoaXMucHJlY2lzaW9uLCAnbm90IHN1cHBvcnRlZCwgdXNpbmcnLCBfbWF4UHJlY2lzaW9uLCAnaW5zdGVhZC4nICk7XHJcbiAgICAgICAgdGhpcy5wcmVjaXNpb24gPSBfbWF4UHJlY2lzaW9uO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBpZiAoIHRoaXMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciApIHtcclxuXHJcbiAgICAgICAgdGhpcy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID0gISEgZXh0ZW5zaW9ucy5nZXQoICdFWFRfZnJhZ19kZXB0aCcgKTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMR2VvbWV0cmllcy5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuV2ViR0xHZW9tZXRyaWVzID0gZnVuY3Rpb24gKCBnbCwgcHJvcGVydGllcywgaW5mbyApIHtcclxuXHJcbiAgICB2YXIgZ2VvbWV0cmllcyA9IHt9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldCggb2JqZWN0ICkge1xyXG5cclxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XHJcblxyXG4gICAgICAgIGlmICggZ2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGdlb21ldHJpZXNbIGdlb21ldHJ5LmlkIF07XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2VvbWV0cnkuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbkdlb21ldHJ5RGlzcG9zZSApO1xyXG5cclxuICAgICAgICB2YXIgYnVmZmVyZ2VvbWV0cnk7XHJcblxyXG4gICAgICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcbiAgICAgICAgICAgIGJ1ZmZlcmdlb21ldHJ5ID0gZ2VvbWV0cnk7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGdlb21ldHJ5Ll9idWZmZXJHZW9tZXRyeSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGdlb21ldHJ5Ll9idWZmZXJHZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpLnNldEZyb21PYmplY3QoIG9iamVjdCApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYnVmZmVyZ2VvbWV0cnkgPSBnZW9tZXRyeS5fYnVmZmVyR2VvbWV0cnk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXSA9IGJ1ZmZlcmdlb21ldHJ5O1xyXG5cclxuICAgICAgICBpbmZvLm1lbW9yeS5nZW9tZXRyaWVzICsrO1xyXG5cclxuICAgICAgICByZXR1cm4gYnVmZmVyZ2VvbWV0cnk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG9uR2VvbWV0cnlEaXNwb3NlKCBldmVudCApIHtcclxuXHJcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gZXZlbnQudGFyZ2V0O1xyXG4gICAgICAgIHZhciBidWZmZXJnZW9tZXRyeSA9IGdlb21ldHJpZXNbIGdlb21ldHJ5LmlkIF07XHJcblxyXG4gICAgICAgIGRlbGV0ZUF0dHJpYnV0ZXMoIGJ1ZmZlcmdlb21ldHJ5LmF0dHJpYnV0ZXMgKTtcclxuXHJcbiAgICAgICAgZ2VvbWV0cnkucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbkdlb21ldHJ5RGlzcG9zZSApO1xyXG5cclxuICAgICAgICBkZWxldGUgZ2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXTtcclxuXHJcbiAgICAgICAgdmFyIHByb3BlcnR5ID0gcHJvcGVydGllcy5nZXQoIGdlb21ldHJ5ICk7XHJcbiAgICAgICAgaWYgKCBwcm9wZXJ0eS53aXJlZnJhbWUgKSBkZWxldGVBdHRyaWJ1dGUoIHByb3BlcnR5LndpcmVmcmFtZSApO1xyXG5cclxuICAgICAgICBpbmZvLm1lbW9yeS5nZW9tZXRyaWVzIC0tO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVCdWZmZXIoIGF0dHJpYnV0ZSApIHtcclxuXHJcbiAgICAgICAgaWYgKCBhdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0aWVzLmdldCggYXR0cmlidXRlLmRhdGEgKS5fX3dlYmdsQnVmZmVyO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzLmdldCggYXR0cmlidXRlICkuX193ZWJnbEJ1ZmZlcjtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGVsZXRlQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XHJcblxyXG4gICAgICAgIHZhciBidWZmZXIgPSBnZXRBdHRyaWJ1dGVCdWZmZXIoIGF0dHJpYnV0ZSApO1xyXG5cclxuICAgICAgICBpZiAoIGJ1ZmZlciAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgZ2wuZGVsZXRlQnVmZmVyKCBidWZmZXIgKTtcclxuICAgICAgICAgICAgcmVtb3ZlQXR0cmlidXRlQnVmZmVyKCBhdHRyaWJ1dGUgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkZWxldGVBdHRyaWJ1dGVzKCBhdHRyaWJ1dGVzICkge1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xyXG5cclxuICAgICAgICAgICAgZGVsZXRlQXR0cmlidXRlKCBhdHRyaWJ1dGVzWyBuYW1lIF0gKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZW1vdmVBdHRyaWJ1dGVCdWZmZXIoIGF0dHJpYnV0ZSApIHtcclxuXHJcbiAgICAgICAgaWYgKCBhdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcclxuXHJcbiAgICAgICAgICAgIHByb3BlcnRpZXMuZGVsZXRlKCBhdHRyaWJ1dGUuZGF0YSApO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgcHJvcGVydGllcy5kZWxldGUoIGF0dHJpYnV0ZSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZ2V0ID0gZ2V0O1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTE9iamVjdHMuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLldlYkdMT2JqZWN0cyA9IGZ1bmN0aW9uICggZ2wsIHByb3BlcnRpZXMsIGluZm8gKSB7XHJcblxyXG4gICAgdmFyIGdlb21ldHJpZXMgPSBuZXcgVEhSRUUuV2ViR0xHZW9tZXRyaWVzKCBnbCwgcHJvcGVydGllcywgaW5mbyApO1xyXG5cclxuICAgIC8vXHJcblxyXG4gICAgZnVuY3Rpb24gdXBkYXRlKCBvYmplY3QgKSB7XHJcblxyXG4gICAgICAgIC8vIFRPRE86IEF2b2lkIHVwZGF0aW5nIHR3aWNlICh3aGVuIHVzaW5nIHNoYWRvd01hcCkuIE1heWJlIGFkZCBmcmFtZSBjb3VudGVyLlxyXG5cclxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBnZW9tZXRyaWVzLmdldCggb2JqZWN0ICk7XHJcblxyXG4gICAgICAgIGlmICggb2JqZWN0Lmdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XHJcblxyXG4gICAgICAgICAgICBnZW9tZXRyeS51cGRhdGVGcm9tT2JqZWN0KCBvYmplY3QgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcclxuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XHJcblxyXG4gICAgICAgIGlmICggaW5kZXggIT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICB1cGRhdGVBdHRyaWJ1dGUoIGluZGV4LCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XHJcblxyXG4gICAgICAgICAgICB1cGRhdGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXNbIG5hbWUgXSwgZ2wuQVJSQVlfQlVGRkVSICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gbW9ycGggdGFyZ2V0c1xyXG5cclxuICAgICAgICB2YXIgbW9ycGhBdHRyaWJ1dGVzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgbmFtZSBpbiBtb3JwaEF0dHJpYnV0ZXMgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBtb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdXBkYXRlQXR0cmlidXRlKCBhcnJheVsgaSBdLCBnbC5BUlJBWV9CVUZGRVIgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZ2VvbWV0cnk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlLCBidWZmZXJUeXBlICkge1xyXG5cclxuICAgICAgICB2YXIgZGF0YSA9ICggYXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSA/IGF0dHJpYnV0ZS5kYXRhIDogYXR0cmlidXRlO1xyXG5cclxuICAgICAgICB2YXIgYXR0cmlidXRlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCBkYXRhICk7XHJcblxyXG4gICAgICAgIGlmICggYXR0cmlidXRlUHJvcGVydGllcy5fX3dlYmdsQnVmZmVyID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBjcmVhdGVCdWZmZXIoIGF0dHJpYnV0ZVByb3BlcnRpZXMsIGRhdGEsIGJ1ZmZlclR5cGUgKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICggYXR0cmlidXRlUHJvcGVydGllcy52ZXJzaW9uICE9PSBkYXRhLnZlcnNpb24gKSB7XHJcblxyXG4gICAgICAgICAgICB1cGRhdGVCdWZmZXIoIGF0dHJpYnV0ZVByb3BlcnRpZXMsIGRhdGEsIGJ1ZmZlclR5cGUgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVCdWZmZXIoIGF0dHJpYnV0ZVByb3BlcnRpZXMsIGRhdGEsIGJ1ZmZlclR5cGUgKSB7XHJcblxyXG4gICAgICAgIGF0dHJpYnV0ZVByb3BlcnRpZXMuX193ZWJnbEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoIGJ1ZmZlclR5cGUsIGF0dHJpYnV0ZVByb3BlcnRpZXMuX193ZWJnbEJ1ZmZlciApO1xyXG5cclxuICAgICAgICB2YXIgdXNhZ2UgPSBkYXRhLmR5bmFtaWMgPyBnbC5EWU5BTUlDX0RSQVcgOiBnbC5TVEFUSUNfRFJBVztcclxuXHJcbiAgICAgICAgZ2wuYnVmZmVyRGF0YSggYnVmZmVyVHlwZSwgZGF0YS5hcnJheSwgdXNhZ2UgKTtcclxuXHJcbiAgICAgICAgYXR0cmlidXRlUHJvcGVydGllcy52ZXJzaW9uID0gZGF0YS52ZXJzaW9uO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVCdWZmZXIoIGF0dHJpYnV0ZVByb3BlcnRpZXMsIGRhdGEsIGJ1ZmZlclR5cGUgKSB7XHJcblxyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoIGJ1ZmZlclR5cGUsIGF0dHJpYnV0ZVByb3BlcnRpZXMuX193ZWJnbEJ1ZmZlciApO1xyXG5cclxuICAgICAgICBpZiAoIGRhdGEuZHluYW1pYyA9PT0gZmFsc2UgfHwgZGF0YS51cGRhdGVSYW5nZS5jb3VudCA9PT0gLSAxICkge1xyXG5cclxuICAgICAgICAgICAgLy8gTm90IHVzaW5nIHVwZGF0ZSByYW5nZXNcclxuXHJcbiAgICAgICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoIGJ1ZmZlclR5cGUsIDAsIGRhdGEuYXJyYXkgKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICggZGF0YS51cGRhdGVSYW5nZS5jb3VudCA9PT0gMCApIHtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTE9iamVjdHMudXBkYXRlQnVmZmVyOiBkeW5hbWljIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSBtYXJrZWQgYXMgbmVlZHNVcGRhdGUgYnV0IHVwZGF0ZVJhbmdlLmNvdW50IGlzIDAsIGVuc3VyZSB5b3UgYXJlIHVzaW5nIHNldCBtZXRob2RzIG9yIHVwZGF0aW5nIG1hbnVhbGx5LicgKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoIGJ1ZmZlclR5cGUsIGRhdGEudXBkYXRlUmFuZ2Uub2Zmc2V0ICogZGF0YS5hcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcclxuICAgICAgICAgICAgICAgIGRhdGEuYXJyYXkuc3ViYXJyYXkoIGRhdGEudXBkYXRlUmFuZ2Uub2Zmc2V0LCBkYXRhLnVwZGF0ZVJhbmdlLm9mZnNldCArIGRhdGEudXBkYXRlUmFuZ2UuY291bnQgKSApO1xyXG5cclxuICAgICAgICAgICAgZGF0YS51cGRhdGVSYW5nZS5jb3VudCA9IDA7IC8vIHJlc2V0IHJhbmdlXHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYXR0cmlidXRlUHJvcGVydGllcy52ZXJzaW9uID0gZGF0YS52ZXJzaW9uO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVCdWZmZXIoIGF0dHJpYnV0ZSApIHtcclxuXHJcbiAgICAgICAgaWYgKCBhdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0aWVzLmdldCggYXR0cmlidXRlLmRhdGEgKS5fX3dlYmdsQnVmZmVyO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzLmdldCggYXR0cmlidXRlICkuX193ZWJnbEJ1ZmZlcjtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0V2lyZWZyYW1lQXR0cmlidXRlKCBnZW9tZXRyeSApIHtcclxuXHJcbiAgICAgICAgdmFyIHByb3BlcnR5ID0gcHJvcGVydGllcy5nZXQoIGdlb21ldHJ5ICk7XHJcblxyXG4gICAgICAgIGlmICggcHJvcGVydHkud2lyZWZyYW1lICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcHJvcGVydHkud2lyZWZyYW1lO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBpbmRpY2VzID0gW107XHJcblxyXG4gICAgICAgIHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xyXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcclxuICAgICAgICB2YXIgcG9zaXRpb24gPSBhdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cclxuICAgICAgICAvLyBjb25zb2xlLnRpbWUoICd3aXJlZnJhbWUnICk7XHJcblxyXG4gICAgICAgIGlmICggaW5kZXggIT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgZWRnZXMgPSB7fTtcclxuICAgICAgICAgICAgdmFyIGFycmF5ID0gaW5kZXguYXJyYXk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpICs9IDMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGEgPSBhcnJheVsgaSArIDAgXTtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gYXJyYXlbIGkgKyAxIF07XHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGFycmF5WyBpICsgMiBdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggY2hlY2tFZGdlKCBlZGdlcywgYSwgYiApICkgaW5kaWNlcy5wdXNoKCBhLCBiICk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIGNoZWNrRWRnZSggZWRnZXMsIGIsIGMgKSApIGluZGljZXMucHVzaCggYiwgYyApO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBjaGVja0VkZ2UoIGVkZ2VzLCBjLCBhICkgKSBpbmRpY2VzLnB1c2goIGMsIGEgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBhcnJheSA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSAoIGFycmF5Lmxlbmd0aCAvIDMgKSAtIDE7IGkgPCBsOyBpICs9IDMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGEgPSBpICsgMDtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gaSArIDE7XHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGkgKyAyO1xyXG5cclxuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaCggYSwgYiwgYiwgYywgYywgYSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUudGltZUVuZCggJ3dpcmVmcmFtZScgKTtcclxuXHJcbiAgICAgICAgdmFyIFR5cGVBcnJheSA9IHBvc2l0aW9uLmNvdW50ID4gNjU1MzUgPyBVaW50MzJBcnJheSA6IFVpbnQxNkFycmF5O1xyXG4gICAgICAgIHZhciBhdHRyaWJ1dGUgPSBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgVHlwZUFycmF5KCBpbmRpY2VzICksIDEgKTtcclxuXHJcbiAgICAgICAgdXBkYXRlQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSICk7XHJcblxyXG4gICAgICAgIHByb3BlcnR5LndpcmVmcmFtZSA9IGF0dHJpYnV0ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2hlY2tFZGdlKCBlZGdlcywgYSwgYiApIHtcclxuXHJcbiAgICAgICAgaWYgKCBhID4gYiApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciB0bXAgPSBhO1xyXG4gICAgICAgICAgICBhID0gYjtcclxuICAgICAgICAgICAgYiA9IHRtcDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbGlzdCA9IGVkZ2VzWyBhIF07XHJcblxyXG4gICAgICAgIGlmICggbGlzdCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgZWRnZXNbIGEgXSA9IFsgYiBdO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICggbGlzdC5pbmRleE9mKCBiICkgPT09IC0xICkge1xyXG5cclxuICAgICAgICAgICAgbGlzdC5wdXNoKCBiICk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5nZXRBdHRyaWJ1dGVCdWZmZXIgPSBnZXRBdHRyaWJ1dGVCdWZmZXI7XHJcbiAgICB0aGlzLmdldFdpcmVmcmFtZUF0dHJpYnV0ZSA9IGdldFdpcmVmcmFtZUF0dHJpYnV0ZTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZSA9IHVwZGF0ZTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xQcm9ncmFtLmpzXHJcblxyXG5USFJFRS5XZWJHTFByb2dyYW0gPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgcHJvZ3JhbUlkQ291bnQgPSAwO1xyXG5cclxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlRGVmaW5lcyggZGVmaW5lcyApIHtcclxuXHJcbiAgICAgICAgdmFyIGNodW5rcyA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgbmFtZSBpbiBkZWZpbmVzICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gZGVmaW5lc1sgbmFtZSBdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKCAnI2RlZmluZSAnICsgbmFtZSArICcgJyArIHZhbHVlICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNodW5rcy5qb2luKCAnXFxuJyApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBmZXRjaFVuaWZvcm1Mb2NhdGlvbnMoIGdsLCBwcm9ncmFtLCBpZGVudGlmaWVycyApIHtcclxuXHJcbiAgICAgICAgdmFyIHVuaWZvcm1zID0ge307XHJcblxyXG4gICAgICAgIHZhciBuID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuQUNUSVZFX1VOSUZPUk1TICk7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG47IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgaW5mbyA9IGdsLmdldEFjdGl2ZVVuaWZvcm0oIHByb2dyYW0sIGkgKTtcclxuICAgICAgICAgICAgdmFyIG5hbWUgPSBpbmZvLm5hbWU7XHJcbiAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgbmFtZSApO1xyXG5cclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJUSFJFRS5XZWJHTFByb2dyYW06IEFDVElWRSBVTklGT1JNOlwiLCBuYW1lKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBzdWZmaXhQb3MgPSBuYW1lLmxhc3RJbmRleE9mKCAnWzBdJyApO1xyXG4gICAgICAgICAgICBpZiAoIHN1ZmZpeFBvcyAhPT0gLSAxICYmIHN1ZmZpeFBvcyA9PT0gbmFtZS5sZW5ndGggLSAzICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHVuaWZvcm1zWyBuYW1lLnN1YnN0ciggMCwgc3VmZml4UG9zICkgXSA9IGxvY2F0aW9uO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdW5pZm9ybXNbIG5hbWUgXSA9IGxvY2F0aW9uO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB1bmlmb3JtcztcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZmV0Y2hBdHRyaWJ1dGVMb2NhdGlvbnMoIGdsLCBwcm9ncmFtLCBpZGVudGlmaWVycyApIHtcclxuXHJcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTtcclxuXHJcbiAgICAgICAgdmFyIG4gPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBnbC5BQ1RJVkVfQVRUUklCVVRFUyApO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBuOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGluZm8gPSBnbC5nZXRBY3RpdmVBdHRyaWIoIHByb2dyYW0sIGkgKTtcclxuICAgICAgICAgICAgdmFyIG5hbWUgPSBpbmZvLm5hbWU7XHJcblxyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlRIUkVFLldlYkdMUHJvZ3JhbTogQUNUSVZFIFZFUlRFWCBBVFRSSUJVVEU6XCIsIG5hbWUsIGkgKTtcclxuXHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNbIG5hbWUgXSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCBuYW1lICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGZpbHRlckVtcHR5TGluZSggc3RyaW5nICkge1xyXG5cclxuICAgICAgICByZXR1cm4gc3RyaW5nICE9PSAnJztcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIFdlYkdMUHJvZ3JhbSggcmVuZGVyZXIsIGNvZGUsIG1hdGVyaWFsLCBwYXJhbWV0ZXJzICkge1xyXG5cclxuICAgICAgICB2YXIgZ2wgPSByZW5kZXJlci5jb250ZXh0O1xyXG5cclxuICAgICAgICB2YXIgZGVmaW5lcyA9IG1hdGVyaWFsLmRlZmluZXM7XHJcblxyXG4gICAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLnZlcnRleFNoYWRlcjtcclxuICAgICAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLmZyYWdtZW50U2hhZGVyO1xyXG5cclxuICAgICAgICB2YXIgc2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9CQVNJQyc7XHJcblxyXG4gICAgICAgIGlmICggcGFyYW1ldGVycy5zaGFkb3dNYXBUeXBlID09PSBUSFJFRS5QQ0ZTaGFkb3dNYXAgKSB7XHJcblxyXG4gICAgICAgICAgICBzaGFkb3dNYXBUeXBlRGVmaW5lID0gJ1NIQURPV01BUF9UWVBFX1BDRic7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIHBhcmFtZXRlcnMuc2hhZG93TWFwVHlwZSA9PT0gVEhSRUUuUENGU29mdFNoYWRvd01hcCApIHtcclxuXHJcbiAgICAgICAgICAgIHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQnO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0NVQkUnO1xyXG4gICAgICAgIHZhciBlbnZNYXBNb2RlRGVmaW5lID0gJ0VOVk1BUF9NT0RFX1JFRkxFQ1RJT04nO1xyXG4gICAgICAgIHZhciBlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfTVVMVElQTFknO1xyXG5cclxuICAgICAgICBpZiAoIHBhcmFtZXRlcnMuZW52TWFwICkge1xyXG5cclxuICAgICAgICAgICAgc3dpdGNoICggbWF0ZXJpYWwuZW52TWFwLm1hcHBpbmcgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5DdWJlUmVmbGVjdGlvbk1hcHBpbmc6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLkN1YmVSZWZyYWN0aW9uTWFwcGluZzpcclxuICAgICAgICAgICAgICAgICAgICBlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0NVQkUnO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmc6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLkVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nOlxyXG4gICAgICAgICAgICAgICAgICAgIGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfRVFVSVJFQyc7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5TcGhlcmljYWxSZWZsZWN0aW9uTWFwcGluZzpcclxuICAgICAgICAgICAgICAgICAgICBlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX1NQSEVSRSc7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKCBtYXRlcmlhbC5lbnZNYXAubWFwcGluZyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLkN1YmVSZWZyYWN0aW9uTWFwcGluZzpcclxuICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmc6XHJcbiAgICAgICAgICAgICAgICAgICAgZW52TWFwTW9kZURlZmluZSA9ICdFTlZNQVBfTU9ERV9SRUZSQUNUSU9OJztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHN3aXRjaCAoIG1hdGVyaWFsLmNvbWJpbmUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5NdWx0aXBseU9wZXJhdGlvbjpcclxuICAgICAgICAgICAgICAgICAgICBlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfTVVMVElQTFknO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuTWl4T3BlcmF0aW9uOlxyXG4gICAgICAgICAgICAgICAgICAgIGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19NSVgnO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuQWRkT3BlcmF0aW9uOlxyXG4gICAgICAgICAgICAgICAgICAgIGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19BREQnO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBnYW1tYUZhY3RvckRlZmluZSA9ICggcmVuZGVyZXIuZ2FtbWFGYWN0b3IgPiAwICkgPyByZW5kZXJlci5nYW1tYUZhY3RvciA6IDEuMDtcclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coICdidWlsZGluZyBuZXcgcHJvZ3JhbSAnICk7XHJcblxyXG4gICAgICAgIC8vXHJcblxyXG4gICAgICAgIHZhciBjdXN0b21EZWZpbmVzID0gZ2VuZXJhdGVEZWZpbmVzKCBkZWZpbmVzICk7XHJcblxyXG4gICAgICAgIC8vXHJcblxyXG4gICAgICAgIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG5cclxuICAgICAgICB2YXIgcHJlZml4VmVydGV4LCBwcmVmaXhGcmFnbWVudDtcclxuXHJcbiAgICAgICAgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLlJhd1NoYWRlck1hdGVyaWFsICkge1xyXG5cclxuICAgICAgICAgICAgcHJlZml4VmVydGV4ID0gJyc7XHJcbiAgICAgICAgICAgIHByZWZpeEZyYWdtZW50ID0gJyc7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICBwcmVmaXhWZXJ0ZXggPSBbXHJcblxyXG4gICAgICAgICAgICAgICAgJ3ByZWNpc2lvbiAnICsgcGFyYW1ldGVycy5wcmVjaXNpb24gKyAnIGZsb2F0OycsXHJcbiAgICAgICAgICAgICAgICAncHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgaW50OycsXHJcblxyXG4gICAgICAgICAgICAgICAgJyNkZWZpbmUgU0hBREVSX05BTUUgJyArIG1hdGVyaWFsLl9fd2ViZ2xTaGFkZXIubmFtZSxcclxuXHJcbiAgICAgICAgICAgICAgICBjdXN0b21EZWZpbmVzLFxyXG5cclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA/ICcjZGVmaW5lIFZFUlRFWF9URVhUVVJFUycgOiAnJyxcclxuXHJcbiAgICAgICAgICAgICAgICByZW5kZXJlci5nYW1tYUlucHV0ID8gJyNkZWZpbmUgR0FNTUFfSU5QVVQnIDogJycsXHJcbiAgICAgICAgICAgICAgICByZW5kZXJlci5nYW1tYU91dHB1dCA/ICcjZGVmaW5lIEdBTU1BX09VVFBVVCcgOiAnJyxcclxuICAgICAgICAgICAgICAgICcjZGVmaW5lIEdBTU1BX0ZBQ1RPUiAnICsgZ2FtbWFGYWN0b3JEZWZpbmUsXHJcblxyXG4gICAgICAgICAgICAgICAgJyNkZWZpbmUgTUFYX0RJUl9MSUdIVFMgJyArIHBhcmFtZXRlcnMubWF4RGlyTGlnaHRzLFxyXG4gICAgICAgICAgICAgICAgJyNkZWZpbmUgTUFYX1BPSU5UX0xJR0hUUyAnICsgcGFyYW1ldGVycy5tYXhQb2ludExpZ2h0cyxcclxuICAgICAgICAgICAgICAgICcjZGVmaW5lIE1BWF9TUE9UX0xJR0hUUyAnICsgcGFyYW1ldGVycy5tYXhTcG90TGlnaHRzLFxyXG4gICAgICAgICAgICAgICAgJyNkZWZpbmUgTUFYX0hFTUlfTElHSFRTICcgKyBwYXJhbWV0ZXJzLm1heEhlbWlMaWdodHMsXHJcblxyXG4gICAgICAgICAgICAgICAgJyNkZWZpbmUgTUFYX1NIQURPV1MgJyArIHBhcmFtZXRlcnMubWF4U2hhZG93cyxcclxuXHJcbiAgICAgICAgICAgICAgICAnI2RlZmluZSBNQVhfQk9ORVMgJyArIHBhcmFtZXRlcnMubWF4Qm9uZXMsXHJcblxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5tYXAgPyAnI2RlZmluZSBVU0VfTUFQJyA6ICcnLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSBVU0VfRU5WTUFQJyA6ICcnLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwTW9kZURlZmluZSA6ICcnLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5saWdodE1hcCA/ICcjZGVmaW5lIFVTRV9MSUdIVE1BUCcgOiAnJyxcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuYW9NYXAgPyAnI2RlZmluZSBVU0VfQU9NQVAnIDogJycsXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmVtaXNzaXZlTWFwID8gJyNkZWZpbmUgVVNFX0VNSVNTSVZFTUFQJyA6ICcnLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5idW1wTWFwID8gJyNkZWZpbmUgVVNFX0JVTVBNQVAnIDogJycsXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLm5vcm1hbE1hcCA/ICcjZGVmaW5lIFVTRV9OT1JNQUxNQVAnIDogJycsXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmRpc3BsYWNlbWVudE1hcCAmJiBwYXJhbWV0ZXJzLnN1cHBvcnRzVmVydGV4VGV4dHVyZXMgPyAnI2RlZmluZSBVU0VfRElTUExBQ0VNRU5UTUFQJyA6ICcnLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5zcGVjdWxhck1hcCA/ICcjZGVmaW5lIFVTRV9TUEVDVUxBUk1BUCcgOiAnJyxcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuYWxwaGFNYXAgPyAnI2RlZmluZSBVU0VfQUxQSEFNQVAnIDogJycsXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLnZlcnRleENvbG9ycyA/ICcjZGVmaW5lIFVTRV9DT0xPUicgOiAnJyxcclxuXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nID8gJyNkZWZpbmUgRkxBVF9TSEFERUQnIDogJycsXHJcblxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5za2lubmluZyA/ICcjZGVmaW5lIFVTRV9TS0lOTklORycgOiAnJyxcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMudXNlVmVydGV4VGV4dHVyZSA/ICcjZGVmaW5lIEJPTkVfVEVYVFVSRScgOiAnJyxcclxuXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0cyA/ICcjZGVmaW5lIFVTRV9NT1JQSFRBUkdFVFMnIDogJycsXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLm1vcnBoTm9ybWFscyAmJiBwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nID09PSBmYWxzZSA/ICcjZGVmaW5lIFVTRV9NT1JQSE5PUk1BTFMnIDogJycsXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmRvdWJsZVNpZGVkID8gJyNkZWZpbmUgRE9VQkxFX1NJREVEJyA6ICcnLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5mbGlwU2lkZWQgPyAnI2RlZmluZSBGTElQX1NJREVEJyA6ICcnLFxyXG5cclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lIFVTRV9TSEFET1dNQVAnIDogJycsXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSAnICsgc2hhZG93TWFwVHlwZURlZmluZSA6ICcnLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5zaGFkb3dNYXBEZWJ1ZyA/ICcjZGVmaW5lIFNIQURPV01BUF9ERUJVRycgOiAnJyxcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMucG9pbnRMaWdodFNoYWRvd3MgPiAwID8gJyNkZWZpbmUgUE9JTlRfTElHSFRfU0hBRE9XUycgOiAnJyxcclxuXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLnNpemVBdHRlbnVhdGlvbiA/ICcjZGVmaW5lIFVTRV9TSVpFQVRURU5VQVRJT04nIDogJycsXHJcblxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGJyA6ICcnLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICYmIHJlbmRlcmVyLmV4dGVuc2lvbnMuZ2V0KCAnRVhUX2ZyYWdfZGVwdGgnICkgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUZfRVhUJyA6ICcnLFxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAndW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4OycsXHJcbiAgICAgICAgICAgICAgICAndW5pZm9ybSBtYXQ0IG1vZGVsVmlld01hdHJpeDsnLFxyXG4gICAgICAgICAgICAgICAgJ3VuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4OycsXHJcbiAgICAgICAgICAgICAgICAndW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7JyxcclxuICAgICAgICAgICAgICAgICd1bmlmb3JtIG1hdDMgbm9ybWFsTWF0cml4OycsXHJcbiAgICAgICAgICAgICAgICAndW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uOycsXHJcblxyXG4gICAgICAgICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uOycsXHJcbiAgICAgICAgICAgICAgICAnYXR0cmlidXRlIHZlYzMgbm9ybWFsOycsXHJcbiAgICAgICAgICAgICAgICAnYXR0cmlidXRlIHZlYzIgdXY7JyxcclxuXHJcbiAgICAgICAgICAgICAgICAnI2lmZGVmIFVTRV9DT0xPUicsXHJcblxyXG4gICAgICAgICAgICAgICAgJ1x0YXR0cmlidXRlIHZlYzMgY29sb3I7JyxcclxuXHJcbiAgICAgICAgICAgICAgICAnI2VuZGlmJyxcclxuXHJcbiAgICAgICAgICAgICAgICAnI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFMnLFxyXG5cclxuICAgICAgICAgICAgICAgICdcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MDsnLFxyXG4gICAgICAgICAgICAgICAgJ1x0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQxOycsXHJcbiAgICAgICAgICAgICAgICAnXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDI7JyxcclxuICAgICAgICAgICAgICAgICdcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MzsnLFxyXG5cclxuICAgICAgICAgICAgICAgICdcdCNpZmRlZiBVU0VfTU9SUEhOT1JNQUxTJyxcclxuXHJcbiAgICAgICAgICAgICAgICAnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMDsnLFxyXG4gICAgICAgICAgICAgICAgJ1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDE7JyxcclxuICAgICAgICAgICAgICAgICdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwyOycsXHJcbiAgICAgICAgICAgICAgICAnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMzsnLFxyXG5cclxuICAgICAgICAgICAgICAgICdcdCNlbHNlJyxcclxuXHJcbiAgICAgICAgICAgICAgICAnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NDsnLFxyXG4gICAgICAgICAgICAgICAgJ1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDU7JyxcclxuICAgICAgICAgICAgICAgICdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ2OycsXHJcbiAgICAgICAgICAgICAgICAnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NzsnLFxyXG5cclxuICAgICAgICAgICAgICAgICdcdCNlbmRpZicsXHJcblxyXG4gICAgICAgICAgICAgICAgJyNlbmRpZicsXHJcblxyXG4gICAgICAgICAgICAgICAgJyNpZmRlZiBVU0VfU0tJTk5JTkcnLFxyXG5cclxuICAgICAgICAgICAgICAgICdcdGF0dHJpYnV0ZSB2ZWM0IHNraW5JbmRleDsnLFxyXG4gICAgICAgICAgICAgICAgJ1x0YXR0cmlidXRlIHZlYzQgc2tpbldlaWdodDsnLFxyXG5cclxuICAgICAgICAgICAgICAgICcjZW5kaWYnLFxyXG5cclxuICAgICAgICAgICAgICAgICdcXG4nXHJcblxyXG4gICAgICAgICAgICBdLmZpbHRlciggZmlsdGVyRW1wdHlMaW5lICkuam9pbiggJ1xcbicgKTtcclxuXHJcbiAgICAgICAgICAgIHByZWZpeEZyYWdtZW50ID0gW1xyXG5cclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuYnVtcE1hcCB8fCBwYXJhbWV0ZXJzLm5vcm1hbE1hcCB8fCBwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nIHx8IG1hdGVyaWFsLmRlcml2YXRpdmVzID8gJyNleHRlbnNpb24gR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzIDogZW5hYmxlJyA6ICcnLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICYmIHJlbmRlcmVyLmV4dGVuc2lvbnMuZ2V0KCAnRVhUX2ZyYWdfZGVwdGgnICkgPyAnI2V4dGVuc2lvbiBHTF9FWFRfZnJhZ19kZXB0aCA6IGVuYWJsZScgOiAnJyxcclxuXHJcbiAgICAgICAgICAgICAgICAncHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgZmxvYXQ7JyxcclxuICAgICAgICAgICAgICAgICdwcmVjaXNpb24gJyArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgJyBpbnQ7JyxcclxuXHJcbiAgICAgICAgICAgICAgICAnI2RlZmluZSBTSEFERVJfTkFNRSAnICsgbWF0ZXJpYWwuX193ZWJnbFNoYWRlci5uYW1lLFxyXG5cclxuICAgICAgICAgICAgICAgIGN1c3RvbURlZmluZXMsXHJcblxyXG4gICAgICAgICAgICAgICAgJyNkZWZpbmUgTUFYX0RJUl9MSUdIVFMgJyArIHBhcmFtZXRlcnMubWF4RGlyTGlnaHRzLFxyXG4gICAgICAgICAgICAgICAgJyNkZWZpbmUgTUFYX1BPSU5UX0xJR0hUUyAnICsgcGFyYW1ldGVycy5tYXhQb2ludExpZ2h0cyxcclxuICAgICAgICAgICAgICAgICcjZGVmaW5lIE1BWF9TUE9UX0xJR0hUUyAnICsgcGFyYW1ldGVycy5tYXhTcG90TGlnaHRzLFxyXG4gICAgICAgICAgICAgICAgJyNkZWZpbmUgTUFYX0hFTUlfTElHSFRTICcgKyBwYXJhbWV0ZXJzLm1heEhlbWlMaWdodHMsXHJcblxyXG4gICAgICAgICAgICAgICAgJyNkZWZpbmUgTUFYX1NIQURPV1MgJyArIHBhcmFtZXRlcnMubWF4U2hhZG93cyxcclxuXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmFscGhhVGVzdCA/ICcjZGVmaW5lIEFMUEhBVEVTVCAnICsgcGFyYW1ldGVycy5hbHBoYVRlc3QgOiAnJyxcclxuXHJcbiAgICAgICAgICAgICAgICByZW5kZXJlci5nYW1tYUlucHV0ID8gJyNkZWZpbmUgR0FNTUFfSU5QVVQnIDogJycsXHJcbiAgICAgICAgICAgICAgICByZW5kZXJlci5nYW1tYU91dHB1dCA/ICcjZGVmaW5lIEdBTU1BX09VVFBVVCcgOiAnJyxcclxuICAgICAgICAgICAgICAgICcjZGVmaW5lIEdBTU1BX0ZBQ1RPUiAnICsgZ2FtbWFGYWN0b3JEZWZpbmUsXHJcblxyXG4gICAgICAgICAgICAgICAgKCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZyApID8gJyNkZWZpbmUgVVNFX0ZPRycgOiAnJyxcclxuICAgICAgICAgICAgICAgICggcGFyYW1ldGVycy51c2VGb2cgJiYgcGFyYW1ldGVycy5mb2dFeHAgKSA/ICcjZGVmaW5lIEZPR19FWFAyJyA6ICcnLFxyXG5cclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMubWFwID8gJyNkZWZpbmUgVVNFX01BUCcgOiAnJyxcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgVVNFX0VOVk1BUCcgOiAnJyxcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcFR5cGVEZWZpbmUgOiAnJyxcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcE1vZGVEZWZpbmUgOiAnJyxcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcEJsZW5kaW5nRGVmaW5lIDogJycsXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmxpZ2h0TWFwID8gJyNkZWZpbmUgVVNFX0xJR0hUTUFQJyA6ICcnLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5hb01hcCA/ICcjZGVmaW5lIFVTRV9BT01BUCcgOiAnJyxcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuZW1pc3NpdmVNYXAgPyAnI2RlZmluZSBVU0VfRU1JU1NJVkVNQVAnIDogJycsXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmJ1bXBNYXAgPyAnI2RlZmluZSBVU0VfQlVNUE1BUCcgOiAnJyxcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMubm9ybWFsTWFwID8gJyNkZWZpbmUgVVNFX05PUk1BTE1BUCcgOiAnJyxcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuc3BlY3VsYXJNYXAgPyAnI2RlZmluZSBVU0VfU1BFQ1VMQVJNQVAnIDogJycsXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmFscGhhTWFwID8gJyNkZWZpbmUgVVNFX0FMUEhBTUFQJyA6ICcnLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy52ZXJ0ZXhDb2xvcnMgPyAnI2RlZmluZSBVU0VfQ09MT1InIDogJycsXHJcblxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5mbGF0U2hhZGluZyA/ICcjZGVmaW5lIEZMQVRfU0hBREVEJyA6ICcnLFxyXG5cclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMubWV0YWwgPyAnI2RlZmluZSBNRVRBTCcgOiAnJyxcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuZG91YmxlU2lkZWQgPyAnI2RlZmluZSBET1VCTEVfU0lERUQnIDogJycsXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmZsaXBTaWRlZCA/ICcjZGVmaW5lIEZMSVBfU0lERUQnIDogJycsXHJcblxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkID8gJyNkZWZpbmUgVVNFX1NIQURPV01BUCcgOiAnJyxcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lICcgKyBzaGFkb3dNYXBUeXBlRGVmaW5lIDogJycsXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLnNoYWRvd01hcERlYnVnID8gJyNkZWZpbmUgU0hBRE9XTUFQX0RFQlVHJyA6ICcnLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5wb2ludExpZ2h0U2hhZG93cyA+IDAgPyAnI2RlZmluZSBQT0lOVF9MSUdIVF9TSEFET1dTJyA6ICcnLFxyXG5cclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA/ICcjZGVmaW5lIFVTRV9MT0dERVBUSEJVRicgOiAnJyxcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAmJiByZW5kZXJlci5leHRlbnNpb25zLmdldCggJ0VYVF9mcmFnX2RlcHRoJyApID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGX0VYVCcgOiAnJyxcclxuXHJcbiAgICAgICAgICAgICAgICAndW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7JyxcclxuICAgICAgICAgICAgICAgICd1bmlmb3JtIHZlYzMgY2FtZXJhUG9zaXRpb247JyxcclxuXHJcbiAgICAgICAgICAgICAgICAnXFxuJ1xyXG5cclxuICAgICAgICAgICAgXS5maWx0ZXIoIGZpbHRlckVtcHR5TGluZSApLmpvaW4oICdcXG4nICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHZlcnRleEdsc2wgPSBwcmVmaXhWZXJ0ZXggKyB2ZXJ0ZXhTaGFkZXI7XHJcbiAgICAgICAgdmFyIGZyYWdtZW50R2xzbCA9IHByZWZpeEZyYWdtZW50ICsgZnJhZ21lbnRTaGFkZXI7XHJcblxyXG4gICAgICAgIHZhciBnbFZlcnRleFNoYWRlciA9IFRIUkVFLldlYkdMU2hhZGVyKCBnbCwgZ2wuVkVSVEVYX1NIQURFUiwgdmVydGV4R2xzbCApO1xyXG4gICAgICAgIHZhciBnbEZyYWdtZW50U2hhZGVyID0gVEhSRUUuV2ViR0xTaGFkZXIoIGdsLCBnbC5GUkFHTUVOVF9TSEFERVIsIGZyYWdtZW50R2xzbCApO1xyXG5cclxuICAgICAgICBnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGdsVmVydGV4U2hhZGVyICk7XHJcbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBnbEZyYWdtZW50U2hhZGVyICk7XHJcblxyXG4gICAgICAgIC8vIEZvcmNlIGEgcGFydGljdWxhciBhdHRyaWJ1dGUgdG8gaW5kZXggMC5cclxuXHJcbiAgICAgICAgaWYgKCBtYXRlcmlhbC5pbmRleDBBdHRyaWJ1dGVOYW1lICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBnbC5iaW5kQXR0cmliTG9jYXRpb24oIHByb2dyYW0sIDAsIG1hdGVyaWFsLmluZGV4MEF0dHJpYnV0ZU5hbWUgKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICggcGFyYW1ldGVycy5tb3JwaFRhcmdldHMgPT09IHRydWUgKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBwcm9ncmFtcyB3aXRoIG1vcnBoVGFyZ2V0cyBkaXNwbGFjZSBwb3NpdGlvbiBvdXQgb2YgYXR0cmlidXRlIDBcclxuICAgICAgICAgICAgZ2wuYmluZEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCAwLCAncG9zaXRpb24nICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2wubGlua1Byb2dyYW0oIHByb2dyYW0gKTtcclxuXHJcbiAgICAgICAgdmFyIHByb2dyYW1Mb2cgPSBnbC5nZXRQcm9ncmFtSW5mb0xvZyggcHJvZ3JhbSApO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhMb2cgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKCBnbFZlcnRleFNoYWRlciApO1xyXG4gICAgICAgIHZhciBmcmFnbWVudExvZyA9IGdsLmdldFNoYWRlckluZm9Mb2coIGdsRnJhZ21lbnRTaGFkZXIgKTtcclxuXHJcbiAgICAgICAgdmFyIHJ1bm5hYmxlID0gdHJ1ZTtcclxuICAgICAgICB2YXIgaGF2ZURpYWdub3N0aWNzID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgaWYgKCBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUyApID09PSBmYWxzZSApIHtcclxuXHJcbiAgICAgICAgICAgIHJ1bm5hYmxlID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xQcm9ncmFtOiBzaGFkZXIgZXJyb3I6ICcsIGdsLmdldEVycm9yKCksICdnbC5WQUxJREFURV9TVEFUVVMnLCBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBnbC5WQUxJREFURV9TVEFUVVMgKSwgJ2dsLmdldFByb2dyYW1JbmZvTG9nJywgcHJvZ3JhbUxvZywgdmVydGV4TG9nLCBmcmFnbWVudExvZyApO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCBwcm9ncmFtTG9nICE9PSAnJyApIHtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUHJvZ3JhbTogZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coKScsIHByb2dyYW1Mb2cgKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICggdmVydGV4TG9nID09PSAnJyB8fCBmcmFnbWVudExvZyA9PT0gJycgKSB7XHJcblxyXG4gICAgICAgICAgICBoYXZlRGlhZ25vc3RpY3MgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIGhhdmVEaWFnbm9zdGljcyApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZGlhZ25vc3RpY3MgPSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcnVubmFibGU6IHJ1bm5hYmxlLFxyXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWw6IG1hdGVyaWFsLFxyXG5cclxuICAgICAgICAgICAgICAgIHByb2dyYW1Mb2c6IHByb2dyYW1Mb2csXHJcblxyXG4gICAgICAgICAgICAgICAgdmVydGV4U2hhZGVyOiB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxvZzogdmVydGV4TG9nLFxyXG4gICAgICAgICAgICAgICAgICAgIHByZWZpeDogcHJlZml4VmVydGV4XHJcblxyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBmcmFnbWVudFNoYWRlcjoge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsb2c6IGZyYWdtZW50TG9nLFxyXG4gICAgICAgICAgICAgICAgICAgIHByZWZpeDogcHJlZml4RnJhZ21lbnRcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNsZWFuIHVwXHJcblxyXG4gICAgICAgIGdsLmRlbGV0ZVNoYWRlciggZ2xWZXJ0ZXhTaGFkZXIgKTtcclxuICAgICAgICBnbC5kZWxldGVTaGFkZXIoIGdsRnJhZ21lbnRTaGFkZXIgKTtcclxuXHJcbiAgICAgICAgLy8gc2V0IHVwIGNhY2hpbmcgZm9yIHVuaWZvcm0gbG9jYXRpb25zXHJcblxyXG4gICAgICAgIHZhciBjYWNoZWRVbmlmb3JtcztcclxuXHJcbiAgICAgICAgdGhpcy5nZXRVbmlmb3JtcyA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBjYWNoZWRVbmlmb3JtcyA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNhY2hlZFVuaWZvcm1zID0gZmV0Y2hVbmlmb3JtTG9jYXRpb25zKCBnbCwgcHJvZ3JhbSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFVuaWZvcm1zO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBzZXQgdXAgY2FjaGluZyBmb3IgYXR0cmlidXRlIGxvY2F0aW9uc1xyXG5cclxuICAgICAgICB2YXIgY2FjaGVkQXR0cmlidXRlcztcclxuXHJcbiAgICAgICAgdGhpcy5nZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGNhY2hlZEF0dHJpYnV0ZXMgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjYWNoZWRBdHRyaWJ1dGVzID0gZmV0Y2hBdHRyaWJ1dGVMb2NhdGlvbnMoIGdsLCBwcm9ncmFtICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQXR0cmlidXRlcztcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gZnJlZSByZXNvdXJjZVxyXG5cclxuICAgICAgICB0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgICAgIGdsLmRlbGV0ZVByb2dyYW0oIHByb2dyYW0gKTtcclxuICAgICAgICAgICAgdGhpcy5wcm9ncmFtID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBERVBSRUNBVEVEXHJcblxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLCB7XHJcblxyXG4gICAgICAgICAgICB1bmlmb3Jtczoge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xQcm9ncmFtOiAudW5pZm9ybXMgaXMgbm93IC5nZXRVbmlmb3JtcygpLicgKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRVbmlmb3JtcygpO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUHJvZ3JhbTogLmF0dHJpYnV0ZXMgaXMgbm93IC5nZXRBdHRyaWJ1dGVzKCkuJyApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZXMoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSApO1xyXG5cclxuXHJcbiAgICAgICAgLy9cclxuXHJcbiAgICAgICAgdGhpcy5pZCA9IHByb2dyYW1JZENvdW50ICsrO1xyXG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XHJcbiAgICAgICAgdGhpcy51c2VkVGltZXMgPSAxO1xyXG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhTaGFkZXIgPSBnbFZlcnRleFNoYWRlcjtcclxuICAgICAgICB0aGlzLmZyYWdtZW50U2hhZGVyID0gZ2xGcmFnbWVudFNoYWRlcjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfTtcclxuXHJcbn0gKSgpO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMUHJvZ3JhbXMuanNcclxuXHJcblRIUkVFLldlYkdMUHJvZ3JhbXMgPSBmdW5jdGlvbiAoIHJlbmRlcmVyLCBjYXBhYmlsaXRpZXMgKSB7XHJcblxyXG4gICAgdmFyIHByb2dyYW1zID0gW107XHJcblxyXG4gICAgdmFyIHNoYWRlcklEcyA9IHtcclxuICAgICAgICBNZXNoRGVwdGhNYXRlcmlhbDogJ2RlcHRoJyxcclxuICAgICAgICBNZXNoTm9ybWFsTWF0ZXJpYWw6ICdub3JtYWwnLFxyXG4gICAgICAgIE1lc2hCYXNpY01hdGVyaWFsOiAnYmFzaWMnLFxyXG4gICAgICAgIE1lc2hMYW1iZXJ0TWF0ZXJpYWw6ICdsYW1iZXJ0JyxcclxuICAgICAgICBNZXNoUGhvbmdNYXRlcmlhbDogJ3Bob25nJyxcclxuICAgICAgICBMaW5lQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcclxuICAgICAgICBMaW5lRGFzaGVkTWF0ZXJpYWw6ICdkYXNoZWQnLFxyXG4gICAgICAgIFBvaW50c01hdGVyaWFsOiAncG9pbnRzJ1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgcGFyYW1ldGVyTmFtZXMgPSBbXHJcbiAgICAgICAgXCJwcmVjaXNpb25cIiwgXCJzdXBwb3J0c1ZlcnRleFRleHR1cmVzXCIsIFwibWFwXCIsIFwiZW52TWFwXCIsIFwiZW52TWFwTW9kZVwiLFxyXG4gICAgICAgIFwibGlnaHRNYXBcIiwgXCJhb01hcFwiLCBcImVtaXNzaXZlTWFwXCIsIFwiYnVtcE1hcFwiLCBcIm5vcm1hbE1hcFwiLCBcImRpc3BsYWNlbWVudE1hcFwiLCBcInNwZWN1bGFyTWFwXCIsXHJcbiAgICAgICAgXCJhbHBoYU1hcFwiLCBcImNvbWJpbmVcIiwgXCJ2ZXJ0ZXhDb2xvcnNcIiwgXCJmb2dcIiwgXCJ1c2VGb2dcIiwgXCJmb2dFeHBcIixcclxuICAgICAgICBcImZsYXRTaGFkaW5nXCIsIFwic2l6ZUF0dGVudWF0aW9uXCIsIFwibG9nYXJpdGhtaWNEZXB0aEJ1ZmZlclwiLCBcInNraW5uaW5nXCIsXHJcbiAgICAgICAgXCJtYXhCb25lc1wiLCBcInVzZVZlcnRleFRleHR1cmVcIiwgXCJtb3JwaFRhcmdldHNcIiwgXCJtb3JwaE5vcm1hbHNcIixcclxuICAgICAgICBcIm1heE1vcnBoVGFyZ2V0c1wiLCBcIm1heE1vcnBoTm9ybWFsc1wiLCBcIm1heERpckxpZ2h0c1wiLCBcIm1heFBvaW50TGlnaHRzXCIsXHJcbiAgICAgICAgXCJtYXhTcG90TGlnaHRzXCIsIFwibWF4SGVtaUxpZ2h0c1wiLCBcIm1heFNoYWRvd3NcIiwgXCJzaGFkb3dNYXBFbmFibGVkXCIsIFwicG9pbnRMaWdodFNoYWRvd3NcIixcclxuICAgICAgICBcInNoYWRvd01hcFR5cGVcIiwgXCJzaGFkb3dNYXBEZWJ1Z1wiLCBcImFscGhhVGVzdFwiLCBcIm1ldGFsXCIsIFwiZG91YmxlU2lkZWRcIixcclxuICAgICAgICBcImZsaXBTaWRlZFwiXHJcbiAgICBdO1xyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBhbGxvY2F0ZUJvbmVzICggb2JqZWN0ICkge1xyXG5cclxuICAgICAgICBpZiAoIGNhcGFiaWxpdGllcy5mbG9hdFZlcnRleFRleHR1cmVzICYmIG9iamVjdCAmJiBvYmplY3Quc2tlbGV0b24gJiYgb2JqZWN0LnNrZWxldG9uLnVzZVZlcnRleFRleHR1cmUgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gMTAyNDtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgZm9yIHdoZW4gb2JqZWN0IGlzIG5vdCBzcGVjaWZpZWRcclxuICAgICAgICAgICAgLy8gKCBmb3IgZXhhbXBsZSB3aGVuIHByZWJ1aWxkaW5nIHNoYWRlciB0byBiZSB1c2VkIHdpdGggbXVsdGlwbGUgb2JqZWN0cyApXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vICAtIGxlYXZlIHNvbWUgZXh0cmEgc3BhY2UgZm9yIG90aGVyIHVuaWZvcm1zXHJcbiAgICAgICAgICAgIC8vICAtIGxpbWl0IGhlcmUgaXMgQU5HTEUncyAyNTQgbWF4IHVuaWZvcm0gdmVjdG9yc1xyXG4gICAgICAgICAgICAvLyAgICAodXAgdG8gNTQgc2hvdWxkIGJlIHNhZmUpXHJcblxyXG4gICAgICAgICAgICB2YXIgblZlcnRleFVuaWZvcm1zID0gY2FwYWJpbGl0aWVzLm1heFZlcnRleFVuaWZvcm1zO1xyXG4gICAgICAgICAgICB2YXIgblZlcnRleE1hdHJpY2VzID0gTWF0aC5mbG9vciggKCBuVmVydGV4VW5pZm9ybXMgLSAyMCApIC8gNCApO1xyXG5cclxuICAgICAgICAgICAgdmFyIG1heEJvbmVzID0gblZlcnRleE1hdHJpY2VzO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBvYmplY3QgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Ta2lubmVkTWVzaCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBtYXhCb25lcyA9IE1hdGgubWluKCBvYmplY3Quc2tlbGV0b24uYm9uZXMubGVuZ3RoLCBtYXhCb25lcyApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggbWF4Qm9uZXMgPCBvYmplY3Quc2tlbGV0b24uYm9uZXMubGVuZ3RoICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdXZWJHTFJlbmRlcmVyOiB0b28gbWFueSBib25lcyAtICcgKyBvYmplY3Quc2tlbGV0b24uYm9uZXMubGVuZ3RoICsgJywgdGhpcyBHUFUgc3VwcG9ydHMganVzdCAnICsgbWF4Qm9uZXMgKyAnICh0cnkgT3BlbkdMIGluc3RlYWQgb2YgQU5HTEUpJyApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBtYXhCb25lcztcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhbGxvY2F0ZUxpZ2h0cyggbGlnaHRzICkge1xyXG5cclxuICAgICAgICB2YXIgZGlyTGlnaHRzID0gMDtcclxuICAgICAgICB2YXIgcG9pbnRMaWdodHMgPSAwO1xyXG4gICAgICAgIHZhciBzcG90TGlnaHRzID0gMDtcclxuICAgICAgICB2YXIgaGVtaUxpZ2h0cyA9IDA7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBsID0gMCwgbGwgPSBsaWdodHMubGVuZ3RoOyBsIDwgbGw7IGwgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbGlnaHQgPSBsaWdodHNbIGwgXTtcclxuXHJcbiAgICAgICAgICAgIGlmICggbGlnaHQudmlzaWJsZSA9PT0gZmFsc2UgKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICkgZGlyTGlnaHRzICsrO1xyXG4gICAgICAgICAgICBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodCApIHBvaW50TGlnaHRzICsrO1xyXG4gICAgICAgICAgICBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuU3BvdExpZ2h0ICkgc3BvdExpZ2h0cyArKztcclxuICAgICAgICAgICAgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkhlbWlzcGhlcmVMaWdodCApIGhlbWlMaWdodHMgKys7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHsgJ2RpcmVjdGlvbmFsJzogZGlyTGlnaHRzLCAncG9pbnQnOiBwb2ludExpZ2h0cywgJ3Nwb3QnOiBzcG90TGlnaHRzLCAnaGVtaSc6IGhlbWlMaWdodHMgfTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWxsb2NhdGVTaGFkb3dzKCBsaWdodHMgKSB7XHJcblxyXG4gICAgICAgIHZhciBtYXhTaGFkb3dzID0gMDtcclxuICAgICAgICB2YXIgcG9pbnRMaWdodFNoYWRvd3MgPSAwO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgbCA9IDAsIGxsID0gbGlnaHRzLmxlbmd0aDsgbCA8IGxsOyBsICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGxpZ2h0ID0gbGlnaHRzWyBsIF07XHJcblxyXG4gICAgICAgICAgICBpZiAoICEgbGlnaHQuY2FzdFNoYWRvdyApIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCB8fCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgKSBtYXhTaGFkb3dzICsrO1xyXG4gICAgICAgICAgICBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBtYXhTaGFkb3dzICsrO1xyXG4gICAgICAgICAgICAgICAgcG9pbnRMaWdodFNoYWRvd3MgKys7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHsgJ21heFNoYWRvd3MnOiBtYXhTaGFkb3dzLCAncG9pbnRMaWdodFNoYWRvd3MnOiBwb2ludExpZ2h0U2hhZG93cyB9O1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmdldFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoIG1hdGVyaWFsLCBsaWdodHMsIGZvZywgb2JqZWN0ICkge1xyXG5cclxuICAgICAgICB2YXIgc2hhZGVySUQgPSBzaGFkZXJJRHNbIG1hdGVyaWFsLnR5cGUgXTtcclxuICAgICAgICAvLyBoZXVyaXN0aWNzIHRvIGNyZWF0ZSBzaGFkZXIgcGFyYW1ldGVycyBhY2NvcmRpbmcgdG8gbGlnaHRzIGluIHRoZSBzY2VuZVxyXG4gICAgICAgIC8vIChub3QgdG8gYmxvdyBvdmVyIG1heExpZ2h0cyBidWRnZXQpXHJcblxyXG4gICAgICAgIHZhciBtYXhMaWdodENvdW50ID0gYWxsb2NhdGVMaWdodHMoIGxpZ2h0cyApO1xyXG4gICAgICAgIHZhciBhbGxvY2F0ZWRTaGFkb3dzID0gYWxsb2NhdGVTaGFkb3dzKCBsaWdodHMgKTtcclxuICAgICAgICB2YXIgbWF4Qm9uZXMgPSBhbGxvY2F0ZUJvbmVzKCBvYmplY3QgKTtcclxuICAgICAgICB2YXIgcHJlY2lzaW9uID0gcmVuZGVyZXIuZ2V0UHJlY2lzaW9uKCk7XHJcblxyXG4gICAgICAgIGlmICggbWF0ZXJpYWwucHJlY2lzaW9uICE9PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgcHJlY2lzaW9uID0gY2FwYWJpbGl0aWVzLmdldE1heFByZWNpc2lvbiggbWF0ZXJpYWwucHJlY2lzaW9uICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHByZWNpc2lvbiAhPT0gbWF0ZXJpYWwucHJlY2lzaW9uICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXIuaW5pdE1hdGVyaWFsOicsIG1hdGVyaWFsLnByZWNpc2lvbiwgJ25vdCBzdXBwb3J0ZWQsIHVzaW5nJywgcHJlY2lzaW9uLCAnaW5zdGVhZC4nICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSB7XHJcblxyXG4gICAgICAgICAgICBzaGFkZXJJRDogc2hhZGVySUQsXHJcblxyXG4gICAgICAgICAgICBwcmVjaXNpb246IHByZWNpc2lvbixcclxuICAgICAgICAgICAgc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlczogY2FwYWJpbGl0aWVzLnZlcnRleFRleHR1cmVzLFxyXG5cclxuICAgICAgICAgICAgbWFwOiAhISBtYXRlcmlhbC5tYXAsXHJcbiAgICAgICAgICAgIGVudk1hcDogISEgbWF0ZXJpYWwuZW52TWFwLFxyXG4gICAgICAgICAgICBlbnZNYXBNb2RlOiBtYXRlcmlhbC5lbnZNYXAgJiYgbWF0ZXJpYWwuZW52TWFwLm1hcHBpbmcsXHJcbiAgICAgICAgICAgIGxpZ2h0TWFwOiAhISBtYXRlcmlhbC5saWdodE1hcCxcclxuICAgICAgICAgICAgYW9NYXA6ICEhIG1hdGVyaWFsLmFvTWFwLFxyXG4gICAgICAgICAgICBlbWlzc2l2ZU1hcDogISEgbWF0ZXJpYWwuZW1pc3NpdmVNYXAsXHJcbiAgICAgICAgICAgIGJ1bXBNYXA6ICEhIG1hdGVyaWFsLmJ1bXBNYXAsXHJcbiAgICAgICAgICAgIG5vcm1hbE1hcDogISEgbWF0ZXJpYWwubm9ybWFsTWFwLFxyXG4gICAgICAgICAgICBkaXNwbGFjZW1lbnRNYXA6ICEhIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCxcclxuICAgICAgICAgICAgc3BlY3VsYXJNYXA6ICEhIG1hdGVyaWFsLnNwZWN1bGFyTWFwLFxyXG4gICAgICAgICAgICBhbHBoYU1hcDogISEgbWF0ZXJpYWwuYWxwaGFNYXAsXHJcblxyXG4gICAgICAgICAgICBjb21iaW5lOiBtYXRlcmlhbC5jb21iaW5lLFxyXG5cclxuICAgICAgICAgICAgdmVydGV4Q29sb3JzOiBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMsXHJcblxyXG4gICAgICAgICAgICBmb2c6IGZvZyxcclxuICAgICAgICAgICAgdXNlRm9nOiBtYXRlcmlhbC5mb2csXHJcbiAgICAgICAgICAgIGZvZ0V4cDogZm9nIGluc3RhbmNlb2YgVEhSRUUuRm9nRXhwMixcclxuXHJcbiAgICAgICAgICAgIGZsYXRTaGFkaW5nOiBtYXRlcmlhbC5zaGFkaW5nID09PSBUSFJFRS5GbGF0U2hhZGluZyxcclxuXHJcbiAgICAgICAgICAgIHNpemVBdHRlbnVhdGlvbjogbWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uLFxyXG4gICAgICAgICAgICBsb2dhcml0aG1pY0RlcHRoQnVmZmVyOiBjYXBhYmlsaXRpZXMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcixcclxuXHJcbiAgICAgICAgICAgIHNraW5uaW5nOiBtYXRlcmlhbC5za2lubmluZyxcclxuICAgICAgICAgICAgbWF4Qm9uZXM6IG1heEJvbmVzLFxyXG4gICAgICAgICAgICB1c2VWZXJ0ZXhUZXh0dXJlOiBjYXBhYmlsaXRpZXMuZmxvYXRWZXJ0ZXhUZXh0dXJlcyAmJiBvYmplY3QgJiYgb2JqZWN0LnNrZWxldG9uICYmIG9iamVjdC5za2VsZXRvbi51c2VWZXJ0ZXhUZXh0dXJlLFxyXG5cclxuICAgICAgICAgICAgbW9ycGhUYXJnZXRzOiBtYXRlcmlhbC5tb3JwaFRhcmdldHMsXHJcbiAgICAgICAgICAgIG1vcnBoTm9ybWFsczogbWF0ZXJpYWwubW9ycGhOb3JtYWxzLFxyXG4gICAgICAgICAgICBtYXhNb3JwaFRhcmdldHM6IHJlbmRlcmVyLm1heE1vcnBoVGFyZ2V0cyxcclxuICAgICAgICAgICAgbWF4TW9ycGhOb3JtYWxzOiByZW5kZXJlci5tYXhNb3JwaE5vcm1hbHMsXHJcblxyXG4gICAgICAgICAgICBtYXhEaXJMaWdodHM6IG1heExpZ2h0Q291bnQuZGlyZWN0aW9uYWwsXHJcbiAgICAgICAgICAgIG1heFBvaW50TGlnaHRzOiBtYXhMaWdodENvdW50LnBvaW50LFxyXG4gICAgICAgICAgICBtYXhTcG90TGlnaHRzOiBtYXhMaWdodENvdW50LnNwb3QsXHJcbiAgICAgICAgICAgIG1heEhlbWlMaWdodHM6IG1heExpZ2h0Q291bnQuaGVtaSxcclxuXHJcbiAgICAgICAgICAgIG1heFNoYWRvd3M6IGFsbG9jYXRlZFNoYWRvd3MubWF4U2hhZG93cyxcclxuICAgICAgICAgICAgcG9pbnRMaWdodFNoYWRvd3M6IGFsbG9jYXRlZFNoYWRvd3MucG9pbnRMaWdodFNoYWRvd3MsXHJcbiAgICAgICAgICAgIHNoYWRvd01hcEVuYWJsZWQ6IHJlbmRlcmVyLnNoYWRvd01hcC5lbmFibGVkICYmIG9iamVjdC5yZWNlaXZlU2hhZG93ICYmIGFsbG9jYXRlZFNoYWRvd3MubWF4U2hhZG93cyA+IDAsXHJcbiAgICAgICAgICAgIHNoYWRvd01hcFR5cGU6IHJlbmRlcmVyLnNoYWRvd01hcC50eXBlLFxyXG4gICAgICAgICAgICBzaGFkb3dNYXBEZWJ1ZzogcmVuZGVyZXIuc2hhZG93TWFwLmRlYnVnLFxyXG5cclxuICAgICAgICAgICAgYWxwaGFUZXN0OiBtYXRlcmlhbC5hbHBoYVRlc3QsXHJcbiAgICAgICAgICAgIG1ldGFsOiBtYXRlcmlhbC5tZXRhbCxcclxuICAgICAgICAgICAgZG91YmxlU2lkZWQ6IG1hdGVyaWFsLnNpZGUgPT09IFRIUkVFLkRvdWJsZVNpZGUsXHJcbiAgICAgICAgICAgIGZsaXBTaWRlZDogbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuQmFja1NpZGVcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnM7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmdldFByb2dyYW1Db2RlID0gZnVuY3Rpb24gKCBtYXRlcmlhbCwgcGFyYW1ldGVycyApIHtcclxuXHJcbiAgICAgICAgdmFyIGNodW5rcyA9IFtdO1xyXG5cclxuICAgICAgICBpZiAoIHBhcmFtZXRlcnMuc2hhZGVySUQgKSB7XHJcblxyXG4gICAgICAgICAgICBjaHVua3MucHVzaCggcGFyYW1ldGVycy5zaGFkZXJJRCApO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgY2h1bmtzLnB1c2goIG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyICk7XHJcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKCBtYXRlcmlhbC52ZXJ0ZXhTaGFkZXIgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIG1hdGVyaWFsLmRlZmluZXMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBuYW1lIGluIG1hdGVyaWFsLmRlZmluZXMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY2h1bmtzLnB1c2goIG5hbWUgKTtcclxuICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKCBtYXRlcmlhbC5kZWZpbmVzWyBuYW1lIF0gKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBwYXJhbWV0ZXJOYW1lcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgcGFyYW1ldGVyTmFtZSA9IHBhcmFtZXRlck5hbWVzWyBpIF07XHJcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKCBwYXJhbWV0ZXJOYW1lICk7XHJcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKCBwYXJhbWV0ZXJzWyBwYXJhbWV0ZXJOYW1lIF0gKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY2h1bmtzLmpvaW4oKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuYWNxdWlyZVByb2dyYW0gPSBmdW5jdGlvbiAoIG1hdGVyaWFsLCBwYXJhbWV0ZXJzLCBjb2RlICkge1xyXG5cclxuICAgICAgICB2YXIgcHJvZ3JhbTtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgY29kZSBoYXMgYmVlbiBhbHJlYWR5IGNvbXBpbGVkXHJcbiAgICAgICAgZm9yICggdmFyIHAgPSAwLCBwbCA9IHByb2dyYW1zLmxlbmd0aDsgcCA8IHBsOyBwICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHByb2dyYW1JbmZvID0gcHJvZ3JhbXNbIHAgXTtcclxuXHJcbiAgICAgICAgICAgIGlmICggcHJvZ3JhbUluZm8uY29kZSA9PT0gY29kZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBwcm9ncmFtID0gcHJvZ3JhbUluZm87XHJcbiAgICAgICAgICAgICAgICArKyBwcm9ncmFtLnVzZWRUaW1lcztcclxuXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIHByb2dyYW0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIHByb2dyYW0gPSBuZXcgVEhSRUUuV2ViR0xQcm9ncmFtKCByZW5kZXJlciwgY29kZSwgbWF0ZXJpYWwsIHBhcmFtZXRlcnMgKTtcclxuICAgICAgICAgICAgcHJvZ3JhbXMucHVzaCggcHJvZ3JhbSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwcm9ncmFtO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5yZWxlYXNlUHJvZ3JhbSA9IGZ1bmN0aW9uKCBwcm9ncmFtICkge1xyXG5cclxuICAgICAgICBpZiAoIC0tIHByb2dyYW0udXNlZFRpbWVzID09PSAwICkge1xyXG5cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gdW5vcmRlcmVkIHNldFxyXG4gICAgICAgICAgICB2YXIgaSA9IHByb2dyYW1zLmluZGV4T2YoIHByb2dyYW0gKTtcclxuICAgICAgICAgICAgcHJvZ3JhbXNbIGkgXSA9IHByb2dyYW1zWyBwcm9ncmFtcy5sZW5ndGggLSAxIF07XHJcbiAgICAgICAgICAgIHByb2dyYW1zLnBvcCgpO1xyXG5cclxuICAgICAgICAgICAgLy8gRnJlZSBXZWJHTCByZXNvdXJjZXNcclxuICAgICAgICAgICAgcHJvZ3JhbS5kZXN0cm95KCk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEV4cG9zZWQgZm9yIHJlc291cmNlIG1vbml0b3JpbmcgJiBlcnJvciBmZWVkYmFjayB2aWEgcmVuZGVyZXIuaW5mbzpcclxuICAgIHRoaXMucHJvZ3JhbXMgPSBwcm9ncmFtcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xQcm9wZXJ0aWVzLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBmb3JkYWNpb3VzIC8gZm9yZGFjaW91cy5naXRodWIuaW9cclxuICovXHJcblxyXG5USFJFRS5XZWJHTFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcclxuXHJcbiAgICB0aGlzLmdldCA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuICAgICAgICB2YXIgdXVpZCA9IG9iamVjdC51dWlkO1xyXG4gICAgICAgIHZhciBtYXAgPSBwcm9wZXJ0aWVzWyB1dWlkIF07XHJcblxyXG4gICAgICAgIGlmICggbWFwID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBtYXAgPSB7fTtcclxuICAgICAgICAgICAgcHJvcGVydGllc1sgdXVpZCBdID0gbWFwO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBtYXA7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmRlbGV0ZSA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuICAgICAgICBkZWxldGUgcHJvcGVydGllc1sgb2JqZWN0LnV1aWQgXTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHByb3BlcnRpZXMgPSB7fTtcclxuXHJcbiAgICB9O1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTFNoYWRlci5qc1xyXG5cclxuVEhSRUUuV2ViR0xTaGFkZXIgPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICBmdW5jdGlvbiBhZGRMaW5lTnVtYmVycyggc3RyaW5nICkge1xyXG5cclxuICAgICAgICB2YXIgbGluZXMgPSBzdHJpbmcuc3BsaXQoICdcXG4nICk7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIGxpbmVzWyBpIF0gPSAoIGkgKyAxICkgKyAnOiAnICsgbGluZXNbIGkgXTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbGluZXMuam9pbiggJ1xcbicgKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIFdlYkdMU2hhZGVyKCBnbCwgdHlwZSwgc3RyaW5nICkge1xyXG5cclxuICAgICAgICB2YXIgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCB0eXBlICk7XHJcblxyXG4gICAgICAgIGdsLnNoYWRlclNvdXJjZSggc2hhZGVyLCBzdHJpbmcgKTtcclxuICAgICAgICBnbC5jb21waWxlU2hhZGVyKCBzaGFkZXIgKTtcclxuXHJcbiAgICAgICAgaWYgKCBnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoIHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMgKSA9PT0gZmFsc2UgKSB7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xTaGFkZXI6IFNoYWRlciBjb3VsZG5cXCd0IGNvbXBpbGUuJyApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggZ2wuZ2V0U2hhZGVySW5mb0xvZyggc2hhZGVyICkgIT09ICcnICkge1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xTaGFkZXI6IGdsLmdldFNoYWRlckluZm9Mb2coKScsIHR5cGUgPT09IGdsLlZFUlRFWF9TSEFERVIgPyAndmVydGV4JyA6ICdmcmFnbWVudCcsIGdsLmdldFNoYWRlckluZm9Mb2coIHNoYWRlciApLCBhZGRMaW5lTnVtYmVycyggc3RyaW5nICkgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAtLWVuYWJsZS1wcml2aWxlZ2VkLXdlYmdsLWV4dGVuc2lvblxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCB0eXBlLCBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9kZWJ1Z19zaGFkZXJzJyApLmdldFRyYW5zbGF0ZWRTaGFkZXJTb3VyY2UoIHNoYWRlciApICk7XHJcblxyXG4gICAgICAgIHJldHVybiBzaGFkZXI7XHJcblxyXG4gICAgfTtcclxuXHJcbn0gKSgpO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMU2hhZG93TWFwLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5XZWJHTFNoYWRvd01hcCA9IGZ1bmN0aW9uICggX3JlbmRlcmVyLCBfbGlnaHRzLCBfb2JqZWN0cyApIHtcclxuXHJcbiAgICB2YXIgX2dsID0gX3JlbmRlcmVyLmNvbnRleHQsXHJcbiAgICAgICAgX3N0YXRlID0gX3JlbmRlcmVyLnN0YXRlLFxyXG4gICAgICAgIF9mcnVzdHVtID0gbmV3IFRIUkVFLkZydXN0dW0oKSxcclxuICAgICAgICBfcHJvalNjcmVlbk1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCksXHJcblxyXG4gICAgICAgIF9taW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG4gICAgICAgIF9tYXggPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cclxuICAgICAgICBfbG9va1RhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcbiAgICAgICAgX2xpZ2h0UG9zaXRpb25Xb3JsZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblxyXG4gICAgICAgIF9yZW5kZXJMaXN0ID0gW10sXHJcblxyXG4gICAgICAgIF9Nb3JwaGluZ0ZsYWcgPSAxLFxyXG4gICAgICAgIF9Ta2lubmluZ0ZsYWcgPSAyLFxyXG5cclxuICAgICAgICBfTnVtYmVyT2ZNYXRlcmlhbFZhcmlhbnRzID0gKCBfTW9ycGhpbmdGbGFnIHwgX1NraW5uaW5nRmxhZyApICsgMSxcclxuXHJcbiAgICAgICAgX2RlcHRoTWF0ZXJpYWxzID0gbmV3IEFycmF5KCBfTnVtYmVyT2ZNYXRlcmlhbFZhcmlhbnRzICksXHJcbiAgICAgICAgX2Rpc3RhbmNlTWF0ZXJpYWxzID0gbmV3IEFycmF5KCBfTnVtYmVyT2ZNYXRlcmlhbFZhcmlhbnRzICk7XHJcblxyXG4gICAgdmFyIGN1YmVEaXJlY3Rpb25zID0gW1xyXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICksIG5ldyBUSFJFRS5WZWN0b3IzKCAtIDEsIDAsIDAgKSwgbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKSxcclxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgLSAxICksIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICksIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtIDEsIDAgKVxyXG4gICAgXTtcclxuXHJcbiAgICB2YXIgY3ViZVVwcyA9IFtcclxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApLFxyXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICksIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICksXHRuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgLSAxIClcclxuICAgIF07XHJcblxyXG4gICAgdmFyIGN1YmUyRFZpZXdQb3J0cyA9IFtcclxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yNCgpLCBuZXcgVEhSRUUuVmVjdG9yNCgpLCBuZXcgVEhSRUUuVmVjdG9yNCgpLFxyXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3I0KCksIG5ldyBUSFJFRS5WZWN0b3I0KCksIG5ldyBUSFJFRS5WZWN0b3I0KClcclxuICAgIF07XHJcblxyXG4gICAgdmFyIF92ZWN0b3I0ID0gbmV3IFRIUkVFLlZlY3RvcjQoKTtcclxuXHJcbiAgICAvLyBpbml0XHJcblxyXG4gICAgdmFyIGRlcHRoU2hhZGVyID0gVEhSRUUuU2hhZGVyTGliWyBcImRlcHRoUkdCQVwiIF07XHJcbiAgICB2YXIgZGVwdGhVbmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIGRlcHRoU2hhZGVyLnVuaWZvcm1zICk7XHJcblxyXG4gICAgdmFyIGRpc3RhbmNlU2hhZGVyID0gVEhSRUUuU2hhZGVyTGliWyBcImRpc3RhbmNlUkdCQVwiIF07XHJcbiAgICB2YXIgZGlzdGFuY2VVbmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIGRpc3RhbmNlU2hhZGVyLnVuaWZvcm1zICk7XHJcblxyXG4gICAgZm9yICggdmFyIGkgPSAwOyBpICE9PSBfTnVtYmVyT2ZNYXRlcmlhbFZhcmlhbnRzOyArKyBpICkge1xyXG5cclxuICAgICAgICB2YXIgdXNlTW9ycGhpbmcgPSAoIGkgJiBfTW9ycGhpbmdGbGFnICkgIT09IDA7XHJcbiAgICAgICAgdmFyIHVzZVNraW5uaW5nID0gKCBpICYgX1NraW5uaW5nRmxhZyApICE9PSAwO1xyXG5cclxuICAgICAgICB2YXIgZGVwdGhNYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCgge1xyXG4gICAgICAgICAgICB1bmlmb3JtczogZGVwdGhVbmlmb3JtcyxcclxuICAgICAgICAgICAgdmVydGV4U2hhZGVyOiBkZXB0aFNoYWRlci52ZXJ0ZXhTaGFkZXIsXHJcbiAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyOiBkZXB0aFNoYWRlci5mcmFnbWVudFNoYWRlcixcclxuICAgICAgICAgICAgbW9ycGhUYXJnZXRzOiB1c2VNb3JwaGluZyxcclxuICAgICAgICAgICAgc2tpbm5pbmc6IHVzZVNraW5uaW5nXHJcbiAgICAgICAgfSApO1xyXG5cclxuICAgICAgICBkZXB0aE1hdGVyaWFsLl9zaGFkb3dQYXNzID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgX2RlcHRoTWF0ZXJpYWxzWyBpIF0gPSBkZXB0aE1hdGVyaWFsO1xyXG5cclxuICAgICAgICB2YXIgZGlzdGFuY2VNYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCgge1xyXG4gICAgICAgICAgICB1bmlmb3JtczogZGlzdGFuY2VVbmlmb3JtcyxcclxuICAgICAgICAgICAgdmVydGV4U2hhZGVyOiBkaXN0YW5jZVNoYWRlci52ZXJ0ZXhTaGFkZXIsXHJcbiAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyOiBkaXN0YW5jZVNoYWRlci5mcmFnbWVudFNoYWRlcixcclxuICAgICAgICAgICAgbW9ycGhUYXJnZXRzOiB1c2VNb3JwaGluZyxcclxuICAgICAgICAgICAgc2tpbm5pbmc6IHVzZVNraW5uaW5nXHJcbiAgICAgICAgfSApO1xyXG5cclxuICAgICAgICBkaXN0YW5jZU1hdGVyaWFsLl9zaGFkb3dQYXNzID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgX2Rpc3RhbmNlTWF0ZXJpYWxzWyBpIF0gPSBkaXN0YW5jZU1hdGVyaWFsO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvL1xyXG5cclxuICAgIHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG4gICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5hdXRvVXBkYXRlID0gdHJ1ZTtcclxuICAgIHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSBUSFJFRS5QQ0ZTaGFkb3dNYXA7XHJcbiAgICB0aGlzLmN1bGxGYWNlID0gVEhSRUUuQ3VsbEZhY2VGcm9udDtcclxuXHJcbiAgICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggc2NlbmUgKSB7XHJcblxyXG4gICAgICAgIHZhciBmYWNlQ291bnQsIGlzUG9pbnRMaWdodDtcclxuXHJcbiAgICAgICAgaWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcclxuICAgICAgICBpZiAoIHNjb3BlLmF1dG9VcGRhdGUgPT09IGZhbHNlICYmIHNjb3BlLm5lZWRzVXBkYXRlID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8gU2V0IEdMIHN0YXRlIGZvciBkZXB0aCBtYXAuXHJcbiAgICAgICAgX2dsLmNsZWFyQ29sb3IoIDEsIDEsIDEsIDEgKTtcclxuICAgICAgICBfc3RhdGUuZGlzYWJsZSggX2dsLkJMRU5EICk7XHJcbiAgICAgICAgX3N0YXRlLmVuYWJsZSggX2dsLkNVTExfRkFDRSApO1xyXG4gICAgICAgIF9nbC5mcm9udEZhY2UoIF9nbC5DQ1cgKTtcclxuICAgICAgICBfZ2wuY3VsbEZhY2UoIHNjb3BlLmN1bGxGYWNlID09PSBUSFJFRS5DdWxsRmFjZUZyb250ID8gX2dsLkZST05UIDogX2dsLkJBQ0sgKTtcclxuICAgICAgICBfc3RhdGUuc2V0RGVwdGhUZXN0KCB0cnVlICk7XHJcblxyXG4gICAgICAgIC8vIHNhdmUgdGhlIGV4aXN0aW5nIHZpZXdwb3J0IHNvIGl0IGNhbiBiZSByZXN0b3JlZCBsYXRlclxyXG4gICAgICAgIF9yZW5kZXJlci5nZXRWaWV3cG9ydCggX3ZlY3RvcjQgKTtcclxuXHJcbiAgICAgICAgLy8gcmVuZGVyIGRlcHRoIG1hcFxyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gX2xpZ2h0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBsaWdodCA9IF9saWdodHNbIGkgXTtcclxuXHJcbiAgICAgICAgICAgIGlmICggbGlnaHQuY2FzdFNoYWRvdyA9PT0gdHJ1ZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2hhZG93ID0gbGlnaHQuc2hhZG93O1xyXG4gICAgICAgICAgICAgICAgdmFyIHNoYWRvd0NhbWVyYSA9IHNoYWRvdy5jYW1lcmE7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2hhZG93TWFwU2l6ZSA9IHNoYWRvdy5tYXBTaXplO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludExpZ2h0ICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmYWNlQ291bnQgPSA2O1xyXG4gICAgICAgICAgICAgICAgICAgIGlzUG9pbnRMaWdodCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2cFdpZHRoID0gc2hhZG93TWFwU2l6ZS54IC8gNC4wO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2cEhlaWdodCA9IHNoYWRvd01hcFNpemUueSAvIDIuMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2Ugdmlld3BvcnRzIG1hcCBhIGN1YmUtbWFwIG9udG8gYSAyRCB0ZXh0dXJlIHdpdGggdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9sbG93aW5nIG9yaWVudGF0aW9uOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gIHh6WFpcclxuICAgICAgICAgICAgICAgICAgICAvLyAgIHkgWVxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gWCAtIFBvc2l0aXZlIHggZGlyZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8geCAtIE5lZ2F0aXZlIHggZGlyZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gWSAtIFBvc2l0aXZlIHkgZGlyZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8geSAtIE5lZ2F0aXZlIHkgZGlyZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gWiAtIFBvc2l0aXZlIHogZGlyZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8geiAtIE5lZ2F0aXZlIHogZGlyZWN0aW9uXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHBvc2l0aXZlIFhcclxuICAgICAgICAgICAgICAgICAgICBjdWJlMkRWaWV3UG9ydHNbIDAgXS5zZXQoIHZwV2lkdGggKiAyLCB2cEhlaWdodCwgdnBXaWR0aCwgdnBIZWlnaHQgKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBuZWdhdGl2ZSBYXHJcbiAgICAgICAgICAgICAgICAgICAgY3ViZTJEVmlld1BvcnRzWyAxIF0uc2V0KCAwLCB2cEhlaWdodCwgdnBXaWR0aCwgdnBIZWlnaHQgKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBwb3NpdGl2ZSBaXHJcbiAgICAgICAgICAgICAgICAgICAgY3ViZTJEVmlld1BvcnRzWyAyIF0uc2V0KCB2cFdpZHRoICogMywgdnBIZWlnaHQsIHZwV2lkdGgsIHZwSGVpZ2h0ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVnYXRpdmUgWlxyXG4gICAgICAgICAgICAgICAgICAgIGN1YmUyRFZpZXdQb3J0c1sgMyBdLnNldCggdnBXaWR0aCwgdnBIZWlnaHQsIHZwV2lkdGgsIHZwSGVpZ2h0ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcG9zaXRpdmUgWVxyXG4gICAgICAgICAgICAgICAgICAgIGN1YmUyRFZpZXdQb3J0c1sgNCBdLnNldCggdnBXaWR0aCAqIDMsIDAsIHZwV2lkdGgsIHZwSGVpZ2h0ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVnYXRpdmUgWVxyXG4gICAgICAgICAgICAgICAgICAgIGN1YmUyRFZpZXdQb3J0c1sgNSBdLnNldCggdnBXaWR0aCwgMCwgdnBXaWR0aCwgdnBIZWlnaHQgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmYWNlQ291bnQgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGlzUG9pbnRMaWdodCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHNoYWRvdy5tYXAgPT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaGFkb3dGaWx0ZXIgPSBUSFJFRS5MaW5lYXJGaWx0ZXI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggc2NvcGUudHlwZSA9PT0gVEhSRUUuUENGU29mdFNoYWRvd01hcCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRvd0ZpbHRlciA9IFRIUkVFLk5lYXJlc3RGaWx0ZXI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnMgPSB7IG1pbkZpbHRlcjogc2hhZG93RmlsdGVyLCBtYWdGaWx0ZXI6IHNoYWRvd0ZpbHRlciwgZm9ybWF0OiBUSFJFRS5SR0JBRm9ybWF0IH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNoYWRvdy5tYXAgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQoIHNoYWRvd01hcFNpemUueCwgc2hhZG93TWFwU2l6ZS55LCBwYXJzICk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hhZG93Lm1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5TcG90TGlnaHQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFkb3dDYW1lcmEuYXNwZWN0ID0gc2hhZG93TWFwU2l6ZS54IC8gc2hhZG93TWFwU2l6ZS55O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNoYWRvd0NhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBzaGFkb3dNYXAgPSBzaGFkb3cubWFwO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNoYWRvd01hdHJpeCA9IHNoYWRvdy5tYXRyaXg7XHJcblxyXG4gICAgICAgICAgICAgICAgX2xpZ2h0UG9zaXRpb25Xb3JsZC5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XHJcbiAgICAgICAgICAgICAgICBzaGFkb3dDYW1lcmEucG9zaXRpb24uY29weSggX2xpZ2h0UG9zaXRpb25Xb3JsZCApO1xyXG5cclxuICAgICAgICAgICAgICAgIF9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIHNoYWRvd01hcCApO1xyXG4gICAgICAgICAgICAgICAgX3JlbmRlcmVyLmNsZWFyKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyIHNoYWRvdyBtYXAgZm9yIGVhY2ggY3ViZSBmYWNlIChpZiBvbW5pLWRpcmVjdGlvbmFsKSBvclxyXG4gICAgICAgICAgICAgICAgLy8gcnVuIGEgc2luZ2xlIHBhc3MgaWYgbm90XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGZhY2UgPSAwOyBmYWNlIDwgZmFjZUNvdW50OyBmYWNlICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGlzUG9pbnRMaWdodCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9sb29rVGFyZ2V0LmNvcHkoIHNoYWRvd0NhbWVyYS5wb3NpdGlvbiApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbG9va1RhcmdldC5hZGQoIGN1YmVEaXJlY3Rpb25zWyBmYWNlIF0gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93Q2FtZXJhLnVwLmNvcHkoIGN1YmVVcHNbIGZhY2UgXSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFkb3dDYW1lcmEubG9va0F0KCBfbG9va1RhcmdldCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdnBEaW1lbnNpb25zID0gY3ViZTJEVmlld1BvcnRzWyBmYWNlIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZW5kZXJlci5zZXRWaWV3cG9ydCggdnBEaW1lbnNpb25zLngsIHZwRGltZW5zaW9ucy55LCB2cERpbWVuc2lvbnMueiwgdnBEaW1lbnNpb25zLncgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9sb29rVGFyZ2V0LnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRvd0NhbWVyYS5sb29rQXQoIF9sb29rVGFyZ2V0ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2hhZG93Q2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGQgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcHV0ZSBzaGFkb3cgbWF0cml4XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNoYWRvd01hdHJpeC5zZXQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDAuNSwgMC4wLCAwLjAsIDAuNSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgMC4wLCAwLjUsIDAuMCwgMC41LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAwLjAsIDAuMCwgMC41LCAwLjUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDAuMCwgMC4wLCAwLjAsIDEuMFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNoYWRvd01hdHJpeC5tdWx0aXBseSggc2hhZG93Q2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcclxuICAgICAgICAgICAgICAgICAgICBzaGFkb3dNYXRyaXgubXVsdGlwbHkoIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIGNhbWVyYSBtYXRyaWNlcyBhbmQgZnJ1c3R1bVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBfcHJvalNjcmVlbk1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBzaGFkb3dDYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xyXG4gICAgICAgICAgICAgICAgICAgIF9mcnVzdHVtLnNldEZyb21NYXRyaXgoIF9wcm9qU2NyZWVuTWF0cml4ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNldCBvYmplY3QgbWF0cmljZXMgJiBmcnVzdHVtIGN1bGxpbmdcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX3JlbmRlckxpc3QubGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvamVjdE9iamVjdCggc2NlbmUsIHNoYWRvd0NhbWVyYSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyByZW5kZXIgc2hhZG93IG1hcFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbmRlciByZWd1bGFyIG9iamVjdHNcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IF9yZW5kZXJMaXN0Lmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iamVjdCA9IF9yZW5kZXJMaXN0WyBqIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnZW9tZXRyeSA9IF9vYmplY3RzLnVwZGF0ZSggb2JqZWN0ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0ZXJpYWxzID0gbWF0ZXJpYWwubWF0ZXJpYWxzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBrID0gMCwga2wgPSBncm91cHMubGVuZ3RoOyBrIDwga2w7IGsgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBncm91cCA9IGdyb3Vwc1sgayBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBncm91cE1hdGVyaWFsID0gbWF0ZXJpYWxzWyBncm91cC5tYXRlcmlhbEluZGV4IF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZ3JvdXBNYXRlcmlhbC52aXNpYmxlID09PSB0cnVlICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlcHRoTWF0ZXJpYWwgPSBnZXREZXB0aE1hdGVyaWFsKCBvYmplY3QsIGdyb3VwTWF0ZXJpYWwsIGlzUG9pbnRMaWdodCwgX2xpZ2h0UG9zaXRpb25Xb3JsZCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KCBzaGFkb3dDYW1lcmEsIF9saWdodHMsIG51bGwsIGdlb21ldHJ5LCBkZXB0aE1hdGVyaWFsLCBvYmplY3QsIGdyb3VwICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZXB0aE1hdGVyaWFsID0gZ2V0RGVwdGhNYXRlcmlhbCggb2JqZWN0LCBtYXRlcmlhbCwgaXNQb2ludExpZ2h0LCBfbGlnaHRQb3NpdGlvbldvcmxkICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KCBzaGFkb3dDYW1lcmEsIF9saWdodHMsIG51bGwsIGdlb21ldHJ5LCBkZXB0aE1hdGVyaWFsLCBvYmplY3QsIG51bGwgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBXZSBtdXN0IGNhbGwgX3JlbmRlcmVyLnJlc2V0R0xTdGF0ZSgpIGF0IHRoZSBlbmQgb2YgZWFjaCBpdGVyYXRpb24gb2ZcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBsaWdodCBsb29wIGluIG9yZGVyIHRvIGZvcmNlIG1hdGVyaWFsIHVwZGF0ZXMgZm9yIGVhY2ggbGlnaHQuXHJcbiAgICAgICAgICAgICAgICBfcmVuZGVyZXIucmVzZXRHTFN0YXRlKCk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgX3JlbmRlcmVyLnNldFZpZXdwb3J0KCBfdmVjdG9yNC54LCBfdmVjdG9yNC55LCBfdmVjdG9yNC56LCBfdmVjdG9yNC53ICk7XHJcblxyXG4gICAgICAgIC8vIFJlc3RvcmUgR0wgc3RhdGUuXHJcbiAgICAgICAgdmFyIGNsZWFyQ29sb3IgPSBfcmVuZGVyZXIuZ2V0Q2xlYXJDb2xvcigpLFxyXG4gICAgICAgICAgICBjbGVhckFscGhhID0gX3JlbmRlcmVyLmdldENsZWFyQWxwaGEoKTtcclxuICAgICAgICBfcmVuZGVyZXIuc2V0Q2xlYXJDb2xvciggY2xlYXJDb2xvciwgY2xlYXJBbHBoYSApO1xyXG4gICAgICAgIF9zdGF0ZS5lbmFibGUoIF9nbC5CTEVORCApO1xyXG5cclxuICAgICAgICBpZiAoIHNjb3BlLmN1bGxGYWNlID09PSBUSFJFRS5DdWxsRmFjZUZyb250ICkge1xyXG5cclxuICAgICAgICAgICAgX2dsLmN1bGxGYWNlKCBfZ2wuQkFDSyApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF9yZW5kZXJlci5yZXNldEdMU3RhdGUoKTtcclxuXHJcbiAgICAgICAgc2NvcGUubmVlZHNVcGRhdGUgPSBmYWxzZTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldERlcHRoTWF0ZXJpYWwoIG9iamVjdCwgbWF0ZXJpYWwsIGlzUG9pbnRMaWdodCwgbGlnaHRQb3NpdGlvbldvcmxkICkge1xyXG5cclxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XHJcblxyXG4gICAgICAgIHZhciBuZXdNYXRlcmlhbCA9IG51bGw7XHJcblxyXG4gICAgICAgIHZhciBtYXRlcmlhbFZhcmlhbnRzID0gX2RlcHRoTWF0ZXJpYWxzO1xyXG4gICAgICAgIHZhciBjdXN0b21NYXRlcmlhbCA9IG9iamVjdC5jdXN0b21EZXB0aE1hdGVyaWFsO1xyXG5cclxuICAgICAgICBpZiAoIGlzUG9pbnRMaWdodCApIHtcclxuXHJcbiAgICAgICAgICAgIG1hdGVyaWFsVmFyaWFudHMgPSBfZGlzdGFuY2VNYXRlcmlhbHM7XHJcbiAgICAgICAgICAgIGN1c3RvbU1hdGVyaWFsID0gb2JqZWN0LmN1c3RvbURpc3RhbmNlTWF0ZXJpYWw7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCAhIGN1c3RvbU1hdGVyaWFsICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHVzZU1vcnBoaW5nID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgICAgIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGggPiAwICYmIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cztcclxuXHJcbiAgICAgICAgICAgIHZhciB1c2VTa2lubmluZyA9IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlNraW5uZWRNZXNoICYmIG1hdGVyaWFsLnNraW5uaW5nO1xyXG5cclxuICAgICAgICAgICAgdmFyIHZhcmlhbnRJbmRleCA9IDA7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHVzZU1vcnBoaW5nICkgdmFyaWFudEluZGV4IHw9IF9Nb3JwaGluZ0ZsYWc7XHJcbiAgICAgICAgICAgIGlmICggdXNlU2tpbm5pbmcgKSB2YXJpYW50SW5kZXggfD0gX1NraW5uaW5nRmxhZztcclxuXHJcbiAgICAgICAgICAgIG5ld01hdGVyaWFsID0gbWF0ZXJpYWxWYXJpYW50c1sgdmFyaWFudEluZGV4IF07XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICBuZXdNYXRlcmlhbCA9IGN1c3RvbU1hdGVyaWFsO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG5ld01hdGVyaWFsLnZpc2libGUgPSBtYXRlcmlhbC52aXNpYmxlO1xyXG4gICAgICAgIG5ld01hdGVyaWFsLndpcmVmcmFtZSA9IG1hdGVyaWFsLndpcmVmcmFtZTtcclxuICAgICAgICBuZXdNYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggPSBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGg7XHJcblxyXG4gICAgICAgIGlmICggaXNQb2ludExpZ2h0ICYmIG5ld01hdGVyaWFsLnVuaWZvcm1zLmxpZ2h0UG9zICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBuZXdNYXRlcmlhbC51bmlmb3Jtcy5saWdodFBvcy52YWx1ZS5jb3B5KCBsaWdodFBvc2l0aW9uV29ybGQgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmV3TWF0ZXJpYWw7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHByb2plY3RPYmplY3QoIG9iamVjdCwgY2FtZXJhICkge1xyXG5cclxuICAgICAgICBpZiAoIG9iamVjdC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoIHx8IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmUgfHwgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRzICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBvYmplY3QuY2FzdFNoYWRvdyAmJiAoIG9iamVjdC5mcnVzdHVtQ3VsbGVkID09PSBmYWxzZSB8fCBfZnJ1c3R1bS5pbnRlcnNlY3RzT2JqZWN0KCBvYmplY3QgKSA9PT0gdHJ1ZSApICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIG1hdGVyaWFsLnZpc2libGUgPT09IHRydWUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3JlbmRlckxpc3QucHVzaCggb2JqZWN0ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IG9iamVjdC5jaGlsZHJlbjtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHByb2plY3RPYmplY3QoIGNoaWxkcmVuWyBpIF0sIGNhbWVyYSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTFN0YXRlLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5XZWJHTFN0YXRlID0gZnVuY3Rpb24gKCBnbCwgZXh0ZW5zaW9ucywgcGFyYW1UaHJlZVRvR0wgKSB7XHJcblxyXG4gICAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICB2YXIgbmV3QXR0cmlidXRlcyA9IG5ldyBVaW50OEFycmF5KCAxNiApO1xyXG4gICAgdmFyIGVuYWJsZWRBdHRyaWJ1dGVzID0gbmV3IFVpbnQ4QXJyYXkoIDE2ICk7XHJcbiAgICB2YXIgYXR0cmlidXRlRGl2aXNvcnMgPSBuZXcgVWludDhBcnJheSggMTYgKTtcclxuXHJcbiAgICB2YXIgY2FwYWJpbGl0aWVzID0ge307XHJcblxyXG4gICAgdmFyIGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyA9IG51bGw7XHJcblxyXG4gICAgdmFyIGN1cnJlbnRCbGVuZGluZyA9IG51bGw7XHJcbiAgICB2YXIgY3VycmVudEJsZW5kRXF1YXRpb24gPSBudWxsO1xyXG4gICAgdmFyIGN1cnJlbnRCbGVuZFNyYyA9IG51bGw7XHJcbiAgICB2YXIgY3VycmVudEJsZW5kRHN0ID0gbnVsbDtcclxuICAgIHZhciBjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhID0gbnVsbDtcclxuICAgIHZhciBjdXJyZW50QmxlbmRTcmNBbHBoYSA9IG51bGw7XHJcbiAgICB2YXIgY3VycmVudEJsZW5kRHN0QWxwaGEgPSBudWxsO1xyXG5cclxuICAgIHZhciBjdXJyZW50RGVwdGhGdW5jID0gbnVsbDtcclxuICAgIHZhciBjdXJyZW50RGVwdGhXcml0ZSA9IG51bGw7XHJcblxyXG4gICAgdmFyIGN1cnJlbnRDb2xvcldyaXRlID0gbnVsbDtcclxuXHJcbiAgICB2YXIgY3VycmVudEZsaXBTaWRlZCA9IG51bGw7XHJcblxyXG4gICAgdmFyIGN1cnJlbnRMaW5lV2lkdGggPSBudWxsO1xyXG5cclxuICAgIHZhciBjdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciA9IG51bGw7XHJcbiAgICB2YXIgY3VycmVudFBvbHlnb25PZmZzZXRVbml0cyA9IG51bGw7XHJcblxyXG4gICAgdmFyIG1heFRleHR1cmVzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyApO1xyXG5cclxuICAgIHZhciBjdXJyZW50VGV4dHVyZVNsb3QgPSB1bmRlZmluZWQ7XHJcbiAgICB2YXIgY3VycmVudEJvdW5kVGV4dHVyZXMgPSB7fTtcclxuXHJcbiAgICB0aGlzLmluaXQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIGdsLmNsZWFyQ29sb3IoIDAsIDAsIDAsIDEgKTtcclxuICAgICAgICBnbC5jbGVhckRlcHRoKCAxICk7XHJcbiAgICAgICAgZ2wuY2xlYXJTdGVuY2lsKCAwICk7XHJcblxyXG4gICAgICAgIHRoaXMuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XHJcbiAgICAgICAgZ2wuZGVwdGhGdW5jKCBnbC5MRVFVQUwgKTtcclxuXHJcbiAgICAgICAgZ2wuZnJvbnRGYWNlKCBnbC5DQ1cgKTtcclxuICAgICAgICBnbC5jdWxsRmFjZSggZ2wuQkFDSyApO1xyXG4gICAgICAgIHRoaXMuZW5hYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcclxuXHJcbiAgICAgICAgdGhpcy5lbmFibGUoIGdsLkJMRU5EICk7XHJcbiAgICAgICAgZ2wuYmxlbmRFcXVhdGlvbiggZ2wuRlVOQ19BREQgKTtcclxuICAgICAgICBnbC5ibGVuZEZ1bmMoIGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSApO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5pbml0QXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gbmV3QXR0cmlidXRlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgbmV3QXR0cmlidXRlc1sgaSBdID0gMDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5lbmFibGVBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGF0dHJpYnV0ZSApIHtcclxuXHJcbiAgICAgICAgbmV3QXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xyXG5cclxuICAgICAgICBpZiAoIGVuYWJsZWRBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9PT0gMCApIHtcclxuXHJcbiAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBhdHRyaWJ1dGUgKTtcclxuICAgICAgICAgICAgZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID0gMTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIGF0dHJpYnV0ZURpdmlzb3JzWyBhdHRyaWJ1dGUgXSAhPT0gMCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XHJcblxyXG4gICAgICAgICAgICBleHRlbnNpb24udmVydGV4QXR0cmliRGl2aXNvckFOR0xFKCBhdHRyaWJ1dGUsIDAgKTtcclxuICAgICAgICAgICAgYXR0cmlidXRlRGl2aXNvcnNbIGF0dHJpYnV0ZSBdID0gMDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5lbmFibGVBdHRyaWJ1dGVBbmREaXZpc29yID0gZnVuY3Rpb24gKCBhdHRyaWJ1dGUsIG1lc2hQZXJBdHRyaWJ1dGUsIGV4dGVuc2lvbiApIHtcclxuXHJcbiAgICAgICAgbmV3QXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xyXG5cclxuICAgICAgICBpZiAoIGVuYWJsZWRBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9PT0gMCApIHtcclxuXHJcbiAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBhdHRyaWJ1dGUgKTtcclxuICAgICAgICAgICAgZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID0gMTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIGF0dHJpYnV0ZURpdmlzb3JzWyBhdHRyaWJ1dGUgXSAhPT0gbWVzaFBlckF0dHJpYnV0ZSApIHtcclxuXHJcbiAgICAgICAgICAgIGV4dGVuc2lvbi52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoIGF0dHJpYnV0ZSwgbWVzaFBlckF0dHJpYnV0ZSApO1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVEaXZpc29yc1sgYXR0cmlidXRlIF0gPSBtZXNoUGVyQXR0cmlidXRlO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBlbmFibGVkQXR0cmlidXRlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBlbmFibGVkQXR0cmlidXRlc1sgaSBdICE9PSBuZXdBdHRyaWJ1dGVzWyBpIF0gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KCBpICk7XHJcbiAgICAgICAgICAgICAgICBlbmFibGVkQXR0cmlidXRlc1sgaSBdID0gMDtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5lbmFibGUgPSBmdW5jdGlvbiAoIGlkICkge1xyXG5cclxuICAgICAgICBpZiAoIGNhcGFiaWxpdGllc1sgaWQgXSAhPT0gdHJ1ZSApIHtcclxuXHJcbiAgICAgICAgICAgIGdsLmVuYWJsZSggaWQgKTtcclxuICAgICAgICAgICAgY2FwYWJpbGl0aWVzWyBpZCBdID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5kaXNhYmxlID0gZnVuY3Rpb24gKCBpZCApIHtcclxuXHJcbiAgICAgICAgaWYgKCBjYXBhYmlsaXRpZXNbIGlkIF0gIT09IGZhbHNlICkge1xyXG5cclxuICAgICAgICAgICAgZ2wuZGlzYWJsZSggaWQgKTtcclxuICAgICAgICAgICAgY2FwYWJpbGl0aWVzWyBpZCBdID0gZmFsc2U7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZ2V0Q29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICBpZiAoIGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyA9PT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgIGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKSB8fFxyXG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZm9ybWF0cyA9IGdsLmdldFBhcmFtZXRlciggZ2wuQ09NUFJFU1NFRF9URVhUVVJFX0ZPUk1BVFMgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBmb3JtYXRzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzLnB1c2goIGZvcm1hdHNbIGkgXSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zZXRCbGVuZGluZyA9IGZ1bmN0aW9uICggYmxlbmRpbmcsIGJsZW5kRXF1YXRpb24sIGJsZW5kU3JjLCBibGVuZERzdCwgYmxlbmRFcXVhdGlvbkFscGhhLCBibGVuZFNyY0FscGhhLCBibGVuZERzdEFscGhhICkge1xyXG5cclxuICAgICAgICBpZiAoIGJsZW5kaW5nICE9PSBjdXJyZW50QmxlbmRpbmcgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGJsZW5kaW5nID09PSBUSFJFRS5Ob0JsZW5kaW5nICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzYWJsZSggZ2wuQkxFTkQgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGJsZW5kaW5nID09PSBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlKCBnbC5CTEVORCApO1xyXG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRFcXVhdGlvbiggZ2wuRlVOQ19BREQgKTtcclxuICAgICAgICAgICAgICAgIGdsLmJsZW5kRnVuYyggZ2wuU1JDX0FMUEhBLCBnbC5PTkUgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGJsZW5kaW5nID09PSBUSFJFRS5TdWJ0cmFjdGl2ZUJsZW5kaW5nICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IEZpbmQgYmxlbmRGdW5jU2VwYXJhdGUoKSBjb21iaW5hdGlvblxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlKCBnbC5CTEVORCApO1xyXG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRFcXVhdGlvbiggZ2wuRlVOQ19BREQgKTtcclxuICAgICAgICAgICAgICAgIGdsLmJsZW5kRnVuYyggZ2wuWkVSTywgZ2wuT05FX01JTlVTX1NSQ19DT0xPUiApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIGlmICggYmxlbmRpbmcgPT09IFRIUkVFLk11bHRpcGx5QmxlbmRpbmcgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogRmluZCBibGVuZEZ1bmNTZXBhcmF0ZSgpIGNvbWJpbmF0aW9uXHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGUoIGdsLkJMRU5EICk7XHJcbiAgICAgICAgICAgICAgICBnbC5ibGVuZEVxdWF0aW9uKCBnbC5GVU5DX0FERCApO1xyXG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRGdW5jKCBnbC5aRVJPLCBnbC5TUkNfQ09MT1IgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGJsZW5kaW5nID09PSBUSFJFRS5DdXN0b21CbGVuZGluZyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZSggZ2wuQkxFTkQgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGUoIGdsLkJMRU5EICk7XHJcbiAgICAgICAgICAgICAgICBnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoIGdsLkZVTkNfQURELCBnbC5GVU5DX0FERCApO1xyXG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUoIGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjdXJyZW50QmxlbmRpbmcgPSBibGVuZGluZztcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIGJsZW5kaW5nID09PSBUSFJFRS5DdXN0b21CbGVuZGluZyApIHtcclxuXHJcbiAgICAgICAgICAgIGJsZW5kRXF1YXRpb25BbHBoYSA9IGJsZW5kRXF1YXRpb25BbHBoYSB8fCBibGVuZEVxdWF0aW9uO1xyXG4gICAgICAgICAgICBibGVuZFNyY0FscGhhID0gYmxlbmRTcmNBbHBoYSB8fCBibGVuZFNyYztcclxuICAgICAgICAgICAgYmxlbmREc3RBbHBoYSA9IGJsZW5kRHN0QWxwaGEgfHwgYmxlbmREc3Q7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGJsZW5kRXF1YXRpb24gIT09IGN1cnJlbnRCbGVuZEVxdWF0aW9uIHx8IGJsZW5kRXF1YXRpb25BbHBoYSAhPT0gY3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoIHBhcmFtVGhyZWVUb0dMKCBibGVuZEVxdWF0aW9uICksIHBhcmFtVGhyZWVUb0dMKCBibGVuZEVxdWF0aW9uQWxwaGEgKSApO1xyXG5cclxuICAgICAgICAgICAgICAgIGN1cnJlbnRCbGVuZEVxdWF0aW9uID0gYmxlbmRFcXVhdGlvbjtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBibGVuZEVxdWF0aW9uQWxwaGE7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIGJsZW5kU3JjICE9PSBjdXJyZW50QmxlbmRTcmMgfHwgYmxlbmREc3QgIT09IGN1cnJlbnRCbGVuZERzdCB8fCBibGVuZFNyY0FscGhhICE9PSBjdXJyZW50QmxlbmRTcmNBbHBoYSB8fCBibGVuZERzdEFscGhhICE9PSBjdXJyZW50QmxlbmREc3RBbHBoYSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggcGFyYW1UaHJlZVRvR0woIGJsZW5kU3JjICksIHBhcmFtVGhyZWVUb0dMKCBibGVuZERzdCApLCBwYXJhbVRocmVlVG9HTCggYmxlbmRTcmNBbHBoYSApLCBwYXJhbVRocmVlVG9HTCggYmxlbmREc3RBbHBoYSApICk7XHJcblxyXG4gICAgICAgICAgICAgICAgY3VycmVudEJsZW5kU3JjID0gYmxlbmRTcmM7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50QmxlbmREc3QgPSBibGVuZERzdDtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRCbGVuZFNyY0FscGhhID0gYmxlbmRTcmNBbHBoYTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRCbGVuZERzdEFscGhhID0gYmxlbmREc3RBbHBoYTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIGN1cnJlbnRCbGVuZEVxdWF0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgY3VycmVudEJsZW5kU3JjID0gbnVsbDtcclxuICAgICAgICAgICAgY3VycmVudEJsZW5kRHN0ID0gbnVsbDtcclxuICAgICAgICAgICAgY3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSA9IG51bGw7XHJcbiAgICAgICAgICAgIGN1cnJlbnRCbGVuZFNyY0FscGhhID0gbnVsbDtcclxuICAgICAgICAgICAgY3VycmVudEJsZW5kRHN0QWxwaGEgPSBudWxsO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnNldERlcHRoRnVuYyA9IGZ1bmN0aW9uICggZGVwdGhGdW5jICkge1xyXG5cclxuICAgICAgICBpZiAoIGN1cnJlbnREZXB0aEZ1bmMgIT09IGRlcHRoRnVuYyApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggZGVwdGhGdW5jICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoIGRlcHRoRnVuYyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5OZXZlckRlcHRoOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKCBnbC5ORVZFUiApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5BbHdheXNEZXB0aDpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmRlcHRoRnVuYyggZ2wuQUxXQVlTICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLkxlc3NEZXB0aDpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmRlcHRoRnVuYyggZ2wuTEVTUyApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5MZXNzRXF1YWxEZXB0aDpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmRlcHRoRnVuYyggZ2wuTEVRVUFMICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLkVxdWFsRGVwdGg6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5kZXB0aEZ1bmMoIGdsLkVRVUFMICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLkdyZWF0ZXJFcXVhbERlcHRoOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKCBnbC5HRVFVQUwgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuR3JlYXRlckRlcHRoOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKCBnbC5HUkVBVEVSICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLk5vdEVxdWFsRGVwdGg6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5kZXB0aEZ1bmMoIGdsLk5PVEVRVUFMICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKCBnbC5MRVFVQUwgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIGdsLmRlcHRoRnVuYyggZ2wuTEVRVUFMICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjdXJyZW50RGVwdGhGdW5jID0gZGVwdGhGdW5jO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnNldERlcHRoVGVzdCA9IGZ1bmN0aW9uICggZGVwdGhUZXN0ICkge1xyXG5cclxuICAgICAgICBpZiAoIGRlcHRoVGVzdCApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRpc2FibGUoIGdsLkRFUFRIX1RFU1QgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zZXREZXB0aFdyaXRlID0gZnVuY3Rpb24gKCBkZXB0aFdyaXRlICkge1xyXG5cclxuICAgICAgICBpZiAoIGN1cnJlbnREZXB0aFdyaXRlICE9PSBkZXB0aFdyaXRlICkge1xyXG5cclxuICAgICAgICAgICAgZ2wuZGVwdGhNYXNrKCBkZXB0aFdyaXRlICk7XHJcbiAgICAgICAgICAgIGN1cnJlbnREZXB0aFdyaXRlID0gZGVwdGhXcml0ZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zZXRDb2xvcldyaXRlID0gZnVuY3Rpb24gKCBjb2xvcldyaXRlICkge1xyXG5cclxuICAgICAgICBpZiAoIGN1cnJlbnRDb2xvcldyaXRlICE9PSBjb2xvcldyaXRlICkge1xyXG5cclxuICAgICAgICAgICAgZ2wuY29sb3JNYXNrKCBjb2xvcldyaXRlLCBjb2xvcldyaXRlLCBjb2xvcldyaXRlLCBjb2xvcldyaXRlICk7XHJcbiAgICAgICAgICAgIGN1cnJlbnRDb2xvcldyaXRlID0gY29sb3JXcml0ZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zZXRGbGlwU2lkZWQgPSBmdW5jdGlvbiAoIGZsaXBTaWRlZCApIHtcclxuXHJcbiAgICAgICAgaWYgKCBjdXJyZW50RmxpcFNpZGVkICE9PSBmbGlwU2lkZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGZsaXBTaWRlZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC5mcm9udEZhY2UoIGdsLkNXICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIGdsLmZyb250RmFjZSggZ2wuQ0NXICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjdXJyZW50RmxpcFNpZGVkID0gZmxpcFNpZGVkO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnNldExpbmVXaWR0aCA9IGZ1bmN0aW9uICggd2lkdGggKSB7XHJcblxyXG4gICAgICAgIGlmICggd2lkdGggIT09IGN1cnJlbnRMaW5lV2lkdGggKSB7XHJcblxyXG4gICAgICAgICAgICBnbC5saW5lV2lkdGgoIHdpZHRoICk7XHJcblxyXG4gICAgICAgICAgICBjdXJyZW50TGluZVdpZHRoID0gd2lkdGg7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc2V0UG9seWdvbk9mZnNldCA9IGZ1bmN0aW9uICggcG9seWdvbk9mZnNldCwgZmFjdG9yLCB1bml0cyApIHtcclxuXHJcbiAgICAgICAgaWYgKCBwb2x5Z29uT2Zmc2V0ICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5lbmFibGUoIGdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwgKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZSggZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggcG9seWdvbk9mZnNldCAmJiAoIGN1cnJlbnRQb2x5Z29uT2Zmc2V0RmFjdG9yICE9PSBmYWN0b3IgfHwgY3VycmVudFBvbHlnb25PZmZzZXRVbml0cyAhPT0gdW5pdHMgKSApIHtcclxuXHJcbiAgICAgICAgICAgIGdsLnBvbHlnb25PZmZzZXQoIGZhY3RvciwgdW5pdHMgKTtcclxuXHJcbiAgICAgICAgICAgIGN1cnJlbnRQb2x5Z29uT2Zmc2V0RmFjdG9yID0gZmFjdG9yO1xyXG4gICAgICAgICAgICBjdXJyZW50UG9seWdvbk9mZnNldFVuaXRzID0gdW5pdHM7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc2V0U2Npc3NvclRlc3QgPSBmdW5jdGlvbiAoIHNjaXNzb3JUZXN0ICkge1xyXG5cclxuICAgICAgICBpZiAoIHNjaXNzb3JUZXN0ICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5lbmFibGUoIGdsLlNDSVNTT1JfVEVTVCApO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5kaXNhYmxlKCBnbC5TQ0lTU09SX1RFU1QgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLy8gdGV4dHVyZVxyXG5cclxuICAgIHRoaXMuYWN0aXZlVGV4dHVyZSA9IGZ1bmN0aW9uICggd2ViZ2xTbG90ICkge1xyXG5cclxuICAgICAgICBpZiAoIHdlYmdsU2xvdCA9PT0gdW5kZWZpbmVkICkgd2ViZ2xTbG90ID0gZ2wuVEVYVFVSRTAgKyBtYXhUZXh0dXJlcyAtIDE7XHJcblxyXG4gICAgICAgIGlmICggY3VycmVudFRleHR1cmVTbG90ICE9PSB3ZWJnbFNsb3QgKSB7XHJcblxyXG4gICAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKCB3ZWJnbFNsb3QgKTtcclxuICAgICAgICAgICAgY3VycmVudFRleHR1cmVTbG90ID0gd2ViZ2xTbG90O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuYmluZFRleHR1cmUgPSBmdW5jdGlvbiAoIHdlYmdsVHlwZSwgd2ViZ2xUZXh0dXJlICkge1xyXG5cclxuICAgICAgICBpZiAoIGN1cnJlbnRUZXh0dXJlU2xvdCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgX3RoaXMuYWN0aXZlVGV4dHVyZSgpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBib3VuZFRleHR1cmUgPSBjdXJyZW50Qm91bmRUZXh0dXJlc1sgY3VycmVudFRleHR1cmVTbG90IF07XHJcblxyXG4gICAgICAgIGlmICggYm91bmRUZXh0dXJlID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBib3VuZFRleHR1cmUgPSB7IHR5cGU6IHVuZGVmaW5lZCwgdGV4dHVyZTogdW5kZWZpbmVkIH07XHJcbiAgICAgICAgICAgIGN1cnJlbnRCb3VuZFRleHR1cmVzWyBjdXJyZW50VGV4dHVyZVNsb3QgXSA9IGJvdW5kVGV4dHVyZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIGJvdW5kVGV4dHVyZS50eXBlICE9PSB3ZWJnbFR5cGUgfHwgYm91bmRUZXh0dXJlLnRleHR1cmUgIT09IHdlYmdsVGV4dHVyZSApIHtcclxuXHJcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKCB3ZWJnbFR5cGUsIHdlYmdsVGV4dHVyZSApO1xyXG5cclxuICAgICAgICAgICAgYm91bmRUZXh0dXJlLnR5cGUgPSB3ZWJnbFR5cGU7XHJcbiAgICAgICAgICAgIGJvdW5kVGV4dHVyZS50ZXh0dXJlID0gd2ViZ2xUZXh0dXJlO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmNvbXByZXNzZWRUZXhJbWFnZTJEID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0cnkge1xyXG5cclxuICAgICAgICAgICAgZ2wuY29tcHJlc3NlZFRleEltYWdlMkQuYXBwbHkoIGdsLCBhcmd1bWVudHMgKTtcclxuXHJcbiAgICAgICAgfSBjYXRjaCAoIGVycm9yICkge1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggZXJyb3IgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy50ZXhJbWFnZTJEID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0cnkge1xyXG5cclxuICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRC5hcHBseSggZ2wsIGFyZ3VtZW50cyApO1xyXG5cclxuICAgICAgICB9IGNhdGNoICggZXJyb3IgKSB7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCBlcnJvciApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvL1xyXG5cclxuICAgIHRoaXMucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGVuYWJsZWRBdHRyaWJ1dGVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggZW5hYmxlZEF0dHJpYnV0ZXNbIGkgXSA9PT0gMSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoIGkgKTtcclxuICAgICAgICAgICAgICAgIGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPSAwO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNhcGFiaWxpdGllcyA9IHt9O1xyXG5cclxuICAgICAgICBjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgPSBudWxsO1xyXG5cclxuICAgICAgICBjdXJyZW50QmxlbmRpbmcgPSBudWxsO1xyXG5cclxuICAgICAgICBjdXJyZW50RGVwdGhXcml0ZSA9IG51bGw7XHJcbiAgICAgICAgY3VycmVudENvbG9yV3JpdGUgPSBudWxsO1xyXG5cclxuICAgICAgICBjdXJyZW50RmxpcFNpZGVkID0gbnVsbDtcclxuXHJcbiAgICB9O1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9wbHVnaW5zL0xlbnNGbGFyZVBsdWdpbi5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTGVuc0ZsYXJlUGx1Z2luID0gZnVuY3Rpb24gKCByZW5kZXJlciwgZmxhcmVzICkge1xyXG5cclxuICAgIHZhciBnbCA9IHJlbmRlcmVyLmNvbnRleHQ7XHJcbiAgICB2YXIgc3RhdGUgPSByZW5kZXJlci5zdGF0ZTtcclxuXHJcbiAgICB2YXIgdmVydGV4QnVmZmVyLCBlbGVtZW50QnVmZmVyO1xyXG4gICAgdmFyIHByb2dyYW0sIGF0dHJpYnV0ZXMsIHVuaWZvcm1zO1xyXG4gICAgdmFyIGhhc1ZlcnRleFRleHR1cmU7XHJcblxyXG4gICAgdmFyIHRlbXBUZXh0dXJlLCBvY2NsdXNpb25UZXh0dXJlO1xyXG5cclxuICAgIGZ1bmN0aW9uIGluaXQoKSB7XHJcblxyXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcclxuICAgICAgICAgICAgLSAxLCAtIDEsICAwLCAwLFxyXG4gICAgICAgICAgICAxLCAtIDEsICAxLCAwLFxyXG4gICAgICAgICAgICAxLCAgMSwgIDEsIDEsXHJcbiAgICAgICAgICAgIC0gMSwgIDEsICAwLCAxXHJcbiAgICAgICAgXSApO1xyXG5cclxuICAgICAgICB2YXIgZmFjZXMgPSBuZXcgVWludDE2QXJyYXkoIFtcclxuICAgICAgICAgICAgMCwgMSwgMixcclxuICAgICAgICAgICAgMCwgMiwgM1xyXG4gICAgICAgIF0gKTtcclxuXHJcbiAgICAgICAgLy8gYnVmZmVyc1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXIgICAgID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgICAgZWxlbWVudEJ1ZmZlciAgICA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cclxuICAgICAgICBnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xyXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGljZXMsIGdsLlNUQVRJQ19EUkFXICk7XHJcblxyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBlbGVtZW50QnVmZmVyICk7XHJcbiAgICAgICAgZ2wuYnVmZmVyRGF0YSggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGZhY2VzLCBnbC5TVEFUSUNfRFJBVyApO1xyXG5cclxuICAgICAgICAvLyB0ZXh0dXJlc1xyXG5cclxuICAgICAgICB0ZW1wVGV4dHVyZSAgICAgID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG4gICAgICAgIG9jY2x1c2lvblRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XHJcblxyXG4gICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCB0ZW1wVGV4dHVyZSApO1xyXG4gICAgICAgIGdsLnRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQiwgMTYsIDE2LCAwLCBnbC5SR0IsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwgKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSApO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFICk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUICk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUICk7XHJcblxyXG4gICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBvY2NsdXNpb25UZXh0dXJlICk7XHJcbiAgICAgICAgZ2wudGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgMTYsIDE2LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsICk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UgKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSApO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xyXG5cclxuICAgICAgICBoYXNWZXJ0ZXhUZXh0dXJlID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKSA+IDA7XHJcblxyXG4gICAgICAgIHZhciBzaGFkZXI7XHJcblxyXG4gICAgICAgIGlmICggaGFzVmVydGV4VGV4dHVyZSApIHtcclxuXHJcbiAgICAgICAgICAgIHNoYWRlciA9IHtcclxuXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSB2ZWMzIHNjcmVlblBvc2l0aW9uO1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSB2ZWMyIHNjYWxlO1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCByb3RhdGlvbjtcIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ1bmlmb3JtIHNhbXBsZXIyRCBvY2NsdXNpb25NYXA7XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwiYXR0cmlidXRlIHZlYzIgcG9zaXRpb247XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMiB1djtcIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ2YXJ5aW5nIHZlYzIgdlVWO1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidmFyeWluZyBmbG9hdCB2VmlzaWJpbGl0eTtcIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwidlVWID0gdXY7XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwidmVjMiBwb3MgPSBwb3NpdGlvbjtcIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJpZiAoIHJlbmRlclR5cGUgPT0gMiApIHtcIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ2ZWM0IHZpc2liaWxpdHkgPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC4xLCAwLjEgKSApO1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC41LCAwLjEgKSApO1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC45LCAwLjEgKSApO1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC45LCAwLjUgKSApO1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC45LCAwLjkgKSApO1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC41LCAwLjkgKSApO1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC4xLCAwLjkgKSApO1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC4xLCAwLjUgKSApO1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC41LCAwLjUgKSApO1wiLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcInZWaXNpYmlsaXR5ID0gICAgICAgIHZpc2liaWxpdHkuciAvIDkuMDtcIixcclxuICAgICAgICAgICAgICAgICAgICBcInZWaXNpYmlsaXR5ICo9IDEuMCAtIHZpc2liaWxpdHkuZyAvIDkuMDtcIixcclxuICAgICAgICAgICAgICAgICAgICBcInZWaXNpYmlsaXR5ICo9ICAgICAgIHZpc2liaWxpdHkuYiAvIDkuMDtcIixcclxuICAgICAgICAgICAgICAgICAgICBcInZWaXNpYmlsaXR5ICo9IDEuMCAtIHZpc2liaWxpdHkuYSAvIDkuMDtcIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJwb3MueCA9IGNvcyggcm90YXRpb24gKSAqIHBvc2l0aW9uLnggLSBzaW4oIHJvdGF0aW9uICkgKiBwb3NpdGlvbi55O1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwicG9zLnkgPSBzaW4oIHJvdGF0aW9uICkgKiBwb3NpdGlvbi54ICsgY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueTtcIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ9XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwiZ2xfUG9zaXRpb24gPSB2ZWM0KCAoIHBvcyAqIHNjYWxlICsgc2NyZWVuUG9zaXRpb24ueHkgKS54eSwgc2NyZWVuUG9zaXRpb24ueiwgMS4wICk7XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwifVwiXHJcblxyXG4gICAgICAgICAgICAgICAgXS5qb2luKCBcIlxcblwiICksXHJcblxyXG4gICAgICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSBzYW1wbGVyMkQgbWFwO1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSB2ZWMzIGNvbG9yO1wiLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcInZhcnlpbmcgdmVjMiB2VVY7XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ2YXJ5aW5nIGZsb2F0IHZWaXNpYmlsaXR5O1wiLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcGluayBzcXVhcmVcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJpZiAoIHJlbmRlclR5cGUgPT0gMCApIHtcIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJnbF9GcmFnQ29sb3IgPSB2ZWM0KCAxLjAsIDAuMCwgMS4wLCAwLjAgKTtcIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcIn0gZWxzZSBpZiAoIHJlbmRlclR5cGUgPT0gMSApIHtcIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZsYXJlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwifSBlbHNlIHtcIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ2ZWM0IHRleHR1cmUgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0dXJlLmEgKj0gb3BhY2l0eSAqIHZWaXNpYmlsaXR5O1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTtcIixcclxuICAgICAgICAgICAgICAgICAgICBcImdsX0ZyYWdDb2xvci5yZ2IgKj0gY29sb3I7XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwifVwiLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcIn1cIlxyXG5cclxuICAgICAgICAgICAgICAgIF0uam9pbiggXCJcXG5cIiApXHJcblxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgc2hhZGVyID0ge1xyXG5cclxuICAgICAgICAgICAgICAgIHZlcnRleFNoYWRlcjogW1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBcInVuaWZvcm0gbG93cCBpbnQgcmVuZGVyVHlwZTtcIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ1bmlmb3JtIHZlYzMgc2NyZWVuUG9zaXRpb247XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ1bmlmb3JtIHZlYzIgc2NhbGU7XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IHJvdGF0aW9uO1wiLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcImF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiYXR0cmlidXRlIHZlYzIgdXY7XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwidmFyeWluZyB2ZWMyIHZVVjtcIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwidlVWID0gdXY7XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwidmVjMiBwb3MgPSBwb3NpdGlvbjtcIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJpZiAoIHJlbmRlclR5cGUgPT0gMiApIHtcIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJwb3MueCA9IGNvcyggcm90YXRpb24gKSAqIHBvc2l0aW9uLnggLSBzaW4oIHJvdGF0aW9uICkgKiBwb3NpdGlvbi55O1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwicG9zLnkgPSBzaW4oIHJvdGF0aW9uICkgKiBwb3NpdGlvbi54ICsgY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueTtcIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ9XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwiZ2xfUG9zaXRpb24gPSB2ZWM0KCAoIHBvcyAqIHNjYWxlICsgc2NyZWVuUG9zaXRpb24ueHkgKS54eSwgc2NyZWVuUG9zaXRpb24ueiwgMS4wICk7XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwifVwiXHJcblxyXG4gICAgICAgICAgICAgICAgXS5qb2luKCBcIlxcblwiICksXHJcblxyXG4gICAgICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSBzYW1wbGVyMkQgbWFwO1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSBzYW1wbGVyMkQgb2NjbHVzaW9uTWFwO1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSB2ZWMzIGNvbG9yO1wiLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcInZhcnlpbmcgdmVjMiB2VVY7XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBwaW5rIHNxdWFyZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcImlmICggcmVuZGVyVHlwZSA9PSAwICkge1wiLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcImdsX0ZyYWdDb2xvciA9IHZlYzQoIHRleHR1cmUyRCggbWFwLCB2VVYgKS5yZ2IsIDAuMCApO1wiLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwifSBlbHNlIGlmICggcmVuZGVyVHlwZSA9PSAxICkge1wiLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcImdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTtcIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZmxhcmVcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ9IGVsc2Uge1wiLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcImZsb2F0IHZpc2liaWxpdHkgPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC41LCAwLjEgKSApLmE7XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuNSApICkuYTtcIixcclxuICAgICAgICAgICAgICAgICAgICBcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC45ICkgKS5hO1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC4xLCAwLjUgKSApLmE7XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ2aXNpYmlsaXR5ID0gKCAxLjAgLSB2aXNpYmlsaXR5IC8gNC4wICk7XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwidmVjNCB0ZXh0dXJlID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dHVyZS5hICo9IG9wYWNpdHkgKiB2aXNpYmlsaXR5O1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTtcIixcclxuICAgICAgICAgICAgICAgICAgICBcImdsX0ZyYWdDb2xvci5yZ2IgKj0gY29sb3I7XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwifVwiLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcIn1cIlxyXG5cclxuICAgICAgICAgICAgICAgIF0uam9pbiggXCJcXG5cIiApXHJcblxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKCBzaGFkZXIgKTtcclxuXHJcbiAgICAgICAgYXR0cmlidXRlcyA9IHtcclxuICAgICAgICAgICAgdmVydGV4OiBnbC5nZXRBdHRyaWJMb2NhdGlvbiAoIHByb2dyYW0sIFwicG9zaXRpb25cIiApLFxyXG4gICAgICAgICAgICB1djogICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uICggcHJvZ3JhbSwgXCJ1dlwiIClcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB1bmlmb3JtcyA9IHtcclxuICAgICAgICAgICAgcmVuZGVyVHlwZTogICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJyZW5kZXJUeXBlXCIgKSxcclxuICAgICAgICAgICAgbWFwOiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJtYXBcIiApLFxyXG4gICAgICAgICAgICBvY2NsdXNpb25NYXA6ICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcIm9jY2x1c2lvbk1hcFwiICksXHJcbiAgICAgICAgICAgIG9wYWNpdHk6ICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwib3BhY2l0eVwiICksXHJcbiAgICAgICAgICAgIGNvbG9yOiAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwiY29sb3JcIiApLFxyXG4gICAgICAgICAgICBzY2FsZTogICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcInNjYWxlXCIgKSxcclxuICAgICAgICAgICAgcm90YXRpb246ICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJyb3RhdGlvblwiICksXHJcbiAgICAgICAgICAgIHNjcmVlblBvc2l0aW9uOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwic2NyZWVuUG9zaXRpb25cIiApXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgICAqIFJlbmRlciBsZW5zIGZsYXJlc1xyXG4gICAgICogTWV0aG9kOiByZW5kZXJzIDE2eDE2IDB4ZmYwMGZmLWNvbG9yZWQgcG9pbnRzIHNjYXR0ZXJlZCBvdmVyIHRoZSBsaWdodCBzb3VyY2UgYXJlYSxcclxuICAgICAqICAgICAgICAgcmVhZHMgdGhlc2UgYmFjayBhbmQgY2FsY3VsYXRlcyBvY2NsdXNpb24uXHJcbiAgICAgKi9cclxuXHJcbiAgICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSwgdmlld3BvcnRXaWR0aCwgdmlld3BvcnRIZWlnaHQgKSB7XHJcblxyXG4gICAgICAgIGlmICggZmxhcmVzLmxlbmd0aCA9PT0gMCApIHJldHVybjtcclxuXHJcbiAgICAgICAgdmFyIHRlbXBQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgIHZhciBpbnZBc3BlY3QgPSB2aWV3cG9ydEhlaWdodCAvIHZpZXdwb3J0V2lkdGgsXHJcbiAgICAgICAgICAgIGhhbGZWaWV3cG9ydFdpZHRoID0gdmlld3BvcnRXaWR0aCAqIDAuNSxcclxuICAgICAgICAgICAgaGFsZlZpZXdwb3J0SGVpZ2h0ID0gdmlld3BvcnRIZWlnaHQgKiAwLjU7XHJcblxyXG4gICAgICAgIHZhciBzaXplID0gMTYgLyB2aWV3cG9ydEhlaWdodCxcclxuICAgICAgICAgICAgc2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMiggc2l6ZSAqIGludkFzcGVjdCwgc2l6ZSApO1xyXG5cclxuICAgICAgICB2YXIgc2NyZWVuUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMSwgMCApLFxyXG4gICAgICAgICAgICBzY3JlZW5Qb3NpdGlvblBpeGVscyA9IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICk7XHJcblxyXG4gICAgICAgIGlmICggcHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgaW5pdCgpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdsLnVzZVByb2dyYW0oIHByb2dyYW0gKTtcclxuXHJcbiAgICAgICAgc3RhdGUuaW5pdEF0dHJpYnV0ZXMoKTtcclxuICAgICAgICBzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMudmVydGV4ICk7XHJcbiAgICAgICAgc3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnV2ICk7XHJcbiAgICAgICAgc3RhdGUuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcclxuXHJcbiAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGFsbCBsZW5zIGZsYXJlcyB0byB1cGRhdGUgdGhlaXIgb2NjbHVzaW9uIGFuZCBwb3NpdGlvbnNcclxuICAgICAgICAvLyBzZXR1cCBnbCBhbmQgY29tbW9uIHVzZWQgYXR0cmlicy91bmlmb3Jtc1xyXG5cclxuICAgICAgICBnbC51bmlmb3JtMWkoIHVuaWZvcm1zLm9jY2x1c2lvbk1hcCwgMCApO1xyXG4gICAgICAgIGdsLnVuaWZvcm0xaSggdW5pZm9ybXMubWFwLCAxICk7XHJcblxyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyICk7XHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy52ZXJ0ZXgsIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDAgKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnV2LCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCA4ICk7XHJcblxyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBlbGVtZW50QnVmZmVyICk7XHJcblxyXG4gICAgICAgIHN0YXRlLmRpc2FibGUoIGdsLkNVTExfRkFDRSApO1xyXG4gICAgICAgIGdsLmRlcHRoTWFzayggZmFsc2UgKTtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gZmxhcmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICBzaXplID0gMTYgLyB2aWV3cG9ydEhlaWdodDtcclxuICAgICAgICAgICAgc2NhbGUuc2V0KCBzaXplICogaW52QXNwZWN0LCBzaXplICk7XHJcblxyXG4gICAgICAgICAgICAvLyBjYWxjIG9iamVjdCBzY3JlZW4gcG9zaXRpb25cclxuXHJcbiAgICAgICAgICAgIHZhciBmbGFyZSA9IGZsYXJlc1sgaSBdO1xyXG5cclxuICAgICAgICAgICAgdGVtcFBvc2l0aW9uLnNldCggZmxhcmUubWF0cml4V29ybGQuZWxlbWVudHNbIDEyIF0sIGZsYXJlLm1hdHJpeFdvcmxkLmVsZW1lbnRzWyAxMyBdLCBmbGFyZS5tYXRyaXhXb3JsZC5lbGVtZW50c1sgMTQgXSApO1xyXG5cclxuICAgICAgICAgICAgdGVtcFBvc2l0aW9uLmFwcGx5TWF0cml4NCggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xyXG4gICAgICAgICAgICB0ZW1wUG9zaXRpb24uYXBwbHlQcm9qZWN0aW9uKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xyXG5cclxuICAgICAgICAgICAgLy8gc2V0dXAgYXJyYXlzIGZvciBnbCBwcm9ncmFtc1xyXG5cclxuICAgICAgICAgICAgc2NyZWVuUG9zaXRpb24uY29weSggdGVtcFBvc2l0aW9uICk7XHJcblxyXG4gICAgICAgICAgICBzY3JlZW5Qb3NpdGlvblBpeGVscy54ID0gc2NyZWVuUG9zaXRpb24ueCAqIGhhbGZWaWV3cG9ydFdpZHRoICsgaGFsZlZpZXdwb3J0V2lkdGg7XHJcbiAgICAgICAgICAgIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgPSBzY3JlZW5Qb3NpdGlvbi55ICogaGFsZlZpZXdwb3J0SGVpZ2h0ICsgaGFsZlZpZXdwb3J0SGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgLy8gc2NyZWVuIGN1bGxcclxuXHJcbiAgICAgICAgICAgIGlmICggaGFzVmVydGV4VGV4dHVyZSB8fCAoXHJcbiAgICAgICAgICAgICAgICBzY3JlZW5Qb3NpdGlvblBpeGVscy54ID4gMCAmJlxyXG4gICAgICAgICAgICAgICAgc2NyZWVuUG9zaXRpb25QaXhlbHMueCA8IHZpZXdwb3J0V2lkdGggJiZcclxuICAgICAgICAgICAgICAgIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgPiAwICYmXHJcbiAgICAgICAgICAgICAgICBzY3JlZW5Qb3NpdGlvblBpeGVscy55IDwgdmlld3BvcnRIZWlnaHQgKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBzYXZlIGN1cnJlbnQgUkdCIHRvIHRlbXAgdGV4dHVyZVxyXG5cclxuICAgICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUwICk7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xyXG4gICAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlVGV4dHVyZSggZ2wuVEVYVFVSRTEgKTtcclxuICAgICAgICAgICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCB0ZW1wVGV4dHVyZSApO1xyXG4gICAgICAgICAgICAgICAgZ2wuY29weVRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQiwgc2NyZWVuUG9zaXRpb25QaXhlbHMueCAtIDgsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgLSA4LCAxNiwgMTYsIDAgKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyIHBpbmsgcXVhZFxyXG5cclxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xaSggdW5pZm9ybXMucmVuZGVyVHlwZSwgMCApO1xyXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTJmKCB1bmlmb3Jtcy5zY2FsZSwgc2NhbGUueCwgc2NhbGUueSApO1xyXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5zY3JlZW5Qb3NpdGlvbiwgc2NyZWVuUG9zaXRpb24ueCwgc2NyZWVuUG9zaXRpb24ueSwgc2NyZWVuUG9zaXRpb24ueiApO1xyXG5cclxuICAgICAgICAgICAgICAgIHN0YXRlLmRpc2FibGUoIGdsLkJMRU5EICk7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5lbmFibGUoIGdsLkRFUFRIX1RFU1QgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoIGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY29weSByZXN1bHQgdG8gb2NjbHVzaW9uTWFwXHJcblxyXG4gICAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlVGV4dHVyZSggZ2wuVEVYVFVSRTAgKTtcclxuICAgICAgICAgICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBvY2NsdXNpb25UZXh0dXJlICk7XHJcbiAgICAgICAgICAgICAgICBnbC5jb3B5VGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgc2NyZWVuUG9zaXRpb25QaXhlbHMueCAtIDgsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgLSA4LCAxNiwgMTYsIDAgKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBncmFwaGljc1xyXG5cclxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xaSggdW5pZm9ybXMucmVuZGVyVHlwZSwgMSApO1xyXG4gICAgICAgICAgICAgICAgc3RhdGUuZGlzYWJsZSggZ2wuREVQVEhfVEVTVCApO1xyXG5cclxuICAgICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUxICk7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgdGVtcFRleHR1cmUgKTtcclxuICAgICAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgb2JqZWN0IHBvc2l0aW9uc1xyXG5cclxuICAgICAgICAgICAgICAgIGZsYXJlLnBvc2l0aW9uU2NyZWVuLmNvcHkoIHNjcmVlblBvc2l0aW9uICk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBmbGFyZS5jdXN0b21VcGRhdGVDYWxsYmFjayApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZmxhcmUuY3VzdG9tVXBkYXRlQ2FsbGJhY2soIGZsYXJlICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZmxhcmUudXBkYXRlTGVuc0ZsYXJlcygpO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyByZW5kZXIgZmxhcmVzXHJcblxyXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5yZW5kZXJUeXBlLCAyICk7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5lbmFibGUoIGdsLkJMRU5EICk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IGZsYXJlLmxlbnNGbGFyZXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzcHJpdGUgPSBmbGFyZS5sZW5zRmxhcmVzWyBqIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggc3ByaXRlLm9wYWNpdHkgPiAwLjAwMSAmJiBzcHJpdGUuc2NhbGUgPiAwLjAwMSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmVlblBvc2l0aW9uLnggPSBzcHJpdGUueDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NyZWVuUG9zaXRpb24ueSA9IHNwcml0ZS55O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JlZW5Qb3NpdGlvbi56ID0gc3ByaXRlLno7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplID0gc3ByaXRlLnNpemUgKiBzcHJpdGUuc2NhbGUgLyB2aWV3cG9ydEhlaWdodDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlLnggPSBzaXplICogaW52QXNwZWN0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZS55ID0gc2l6ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuc2NyZWVuUG9zaXRpb24sIHNjcmVlblBvc2l0aW9uLngsIHNjcmVlblBvc2l0aW9uLnksIHNjcmVlblBvc2l0aW9uLnogKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTJmKCB1bmlmb3Jtcy5zY2FsZSwgc2NhbGUueCwgc2NhbGUueSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWYoIHVuaWZvcm1zLnJvdGF0aW9uLCBzcHJpdGUucm90YXRpb24gKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xZiggdW5pZm9ybXMub3BhY2l0eSwgc3ByaXRlLm9wYWNpdHkgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5jb2xvciwgc3ByaXRlLmNvbG9yLnIsIHNwcml0ZS5jb2xvci5nLCBzcHJpdGUuY29sb3IuYiApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuc2V0QmxlbmRpbmcoIHNwcml0ZS5ibGVuZGluZywgc3ByaXRlLmJsZW5kRXF1YXRpb24sIHNwcml0ZS5ibGVuZFNyYywgc3ByaXRlLmJsZW5kRHN0ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyLnNldFRleHR1cmUoIHNwcml0ZS50ZXh0dXJlLCAxICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoIGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyByZXN0b3JlIGdsXHJcblxyXG4gICAgICAgIHN0YXRlLmVuYWJsZSggZ2wuQ1VMTF9GQUNFICk7XHJcbiAgICAgICAgc3RhdGUuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XHJcbiAgICAgICAgZ2wuZGVwdGhNYXNrKCB0cnVlICk7XHJcblxyXG4gICAgICAgIHJlbmRlcmVyLnJlc2V0R0xTdGF0ZSgpO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbSAoIHNoYWRlciApIHtcclxuXHJcbiAgICAgICAgdmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XHJcblxyXG4gICAgICAgIHZhciBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggZ2wuRlJBR01FTlRfU0hBREVSICk7XHJcbiAgICAgICAgdmFyIHZlcnRleFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggZ2wuVkVSVEVYX1NIQURFUiApO1xyXG5cclxuICAgICAgICB2YXIgcHJlZml4ID0gXCJwcmVjaXNpb24gXCIgKyByZW5kZXJlci5nZXRQcmVjaXNpb24oKSArIFwiIGZsb2F0O1xcblwiO1xyXG5cclxuICAgICAgICBnbC5zaGFkZXJTb3VyY2UoIGZyYWdtZW50U2hhZGVyLCBwcmVmaXggKyBzaGFkZXIuZnJhZ21lbnRTaGFkZXIgKTtcclxuICAgICAgICBnbC5zaGFkZXJTb3VyY2UoIHZlcnRleFNoYWRlciwgcHJlZml4ICsgc2hhZGVyLnZlcnRleFNoYWRlciApO1xyXG5cclxuICAgICAgICBnbC5jb21waWxlU2hhZGVyKCBmcmFnbWVudFNoYWRlciApO1xyXG4gICAgICAgIGdsLmNvbXBpbGVTaGFkZXIoIHZlcnRleFNoYWRlciApO1xyXG5cclxuICAgICAgICBnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGZyYWdtZW50U2hhZGVyICk7XHJcbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIgKTtcclxuXHJcbiAgICAgICAgZ2wubGlua1Byb2dyYW0oIHByb2dyYW0gKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHByb2dyYW07XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9wbHVnaW5zL1Nwcml0ZVBsdWdpbi5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU3ByaXRlUGx1Z2luID0gZnVuY3Rpb24gKCByZW5kZXJlciwgc3ByaXRlcyApIHtcclxuXHJcbiAgICB2YXIgZ2wgPSByZW5kZXJlci5jb250ZXh0O1xyXG4gICAgdmFyIHN0YXRlID0gcmVuZGVyZXIuc3RhdGU7XHJcblxyXG4gICAgdmFyIHZlcnRleEJ1ZmZlciwgZWxlbWVudEJ1ZmZlcjtcclxuICAgIHZhciBwcm9ncmFtLCBhdHRyaWJ1dGVzLCB1bmlmb3JtcztcclxuXHJcbiAgICB2YXIgdGV4dHVyZTtcclxuXHJcbiAgICAvLyBkZWNvbXBvc2UgbWF0cml4V29ybGRcclxuXHJcbiAgICB2YXIgc3ByaXRlUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgdmFyIHNwcml0ZVJvdGF0aW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcclxuICAgIHZhciBzcHJpdGVTY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgZnVuY3Rpb24gaW5pdCgpIHtcclxuXHJcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggW1xyXG4gICAgICAgICAgICAtIDAuNSwgLSAwLjUsICAwLCAwLFxyXG4gICAgICAgICAgICAwLjUsIC0gMC41LCAgMSwgMCxcclxuICAgICAgICAgICAgMC41LCAgIDAuNSwgIDEsIDEsXHJcbiAgICAgICAgICAgIC0gMC41LCAgIDAuNSwgIDAsIDFcclxuICAgICAgICBdICk7XHJcblxyXG4gICAgICAgIHZhciBmYWNlcyA9IG5ldyBVaW50MTZBcnJheSggW1xyXG4gICAgICAgICAgICAwLCAxLCAyLFxyXG4gICAgICAgICAgICAwLCAyLCAzXHJcbiAgICAgICAgXSApO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXIgID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgICAgZWxlbWVudEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cclxuICAgICAgICBnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xyXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGljZXMsIGdsLlNUQVRJQ19EUkFXICk7XHJcblxyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBlbGVtZW50QnVmZmVyICk7XHJcbiAgICAgICAgZ2wuYnVmZmVyRGF0YSggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGZhY2VzLCBnbC5TVEFUSUNfRFJBVyApO1xyXG5cclxuICAgICAgICBwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSgpO1xyXG5cclxuICAgICAgICBhdHRyaWJ1dGVzID0ge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjpcdFx0XHRnbC5nZXRBdHRyaWJMb2NhdGlvbiAoIHByb2dyYW0sICdwb3NpdGlvbicgKSxcclxuICAgICAgICAgICAgdXY6XHRcdFx0XHRcdGdsLmdldEF0dHJpYkxvY2F0aW9uICggcHJvZ3JhbSwgJ3V2JyApXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdW5pZm9ybXMgPSB7XHJcbiAgICAgICAgICAgIHV2T2Zmc2V0Olx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3V2T2Zmc2V0JyApLFxyXG4gICAgICAgICAgICB1dlNjYWxlOlx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3V2U2NhbGUnICksXHJcblxyXG4gICAgICAgICAgICByb3RhdGlvbjpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdyb3RhdGlvbicgKSxcclxuICAgICAgICAgICAgc2NhbGU6XHRcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdzY2FsZScgKSxcclxuXHJcbiAgICAgICAgICAgIGNvbG9yOlx0XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnY29sb3InICksXHJcbiAgICAgICAgICAgIG1hcDpcdFx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ21hcCcgKSxcclxuICAgICAgICAgICAgb3BhY2l0eTpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdvcGFjaXR5JyApLFxyXG5cclxuICAgICAgICAgICAgbW9kZWxWaWV3TWF0cml4OiBcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ21vZGVsVmlld01hdHJpeCcgKSxcclxuICAgICAgICAgICAgcHJvamVjdGlvbk1hdHJpeDpcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3Byb2plY3Rpb25NYXRyaXgnICksXHJcblxyXG4gICAgICAgICAgICBmb2dUeXBlOlx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ1R5cGUnICksXHJcbiAgICAgICAgICAgIGZvZ0RlbnNpdHk6XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nRGVuc2l0eScgKSxcclxuICAgICAgICAgICAgZm9nTmVhcjpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dOZWFyJyApLFxyXG4gICAgICAgICAgICBmb2dGYXI6XHRcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dGYXInICksXHJcbiAgICAgICAgICAgIGZvZ0NvbG9yOlx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ0NvbG9yJyApLFxyXG5cclxuICAgICAgICAgICAgYWxwaGFUZXN0Olx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2FscGhhVGVzdCcgKVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xyXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IDg7XHJcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IDg7XHJcblxyXG4gICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcclxuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XHJcbiAgICAgICAgY29udGV4dC5maWxsUmVjdCggMCwgMCwgOCwgOCApO1xyXG5cclxuICAgICAgICB0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoIGNhbnZhcyApO1xyXG4gICAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSApIHtcclxuXHJcbiAgICAgICAgaWYgKCBzcHJpdGVzLmxlbmd0aCA9PT0gMCApIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8gc2V0dXAgZ2xcclxuXHJcbiAgICAgICAgaWYgKCBwcm9ncmFtID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBpbml0KCk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2wudXNlUHJvZ3JhbSggcHJvZ3JhbSApO1xyXG5cclxuICAgICAgICBzdGF0ZS5pbml0QXR0cmlidXRlcygpO1xyXG4gICAgICAgIHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5wb3NpdGlvbiApO1xyXG4gICAgICAgIHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy51diApO1xyXG4gICAgICAgIHN0YXRlLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XHJcblxyXG4gICAgICAgIHN0YXRlLmRpc2FibGUoIGdsLkNVTExfRkFDRSApO1xyXG4gICAgICAgIHN0YXRlLmVuYWJsZSggZ2wuQkxFTkQgKTtcclxuXHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIgKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnBvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCAwICk7XHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy51diwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogOCwgOCApO1xyXG5cclxuICAgICAgICBnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZWxlbWVudEJ1ZmZlciApO1xyXG5cclxuICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KCB1bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4LCBmYWxzZSwgY2FtZXJhLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHMgKTtcclxuXHJcbiAgICAgICAgc3RhdGUuYWN0aXZlVGV4dHVyZSggZ2wuVEVYVFVSRTAgKTtcclxuICAgICAgICBnbC51bmlmb3JtMWkoIHVuaWZvcm1zLm1hcCwgMCApO1xyXG5cclxuICAgICAgICB2YXIgb2xkRm9nVHlwZSA9IDA7XHJcbiAgICAgICAgdmFyIHNjZW5lRm9nVHlwZSA9IDA7XHJcbiAgICAgICAgdmFyIGZvZyA9IHNjZW5lLmZvZztcclxuXHJcbiAgICAgICAgaWYgKCBmb2cgKSB7XHJcblxyXG4gICAgICAgICAgICBnbC51bmlmb3JtM2YoIHVuaWZvcm1zLmZvZ0NvbG9yLCBmb2cuY29sb3IuciwgZm9nLmNvbG9yLmcsIGZvZy5jb2xvci5iICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWYoIHVuaWZvcm1zLmZvZ05lYXIsIGZvZy5uZWFyICk7XHJcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWYoIHVuaWZvcm1zLmZvZ0ZhciwgZm9nLmZhciApO1xyXG5cclxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgMSApO1xyXG4gICAgICAgICAgICAgICAgb2xkRm9nVHlwZSA9IDE7XHJcbiAgICAgICAgICAgICAgICBzY2VuZUZvZ1R5cGUgPSAxO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIGlmICggZm9nIGluc3RhbmNlb2YgVEhSRUUuRm9nRXhwMiApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWYoIHVuaWZvcm1zLmZvZ0RlbnNpdHksIGZvZy5kZW5zaXR5ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5mb2dUeXBlLCAyICk7XHJcbiAgICAgICAgICAgICAgICBvbGRGb2dUeXBlID0gMjtcclxuICAgICAgICAgICAgICAgIHNjZW5lRm9nVHlwZSA9IDI7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICBnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIDAgKTtcclxuICAgICAgICAgICAgb2xkRm9nVHlwZSA9IDA7XHJcbiAgICAgICAgICAgIHNjZW5lRm9nVHlwZSA9IDA7XHJcblxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSBwb3NpdGlvbnMgYW5kIHNvcnRcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gc3ByaXRlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHNwcml0ZSA9IHNwcml0ZXNbIGkgXTtcclxuXHJcbiAgICAgICAgICAgIHNwcml0ZS5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgc3ByaXRlLm1hdHJpeFdvcmxkICk7XHJcbiAgICAgICAgICAgIHNwcml0ZS56ID0gLSBzcHJpdGUubW9kZWxWaWV3TWF0cml4LmVsZW1lbnRzWyAxNCBdO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNwcml0ZXMuc29ydCggcGFpbnRlclNvcnRTdGFibGUgKTtcclxuXHJcbiAgICAgICAgLy8gcmVuZGVyIGFsbCBzcHJpdGVzXHJcblxyXG4gICAgICAgIHZhciBzY2FsZSA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBzcHJpdGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgc3ByaXRlID0gc3ByaXRlc1sgaSBdO1xyXG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWwgPSBzcHJpdGUubWF0ZXJpYWw7XHJcblxyXG4gICAgICAgICAgICBnbC51bmlmb3JtMWYoIHVuaWZvcm1zLmFscGhhVGVzdCwgbWF0ZXJpYWwuYWxwaGFUZXN0ICk7XHJcbiAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYoIHVuaWZvcm1zLm1vZGVsVmlld01hdHJpeCwgZmFsc2UsIHNwcml0ZS5tb2RlbFZpZXdNYXRyaXguZWxlbWVudHMgKTtcclxuXHJcbiAgICAgICAgICAgIHNwcml0ZS5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHNwcml0ZVBvc2l0aW9uLCBzcHJpdGVSb3RhdGlvbiwgc3ByaXRlU2NhbGUgKTtcclxuXHJcbiAgICAgICAgICAgIHNjYWxlWyAwIF0gPSBzcHJpdGVTY2FsZS54O1xyXG4gICAgICAgICAgICBzY2FsZVsgMSBdID0gc3ByaXRlU2NhbGUueTtcclxuXHJcbiAgICAgICAgICAgIHZhciBmb2dUeXBlID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmICggc2NlbmUuZm9nICYmIG1hdGVyaWFsLmZvZyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBmb2dUeXBlID0gc2NlbmVGb2dUeXBlO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBvbGRGb2dUeXBlICE9PSBmb2dUeXBlICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgZm9nVHlwZSApO1xyXG4gICAgICAgICAgICAgICAgb2xkRm9nVHlwZSA9IGZvZ1R5cGU7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIG1hdGVyaWFsLm1hcCAhPT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnV2T2Zmc2V0LCBtYXRlcmlhbC5tYXAub2Zmc2V0LngsIG1hdGVyaWFsLm1hcC5vZmZzZXQueSApO1xyXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dlNjYWxlLCBtYXRlcmlhbC5tYXAucmVwZWF0LngsIG1hdGVyaWFsLm1hcC5yZXBlYXQueSApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnV2T2Zmc2V0LCAwLCAwICk7XHJcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnV2U2NhbGUsIDEsIDEgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZiggdW5pZm9ybXMub3BhY2l0eSwgbWF0ZXJpYWwub3BhY2l0eSApO1xyXG4gICAgICAgICAgICBnbC51bmlmb3JtM2YoIHVuaWZvcm1zLmNvbG9yLCBtYXRlcmlhbC5jb2xvci5yLCBtYXRlcmlhbC5jb2xvci5nLCBtYXRlcmlhbC5jb2xvci5iICk7XHJcblxyXG4gICAgICAgICAgICBnbC51bmlmb3JtMWYoIHVuaWZvcm1zLnJvdGF0aW9uLCBtYXRlcmlhbC5yb3RhdGlvbiApO1xyXG4gICAgICAgICAgICBnbC51bmlmb3JtMmZ2KCB1bmlmb3Jtcy5zY2FsZSwgc2NhbGUgKTtcclxuXHJcbiAgICAgICAgICAgIHN0YXRlLnNldEJsZW5kaW5nKCBtYXRlcmlhbC5ibGVuZGluZywgbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbiwgbWF0ZXJpYWwuYmxlbmRTcmMsIG1hdGVyaWFsLmJsZW5kRHN0ICk7XHJcbiAgICAgICAgICAgIHN0YXRlLnNldERlcHRoVGVzdCggbWF0ZXJpYWwuZGVwdGhUZXN0ICk7XHJcbiAgICAgICAgICAgIHN0YXRlLnNldERlcHRoV3JpdGUoIG1hdGVyaWFsLmRlcHRoV3JpdGUgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggbWF0ZXJpYWwubWFwICYmIG1hdGVyaWFsLm1hcC5pbWFnZSAmJiBtYXRlcmlhbC5tYXAuaW1hZ2Uud2lkdGggKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuc2V0VGV4dHVyZSggbWF0ZXJpYWwubWFwLCAwICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnNldFRleHR1cmUoIHRleHR1cmUsIDAgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJlc3RvcmUgZ2xcclxuXHJcbiAgICAgICAgc3RhdGUuZW5hYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcclxuXHJcbiAgICAgICAgcmVuZGVyZXIucmVzZXRHTFN0YXRlKCk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVQcm9ncmFtICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XHJcblxyXG4gICAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIGdsLlZFUlRFWF9TSEFERVIgKTtcclxuICAgICAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIGdsLkZSQUdNRU5UX1NIQURFUiApO1xyXG5cclxuICAgICAgICBnbC5zaGFkZXJTb3VyY2UoIHZlcnRleFNoYWRlciwgW1xyXG5cclxuICAgICAgICAgICAgJ3ByZWNpc2lvbiAnICsgcmVuZGVyZXIuZ2V0UHJlY2lzaW9uKCkgKyAnIGZsb2F0OycsXHJcblxyXG4gICAgICAgICAgICAndW5pZm9ybSBtYXQ0IG1vZGVsVmlld01hdHJpeDsnLFxyXG4gICAgICAgICAgICAndW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7JyxcclxuICAgICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgcm90YXRpb247JyxcclxuICAgICAgICAgICAgJ3VuaWZvcm0gdmVjMiBzY2FsZTsnLFxyXG4gICAgICAgICAgICAndW5pZm9ybSB2ZWMyIHV2T2Zmc2V0OycsXHJcbiAgICAgICAgICAgICd1bmlmb3JtIHZlYzIgdXZTY2FsZTsnLFxyXG5cclxuICAgICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uOycsXHJcbiAgICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiB1djsnLFxyXG5cclxuICAgICAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VVY7JyxcclxuXHJcbiAgICAgICAgICAgICd2b2lkIG1haW4oKSB7JyxcclxuXHJcbiAgICAgICAgICAgICd2VVYgPSB1dk9mZnNldCArIHV2ICogdXZTY2FsZTsnLFxyXG5cclxuICAgICAgICAgICAgJ3ZlYzIgYWxpZ25lZFBvc2l0aW9uID0gcG9zaXRpb24gKiBzY2FsZTsnLFxyXG5cclxuICAgICAgICAgICAgJ3ZlYzIgcm90YXRlZFBvc2l0aW9uOycsXHJcbiAgICAgICAgICAgICdyb3RhdGVkUG9zaXRpb24ueCA9IGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7JyxcclxuICAgICAgICAgICAgJ3JvdGF0ZWRQb3NpdGlvbi55ID0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnggKyBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueTsnLFxyXG5cclxuICAgICAgICAgICAgJ3ZlYzQgZmluYWxQb3NpdGlvbjsnLFxyXG5cclxuICAgICAgICAgICAgJ2ZpbmFsUG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCAwLjAsIDAuMCwgMC4wLCAxLjAgKTsnLFxyXG4gICAgICAgICAgICAnZmluYWxQb3NpdGlvbi54eSArPSByb3RhdGVkUG9zaXRpb247JyxcclxuICAgICAgICAgICAgJ2ZpbmFsUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogZmluYWxQb3NpdGlvbjsnLFxyXG5cclxuICAgICAgICAgICAgJ2dsX1Bvc2l0aW9uID0gZmluYWxQb3NpdGlvbjsnLFxyXG5cclxuICAgICAgICAgICAgJ30nXHJcblxyXG4gICAgICAgIF0uam9pbiggJ1xcbicgKSApO1xyXG5cclxuICAgICAgICBnbC5zaGFkZXJTb3VyY2UoIGZyYWdtZW50U2hhZGVyLCBbXHJcblxyXG4gICAgICAgICAgICAncHJlY2lzaW9uICcgKyByZW5kZXJlci5nZXRQcmVjaXNpb24oKSArICcgZmxvYXQ7JyxcclxuXHJcbiAgICAgICAgICAgICd1bmlmb3JtIHZlYzMgY29sb3I7JyxcclxuICAgICAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIG1hcDsnLFxyXG4gICAgICAgICAgICAndW5pZm9ybSBmbG9hdCBvcGFjaXR5OycsXHJcblxyXG4gICAgICAgICAgICAndW5pZm9ybSBpbnQgZm9nVHlwZTsnLFxyXG4gICAgICAgICAgICAndW5pZm9ybSB2ZWMzIGZvZ0NvbG9yOycsXHJcbiAgICAgICAgICAgICd1bmlmb3JtIGZsb2F0IGZvZ0RlbnNpdHk7JyxcclxuICAgICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgZm9nTmVhcjsnLFxyXG4gICAgICAgICAgICAndW5pZm9ybSBmbG9hdCBmb2dGYXI7JyxcclxuICAgICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgYWxwaGFUZXN0OycsXHJcblxyXG4gICAgICAgICAgICAndmFyeWluZyB2ZWMyIHZVVjsnLFxyXG5cclxuICAgICAgICAgICAgJ3ZvaWQgbWFpbigpIHsnLFxyXG5cclxuICAgICAgICAgICAgJ3ZlYzQgdGV4dHVyZSA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTsnLFxyXG5cclxuICAgICAgICAgICAgJ2lmICggdGV4dHVyZS5hIDwgYWxwaGFUZXN0ICkgZGlzY2FyZDsnLFxyXG5cclxuICAgICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IHZlYzQoIGNvbG9yICogdGV4dHVyZS54eXosIHRleHR1cmUuYSAqIG9wYWNpdHkgKTsnLFxyXG5cclxuICAgICAgICAgICAgJ2lmICggZm9nVHlwZSA+IDAgKSB7JyxcclxuXHJcbiAgICAgICAgICAgICdmbG9hdCBkZXB0aCA9IGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLnc7JyxcclxuICAgICAgICAgICAgJ2Zsb2F0IGZvZ0ZhY3RvciA9IDAuMDsnLFxyXG5cclxuICAgICAgICAgICAgJ2lmICggZm9nVHlwZSA9PSAxICkgeycsXHJcblxyXG4gICAgICAgICAgICAnZm9nRmFjdG9yID0gc21vb3Roc3RlcCggZm9nTmVhciwgZm9nRmFyLCBkZXB0aCApOycsXHJcblxyXG4gICAgICAgICAgICAnfSBlbHNlIHsnLFxyXG5cclxuICAgICAgICAgICAgJ2NvbnN0IGZsb2F0IExPRzIgPSAxLjQ0MjY5NTsnLFxyXG4gICAgICAgICAgICAnZm9nRmFjdG9yID0gZXhwMiggLSBmb2dEZW5zaXR5ICogZm9nRGVuc2l0eSAqIGRlcHRoICogZGVwdGggKiBMT0cyICk7JyxcclxuICAgICAgICAgICAgJ2ZvZ0ZhY3RvciA9IDEuMCAtIGNsYW1wKCBmb2dGYWN0b3IsIDAuMCwgMS4wICk7JyxcclxuXHJcbiAgICAgICAgICAgICd9JyxcclxuXHJcbiAgICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBtaXgoIGdsX0ZyYWdDb2xvciwgdmVjNCggZm9nQ29sb3IsIGdsX0ZyYWdDb2xvci53ICksIGZvZ0ZhY3RvciApOycsXHJcblxyXG4gICAgICAgICAgICAnfScsXHJcblxyXG4gICAgICAgICAgICAnfSdcclxuXHJcbiAgICAgICAgXS5qb2luKCAnXFxuJyApICk7XHJcblxyXG4gICAgICAgIGdsLmNvbXBpbGVTaGFkZXIoIHZlcnRleFNoYWRlciApO1xyXG4gICAgICAgIGdsLmNvbXBpbGVTaGFkZXIoIGZyYWdtZW50U2hhZGVyICk7XHJcblxyXG4gICAgICAgIGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgdmVydGV4U2hhZGVyICk7XHJcbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBmcmFnbWVudFNoYWRlciApO1xyXG5cclxuICAgICAgICBnbC5saW5rUHJvZ3JhbSggcHJvZ3JhbSApO1xyXG5cclxuICAgICAgICByZXR1cm4gcHJvZ3JhbTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGFpbnRlclNvcnRTdGFibGUgKCBhLCBiICkge1xyXG5cclxuICAgICAgICBpZiAoIGEueiAhPT0gYi56ICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGIueiAtIGEuejtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBiLmlkIC0gYS5pZDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvQ3VydmVVdGlscy5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICovXHJcblxyXG5USFJFRS5DdXJ2ZVV0aWxzID0ge1xyXG5cclxuICAgIHRhbmdlbnRRdWFkcmF0aWNCZXppZXI6IGZ1bmN0aW9uICggdCwgcDAsIHAxLCBwMiApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIDIgKiAoIDEgLSB0ICkgKiAoIHAxIC0gcDAgKSArIDIgKiB0ICogKCBwMiAtIHAxICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBQdWF5IEJpbmcsIHRoYW5rcyBmb3IgaGVscGluZyB3aXRoIHRoaXMgZGVyaXZhdGl2ZSFcclxuXHJcbiAgICB0YW5nZW50Q3ViaWNCZXppZXI6IGZ1bmN0aW9uICggdCwgcDAsIHAxLCBwMiwgcDMgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiAtIDMgKiBwMCAqICggMSAtIHQgKSAqICggMSAtIHQgKSAgK1xyXG4gICAgICAgICAgICAzICogcDEgKiAoIDEgLSB0ICkgKiAoIDEgLSB0ICkgLSA2ICogdCAqIHAxICogKCAxIC0gdCApICtcclxuICAgICAgICAgICAgNiAqIHQgKiAgcDIgKiAoIDEgLSB0ICkgLSAzICogdCAqIHQgKiBwMiArXHJcbiAgICAgICAgICAgIDMgKiB0ICogdCAqIHAzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdGFuZ2VudFNwbGluZTogZnVuY3Rpb24gKCB0LCBwMCwgcDEsIHAyLCBwMyApIHtcclxuXHJcbiAgICAgICAgLy8gVG8gY2hlY2sgaWYgbXkgZm9ybXVsYXMgYXJlIGNvcnJlY3RcclxuXHJcbiAgICAgICAgdmFyIGgwMCA9IDYgKiB0ICogdCAtIDYgKiB0OyBcdC8vIGRlcml2ZWQgZnJvbSAydF4zID8gM3ReMiArIDFcclxuICAgICAgICB2YXIgaDEwID0gMyAqIHQgKiB0IC0gNCAqIHQgKyAxOyAvLyB0XjMgPyAydF4yICsgdFxyXG4gICAgICAgIHZhciBoMDEgPSAtIDYgKiB0ICogdCArIDYgKiB0OyBcdC8vID8gMnQzICsgM3QyXHJcbiAgICAgICAgdmFyIGgxMSA9IDMgKiB0ICogdCAtIDIgKiB0O1x0Ly8gdDMgPyB0MlxyXG5cclxuICAgICAgICByZXR1cm4gaDAwICsgaDEwICsgaDAxICsgaDExO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLy8gQ2F0bXVsbC1Sb21cclxuXHJcbiAgICBpbnRlcnBvbGF0ZTogZnVuY3Rpb24oIHAwLCBwMSwgcDIsIHAzLCB0ICkge1xyXG5cclxuICAgICAgICB2YXIgdjAgPSAoIHAyIC0gcDAgKSAqIDAuNTtcclxuICAgICAgICB2YXIgdjEgPSAoIHAzIC0gcDEgKSAqIDAuNTtcclxuICAgICAgICB2YXIgdDIgPSB0ICogdDtcclxuICAgICAgICB2YXIgdDMgPSB0ICogdDI7XHJcbiAgICAgICAgcmV0dXJuICggMiAqIHAxIC0gMiAqIHAyICsgdjAgKyB2MSApICogdDMgKyAoIC0gMyAqIHAxICsgMyAqIHAyIC0gMiAqIHYwIC0gdjEgKSAqIHQyICsgdjAgKiB0ICsgcDE7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9HZW9tZXRyeVV0aWxzLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5HZW9tZXRyeVV0aWxzID0ge1xyXG5cclxuICAgIG1lcmdlOiBmdW5jdGlvbiAoIGdlb21ldHJ5MSwgZ2VvbWV0cnkyLCBtYXRlcmlhbEluZGV4T2Zmc2V0ICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5HZW9tZXRyeVV0aWxzOiAubWVyZ2UoKSBoYXMgYmVlbiBtb3ZlZCB0byBHZW9tZXRyeS4gVXNlIGdlb21ldHJ5Lm1lcmdlKCBnZW9tZXRyeTIsIG1hdHJpeCwgbWF0ZXJpYWxJbmRleE9mZnNldCApIGluc3RlYWQuJyApO1xyXG5cclxuICAgICAgICB2YXIgbWF0cml4O1xyXG5cclxuICAgICAgICBpZiAoIGdlb21ldHJ5MiBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XHJcblxyXG4gICAgICAgICAgICBnZW9tZXRyeTIubWF0cml4QXV0b1VwZGF0ZSAmJiBnZW9tZXRyeTIudXBkYXRlTWF0cml4KCk7XHJcblxyXG4gICAgICAgICAgICBtYXRyaXggPSBnZW9tZXRyeTIubWF0cml4O1xyXG4gICAgICAgICAgICBnZW9tZXRyeTIgPSBnZW9tZXRyeTIuZ2VvbWV0cnk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2VvbWV0cnkxLm1lcmdlKCBnZW9tZXRyeTIsIG1hdHJpeCwgbWF0ZXJpYWxJbmRleE9mZnNldCApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2VudGVyOiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5HZW9tZXRyeVV0aWxzOiAuY2VudGVyKCkgaGFzIGJlZW4gbW92ZWQgdG8gR2VvbWV0cnkuIFVzZSBnZW9tZXRyeS5jZW50ZXIoKSBpbnN0ZWFkLicgKTtcclxuICAgICAgICByZXR1cm4gZ2VvbWV0cnkuY2VudGVyKCk7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9JbWFnZVV0aWxzLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBEYW9zaGVuZyBNdSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9EYW9zaGVuZ011L1xyXG4gKi9cclxuXHJcblRIUkVFLkltYWdlVXRpbHMgPSB7XHJcblxyXG4gICAgY3Jvc3NPcmlnaW46IHVuZGVmaW5lZCxcclxuXHJcbiAgICBsb2FkVGV4dHVyZTogZnVuY3Rpb24gKCB1cmwsIG1hcHBpbmcsIG9uTG9hZCwgb25FcnJvciApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuSW1hZ2VVdGlscy5sb2FkVGV4dHVyZSBpcyBiZWluZyBkZXByZWNhdGVkLiBVc2UgVEhSRUUuVGV4dHVyZUxvYWRlcigpIGluc3RlYWQuJyApO1xyXG5cclxuICAgICAgICB2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoKTtcclxuICAgICAgICBsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcclxuXHJcbiAgICAgICAgdmFyIHRleHR1cmUgPSBsb2FkZXIubG9hZCggdXJsLCBvbkxvYWQsIHVuZGVmaW5lZCwgb25FcnJvciApO1xyXG5cclxuICAgICAgICBpZiAoIG1hcHBpbmcgKSB0ZXh0dXJlLm1hcHBpbmcgPSBtYXBwaW5nO1xyXG5cclxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGxvYWRUZXh0dXJlQ3ViZTogZnVuY3Rpb24gKCB1cmxzLCBtYXBwaW5nLCBvbkxvYWQsIG9uRXJyb3IgKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkltYWdlVXRpbHMubG9hZFRleHR1cmVDdWJlIGlzIGJlaW5nIGRlcHJlY2F0ZWQuIFVzZSBUSFJFRS5DdWJlVGV4dHVyZUxvYWRlcigpIGluc3RlYWQuJyApO1xyXG5cclxuICAgICAgICB2YXIgbG9hZGVyID0gbmV3IFRIUkVFLkN1YmVUZXh0dXJlTG9hZGVyKCk7XHJcbiAgICAgICAgbG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XHJcblxyXG4gICAgICAgIHZhciB0ZXh0dXJlID0gbG9hZGVyLmxvYWQoIHVybHMsIG9uTG9hZCwgdW5kZWZpbmVkLCBvbkVycm9yICk7XHJcblxyXG4gICAgICAgIGlmICggbWFwcGluZyApIHRleHR1cmUubWFwcGluZyA9IG1hcHBpbmc7XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbG9hZENvbXByZXNzZWRUZXh0dXJlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5JbWFnZVV0aWxzLmxvYWRDb21wcmVzc2VkVGV4dHVyZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuRERTTG9hZGVyIGluc3RlYWQuJyApXHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBsb2FkQ29tcHJlc3NlZFRleHR1cmVDdWJlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5JbWFnZVV0aWxzLmxvYWRDb21wcmVzc2VkVGV4dHVyZUN1YmUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkREU0xvYWRlciBpbnN0ZWFkLicgKVxyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvU2NlbmVVdGlscy5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU2NlbmVVdGlscyA9IHtcclxuXHJcbiAgICBjcmVhdGVNdWx0aU1hdGVyaWFsT2JqZWN0OiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbHMgKSB7XHJcblxyXG4gICAgICAgIHZhciBncm91cCA9IG5ldyBUSFJFRS5Hcm91cCgpO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBtYXRlcmlhbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIGdyb3VwLmFkZCggbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbHNbIGkgXSApICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGdyb3VwO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZGV0YWNoOiBmdW5jdGlvbiAoIGNoaWxkLCBwYXJlbnQsIHNjZW5lICkge1xyXG5cclxuICAgICAgICBjaGlsZC5hcHBseU1hdHJpeCggcGFyZW50Lm1hdHJpeFdvcmxkICk7XHJcbiAgICAgICAgcGFyZW50LnJlbW92ZSggY2hpbGQgKTtcclxuICAgICAgICBzY2VuZS5hZGQoIGNoaWxkICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhdHRhY2g6IGZ1bmN0aW9uICggY2hpbGQsIHNjZW5lLCBwYXJlbnQgKSB7XHJcblxyXG4gICAgICAgIHZhciBtYXRyaXhXb3JsZEludmVyc2UgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG4gICAgICAgIG1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCBwYXJlbnQubWF0cml4V29ybGQgKTtcclxuICAgICAgICBjaGlsZC5hcHBseU1hdHJpeCggbWF0cml4V29ybGRJbnZlcnNlICk7XHJcblxyXG4gICAgICAgIHNjZW5lLnJlbW92ZSggY2hpbGQgKTtcclxuICAgICAgICBwYXJlbnQuYWRkKCBjaGlsZCApO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvU2hhcGVVdGlscy5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICovXHJcblxyXG5USFJFRS5TaGFwZVV0aWxzID0ge1xyXG5cclxuICAgIC8vIGNhbGN1bGF0ZSBhcmVhIG9mIHRoZSBjb250b3VyIHBvbHlnb25cclxuXHJcbiAgICBhcmVhOiBmdW5jdGlvbiAoIGNvbnRvdXIgKSB7XHJcblxyXG4gICAgICAgIHZhciBuID0gY29udG91ci5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGEgPSAwLjA7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBwID0gbiAtIDEsIHEgPSAwOyBxIDwgbjsgcCA9IHEgKysgKSB7XHJcblxyXG4gICAgICAgICAgICBhICs9IGNvbnRvdXJbIHAgXS54ICogY29udG91clsgcSBdLnkgLSBjb250b3VyWyBxIF0ueCAqIGNvbnRvdXJbIHAgXS55O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhICogMC41O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdHJpYW5ndWxhdGU6ICggZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIGNvZGUgaXMgYSBxdWljayBwb3J0IG9mIGNvZGUgd3JpdHRlbiBpbiBDKysgd2hpY2ggd2FzIHN1Ym1pdHRlZCB0b1xyXG4gICAgICAgICAqIGZsaXBjb2RlLmNvbSBieSBKb2huIFcuIFJhdGNsaWZmICAvLyBKdWx5IDIyLCAyMDAwXHJcbiAgICAgICAgICogU2VlIG9yaWdpbmFsIGNvZGUgYW5kIG1vcmUgaW5mb3JtYXRpb24gaGVyZTpcclxuICAgICAgICAgKiBodHRwOi8vd3d3LmZsaXBjb2RlLmNvbS9hcmNoaXZlcy9FZmZpY2llbnRfUG9seWdvbl9Ucmlhbmd1bGF0aW9uLnNodG1sXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBwb3J0ZWQgdG8gYWN0aW9uc2NyaXB0IGJ5IFpldmFuIFJvc3NlclxyXG4gICAgICAgICAqIHd3dy5hY3Rpb25zbmlwcGV0LmNvbVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogcG9ydGVkIHRvIGphdmFzY3JpcHQgYnkgSm9zaHVhIEtvb1xyXG4gICAgICAgICAqIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBzbmlwKCBjb250b3VyLCB1LCB2LCB3LCBuLCB2ZXJ0cyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBwO1xyXG4gICAgICAgICAgICB2YXIgYXgsIGF5LCBieCwgYnk7XHJcbiAgICAgICAgICAgIHZhciBjeCwgY3ksIHB4LCBweTtcclxuXHJcbiAgICAgICAgICAgIGF4ID0gY29udG91clsgdmVydHNbIHUgXSBdLng7XHJcbiAgICAgICAgICAgIGF5ID0gY29udG91clsgdmVydHNbIHUgXSBdLnk7XHJcblxyXG4gICAgICAgICAgICBieCA9IGNvbnRvdXJbIHZlcnRzWyB2IF0gXS54O1xyXG4gICAgICAgICAgICBieSA9IGNvbnRvdXJbIHZlcnRzWyB2IF0gXS55O1xyXG5cclxuICAgICAgICAgICAgY3ggPSBjb250b3VyWyB2ZXJ0c1sgdyBdIF0ueDtcclxuICAgICAgICAgICAgY3kgPSBjb250b3VyWyB2ZXJ0c1sgdyBdIF0ueTtcclxuXHJcbiAgICAgICAgICAgIGlmICggTnVtYmVyLkVQU0lMT04gPiAoICggKCBieCAtIGF4ICkgKiAoIGN5IC0gYXkgKSApIC0gKCAoIGJ5IC0gYXkgKSAqICggY3ggLSBheCApICkgKSApIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIHZhciBhWCwgYVksIGJYLCBiWSwgY1gsIGNZO1xyXG4gICAgICAgICAgICB2YXIgYXB4LCBhcHksIGJweCwgYnB5LCBjcHgsIGNweTtcclxuICAgICAgICAgICAgdmFyIGNDUk9TU2FwLCBiQ1JPU1NjcCwgYUNST1NTYnA7XHJcblxyXG4gICAgICAgICAgICBhWCA9IGN4IC0gYng7ICBhWSA9IGN5IC0gYnk7XHJcbiAgICAgICAgICAgIGJYID0gYXggLSBjeDsgIGJZID0gYXkgLSBjeTtcclxuICAgICAgICAgICAgY1ggPSBieCAtIGF4OyAgY1kgPSBieSAtIGF5O1xyXG5cclxuICAgICAgICAgICAgZm9yICggcCA9IDA7IHAgPCBuOyBwICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHB4ID0gY29udG91clsgdmVydHNbIHAgXSBdLng7XHJcbiAgICAgICAgICAgICAgICBweSA9IGNvbnRvdXJbIHZlcnRzWyBwIF0gXS55O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggKCAoIHB4ID09PSBheCApICYmICggcHkgPT09IGF5ICkgKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICggKCBweCA9PT0gYnggKSAmJiAoIHB5ID09PSBieSApICkgfHxcclxuICAgICAgICAgICAgICAgICAgICAoICggcHggPT09IGN4ICkgJiYgKCBweSA9PT0gY3kgKSApIClcdGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGFweCA9IHB4IC0gYXg7ICBhcHkgPSBweSAtIGF5O1xyXG4gICAgICAgICAgICAgICAgYnB4ID0gcHggLSBieDsgIGJweSA9IHB5IC0gYnk7XHJcbiAgICAgICAgICAgICAgICBjcHggPSBweCAtIGN4OyAgY3B5ID0gcHkgLSBjeTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBzZWUgaWYgcCBpcyBpbnNpZGUgdHJpYW5nbGUgYWJjXHJcblxyXG4gICAgICAgICAgICAgICAgYUNST1NTYnAgPSBhWCAqIGJweSAtIGFZICogYnB4O1xyXG4gICAgICAgICAgICAgICAgY0NST1NTYXAgPSBjWCAqIGFweSAtIGNZICogYXB4O1xyXG4gICAgICAgICAgICAgICAgYkNST1NTY3AgPSBiWCAqIGNweSAtIGJZICogY3B4O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggKCBhQ1JPU1NicCA+PSAtIE51bWJlci5FUFNJTE9OICkgJiYgKCBiQ1JPU1NjcCA+PSAtIE51bWJlci5FUFNJTE9OICkgJiYgKCBjQ1JPU1NhcCA+PSAtIE51bWJlci5FUFNJTE9OICkgKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB0YWtlcyBpbiBhbiBjb250b3VyIGFycmF5IGFuZCByZXR1cm5zXHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIGNvbnRvdXIsIGluZGljZXMgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbiA9IGNvbnRvdXIubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBuIDwgMyApIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdLFxyXG4gICAgICAgICAgICAgICAgdmVydHMgPSBbXSxcclxuICAgICAgICAgICAgICAgIHZlcnRJbmRpY2VzID0gW107XHJcblxyXG4gICAgICAgICAgICAvKiB3ZSB3YW50IGEgY291bnRlci1jbG9ja3dpc2UgcG9seWdvbiBpbiB2ZXJ0cyAqL1xyXG5cclxuICAgICAgICAgICAgdmFyIHUsIHYsIHc7XHJcblxyXG4gICAgICAgICAgICBpZiAoIFRIUkVFLlNoYXBlVXRpbHMuYXJlYSggY29udG91ciApID4gMC4wICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHYgPSAwOyB2IDwgbjsgdiArKyApIHZlcnRzWyB2IF0gPSB2O1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCB2ID0gMDsgdiA8IG47IHYgKysgKSB2ZXJ0c1sgdiBdID0gKCBuIC0gMSApIC0gdjtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBudiA9IG47XHJcblxyXG4gICAgICAgICAgICAvKiAgcmVtb3ZlIG52IC0gMiB2ZXJ0aWNlcywgY3JlYXRpbmcgMSB0cmlhbmdsZSBldmVyeSB0aW1lICovXHJcblxyXG4gICAgICAgICAgICB2YXIgY291bnQgPSAyICogbnY7ICAgLyogZXJyb3IgZGV0ZWN0aW9uICovXHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2ID0gbnYgLSAxOyBudiA+IDI7ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8qIGlmIHdlIGxvb3AsIGl0IGlzIHByb2JhYmx5IGEgbm9uLXNpbXBsZSBwb2x5Z29uICovXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCAoIGNvdW50IC0tICkgPD0gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8qKiBUcmlhbmd1bGF0ZTogRVJST1IgLSBwcm9iYWJsZSBiYWQgcG9seWdvbiFcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy90aHJvdyAoIFwiV2FybmluZywgdW5hYmxlIHRvIHRyaWFuZ3VsYXRlIHBvbHlnb24hXCIgKTtcclxuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNvbWV0aW1lcyB3YXJuaW5nIGlzIGZpbmUsIGVzcGVjaWFsbHkgcG9seWdvbnMgYXJlIHRyaWFuZ3VsYXRlZCBpbiByZXZlcnNlLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlNoYXBlVXRpbHM6IFVuYWJsZSB0byB0cmlhbmd1bGF0ZSBwb2x5Z29uISBpbiB0cmlhbmd1bGF0ZSgpJyApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGluZGljZXMgKSByZXR1cm4gdmVydEluZGljZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyogdGhyZWUgY29uc2VjdXRpdmUgdmVydGljZXMgaW4gY3VycmVudCBwb2x5Z29uLCA8dSx2LHc+ICovXHJcblxyXG4gICAgICAgICAgICAgICAgdSA9IHY7IFx0IFx0aWYgKCBudiA8PSB1ICkgdSA9IDA7ICAgICAvKiBwcmV2aW91cyAqL1xyXG4gICAgICAgICAgICAgICAgdiA9IHUgKyAxOyAgaWYgKCBudiA8PSB2ICkgdiA9IDA7ICAgICAvKiBuZXcgdiAgICAqL1xyXG4gICAgICAgICAgICAgICAgdyA9IHYgKyAxOyAgaWYgKCBudiA8PSB3ICkgdyA9IDA7ICAgICAvKiBuZXh0ICAgICAqL1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggc25pcCggY29udG91ciwgdSwgdiwgdywgbnYsIHZlcnRzICkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhLCBiLCBjLCBzLCB0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKiB0cnVlIG5hbWVzIG9mIHRoZSB2ZXJ0aWNlcyAqL1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBhID0gdmVydHNbIHUgXTtcclxuICAgICAgICAgICAgICAgICAgICBiID0gdmVydHNbIHYgXTtcclxuICAgICAgICAgICAgICAgICAgICBjID0gdmVydHNbIHcgXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyogb3V0cHV0IFRyaWFuZ2xlICovXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCBbIGNvbnRvdXJbIGEgXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udG91clsgYiBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250b3VyWyBjIF0gXSApO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmVydEluZGljZXMucHVzaCggWyB2ZXJ0c1sgdSBdLCB2ZXJ0c1sgdiBdLCB2ZXJ0c1sgdyBdIF0gKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyogcmVtb3ZlIHYgZnJvbSB0aGUgcmVtYWluaW5nIHBvbHlnb24gKi9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggcyA9IHYsIHQgPSB2ICsgMTsgdCA8IG52OyBzICsrLCB0ICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVydHNbIHMgXSA9IHZlcnRzWyB0IF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbnYgLS07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qIHJlc2V0IGVycm9yIGRldGVjdGlvbiBjb3VudGVyICovXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ID0gMiAqIG52O1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggaW5kaWNlcyApIHJldHVybiB2ZXJ0SW5kaWNlcztcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0gKSgpLFxyXG5cclxuICAgIHRyaWFuZ3VsYXRlU2hhcGU6IGZ1bmN0aW9uICggY29udG91ciwgaG9sZXMgKSB7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHBvaW50X2luX3NlZ21lbnRfMkRfY29saW4oIGluU2VnUHQxLCBpblNlZ1B0MiwgaW5PdGhlclB0ICkge1xyXG5cclxuICAgICAgICAgICAgLy8gaW5PdGhlclB0IG5lZWRzIHRvIGJlIGNvbGxpbmVhciB0byB0aGUgaW5TZWdtZW50XHJcbiAgICAgICAgICAgIGlmICggaW5TZWdQdDEueCAhPT0gaW5TZWdQdDIueCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGluU2VnUHQxLnggPCBpblNlZ1B0Mi54ICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cdCggKCBpblNlZ1B0MS54IDw9IGluT3RoZXJQdC54ICkgJiYgKCBpbk90aGVyUHQueCA8PSBpblNlZ1B0Mi54ICkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cdCggKCBpblNlZ1B0Mi54IDw9IGluT3RoZXJQdC54ICkgJiYgKCBpbk90aGVyUHQueCA8PSBpblNlZ1B0MS54ICkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggaW5TZWdQdDEueSA8IGluU2VnUHQyLnkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblx0KCAoIGluU2VnUHQxLnkgPD0gaW5PdGhlclB0LnkgKSAmJiAoIGluT3RoZXJQdC55IDw9IGluU2VnUHQyLnkgKSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblx0KCAoIGluU2VnUHQyLnkgPD0gaW5PdGhlclB0LnkgKSAmJiAoIGluT3RoZXJQdC55IDw9IGluU2VnUHQxLnkgKSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBpbnRlcnNlY3Rfc2VnbWVudHNfMkQoIGluU2VnMVB0MSwgaW5TZWcxUHQyLCBpblNlZzJQdDEsIGluU2VnMlB0MiwgaW5FeGNsdWRlQWRqYWNlbnRTZWdzICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHNlZzFkeCA9IGluU2VnMVB0Mi54IC0gaW5TZWcxUHQxLngsICAgc2VnMWR5ID0gaW5TZWcxUHQyLnkgLSBpblNlZzFQdDEueTtcclxuICAgICAgICAgICAgdmFyIHNlZzJkeCA9IGluU2VnMlB0Mi54IC0gaW5TZWcyUHQxLngsICAgc2VnMmR5ID0gaW5TZWcyUHQyLnkgLSBpblNlZzJQdDEueTtcclxuXHJcbiAgICAgICAgICAgIHZhciBzZWcxc2VnMmR4ID0gaW5TZWcxUHQxLnggLSBpblNlZzJQdDEueDtcclxuICAgICAgICAgICAgdmFyIHNlZzFzZWcyZHkgPSBpblNlZzFQdDEueSAtIGluU2VnMlB0MS55O1xyXG5cclxuICAgICAgICAgICAgdmFyIGxpbWl0XHRcdD0gc2VnMWR5ICogc2VnMmR4IC0gc2VnMWR4ICogc2VnMmR5O1xyXG4gICAgICAgICAgICB2YXIgcGVycFNlZzFcdD0gc2VnMWR5ICogc2VnMXNlZzJkeCAtIHNlZzFkeCAqIHNlZzFzZWcyZHk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIE1hdGguYWJzKCBsaW1pdCApID4gTnVtYmVyLkVQU0lMT04gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbm90IHBhcmFsbGVsXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHBlcnBTZWcyO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBsaW1pdCA+IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggKCBwZXJwU2VnMSA8IDAgKSB8fCAoIHBlcnBTZWcxID4gbGltaXQgKSApIFx0XHRyZXR1cm4gW107XHJcbiAgICAgICAgICAgICAgICAgICAgcGVycFNlZzIgPSBzZWcyZHkgKiBzZWcxc2VnMmR4IC0gc2VnMmR4ICogc2VnMXNlZzJkeTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoICggcGVycFNlZzIgPCAwICkgfHwgKCBwZXJwU2VnMiA+IGxpbWl0ICkgKSBcdFx0cmV0dXJuIFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggKCBwZXJwU2VnMSA+IDAgKSB8fCAoIHBlcnBTZWcxIDwgbGltaXQgKSApIFx0XHRyZXR1cm4gW107XHJcbiAgICAgICAgICAgICAgICAgICAgcGVycFNlZzIgPSBzZWcyZHkgKiBzZWcxc2VnMmR4IC0gc2VnMmR4ICogc2VnMXNlZzJkeTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoICggcGVycFNlZzIgPiAwICkgfHwgKCBwZXJwU2VnMiA8IGxpbWl0ICkgKSBcdFx0cmV0dXJuIFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpLmUuIHRvIHJlZHVjZSByb3VuZGluZyBlcnJvcnNcclxuICAgICAgICAgICAgICAgIC8vIGludGVyc2VjdGlvbiBhdCBlbmRwb2ludCBvZiBzZWdtZW50IzE/XHJcbiAgICAgICAgICAgICAgICBpZiAoIHBlcnBTZWcyID09PSAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoICggaW5FeGNsdWRlQWRqYWNlbnRTZWdzICkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKCAoIHBlcnBTZWcxID09PSAwICkgfHwgKCBwZXJwU2VnMSA9PT0gbGltaXQgKSApIClcdFx0cmV0dXJuIFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbIGluU2VnMVB0MSBdO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICggcGVycFNlZzIgPT09IGxpbWl0ICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoICggaW5FeGNsdWRlQWRqYWNlbnRTZWdzICkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKCAoIHBlcnBTZWcxID09PSAwICkgfHwgKCBwZXJwU2VnMSA9PT0gbGltaXQgKSApIClcdFx0cmV0dXJuIFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbIGluU2VnMVB0MiBdO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGludGVyc2VjdGlvbiBhdCBlbmRwb2ludCBvZiBzZWdtZW50IzI/XHJcbiAgICAgICAgICAgICAgICBpZiAoIHBlcnBTZWcxID09PSAwIClcdFx0cmV0dXJuIFsgaW5TZWcyUHQxIF07XHJcbiAgICAgICAgICAgICAgICBpZiAoIHBlcnBTZWcxID09PSBsaW1pdCApXHRyZXR1cm4gWyBpblNlZzJQdDIgXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gcmVhbCBpbnRlcnNlY3Rpb24gcG9pbnRcclxuICAgICAgICAgICAgICAgIHZhciBmYWN0b3JTZWcxID0gcGVycFNlZzIgLyBsaW1pdDtcclxuICAgICAgICAgICAgICAgIHJldHVyblx0WyB7IHg6IGluU2VnMVB0MS54ICsgZmFjdG9yU2VnMSAqIHNlZzFkeCxcclxuICAgICAgICAgICAgICAgICAgICB5OiBpblNlZzFQdDEueSArIGZhY3RvclNlZzEgKiBzZWcxZHkgfSBdO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBwYXJhbGxlbCBvciBjb2xsaW5lYXJcclxuICAgICAgICAgICAgICAgIGlmICggKCBwZXJwU2VnMSAhPT0gMCApIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKCBzZWcyZHkgKiBzZWcxc2VnMmR4ICE9PSBzZWcyZHggKiBzZWcxc2VnMmR5ICkgKSBcdFx0XHRyZXR1cm4gW107XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gdGhleSBhcmUgY29sbGluZWFyIG9yIGRlZ2VuZXJhdGVcclxuICAgICAgICAgICAgICAgIHZhciBzZWcxUHQgPSAoICggc2VnMWR4ID09PSAwICkgJiYgKCBzZWcxZHkgPT09IDAgKSApO1x0Ly8gc2VnbWVudDEgaXMganVzdCBhIHBvaW50P1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlZzJQdCA9ICggKCBzZWcyZHggPT09IDAgKSAmJiAoIHNlZzJkeSA9PT0gMCApICk7XHQvLyBzZWdtZW50MiBpcyBqdXN0IGEgcG9pbnQ/XHJcbiAgICAgICAgICAgICAgICAvLyBib3RoIHNlZ21lbnRzIGFyZSBwb2ludHNcclxuICAgICAgICAgICAgICAgIGlmICggc2VnMVB0ICYmIHNlZzJQdCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAoIGluU2VnMVB0MS54ICE9PSBpblNlZzJQdDEueCApIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICggaW5TZWcxUHQxLnkgIT09IGluU2VnMlB0MS55ICkgKVx0XHRyZXR1cm4gW107XHQvLyB0aGV5IGFyZSBkaXN0aW5jdCAgcG9pbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgaW5TZWcxUHQxIF07ICAgICAgICAgICAgICAgICBcdFx0XHRcdFx0XHQvLyB0aGV5IGFyZSB0aGUgc2FtZSBwb2ludFxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHNlZ21lbnQjMSAgaXMgYSBzaW5nbGUgcG9pbnRcclxuICAgICAgICAgICAgICAgIGlmICggc2VnMVB0ICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoICEgcG9pbnRfaW5fc2VnbWVudF8yRF9jb2xpbiggaW5TZWcyUHQxLCBpblNlZzJQdDIsIGluU2VnMVB0MSApIClcdFx0cmV0dXJuIFtdO1x0XHQvLyBidXQgbm90IGluIHNlZ21lbnQjMlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbIGluU2VnMVB0MSBdO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHNlZ21lbnQjMiAgaXMgYSBzaW5nbGUgcG9pbnRcclxuICAgICAgICAgICAgICAgIGlmICggc2VnMlB0ICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoICEgcG9pbnRfaW5fc2VnbWVudF8yRF9jb2xpbiggaW5TZWcxUHQxLCBpblNlZzFQdDIsIGluU2VnMlB0MSApIClcdFx0cmV0dXJuIFtdO1x0XHQvLyBidXQgbm90IGluIHNlZ21lbnQjMVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbIGluU2VnMlB0MSBdO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyB0aGV5IGFyZSBjb2xsaW5lYXIgc2VnbWVudHMsIHdoaWNoIG1pZ2h0IG92ZXJsYXBcclxuICAgICAgICAgICAgICAgIHZhciBzZWcxbWluLCBzZWcxbWF4LCBzZWcxbWluVmFsLCBzZWcxbWF4VmFsO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlZzJtaW4sIHNlZzJtYXgsIHNlZzJtaW5WYWwsIHNlZzJtYXhWYWw7XHJcbiAgICAgICAgICAgICAgICBpZiAoIHNlZzFkeCAhPT0gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHNlZ21lbnRzIGFyZSBOT1Qgb24gYSB2ZXJ0aWNhbCBsaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpblNlZzFQdDEueCA8IGluU2VnMVB0Mi54ICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMW1pbiA9IGluU2VnMVB0MTsgc2VnMW1pblZhbCA9IGluU2VnMVB0MS54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcxbWF4ID0gaW5TZWcxUHQyOyBzZWcxbWF4VmFsID0gaW5TZWcxUHQyLng7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcxbWluID0gaW5TZWcxUHQyOyBzZWcxbWluVmFsID0gaW5TZWcxUHQyLng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzFtYXggPSBpblNlZzFQdDE7IHNlZzFtYXhWYWwgPSBpblNlZzFQdDEueDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggaW5TZWcyUHQxLnggPCBpblNlZzJQdDIueCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzJtaW4gPSBpblNlZzJQdDE7IHNlZzJtaW5WYWwgPSBpblNlZzJQdDEueDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMm1heCA9IGluU2VnMlB0Mjsgc2VnMm1heFZhbCA9IGluU2VnMlB0Mi54O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMm1pbiA9IGluU2VnMlB0Mjsgc2VnMm1pblZhbCA9IGluU2VnMlB0Mi54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcybWF4ID0gaW5TZWcyUHQxOyBzZWcybWF4VmFsID0gaW5TZWcyUHQxLng7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgc2VnbWVudHMgYXJlIG9uIGEgdmVydGljYWwgbGluZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggaW5TZWcxUHQxLnkgPCBpblNlZzFQdDIueSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzFtaW4gPSBpblNlZzFQdDE7IHNlZzFtaW5WYWwgPSBpblNlZzFQdDEueTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMW1heCA9IGluU2VnMVB0Mjsgc2VnMW1heFZhbCA9IGluU2VnMVB0Mi55O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMW1pbiA9IGluU2VnMVB0Mjsgc2VnMW1pblZhbCA9IGluU2VnMVB0Mi55O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcxbWF4ID0gaW5TZWcxUHQxOyBzZWcxbWF4VmFsID0gaW5TZWcxUHQxLnk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGluU2VnMlB0MS55IDwgaW5TZWcyUHQyLnkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcybWluID0gaW5TZWcyUHQxOyBzZWcybWluVmFsID0gaW5TZWcyUHQxLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzJtYXggPSBpblNlZzJQdDI7IHNlZzJtYXhWYWwgPSBpblNlZzJQdDIueTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzJtaW4gPSBpblNlZzJQdDI7IHNlZzJtaW5WYWwgPSBpblNlZzJQdDIueTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMm1heCA9IGluU2VnMlB0MTsgc2VnMm1heFZhbCA9IGluU2VnMlB0MS55O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCBzZWcxbWluVmFsIDw9IHNlZzJtaW5WYWwgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggc2VnMW1heFZhbCA8ICBzZWcybWluVmFsIClcdHJldHVybiBbXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHNlZzFtYXhWYWwgPT09IHNlZzJtaW5WYWwgKVx0e1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpbkV4Y2x1ZGVBZGphY2VudFNlZ3MgKVx0XHRyZXR1cm4gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHNlZzJtaW4gXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggc2VnMW1heFZhbCA8PSBzZWcybWF4VmFsIClcdHJldHVybiBbIHNlZzJtaW4sIHNlZzFtYXggXTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cdFsgc2VnMm1pbiwgc2VnMm1heCBdO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggc2VnMW1pblZhbCA+ICBzZWcybWF4VmFsIClcdHJldHVybiBbXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHNlZzFtaW5WYWwgPT09IHNlZzJtYXhWYWwgKVx0e1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpbkV4Y2x1ZGVBZGphY2VudFNlZ3MgKVx0XHRyZXR1cm4gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIHNlZzFtaW4gXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggc2VnMW1heFZhbCA8PSBzZWcybWF4VmFsIClcdHJldHVybiBbIHNlZzFtaW4sIHNlZzFtYXggXTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cdFsgc2VnMW1pbiwgc2VnMm1heCBdO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBpc1BvaW50SW5zaWRlQW5nbGUoIGluVmVydGV4LCBpbkxlZ0Zyb21QdCwgaW5MZWdUb1B0LCBpbk90aGVyUHQgKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgb3JkZXIgb2YgbGVncyBpcyBpbXBvcnRhbnRcclxuXHJcbiAgICAgICAgICAgIC8vIHRyYW5zbGF0aW9uIG9mIGFsbCBwb2ludHMsIHNvIHRoYXQgVmVydGV4IGlzIGF0ICgwLDApXHJcbiAgICAgICAgICAgIHZhciBsZWdGcm9tUHRYXHQ9IGluTGVnRnJvbVB0LnggLSBpblZlcnRleC54LCAgbGVnRnJvbVB0WVx0PSBpbkxlZ0Zyb21QdC55IC0gaW5WZXJ0ZXgueTtcclxuICAgICAgICAgICAgdmFyIGxlZ1RvUHRYXHQ9IGluTGVnVG9QdC54XHQtIGluVmVydGV4LngsICBsZWdUb1B0WVx0XHQ9IGluTGVnVG9QdC55XHQtIGluVmVydGV4Lnk7XHJcbiAgICAgICAgICAgIHZhciBvdGhlclB0WFx0PSBpbk90aGVyUHQueFx0LSBpblZlcnRleC54LCAgb3RoZXJQdFlcdFx0PSBpbk90aGVyUHQueVx0LSBpblZlcnRleC55O1xyXG5cclxuICAgICAgICAgICAgLy8gbWFpbiBhbmdsZSA+MDogPCAxODAgZGVnLjsgMDogMTgwIGRlZy47IDwwOiA+IDE4MCBkZWcuXHJcbiAgICAgICAgICAgIHZhciBmcm9tMnRvQW5nbGVcdD0gbGVnRnJvbVB0WCAqIGxlZ1RvUHRZIC0gbGVnRnJvbVB0WSAqIGxlZ1RvUHRYO1xyXG4gICAgICAgICAgICB2YXIgZnJvbTJvdGhlckFuZ2xlXHQ9IGxlZ0Zyb21QdFggKiBvdGhlclB0WSAtIGxlZ0Zyb21QdFkgKiBvdGhlclB0WDtcclxuXHJcbiAgICAgICAgICAgIGlmICggTWF0aC5hYnMoIGZyb20ydG9BbmdsZSApID4gTnVtYmVyLkVQU0lMT04gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gYW5nbGUgIT0gMTgwIGRlZy5cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXIydG9BbmdsZVx0XHQ9IG90aGVyUHRYICogbGVnVG9QdFkgLSBvdGhlclB0WSAqIGxlZ1RvUHRYO1xyXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coIFwiZnJvbTJ0bzogXCIgKyBmcm9tMnRvQW5nbGUgKyBcIiwgZnJvbTJvdGhlcjogXCIgKyBmcm9tMm90aGVyQW5nbGUgKyBcIiwgb3RoZXIydG86IFwiICsgb3RoZXIydG9BbmdsZSApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggZnJvbTJ0b0FuZ2xlID4gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFpbiBhbmdsZSA8IDE4MCBkZWcuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXHQoICggZnJvbTJvdGhlckFuZ2xlID49IDAgKSAmJiAoIG90aGVyMnRvQW5nbGUgPj0gMCApICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFpbiBhbmdsZSA+IDE4MCBkZWcuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXHQoICggZnJvbTJvdGhlckFuZ2xlID49IDAgKSB8fCAoIG90aGVyMnRvQW5nbGUgPj0gMCApICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBhbmdsZSA9PSAxODAgZGVnLlxyXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coIFwiZnJvbTJ0bzogMTgwIGRlZy4sIGZyb20yb3RoZXI6IFwiICsgZnJvbTJvdGhlckFuZ2xlICApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuXHQoIGZyb20yb3RoZXJBbmdsZSA+IDAgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlSG9sZXMoIGNvbnRvdXIsIGhvbGVzICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gY29udG91ci5jb25jYXQoKTsgLy8gd29yayBvbiB0aGlzIHNoYXBlXHJcbiAgICAgICAgICAgIHZhciBob2xlO1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gaXNDdXRMaW5lSW5zaWRlQW5nbGVzKCBpblNoYXBlSWR4LCBpbkhvbGVJZHggKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaG9sZSBwb2ludCBsaWVzIHdpdGhpbiBhbmdsZSBhcm91bmQgc2hhcGUgcG9pbnRcclxuICAgICAgICAgICAgICAgIHZhciBsYXN0U2hhcGVJZHggPSBzaGFwZS5sZW5ndGggLSAxO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBwcmV2U2hhcGVJZHggPSBpblNoYXBlSWR4IC0gMTtcclxuICAgICAgICAgICAgICAgIGlmICggcHJldlNoYXBlSWR4IDwgMCApXHRcdFx0cHJldlNoYXBlSWR4ID0gbGFzdFNoYXBlSWR4O1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBuZXh0U2hhcGVJZHggPSBpblNoYXBlSWR4ICsgMTtcclxuICAgICAgICAgICAgICAgIGlmICggbmV4dFNoYXBlSWR4ID4gbGFzdFNoYXBlSWR4IClcdG5leHRTaGFwZUlkeCA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGluc2lkZUFuZ2xlID0gaXNQb2ludEluc2lkZUFuZ2xlKCBzaGFwZVsgaW5TaGFwZUlkeCBdLCBzaGFwZVsgcHJldlNoYXBlSWR4IF0sIHNoYXBlWyBuZXh0U2hhcGVJZHggXSwgaG9sZVsgaW5Ib2xlSWR4IF0gKTtcclxuICAgICAgICAgICAgICAgIGlmICggISBpbnNpZGVBbmdsZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coIFwiVmVydGV4IChTaGFwZSk6IFwiICsgaW5TaGFwZUlkeCArIFwiLCBQb2ludDogXCIgKyBob2xlW2luSG9sZUlkeF0ueCArIFwiL1wiICsgaG9sZVtpbkhvbGVJZHhdLnkgKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cdGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBzaGFwZSBwb2ludCBsaWVzIHdpdGhpbiBhbmdsZSBhcm91bmQgaG9sZSBwb2ludFxyXG4gICAgICAgICAgICAgICAgdmFyIGxhc3RIb2xlSWR4ID0gaG9sZS5sZW5ndGggLSAxO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBwcmV2SG9sZUlkeCA9IGluSG9sZUlkeCAtIDE7XHJcbiAgICAgICAgICAgICAgICBpZiAoIHByZXZIb2xlSWR4IDwgMCApXHRcdFx0cHJldkhvbGVJZHggPSBsYXN0SG9sZUlkeDtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dEhvbGVJZHggPSBpbkhvbGVJZHggKyAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBuZXh0SG9sZUlkeCA+IGxhc3RIb2xlSWR4IClcdG5leHRIb2xlSWR4ID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICBpbnNpZGVBbmdsZSA9IGlzUG9pbnRJbnNpZGVBbmdsZSggaG9sZVsgaW5Ib2xlSWR4IF0sIGhvbGVbIHByZXZIb2xlSWR4IF0sIGhvbGVbIG5leHRIb2xlSWR4IF0sIHNoYXBlWyBpblNoYXBlSWR4IF0gKTtcclxuICAgICAgICAgICAgICAgIGlmICggISBpbnNpZGVBbmdsZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coIFwiVmVydGV4IChIb2xlKTogXCIgKyBpbkhvbGVJZHggKyBcIiwgUG9pbnQ6IFwiICsgc2hhcGVbaW5TaGFwZUlkeF0ueCArIFwiL1wiICsgc2hhcGVbaW5TaGFwZUlkeF0ueSApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblx0ZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVyblx0dHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGludGVyc2VjdHNTaGFwZUVkZ2UoIGluU2hhcGVQdCwgaW5Ib2xlUHQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2tzIGZvciBpbnRlcnNlY3Rpb25zIHdpdGggc2hhcGUgZWRnZXNcclxuICAgICAgICAgICAgICAgIHZhciBzSWR4LCBuZXh0SWR4LCBpbnRlcnNlY3Rpb247XHJcbiAgICAgICAgICAgICAgICBmb3IgKCBzSWR4ID0gMDsgc0lkeCA8IHNoYXBlLmxlbmd0aDsgc0lkeCArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dElkeCA9IHNJZHggKyAxOyBuZXh0SWR4ICU9IHNoYXBlLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rfc2VnbWVudHNfMkQoIGluU2hhcGVQdCwgaW5Ib2xlUHQsIHNoYXBlWyBzSWR4IF0sIHNoYXBlWyBuZXh0SWR4IF0sIHRydWUgKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGludGVyc2VjdGlvbi5sZW5ndGggPiAwIClcdFx0cmV0dXJuXHR0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm5cdGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGluZGVwSG9sZXMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGludGVyc2VjdHNIb2xlRWRnZSggaW5TaGFwZVB0LCBpbkhvbGVQdCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjaGVja3MgZm9yIGludGVyc2VjdGlvbnMgd2l0aCBob2xlIGVkZ2VzXHJcbiAgICAgICAgICAgICAgICB2YXIgaWhJZHgsIGNoa0hvbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgaElkeCwgbmV4dElkeCwgaW50ZXJzZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgZm9yICggaWhJZHggPSAwOyBpaElkeCA8IGluZGVwSG9sZXMubGVuZ3RoOyBpaElkeCArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2hrSG9sZSA9IGhvbGVzWyBpbmRlcEhvbGVzWyBpaElkeCBdXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBoSWR4ID0gMDsgaElkeCA8IGNoa0hvbGUubGVuZ3RoOyBoSWR4ICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dElkeCA9IGhJZHggKyAxOyBuZXh0SWR4ICU9IGNoa0hvbGUubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rfc2VnbWVudHNfMkQoIGluU2hhcGVQdCwgaW5Ib2xlUHQsIGNoa0hvbGVbIGhJZHggXSwgY2hrSG9sZVsgbmV4dElkeCBdLCB0cnVlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaW50ZXJzZWN0aW9uLmxlbmd0aCA+IDAgKVx0XHRyZXR1cm5cdHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm5cdGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGhvbGVJbmRleCwgc2hhcGVJbmRleCxcclxuICAgICAgICAgICAgICAgIHNoYXBlUHQsIGhvbGVQdCxcclxuICAgICAgICAgICAgICAgIGhvbGVJZHgsIGN1dEtleSwgZmFpbGVkQ3V0cyA9IFtdLFxyXG4gICAgICAgICAgICAgICAgdG1wU2hhcGUxLCB0bXBTaGFwZTIsXHJcbiAgICAgICAgICAgICAgICB0bXBIb2xlMSwgdG1wSG9sZTI7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaW5kZXBIb2xlcy5wdXNoKCBoICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgbWluU2hhcGVJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBjb3VudGVyID0gaW5kZXBIb2xlcy5sZW5ndGggKiAyO1xyXG4gICAgICAgICAgICB3aGlsZSAoIGluZGVwSG9sZXMubGVuZ3RoID4gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb3VudGVyIC0tO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBjb3VudGVyIDwgMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coIFwiSW5maW5pdGUgTG9vcCEgSG9sZXMgbGVmdDpcIiArIGluZGVwSG9sZXMubGVuZ3RoICsgXCIsIFByb2JhYmx5IEhvbGUgb3V0c2lkZSBTaGFwZSFcIiApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBzZWFyY2ggZm9yIHNoYXBlLXZlcnRleCBhbmQgaG9sZS12ZXJ0ZXgsXHJcbiAgICAgICAgICAgICAgICAvLyB3aGljaCBjYW4gYmUgY29ubmVjdGVkIHdpdGhvdXQgaW50ZXJzZWN0aW9uc1xyXG4gICAgICAgICAgICAgICAgZm9yICggc2hhcGVJbmRleCA9IG1pblNoYXBlSW5kZXg7IHNoYXBlSW5kZXggPCBzaGFwZS5sZW5ndGg7IHNoYXBlSW5kZXggKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlUHQgPSBzaGFwZVsgc2hhcGVJbmRleCBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGhvbGVJbmRleFx0PSAtIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNlYXJjaCBmb3IgaG9sZSB3aGljaCBjYW4gYmUgcmVhY2hlZCB3aXRob3V0IGludGVyc2VjdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaCA9IDA7IGggPCBpbmRlcEhvbGVzLmxlbmd0aDsgaCArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGVJZHggPSBpbmRlcEhvbGVzWyBoIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IG11bHRpcGxlIGNoZWNrc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXRLZXkgPSBzaGFwZVB0LnggKyBcIjpcIiArIHNoYXBlUHQueSArIFwiOlwiICsgaG9sZUlkeDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBmYWlsZWRDdXRzWyBjdXRLZXkgXSAhPT0gdW5kZWZpbmVkIClcdFx0XHRjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGUgPSBob2xlc1sgaG9sZUlkeCBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaDIgPSAwOyBoMiA8IGhvbGUubGVuZ3RoOyBoMiArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xlUHQgPSBob2xlWyBoMiBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhIGlzQ3V0TGluZUluc2lkZUFuZ2xlcyggc2hhcGVJbmRleCwgaDIgKSApXHRcdGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpbnRlcnNlY3RzU2hhcGVFZGdlKCBzaGFwZVB0LCBob2xlUHQgKSApXHRcdGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpbnRlcnNlY3RzSG9sZUVkZ2UoIHNoYXBlUHQsIGhvbGVQdCApIClcdFx0Y29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZUluZGV4ID0gaDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRlcEhvbGVzLnNwbGljZSggaCwgMSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcFNoYXBlMSA9IHNoYXBlLnNsaWNlKCAwLCBzaGFwZUluZGV4ICsgMSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wU2hhcGUyID0gc2hhcGUuc2xpY2UoIHNoYXBlSW5kZXggKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcEhvbGUxID0gaG9sZS5zbGljZSggaG9sZUluZGV4ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBIb2xlMiA9IGhvbGUuc2xpY2UoIDAsIGhvbGVJbmRleCArIDEgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZSA9IHRtcFNoYXBlMS5jb25jYXQoIHRtcEhvbGUxICkuY29uY2F0KCB0bXBIb2xlMiApLmNvbmNhdCggdG1wU2hhcGUyICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluU2hhcGVJbmRleCA9IHNoYXBlSW5kZXg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVidWcgb25seSwgdG8gc2hvdyB0aGUgc2VsZWN0ZWQgY3V0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2xvYl9DdXRMaW5lcy5wdXNoKCBbIHNoYXBlUHQsIGhvbGVQdCBdICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaG9sZUluZGV4ID49IDAgKVx0YnJlYWs7XHRcdC8vIGhvbGUtdmVydGV4IGZvdW5kXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsZWRDdXRzWyBjdXRLZXkgXSA9IHRydWU7XHRcdFx0Ly8gcmVtZW1iZXIgZmFpbHVyZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBob2xlSW5kZXggPj0gMCApXHRicmVhaztcdFx0Ly8gaG9sZS12ZXJ0ZXggZm91bmRcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc2hhcGU7IFx0XHRcdC8qIHNoYXBlIHdpdGggbm8gaG9sZXMgKi9cclxuXHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgdmFyIGksIGlsLCBmLCBmYWNlLFxyXG4gICAgICAgICAgICBrZXksIGluZGV4LFxyXG4gICAgICAgICAgICBhbGxQb2ludHNNYXAgPSB7fTtcclxuXHJcbiAgICAgICAgLy8gVG8gbWFpbnRhaW4gcmVmZXJlbmNlIHRvIG9sZCBzaGFwZSwgb25lIG11c3QgbWF0Y2ggY29vcmRpbmF0ZXMsIG9yIG9mZnNldCB0aGUgaW5kaWNlcyBmcm9tIG9yaWdpbmFsIGFycmF5cy4gSXQncyBwcm9iYWJseSBlYXNpZXIgdG8gZG8gdGhlIGZpcnN0LlxyXG5cclxuICAgICAgICB2YXIgYWxscG9pbnRzID0gY29udG91ci5jb25jYXQoKTtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xyXG5cclxuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoIGFsbHBvaW50cywgaG9sZXNbIGggXSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2coIFwiYWxscG9pbnRzXCIsYWxscG9pbnRzLCBhbGxwb2ludHMubGVuZ3RoICk7XHJcblxyXG4gICAgICAgIC8vIHByZXBhcmUgYWxsIHBvaW50cyBtYXBcclxuXHJcbiAgICAgICAgZm9yICggaSA9IDAsIGlsID0gYWxscG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAga2V5ID0gYWxscG9pbnRzWyBpIF0ueCArIFwiOlwiICsgYWxscG9pbnRzWyBpIF0ueTtcclxuXHJcbiAgICAgICAgICAgIGlmICggYWxsUG9pbnRzTWFwWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggXCJUSFJFRS5TaGFwZTogRHVwbGljYXRlIHBvaW50XCIsIGtleSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYWxsUG9pbnRzTWFwWyBrZXkgXSA9IGk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcmVtb3ZlIGhvbGVzIGJ5IGN1dHRpbmcgcGF0aHMgdG8gaG9sZXMgYW5kIGFkZGluZyB0aGVtIHRvIHRoZSBzaGFwZVxyXG4gICAgICAgIHZhciBzaGFwZVdpdGhvdXRIb2xlcyA9IHJlbW92ZUhvbGVzKCBjb250b3VyLCBob2xlcyApO1xyXG5cclxuICAgICAgICB2YXIgdHJpYW5nbGVzID0gVEhSRUUuU2hhcGVVdGlscy50cmlhbmd1bGF0ZSggc2hhcGVXaXRob3V0SG9sZXMsIGZhbHNlICk7IC8vIFRydWUgcmV0dXJucyBpbmRpY2VzIGZvciBwb2ludHMgb2Ygc3Bvb2xlZCBzaGFwZVxyXG4gICAgICAgIC8vY29uc29sZS5sb2coIFwidHJpYW5nbGVzXCIsdHJpYW5nbGVzLCB0cmlhbmdsZXMubGVuZ3RoICk7XHJcblxyXG4gICAgICAgIC8vIGNoZWNrIGFsbCBmYWNlIHZlcnRpY2VzIGFnYWluc3QgYWxsIHBvaW50cyBtYXBcclxuXHJcbiAgICAgICAgZm9yICggaSA9IDAsIGlsID0gdHJpYW5nbGVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgZmFjZSA9IHRyaWFuZ2xlc1sgaSBdO1xyXG5cclxuICAgICAgICAgICAgZm9yICggZiA9IDA7IGYgPCAzOyBmICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGtleSA9IGZhY2VbIGYgXS54ICsgXCI6XCIgKyBmYWNlWyBmIF0ueTtcclxuXHJcbiAgICAgICAgICAgICAgICBpbmRleCA9IGFsbFBvaW50c01hcFsga2V5IF07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmYWNlWyBmIF0gPSBpbmRleDtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRyaWFuZ2xlcy5jb25jYXQoKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGlzQ2xvY2tXaXNlOiBmdW5jdGlvbiAoIHB0cyApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIFRIUkVFLlNoYXBlVXRpbHMuYXJlYSggcHRzICkgPCAwO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLy8gQmV6aWVyIEN1cnZlcyBmb3JtdWxhcyBvYnRhaW5lZCBmcm9tXHJcbiAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0IlQzMlQTl6aWVyX2N1cnZlXHJcblxyXG4gICAgLy8gUXVhZCBCZXppZXIgRnVuY3Rpb25zXHJcblxyXG4gICAgYjI6ICggZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBiMnAwKCB0LCBwICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGsgPSAxIC0gdDtcclxuICAgICAgICAgICAgcmV0dXJuIGsgKiBrICogcDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBiMnAxKCB0LCBwICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIDIgKiAoIDEgLSB0ICkgKiB0ICogcDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBiMnAyKCB0LCBwICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHQgKiB0ICogcDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCB0LCBwMCwgcDEsIHAyICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGIycDAoIHQsIHAwICkgKyBiMnAxKCB0LCBwMSApICsgYjJwMiggdCwgcDIgKTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9ICkoKSxcclxuXHJcbiAgICAvLyBDdWJpYyBCZXppZXIgRnVuY3Rpb25zXHJcblxyXG4gICAgYjM6ICggZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBiM3AwKCB0LCBwICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGsgPSAxIC0gdDtcclxuICAgICAgICAgICAgcmV0dXJuIGsgKiBrICogayAqIHA7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gYjNwMSggdCwgcCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBrID0gMSAtIHQ7XHJcbiAgICAgICAgICAgIHJldHVybiAzICogayAqIGsgKiB0ICogcDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBiM3AyKCB0LCBwICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGsgPSAxIC0gdDtcclxuICAgICAgICAgICAgcmV0dXJuIDMgKiBrICogdCAqIHQgKiBwO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGIzcDMoIHQsIHAgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdCAqIHQgKiB0ICogcDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCB0LCBwMCwgcDEsIHAyLCBwMyApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBiM3AwKCB0LCBwMCApICsgYjNwMSggdCwgcDEgKSArIGIzcDIoIHQsIHAyICkgKyBiM3AzKCB0LCBwMyApO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0gKSgpXHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2F1ZGlvL0F1ZGlvLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5BdWRpbyA9IGZ1bmN0aW9uICggbGlzdGVuZXIgKSB7XHJcblxyXG4gICAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdBdWRpbyc7XHJcblxyXG4gICAgdGhpcy5jb250ZXh0ID0gbGlzdGVuZXIuY29udGV4dDtcclxuICAgIHRoaXMuc291cmNlID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xyXG4gICAgdGhpcy5zb3VyY2Uub25lbmRlZCA9IHRoaXMub25FbmRlZC5iaW5kKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy5nYWluID0gdGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcclxuICAgIHRoaXMuZ2Fpbi5jb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcclxuXHJcbiAgICB0aGlzLnBhbm5lciA9IHRoaXMuY29udGV4dC5jcmVhdGVQYW5uZXIoKTtcclxuICAgIHRoaXMucGFubmVyLmNvbm5lY3QoIHRoaXMuZ2FpbiApO1xyXG5cclxuICAgIHRoaXMuYXV0b3BsYXkgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLnN0YXJ0VGltZSA9IDA7XHJcbiAgICB0aGlzLnBsYXliYWNrUmF0ZSA9IDE7XHJcbiAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5USFJFRS5BdWRpby5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5BdWRpbztcclxuXHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCBmaWxlICkge1xyXG5cclxuICAgIHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgIHJlcXVlc3Qub3BlbiggJ0dFVCcsIGZpbGUsIHRydWUgKTtcclxuICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcclxuICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24gKCBlICkge1xyXG5cclxuICAgICAgICBzY29wZS5jb250ZXh0LmRlY29kZUF1ZGlvRGF0YSggdGhpcy5yZXNwb25zZSwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XHJcblxyXG4gICAgICAgICAgICBzY29wZS5zb3VyY2UuYnVmZmVyID0gYnVmZmVyO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBzY29wZS5hdXRvcGxheSApIHNjb3BlLnBsYXkoKTtcclxuXHJcbiAgICAgICAgfSApO1xyXG5cclxuICAgIH07XHJcbiAgICByZXF1ZXN0LnNlbmQoKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpby5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICBpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogQXVkaW8gaXMgYWxyZWFkeSBwbGF5aW5nLicgKTtcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHZhciBzb3VyY2UgPSB0aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XHJcblxyXG4gICAgc291cmNlLmJ1ZmZlciA9IHRoaXMuc291cmNlLmJ1ZmZlcjtcclxuICAgIHNvdXJjZS5sb29wID0gdGhpcy5zb3VyY2UubG9vcDtcclxuICAgIHNvdXJjZS5vbmVuZGVkID0gdGhpcy5zb3VyY2Uub25lbmRlZDtcclxuICAgIHNvdXJjZS5zdGFydCggMCwgdGhpcy5zdGFydFRpbWUgKTtcclxuICAgIHNvdXJjZS5wbGF5YmFja1JhdGUudmFsdWUgPSB0aGlzLnBsYXliYWNrUmF0ZTtcclxuXHJcbiAgICB0aGlzLmlzUGxheWluZyA9IHRydWU7XHJcblxyXG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcblxyXG4gICAgdGhpcy5jb25uZWN0KCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHRoaXMuc291cmNlLnN0b3AoKTtcclxuICAgIHRoaXMuc3RhcnRUaW1lID0gdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHRoaXMuc291cmNlLnN0b3AoKTtcclxuICAgIHRoaXMuc3RhcnRUaW1lID0gMDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpby5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICBpZiAoIHRoaXMuZmlsdGVyICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuc291cmNlLmNvbm5lY3QoIHRoaXMuZmlsdGVyICk7XHJcbiAgICAgICAgdGhpcy5maWx0ZXIuY29ubmVjdCggdGhpcy5wYW5uZXIgKTtcclxuXHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICB0aGlzLnNvdXJjZS5jb25uZWN0KCB0aGlzLnBhbm5lciApO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpby5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICBpZiAoIHRoaXMuZmlsdGVyICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuc291cmNlLmRpc2Nvbm5lY3QoIHRoaXMuZmlsdGVyICk7XHJcbiAgICAgICAgdGhpcy5maWx0ZXIuZGlzY29ubmVjdCggdGhpcy5wYW5uZXIgKTtcclxuXHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICB0aGlzLnNvdXJjZS5kaXNjb25uZWN0KCB0aGlzLnBhbm5lciApO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpby5wcm90b3R5cGUuc2V0RmlsdGVyID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcbiAgICBpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xyXG5cclxuICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICB0aGlzLmZpbHRlciA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdCgpO1xyXG5cclxuICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIHRoaXMuZmlsdGVyID0gdmFsdWU7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5nZXRGaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zZXRQbGF5YmFja1JhdGUgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuICAgIHRoaXMucGxheWJhY2tSYXRlID0gdmFsdWU7XHJcblxyXG4gICAgaWYgKCB0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5zb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlID0gdGhpcy5wbGF5YmFja1JhdGU7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5nZXRQbGF5YmFja1JhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMucGxheWJhY2tSYXRlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5vbkVuZGVkID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpby5wcm90b3R5cGUuc2V0TG9vcCA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG4gICAgdGhpcy5zb3VyY2UubG9vcCA9IHZhbHVlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5nZXRMb29wID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHJldHVybiB0aGlzLnNvdXJjZS5sb29wO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zZXRSZWZEaXN0YW5jZSA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG4gICAgdGhpcy5wYW5uZXIucmVmRGlzdGFuY2UgPSB2YWx1ZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpby5wcm90b3R5cGUuZ2V0UmVmRGlzdGFuY2UgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMucGFubmVyLnJlZkRpc3RhbmNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zZXRSb2xsb2ZmRmFjdG9yID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcbiAgICB0aGlzLnBhbm5lci5yb2xsb2ZmRmFjdG9yID0gdmFsdWU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLmdldFJvbGxvZmZGYWN0b3IgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMucGFubmVyLnJvbGxvZmZGYWN0b3I7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnNldFZvbHVtZSA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG4gICAgdGhpcy5nYWluLmdhaW4udmFsdWUgPSB2YWx1ZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpby5wcm90b3R5cGUuZ2V0Vm9sdW1lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHJldHVybiB0aGlzLmdhaW4uZ2Fpbi52YWx1ZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpby5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQgPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiB1cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKSB7XHJcblxyXG4gICAgICAgIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZC5jYWxsKCB0aGlzLCBmb3JjZSApO1xyXG5cclxuICAgICAgICBwb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHJcbiAgICAgICAgdGhpcy5wYW5uZXIuc2V0UG9zaXRpb24oIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnogKTtcclxuXHJcbiAgICB9O1xyXG5cclxufSApKCk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvYXVkaW8vQXVkaW9MaXN0ZW5lci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQXVkaW9MaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ0F1ZGlvTGlzdGVuZXInO1xyXG5cclxuICAgIHRoaXMuY29udGV4dCA9IG5ldyAoIHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCApKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW9MaXN0ZW5lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuQXVkaW9MaXN0ZW5lci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5BdWRpb0xpc3RlbmVyO1xyXG5cclxuVEhSRUUuQXVkaW9MaXN0ZW5lci5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQgPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgdmFyIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG4gICAgdmFyIHNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICB2YXIgb3JpZW50YXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiB1cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKSB7XHJcblxyXG4gICAgICAgIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZC5jYWxsKCB0aGlzLCBmb3JjZSApO1xyXG5cclxuICAgICAgICB2YXIgbGlzdGVuZXIgPSB0aGlzLmNvbnRleHQubGlzdGVuZXI7XHJcbiAgICAgICAgdmFyIHVwID0gdGhpcy51cDtcclxuXHJcbiAgICAgICAgdGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSApO1xyXG5cclxuICAgICAgICBvcmllbnRhdGlvbi5zZXQoIDAsIDAsIC0gMSApLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xyXG5cclxuICAgICAgICBsaXN0ZW5lci5zZXRQb3NpdGlvbiggcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ueiApO1xyXG4gICAgICAgIGxpc3RlbmVyLnNldE9yaWVudGF0aW9uKCBvcmllbnRhdGlvbi54LCBvcmllbnRhdGlvbi55LCBvcmllbnRhdGlvbi56LCB1cC54LCB1cC55LCB1cC56ICk7XHJcblxyXG4gICAgfTtcclxuXHJcbn0gKSgpO1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2NvcmUvQ3VydmUuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqIEV4dGVuc2libGUgY3VydmUgb2JqZWN0XHJcbiAqXHJcbiAqIFNvbWUgY29tbW9uIG9mIEN1cnZlIG1ldGhvZHNcclxuICogLmdldFBvaW50KHQpLCBnZXRUYW5nZW50KHQpXHJcbiAqIC5nZXRQb2ludEF0KHUpLCBnZXRUYWdlbnRBdCh1KVxyXG4gKiAuZ2V0UG9pbnRzKCksIC5nZXRTcGFjZWRQb2ludHMoKVxyXG4gKiAuZ2V0TGVuZ3RoKClcclxuICogLnVwZGF0ZUFyY0xlbmd0aHMoKVxyXG4gKlxyXG4gKiBUaGlzIGZvbGxvd2luZyBjbGFzc2VzIHN1YmNsYXNzZXMgVEhSRUUuQ3VydmU6XHJcbiAqXHJcbiAqIC0tIDJkIGNsYXNzZXMgLS1cclxuICogVEhSRUUuTGluZUN1cnZlXHJcbiAqIFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlXHJcbiAqIFRIUkVFLkN1YmljQmV6aWVyQ3VydmVcclxuICogVEhSRUUuU3BsaW5lQ3VydmVcclxuICogVEhSRUUuQXJjQ3VydmVcclxuICogVEhSRUUuRWxsaXBzZUN1cnZlXHJcbiAqXHJcbiAqIC0tIDNkIGNsYXNzZXMgLS1cclxuICogVEhSRUUuTGluZUN1cnZlM1xyXG4gKiBUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZTNcclxuICogVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZTNcclxuICogVEhSRUUuU3BsaW5lQ3VydmUzXHJcbiAqIFRIUkVFLkNsb3NlZFNwbGluZUN1cnZlM1xyXG4gKlxyXG4gKiBBIHNlcmllcyBvZiBjdXJ2ZXMgY2FuIGJlIHJlcHJlc2VudGVkIGFzIGEgVEhSRUUuQ3VydmVQYXRoXHJcbiAqXHJcbiAqKi9cclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0QWJzdHJhY3QgQ3VydmUgYmFzZSBjbGFzc1xyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5USFJFRS5DdXJ2ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkN1cnZlLFxyXG5cclxuICAgIC8vIFZpcnR1YWwgYmFzZSBjbGFzcyBtZXRob2QgdG8gb3ZlcndyaXRlIGFuZCBpbXBsZW1lbnQgaW4gc3ViY2xhc3Nlc1xyXG4gICAgLy9cdC0gdCBbMCAuLiAxXVxyXG5cclxuICAgIGdldFBvaW50OiBmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggXCJUSFJFRS5DdXJ2ZTogV2FybmluZywgZ2V0UG9pbnQoKSBub3QgaW1wbGVtZW50ZWQhXCIgKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEdldCBwb2ludCBhdCByZWxhdGl2ZSBwb3NpdGlvbiBpbiBjdXJ2ZSBhY2NvcmRpbmcgdG8gYXJjIGxlbmd0aFxyXG4gICAgLy8gLSB1IFswIC4uIDFdXHJcblxyXG4gICAgZ2V0UG9pbnRBdDogZnVuY3Rpb24gKCB1ICkge1xyXG5cclxuICAgICAgICB2YXIgdCA9IHRoaXMuZ2V0VXRvVG1hcHBpbmcoIHUgKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRQb2ludCggdCApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLy8gR2V0IHNlcXVlbmNlIG9mIHBvaW50cyB1c2luZyBnZXRQb2ludCggdCApXHJcblxyXG4gICAgZ2V0UG9pbnRzOiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcclxuXHJcbiAgICAgICAgaWYgKCAhIGRpdmlzaW9ucyApIGRpdmlzaW9ucyA9IDU7XHJcblxyXG4gICAgICAgIHZhciBkLCBwdHMgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICggZCA9IDA7IGQgPD0gZGl2aXNpb25zOyBkICsrICkge1xyXG5cclxuICAgICAgICAgICAgcHRzLnB1c2goIHRoaXMuZ2V0UG9pbnQoIGQgLyBkaXZpc2lvbnMgKSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwdHM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBHZXQgc2VxdWVuY2Ugb2YgcG9pbnRzIHVzaW5nIGdldFBvaW50QXQoIHUgKVxyXG5cclxuICAgIGdldFNwYWNlZFBvaW50czogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XHJcblxyXG4gICAgICAgIGlmICggISBkaXZpc2lvbnMgKSBkaXZpc2lvbnMgPSA1O1xyXG5cclxuICAgICAgICB2YXIgZCwgcHRzID0gW107XHJcblxyXG4gICAgICAgIGZvciAoIGQgPSAwOyBkIDw9IGRpdmlzaW9uczsgZCArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCB0aGlzLmdldFBvaW50QXQoIGQgLyBkaXZpc2lvbnMgKSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwdHM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBHZXQgdG90YWwgY3VydmUgYXJjIGxlbmd0aFxyXG5cclxuICAgIGdldExlbmd0aDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgbGVuZ3RocyA9IHRoaXMuZ2V0TGVuZ3RocygpO1xyXG4gICAgICAgIHJldHVybiBsZW5ndGhzWyBsZW5ndGhzLmxlbmd0aCAtIDEgXTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEdldCBsaXN0IG9mIGN1bXVsYXRpdmUgc2VnbWVudCBsZW5ndGhzXHJcblxyXG4gICAgZ2V0TGVuZ3RoczogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XHJcblxyXG4gICAgICAgIGlmICggISBkaXZpc2lvbnMgKSBkaXZpc2lvbnMgPSAoIHRoaXMuX19hcmNMZW5ndGhEaXZpc2lvbnMgKSA/ICggdGhpcy5fX2FyY0xlbmd0aERpdmlzaW9ucyApIDogMjAwO1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMuY2FjaGVBcmNMZW5ndGhzXHJcbiAgICAgICAgICAgICYmICggdGhpcy5jYWNoZUFyY0xlbmd0aHMubGVuZ3RoID09PSBkaXZpc2lvbnMgKyAxIClcclxuICAgICAgICAgICAgJiYgISB0aGlzLm5lZWRzVXBkYXRlICkge1xyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyggXCJjYWNoZWRcIiwgdGhpcy5jYWNoZUFyY0xlbmd0aHMgKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVBcmNMZW5ndGhzO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdmFyIGNhY2hlID0gW107XHJcbiAgICAgICAgdmFyIGN1cnJlbnQsIGxhc3QgPSB0aGlzLmdldFBvaW50KCAwICk7XHJcbiAgICAgICAgdmFyIHAsIHN1bSA9IDA7XHJcblxyXG4gICAgICAgIGNhY2hlLnB1c2goIDAgKTtcclxuXHJcbiAgICAgICAgZm9yICggcCA9IDE7IHAgPD0gZGl2aXNpb25zOyBwICsrICkge1xyXG5cclxuICAgICAgICAgICAgY3VycmVudCA9IHRoaXMuZ2V0UG9pbnQgKCBwIC8gZGl2aXNpb25zICk7XHJcbiAgICAgICAgICAgIHN1bSArPSBjdXJyZW50LmRpc3RhbmNlVG8oIGxhc3QgKTtcclxuICAgICAgICAgICAgY2FjaGUucHVzaCggc3VtICk7XHJcbiAgICAgICAgICAgIGxhc3QgPSBjdXJyZW50O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY2FjaGVBcmNMZW5ndGhzID0gY2FjaGU7XHJcblxyXG4gICAgICAgIHJldHVybiBjYWNoZTsgLy8geyBzdW1zOiBjYWNoZSwgc3VtOnN1bSB9OyBTdW0gaXMgaW4gdGhlIGxhc3QgZWxlbWVudC5cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZUFyY0xlbmd0aHM6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmdldExlbmd0aHMoKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEdpdmVuIHUgKCAwIC4uIDEgKSwgZ2V0IGEgdCB0byBmaW5kIHAuIFRoaXMgZ2l2ZXMgeW91IHBvaW50cyB3aGljaCBhcmUgZXF1aWRpc3RhbnRcclxuXHJcbiAgICBnZXRVdG9UbWFwcGluZzogZnVuY3Rpb24gKCB1LCBkaXN0YW5jZSApIHtcclxuXHJcbiAgICAgICAgdmFyIGFyY0xlbmd0aHMgPSB0aGlzLmdldExlbmd0aHMoKTtcclxuXHJcbiAgICAgICAgdmFyIGkgPSAwLCBpbCA9IGFyY0xlbmd0aHMubGVuZ3RoO1xyXG5cclxuICAgICAgICB2YXIgdGFyZ2V0QXJjTGVuZ3RoOyAvLyBUaGUgdGFyZ2V0ZWQgdSBkaXN0YW5jZSB2YWx1ZSB0byBnZXRcclxuXHJcbiAgICAgICAgaWYgKCBkaXN0YW5jZSApIHtcclxuXHJcbiAgICAgICAgICAgIHRhcmdldEFyY0xlbmd0aCA9IGRpc3RhbmNlO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgdGFyZ2V0QXJjTGVuZ3RoID0gdSAqIGFyY0xlbmd0aHNbIGlsIC0gMSBdO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vdmFyIHRpbWUgPSBEYXRlLm5vdygpO1xyXG5cclxuICAgICAgICAvLyBiaW5hcnkgc2VhcmNoIGZvciB0aGUgaW5kZXggd2l0aCBsYXJnZXN0IHZhbHVlIHNtYWxsZXIgdGhhbiB0YXJnZXQgdSBkaXN0YW5jZVxyXG5cclxuICAgICAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGlsIC0gMSwgY29tcGFyaXNvbjtcclxuXHJcbiAgICAgICAgd2hpbGUgKCBsb3cgPD0gaGlnaCApIHtcclxuXHJcbiAgICAgICAgICAgIGkgPSBNYXRoLmZsb29yKCBsb3cgKyAoIGhpZ2ggLSBsb3cgKSAvIDIgKTsgLy8gbGVzcyBsaWtlbHkgdG8gb3ZlcmZsb3csIHRob3VnaCBwcm9iYWJseSBub3QgaXNzdWUgaGVyZSwgSlMgZG9lc24ndCByZWFsbHkgaGF2ZSBpbnRlZ2VycywgYWxsIG51bWJlcnMgYXJlIGZsb2F0c1xyXG5cclxuICAgICAgICAgICAgY29tcGFyaXNvbiA9IGFyY0xlbmd0aHNbIGkgXSAtIHRhcmdldEFyY0xlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIGlmICggY29tcGFyaXNvbiA8IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgbG93ID0gaSArIDE7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBjb21wYXJpc29uID4gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBoaWdoID0gaSAtIDE7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIGhpZ2ggPSBpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRE9ORVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGkgPSBoaWdoO1xyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdiJyAsIGksIGxvdywgaGlnaCwgRGF0ZS5ub3coKS0gdGltZSk7XHJcblxyXG4gICAgICAgIGlmICggYXJjTGVuZ3Roc1sgaSBdID09PSB0YXJnZXRBcmNMZW5ndGggKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgdCA9IGkgLyAoIGlsIC0gMSApO1xyXG4gICAgICAgICAgICByZXR1cm4gdDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB3ZSBjb3VsZCBnZXQgZmluZXIgZ3JhaW4gYXQgbGVuZ3Rocywgb3IgdXNlIHNpbXBsZSBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHBvaW50c1xyXG5cclxuICAgICAgICB2YXIgbGVuZ3RoQmVmb3JlID0gYXJjTGVuZ3Roc1sgaSBdO1xyXG4gICAgICAgIHZhciBsZW5ndGhBZnRlciA9IGFyY0xlbmd0aHNbIGkgKyAxIF07XHJcblxyXG4gICAgICAgIHZhciBzZWdtZW50TGVuZ3RoID0gbGVuZ3RoQWZ0ZXIgLSBsZW5ndGhCZWZvcmU7XHJcblxyXG4gICAgICAgIC8vIGRldGVybWluZSB3aGVyZSB3ZSBhcmUgYmV0d2VlbiB0aGUgJ2JlZm9yZScgYW5kICdhZnRlcicgcG9pbnRzXHJcblxyXG4gICAgICAgIHZhciBzZWdtZW50RnJhY3Rpb24gPSAoIHRhcmdldEFyY0xlbmd0aCAtIGxlbmd0aEJlZm9yZSApIC8gc2VnbWVudExlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gYWRkIHRoYXQgZnJhY3Rpb25hbCBhbW91bnQgdG8gdFxyXG5cclxuICAgICAgICB2YXIgdCA9ICggaSArIHNlZ21lbnRGcmFjdGlvbiApIC8gKCBpbCAtIDEgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBSZXR1cm5zIGEgdW5pdCB2ZWN0b3IgdGFuZ2VudCBhdCB0XHJcbiAgICAvLyBJbiBjYXNlIGFueSBzdWIgY3VydmUgZG9lcyBub3QgaW1wbGVtZW50IGl0cyB0YW5nZW50IGRlcml2YXRpb24sXHJcbiAgICAvLyAyIHBvaW50cyBhIHNtYWxsIGRlbHRhIGFwYXJ0IHdpbGwgYmUgdXNlZCB0byBmaW5kIGl0cyBncmFkaWVudFxyXG4gICAgLy8gd2hpY2ggc2VlbXMgdG8gZ2l2ZSBhIHJlYXNvbmFibGUgYXBwcm94aW1hdGlvblxyXG5cclxuICAgIGdldFRhbmdlbnQ6IGZ1bmN0aW9uKCB0ICkge1xyXG5cclxuICAgICAgICB2YXIgZGVsdGEgPSAwLjAwMDE7XHJcbiAgICAgICAgdmFyIHQxID0gdCAtIGRlbHRhO1xyXG4gICAgICAgIHZhciB0MiA9IHQgKyBkZWx0YTtcclxuXHJcbiAgICAgICAgLy8gQ2FwcGluZyBpbiBjYXNlIG9mIGRhbmdlclxyXG5cclxuICAgICAgICBpZiAoIHQxIDwgMCApIHQxID0gMDtcclxuICAgICAgICBpZiAoIHQyID4gMSApIHQyID0gMTtcclxuXHJcbiAgICAgICAgdmFyIHB0MSA9IHRoaXMuZ2V0UG9pbnQoIHQxICk7XHJcbiAgICAgICAgdmFyIHB0MiA9IHRoaXMuZ2V0UG9pbnQoIHQyICk7XHJcblxyXG4gICAgICAgIHZhciB2ZWMgPSBwdDIuY2xvbmUoKS5zdWIoIHB0MSApO1xyXG4gICAgICAgIHJldHVybiB2ZWMubm9ybWFsaXplKCk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRUYW5nZW50QXQ6IGZ1bmN0aW9uICggdSApIHtcclxuXHJcbiAgICAgICAgdmFyIHQgPSB0aGlzLmdldFV0b1RtYXBwaW5nKCB1ICk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGFuZ2VudCggdCApO1xyXG5cclxuICAgIH1cclxuXHJcbn1cclxuXHJcblRIUkVFLkN1cnZlLlV0aWxzID0gVEhSRUUuQ3VydmVVdGlsczsgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcclxuXHJcbi8vIFRPRE86IFRyYW5zZm9ybWF0aW9uIGZvciBDdXJ2ZXM/XHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdDNEIEN1cnZlc1xyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG4vLyBBIEZhY3RvcnkgbWV0aG9kIGZvciBjcmVhdGluZyBuZXcgY3VydmUgc3ViY2xhc3Nlc1xyXG5cclxuVEhSRUUuQ3VydmUuY3JlYXRlID0gZnVuY3Rpb24gKCBjb25zdHJ1Y3RvciwgZ2V0UG9pbnRGdW5jICkge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xyXG4gICAgY29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY29uc3RydWN0b3I7XHJcbiAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0UG9pbnQgPSBnZXRQb2ludEZ1bmM7XHJcblxyXG4gICAgcmV0dXJuIGNvbnN0cnVjdG9yO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9jb3JlL0N1cnZlUGF0aC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICpcclxuICoqL1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRDdXJ2ZWQgUGF0aCAtIGEgY3VydmUgcGF0aCBpcyBzaW1wbHkgYSBhcnJheSBvZiBjb25uZWN0ZWRcclxuICogIGN1cnZlcywgYnV0IHJldGFpbnMgdGhlIGFwaSBvZiBhIGN1cnZlXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblRIUkVFLkN1cnZlUGF0aCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB0aGlzLmN1cnZlcyA9IFtdO1xyXG5cclxuICAgIHRoaXMuYXV0b0Nsb3NlID0gZmFsc2U7IC8vIEF1dG9tYXRpY2FsbHkgY2xvc2VzIHRoZSBwYXRoXHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ3VydmVQYXRoO1xyXG5cclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoIGN1cnZlICkge1xyXG5cclxuICAgIHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XHJcblxyXG59O1xyXG5cclxuLypcclxuIFRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY2hlY2tDb25uZWN0aW9uID0gZnVuY3Rpb24oKSB7XHJcbiAvLyBUT0RPXHJcbiAvLyBJZiB0aGUgZW5kaW5nIG9mIGN1cnZlIGlzIG5vdCBjb25uZWN0ZWQgdG8gdGhlIHN0YXJ0aW5nXHJcbiAvLyBvciB0aGUgbmV4dCBjdXJ2ZSwgdGhlbiwgdGhpcyBpcyBub3QgYSByZWFsIHBhdGhcclxuIH07XHJcbiAqL1xyXG5cclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jbG9zZVBhdGggPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAvLyBUT0RPIFRlc3RcclxuICAgIC8vIGFuZCB2ZXJpZnkgZm9yIHZlY3RvcjMgKG5lZWRzIHRvIGltcGxlbWVudCBlcXVhbHMpXHJcbiAgICAvLyBBZGQgYSBsaW5lIGN1cnZlIGlmIHN0YXJ0IGFuZCBlbmQgb2YgbGluZXMgYXJlIG5vdCBjb25uZWN0ZWRcclxuICAgIHZhciBzdGFydFBvaW50ID0gdGhpcy5jdXJ2ZXNbIDAgXS5nZXRQb2ludCggMCApO1xyXG4gICAgdmFyIGVuZFBvaW50ID0gdGhpcy5jdXJ2ZXNbIHRoaXMuY3VydmVzLmxlbmd0aCAtIDEgXS5nZXRQb2ludCggMSApO1xyXG5cclxuICAgIGlmICggISBzdGFydFBvaW50LmVxdWFscyggZW5kUG9pbnQgKSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5jdXJ2ZXMucHVzaCggbmV3IFRIUkVFLkxpbmVDdXJ2ZSggZW5kUG9pbnQsIHN0YXJ0UG9pbnQgKSApO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vLyBUbyBnZXQgYWNjdXJhdGUgcG9pbnQgd2l0aCByZWZlcmVuY2UgdG9cclxuLy8gZW50aXJlIHBhdGggZGlzdGFuY2UgYXQgdGltZSB0LFxyXG4vLyBmb2xsb3dpbmcgaGFzIHRvIGJlIGRvbmU6XHJcblxyXG4vLyAxLiBMZW5ndGggb2YgZWFjaCBzdWIgcGF0aCBoYXZlIHRvIGJlIGtub3duXHJcbi8vIDIuIExvY2F0ZSBhbmQgaWRlbnRpZnkgdHlwZSBvZiBjdXJ2ZVxyXG4vLyAzLiBHZXQgdCBmb3IgdGhlIGN1cnZlXHJcbi8vIDQuIFJldHVybiBjdXJ2ZS5nZXRQb2ludEF0KHQnKVxyXG5cclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uKCB0ICkge1xyXG5cclxuICAgIHZhciBkID0gdCAqIHRoaXMuZ2V0TGVuZ3RoKCk7XHJcbiAgICB2YXIgY3VydmVMZW5ndGhzID0gdGhpcy5nZXRDdXJ2ZUxlbmd0aHMoKTtcclxuICAgIHZhciBpID0gMDtcclxuXHJcbiAgICAvLyBUbyB0aGluayBhYm91dCBib3VuZGFyaWVzIHBvaW50cy5cclxuXHJcbiAgICB3aGlsZSAoIGkgPCBjdXJ2ZUxlbmd0aHMubGVuZ3RoICkge1xyXG5cclxuICAgICAgICBpZiAoIGN1cnZlTGVuZ3Roc1sgaSBdID49IGQgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgZGlmZiA9IGN1cnZlTGVuZ3Roc1sgaSBdIC0gZDtcclxuICAgICAgICAgICAgdmFyIGN1cnZlID0gdGhpcy5jdXJ2ZXNbIGkgXTtcclxuXHJcbiAgICAgICAgICAgIHZhciB1ID0gMSAtIGRpZmYgLyBjdXJ2ZS5nZXRMZW5ndGgoKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBjdXJ2ZS5nZXRQb2ludEF0KCB1ICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaSArKztcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgLy8gbG9vcCB3aGVyZSBzdW0gIT0gMCwgc3VtID4gZCAsIHN1bSsxIDxkXHJcblxyXG59O1xyXG5cclxuLypcclxuIFRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uKCB0ICkge1xyXG4gfTtcclxuICovXHJcblxyXG4vLyBXZSBjYW5ub3QgdXNlIHRoZSBkZWZhdWx0IFRIUkVFLkN1cnZlIGdldFBvaW50KCkgd2l0aCBnZXRMZW5ndGgoKSBiZWNhdXNlIGluXHJcbi8vIFRIUkVFLkN1cnZlLCBnZXRMZW5ndGgoKSBkZXBlbmRzIG9uIGdldFBvaW50KCkgYnV0IGluIFRIUkVFLkN1cnZlUGF0aFxyXG4vLyBnZXRQb2ludCgpIGRlcGVuZHMgb24gZ2V0TGVuZ3RoXHJcblxyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBsZW5zID0gdGhpcy5nZXRDdXJ2ZUxlbmd0aHMoKTtcclxuICAgIHJldHVybiBsZW5zWyBsZW5zLmxlbmd0aCAtIDEgXTtcclxuXHJcbn07XHJcblxyXG4vLyBDb21wdXRlIGxlbmd0aHMgYW5kIGNhY2hlIHRoZW1cclxuLy8gV2UgY2Fubm90IG92ZXJ3cml0ZSBnZXRMZW5ndGhzKCkgYmVjYXVzZSBVdG9UIG1hcHBpbmcgdXNlcyBpdC5cclxuXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0Q3VydmVMZW5ndGhzID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgLy8gV2UgdXNlIGNhY2hlIHZhbHVlcyBpZiBjdXJ2ZXMgYW5kIGNhY2hlIGFycmF5IGFyZSBzYW1lIGxlbmd0aFxyXG5cclxuICAgIGlmICggdGhpcy5jYWNoZUxlbmd0aHMgJiYgdGhpcy5jYWNoZUxlbmd0aHMubGVuZ3RoID09PSB0aGlzLmN1cnZlcy5sZW5ndGggKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlTGVuZ3RocztcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gR2V0IGxlbmd0aCBvZiBzdWItY3VydmVcclxuICAgIC8vIFB1c2ggc3VtcyBpbnRvIGNhY2hlZCBhcnJheVxyXG5cclxuICAgIHZhciBsZW5ndGhzID0gW10sIHN1bXMgPSAwO1xyXG5cclxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIHN1bXMgKz0gdGhpcy5jdXJ2ZXNbIGkgXS5nZXRMZW5ndGgoKTtcclxuICAgICAgICBsZW5ndGhzLnB1c2goIHN1bXMgKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jYWNoZUxlbmd0aHMgPSBsZW5ndGhzO1xyXG5cclxuICAgIHJldHVybiBsZW5ndGhzO1xyXG5cclxufTtcclxuXHJcblxyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRDcmVhdGUgR2VvbWV0cmllcyBIZWxwZXJzXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcbi8vLyBHZW5lcmF0ZSBnZW9tZXRyeSBmcm9tIHBhdGggcG9pbnRzIChmb3IgTGluZSBvciBQb2ludHMgb2JqZWN0cylcclxuXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY3JlYXRlUG9pbnRzR2VvbWV0cnkgPSBmdW5jdGlvbiggZGl2aXNpb25zICkge1xyXG5cclxuICAgIHZhciBwdHMgPSB0aGlzLmdldFBvaW50cyggZGl2aXNpb25zLCB0cnVlICk7XHJcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeSggcHRzICk7XHJcblxyXG59O1xyXG5cclxuLy8gR2VuZXJhdGUgZ2VvbWV0cnkgZnJvbSBlcXVpZGlzdGFudCBzYW1wbGluZyBhbG9uZyB0aGUgcGF0aFxyXG5cclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jcmVhdGVTcGFjZWRQb2ludHNHZW9tZXRyeSA9IGZ1bmN0aW9uKCBkaXZpc2lvbnMgKSB7XHJcblxyXG4gICAgdmFyIHB0cyA9IHRoaXMuZ2V0U3BhY2VkUG9pbnRzKCBkaXZpc2lvbnMsIHRydWUgKTtcclxuICAgIHJldHVybiB0aGlzLmNyZWF0ZUdlb21ldHJ5KCBwdHMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNyZWF0ZUdlb21ldHJ5ID0gZnVuY3Rpb24oIHBvaW50cyApIHtcclxuXHJcbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHJcbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgdmFyIHBvaW50ID0gcG9pbnRzWyBpIF07XHJcbiAgICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIHBvaW50LngsIHBvaW50LnksIHBvaW50LnogfHwgMCApICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBnZW9tZXRyeTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvY29yZS9QYXRoLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKiBDcmVhdGVzIGZyZWUgZm9ybSAyZCBwYXRoIHVzaW5nIHNlcmllcyBvZiBwb2ludHMsIGxpbmVzIG9yIGN1cnZlcy5cclxuICpcclxuICoqL1xyXG5cclxuVEhSRUUuUGF0aCA9IGZ1bmN0aW9uICggcG9pbnRzICkge1xyXG5cclxuICAgIFRIUkVFLkN1cnZlUGF0aC5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy5hY3Rpb25zID0gW107XHJcblxyXG4gICAgaWYgKCBwb2ludHMgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuZnJvbVBvaW50cyggcG9pbnRzICk7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZSApO1xyXG5USFJFRS5QYXRoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBhdGg7XHJcblxyXG4vLyBUT0RPIENsZWFuIHVwIFBBVEggQVBJXHJcblxyXG4vLyBDcmVhdGUgcGF0aCB1c2luZyBzdHJhaWdodCBsaW5lcyB0byBjb25uZWN0IGFsbCBwb2ludHNcclxuLy8gLSB2ZWN0b3JzOiBhcnJheSBvZiBWZWN0b3IyXHJcblxyXG5USFJFRS5QYXRoLnByb3RvdHlwZS5mcm9tUG9pbnRzID0gZnVuY3Rpb24gKCB2ZWN0b3JzICkge1xyXG5cclxuICAgIHRoaXMubW92ZVRvKCB2ZWN0b3JzWyAwIF0ueCwgdmVjdG9yc1sgMCBdLnkgKTtcclxuXHJcbiAgICBmb3IgKCB2YXIgaSA9IDEsIGwgPSB2ZWN0b3JzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIHRoaXMubGluZVRvKCB2ZWN0b3JzWyBpIF0ueCwgdmVjdG9yc1sgaSBdLnkgKTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gc3RhcnRQYXRoKCkgZW5kUGF0aCgpP1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24gKCB4LCB5ICkge1xyXG5cclxuICAgIHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogJ21vdmVUbycsIGFyZ3M6IFsgeCwgeSBdIH0gKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5QYXRoLnByb3RvdHlwZS5saW5lVG8gPSBmdW5jdGlvbiAoIHgsIHkgKSB7XHJcblxyXG4gICAgdmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMSBdLmFyZ3M7XHJcblxyXG4gICAgdmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcclxuICAgIHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XHJcblxyXG4gICAgdmFyIGN1cnZlID0gbmV3IFRIUkVFLkxpbmVDdXJ2ZSggbmV3IFRIUkVFLlZlY3RvcjIoIHgwLCB5MCApLCBuZXcgVEhSRUUuVmVjdG9yMiggeCwgeSApICk7XHJcbiAgICB0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xyXG5cclxuICAgIHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogJ2xpbmVUbycsIGFyZ3M6IFsgeCwgeSBdIH0gKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5QYXRoLnByb3RvdHlwZS5xdWFkcmF0aWNDdXJ2ZVRvID0gZnVuY3Rpb24oIGFDUHgsIGFDUHksIGFYLCBhWSApIHtcclxuXHJcbiAgICB2YXIgbGFzdGFyZ3MgPSB0aGlzLmFjdGlvbnNbIHRoaXMuYWN0aW9ucy5sZW5ndGggLSAxIF0uYXJncztcclxuXHJcbiAgICB2YXIgeDAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMiBdO1xyXG4gICAgdmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcclxuXHJcbiAgICB2YXIgY3VydmUgPSBuZXcgVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUoXHJcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIHgwLCB5MCApLFxyXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBhQ1B4LCBhQ1B5ICksXHJcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGFYLCBhWSApXHJcbiAgICApO1xyXG5cclxuICAgIHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XHJcblxyXG4gICAgdGhpcy5hY3Rpb25zLnB1c2goIHsgYWN0aW9uOiAncXVhZHJhdGljQ3VydmVUbycsIGFyZ3M6IFsgYUNQeCwgYUNQeSwgYVgsIGFZIF0gfSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLmJlemllckN1cnZlVG8gPSBmdW5jdGlvbiggYUNQMXgsIGFDUDF5LCBhQ1AyeCwgYUNQMnksIGFYLCBhWSApIHtcclxuXHJcbiAgICB2YXIgbGFzdGFyZ3MgPSB0aGlzLmFjdGlvbnNbIHRoaXMuYWN0aW9ucy5sZW5ndGggLSAxIF0uYXJncztcclxuXHJcbiAgICB2YXIgeDAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMiBdO1xyXG4gICAgdmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcclxuXHJcbiAgICB2YXIgY3VydmUgPSBuZXcgVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZShcclxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggeDAsIHkwICksXHJcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGFDUDF4LCBhQ1AxeSApLFxyXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBhQ1AyeCwgYUNQMnkgKSxcclxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYVgsIGFZIClcclxuICAgICk7XHJcblxyXG4gICAgdGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcclxuXHJcbiAgICB0aGlzLmFjdGlvbnMucHVzaCggeyBhY3Rpb246ICdiZXppZXJDdXJ2ZVRvJywgYXJnczogWyBhQ1AxeCwgYUNQMXksIGFDUDJ4LCBhQ1AyeSwgYVgsIGFZIF0gfSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLnNwbGluZVRocnUgPSBmdW5jdGlvbiggcHRzIC8qQXJyYXkgb2YgVmVjdG9yKi8gKSB7XHJcblxyXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XHJcblxyXG4gICAgdmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMSBdLmFyZ3M7XHJcblxyXG4gICAgdmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcclxuICAgIHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XHJcblxyXG4gICAgdmFyIG5wdHMgPSBbIG5ldyBUSFJFRS5WZWN0b3IyKCB4MCwgeTAgKSBdO1xyXG4gICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoIG5wdHMsIHB0cyApO1xyXG5cclxuICAgIHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5TcGxpbmVDdXJ2ZSggbnB0cyApO1xyXG4gICAgdGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcclxuXHJcbiAgICB0aGlzLmFjdGlvbnMucHVzaCggeyBhY3Rpb246ICdzcGxpbmVUaHJ1JywgYXJnczogYXJncyB9ICk7XHJcblxyXG59O1xyXG5cclxuLy8gRlVUVVJFOiBDaGFuZ2UgdGhlIEFQSSBvciBmb2xsb3cgY2FudmFzIEFQST9cclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLmFyYyA9IGZ1bmN0aW9uICggYVgsIGFZLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xyXG5cclxuICAgIHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xyXG4gICAgdmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcclxuICAgIHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XHJcblxyXG4gICAgdGhpcy5hYnNhcmMoIGFYICsgeDAsIGFZICsgeTAsIGFSYWRpdXMsXHJcbiAgICAgICAgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLmFic2FyYyA9IGZ1bmN0aW9uICggYVgsIGFZLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xyXG5cclxuICAgIHRoaXMuYWJzZWxsaXBzZSggYVgsIGFZLCBhUmFkaXVzLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUuZWxsaXBzZSA9IGZ1bmN0aW9uICggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKSB7XHJcblxyXG4gICAgdmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMSBdLmFyZ3M7XHJcbiAgICB2YXIgeDAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMiBdO1xyXG4gICAgdmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcclxuXHJcbiAgICB0aGlzLmFic2VsbGlwc2UoIGFYICsgeDAsIGFZICsgeTAsIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApO1xyXG5cclxufTtcclxuXHJcblxyXG5USFJFRS5QYXRoLnByb3RvdHlwZS5hYnNlbGxpcHNlID0gZnVuY3Rpb24gKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApIHtcclxuXHJcbiAgICB2YXIgYXJncyA9IFtcclxuICAgICAgICBhWCwgYVksXHJcbiAgICAgICAgeFJhZGl1cywgeVJhZGl1cyxcclxuICAgICAgICBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLFxyXG4gICAgICAgIGFDbG9ja3dpc2UsXHJcbiAgICAgICAgYVJvdGF0aW9uIHx8IDAgLy8gYVJvdGF0aW9uIGlzIG9wdGlvbmFsLlxyXG4gICAgXTtcclxuXHJcbiAgICB2YXIgY3VydmUgPSBuZXcgVEhSRUUuRWxsaXBzZUN1cnZlKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApO1xyXG4gICAgdGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcclxuXHJcbiAgICB2YXIgbGFzdFBvaW50ID0gY3VydmUuZ2V0UG9pbnQoIDEgKTtcclxuICAgIGFyZ3MucHVzaCggbGFzdFBvaW50LnggKTtcclxuICAgIGFyZ3MucHVzaCggbGFzdFBvaW50LnkgKTtcclxuXHJcbiAgICB0aGlzLmFjdGlvbnMucHVzaCggeyBhY3Rpb246ICdlbGxpcHNlJywgYXJnczogYXJncyB9ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUuZ2V0U3BhY2VkUG9pbnRzID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMsIGNsb3NlZFBhdGggKSB7XHJcblxyXG4gICAgaWYgKCAhIGRpdmlzaW9ucyApIGRpdmlzaW9ucyA9IDQwO1xyXG5cclxuICAgIHZhciBwb2ludHMgPSBbXTtcclxuXHJcbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBkaXZpc2lvbnM7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIHBvaW50cy5wdXNoKCB0aGlzLmdldFBvaW50KCBpIC8gZGl2aXNpb25zICkgKTtcclxuXHJcbiAgICAgICAgLy9pZiAoICF0aGlzLmdldFBvaW50KCBpIC8gZGl2aXNpb25zICkgKSB0aHJvdyBcIkRJRVwiO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBpZiAoIGNsb3NlZFBhdGggKSB7XHJcbiAgICAvL1xyXG4gICAgLy8gXHRwb2ludHMucHVzaCggcG9pbnRzWyAwIF0gKTtcclxuICAgIC8vXHJcbiAgICAvLyB9XHJcblxyXG4gICAgcmV0dXJuIHBvaW50cztcclxuXHJcbn07XHJcblxyXG4vKiBSZXR1cm4gYW4gYXJyYXkgb2YgdmVjdG9ycyBiYXNlZCBvbiBjb250b3VyIG9mIHRoZSBwYXRoICovXHJcblxyXG5USFJFRS5QYXRoLnByb3RvdHlwZS5nZXRQb2ludHMgPSBmdW5jdGlvbiggZGl2aXNpb25zLCBjbG9zZWRQYXRoICkge1xyXG5cclxuICAgIGRpdmlzaW9ucyA9IGRpdmlzaW9ucyB8fCAxMjtcclxuXHJcbiAgICB2YXIgYjIgPSBUSFJFRS5TaGFwZVV0aWxzLmIyO1xyXG4gICAgdmFyIGIzID0gVEhSRUUuU2hhcGVVdGlscy5iMztcclxuXHJcbiAgICB2YXIgcG9pbnRzID0gW107XHJcblxyXG4gICAgdmFyIGNweCwgY3B5LCBjcHgyLCBjcHkyLCBjcHgxLCBjcHkxLCBjcHgwLCBjcHkwLFxyXG4gICAgICAgIGxhc3RlLCB0eCwgdHk7XHJcblxyXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5hY3Rpb25zLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5hY3Rpb25zWyBpIF07XHJcblxyXG4gICAgICAgIHZhciBhY3Rpb24gPSBpdGVtLmFjdGlvbjtcclxuICAgICAgICB2YXIgYXJncyA9IGl0ZW0uYXJncztcclxuXHJcbiAgICAgICAgc3dpdGNoICggYWN0aW9uICkge1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnbW92ZVRvJzpcclxuXHJcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIGFyZ3NbIDAgXSwgYXJnc1sgMSBdICkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJ2xpbmVUbyc6XHJcblxyXG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCBhcmdzWyAwIF0sIGFyZ3NbIDEgXSApICk7XHJcblxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlICdxdWFkcmF0aWNDdXJ2ZVRvJzpcclxuXHJcbiAgICAgICAgICAgICAgICBjcHggID0gYXJnc1sgMiBdO1xyXG4gICAgICAgICAgICAgICAgY3B5ICA9IGFyZ3NbIDMgXTtcclxuXHJcbiAgICAgICAgICAgICAgICBjcHgxID0gYXJnc1sgMCBdO1xyXG4gICAgICAgICAgICAgICAgY3B5MSA9IGFyZ3NbIDEgXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHBvaW50cy5sZW5ndGggPiAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsYXN0ZSA9IHBvaW50c1sgcG9pbnRzLmxlbmd0aCAtIDEgXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY3B4MCA9IGxhc3RlLng7XHJcbiAgICAgICAgICAgICAgICAgICAgY3B5MCA9IGxhc3RlLnk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdGUgPSB0aGlzLmFjdGlvbnNbIGkgLSAxIF0uYXJncztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY3B4MCA9IGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAyIF07XHJcbiAgICAgICAgICAgICAgICAgICAgY3B5MCA9IGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAxIF07XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBqID0gMTsgaiA8PSBkaXZpc2lvbnM7IGogKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gaiAvIGRpdmlzaW9ucztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdHggPSBiMiggdCwgY3B4MCwgY3B4MSwgY3B4ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHkgPSBiMiggdCwgY3B5MCwgY3B5MSwgY3B5ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlICdiZXppZXJDdXJ2ZVRvJzpcclxuXHJcbiAgICAgICAgICAgICAgICBjcHggID0gYXJnc1sgNCBdO1xyXG4gICAgICAgICAgICAgICAgY3B5ICA9IGFyZ3NbIDUgXTtcclxuXHJcbiAgICAgICAgICAgICAgICBjcHgxID0gYXJnc1sgMCBdO1xyXG4gICAgICAgICAgICAgICAgY3B5MSA9IGFyZ3NbIDEgXTtcclxuXHJcbiAgICAgICAgICAgICAgICBjcHgyID0gYXJnc1sgMiBdO1xyXG4gICAgICAgICAgICAgICAgY3B5MiA9IGFyZ3NbIDMgXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHBvaW50cy5sZW5ndGggPiAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsYXN0ZSA9IHBvaW50c1sgcG9pbnRzLmxlbmd0aCAtIDEgXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY3B4MCA9IGxhc3RlLng7XHJcbiAgICAgICAgICAgICAgICAgICAgY3B5MCA9IGxhc3RlLnk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdGUgPSB0aGlzLmFjdGlvbnNbIGkgLSAxIF0uYXJncztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY3B4MCA9IGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAyIF07XHJcbiAgICAgICAgICAgICAgICAgICAgY3B5MCA9IGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAxIF07XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDE7IGogPD0gZGl2aXNpb25zOyBqICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGogLyBkaXZpc2lvbnM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHR4ID0gYjMoIHQsIGNweDAsIGNweDEsIGNweDIsIGNweCApO1xyXG4gICAgICAgICAgICAgICAgICAgIHR5ID0gYjMoIHQsIGNweTAsIGNweTEsIGNweTIsIGNweSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnc3BsaW5lVGhydSc6XHJcblxyXG4gICAgICAgICAgICAgICAgbGFzdGUgPSB0aGlzLmFjdGlvbnNbIGkgLSAxIF0uYXJncztcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IG5ldyBUSFJFRS5WZWN0b3IyKCBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMiBdLCBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMSBdICk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3B0cyA9IFsgbGFzdCBdO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBuID0gZGl2aXNpb25zICogYXJnc1sgMCBdLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICBzcHRzID0gc3B0cy5jb25jYXQoIGFyZ3NbIDAgXSApO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBzcGxpbmUgPSBuZXcgVEhSRUUuU3BsaW5lQ3VydmUoIHNwdHMgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDE7IGogPD0gbjsgaiArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goIHNwbGluZS5nZXRQb2ludEF0KCBqIC8gbiApICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnYXJjJzpcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgYVggPSBhcmdzWyAwIF0sIGFZID0gYXJnc1sgMSBdLFxyXG4gICAgICAgICAgICAgICAgICAgIGFSYWRpdXMgPSBhcmdzWyAyIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgYVN0YXJ0QW5nbGUgPSBhcmdzWyAzIF0sIGFFbmRBbmdsZSA9IGFyZ3NbIDQgXSxcclxuICAgICAgICAgICAgICAgICAgICBhQ2xvY2t3aXNlID0gISEgYXJnc1sgNSBdO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBkZWx0YUFuZ2xlID0gYUVuZEFuZ2xlIC0gYVN0YXJ0QW5nbGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgYW5nbGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGRpdmlzaW9ucyA9IGRpdmlzaW9ucyAqIDI7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGogPSAxOyBqIDw9IHRkaXZpc2lvbnM7IGogKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gaiAvIHRkaXZpc2lvbnM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggISBhQ2xvY2t3aXNlICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IDEgLSB0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlID0gYVN0YXJ0QW5nbGUgKyB0ICogZGVsdGFBbmdsZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdHggPSBhWCArIGFSYWRpdXMgKiBNYXRoLmNvcyggYW5nbGUgKTtcclxuICAgICAgICAgICAgICAgICAgICB0eSA9IGFZICsgYVJhZGl1cyAqIE1hdGguc2luKCBhbmdsZSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd0JywgdCwgJ2FuZ2xlJywgYW5nbGUsICd0eCcsIHR4LCAndHknLCB0eSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhwb2ludHMpO1xyXG5cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnZWxsaXBzZSc6XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGFYID0gYXJnc1sgMCBdLCBhWSA9IGFyZ3NbIDEgXSxcclxuICAgICAgICAgICAgICAgICAgICB4UmFkaXVzID0gYXJnc1sgMiBdLFxyXG4gICAgICAgICAgICAgICAgICAgIHlSYWRpdXMgPSBhcmdzWyAzIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgYVN0YXJ0QW5nbGUgPSBhcmdzWyA0IF0sIGFFbmRBbmdsZSA9IGFyZ3NbIDUgXSxcclxuICAgICAgICAgICAgICAgICAgICBhQ2xvY2t3aXNlID0gISEgYXJnc1sgNiBdLFxyXG4gICAgICAgICAgICAgICAgICAgIGFSb3RhdGlvbiA9IGFyZ3NbIDcgXTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGRlbHRhQW5nbGUgPSBhRW5kQW5nbGUgLSBhU3RhcnRBbmdsZTtcclxuICAgICAgICAgICAgICAgIHZhciBhbmdsZTtcclxuICAgICAgICAgICAgICAgIHZhciB0ZGl2aXNpb25zID0gZGl2aXNpb25zICogMjtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgY29zLCBzaW47XHJcbiAgICAgICAgICAgICAgICBpZiAoIGFSb3RhdGlvbiAhPT0gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29zID0gTWF0aC5jb3MoIGFSb3RhdGlvbiApO1xyXG4gICAgICAgICAgICAgICAgICAgIHNpbiA9IE1hdGguc2luKCBhUm90YXRpb24gKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGogPSAxOyBqIDw9IHRkaXZpc2lvbnM7IGogKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gaiAvIHRkaXZpc2lvbnM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggISBhQ2xvY2t3aXNlICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IDEgLSB0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlID0gYVN0YXJ0QW5nbGUgKyB0ICogZGVsdGFBbmdsZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdHggPSBhWCArIHhSYWRpdXMgKiBNYXRoLmNvcyggYW5nbGUgKTtcclxuICAgICAgICAgICAgICAgICAgICB0eSA9IGFZICsgeVJhZGl1cyAqIE1hdGguc2luKCBhbmdsZSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGFSb3RhdGlvbiAhPT0gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gdHgsIHkgPSB0eTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJvdGF0ZSB0aGUgcG9pbnQgYWJvdXQgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdHggPSAoIHggLSBhWCApICogY29zIC0gKCB5IC0gYVkgKSAqIHNpbiArIGFYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eSA9ICggeCAtIGFYICkgKiBzaW4gKyAoIHkgLSBhWSApICogY29zICsgYVk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndCcsIHQsICdhbmdsZScsIGFuZ2xlLCAndHgnLCB0eCwgJ3R5JywgdHkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2cocG9pbnRzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgfSAvLyBlbmQgc3dpdGNoXHJcblxyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgLy8gTm9ybWFsaXplIHRvIHJlbW92ZSB0aGUgY2xvc2luZyBwb2ludCBieSBkZWZhdWx0LlxyXG4gICAgdmFyIGxhc3RQb2ludCA9IHBvaW50c1sgcG9pbnRzLmxlbmd0aCAtIDEgXTtcclxuICAgIGlmICggTWF0aC5hYnMoIGxhc3RQb2ludC54IC0gcG9pbnRzWyAwIF0ueCApIDwgTnVtYmVyLkVQU0lMT04gJiZcclxuICAgICAgICBNYXRoLmFicyggbGFzdFBvaW50LnkgLSBwb2ludHNbIDAgXS55ICkgPCBOdW1iZXIuRVBTSUxPTiApXHJcbiAgICAgICAgcG9pbnRzLnNwbGljZSggcG9pbnRzLmxlbmd0aCAtIDEsIDEgKTtcclxuICAgIGlmICggY2xvc2VkUGF0aCApIHtcclxuXHJcbiAgICAgICAgcG9pbnRzLnB1c2goIHBvaW50c1sgMCBdICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwb2ludHM7XHJcblxyXG59O1xyXG5cclxuLy9cclxuLy8gQnJlYWtzIHBhdGggaW50byBzaGFwZXNcclxuLy9cclxuLy9cdEFzc3VtcHRpb25zIChpZiBwYXJhbWV0ZXIgaXNDQ1c9PXRydWUgdGhlIG9wcG9zaXRlIGhvbGRzKTpcclxuLy9cdC0gc29saWQgc2hhcGVzIGFyZSBkZWZpbmVkIGNsb2Nrd2lzZSAoQ1cpXHJcbi8vXHQtIGhvbGVzIGFyZSBkZWZpbmVkIGNvdW50ZXJjbG9ja3dpc2UgKENDVylcclxuLy9cclxuLy9cdElmIHBhcmFtZXRlciBub0hvbGVzPT10cnVlOlxyXG4vLyAgLSBhbGwgc3ViUGF0aHMgYXJlIHJlZ2FyZGVkIGFzIHNvbGlkIHNoYXBlc1xyXG4vLyAgLSBkZWZpbml0aW9uIG9yZGVyIENXL0NDVyBoYXMgbm8gcmVsZXZhbmNlXHJcbi8vXHJcblxyXG5USFJFRS5QYXRoLnByb3RvdHlwZS50b1NoYXBlcyA9IGZ1bmN0aW9uKCBpc0NDVywgbm9Ib2xlcyApIHtcclxuXHJcbiAgICBmdW5jdGlvbiBleHRyYWN0U3VicGF0aHMoIGluQWN0aW9ucyApIHtcclxuXHJcbiAgICAgICAgdmFyIHN1YlBhdGhzID0gW10sIGxhc3RQYXRoID0gbmV3IFRIUkVFLlBhdGgoKTtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gaW5BY3Rpb25zLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgaXRlbSA9IGluQWN0aW9uc1sgaSBdO1xyXG5cclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBpdGVtLmFyZ3M7XHJcbiAgICAgICAgICAgIHZhciBhY3Rpb24gPSBpdGVtLmFjdGlvbjtcclxuXHJcbiAgICAgICAgICAgIGlmICggYWN0aW9uID09PSAnbW92ZVRvJyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGxhc3RQYXRoLmFjdGlvbnMubGVuZ3RoICE9PSAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzdWJQYXRocy5wdXNoKCBsYXN0UGF0aCApO1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RQYXRoID0gbmV3IFRIUkVFLlBhdGgoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsYXN0UGF0aFsgYWN0aW9uIF0uYXBwbHkoIGxhc3RQYXRoLCBhcmdzICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBsYXN0UGF0aC5hY3Rpb25zLmxlbmd0aCAhPT0gMCApIHtcclxuXHJcbiAgICAgICAgICAgIHN1YlBhdGhzLnB1c2goIGxhc3RQYXRoICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coc3ViUGF0aHMpO1xyXG5cclxuICAgICAgICByZXR1cm5cdHN1YlBhdGhzO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0b1NoYXBlc05vSG9sZXMoIGluU3VicGF0aHMgKSB7XHJcblxyXG4gICAgICAgIHZhciBzaGFwZXMgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gaW5TdWJwYXRocy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHRtcFBhdGggPSBpblN1YnBhdGhzWyBpIF07XHJcblxyXG4gICAgICAgICAgICB2YXIgdG1wU2hhcGUgPSBuZXcgVEhSRUUuU2hhcGUoKTtcclxuICAgICAgICAgICAgdG1wU2hhcGUuYWN0aW9ucyA9IHRtcFBhdGguYWN0aW9ucztcclxuICAgICAgICAgICAgdG1wU2hhcGUuY3VydmVzID0gdG1wUGF0aC5jdXJ2ZXM7XHJcblxyXG4gICAgICAgICAgICBzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwic2hhcGVcIiwgc2hhcGVzKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHNoYXBlcztcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNQb2ludEluc2lkZVBvbHlnb24oIGluUHQsIGluUG9seWdvbiApIHtcclxuXHJcbiAgICAgICAgdmFyIHBvbHlMZW4gPSBpblBvbHlnb24ubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyBpblB0IG9uIHBvbHlnb24gY29udG91ciA9PiBpbW1lZGlhdGUgc3VjY2VzcyAgICBvclxyXG4gICAgICAgIC8vIHRvZ2dsaW5nIG9mIGluc2lkZS9vdXRzaWRlIGF0IGV2ZXJ5IHNpbmdsZSEgaW50ZXJzZWN0aW9uIHBvaW50IG9mIGFuIGVkZ2VcclxuICAgICAgICAvLyAgd2l0aCB0aGUgaG9yaXpvbnRhbCBsaW5lIHRocm91Z2ggaW5QdCwgbGVmdCBvZiBpblB0XHJcbiAgICAgICAgLy8gIG5vdCBjb3VudGluZyBsb3dlclkgZW5kcG9pbnRzIG9mIGVkZ2VzIGFuZCB3aG9sZSBlZGdlcyBvbiB0aGF0IGxpbmVcclxuICAgICAgICB2YXIgaW5zaWRlID0gZmFsc2U7XHJcbiAgICAgICAgZm9yICggdmFyIHAgPSBwb2x5TGVuIC0gMSwgcSA9IDA7IHEgPCBwb2x5TGVuOyBwID0gcSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBlZGdlTG93UHQgID0gaW5Qb2x5Z29uWyBwIF07XHJcbiAgICAgICAgICAgIHZhciBlZGdlSGlnaFB0ID0gaW5Qb2x5Z29uWyBxIF07XHJcblxyXG4gICAgICAgICAgICB2YXIgZWRnZUR4ID0gZWRnZUhpZ2hQdC54IC0gZWRnZUxvd1B0Lng7XHJcbiAgICAgICAgICAgIHZhciBlZGdlRHkgPSBlZGdlSGlnaFB0LnkgLSBlZGdlTG93UHQueTtcclxuXHJcbiAgICAgICAgICAgIGlmICggTWF0aC5hYnMoIGVkZ2VEeSApID4gTnVtYmVyLkVQU0lMT04gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbm90IHBhcmFsbGVsXHJcbiAgICAgICAgICAgICAgICBpZiAoIGVkZ2VEeSA8IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VMb3dQdCAgPSBpblBvbHlnb25bIHEgXTsgZWRnZUR4ID0gLSBlZGdlRHg7XHJcbiAgICAgICAgICAgICAgICAgICAgZWRnZUhpZ2hQdCA9IGluUG9seWdvblsgcCBdOyBlZGdlRHkgPSAtIGVkZ2VEeTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoICggaW5QdC55IDwgZWRnZUxvd1B0LnkgKSB8fCAoIGluUHQueSA+IGVkZ2VIaWdoUHQueSApICkgXHRcdGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggaW5QdC55ID09PSBlZGdlTG93UHQueSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpblB0LnggPT09IGVkZ2VMb3dQdC54IClcdFx0cmV0dXJuXHR0cnVlO1x0XHQvLyBpblB0IGlzIG9uIGNvbnRvdXIgP1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlO1x0XHRcdFx0Ly8gbm8gaW50ZXJzZWN0aW9uIG9yIGVkZ2VMb3dQdCA9PiBkb2Vzbid0IGNvdW50ICEhIVxyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwZXJwRWRnZSA9IGVkZ2VEeSAqICggaW5QdC54IC0gZWRnZUxvd1B0LnggKSAtIGVkZ2VEeCAqICggaW5QdC55IC0gZWRnZUxvd1B0LnkgKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHBlcnBFZGdlID09PSAwIClcdFx0XHRcdHJldHVyblx0dHJ1ZTtcdFx0Ly8gaW5QdCBpcyBvbiBjb250b3VyID9cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHBlcnBFZGdlIDwgMCApIFx0XHRcdFx0Y29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zaWRlID0gISBpbnNpZGU7XHRcdC8vIHRydWUgaW50ZXJzZWN0aW9uIGxlZnQgb2YgaW5QdFxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcGFyYWxsZWwgb3IgY29sbGluZWFyXHJcbiAgICAgICAgICAgICAgICBpZiAoIGluUHQueSAhPT0gZWRnZUxvd1B0LnkgKSBcdFx0Y29udGludWU7XHRcdFx0Ly8gcGFyYWxsZWxcclxuICAgICAgICAgICAgICAgIC8vIGVkZ2UgbGllcyBvbiB0aGUgc2FtZSBob3Jpem9udGFsIGxpbmUgYXMgaW5QdFxyXG4gICAgICAgICAgICAgICAgaWYgKCAoICggZWRnZUhpZ2hQdC54IDw9IGluUHQueCApICYmICggaW5QdC54IDw9IGVkZ2VMb3dQdC54ICkgKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICggKCBlZGdlTG93UHQueCA8PSBpblB0LnggKSAmJiAoIGluUHQueCA8PSBlZGdlSGlnaFB0LnggKSApIClcdFx0cmV0dXJuXHR0cnVlO1x0Ly8gaW5QdDogUG9pbnQgb24gY29udG91ciAhXHJcbiAgICAgICAgICAgICAgICAvLyBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm5cdGluc2lkZTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGlzQ2xvY2tXaXNlID0gVEhSRUUuU2hhcGVVdGlscy5pc0Nsb2NrV2lzZTtcclxuXHJcbiAgICB2YXIgc3ViUGF0aHMgPSBleHRyYWN0U3VicGF0aHMoIHRoaXMuYWN0aW9ucyApO1xyXG4gICAgaWYgKCBzdWJQYXRocy5sZW5ndGggPT09IDAgKSByZXR1cm4gW107XHJcblxyXG4gICAgaWYgKCBub0hvbGVzID09PSB0cnVlIClcdHJldHVyblx0dG9TaGFwZXNOb0hvbGVzKCBzdWJQYXRocyApO1xyXG5cclxuXHJcbiAgICB2YXIgc29saWQsIHRtcFBhdGgsIHRtcFNoYXBlLCBzaGFwZXMgPSBbXTtcclxuXHJcbiAgICBpZiAoIHN1YlBhdGhzLmxlbmd0aCA9PT0gMSApIHtcclxuXHJcbiAgICAgICAgdG1wUGF0aCA9IHN1YlBhdGhzWyAwIF07XHJcbiAgICAgICAgdG1wU2hhcGUgPSBuZXcgVEhSRUUuU2hhcGUoKTtcclxuICAgICAgICB0bXBTaGFwZS5hY3Rpb25zID0gdG1wUGF0aC5hY3Rpb25zO1xyXG4gICAgICAgIHRtcFNoYXBlLmN1cnZlcyA9IHRtcFBhdGguY3VydmVzO1xyXG4gICAgICAgIHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xyXG4gICAgICAgIHJldHVybiBzaGFwZXM7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHZhciBob2xlc0ZpcnN0ID0gISBpc0Nsb2NrV2lzZSggc3ViUGF0aHNbIDAgXS5nZXRQb2ludHMoKSApO1xyXG4gICAgaG9sZXNGaXJzdCA9IGlzQ0NXID8gISBob2xlc0ZpcnN0IDogaG9sZXNGaXJzdDtcclxuXHJcbiAgICAvLyBjb25zb2xlLmxvZyhcIkhvbGVzIGZpcnN0XCIsIGhvbGVzRmlyc3QpO1xyXG5cclxuICAgIHZhciBiZXR0ZXJTaGFwZUhvbGVzID0gW107XHJcbiAgICB2YXIgbmV3U2hhcGVzID0gW107XHJcbiAgICB2YXIgbmV3U2hhcGVIb2xlcyA9IFtdO1xyXG4gICAgdmFyIG1haW5JZHggPSAwO1xyXG4gICAgdmFyIHRtcFBvaW50cztcclxuXHJcbiAgICBuZXdTaGFwZXNbIG1haW5JZHggXSA9IHVuZGVmaW5lZDtcclxuICAgIG5ld1NoYXBlSG9sZXNbIG1haW5JZHggXSA9IFtdO1xyXG5cclxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHN1YlBhdGhzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIHRtcFBhdGggPSBzdWJQYXRoc1sgaSBdO1xyXG4gICAgICAgIHRtcFBvaW50cyA9IHRtcFBhdGguZ2V0UG9pbnRzKCk7XHJcbiAgICAgICAgc29saWQgPSBpc0Nsb2NrV2lzZSggdG1wUG9pbnRzICk7XHJcbiAgICAgICAgc29saWQgPSBpc0NDVyA/ICEgc29saWQgOiBzb2xpZDtcclxuXHJcbiAgICAgICAgaWYgKCBzb2xpZCApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggKCAhIGhvbGVzRmlyc3QgKSAmJiAoIG5ld1NoYXBlc1sgbWFpbklkeCBdICkgKVx0bWFpbklkeCArKztcclxuXHJcbiAgICAgICAgICAgIG5ld1NoYXBlc1sgbWFpbklkeCBdID0geyBzOiBuZXcgVEhSRUUuU2hhcGUoKSwgcDogdG1wUG9pbnRzIH07XHJcbiAgICAgICAgICAgIG5ld1NoYXBlc1sgbWFpbklkeCBdLnMuYWN0aW9ucyA9IHRtcFBhdGguYWN0aW9ucztcclxuICAgICAgICAgICAgbmV3U2hhcGVzWyBtYWluSWR4IF0ucy5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcclxuXHJcbiAgICAgICAgICAgIGlmICggaG9sZXNGaXJzdCApXHRtYWluSWR4ICsrO1xyXG4gICAgICAgICAgICBuZXdTaGFwZUhvbGVzWyBtYWluSWR4IF0gPSBbXTtcclxuXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2N3JywgaSk7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICBuZXdTaGFwZUhvbGVzWyBtYWluSWR4IF0ucHVzaCggeyBoOiB0bXBQYXRoLCBwOiB0bXBQb2ludHNbIDAgXSB9ICk7XHJcblxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjY3cnLCBpKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBvbmx5IEhvbGVzPyAtPiBwcm9iYWJseSBhbGwgU2hhcGVzIHdpdGggd3Jvbmcgb3JpZW50YXRpb25cclxuICAgIGlmICggISBuZXdTaGFwZXNbIDAgXSApXHRyZXR1cm5cdHRvU2hhcGVzTm9Ib2xlcyggc3ViUGF0aHMgKTtcclxuXHJcblxyXG4gICAgaWYgKCBuZXdTaGFwZXMubGVuZ3RoID4gMSApIHtcclxuXHJcbiAgICAgICAgdmFyIGFtYmlndW91cyA9IGZhbHNlO1xyXG4gICAgICAgIHZhciB0b0NoYW5nZSA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgc0lkeCA9IDAsIHNMZW4gPSBuZXdTaGFwZXMubGVuZ3RoOyBzSWR4IDwgc0xlbjsgc0lkeCArKyApIHtcclxuXHJcbiAgICAgICAgICAgIGJldHRlclNoYXBlSG9sZXNbIHNJZHggXSA9IFtdO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBzSWR4ID0gMCwgc0xlbiA9IG5ld1NoYXBlcy5sZW5ndGg7IHNJZHggPCBzTGVuOyBzSWR4ICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHNobyA9IG5ld1NoYXBlSG9sZXNbIHNJZHggXTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBoSWR4ID0gMDsgaElkeCA8IHNoby5sZW5ndGg7IGhJZHggKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGhvID0gc2hvWyBoSWR4IF07XHJcbiAgICAgICAgICAgICAgICB2YXIgaG9sZV91bmFzc2lnbmVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgczJJZHggPSAwOyBzMklkeCA8IG5ld1NoYXBlcy5sZW5ndGg7IHMySWR4ICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGlzUG9pbnRJbnNpZGVQb2x5Z29uKCBoby5wLCBuZXdTaGFwZXNbIHMySWR4IF0ucCApICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzSWR4ICE9PSBzMklkeCApXHR0b0NoYW5nZS5wdXNoKCB7IGZyb21zOiBzSWR4LCB0b3M6IHMySWR4LCBob2xlOiBoSWR4IH0gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBob2xlX3VuYXNzaWduZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZV91bmFzc2lnbmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXR0ZXJTaGFwZUhvbGVzWyBzMklkeCBdLnB1c2goIGhvICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFtYmlndW91cyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIGhvbGVfdW5hc3NpZ25lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYmV0dGVyU2hhcGVIb2xlc1sgc0lkeCBdLnB1c2goIGhvICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJhbWJpZ3VvdXM6IFwiLCBhbWJpZ3VvdXMpO1xyXG4gICAgICAgIGlmICggdG9DaGFuZ2UubGVuZ3RoID4gMCApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwidG8gY2hhbmdlOiBcIiwgdG9DaGFuZ2UpO1xyXG4gICAgICAgICAgICBpZiAoICEgYW1iaWd1b3VzIClcdG5ld1NoYXBlSG9sZXMgPSBiZXR0ZXJTaGFwZUhvbGVzO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHZhciB0bXBIb2xlcztcclxuXHJcbiAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gbmV3U2hhcGVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuICAgICAgICB0bXBTaGFwZSA9IG5ld1NoYXBlc1sgaSBdLnM7XHJcbiAgICAgICAgc2hhcGVzLnB1c2goIHRtcFNoYXBlICk7XHJcbiAgICAgICAgdG1wSG9sZXMgPSBuZXdTaGFwZUhvbGVzWyBpIF07XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSB0bXBIb2xlcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHRtcFNoYXBlLmhvbGVzLnB1c2goIHRtcEhvbGVzWyBqIF0uaCApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vY29uc29sZS5sb2coXCJzaGFwZVwiLCBzaGFwZXMpO1xyXG5cclxuICAgIHJldHVybiBzaGFwZXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2NvcmUvU2hhcGUuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqIERlZmluZXMgYSAyZCBzaGFwZSBwbGFuZSB1c2luZyBwYXRocy5cclxuICoqL1xyXG5cclxuLy8gU1RFUCAxIENyZWF0ZSBhIHBhdGguXHJcbi8vIFNURVAgMiBUdXJuIHBhdGggaW50byBzaGFwZS5cclxuLy8gU1RFUCAzIEV4dHJ1ZGVHZW9tZXRyeSB0YWtlcyBpbiBTaGFwZS9TaGFwZXNcclxuLy8gU1RFUCAzYSAtIEV4dHJhY3QgcG9pbnRzIGZyb20gZWFjaCBzaGFwZSwgdHVybiB0byB2ZXJ0aWNlc1xyXG4vLyBTVEVQIDNiIC0gVHJpYW5ndWxhdGUgZWFjaCBzaGFwZSwgYWRkIGZhY2VzLlxyXG5cclxuVEhSRUUuU2hhcGUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgVEhSRUUuUGF0aC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XHJcblxyXG4gICAgdGhpcy5ob2xlcyA9IFtdO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNoYXBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlBhdGgucHJvdG90eXBlICk7XHJcblRIUkVFLlNoYXBlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNoYXBlO1xyXG5cclxuLy8gQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJldHVybiBFeHRydWRlR2VvbWV0cnlcclxuXHJcblRIUkVFLlNoYXBlLnByb3RvdHlwZS5leHRydWRlID0gZnVuY3Rpb24gKCBvcHRpb25zICkge1xyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuRXh0cnVkZUdlb21ldHJ5KCB0aGlzLCBvcHRpb25zICk7XHJcblxyXG59O1xyXG5cclxuLy8gQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJldHVybiBTaGFwZUdlb21ldHJ5XHJcblxyXG5USFJFRS5TaGFwZS5wcm90b3R5cGUubWFrZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCBvcHRpb25zICkge1xyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuU2hhcGVHZW9tZXRyeSggdGhpcywgb3B0aW9ucyApO1xyXG5cclxufTtcclxuXHJcbi8vIEdldCBwb2ludHMgb2YgaG9sZXNcclxuXHJcblRIUkVFLlNoYXBlLnByb3RvdHlwZS5nZXRQb2ludHNIb2xlcyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xyXG5cclxuICAgIHZhciBob2xlc1B0cyA9IFtdO1xyXG5cclxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgaG9sZXNQdHNbIGkgXSA9IHRoaXMuaG9sZXNbIGkgXS5nZXRQb2ludHMoIGRpdmlzaW9ucyApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaG9sZXNQdHM7XHJcblxyXG59O1xyXG5cclxuXHJcbi8vIEdldCBwb2ludHMgb2Ygc2hhcGUgYW5kIGhvbGVzIChrZXlwb2ludHMgYmFzZWQgb24gc2VnbWVudHMgcGFyYW1ldGVyKVxyXG5cclxuVEhSRUUuU2hhcGUucHJvdG90eXBlLmV4dHJhY3RBbGxQb2ludHMgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcclxuXHJcbiAgICByZXR1cm4ge1xyXG5cclxuICAgICAgICBzaGFwZTogdGhpcy5nZXRQb2ludHMoIGRpdmlzaW9ucyApLFxyXG4gICAgICAgIGhvbGVzOiB0aGlzLmdldFBvaW50c0hvbGVzKCBkaXZpc2lvbnMgKVxyXG5cclxuICAgIH07XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU2hhcGUucHJvdG90eXBlLmV4dHJhY3RQb2ludHMgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5leHRyYWN0QWxsUG9pbnRzKCBkaXZpc2lvbnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TaGFwZS5VdGlscyA9IFRIUkVFLlNoYXBlVXRpbHM7IC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0xpbmVDdXJ2ZS5qc1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRMaW5lXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblRIUkVFLkxpbmVDdXJ2ZSA9IGZ1bmN0aW9uICggdjEsIHYyICkge1xyXG5cclxuICAgIHRoaXMudjEgPSB2MTtcclxuICAgIHRoaXMudjIgPSB2MjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5MaW5lQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XHJcblRIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MaW5lQ3VydmU7XHJcblxyXG5USFJFRS5MaW5lQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuICAgIHZhciBwb2ludCA9IHRoaXMudjIuY2xvbmUoKS5zdWIoIHRoaXMudjEgKTtcclxuICAgIHBvaW50Lm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLnYxICk7XHJcblxyXG4gICAgcmV0dXJuIHBvaW50O1xyXG5cclxufTtcclxuXHJcbi8vIExpbmUgY3VydmUgaXMgbGluZWFyLCBzbyB3ZSBjYW4gb3ZlcndyaXRlIGRlZmF1bHQgZ2V0UG9pbnRBdFxyXG5cclxuVEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludEF0ID0gZnVuY3Rpb24gKCB1ICkge1xyXG5cclxuICAgIHJldHVybiB0aGlzLmdldFBvaW50KCB1ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XHJcblxyXG4gICAgdmFyIHRhbmdlbnQgPSB0aGlzLnYyLmNsb25lKCkuc3ViKCB0aGlzLnYxICk7XHJcblxyXG4gICAgcmV0dXJuIHRhbmdlbnQubm9ybWFsaXplKCk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9RdWFkcmF0aWNCZXppZXJDdXJ2ZS5qc1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRRdWFkcmF0aWMgQmV6aWVyIGN1cnZlXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblxyXG5USFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZSA9IGZ1bmN0aW9uICggdjAsIHYxLCB2MiApIHtcclxuXHJcbiAgICB0aGlzLnYwID0gdjA7XHJcbiAgICB0aGlzLnYxID0gdjE7XHJcbiAgICB0aGlzLnYyID0gdjI7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XHJcblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlO1xyXG5cclxuXHJcblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcclxuXHJcbiAgICB2YXIgYjIgPSBUSFJFRS5TaGFwZVV0aWxzLmIyO1xyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMihcclxuICAgICAgICBiMiggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCApLFxyXG4gICAgICAgIGIyKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55IClcclxuICAgICk7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XHJcblxyXG4gICAgdmFyIHRhbmdlbnRRdWFkcmF0aWNCZXppZXIgPSBUSFJFRS5DdXJ2ZVV0aWxzLnRhbmdlbnRRdWFkcmF0aWNCZXppZXI7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKFxyXG4gICAgICAgIHRhbmdlbnRRdWFkcmF0aWNCZXppZXIoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLnggKSxcclxuICAgICAgICB0YW5nZW50UXVhZHJhdGljQmV6aWVyKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55IClcclxuICAgICkubm9ybWFsaXplKCk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9DdWJpY0JlemllckN1cnZlLmpzXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdEN1YmljIEJlemllciBjdXJ2ZVxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5USFJFRS5DdWJpY0JlemllckN1cnZlID0gZnVuY3Rpb24gKCB2MCwgdjEsIHYyLCB2MyApIHtcclxuXHJcbiAgICB0aGlzLnYwID0gdjA7XHJcbiAgICB0aGlzLnYxID0gdjE7XHJcbiAgICB0aGlzLnYyID0gdjI7XHJcbiAgICB0aGlzLnYzID0gdjM7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcclxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DdWJpY0JlemllckN1cnZlO1xyXG5cclxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG4gICAgdmFyIGIzID0gVEhSRUUuU2hhcGVVdGlscy5iMztcclxuXHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoXHJcbiAgICAgICAgYjMoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLngsIHRoaXMudjMueCApLFxyXG4gICAgICAgIGIzKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55LCB0aGlzLnYzLnkgKVxyXG4gICAgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XHJcblxyXG4gICAgdmFyIHRhbmdlbnRDdWJpY0JlemllciA9IFRIUkVFLkN1cnZlVXRpbHMudGFuZ2VudEN1YmljQmV6aWVyO1xyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMihcclxuICAgICAgICB0YW5nZW50Q3ViaWNCZXppZXIoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLngsIHRoaXMudjMueCApLFxyXG4gICAgICAgIHRhbmdlbnRDdWJpY0JlemllciggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSwgdGhpcy52My55IClcclxuICAgICkubm9ybWFsaXplKCk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9TcGxpbmVDdXJ2ZS5qc1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRTcGxpbmUgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuVEhSRUUuU3BsaW5lQ3VydmUgPSBmdW5jdGlvbiAoIHBvaW50cyAvKiBhcnJheSBvZiBWZWN0b3IyICovICkge1xyXG5cclxuICAgIHRoaXMucG9pbnRzID0gKCBwb2ludHMgPT0gdW5kZWZpbmVkICkgPyBbXSA6IHBvaW50cztcclxuXHJcbn07XHJcblxyXG5USFJFRS5TcGxpbmVDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcclxuVEhSRUUuU3BsaW5lQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU3BsaW5lQ3VydmU7XHJcblxyXG5USFJFRS5TcGxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG4gICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xyXG4gICAgdmFyIHBvaW50ID0gKCBwb2ludHMubGVuZ3RoIC0gMSApICogdDtcclxuXHJcbiAgICB2YXIgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xyXG4gICAgdmFyIHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XHJcblxyXG4gICAgdmFyIHBvaW50MCA9IHBvaW50c1sgaW50UG9pbnQgPT09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMSBdO1xyXG4gICAgdmFyIHBvaW50MSA9IHBvaW50c1sgaW50UG9pbnQgXTtcclxuICAgIHZhciBwb2ludDIgPSBwb2ludHNbIGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDIgPyBwb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMSBdO1xyXG4gICAgdmFyIHBvaW50MyA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMyA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAyIF07XHJcblxyXG4gICAgdmFyIGludGVycG9sYXRlID0gVEhSRUUuQ3VydmVVdGlscy5pbnRlcnBvbGF0ZTtcclxuXHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoXHJcbiAgICAgICAgaW50ZXJwb2xhdGUoIHBvaW50MC54LCBwb2ludDEueCwgcG9pbnQyLngsIHBvaW50My54LCB3ZWlnaHQgKSxcclxuICAgICAgICBpbnRlcnBvbGF0ZSggcG9pbnQwLnksIHBvaW50MS55LCBwb2ludDIueSwgcG9pbnQzLnksIHdlaWdodCApXHJcbiAgICApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvRWxsaXBzZUN1cnZlLmpzXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdEVsbGlwc2UgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuVEhSRUUuRWxsaXBzZUN1cnZlID0gZnVuY3Rpb24gKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApIHtcclxuXHJcbiAgICB0aGlzLmFYID0gYVg7XHJcbiAgICB0aGlzLmFZID0gYVk7XHJcblxyXG4gICAgdGhpcy54UmFkaXVzID0geFJhZGl1cztcclxuICAgIHRoaXMueVJhZGl1cyA9IHlSYWRpdXM7XHJcblxyXG4gICAgdGhpcy5hU3RhcnRBbmdsZSA9IGFTdGFydEFuZ2xlO1xyXG4gICAgdGhpcy5hRW5kQW5nbGUgPSBhRW5kQW5nbGU7XHJcblxyXG4gICAgdGhpcy5hQ2xvY2t3aXNlID0gYUNsb2Nrd2lzZTtcclxuXHJcbiAgICB0aGlzLmFSb3RhdGlvbiA9IGFSb3RhdGlvbiB8fCAwO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcclxuVEhSRUUuRWxsaXBzZUN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkVsbGlwc2VDdXJ2ZTtcclxuXHJcblRIUkVFLkVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG4gICAgdmFyIGRlbHRhQW5nbGUgPSB0aGlzLmFFbmRBbmdsZSAtIHRoaXMuYVN0YXJ0QW5nbGU7XHJcblxyXG4gICAgaWYgKCBkZWx0YUFuZ2xlIDwgMCApIGRlbHRhQW5nbGUgKz0gTWF0aC5QSSAqIDI7XHJcbiAgICBpZiAoIGRlbHRhQW5nbGUgPiBNYXRoLlBJICogMiApIGRlbHRhQW5nbGUgLT0gTWF0aC5QSSAqIDI7XHJcblxyXG4gICAgdmFyIGFuZ2xlO1xyXG5cclxuICAgIGlmICggdGhpcy5hQ2xvY2t3aXNlID09PSB0cnVlICkge1xyXG5cclxuICAgICAgICBhbmdsZSA9IHRoaXMuYUVuZEFuZ2xlICsgKCAxIC0gdCApICogKCBNYXRoLlBJICogMiAtIGRlbHRhQW5nbGUgKTtcclxuXHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICBhbmdsZSA9IHRoaXMuYVN0YXJ0QW5nbGUgKyB0ICogZGVsdGFBbmdsZTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHggPSB0aGlzLmFYICsgdGhpcy54UmFkaXVzICogTWF0aC5jb3MoIGFuZ2xlICk7XHJcbiAgICB2YXIgeSA9IHRoaXMuYVkgKyB0aGlzLnlSYWRpdXMgKiBNYXRoLnNpbiggYW5nbGUgKTtcclxuXHJcbiAgICBpZiAoIHRoaXMuYVJvdGF0aW9uICE9PSAwICkge1xyXG5cclxuICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MoIHRoaXMuYVJvdGF0aW9uICk7XHJcbiAgICAgICAgdmFyIHNpbiA9IE1hdGguc2luKCB0aGlzLmFSb3RhdGlvbiApO1xyXG5cclxuICAgICAgICB2YXIgdHggPSB4LCB0eSA9IHk7XHJcblxyXG4gICAgICAgIC8vIFJvdGF0ZSB0aGUgcG9pbnQgYWJvdXQgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzZS5cclxuICAgICAgICB4ID0gKCB0eCAtIHRoaXMuYVggKSAqIGNvcyAtICggdHkgLSB0aGlzLmFZICkgKiBzaW4gKyB0aGlzLmFYO1xyXG4gICAgICAgIHkgPSAoIHR4IC0gdGhpcy5hWCApICogc2luICsgKCB0eSAtIHRoaXMuYVkgKSAqIGNvcyArIHRoaXMuYVk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMiggeCwgeSApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvQXJjQ3VydmUuanNcclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0QXJjIGN1cnZlXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblRIUkVFLkFyY0N1cnZlID0gZnVuY3Rpb24gKCBhWCwgYVksIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XHJcblxyXG4gICAgVEhSRUUuRWxsaXBzZUN1cnZlLmNhbGwoIHRoaXMsIGFYLCBhWSwgYVJhZGl1cywgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkFyY0N1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUgKTtcclxuVEhSRUUuQXJjQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQXJjQ3VydmU7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0xpbmVDdXJ2ZTMuanNcclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0TGluZTNEXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblRIUkVFLkxpbmVDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXHJcblxyXG4gICAgZnVuY3Rpb24gKCB2MSwgdjIgKSB7XHJcblxyXG4gICAgICAgIHRoaXMudjEgPSB2MTtcclxuICAgICAgICB0aGlzLnYyID0gdjI7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG4gICAgICAgIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICB2ZWN0b3Iuc3ViVmVjdG9ycyggdGhpcy52MiwgdGhpcy52MSApOyAvLyBkaWZmXHJcbiAgICAgICAgdmVjdG9yLm11bHRpcGx5U2NhbGFyKCB0ICk7XHJcbiAgICAgICAgdmVjdG9yLmFkZCggdGhpcy52MSApO1xyXG5cclxuICAgICAgICByZXR1cm4gdmVjdG9yO1xyXG5cclxuICAgIH1cclxuXHJcbik7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL1F1YWRyYXRpY0JlemllckN1cnZlMy5qc1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRRdWFkcmF0aWMgQmV6aWVyIDNEIGN1cnZlXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlMyA9IFRIUkVFLkN1cnZlLmNyZWF0ZShcclxuXHJcbiAgICBmdW5jdGlvbiAoIHYwLCB2MSwgdjIgKSB7XHJcblxyXG4gICAgICAgIHRoaXMudjAgPSB2MDtcclxuICAgICAgICB0aGlzLnYxID0gdjE7XHJcbiAgICAgICAgdGhpcy52MiA9IHYyO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuICAgICAgICB2YXIgYjIgPSBUSFJFRS5TaGFwZVV0aWxzLmIyO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoXHJcbiAgICAgICAgICAgIGIyKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54ICksXHJcbiAgICAgICAgICAgIGIyKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55ICksXHJcbiAgICAgICAgICAgIGIyKCB0LCB0aGlzLnYwLnosIHRoaXMudjEueiwgdGhpcy52Mi56IClcclxuICAgICAgICApO1xyXG5cclxuICAgIH1cclxuXHJcbik7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0N1YmljQmV6aWVyQ3VydmUzLmpzXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdEN1YmljIEJlemllciAzRCBjdXJ2ZVxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5USFJFRS5DdWJpY0JlemllckN1cnZlMyA9IFRIUkVFLkN1cnZlLmNyZWF0ZShcclxuXHJcbiAgICBmdW5jdGlvbiAoIHYwLCB2MSwgdjIsIHYzICkge1xyXG5cclxuICAgICAgICB0aGlzLnYwID0gdjA7XHJcbiAgICAgICAgdGhpcy52MSA9IHYxO1xyXG4gICAgICAgIHRoaXMudjIgPSB2MjtcclxuICAgICAgICB0aGlzLnYzID0gdjM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG4gICAgICAgIHZhciBiMyA9IFRIUkVFLlNoYXBlVXRpbHMuYjM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyhcclxuICAgICAgICAgICAgYjMoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLngsIHRoaXMudjMueCApLFxyXG4gICAgICAgICAgICBiMyggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSwgdGhpcy52My55ICksXHJcbiAgICAgICAgICAgIGIzKCB0LCB0aGlzLnYwLnosIHRoaXMudjEueiwgdGhpcy52Mi56LCB0aGlzLnYzLnogKVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgfVxyXG5cclxuKTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvU3BsaW5lQ3VydmUzLmpzXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdFNwbGluZSAzRCBjdXJ2ZVxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5cclxuVEhSRUUuU3BsaW5lQ3VydmUzID0gVEhSRUUuQ3VydmUuY3JlYXRlKFxyXG5cclxuICAgIGZ1bmN0aW9uICggcG9pbnRzIC8qIGFycmF5IG9mIFZlY3RvcjMgKi8gKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlNwbGluZUN1cnZlMyB3aWxsIGJlIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgVEhSRUUuQ2F0bXVsbFJvbUN1cnZlMycgKTtcclxuICAgICAgICB0aGlzLnBvaW50cyA9ICggcG9pbnRzID09IHVuZGVmaW5lZCApID8gW10gOiBwb2ludHM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcclxuICAgICAgICB2YXIgcG9pbnQgPSAoIHBvaW50cy5sZW5ndGggLSAxICkgKiB0O1xyXG5cclxuICAgICAgICB2YXIgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xyXG4gICAgICAgIHZhciB3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xyXG5cclxuICAgICAgICB2YXIgcG9pbnQwID0gcG9pbnRzWyBpbnRQb2ludCA9PSAwID8gaW50UG9pbnQgOiBpbnRQb2ludCAtIDEgXTtcclxuICAgICAgICB2YXIgcG9pbnQxID0gcG9pbnRzWyBpbnRQb2ludCBdO1xyXG4gICAgICAgIHZhciBwb2ludDIgPSBwb2ludHNbIGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDIgPyBwb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMSBdO1xyXG4gICAgICAgIHZhciBwb2ludDMgPSBwb2ludHNbIGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDMgPyBwb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMiBdO1xyXG5cclxuICAgICAgICB2YXIgaW50ZXJwb2xhdGUgPSBUSFJFRS5DdXJ2ZVV0aWxzLmludGVycG9sYXRlO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoXHJcbiAgICAgICAgICAgIGludGVycG9sYXRlKCBwb2ludDAueCwgcG9pbnQxLngsIHBvaW50Mi54LCBwb2ludDMueCwgd2VpZ2h0ICksXHJcbiAgICAgICAgICAgIGludGVycG9sYXRlKCBwb2ludDAueSwgcG9pbnQxLnksIHBvaW50Mi55LCBwb2ludDMueSwgd2VpZ2h0ICksXHJcbiAgICAgICAgICAgIGludGVycG9sYXRlKCBwb2ludDAueiwgcG9pbnQxLnosIHBvaW50Mi56LCBwb2ludDMueiwgd2VpZ2h0IClcclxuICAgICAgICApO1xyXG5cclxuICAgIH1cclxuXHJcbik7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0NhdG11bGxSb21DdXJ2ZTMuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIHp6ODUgaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcclxuICpcclxuICogQ2VudHJpcGV0YWwgQ2F0bXVsbFJvbSBDdXJ2ZSAtIHdoaWNoIGlzIHVzZWZ1bCBmb3IgYXZvaWRpbmdcclxuICogY3VzcHMgYW5kIHNlbGYtaW50ZXJzZWN0aW9ucyBpbiBub24tdW5pZm9ybSBjYXRtdWxsIHJvbSBjdXJ2ZXMuXHJcbiAqIGh0dHA6Ly93d3cuY2VteXVrc2VsLmNvbS9yZXNlYXJjaC9jYXRtdWxscm9tX3BhcmFtL2NhdG11bGxyb20ucGRmXHJcbiAqXHJcbiAqIGN1cnZlLnR5cGUgYWNjZXB0cyBjZW50cmlwZXRhbChkZWZhdWx0KSwgY2hvcmRhbCBhbmQgY2F0bXVsbHJvbVxyXG4gKiBjdXJ2ZS50ZW5zaW9uIGlzIHVzZWQgZm9yIGNhdG11bGxyb20gd2hpY2ggZGVmYXVsdHMgdG8gMC41XHJcbiAqL1xyXG5cclxuVEhSRUUuQ2F0bXVsbFJvbUN1cnZlMyA9ICggZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgdmFyXHJcbiAgICAgICAgdG1wID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuICAgICAgICBweCA9IG5ldyBDdWJpY1BvbHkoKSxcclxuICAgICAgICBweSA9IG5ldyBDdWJpY1BvbHkoKSxcclxuICAgICAgICBweiA9IG5ldyBDdWJpY1BvbHkoKTtcclxuXHJcbiAgICAvKlxyXG4gICAgIEJhc2VkIG9uIGFuIG9wdGltaXplZCBjKysgc29sdXRpb24gaW5cclxuICAgICAtIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTQ4OTczNi9jYXRtdWxsLXJvbS1jdXJ2ZS13aXRoLW5vLWN1c3BzLWFuZC1uby1zZWxmLWludGVyc2VjdGlvbnMvXHJcbiAgICAgLSBodHRwOi8vaWRlb25lLmNvbS9Ob0ViVk1cclxuXHJcbiAgICAgVGhpcyBDdWJpY1BvbHkgY2xhc3MgY291bGQgYmUgdXNlZCBmb3IgcmV1c2luZyBzb21lIHZhcmlhYmxlcyBhbmQgY2FsY3VsYXRpb25zLFxyXG4gICAgIGJ1dCBmb3IgdGhyZWUuanMgY3VydmUgdXNlLCBpdCBjb3VsZCBiZSBwb3NzaWJsZSBpbmxpbmVkIGFuZCBmbGF0dGVuIGludG8gYSBzaW5nbGUgZnVuY3Rpb24gY2FsbFxyXG4gICAgIHdoaWNoIGNhbiBiZSBwbGFjZWQgaW4gQ3VydmVVdGlscy5cclxuICAgICAqL1xyXG5cclxuICAgIGZ1bmN0aW9uIEN1YmljUG9seSgpIHtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgICAqIENvbXB1dGUgY29lZmZpY2llbnRzIGZvciBhIGN1YmljIHBvbHlub21pYWxcclxuICAgICAqICAgcChzKSA9IGMwICsgYzEqcyArIGMyKnNeMiArIGMzKnNeM1xyXG4gICAgICogc3VjaCB0aGF0XHJcbiAgICAgKiAgIHAoMCkgPSB4MCwgcCgxKSA9IHgxXHJcbiAgICAgKiAgYW5kXHJcbiAgICAgKiAgIHAnKDApID0gdDAsIHAnKDEpID0gdDEuXHJcbiAgICAgKi9cclxuICAgIEN1YmljUG9seS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCB4MCwgeDEsIHQwLCB0MSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5jMCA9IHgwO1xyXG4gICAgICAgIHRoaXMuYzEgPSB0MDtcclxuICAgICAgICB0aGlzLmMyID0gLSAzICogeDAgKyAzICogeDEgLSAyICogdDAgLSB0MTtcclxuICAgICAgICB0aGlzLmMzID0gMiAqIHgwIC0gMiAqIHgxICsgdDAgKyB0MTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIEN1YmljUG9seS5wcm90b3R5cGUuaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tID0gZnVuY3Rpb24oIHgwLCB4MSwgeDIsIHgzLCBkdDAsIGR0MSwgZHQyICkge1xyXG5cclxuICAgICAgICAvLyBjb21wdXRlIHRhbmdlbnRzIHdoZW4gcGFyYW1ldGVyaXplZCBpbiBbdDEsdDJdXHJcbiAgICAgICAgdmFyIHQxID0gKCB4MSAtIHgwICkgLyBkdDAgLSAoIHgyIC0geDAgKSAvICggZHQwICsgZHQxICkgKyAoIHgyIC0geDEgKSAvIGR0MTtcclxuICAgICAgICB2YXIgdDIgPSAoIHgyIC0geDEgKSAvIGR0MSAtICggeDMgLSB4MSApIC8gKCBkdDEgKyBkdDIgKSArICggeDMgLSB4MiApIC8gZHQyO1xyXG5cclxuICAgICAgICAvLyByZXNjYWxlIHRhbmdlbnRzIGZvciBwYXJhbWV0cml6YXRpb24gaW4gWzAsMV1cclxuICAgICAgICB0MSAqPSBkdDE7XHJcbiAgICAgICAgdDIgKj0gZHQxO1xyXG5cclxuICAgICAgICAvLyBpbml0Q3ViaWNQb2x5XHJcbiAgICAgICAgdGhpcy5pbml0KCB4MSwgeDIsIHQxLCB0MiApO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLy8gc3RhbmRhcmQgQ2F0bXVsbC1Sb20gc3BsaW5lOiBpbnRlcnBvbGF0ZSBiZXR3ZWVuIHgxIGFuZCB4MiB3aXRoIHByZXZpb3VzL2ZvbGxvd2luZyBwb2ludHMgeDEveDRcclxuICAgIEN1YmljUG9seS5wcm90b3R5cGUuaW5pdENhdG11bGxSb20gPSBmdW5jdGlvbiggeDAsIHgxLCB4MiwgeDMsIHRlbnNpb24gKSB7XHJcblxyXG4gICAgICAgIHRoaXMuaW5pdCggeDEsIHgyLCB0ZW5zaW9uICogKCB4MiAtIHgwICksIHRlbnNpb24gKiAoIHgzIC0geDEgKSApO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgQ3ViaWNQb2x5LnByb3RvdHlwZS5jYWxjID0gZnVuY3Rpb24oIHQgKSB7XHJcblxyXG4gICAgICAgIHZhciB0MiA9IHQgKiB0O1xyXG4gICAgICAgIHZhciB0MyA9IHQyICogdDtcclxuICAgICAgICByZXR1cm4gdGhpcy5jMCArIHRoaXMuYzEgKiB0ICsgdGhpcy5jMiAqIHQyICsgdGhpcy5jMyAqIHQzO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLy8gU3ViY2xhc3MgVGhyZWUuanMgY3VydmVcclxuICAgIHJldHVybiBUSFJFRS5DdXJ2ZS5jcmVhdGUoXHJcblxyXG4gICAgICAgIGZ1bmN0aW9uICggcCAvKiBhcnJheSBvZiBWZWN0b3IzICovICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5wb2ludHMgPSBwIHx8IFtdO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHMsXHJcbiAgICAgICAgICAgICAgICBwb2ludCwgaW50UG9pbnQsIHdlaWdodCwgbDtcclxuXHJcbiAgICAgICAgICAgIGwgPSBwb2ludHMubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBsIDwgMiApIGNvbnNvbGUubG9nKCAnZHVoLCB5b3UgbmVlZCBhdCBsZWFzdCAyIHBvaW50cycgKTtcclxuXHJcbiAgICAgICAgICAgIHBvaW50ID0gKCBsIC0gMSApICogdDtcclxuICAgICAgICAgICAgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xyXG4gICAgICAgICAgICB3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xyXG5cclxuICAgICAgICAgICAgaWYgKCB3ZWlnaHQgPT09IDAgJiYgaW50UG9pbnQgPT09IGwgLSAxICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGludFBvaW50ID0gbCAtIDI7XHJcbiAgICAgICAgICAgICAgICB3ZWlnaHQgPSAxO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHAwLCBwMSwgcDIsIHAzO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBpbnRQb2ludCA9PT0gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBleHRyYXBvbGF0ZSBmaXJzdCBwb2ludFxyXG4gICAgICAgICAgICAgICAgdG1wLnN1YlZlY3RvcnMoIHBvaW50c1sgMCBdLCBwb2ludHNbIDEgXSApLmFkZCggcG9pbnRzWyAwIF0gKTtcclxuICAgICAgICAgICAgICAgIHAwID0gdG1wO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICBwMCA9IHBvaW50c1sgaW50UG9pbnQgLSAxIF07XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwMSA9IHBvaW50c1sgaW50UG9pbnQgXTtcclxuICAgICAgICAgICAgcDIgPSBwb2ludHNbIGludFBvaW50ICsgMSBdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBpbnRQb2ludCArIDIgPCBsICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHAzID0gcG9pbnRzWyBpbnRQb2ludCArIDIgXVxyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBleHRyYXBvbGF0ZSBsYXN0IHBvaW50XHJcbiAgICAgICAgICAgICAgICB0bXAuc3ViVmVjdG9ycyggcG9pbnRzWyBsIC0gMSBdLCBwb2ludHNbIGwgLSAyIF0gKS5hZGQoIHBvaW50c1sgbCAtIDIgXSApO1xyXG4gICAgICAgICAgICAgICAgcDMgPSB0bXA7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIHRoaXMudHlwZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMudHlwZSA9PT0gJ2NlbnRyaXBldGFsJyB8fCB0aGlzLnR5cGUgPT09ICdjaG9yZGFsJyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpbml0IENlbnRyaXBldGFsIC8gQ2hvcmRhbCBDYXRtdWxsLVJvbVxyXG4gICAgICAgICAgICAgICAgdmFyIHBvdyA9IHRoaXMudHlwZSA9PT0gJ2Nob3JkYWwnID8gMC41IDogMC4yNTtcclxuICAgICAgICAgICAgICAgIHZhciBkdDAgPSBNYXRoLnBvdyggcDAuZGlzdGFuY2VUb1NxdWFyZWQoIHAxICksIHBvdyApO1xyXG4gICAgICAgICAgICAgICAgdmFyIGR0MSA9IE1hdGgucG93KCBwMS5kaXN0YW5jZVRvU3F1YXJlZCggcDIgKSwgcG93ICk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZHQyID0gTWF0aC5wb3coIHAyLmRpc3RhbmNlVG9TcXVhcmVkKCBwMyApLCBwb3cgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBzYWZldHkgY2hlY2sgZm9yIHJlcGVhdGVkIHBvaW50c1xyXG4gICAgICAgICAgICAgICAgaWYgKCBkdDEgPCAxZS00ICkgZHQxID0gMS4wO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBkdDAgPCAxZS00ICkgZHQwID0gZHQxO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBkdDIgPCAxZS00ICkgZHQyID0gZHQxO1xyXG5cclxuICAgICAgICAgICAgICAgIHB4LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSggcDAueCwgcDEueCwgcDIueCwgcDMueCwgZHQwLCBkdDEsIGR0MiApO1xyXG4gICAgICAgICAgICAgICAgcHkuaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tKCBwMC55LCBwMS55LCBwMi55LCBwMy55LCBkdDAsIGR0MSwgZHQyICk7XHJcbiAgICAgICAgICAgICAgICBwei5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oIHAwLnosIHAxLnosIHAyLnosIHAzLnosIGR0MCwgZHQxLCBkdDIgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHRoaXMudHlwZSA9PT0gJ2NhdG11bGxyb20nICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB0ZW5zaW9uID0gdGhpcy50ZW5zaW9uICE9PSB1bmRlZmluZWQgPyB0aGlzLnRlbnNpb24gOiAwLjU7XHJcbiAgICAgICAgICAgICAgICBweC5pbml0Q2F0bXVsbFJvbSggcDAueCwgcDEueCwgcDIueCwgcDMueCwgdGVuc2lvbiApO1xyXG4gICAgICAgICAgICAgICAgcHkuaW5pdENhdG11bGxSb20oIHAwLnksIHAxLnksIHAyLnksIHAzLnksIHRlbnNpb24gKTtcclxuICAgICAgICAgICAgICAgIHB6LmluaXRDYXRtdWxsUm9tKCBwMC56LCBwMS56LCBwMi56LCBwMy56LCB0ZW5zaW9uICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgdiA9IG5ldyBUSFJFRS5WZWN0b3IzKFxyXG4gICAgICAgICAgICAgICAgcHguY2FsYyggd2VpZ2h0ICksXHJcbiAgICAgICAgICAgICAgICBweS5jYWxjKCB3ZWlnaHQgKSxcclxuICAgICAgICAgICAgICAgIHB6LmNhbGMoIHdlaWdodCApXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdjtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICk7XHJcblxyXG59ICkoKTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvQ2xvc2VkU3BsaW5lQ3VydmUzLmpzXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdENsb3NlZCBTcGxpbmUgM0QgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuXHJcblRIUkVFLkNsb3NlZFNwbGluZUN1cnZlMyA9IFRIUkVFLkN1cnZlLmNyZWF0ZShcclxuXHJcbiAgICBmdW5jdGlvbiAoIHBvaW50cyAvKiBhcnJheSBvZiBWZWN0b3IzICovICkge1xyXG5cclxuICAgICAgICB0aGlzLnBvaW50cyA9ICggcG9pbnRzID09IHVuZGVmaW5lZCApID8gW10gOiBwb2ludHM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcclxuICAgICAgICB2YXIgcG9pbnQgPSAoIHBvaW50cy5sZW5ndGggLSAwICkgKiB0OyAvLyBUaGlzIG5lZWRzIHRvIGJlIGZyb20gMC1sZW5ndGggKzFcclxuXHJcbiAgICAgICAgdmFyIGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcclxuICAgICAgICB2YXIgd2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcclxuXHJcbiAgICAgICAgaW50UG9pbnQgKz0gaW50UG9pbnQgPiAwID8gMCA6ICggTWF0aC5mbG9vciggTWF0aC5hYnMoIGludFBvaW50ICkgLyBwb2ludHMubGVuZ3RoICkgKyAxICkgKiBwb2ludHMubGVuZ3RoO1xyXG5cclxuICAgICAgICB2YXIgcG9pbnQwID0gcG9pbnRzWyAoIGludFBvaW50IC0gMSApICUgcG9pbnRzLmxlbmd0aCBdO1xyXG4gICAgICAgIHZhciBwb2ludDEgPSBwb2ludHNbICggaW50UG9pbnQgICAgICkgJSBwb2ludHMubGVuZ3RoIF07XHJcbiAgICAgICAgdmFyIHBvaW50MiA9IHBvaW50c1sgKCBpbnRQb2ludCArIDEgKSAlIHBvaW50cy5sZW5ndGggXTtcclxuICAgICAgICB2YXIgcG9pbnQzID0gcG9pbnRzWyAoIGludFBvaW50ICsgMiApICUgcG9pbnRzLmxlbmd0aCBdO1xyXG5cclxuICAgICAgICB2YXIgaW50ZXJwb2xhdGUgPSBUSFJFRS5DdXJ2ZVV0aWxzLmludGVycG9sYXRlO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoXHJcbiAgICAgICAgICAgIGludGVycG9sYXRlKCBwb2ludDAueCwgcG9pbnQxLngsIHBvaW50Mi54LCBwb2ludDMueCwgd2VpZ2h0ICksXHJcbiAgICAgICAgICAgIGludGVycG9sYXRlKCBwb2ludDAueSwgcG9pbnQxLnksIHBvaW50Mi55LCBwb2ludDMueSwgd2VpZ2h0ICksXHJcbiAgICAgICAgICAgIGludGVycG9sYXRlKCBwb2ludDAueiwgcG9pbnQxLnosIHBvaW50Mi56LCBwb2ludDMueiwgd2VpZ2h0IClcclxuICAgICAgICApO1xyXG5cclxuICAgIH1cclxuXHJcbik7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9Cb3hHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIGJhc2VkIG9uIGh0dHA6Ly9wYXBlcnZpc2lvbjNkLmdvb2dsZWNvZGUuY29tL3N2bi90cnVuay9hczMvdHJ1bmsvc3JjL29yZy9wYXBlcnZpc2lvbjNkL29iamVjdHMvcHJpbWl0aXZlcy9DdWJlLmFzXHJcbiAqL1xyXG5cclxuVEhSRUUuQm94R2VvbWV0cnkgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgZGVwdGhTZWdtZW50cyApIHtcclxuXHJcbiAgICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ0JveEdlb21ldHJ5JztcclxuXHJcbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgIGRlcHRoOiBkZXB0aCxcclxuICAgICAgICB3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxyXG4gICAgICAgIGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcclxuICAgICAgICBkZXB0aFNlZ21lbnRzOiBkZXB0aFNlZ21lbnRzXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMud2lkdGhTZWdtZW50cyA9IHdpZHRoU2VnbWVudHMgfHwgMTtcclxuICAgIHRoaXMuaGVpZ2h0U2VnbWVudHMgPSBoZWlnaHRTZWdtZW50cyB8fCAxO1xyXG4gICAgdGhpcy5kZXB0aFNlZ21lbnRzID0gZGVwdGhTZWdtZW50cyB8fCAxO1xyXG5cclxuICAgIHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG4gICAgdmFyIHdpZHRoX2hhbGYgPSB3aWR0aCAvIDI7XHJcbiAgICB2YXIgaGVpZ2h0X2hhbGYgPSBoZWlnaHQgLyAyO1xyXG4gICAgdmFyIGRlcHRoX2hhbGYgPSBkZXB0aCAvIDI7XHJcblxyXG4gICAgYnVpbGRQbGFuZSggJ3onLCAneScsIC0gMSwgLSAxLCBkZXB0aCwgaGVpZ2h0LCB3aWR0aF9oYWxmLCAwICk7IC8vIHB4XHJcbiAgICBidWlsZFBsYW5lKCAneicsICd5JywgICAxLCAtIDEsIGRlcHRoLCBoZWlnaHQsIC0gd2lkdGhfaGFsZiwgMSApOyAvLyBueFxyXG4gICAgYnVpbGRQbGFuZSggJ3gnLCAneicsICAgMSwgICAxLCB3aWR0aCwgZGVwdGgsIGhlaWdodF9oYWxmLCAyICk7IC8vIHB5XHJcbiAgICBidWlsZFBsYW5lKCAneCcsICd6JywgICAxLCAtIDEsIHdpZHRoLCBkZXB0aCwgLSBoZWlnaHRfaGFsZiwgMyApOyAvLyBueVxyXG4gICAgYnVpbGRQbGFuZSggJ3gnLCAneScsICAgMSwgLSAxLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aF9oYWxmLCA0ICk7IC8vIHB6XHJcbiAgICBidWlsZFBsYW5lKCAneCcsICd5JywgLSAxLCAtIDEsIHdpZHRoLCBoZWlnaHQsIC0gZGVwdGhfaGFsZiwgNSApOyAvLyBuelxyXG5cclxuICAgIGZ1bmN0aW9uIGJ1aWxkUGxhbmUoIHUsIHYsIHVkaXIsIHZkaXIsIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCBtYXRlcmlhbEluZGV4ICkge1xyXG5cclxuICAgICAgICB2YXIgdywgaXgsIGl5LFxyXG4gICAgICAgICAgICBncmlkWCA9IHNjb3BlLndpZHRoU2VnbWVudHMsXHJcbiAgICAgICAgICAgIGdyaWRZID0gc2NvcGUuaGVpZ2h0U2VnbWVudHMsXHJcbiAgICAgICAgICAgIHdpZHRoX2hhbGYgPSB3aWR0aCAvIDIsXHJcbiAgICAgICAgICAgIGhlaWdodF9oYWxmID0gaGVpZ2h0IC8gMixcclxuICAgICAgICAgICAgb2Zmc2V0ID0gc2NvcGUudmVydGljZXMubGVuZ3RoO1xyXG5cclxuICAgICAgICBpZiAoICggdSA9PT0gJ3gnICYmIHYgPT09ICd5JyApIHx8ICggdSA9PT0gJ3knICYmIHYgPT09ICd4JyApICkge1xyXG5cclxuICAgICAgICAgICAgdyA9ICd6JztcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICggKCB1ID09PSAneCcgJiYgdiA9PT0gJ3onICkgfHwgKCB1ID09PSAneicgJiYgdiA9PT0gJ3gnICkgKSB7XHJcblxyXG4gICAgICAgICAgICB3ID0gJ3knO1xyXG4gICAgICAgICAgICBncmlkWSA9IHNjb3BlLmRlcHRoU2VnbWVudHM7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoICggdSA9PT0gJ3onICYmIHYgPT09ICd5JyApIHx8ICggdSA9PT0gJ3knICYmIHYgPT09ICd6JyApICkge1xyXG5cclxuICAgICAgICAgICAgdyA9ICd4JztcclxuICAgICAgICAgICAgZ3JpZFggPSBzY29wZS5kZXB0aFNlZ21lbnRzO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBncmlkWDEgPSBncmlkWCArIDEsXHJcbiAgICAgICAgICAgIGdyaWRZMSA9IGdyaWRZICsgMSxcclxuICAgICAgICAgICAgc2VnbWVudF93aWR0aCA9IHdpZHRoIC8gZ3JpZFgsXHJcbiAgICAgICAgICAgIHNlZ21lbnRfaGVpZ2h0ID0gaGVpZ2h0IC8gZ3JpZFksXHJcbiAgICAgICAgICAgIG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgIG5vcm1hbFsgdyBdID0gZGVwdGggPiAwID8gMSA6IC0gMTtcclxuXHJcbiAgICAgICAgZm9yICggaXkgPSAwOyBpeSA8IGdyaWRZMTsgaXkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCBpeCA9IDA7IGl4IDwgZ3JpZFgxOyBpeCArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICAgICAgICAgIHZlY3RvclsgdSBdID0gKCBpeCAqIHNlZ21lbnRfd2lkdGggLSB3aWR0aF9oYWxmICkgKiB1ZGlyO1xyXG4gICAgICAgICAgICAgICAgdmVjdG9yWyB2IF0gPSAoIGl5ICogc2VnbWVudF9oZWlnaHQgLSBoZWlnaHRfaGFsZiApICogdmRpcjtcclxuICAgICAgICAgICAgICAgIHZlY3RvclsgdyBdID0gZGVwdGg7XHJcblxyXG4gICAgICAgICAgICAgICAgc2NvcGUudmVydGljZXMucHVzaCggdmVjdG9yICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICggaXkgPSAwOyBpeSA8IGdyaWRZOyBpeSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIGl4ID0gMDsgaXggPCBncmlkWDsgaXggKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGEgPSBpeCArIGdyaWRYMSAqIGl5O1xyXG4gICAgICAgICAgICAgICAgdmFyIGIgPSBpeCArIGdyaWRYMSAqICggaXkgKyAxICk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9ICggaXggKyAxICkgKyBncmlkWDEgKiAoIGl5ICsgMSApO1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogaXk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHV2YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBpeCAvIGdyaWRYLCAxIC0gaXkgLyBncmlkWSApO1xyXG4gICAgICAgICAgICAgICAgdmFyIHV2YiA9IG5ldyBUSFJFRS5WZWN0b3IyKCBpeCAvIGdyaWRYLCAxIC0gKCBpeSArIDEgKSAvIGdyaWRZICk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdXZjID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaXggKyAxICkgLyBncmlkWCwgMSAtICggaXkgKyAxICkgLyBncmlkWSApO1xyXG4gICAgICAgICAgICAgICAgdmFyIHV2ZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGl4ICsgMSApIC8gZ3JpZFgsIDEgLSBpeSAvIGdyaWRZICk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIGEgKyBvZmZzZXQsIGIgKyBvZmZzZXQsIGQgKyBvZmZzZXQgKTtcclxuICAgICAgICAgICAgICAgIGZhY2Uubm9ybWFsLmNvcHkoIG5vcm1hbCApO1xyXG4gICAgICAgICAgICAgICAgZmFjZS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbC5jbG9uZSgpLCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCkgKTtcclxuICAgICAgICAgICAgICAgIGZhY2UubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXg7XHJcblxyXG4gICAgICAgICAgICAgICAgc2NvcGUuZmFjZXMucHVzaCggZmFjZSApO1xyXG4gICAgICAgICAgICAgICAgc2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZhLCB1dmIsIHV2ZCBdICk7XHJcblxyXG4gICAgICAgICAgICAgICAgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggYiArIG9mZnNldCwgYyArIG9mZnNldCwgZCArIG9mZnNldCApO1xyXG4gICAgICAgICAgICAgICAgZmFjZS5ub3JtYWwuY29weSggbm9ybWFsICk7XHJcbiAgICAgICAgICAgICAgICBmYWNlLnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsLmNsb25lKCksIG5vcm1hbC5jbG9uZSgpLCBub3JtYWwuY2xvbmUoKSApO1xyXG4gICAgICAgICAgICAgICAgZmFjZS5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcclxuXHJcbiAgICAgICAgICAgICAgICBzY29wZS5mYWNlcy5wdXNoKCBmYWNlICk7XHJcbiAgICAgICAgICAgICAgICBzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dmIuY2xvbmUoKSwgdXZjLCB1dmQuY2xvbmUoKSBdICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5tZXJnZVZlcnRpY2VzKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQm94R2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLkJveEdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkJveEdlb21ldHJ5O1xyXG5cclxuVEhSRUUuQm94R2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuQm94R2VvbWV0cnkoXHJcbiAgICAgICAgcGFyYW1ldGVycy53aWR0aCxcclxuICAgICAgICBwYXJhbWV0ZXJzLmhlaWdodCxcclxuICAgICAgICBwYXJhbWV0ZXJzLmRlcHRoLFxyXG4gICAgICAgIHBhcmFtZXRlcnMud2lkdGhTZWdtZW50cyxcclxuICAgICAgICBwYXJhbWV0ZXJzLmhlaWdodFNlZ21lbnRzLFxyXG4gICAgICAgIHBhcmFtZXRlcnMuZGVwdGhTZWdtZW50c1xyXG4gICAgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DdWJlR2VvbWV0cnkgPSBUSFJFRS5Cb3hHZW9tZXRyeTsgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0NpcmNsZUdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBodWdoZXNcclxuICovXHJcblxyXG5USFJFRS5DaXJjbGVHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCBzZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XHJcblxyXG4gICAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdDaXJjbGVHZW9tZXRyeSc7XHJcblxyXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xyXG4gICAgICAgIHJhZGl1czogcmFkaXVzLFxyXG4gICAgICAgIHNlZ21lbnRzOiBzZWdtZW50cyxcclxuICAgICAgICB0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxyXG4gICAgICAgIHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IFRIUkVFLkNpcmNsZUJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIHNlZ21lbnRzLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ2lyY2xlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLkNpcmNsZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkNpcmNsZUdlb21ldHJ5O1xyXG5cclxuVEhSRUUuQ2lyY2xlR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuQ2lyY2xlR2VvbWV0cnkoXHJcbiAgICAgICAgcGFyYW1ldGVycy5yYWRpdXMsXHJcbiAgICAgICAgcGFyYW1ldGVycy5zZWdtZW50cyxcclxuICAgICAgICBwYXJhbWV0ZXJzLnRoZXRhU3RhcnQsXHJcbiAgICAgICAgcGFyYW1ldGVycy50aGV0YUxlbmd0aFxyXG4gICAgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9DaXJjbGVCdWZmZXJHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xyXG4gKi9cclxuXHJcblRIUkVFLkNpcmNsZUJ1ZmZlckdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIHNlZ21lbnRzLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcclxuXHJcbiAgICBUSFJFRS5CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ0NpcmNsZUJ1ZmZlckdlb21ldHJ5JztcclxuXHJcbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgcmFkaXVzOiByYWRpdXMsXHJcbiAgICAgICAgc2VnbWVudHM6IHNlZ21lbnRzLFxyXG4gICAgICAgIHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXHJcbiAgICAgICAgdGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXHJcbiAgICB9O1xyXG5cclxuICAgIHJhZGl1cyA9IHJhZGl1cyB8fCA1MDtcclxuICAgIHNlZ21lbnRzID0gc2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IE1hdGgubWF4KCAzLCBzZWdtZW50cyApIDogODtcclxuXHJcbiAgICB0aGV0YVN0YXJ0ID0gdGhldGFTdGFydCAhPT0gdW5kZWZpbmVkID8gdGhldGFTdGFydCA6IDA7XHJcbiAgICB0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IE1hdGguUEkgKiAyO1xyXG5cclxuICAgIHZhciB2ZXJ0aWNlcyA9IHNlZ21lbnRzICsgMjtcclxuXHJcbiAgICB2YXIgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSggdmVydGljZXMgKiAzICk7XHJcbiAgICB2YXIgbm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRpY2VzICogMyApO1xyXG4gICAgdmFyIHV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRpY2VzICogMiApO1xyXG5cclxuICAgIC8vIGNlbnRlciBkYXRhIGlzIGFscmVhZHkgemVybywgYnV0IG5lZWQgdG8gc2V0IGEgZmV3IGV4dHJhc1xyXG4gICAgbm9ybWFsc1sgMiBdID0gMS4wO1xyXG4gICAgdXZzWyAwIF0gPSAwLjU7XHJcbiAgICB1dnNbIDEgXSA9IDAuNTtcclxuXHJcbiAgICBmb3IgKCB2YXIgcyA9IDAsIGkgPSAzLCBpaSA9IDIgOyBzIDw9IHNlZ21lbnRzOyBzICsrLCBpICs9IDMsIGlpICs9IDIgKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWdtZW50ID0gdGhldGFTdGFydCArIHMgLyBzZWdtZW50cyAqIHRoZXRhTGVuZ3RoO1xyXG5cclxuICAgICAgICBwb3NpdGlvbnNbIGkgXSA9IHJhZGl1cyAqIE1hdGguY29zKCBzZWdtZW50ICk7XHJcbiAgICAgICAgcG9zaXRpb25zWyBpICsgMSBdID0gcmFkaXVzICogTWF0aC5zaW4oIHNlZ21lbnQgKTtcclxuXHJcbiAgICAgICAgbm9ybWFsc1sgaSArIDIgXSA9IDE7IC8vIG5vcm1hbCB6XHJcblxyXG4gICAgICAgIHV2c1sgaWkgXSA9ICggcG9zaXRpb25zWyBpIF0gLyByYWRpdXMgKyAxICkgLyAyO1xyXG4gICAgICAgIHV2c1sgaWkgKyAxIF0gPSAoIHBvc2l0aW9uc1sgaSArIDEgXSAvIHJhZGl1cyArIDEgKSAvIDI7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHZhciBpbmRpY2VzID0gW107XHJcblxyXG4gICAgZm9yICggdmFyIGkgPSAxOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xyXG5cclxuICAgICAgICBpbmRpY2VzLnB1c2goIGksIGkgKyAxLCAwICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc2V0SW5kZXgoIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBVaW50MTZBcnJheSggaW5kaWNlcyApLCAxICkgKTtcclxuICAgIHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIDMgKSApO1xyXG4gICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcclxuICAgIHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xyXG5cclxuICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCBuZXcgVEhSRUUuVmVjdG9yMygpLCByYWRpdXMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DaXJjbGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuQ2lyY2xlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ2lyY2xlQnVmZmVyR2VvbWV0cnk7XHJcblxyXG5USFJFRS5DaXJjbGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5DaXJjbGVCdWZmZXJHZW9tZXRyeShcclxuICAgICAgICBwYXJhbWV0ZXJzLnJhZGl1cyxcclxuICAgICAgICBwYXJhbWV0ZXJzLnNlZ21lbnRzLFxyXG4gICAgICAgIHBhcmFtZXRlcnMudGhldGFTdGFydCxcclxuICAgICAgICBwYXJhbWV0ZXJzLnRoZXRhTGVuZ3RoXHJcbiAgICApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0N5bGluZGVyR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkN5bGluZGVyR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1c1RvcCwgcmFkaXVzQm90dG9tLCBoZWlnaHQsIHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgb3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcclxuXHJcbiAgICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ0N5bGluZGVyR2VvbWV0cnknO1xyXG5cclxuICAgIHRoaXMucGFyYW1ldGVycyA9IHtcclxuICAgICAgICByYWRpdXNUb3A6IHJhZGl1c1RvcCxcclxuICAgICAgICByYWRpdXNCb3R0b206IHJhZGl1c0JvdHRvbSxcclxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICByYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXHJcbiAgICAgICAgaGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxyXG4gICAgICAgIG9wZW5FbmRlZDogb3BlbkVuZGVkLFxyXG4gICAgICAgIHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXHJcbiAgICAgICAgdGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXHJcbiAgICB9O1xyXG5cclxuICAgIHJhZGl1c1RvcCA9IHJhZGl1c1RvcCAhPT0gdW5kZWZpbmVkID8gcmFkaXVzVG9wIDogMjA7XHJcbiAgICByYWRpdXNCb3R0b20gPSByYWRpdXNCb3R0b20gIT09IHVuZGVmaW5lZCA/IHJhZGl1c0JvdHRvbSA6IDIwO1xyXG4gICAgaGVpZ2h0ID0gaGVpZ2h0ICE9PSB1bmRlZmluZWQgPyBoZWlnaHQgOiAxMDA7XHJcblxyXG4gICAgcmFkaWFsU2VnbWVudHMgPSByYWRpYWxTZWdtZW50cyB8fCA4O1xyXG4gICAgaGVpZ2h0U2VnbWVudHMgPSBoZWlnaHRTZWdtZW50cyB8fCAxO1xyXG5cclxuICAgIG9wZW5FbmRlZCA9IG9wZW5FbmRlZCAhPT0gdW5kZWZpbmVkID8gb3BlbkVuZGVkIDogZmFsc2U7XHJcbiAgICB0aGV0YVN0YXJ0ID0gdGhldGFTdGFydCAhPT0gdW5kZWZpbmVkID8gdGhldGFTdGFydCA6IDA7XHJcbiAgICB0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IDIgKiBNYXRoLlBJO1xyXG5cclxuICAgIHZhciBoZWlnaHRIYWxmID0gaGVpZ2h0IC8gMjtcclxuXHJcbiAgICB2YXIgeCwgeSwgdmVydGljZXMgPSBbXSwgdXZzID0gW107XHJcblxyXG4gICAgZm9yICggeSA9IDA7IHkgPD0gaGVpZ2h0U2VnbWVudHM7IHkgKysgKSB7XHJcblxyXG4gICAgICAgIHZhciB2ZXJ0aWNlc1JvdyA9IFtdO1xyXG4gICAgICAgIHZhciB1dnNSb3cgPSBbXTtcclxuXHJcbiAgICAgICAgdmFyIHYgPSB5IC8gaGVpZ2h0U2VnbWVudHM7XHJcbiAgICAgICAgdmFyIHJhZGl1cyA9IHYgKiAoIHJhZGl1c0JvdHRvbSAtIHJhZGl1c1RvcCApICsgcmFkaXVzVG9wO1xyXG5cclxuICAgICAgICBmb3IgKCB4ID0gMDsgeCA8PSByYWRpYWxTZWdtZW50czsgeCArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciB1ID0geCAvIHJhZGlhbFNlZ21lbnRzO1xyXG5cclxuICAgICAgICAgICAgdmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgICAgIHZlcnRleC54ID0gcmFkaXVzICogTWF0aC5zaW4oIHUgKiB0aGV0YUxlbmd0aCArIHRoZXRhU3RhcnQgKTtcclxuICAgICAgICAgICAgdmVydGV4LnkgPSAtIHYgKiBoZWlnaHQgKyBoZWlnaHRIYWxmO1xyXG4gICAgICAgICAgICB2ZXJ0ZXgueiA9IHJhZGl1cyAqIE1hdGguY29zKCB1ICogdGhldGFMZW5ndGggKyB0aGV0YVN0YXJ0ICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xyXG5cclxuICAgICAgICAgICAgdmVydGljZXNSb3cucHVzaCggdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAxICk7XHJcbiAgICAgICAgICAgIHV2c1Jvdy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdSwgMSAtIHYgKSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZlcnRpY2VzLnB1c2goIHZlcnRpY2VzUm93ICk7XHJcbiAgICAgICAgdXZzLnB1c2goIHV2c1JvdyApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB2YXIgdGFuVGhldGEgPSAoIHJhZGl1c0JvdHRvbSAtIHJhZGl1c1RvcCApIC8gaGVpZ2h0O1xyXG4gICAgdmFyIG5hLCBuYjtcclxuXHJcbiAgICBmb3IgKCB4ID0gMDsgeCA8IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xyXG5cclxuICAgICAgICBpZiAoIHJhZGl1c1RvcCAhPT0gMCApIHtcclxuXHJcbiAgICAgICAgICAgIG5hID0gdGhpcy52ZXJ0aWNlc1sgdmVydGljZXNbIDAgXVsgeCBdIF0uY2xvbmUoKTtcclxuICAgICAgICAgICAgbmIgPSB0aGlzLnZlcnRpY2VzWyB2ZXJ0aWNlc1sgMCBdWyB4ICsgMSBdIF0uY2xvbmUoKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIG5hID0gdGhpcy52ZXJ0aWNlc1sgdmVydGljZXNbIDEgXVsgeCBdIF0uY2xvbmUoKTtcclxuICAgICAgICAgICAgbmIgPSB0aGlzLnZlcnRpY2VzWyB2ZXJ0aWNlc1sgMSBdWyB4ICsgMSBdIF0uY2xvbmUoKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBuYS5zZXRZKCBNYXRoLnNxcnQoIG5hLnggKiBuYS54ICsgbmEueiAqIG5hLnogKSAqIHRhblRoZXRhICkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgbmIuc2V0WSggTWF0aC5zcXJ0KCBuYi54ICogbmIueCArIG5iLnogKiBuYi56ICkgKiB0YW5UaGV0YSApLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICBmb3IgKCB5ID0gMDsgeSA8IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHYxID0gdmVydGljZXNbIHkgXVsgeCBdO1xyXG4gICAgICAgICAgICB2YXIgdjIgPSB2ZXJ0aWNlc1sgeSArIDEgXVsgeCBdO1xyXG4gICAgICAgICAgICB2YXIgdjMgPSB2ZXJ0aWNlc1sgeSArIDEgXVsgeCArIDEgXTtcclxuICAgICAgICAgICAgdmFyIHY0ID0gdmVydGljZXNbIHkgXVsgeCArIDEgXTtcclxuXHJcbiAgICAgICAgICAgIHZhciBuMSA9IG5hLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHZhciBuMiA9IG5hLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHZhciBuMyA9IG5iLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHZhciBuNCA9IG5iLmNsb25lKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdXYxID0gdXZzWyB5IF1bIHggXS5jbG9uZSgpO1xyXG4gICAgICAgICAgICB2YXIgdXYyID0gdXZzWyB5ICsgMSBdWyB4IF0uY2xvbmUoKTtcclxuICAgICAgICAgICAgdmFyIHV2MyA9IHV2c1sgeSArIDEgXVsgeCArIDEgXS5jbG9uZSgpO1xyXG4gICAgICAgICAgICB2YXIgdXY0ID0gdXZzWyB5IF1bIHggKyAxIF0uY2xvbmUoKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHY0LCBbIG4xLCBuMiwgbjQgXSApICk7XHJcbiAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYxLCB1djIsIHV2NCBdICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjIsIHYzLCB2NCwgWyBuMi5jbG9uZSgpLCBuMywgbjQuY2xvbmUoKSBdICkgKTtcclxuICAgICAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1djIuY2xvbmUoKSwgdXYzLCB1djQuY2xvbmUoKSBdICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gdG9wIGNhcFxyXG5cclxuICAgIGlmICggb3BlbkVuZGVkID09PSBmYWxzZSAmJiByYWRpdXNUb3AgPiAwICkge1xyXG5cclxuICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCBoZWlnaHRIYWxmLCAwICkgKTtcclxuXHJcbiAgICAgICAgZm9yICggeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgeCArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciB2MSA9IHZlcnRpY2VzWyAwIF1bIHggXTtcclxuICAgICAgICAgICAgdmFyIHYyID0gdmVydGljZXNbIDAgXVsgeCArIDEgXTtcclxuICAgICAgICAgICAgdmFyIHYzID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAxO1xyXG5cclxuICAgICAgICAgICAgdmFyIG4xID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcclxuICAgICAgICAgICAgdmFyIG4yID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcclxuICAgICAgICAgICAgdmFyIG4zID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB1djEgPSB1dnNbIDAgXVsgeCBdLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHZhciB1djIgPSB1dnNbIDAgXVsgeCArIDEgXS5jbG9uZSgpO1xyXG4gICAgICAgICAgICB2YXIgdXYzID0gbmV3IFRIUkVFLlZlY3RvcjIoIHV2Mi54LCAwICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2MywgWyBuMSwgbjIsIG4zIF0sIHVuZGVmaW5lZCwgMSApICk7XHJcbiAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYxLCB1djIsIHV2MyBdICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gYm90dG9tIGNhcFxyXG5cclxuICAgIGlmICggb3BlbkVuZGVkID09PSBmYWxzZSAmJiByYWRpdXNCb3R0b20gPiAwICkge1xyXG5cclxuICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtIGhlaWdodEhhbGYsIDAgKSApO1xyXG5cclxuICAgICAgICBmb3IgKCB4ID0gMDsgeCA8IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHYxID0gdmVydGljZXNbIGhlaWdodFNlZ21lbnRzIF1bIHggKyAxIF07XHJcbiAgICAgICAgICAgIHZhciB2MiA9IHZlcnRpY2VzWyBoZWlnaHRTZWdtZW50cyBdWyB4IF07XHJcbiAgICAgICAgICAgIHZhciB2MyA9IHRoaXMudmVydGljZXMubGVuZ3RoIC0gMTtcclxuXHJcbiAgICAgICAgICAgIHZhciBuMSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtIDEsIDAgKTtcclxuICAgICAgICAgICAgdmFyIG4yID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0gMSwgMCApO1xyXG4gICAgICAgICAgICB2YXIgbjMgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLSAxLCAwICk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdXYxID0gdXZzWyBoZWlnaHRTZWdtZW50cyBdWyB4ICsgMSBdLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHZhciB1djIgPSB1dnNbIGhlaWdodFNlZ21lbnRzIF1bIHggXS5jbG9uZSgpO1xyXG4gICAgICAgICAgICB2YXIgdXYzID0gbmV3IFRIUkVFLlZlY3RvcjIoIHV2Mi54LCAxICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2MywgWyBuMSwgbjIsIG4zIF0sIHVuZGVmaW5lZCwgMiApICk7XHJcbiAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYxLCB1djIsIHV2MyBdICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DeWxpbmRlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5DeWxpbmRlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkN5bGluZGVyR2VvbWV0cnk7XHJcblxyXG5USFJFRS5DeWxpbmRlckdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcclxuXHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoXHJcbiAgICAgICAgcGFyYW1ldGVycy5yYWRpdXNUb3AsXHJcbiAgICAgICAgcGFyYW1ldGVycy5yYWRpdXNCb3R0b20sXHJcbiAgICAgICAgcGFyYW1ldGVycy5oZWlnaHQsXHJcbiAgICAgICAgcGFyYW1ldGVycy5yYWRpYWxTZWdtZW50cyxcclxuICAgICAgICBwYXJhbWV0ZXJzLmhlaWdodFNlZ21lbnRzLFxyXG4gICAgICAgIHBhcmFtZXRlcnMub3BlbkVuZGVkLFxyXG4gICAgICAgIHBhcmFtZXRlcnMudGhldGFTdGFydCxcclxuICAgICAgICBwYXJhbWV0ZXJzLnRoZXRhTGVuZ3RoXHJcbiAgICApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0VkZ2VzR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICovXHJcblxyXG5USFJFRS5FZGdlc0dlb21ldHJ5ID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgdGhyZXNob2xkQW5nbGUgKSB7XHJcblxyXG4gICAgVEhSRUUuQnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRocmVzaG9sZEFuZ2xlID0gKCB0aHJlc2hvbGRBbmdsZSAhPT0gdW5kZWZpbmVkICkgPyB0aHJlc2hvbGRBbmdsZSA6IDE7XHJcblxyXG4gICAgdmFyIHRocmVzaG9sZERvdCA9IE1hdGguY29zKCBUSFJFRS5NYXRoLmRlZ1RvUmFkKCB0aHJlc2hvbGRBbmdsZSApICk7XHJcblxyXG4gICAgdmFyIGVkZ2UgPSBbIDAsIDAgXSwgaGFzaCA9IHt9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHNvcnRGdW5jdGlvbiggYSwgYiApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIGEgLSBiO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB2YXIga2V5cyA9IFsgJ2EnLCAnYicsICdjJyBdO1xyXG5cclxuICAgIHZhciBnZW9tZXRyeTI7XHJcblxyXG4gICAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xyXG5cclxuICAgICAgICBnZW9tZXRyeTIgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuICAgICAgICBnZW9tZXRyeTIuZnJvbUJ1ZmZlckdlb21ldHJ5KCBnZW9tZXRyeSApO1xyXG5cclxuICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIGdlb21ldHJ5MiA9IGdlb21ldHJ5LmNsb25lKCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGdlb21ldHJ5Mi5tZXJnZVZlcnRpY2VzKCk7XHJcbiAgICBnZW9tZXRyeTIuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcblxyXG4gICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkyLnZlcnRpY2VzO1xyXG4gICAgdmFyIGZhY2VzID0gZ2VvbWV0cnkyLmZhY2VzO1xyXG5cclxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIHZhciBmYWNlID0gZmFjZXNbIGkgXTtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwgMzsgaiArKyApIHtcclxuXHJcbiAgICAgICAgICAgIGVkZ2VbIDAgXSA9IGZhY2VbIGtleXNbIGogXSBdO1xyXG4gICAgICAgICAgICBlZGdlWyAxIF0gPSBmYWNlWyBrZXlzWyAoIGogKyAxICkgJSAzIF0gXTtcclxuICAgICAgICAgICAgZWRnZS5zb3J0KCBzb3J0RnVuY3Rpb24gKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBlZGdlLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGhhc2hbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaGFzaFsga2V5IF0gPSB7IHZlcnQxOiBlZGdlWyAwIF0sIHZlcnQyOiBlZGdlWyAxIF0sIGZhY2UxOiBpLCBmYWNlMjogdW5kZWZpbmVkIH07XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIGhhc2hbIGtleSBdLmZhY2UyID0gaTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICB2YXIgY29vcmRzID0gW107XHJcblxyXG4gICAgZm9yICggdmFyIGtleSBpbiBoYXNoICkge1xyXG5cclxuICAgICAgICB2YXIgaCA9IGhhc2hbIGtleSBdO1xyXG5cclxuICAgICAgICBpZiAoIGguZmFjZTIgPT09IHVuZGVmaW5lZCB8fCBmYWNlc1sgaC5mYWNlMSBdLm5vcm1hbC5kb3QoIGZhY2VzWyBoLmZhY2UyIF0ubm9ybWFsICkgPD0gdGhyZXNob2xkRG90ICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHZlcnRleCA9IHZlcnRpY2VzWyBoLnZlcnQxIF07XHJcbiAgICAgICAgICAgIGNvb3Jkcy5wdXNoKCB2ZXJ0ZXgueCApO1xyXG4gICAgICAgICAgICBjb29yZHMucHVzaCggdmVydGV4LnkgKTtcclxuICAgICAgICAgICAgY29vcmRzLnB1c2goIHZlcnRleC56ICk7XHJcblxyXG4gICAgICAgICAgICB2ZXJ0ZXggPSB2ZXJ0aWNlc1sgaC52ZXJ0MiBdO1xyXG4gICAgICAgICAgICBjb29yZHMucHVzaCggdmVydGV4LnggKTtcclxuICAgICAgICAgICAgY29vcmRzLnB1c2goIHZlcnRleC55ICk7XHJcbiAgICAgICAgICAgIGNvb3Jkcy5wdXNoKCB2ZXJ0ZXgueiApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCBjb29yZHMgKSwgMyApICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRWRnZXNHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuRWRnZXNHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5FZGdlc0dlb21ldHJ5O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvRXh0cnVkZUdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKlxyXG4gKiBDcmVhdGVzIGV4dHJ1ZGVkIGdlb21ldHJ5IGZyb20gYSBwYXRoIHNoYXBlLlxyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKlxyXG4gKiAgY3VydmVTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBwb2ludHMgb24gdGhlIGN1cnZlc1xyXG4gKiAgc3RlcHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIGZvciB6LXNpZGUgZXh0cnVzaW9ucyAvIHVzZWQgZm9yIHN1YmRpdmlkaW5nIHNlZ21lbnRzIG9mIGV4dHJ1ZGUgc3BsaW5lIHRvb1xyXG4gKiAgYW1vdW50OiA8aW50PiwgLy8gRGVwdGggdG8gZXh0cnVkZSB0aGUgc2hhcGVcclxuICpcclxuICogIGJldmVsRW5hYmxlZDogPGJvb2w+LCAvLyB0dXJuIG9uIGJldmVsXHJcbiAqICBiZXZlbFRoaWNrbmVzczogPGZsb2F0PiwgLy8gaG93IGRlZXAgaW50byB0aGUgb3JpZ2luYWwgc2hhcGUgYmV2ZWwgZ29lc1xyXG4gKiAgYmV2ZWxTaXplOiA8ZmxvYXQ+LCAvLyBob3cgZmFyIGZyb20gc2hhcGUgb3V0bGluZSBpcyBiZXZlbFxyXG4gKiAgYmV2ZWxTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBiZXZlbCBsYXllcnNcclxuICpcclxuICogIGV4dHJ1ZGVQYXRoOiA8VEhSRUUuQ3VydmVQYXRoPiAvLyAzZCBzcGxpbmUgcGF0aCB0byBleHRydWRlIHNoYXBlIGFsb25nLiAoY3JlYXRlcyBGcmFtZXMgaWYgLmZyYW1lcyBhcmVuJ3QgZGVmaW5lZClcclxuICogIGZyYW1lczogPFRIUkVFLlR1YmVHZW9tZXRyeS5GcmVuZXRGcmFtZXM+IC8vIGNvbnRhaW5pbmcgYXJyYXlzIG9mIHRhbmdlbnRzLCBub3JtYWxzLCBiaW5vcm1hbHNcclxuICpcclxuICogIHV2R2VuZXJhdG9yOiA8T2JqZWN0PiAvLyBvYmplY3QgdGhhdCBwcm92aWRlcyBVViBnZW5lcmF0b3IgZnVuY3Rpb25zXHJcbiAqXHJcbiAqIH1cclxuICoqL1xyXG5cclxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCBzaGFwZXMsIG9wdGlvbnMgKSB7XHJcblxyXG4gICAgaWYgKCB0eXBlb2YoIHNoYXBlcyApID09PSBcInVuZGVmaW5lZFwiICkge1xyXG5cclxuICAgICAgICBzaGFwZXMgPSBbXTtcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgfVxyXG5cclxuICAgIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnRXh0cnVkZUdlb21ldHJ5JztcclxuXHJcbiAgICBzaGFwZXMgPSBBcnJheS5pc0FycmF5KCBzaGFwZXMgKSA/IHNoYXBlcyA6IFsgc2hhcGVzIF07XHJcblxyXG4gICAgdGhpcy5hZGRTaGFwZUxpc3QoIHNoYXBlcywgb3B0aW9ucyApO1xyXG5cclxuICAgIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcblxyXG4gICAgLy8gY2FuJ3QgcmVhbGx5IHVzZSBhdXRvbWF0aWMgdmVydGV4IG5vcm1hbHNcclxuICAgIC8vIGFzIHRoZW4gZnJvbnQgYW5kIGJhY2sgc2lkZXMgZ2V0IHNtb290aGVkIHRvb1xyXG4gICAgLy8gc2hvdWxkIGRvIHNlcGFyYXRlIHNtb290aGluZyBqdXN0IGZvciBzaWRlc1xyXG5cclxuICAgIC8vdGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xyXG5cclxuICAgIC8vY29uc29sZS5sb2coIFwidG9va1wiLCAoIERhdGUubm93KCkgLSBzdGFydFRpbWUgKSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeTtcclxuXHJcblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGVMaXN0ID0gZnVuY3Rpb24gKCBzaGFwZXMsIG9wdGlvbnMgKSB7XHJcblxyXG4gICAgdmFyIHNsID0gc2hhcGVzLmxlbmd0aDtcclxuXHJcbiAgICBmb3IgKCB2YXIgcyA9IDA7IHMgPCBzbDsgcyArKyApIHtcclxuXHJcbiAgICAgICAgdmFyIHNoYXBlID0gc2hhcGVzWyBzIF07XHJcbiAgICAgICAgdGhpcy5hZGRTaGFwZSggc2hhcGUsIG9wdGlvbnMgKTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uICggc2hhcGUsIG9wdGlvbnMgKSB7XHJcblxyXG4gICAgdmFyIGFtb3VudCA9IG9wdGlvbnMuYW1vdW50ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFtb3VudCA6IDEwMDtcclxuXHJcbiAgICB2YXIgYmV2ZWxUaGlja25lc3MgPSBvcHRpb25zLmJldmVsVGhpY2tuZXNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsVGhpY2tuZXNzIDogNjsgLy8gMTBcclxuICAgIHZhciBiZXZlbFNpemUgPSBvcHRpb25zLmJldmVsU2l6ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFNpemUgOiBiZXZlbFRoaWNrbmVzcyAtIDI7IC8vIDhcclxuICAgIHZhciBiZXZlbFNlZ21lbnRzID0gb3B0aW9ucy5iZXZlbFNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsU2VnbWVudHMgOiAzO1xyXG5cclxuICAgIHZhciBiZXZlbEVuYWJsZWQgPSBvcHRpb25zLmJldmVsRW5hYmxlZCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbEVuYWJsZWQgOiB0cnVlOyAvLyBmYWxzZVxyXG5cclxuICAgIHZhciBjdXJ2ZVNlZ21lbnRzID0gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmN1cnZlU2VnbWVudHMgOiAxMjtcclxuXHJcbiAgICB2YXIgc3RlcHMgPSBvcHRpb25zLnN0ZXBzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0ZXBzIDogMTtcclxuXHJcbiAgICB2YXIgZXh0cnVkZVBhdGggPSBvcHRpb25zLmV4dHJ1ZGVQYXRoO1xyXG4gICAgdmFyIGV4dHJ1ZGVQdHMsIGV4dHJ1ZGVCeVBhdGggPSBmYWxzZTtcclxuXHJcbiAgICAvLyBVc2UgZGVmYXVsdCBXb3JsZFVWR2VuZXJhdG9yIGlmIG5vIFVWIGdlbmVyYXRvcnMgYXJlIHNwZWNpZmllZC5cclxuICAgIHZhciB1dmdlbiA9IG9wdGlvbnMuVVZHZW5lcmF0b3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuVVZHZW5lcmF0b3IgOiBUSFJFRS5FeHRydWRlR2VvbWV0cnkuV29ybGRVVkdlbmVyYXRvcjtcclxuXHJcbiAgICB2YXIgc3BsaW5lVHViZSwgYmlub3JtYWwsIG5vcm1hbCwgcG9zaXRpb24yO1xyXG4gICAgaWYgKCBleHRydWRlUGF0aCApIHtcclxuXHJcbiAgICAgICAgZXh0cnVkZVB0cyA9IGV4dHJ1ZGVQYXRoLmdldFNwYWNlZFBvaW50cyggc3RlcHMgKTtcclxuXHJcbiAgICAgICAgZXh0cnVkZUJ5UGF0aCA9IHRydWU7XHJcbiAgICAgICAgYmV2ZWxFbmFibGVkID0gZmFsc2U7IC8vIGJldmVscyBub3Qgc3VwcG9ydGVkIGZvciBwYXRoIGV4dHJ1c2lvblxyXG5cclxuICAgICAgICAvLyBTRVRVUCBUTkIgdmFyaWFibGVzXHJcblxyXG4gICAgICAgIC8vIFJldXNlIFROQiBmcm9tIFR1YmVHZW9tdHJ5IGZvciBub3cuXHJcbiAgICAgICAgLy8gVE9ETzEgLSBoYXZlIGEgLmlzQ2xvc2VkIGluIHNwbGluZT9cclxuXHJcbiAgICAgICAgc3BsaW5lVHViZSA9IG9wdGlvbnMuZnJhbWVzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZyYW1lcyA6IG5ldyBUSFJFRS5UdWJlR2VvbWV0cnkuRnJlbmV0RnJhbWVzKCBleHRydWRlUGF0aCwgc3RlcHMsIGZhbHNlICk7XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHNwbGluZVR1YmUsICdzcGxpbmVUdWJlJywgc3BsaW5lVHViZS5ub3JtYWxzLmxlbmd0aCwgJ3N0ZXBzJywgc3RlcHMsICdleHRydWRlUHRzJywgZXh0cnVkZVB0cy5sZW5ndGgpO1xyXG5cclxuICAgICAgICBiaW5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICBwb3NpdGlvbjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBTYWZlZ3VhcmRzIGlmIGJldmVscyBhcmUgbm90IGVuYWJsZWRcclxuXHJcbiAgICBpZiAoICEgYmV2ZWxFbmFibGVkICkge1xyXG5cclxuICAgICAgICBiZXZlbFNlZ21lbnRzID0gMDtcclxuICAgICAgICBiZXZlbFRoaWNrbmVzcyA9IDA7XHJcbiAgICAgICAgYmV2ZWxTaXplID0gMDtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gVmFyaWFibGVzIGluaXRpYWxpemF0aW9uXHJcblxyXG4gICAgdmFyIGFob2xlLCBoLCBobDsgLy8gbG9vcGluZyBvZiBob2xlc1xyXG4gICAgdmFyIHNjb3BlID0gdGhpcztcclxuXHJcbiAgICB2YXIgc2hhcGVzT2Zmc2V0ID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XHJcblxyXG4gICAgdmFyIHNoYXBlUG9pbnRzID0gc2hhcGUuZXh0cmFjdFBvaW50cyggY3VydmVTZWdtZW50cyApO1xyXG5cclxuICAgIHZhciB2ZXJ0aWNlcyA9IHNoYXBlUG9pbnRzLnNoYXBlO1xyXG4gICAgdmFyIGhvbGVzID0gc2hhcGVQb2ludHMuaG9sZXM7XHJcblxyXG4gICAgdmFyIHJldmVyc2UgPSAhIFRIUkVFLlNoYXBlVXRpbHMuaXNDbG9ja1dpc2UoIHZlcnRpY2VzICk7XHJcblxyXG4gICAgaWYgKCByZXZlcnNlICkge1xyXG5cclxuICAgICAgICB2ZXJ0aWNlcyA9IHZlcnRpY2VzLnJldmVyc2UoKTtcclxuXHJcbiAgICAgICAgLy8gTWF5YmUgd2Ugc2hvdWxkIGFsc28gY2hlY2sgaWYgaG9sZXMgYXJlIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24sIGp1c3QgdG8gYmUgc2FmZSAuLi5cclxuXHJcbiAgICAgICAgZm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XHJcblxyXG4gICAgICAgICAgICBhaG9sZSA9IGhvbGVzWyBoIF07XHJcblxyXG4gICAgICAgICAgICBpZiAoIFRIUkVFLlNoYXBlVXRpbHMuaXNDbG9ja1dpc2UoIGFob2xlICkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaG9sZXNbIGggXSA9IGFob2xlLnJldmVyc2UoKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXZlcnNlID0gZmFsc2U7IC8vIElmIHZlcnRpY2VzIGFyZSBpbiBvcmRlciBub3csIHdlIHNob3VsZG4ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoZW0gYWdhaW4gKGhvcGVmdWxseSkhXHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICB2YXIgZmFjZXMgPSBUSFJFRS5TaGFwZVV0aWxzLnRyaWFuZ3VsYXRlU2hhcGUoIHZlcnRpY2VzLCBob2xlcyApO1xyXG5cclxuICAgIC8qIFZlcnRpY2VzICovXHJcblxyXG4gICAgdmFyIGNvbnRvdXIgPSB2ZXJ0aWNlczsgLy8gdmVydGljZXMgaGFzIGFsbCBwb2ludHMgYnV0IGNvbnRvdXIgaGFzIG9ubHkgcG9pbnRzIG9mIGNpcmN1bWZlcmVuY2VcclxuXHJcbiAgICBmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcclxuXHJcbiAgICAgICAgYWhvbGUgPSBob2xlc1sgaCBdO1xyXG5cclxuICAgICAgICB2ZXJ0aWNlcyA9IHZlcnRpY2VzLmNvbmNhdCggYWhvbGUgKTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIHNjYWxlUHQyICggcHQsIHZlYywgc2l6ZSApIHtcclxuXHJcbiAgICAgICAgaWYgKCAhIHZlYyApIGNvbnNvbGUuZXJyb3IoIFwiVEhSRUUuRXh0cnVkZUdlb21ldHJ5OiB2ZWMgZG9lcyBub3QgZXhpc3RcIiApO1xyXG5cclxuICAgICAgICByZXR1cm4gdmVjLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoIHNpemUgKS5hZGQoIHB0ICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHZhciBiLCBicywgdCwgeixcclxuICAgICAgICB2ZXJ0LCB2bGVuID0gdmVydGljZXMubGVuZ3RoLFxyXG4gICAgICAgIGZhY2UsIGZsZW4gPSBmYWNlcy5sZW5ndGg7XHJcblxyXG5cclxuICAgIC8vIEZpbmQgZGlyZWN0aW9ucyBmb3IgcG9pbnQgbW92ZW1lbnRcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0QmV2ZWxWZWMoIGluUHQsIGluUHJldiwgaW5OZXh0ICkge1xyXG5cclxuICAgICAgICAvLyBjb21wdXRlcyBmb3IgaW5QdCB0aGUgY29ycmVzcG9uZGluZyBwb2ludCBpblB0JyBvbiBhIG5ldyBjb250b3VyXHJcbiAgICAgICAgLy8gICBzaGlmdGVkIGJ5IDEgdW5pdCAobGVuZ3RoIG9mIG5vcm1hbGl6ZWQgdmVjdG9yKSB0byB0aGUgbGVmdFxyXG4gICAgICAgIC8vIGlmIHdlIHdhbGsgYWxvbmcgY29udG91ciBjbG9ja3dpc2UsIHRoaXMgbmV3IGNvbnRvdXIgaXMgb3V0c2lkZSB0aGUgb2xkIG9uZVxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gaW5QdCcgaXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIGxpbmVzIHBhcmFsbGVsIHRvIHRoZSB0d29cclxuICAgICAgICAvLyAgYWRqYWNlbnQgZWRnZXMgb2YgaW5QdCBhdCBhIGRpc3RhbmNlIG9mIDEgdW5pdCBvbiB0aGUgbGVmdCBzaWRlLlxyXG5cclxuICAgICAgICB2YXIgdl90cmFuc194LCB2X3RyYW5zX3ksIHNocmlua19ieSA9IDE7XHRcdC8vIHJlc3VsdGluZyB0cmFuc2xhdGlvbiB2ZWN0b3IgZm9yIGluUHRcclxuXHJcbiAgICAgICAgLy8gZ29vZCByZWFkaW5nIGZvciBnZW9tZXRyeSBhbGdvcml0aG1zIChoZXJlOiBsaW5lLWxpbmUgaW50ZXJzZWN0aW9uKVxyXG4gICAgICAgIC8vIGh0dHA6Ly9nZW9tYWxnb3JpdGhtcy5jb20vYTA1LV9pbnRlcnNlY3QtMS5odG1sXHJcblxyXG4gICAgICAgIHZhciB2X3ByZXZfeCA9IGluUHQueCAtIGluUHJldi54LCB2X3ByZXZfeSA9IGluUHQueSAtIGluUHJldi55O1xyXG4gICAgICAgIHZhciB2X25leHRfeCA9IGluTmV4dC54IC0gaW5QdC54LCB2X25leHRfeSA9IGluTmV4dC55IC0gaW5QdC55O1xyXG5cclxuICAgICAgICB2YXIgdl9wcmV2X2xlbnNxID0gKCB2X3ByZXZfeCAqIHZfcHJldl94ICsgdl9wcmV2X3kgKiB2X3ByZXZfeSApO1xyXG5cclxuICAgICAgICAvLyBjaGVjayBmb3IgY29sbGluZWFyIGVkZ2VzXHJcbiAgICAgICAgdmFyIGNvbGxpbmVhcjAgPSAoIHZfcHJldl94ICogdl9uZXh0X3kgLSB2X3ByZXZfeSAqIHZfbmV4dF94ICk7XHJcblxyXG4gICAgICAgIGlmICggTWF0aC5hYnMoIGNvbGxpbmVhcjAgKSA+IE51bWJlci5FUFNJTE9OICkge1xyXG5cclxuICAgICAgICAgICAgLy8gbm90IGNvbGxpbmVhclxyXG5cclxuICAgICAgICAgICAgLy8gbGVuZ3RoIG9mIHZlY3RvcnMgZm9yIG5vcm1hbGl6aW5nXHJcblxyXG4gICAgICAgICAgICB2YXIgdl9wcmV2X2xlbiA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxICk7XHJcbiAgICAgICAgICAgIHZhciB2X25leHRfbGVuID0gTWF0aC5zcXJ0KCB2X25leHRfeCAqIHZfbmV4dF94ICsgdl9uZXh0X3kgKiB2X25leHRfeSApO1xyXG5cclxuICAgICAgICAgICAgLy8gc2hpZnQgYWRqYWNlbnQgcG9pbnRzIGJ5IHVuaXQgdmVjdG9ycyB0byB0aGUgbGVmdFxyXG5cclxuICAgICAgICAgICAgdmFyIHB0UHJldlNoaWZ0X3ggPSAoIGluUHJldi54IC0gdl9wcmV2X3kgLyB2X3ByZXZfbGVuICk7XHJcbiAgICAgICAgICAgIHZhciBwdFByZXZTaGlmdF95ID0gKCBpblByZXYueSArIHZfcHJldl94IC8gdl9wcmV2X2xlbiApO1xyXG5cclxuICAgICAgICAgICAgdmFyIHB0TmV4dFNoaWZ0X3ggPSAoIGluTmV4dC54IC0gdl9uZXh0X3kgLyB2X25leHRfbGVuICk7XHJcbiAgICAgICAgICAgIHZhciBwdE5leHRTaGlmdF95ID0gKCBpbk5leHQueSArIHZfbmV4dF94IC8gdl9uZXh0X2xlbiApO1xyXG5cclxuICAgICAgICAgICAgLy8gc2NhbGluZyBmYWN0b3IgZm9yIHZfcHJldiB0byBpbnRlcnNlY3Rpb24gcG9pbnRcclxuXHJcbiAgICAgICAgICAgIHZhciBzZiA9ICggICggcHROZXh0U2hpZnRfeCAtIHB0UHJldlNoaWZ0X3ggKSAqIHZfbmV4dF95IC1cclxuICAgICAgICAgICAgICAgICggcHROZXh0U2hpZnRfeSAtIHB0UHJldlNoaWZ0X3kgKSAqIHZfbmV4dF94ICAgICkgL1xyXG4gICAgICAgICAgICAgICAgKCB2X3ByZXZfeCAqIHZfbmV4dF95IC0gdl9wcmV2X3kgKiB2X25leHRfeCApO1xyXG5cclxuICAgICAgICAgICAgLy8gdmVjdG9yIGZyb20gaW5QdCB0byBpbnRlcnNlY3Rpb24gcG9pbnRcclxuXHJcbiAgICAgICAgICAgIHZfdHJhbnNfeCA9ICggcHRQcmV2U2hpZnRfeCArIHZfcHJldl94ICogc2YgLSBpblB0LnggKTtcclxuICAgICAgICAgICAgdl90cmFuc195ID0gKCBwdFByZXZTaGlmdF95ICsgdl9wcmV2X3kgKiBzZiAtIGluUHQueSApO1xyXG5cclxuICAgICAgICAgICAgLy8gRG9uJ3Qgbm9ybWFsaXplISwgb3RoZXJ3aXNlIHNoYXJwIGNvcm5lcnMgYmVjb21lIHVnbHlcclxuICAgICAgICAgICAgLy8gIGJ1dCBwcmV2ZW50IGNyYXp5IHNwaWtlc1xyXG4gICAgICAgICAgICB2YXIgdl90cmFuc19sZW5zcSA9ICggdl90cmFuc194ICogdl90cmFuc194ICsgdl90cmFuc195ICogdl90cmFuc195ICk7XHJcbiAgICAgICAgICAgIGlmICggdl90cmFuc19sZW5zcSA8PSAyICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVyblx0bmV3IFRIUkVFLlZlY3RvcjIoIHZfdHJhbnNfeCwgdl90cmFuc195ICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIHNocmlua19ieSA9IE1hdGguc3FydCggdl90cmFuc19sZW5zcSAvIDIgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGhhbmRsZSBzcGVjaWFsIGNhc2Ugb2YgY29sbGluZWFyIGVkZ2VzXHJcblxyXG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uX2VxID0gZmFsc2U7XHRcdC8vIGFzc3VtZXM6IG9wcG9zaXRlXHJcbiAgICAgICAgICAgIGlmICggdl9wcmV2X3ggPiBOdW1iZXIuRVBTSUxPTiApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHZfbmV4dF94ID4gTnVtYmVyLkVQU0lMT04gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbl9lcSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHZfcHJldl94IDwgLSBOdW1iZXIuRVBTSUxPTiApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB2X25leHRfeCA8IC0gTnVtYmVyLkVQU0lMT04gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb25fZXEgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBNYXRoLnNpZ24oIHZfcHJldl95ICkgPT09IE1hdGguc2lnbiggdl9uZXh0X3kgKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbl9lcSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIGRpcmVjdGlvbl9lcSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIldhcm5pbmc6IGxpbmVzIGFyZSBhIHN0cmFpZ2h0IHNlcXVlbmNlXCIpO1xyXG4gICAgICAgICAgICAgICAgdl90cmFuc194ID0gLSB2X3ByZXZfeTtcclxuICAgICAgICAgICAgICAgIHZfdHJhbnNfeSA9ICB2X3ByZXZfeDtcclxuICAgICAgICAgICAgICAgIHNocmlua19ieSA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiV2FybmluZzogbGluZXMgYXJlIGEgc3RyYWlnaHQgc3Bpa2VcIik7XHJcbiAgICAgICAgICAgICAgICB2X3RyYW5zX3ggPSB2X3ByZXZfeDtcclxuICAgICAgICAgICAgICAgIHZfdHJhbnNfeSA9IHZfcHJldl95O1xyXG4gICAgICAgICAgICAgICAgc2hyaW5rX2J5ID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgLyAyICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuXHRuZXcgVEhSRUUuVmVjdG9yMiggdl90cmFuc194IC8gc2hyaW5rX2J5LCB2X3RyYW5zX3kgLyBzaHJpbmtfYnkgKTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIHZhciBjb250b3VyTW92ZW1lbnRzID0gW107XHJcblxyXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoLCBqID0gaWwgLSAxLCBrID0gaSArIDE7IGkgPCBpbDsgaSArKywgaiArKywgayArKyApIHtcclxuXHJcbiAgICAgICAgaWYgKCBqID09PSBpbCApIGogPSAwO1xyXG4gICAgICAgIGlmICggayA9PT0gaWwgKSBrID0gMDtcclxuXHJcbiAgICAgICAgLy8gIChqKS0tLShpKS0tLShrKVxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdpLGosaycsIGksIGogLCBrKVxyXG5cclxuICAgICAgICBjb250b3VyTW92ZW1lbnRzWyBpIF0gPSBnZXRCZXZlbFZlYyggY29udG91clsgaSBdLCBjb250b3VyWyBqIF0sIGNvbnRvdXJbIGsgXSApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB2YXIgaG9sZXNNb3ZlbWVudHMgPSBbXSwgb25lSG9sZU1vdmVtZW50cywgdmVydGljZXNNb3ZlbWVudHMgPSBjb250b3VyTW92ZW1lbnRzLmNvbmNhdCgpO1xyXG5cclxuICAgIGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xyXG5cclxuICAgICAgICBhaG9sZSA9IGhvbGVzWyBoIF07XHJcblxyXG4gICAgICAgIG9uZUhvbGVNb3ZlbWVudHMgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICggaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoLCBqID0gaWwgLSAxLCBrID0gaSArIDE7IGkgPCBpbDsgaSArKywgaiArKywgayArKyApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggaiA9PT0gaWwgKSBqID0gMDtcclxuICAgICAgICAgICAgaWYgKCBrID09PSBpbCApIGsgPSAwO1xyXG5cclxuICAgICAgICAgICAgLy8gIChqKS0tLShpKS0tLShrKVxyXG4gICAgICAgICAgICBvbmVIb2xlTW92ZW1lbnRzWyBpIF0gPSBnZXRCZXZlbFZlYyggYWhvbGVbIGkgXSwgYWhvbGVbIGogXSwgYWhvbGVbIGsgXSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGhvbGVzTW92ZW1lbnRzLnB1c2goIG9uZUhvbGVNb3ZlbWVudHMgKTtcclxuICAgICAgICB2ZXJ0aWNlc01vdmVtZW50cyA9IHZlcnRpY2VzTW92ZW1lbnRzLmNvbmNhdCggb25lSG9sZU1vdmVtZW50cyApO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gTG9vcCBiZXZlbFNlZ21lbnRzLCAxIGZvciB0aGUgZnJvbnQsIDEgZm9yIHRoZSBiYWNrXHJcblxyXG4gICAgZm9yICggYiA9IDA7IGIgPCBiZXZlbFNlZ21lbnRzOyBiICsrICkge1xyXG5cclxuICAgICAgICAvL2ZvciAoIGIgPSBiZXZlbFNlZ21lbnRzOyBiID4gMDsgYiAtLSApIHtcclxuXHJcbiAgICAgICAgdCA9IGIgLyBiZXZlbFNlZ21lbnRzO1xyXG4gICAgICAgIHogPSBiZXZlbFRoaWNrbmVzcyAqICggMSAtIHQgKTtcclxuXHJcbiAgICAgICAgLy96ID0gYmV2ZWxUaGlja25lc3MgKiB0O1xyXG4gICAgICAgIGJzID0gYmV2ZWxTaXplICogKCBNYXRoLnNpbiAoIHQgKiBNYXRoLlBJIC8gMiApICk7IC8vIGN1cnZlZFxyXG4gICAgICAgIC8vYnMgPSBiZXZlbFNpemUgKiB0OyAvLyBsaW5lYXJcclxuXHJcbiAgICAgICAgLy8gY29udHJhY3Qgc2hhcGVcclxuXHJcbiAgICAgICAgZm9yICggaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZlcnQgPSBzY2FsZVB0MiggY29udG91clsgaSBdLCBjb250b3VyTW92ZW1lbnRzWyBpIF0sIGJzICk7XHJcblxyXG4gICAgICAgICAgICB2KCB2ZXJ0LngsIHZlcnQueSwgIC0geiApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGV4cGFuZCBob2xlc1xyXG5cclxuICAgICAgICBmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcclxuXHJcbiAgICAgICAgICAgIGFob2xlID0gaG9sZXNbIGggXTtcclxuICAgICAgICAgICAgb25lSG9sZU1vdmVtZW50cyA9IGhvbGVzTW92ZW1lbnRzWyBoIF07XHJcblxyXG4gICAgICAgICAgICBmb3IgKCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ID0gc2NhbGVQdDIoIGFob2xlWyBpIF0sIG9uZUhvbGVNb3ZlbWVudHNbIGkgXSwgYnMgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2KCB2ZXJ0LngsIHZlcnQueSwgIC0geiApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGJzID0gYmV2ZWxTaXplO1xyXG5cclxuICAgIC8vIEJhY2sgZmFjaW5nIHZlcnRpY2VzXHJcblxyXG4gICAgZm9yICggaSA9IDA7IGkgPCB2bGVuOyBpICsrICkge1xyXG5cclxuICAgICAgICB2ZXJ0ID0gYmV2ZWxFbmFibGVkID8gc2NhbGVQdDIoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzTW92ZW1lbnRzWyBpIF0sIGJzICkgOiB2ZXJ0aWNlc1sgaSBdO1xyXG5cclxuICAgICAgICBpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcclxuXHJcbiAgICAgICAgICAgIHYoIHZlcnQueCwgdmVydC55LCAwICk7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAvLyB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIDAgXS55LCBleHRydWRlUHRzWyAwIF0ueCApO1xyXG5cclxuICAgICAgICAgICAgbm9ybWFsLmNvcHkoIHNwbGluZVR1YmUubm9ybWFsc1sgMCBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueCApO1xyXG4gICAgICAgICAgICBiaW5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLmJpbm9ybWFsc1sgMCBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueSApO1xyXG5cclxuICAgICAgICAgICAgcG9zaXRpb24yLmNvcHkoIGV4dHJ1ZGVQdHNbIDAgXSApLmFkZCggbm9ybWFsICkuYWRkKCBiaW5vcm1hbCApO1xyXG5cclxuICAgICAgICAgICAgdiggcG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueiApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZCBzdGVwcGVkIHZlcnRpY2VzLi4uXHJcbiAgICAvLyBJbmNsdWRpbmcgZnJvbnQgZmFjaW5nIHZlcnRpY2VzXHJcblxyXG4gICAgdmFyIHM7XHJcblxyXG4gICAgZm9yICggcyA9IDE7IHMgPD0gc3RlcHM7IHMgKysgKSB7XHJcblxyXG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZlcnQgPSBiZXZlbEVuYWJsZWQgPyBzY2FsZVB0MiggdmVydGljZXNbIGkgXSwgdmVydGljZXNNb3ZlbWVudHNbIGkgXSwgYnMgKSA6IHZlcnRpY2VzWyBpIF07XHJcblxyXG4gICAgICAgICAgICBpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2KCB2ZXJ0LngsIHZlcnQueSwgYW1vdW50IC8gc3RlcHMgKiBzICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHYoIHZlcnQueCwgdmVydC55ICsgZXh0cnVkZVB0c1sgcyAtIDEgXS55LCBleHRydWRlUHRzWyBzIC0gMSBdLnggKTtcclxuXHJcbiAgICAgICAgICAgICAgICBub3JtYWwuY29weSggc3BsaW5lVHViZS5ub3JtYWxzWyBzIF0gKS5tdWx0aXBseVNjYWxhciggdmVydC54ICk7XHJcbiAgICAgICAgICAgICAgICBiaW5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLmJpbm9ybWFsc1sgcyBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueSApO1xyXG5cclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uMi5jb3B5KCBleHRydWRlUHRzWyBzIF0gKS5hZGQoIG5vcm1hbCApLmFkZCggYmlub3JtYWwgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2KCBwb3NpdGlvbjIueCwgcG9zaXRpb24yLnksIHBvc2l0aW9uMi56ICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIEFkZCBiZXZlbCBzZWdtZW50cyBwbGFuZXNcclxuXHJcbiAgICAvL2ZvciAoIGIgPSAxOyBiIDw9IGJldmVsU2VnbWVudHM7IGIgKysgKSB7XHJcbiAgICBmb3IgKCBiID0gYmV2ZWxTZWdtZW50cyAtIDE7IGIgPj0gMDsgYiAtLSApIHtcclxuXHJcbiAgICAgICAgdCA9IGIgLyBiZXZlbFNlZ21lbnRzO1xyXG4gICAgICAgIHogPSBiZXZlbFRoaWNrbmVzcyAqICggMSAtIHQgKTtcclxuICAgICAgICAvL2JzID0gYmV2ZWxTaXplICogKCAxLU1hdGguc2luICggKCAxIC0gdCApICogTWF0aC5QSS8yICkgKTtcclxuICAgICAgICBicyA9IGJldmVsU2l6ZSAqIE1hdGguc2luICggdCAqIE1hdGguUEkgLyAyICk7XHJcblxyXG4gICAgICAgIC8vIGNvbnRyYWN0IHNoYXBlXHJcblxyXG4gICAgICAgIGZvciAoIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2ZXJ0ID0gc2NhbGVQdDIoIGNvbnRvdXJbIGkgXSwgY29udG91ck1vdmVtZW50c1sgaSBdLCBicyApO1xyXG4gICAgICAgICAgICB2KCB2ZXJ0LngsIHZlcnQueSwgIGFtb3VudCArIHogKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBleHBhbmQgaG9sZXNcclxuXHJcbiAgICAgICAgZm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XHJcblxyXG4gICAgICAgICAgICBhaG9sZSA9IGhvbGVzWyBoIF07XHJcbiAgICAgICAgICAgIG9uZUhvbGVNb3ZlbWVudHMgPSBob2xlc01vdmVtZW50c1sgaCBdO1xyXG5cclxuICAgICAgICAgICAgZm9yICggaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmVydCA9IHNjYWxlUHQyKCBhaG9sZVsgaSBdLCBvbmVIb2xlTW92ZW1lbnRzWyBpIF0sIGJzICk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCAhIGV4dHJ1ZGVCeVBhdGggKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHYoIHZlcnQueCwgdmVydC55LCAgYW1vdW50ICsgeiApO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHYoIHZlcnQueCwgdmVydC55ICsgZXh0cnVkZVB0c1sgc3RlcHMgLSAxIF0ueSwgZXh0cnVkZVB0c1sgc3RlcHMgLSAxIF0ueCArIHogKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyogRmFjZXMgKi9cclxuXHJcbiAgICAvLyBUb3AgYW5kIGJvdHRvbSBmYWNlc1xyXG5cclxuICAgIGJ1aWxkTGlkRmFjZXMoKTtcclxuXHJcbiAgICAvLyBTaWRlcyBmYWNlc1xyXG5cclxuICAgIGJ1aWxkU2lkZUZhY2VzKCk7XHJcblxyXG5cclxuICAgIC8vLy8vICBJbnRlcm5hbCBmdW5jdGlvbnNcclxuXHJcbiAgICBmdW5jdGlvbiBidWlsZExpZEZhY2VzKCkge1xyXG5cclxuICAgICAgICBpZiAoIGJldmVsRW5hYmxlZCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBsYXllciA9IDA7IC8vIHN0ZXBzICsgMVxyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdmxlbiAqIGxheWVyO1xyXG5cclxuICAgICAgICAgICAgLy8gQm90dG9tIGZhY2VzXHJcblxyXG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZmFjZSA9IGZhY2VzWyBpIF07XHJcbiAgICAgICAgICAgICAgICBmMyggZmFjZVsgMiBdICsgb2Zmc2V0LCBmYWNlWyAxIF0gKyBvZmZzZXQsIGZhY2VbIDAgXSArIG9mZnNldCApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGF5ZXIgPSBzdGVwcyArIGJldmVsU2VnbWVudHMgKiAyO1xyXG4gICAgICAgICAgICBvZmZzZXQgPSB2bGVuICogbGF5ZXI7XHJcblxyXG4gICAgICAgICAgICAvLyBUb3AgZmFjZXNcclxuXHJcbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBmYWNlID0gZmFjZXNbIGkgXTtcclxuICAgICAgICAgICAgICAgIGYzKCBmYWNlWyAwIF0gKyBvZmZzZXQsIGZhY2VbIDEgXSArIG9mZnNldCwgZmFjZVsgMiBdICsgb2Zmc2V0ICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAvLyBCb3R0b20gZmFjZXNcclxuXHJcbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBmYWNlID0gZmFjZXNbIGkgXTtcclxuICAgICAgICAgICAgICAgIGYzKCBmYWNlWyAyIF0sIGZhY2VbIDEgXSwgZmFjZVsgMCBdICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBUb3AgZmFjZXNcclxuXHJcbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBmYWNlID0gZmFjZXNbIGkgXTtcclxuICAgICAgICAgICAgICAgIGYzKCBmYWNlWyAwIF0gKyB2bGVuICogc3RlcHMsIGZhY2VbIDEgXSArIHZsZW4gKiBzdGVwcywgZmFjZVsgMiBdICsgdmxlbiAqIHN0ZXBzICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ3JlYXRlIGZhY2VzIGZvciB0aGUgei1zaWRlcyBvZiB0aGUgc2hhcGVcclxuXHJcbiAgICBmdW5jdGlvbiBidWlsZFNpZGVGYWNlcygpIHtcclxuXHJcbiAgICAgICAgdmFyIGxheWVyb2Zmc2V0ID0gMDtcclxuICAgICAgICBzaWRld2FsbHMoIGNvbnRvdXIsIGxheWVyb2Zmc2V0ICk7XHJcbiAgICAgICAgbGF5ZXJvZmZzZXQgKz0gY29udG91ci5sZW5ndGg7XHJcblxyXG4gICAgICAgIGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xyXG5cclxuICAgICAgICAgICAgYWhvbGUgPSBob2xlc1sgaCBdO1xyXG4gICAgICAgICAgICBzaWRld2FsbHMoIGFob2xlLCBsYXllcm9mZnNldCApO1xyXG5cclxuICAgICAgICAgICAgLy8sIHRydWVcclxuICAgICAgICAgICAgbGF5ZXJvZmZzZXQgKz0gYWhvbGUubGVuZ3RoO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNpZGV3YWxscyggY29udG91ciwgbGF5ZXJvZmZzZXQgKSB7XHJcblxyXG4gICAgICAgIHZhciBqLCBrO1xyXG4gICAgICAgIGkgPSBjb250b3VyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgd2hpbGUgKCAtLSBpID49IDAgKSB7XHJcblxyXG4gICAgICAgICAgICBqID0gaTtcclxuICAgICAgICAgICAgayA9IGkgLSAxO1xyXG4gICAgICAgICAgICBpZiAoIGsgPCAwICkgayA9IGNvbnRvdXIubGVuZ3RoIC0gMTtcclxuXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2InLCBpLGosIGktMSwgayx2ZXJ0aWNlcy5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHMgPSAwLCBzbCA9IHN0ZXBzICArIGJldmVsU2VnbWVudHMgKiAyO1xyXG5cclxuICAgICAgICAgICAgZm9yICggcyA9IDA7IHMgPCBzbDsgcyArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2xlbjEgPSB2bGVuICogcztcclxuICAgICAgICAgICAgICAgIHZhciBzbGVuMiA9IHZsZW4gKiAoIHMgKyAxICk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGEgPSBsYXllcm9mZnNldCArIGogKyBzbGVuMSxcclxuICAgICAgICAgICAgICAgICAgICBiID0gbGF5ZXJvZmZzZXQgKyBrICsgc2xlbjEsXHJcbiAgICAgICAgICAgICAgICAgICAgYyA9IGxheWVyb2Zmc2V0ICsgayArIHNsZW4yLFxyXG4gICAgICAgICAgICAgICAgICAgIGQgPSBsYXllcm9mZnNldCArIGogKyBzbGVuMjtcclxuXHJcbiAgICAgICAgICAgICAgICBmNCggYSwgYiwgYywgZCwgY29udG91ciwgcywgc2wsIGosIGsgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdiggeCwgeSwgeiApIHtcclxuXHJcbiAgICAgICAgc2NvcGUudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIHgsIHksIHogKSApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBmMyggYSwgYiwgYyApIHtcclxuXHJcbiAgICAgICAgYSArPSBzaGFwZXNPZmZzZXQ7XHJcbiAgICAgICAgYiArPSBzaGFwZXNPZmZzZXQ7XHJcbiAgICAgICAgYyArPSBzaGFwZXNPZmZzZXQ7XHJcblxyXG4gICAgICAgIHNjb3BlLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgYywgbnVsbCwgbnVsbCwgMCApICk7XHJcblxyXG4gICAgICAgIHZhciB1dnMgPSB1dmdlbi5nZW5lcmF0ZVRvcFVWKCBzY29wZSwgYSwgYiwgYyApO1xyXG5cclxuICAgICAgICBzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggdXZzICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGY0KCBhLCBiLCBjLCBkLCB3YWxsQ29udG91ciwgc3RlcEluZGV4LCBzdGVwc0xlbmd0aCwgY29udG91ckluZGV4MSwgY29udG91ckluZGV4MiApIHtcclxuXHJcbiAgICAgICAgYSArPSBzaGFwZXNPZmZzZXQ7XHJcbiAgICAgICAgYiArPSBzaGFwZXNPZmZzZXQ7XHJcbiAgICAgICAgYyArPSBzaGFwZXNPZmZzZXQ7XHJcbiAgICAgICAgZCArPSBzaGFwZXNPZmZzZXQ7XHJcblxyXG4gICAgICAgIHNjb3BlLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCwgbnVsbCwgbnVsbCwgMSApICk7XHJcbiAgICAgICAgc2NvcGUuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkLCBudWxsLCBudWxsLCAxICkgKTtcclxuXHJcbiAgICAgICAgdmFyIHV2cyA9IHV2Z2VuLmdlbmVyYXRlU2lkZVdhbGxVViggc2NvcGUsIGEsIGIsIGMsIGQgKTtcclxuXHJcbiAgICAgICAgc2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyAwIF0sIHV2c1sgMSBdLCB1dnNbIDMgXSBdICk7XHJcbiAgICAgICAgc2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyAxIF0sIHV2c1sgMiBdLCB1dnNbIDMgXSBdICk7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5Xb3JsZFVWR2VuZXJhdG9yID0ge1xyXG5cclxuICAgIGdlbmVyYXRlVG9wVVY6IGZ1bmN0aW9uICggZ2VvbWV0cnksIGluZGV4QSwgaW5kZXhCLCBpbmRleEMgKSB7XHJcblxyXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cclxuICAgICAgICB2YXIgYSA9IHZlcnRpY2VzWyBpbmRleEEgXTtcclxuICAgICAgICB2YXIgYiA9IHZlcnRpY2VzWyBpbmRleEIgXTtcclxuICAgICAgICB2YXIgYyA9IHZlcnRpY2VzWyBpbmRleEMgXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGEueCwgYS55ICksXHJcbiAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBiLngsIGIueSApLFxyXG4gICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYy54LCBjLnkgKVxyXG4gICAgICAgIF07XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZW5lcmF0ZVNpZGVXYWxsVVY6IGZ1bmN0aW9uICggZ2VvbWV0cnksIGluZGV4QSwgaW5kZXhCLCBpbmRleEMsIGluZGV4RCApIHtcclxuXHJcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XHJcblxyXG4gICAgICAgIHZhciBhID0gdmVydGljZXNbIGluZGV4QSBdO1xyXG4gICAgICAgIHZhciBiID0gdmVydGljZXNbIGluZGV4QiBdO1xyXG4gICAgICAgIHZhciBjID0gdmVydGljZXNbIGluZGV4QyBdO1xyXG4gICAgICAgIHZhciBkID0gdmVydGljZXNbIGluZGV4RCBdO1xyXG5cclxuICAgICAgICBpZiAoIE1hdGguYWJzKCBhLnkgLSBiLnkgKSA8IDAuMDEgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGEueCwgMSAtIGEueiApLFxyXG4gICAgICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGIueCwgMSAtIGIueiApLFxyXG4gICAgICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGMueCwgMSAtIGMueiApLFxyXG4gICAgICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGQueCwgMSAtIGQueiApXHJcbiAgICAgICAgICAgIF07XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGEueSwgMSAtIGEueiApLFxyXG4gICAgICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGIueSwgMSAtIGIueiApLFxyXG4gICAgICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGMueSwgMSAtIGMueiApLFxyXG4gICAgICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGQueSwgMSAtIGQueiApXHJcbiAgICAgICAgICAgIF07XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9TaGFwZUdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBqb25vYnIxIC8gaHR0cDovL2pvbm9icjEuY29tXHJcbiAqXHJcbiAqIENyZWF0ZXMgYSBvbmUtc2lkZWQgcG9seWdvbmFsIGdlb21ldHJ5IGZyb20gYSBwYXRoIHNoYXBlLiBTaW1pbGFyIHRvXHJcbiAqIEV4dHJ1ZGVHZW9tZXRyeS5cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICpcclxuICpcdGN1cnZlU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZXMuIE5PVCBVU0VEIEFUIFRIRSBNT01FTlQuXHJcbiAqXHJcbiAqXHRtYXRlcmlhbDogPGludD4gLy8gbWF0ZXJpYWwgaW5kZXggZm9yIGZyb250IGFuZCBiYWNrIGZhY2VzXHJcbiAqXHR1dkdlbmVyYXRvcjogPE9iamVjdD4gLy8gb2JqZWN0IHRoYXQgcHJvdmlkZXMgVVYgZ2VuZXJhdG9yIGZ1bmN0aW9uc1xyXG4gKlxyXG4gKiB9XHJcbiAqKi9cclxuXHJcblRIUkVFLlNoYXBlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHNoYXBlcywgb3B0aW9ucyApIHtcclxuXHJcbiAgICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ1NoYXBlR2VvbWV0cnknO1xyXG5cclxuICAgIGlmICggQXJyYXkuaXNBcnJheSggc2hhcGVzICkgPT09IGZhbHNlICkgc2hhcGVzID0gWyBzaGFwZXMgXTtcclxuXHJcbiAgICB0aGlzLmFkZFNoYXBlTGlzdCggc2hhcGVzLCBvcHRpb25zICk7XHJcblxyXG4gICAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TaGFwZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5TaGFwZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNoYXBlR2VvbWV0cnk7XHJcblxyXG4vKipcclxuICogQWRkIGFuIGFycmF5IG9mIHNoYXBlcyB0byBUSFJFRS5TaGFwZUdlb21ldHJ5LlxyXG4gKi9cclxuVEhSRUUuU2hhcGVHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGVMaXN0ID0gZnVuY3Rpb24gKCBzaGFwZXMsIG9wdGlvbnMgKSB7XHJcblxyXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gc2hhcGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkU2hhcGUoIHNoYXBlc1sgaSBdLCBvcHRpb25zICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGEgc2hhcGUgdG8gVEhSRUUuU2hhcGVHZW9tZXRyeSwgYmFzZWQgb24gVEhSRUUuRXh0cnVkZUdlb21ldHJ5LlxyXG4gKi9cclxuVEhSRUUuU2hhcGVHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGUgPSBmdW5jdGlvbiAoIHNoYXBlLCBvcHRpb25zICkge1xyXG5cclxuICAgIGlmICggb3B0aW9ucyA9PT0gdW5kZWZpbmVkICkgb3B0aW9ucyA9IHt9O1xyXG4gICAgdmFyIGN1cnZlU2VnbWVudHMgPSBvcHRpb25zLmN1cnZlU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY3VydmVTZWdtZW50cyA6IDEyO1xyXG5cclxuICAgIHZhciBtYXRlcmlhbCA9IG9wdGlvbnMubWF0ZXJpYWw7XHJcbiAgICB2YXIgdXZnZW4gPSBvcHRpb25zLlVWR2VuZXJhdG9yID09PSB1bmRlZmluZWQgPyBUSFJFRS5FeHRydWRlR2VvbWV0cnkuV29ybGRVVkdlbmVyYXRvciA6IG9wdGlvbnMuVVZHZW5lcmF0b3I7XHJcblxyXG4gICAgLy9cclxuXHJcbiAgICB2YXIgaSwgbCwgaG9sZTtcclxuXHJcbiAgICB2YXIgc2hhcGVzT2Zmc2V0ID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XHJcbiAgICB2YXIgc2hhcGVQb2ludHMgPSBzaGFwZS5leHRyYWN0UG9pbnRzKCBjdXJ2ZVNlZ21lbnRzICk7XHJcblxyXG4gICAgdmFyIHZlcnRpY2VzID0gc2hhcGVQb2ludHMuc2hhcGU7XHJcbiAgICB2YXIgaG9sZXMgPSBzaGFwZVBvaW50cy5ob2xlcztcclxuXHJcbiAgICB2YXIgcmV2ZXJzZSA9ICEgVEhSRUUuU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSggdmVydGljZXMgKTtcclxuXHJcbiAgICBpZiAoIHJldmVyc2UgKSB7XHJcblxyXG4gICAgICAgIHZlcnRpY2VzID0gdmVydGljZXMucmV2ZXJzZSgpO1xyXG5cclxuICAgICAgICAvLyBNYXliZSB3ZSBzaG91bGQgYWxzbyBjaGVjayBpZiBob2xlcyBhcmUgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiwganVzdCB0byBiZSBzYWZlLi4uXHJcblxyXG4gICAgICAgIGZvciAoIGkgPSAwLCBsID0gaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIGhvbGUgPSBob2xlc1sgaSBdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBUSFJFRS5TaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKCBob2xlICkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaG9sZXNbIGkgXSA9IGhvbGUucmV2ZXJzZSgpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldmVyc2UgPSBmYWxzZTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGZhY2VzID0gVEhSRUUuU2hhcGVVdGlscy50cmlhbmd1bGF0ZVNoYXBlKCB2ZXJ0aWNlcywgaG9sZXMgKTtcclxuXHJcbiAgICAvLyBWZXJ0aWNlc1xyXG5cclxuICAgIGZvciAoIGkgPSAwLCBsID0gaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgaG9sZSA9IGhvbGVzWyBpIF07XHJcbiAgICAgICAgdmVydGljZXMgPSB2ZXJ0aWNlcy5jb25jYXQoIGhvbGUgKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy9cclxuXHJcbiAgICB2YXIgdmVydCwgdmxlbiA9IHZlcnRpY2VzLmxlbmd0aDtcclxuICAgIHZhciBmYWNlLCBmbGVuID0gZmFjZXMubGVuZ3RoO1xyXG5cclxuICAgIGZvciAoIGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcclxuXHJcbiAgICAgICAgdmVydCA9IHZlcnRpY2VzWyBpIF07XHJcblxyXG4gICAgICAgIHRoaXMudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIHZlcnQueCwgdmVydC55LCAwICkgKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xyXG5cclxuICAgICAgICBmYWNlID0gZmFjZXNbIGkgXTtcclxuXHJcbiAgICAgICAgdmFyIGEgPSBmYWNlWyAwIF0gKyBzaGFwZXNPZmZzZXQ7XHJcbiAgICAgICAgdmFyIGIgPSBmYWNlWyAxIF0gKyBzaGFwZXNPZmZzZXQ7XHJcbiAgICAgICAgdmFyIGMgPSBmYWNlWyAyIF0gKyBzaGFwZXNPZmZzZXQ7XHJcblxyXG4gICAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBjLCBudWxsLCBudWxsLCBtYXRlcmlhbCApICk7XHJcbiAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggdXZnZW4uZ2VuZXJhdGVUb3BVViggdGhpcywgYSwgYiwgYyApICk7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0xhdGhlR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFzdHJvZHVkIC8gaHR0cDovL2FzdHJvZHVkLmlzZ3JlYXQub3JnL1xyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwczovL2dpdGh1Yi5jb20veno4NVxyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXHJcbiAqL1xyXG5cclxuLy8gcG9pbnRzIC0gdG8gY3JlYXRlIGEgY2xvc2VkIHRvcnVzLCBvbmUgbXVzdCB1c2UgYSBzZXQgb2YgcG9pbnRzIFxyXG4vLyAgICBsaWtlIHNvOiBbIGEsIGIsIGMsIGQsIGEgXSwgc2VlIGZpcnN0IGlzIHRoZSBzYW1lIGFzIGxhc3QuXHJcbi8vIHNlZ21lbnRzIC0gdGhlIG51bWJlciBvZiBjaXJjdW1mZXJlbmNlIHNlZ21lbnRzIHRvIGNyZWF0ZVxyXG4vLyBwaGlTdGFydCAtIHRoZSBzdGFydGluZyByYWRpYW5cclxuLy8gcGhpTGVuZ3RoIC0gdGhlIHJhZGlhbiAoMCB0byAyKlBJKSByYW5nZSBvZiB0aGUgbGF0aGVkIHNlY3Rpb25cclxuLy8gICAgMipwaSBpcyBhIGNsb3NlZCBsYXRoZSwgbGVzcyB0aGFuIDJQSSBpcyBhIHBvcnRpb24uXHJcblxyXG5USFJFRS5MYXRoZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCBwb2ludHMsIHNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoICkge1xyXG5cclxuICAgIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnTGF0aGVHZW9tZXRyeSc7XHJcblxyXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xyXG4gICAgICAgIHBvaW50czogcG9pbnRzLFxyXG4gICAgICAgIHNlZ21lbnRzOiBzZWdtZW50cyxcclxuICAgICAgICBwaGlTdGFydDogcGhpU3RhcnQsXHJcbiAgICAgICAgcGhpTGVuZ3RoOiBwaGlMZW5ndGhcclxuICAgIH07XHJcblxyXG4gICAgc2VnbWVudHMgPSBzZWdtZW50cyB8fCAxMjtcclxuICAgIHBoaVN0YXJ0ID0gcGhpU3RhcnQgfHwgMDtcclxuICAgIHBoaUxlbmd0aCA9IHBoaUxlbmd0aCB8fCAyICogTWF0aC5QSTtcclxuXHJcbiAgICB2YXIgaW52ZXJzZVBvaW50TGVuZ3RoID0gMS4wIC8gKCBwb2ludHMubGVuZ3RoIC0gMSApO1xyXG4gICAgdmFyIGludmVyc2VTZWdtZW50cyA9IDEuMCAvIHNlZ21lbnRzO1xyXG5cclxuICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBzZWdtZW50czsgaSA8PSBpbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgdmFyIHBoaSA9IHBoaVN0YXJ0ICsgaSAqIGludmVyc2VTZWdtZW50cyAqIHBoaUxlbmd0aDtcclxuXHJcbiAgICAgICAgdmFyIGMgPSBNYXRoLmNvcyggcGhpICksXHJcbiAgICAgICAgICAgIHMgPSBNYXRoLnNpbiggcGhpICk7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBwb2ludHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgcHQgPSBwb2ludHNbIGogXTtcclxuXHJcbiAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICAgICAgdmVydGV4LnggPSBjICogcHQueCAtIHMgKiBwdC55O1xyXG4gICAgICAgICAgICB2ZXJ0ZXgueSA9IHMgKiBwdC54ICsgYyAqIHB0Lnk7XHJcbiAgICAgICAgICAgIHZlcnRleC56ID0gcHQuejtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudmVydGljZXMucHVzaCggdmVydGV4ICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG5wID0gcG9pbnRzLmxlbmd0aDtcclxuXHJcbiAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gc2VnbWVudHM7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IHBvaW50cy5sZW5ndGggLSAxOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYmFzZSA9IGogKyBucCAqIGk7XHJcbiAgICAgICAgICAgIHZhciBhID0gYmFzZTtcclxuICAgICAgICAgICAgdmFyIGIgPSBiYXNlICsgbnA7XHJcbiAgICAgICAgICAgIHZhciBjID0gYmFzZSArIDEgKyBucDtcclxuICAgICAgICAgICAgdmFyIGQgPSBiYXNlICsgMTtcclxuXHJcbiAgICAgICAgICAgIHZhciB1MCA9IGkgKiBpbnZlcnNlU2VnbWVudHM7XHJcbiAgICAgICAgICAgIHZhciB2MCA9IGogKiBpbnZlcnNlUG9pbnRMZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciB1MSA9IHUwICsgaW52ZXJzZVNlZ21lbnRzO1xyXG4gICAgICAgICAgICB2YXIgdjEgPSB2MCArIGludmVyc2VQb2ludExlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBkICkgKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFtcclxuXHJcbiAgICAgICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggdTAsIHYwICksXHJcbiAgICAgICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggdTEsIHYwICksXHJcbiAgICAgICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggdTAsIHYxIClcclxuXHJcbiAgICAgICAgICAgIF0gKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkICkgKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFtcclxuXHJcbiAgICAgICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggdTEsIHYwICksXHJcbiAgICAgICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggdTEsIHYxICksXHJcbiAgICAgICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggdTAsIHYxIClcclxuXHJcbiAgICAgICAgICAgIF0gKTtcclxuXHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5tZXJnZVZlcnRpY2VzKCk7XHJcbiAgICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG4gICAgdGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxhdGhlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLkxhdGhlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGF0aGVHZW9tZXRyeTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1BsYW5lR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBiYXNlZCBvbiBodHRwOi8vcGFwZXJ2aXNpb24zZC5nb29nbGVjb2RlLmNvbS9zdm4vdHJ1bmsvYXMzL3RydW5rL3NyYy9vcmcvcGFwZXJ2aXNpb24zZC9vYmplY3RzL3ByaW1pdGl2ZXMvUGxhbmUuYXNcclxuICovXHJcblxyXG5USFJFRS5QbGFuZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cyApIHtcclxuXHJcbiAgICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ1BsYW5lR2VvbWV0cnknO1xyXG5cclxuICAgIHRoaXMucGFyYW1ldGVycyA9IHtcclxuICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgd2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcclxuICAgICAgICBoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHNcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBUSFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5KCB3aWR0aCwgaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cyApICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGxhbmVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuUGxhbmVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5QbGFuZUdlb21ldHJ5O1xyXG5cclxuVEhSRUUuUGxhbmVHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KFxyXG4gICAgICAgIHBhcmFtZXRlcnMud2lkdGgsXHJcbiAgICAgICAgcGFyYW1ldGVycy5oZWlnaHQsXHJcbiAgICAgICAgcGFyYW1ldGVycy53aWR0aFNlZ21lbnRzLFxyXG4gICAgICAgIHBhcmFtZXRlcnMuaGVpZ2h0U2VnbWVudHNcclxuICAgICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvUGxhbmVCdWZmZXJHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIGJhc2VkIG9uIGh0dHA6Ly9wYXBlcnZpc2lvbjNkLmdvb2dsZWNvZGUuY29tL3N2bi90cnVuay9hczMvdHJ1bmsvc3JjL29yZy9wYXBlcnZpc2lvbjNkL29iamVjdHMvcHJpbWl0aXZlcy9QbGFuZS5hc1xyXG4gKi9cclxuXHJcblRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzICkge1xyXG5cclxuICAgIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnUGxhbmVCdWZmZXJHZW9tZXRyeSc7XHJcblxyXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xyXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICB3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxyXG4gICAgICAgIGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50c1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgd2lkdGhfaGFsZiA9IHdpZHRoIC8gMjtcclxuICAgIHZhciBoZWlnaHRfaGFsZiA9IGhlaWdodCAvIDI7XHJcblxyXG4gICAgdmFyIGdyaWRYID0gTWF0aC5mbG9vciggd2lkdGhTZWdtZW50cyApIHx8IDE7XHJcbiAgICB2YXIgZ3JpZFkgPSBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApIHx8IDE7XHJcblxyXG4gICAgdmFyIGdyaWRYMSA9IGdyaWRYICsgMTtcclxuICAgIHZhciBncmlkWTEgPSBncmlkWSArIDE7XHJcblxyXG4gICAgdmFyIHNlZ21lbnRfd2lkdGggPSB3aWR0aCAvIGdyaWRYO1xyXG4gICAgdmFyIHNlZ21lbnRfaGVpZ2h0ID0gaGVpZ2h0IC8gZ3JpZFk7XHJcblxyXG4gICAgdmFyIHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggZ3JpZFgxICogZ3JpZFkxICogMyApO1xyXG4gICAgdmFyIG5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KCBncmlkWDEgKiBncmlkWTEgKiAzICk7XHJcbiAgICB2YXIgdXZzID0gbmV3IEZsb2F0MzJBcnJheSggZ3JpZFgxICogZ3JpZFkxICogMiApO1xyXG5cclxuICAgIHZhciBvZmZzZXQgPSAwO1xyXG4gICAgdmFyIG9mZnNldDIgPSAwO1xyXG5cclxuICAgIGZvciAoIHZhciBpeSA9IDA7IGl5IDwgZ3JpZFkxOyBpeSArKyApIHtcclxuXHJcbiAgICAgICAgdmFyIHkgPSBpeSAqIHNlZ21lbnRfaGVpZ2h0IC0gaGVpZ2h0X2hhbGY7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpeCA9IDA7IGl4IDwgZ3JpZFgxOyBpeCArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciB4ID0gaXggKiBzZWdtZW50X3dpZHRoIC0gd2lkdGhfaGFsZjtcclxuXHJcbiAgICAgICAgICAgIHZlcnRpY2VzWyBvZmZzZXQgXSA9IHg7XHJcbiAgICAgICAgICAgIHZlcnRpY2VzWyBvZmZzZXQgKyAxIF0gPSAtIHk7XHJcblxyXG4gICAgICAgICAgICBub3JtYWxzWyBvZmZzZXQgKyAyIF0gPSAxO1xyXG5cclxuICAgICAgICAgICAgdXZzWyBvZmZzZXQyIF0gPSBpeCAvIGdyaWRYO1xyXG4gICAgICAgICAgICB1dnNbIG9mZnNldDIgKyAxIF0gPSAxIC0gKCBpeSAvIGdyaWRZICk7XHJcblxyXG4gICAgICAgICAgICBvZmZzZXQgKz0gMztcclxuICAgICAgICAgICAgb2Zmc2V0MiArPSAyO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIG9mZnNldCA9IDA7XHJcblxyXG4gICAgdmFyIGluZGljZXMgPSBuZXcgKCAoIHZlcnRpY2VzLmxlbmd0aCAvIDMgKSA+IDY1NTM1ID8gVWludDMyQXJyYXkgOiBVaW50MTZBcnJheSApKCBncmlkWCAqIGdyaWRZICogNiApO1xyXG5cclxuICAgIGZvciAoIHZhciBpeSA9IDA7IGl5IDwgZ3JpZFk7IGl5ICsrICkge1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaXggPSAwOyBpeCA8IGdyaWRYOyBpeCArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBhID0gaXggKyBncmlkWDEgKiBpeTtcclxuICAgICAgICAgICAgdmFyIGIgPSBpeCArIGdyaWRYMSAqICggaXkgKyAxICk7XHJcbiAgICAgICAgICAgIHZhciBjID0gKCBpeCArIDEgKSArIGdyaWRYMSAqICggaXkgKyAxICk7XHJcbiAgICAgICAgICAgIHZhciBkID0gKCBpeCArIDEgKSArIGdyaWRYMSAqIGl5O1xyXG5cclxuICAgICAgICAgICAgaW5kaWNlc1sgb2Zmc2V0IF0gPSBhO1xyXG4gICAgICAgICAgICBpbmRpY2VzWyBvZmZzZXQgKyAxIF0gPSBiO1xyXG4gICAgICAgICAgICBpbmRpY2VzWyBvZmZzZXQgKyAyIF0gPSBkO1xyXG5cclxuICAgICAgICAgICAgaW5kaWNlc1sgb2Zmc2V0ICsgMyBdID0gYjtcclxuICAgICAgICAgICAgaW5kaWNlc1sgb2Zmc2V0ICsgNCBdID0gYztcclxuICAgICAgICAgICAgaW5kaWNlc1sgb2Zmc2V0ICsgNSBdID0gZDtcclxuXHJcbiAgICAgICAgICAgIG9mZnNldCArPSA2O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc2V0SW5kZXgoIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGluZGljZXMsIDEgKSApO1xyXG4gICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcclxuICAgIHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XHJcbiAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnk7XHJcblxyXG5USFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcclxuXHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkoXHJcbiAgICAgICAgcGFyYW1ldGVycy53aWR0aCxcclxuICAgICAgICBwYXJhbWV0ZXJzLmhlaWdodCxcclxuICAgICAgICBwYXJhbWV0ZXJzLndpZHRoU2VnbWVudHMsXHJcbiAgICAgICAgcGFyYW1ldGVycy5oZWlnaHRTZWdtZW50c1xyXG4gICAgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9SaW5nR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIEthbGViIE11cnBoeVxyXG4gKi9cclxuXHJcblRIUkVFLlJpbmdHZW9tZXRyeSA9IGZ1bmN0aW9uICggaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCB0aGV0YVNlZ21lbnRzLCBwaGlTZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XHJcblxyXG4gICAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdSaW5nR2VvbWV0cnknO1xyXG5cclxuICAgIHRoaXMucGFyYW1ldGVycyA9IHtcclxuICAgICAgICBpbm5lclJhZGl1czogaW5uZXJSYWRpdXMsXHJcbiAgICAgICAgb3V0ZXJSYWRpdXM6IG91dGVyUmFkaXVzLFxyXG4gICAgICAgIHRoZXRhU2VnbWVudHM6IHRoZXRhU2VnbWVudHMsXHJcbiAgICAgICAgcGhpU2VnbWVudHM6IHBoaVNlZ21lbnRzLFxyXG4gICAgICAgIHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXHJcbiAgICAgICAgdGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXHJcbiAgICB9O1xyXG5cclxuICAgIGlubmVyUmFkaXVzID0gaW5uZXJSYWRpdXMgfHwgMDtcclxuICAgIG91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgfHwgNTA7XHJcblxyXG4gICAgdGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xyXG4gICAgdGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiBNYXRoLlBJICogMjtcclxuXHJcbiAgICB0aGV0YVNlZ21lbnRzID0gdGhldGFTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gTWF0aC5tYXgoIDMsIHRoZXRhU2VnbWVudHMgKSA6IDg7XHJcbiAgICBwaGlTZWdtZW50cyA9IHBoaVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBNYXRoLm1heCggMSwgcGhpU2VnbWVudHMgKSA6IDg7XHJcblxyXG4gICAgdmFyIGksIG8sIHV2cyA9IFtdLCByYWRpdXMgPSBpbm5lclJhZGl1cywgcmFkaXVzU3RlcCA9ICggKCBvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzICkgLyBwaGlTZWdtZW50cyApO1xyXG5cclxuICAgIGZvciAoIGkgPSAwOyBpIDwgcGhpU2VnbWVudHMgKyAxOyBpICsrICkge1xyXG5cclxuICAgICAgICAvLyBjb25jZW50cmljIGNpcmNsZXMgaW5zaWRlIHJpbmdcclxuXHJcbiAgICAgICAgZm9yICggbyA9IDA7IG8gPCB0aGV0YVNlZ21lbnRzICsgMTsgbyArKyApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIG51bWJlciBvZiBzZWdtZW50cyBwZXIgY2lyY2xlXHJcblxyXG4gICAgICAgICAgICB2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSB0aGV0YVN0YXJ0ICsgbyAvIHRoZXRhU2VnbWVudHMgKiB0aGV0YUxlbmd0aDtcclxuICAgICAgICAgICAgdmVydGV4LnggPSByYWRpdXMgKiBNYXRoLmNvcyggc2VnbWVudCApO1xyXG4gICAgICAgICAgICB2ZXJ0ZXgueSA9IHJhZGl1cyAqIE1hdGguc2luKCBzZWdtZW50ICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xyXG4gICAgICAgICAgICB1dnMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoICggdmVydGV4LnggLyBvdXRlclJhZGl1cyArIDEgKSAvIDIsICggdmVydGV4LnkgLyBvdXRlclJhZGl1cyArIDEgKSAvIDIgKSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJhZGl1cyArPSByYWRpdXNTdGVwO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB2YXIgbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICk7XHJcblxyXG4gICAgZm9yICggaSA9IDA7IGkgPCBwaGlTZWdtZW50czsgaSArKyApIHtcclxuXHJcbiAgICAgICAgLy8gY29uY2VudHJpYyBjaXJjbGVzIGluc2lkZSByaW5nXHJcblxyXG4gICAgICAgIHZhciB0aGV0YVNlZ21lbnQgPSBpICogKCB0aGV0YVNlZ21lbnRzICsgMSApO1xyXG5cclxuICAgICAgICBmb3IgKCBvID0gMDsgbyA8IHRoZXRhU2VnbWVudHMgOyBvICsrICkge1xyXG5cclxuICAgICAgICAgICAgLy8gbnVtYmVyIG9mIHNlZ21lbnRzIHBlciBjaXJjbGVcclxuXHJcbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gbyArIHRoZXRhU2VnbWVudDtcclxuXHJcbiAgICAgICAgICAgIHZhciB2MSA9IHNlZ21lbnQ7XHJcbiAgICAgICAgICAgIHZhciB2MiA9IHNlZ21lbnQgKyB0aGV0YVNlZ21lbnRzICsgMTtcclxuICAgICAgICAgICAgdmFyIHYzID0gc2VnbWVudCArIHRoZXRhU2VnbWVudHMgKyAyO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MiwgdjMsIFsgbi5jbG9uZSgpLCBuLmNsb25lKCksIG4uY2xvbmUoKSBdICkgKTtcclxuICAgICAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIHYxIF0uY2xvbmUoKSwgdXZzWyB2MiBdLmNsb25lKCksIHV2c1sgdjMgXS5jbG9uZSgpIF0gKTtcclxuXHJcbiAgICAgICAgICAgIHYxID0gc2VnbWVudDtcclxuICAgICAgICAgICAgdjIgPSBzZWdtZW50ICsgdGhldGFTZWdtZW50cyArIDI7XHJcbiAgICAgICAgICAgIHYzID0gc2VnbWVudCArIDE7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2MywgWyBuLmNsb25lKCksIG4uY2xvbmUoKSwgbi5jbG9uZSgpIF0gKSApO1xyXG4gICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2c1sgdjEgXS5jbG9uZSgpLCB1dnNbIHYyIF0uY2xvbmUoKSwgdXZzWyB2MyBdLmNsb25lKCkgXSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcblxyXG4gICAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoIG5ldyBUSFJFRS5WZWN0b3IzKCksIHJhZGl1cyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlJpbmdHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuUmluZ0dlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlJpbmdHZW9tZXRyeTtcclxuXHJcblRIUkVFLlJpbmdHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5SaW5nR2VvbWV0cnkoXHJcbiAgICAgICAgcGFyYW1ldGVycy5pbm5lclJhZGl1cyxcclxuICAgICAgICBwYXJhbWV0ZXJzLm91dGVyUmFkaXVzLFxyXG4gICAgICAgIHBhcmFtZXRlcnMudGhldGFTZWdtZW50cyxcclxuICAgICAgICBwYXJhbWV0ZXJzLnBoaVNlZ21lbnRzLFxyXG4gICAgICAgIHBhcmFtZXRlcnMudGhldGFTdGFydCxcclxuICAgICAgICBwYXJhbWV0ZXJzLnRoZXRhTGVuZ3RoXHJcbiAgICApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1NwaGVyZUdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5TcGhlcmVHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XHJcblxyXG4gICAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdTcGhlcmVHZW9tZXRyeSc7XHJcblxyXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xyXG4gICAgICAgIHJhZGl1czogcmFkaXVzLFxyXG4gICAgICAgIHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXHJcbiAgICAgICAgaGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxyXG4gICAgICAgIHBoaVN0YXJ0OiBwaGlTdGFydCxcclxuICAgICAgICBwaGlMZW5ndGg6IHBoaUxlbmd0aCxcclxuICAgICAgICB0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxyXG4gICAgICAgIHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IFRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU3BoZXJlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLlNwaGVyZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwaGVyZUdlb21ldHJ5O1xyXG5cclxuVEhSRUUuU3BoZXJlR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoXHJcbiAgICAgICAgcGFyYW1ldGVycy5yYWRpdXMsXHJcbiAgICAgICAgcGFyYW1ldGVycy53aWR0aFNlZ21lbnRzLFxyXG4gICAgICAgIHBhcmFtZXRlcnMuaGVpZ2h0U2VnbWVudHMsXHJcbiAgICAgICAgcGFyYW1ldGVycy5waGlTdGFydCxcclxuICAgICAgICBwYXJhbWV0ZXJzLnBoaUxlbmd0aCxcclxuICAgICAgICBwYXJhbWV0ZXJzLnRoZXRhU3RhcnQsXHJcbiAgICAgICAgcGFyYW1ldGVycy50aGV0YUxlbmd0aFxyXG4gICAgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9TcGhlcmVCdWZmZXJHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xyXG4gKiBiYXNlZCBvbiBUSFJFRS5TcGhlcmVHZW9tZXRyeVxyXG4gKi9cclxuXHJcblRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcclxuXHJcbiAgICBUSFJFRS5CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ1NwaGVyZUJ1ZmZlckdlb21ldHJ5JztcclxuXHJcbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgcmFkaXVzOiByYWRpdXMsXHJcbiAgICAgICAgd2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcclxuICAgICAgICBoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXHJcbiAgICAgICAgcGhpU3RhcnQ6IHBoaVN0YXJ0LFxyXG4gICAgICAgIHBoaUxlbmd0aDogcGhpTGVuZ3RoLFxyXG4gICAgICAgIHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXHJcbiAgICAgICAgdGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXHJcbiAgICB9O1xyXG5cclxuICAgIHJhZGl1cyA9IHJhZGl1cyB8fCA1MDtcclxuXHJcbiAgICB3aWR0aFNlZ21lbnRzID0gTWF0aC5tYXgoIDMsIE1hdGguZmxvb3IoIHdpZHRoU2VnbWVudHMgKSB8fCA4ICk7XHJcbiAgICBoZWlnaHRTZWdtZW50cyA9IE1hdGgubWF4KCAyLCBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApIHx8IDYgKTtcclxuXHJcbiAgICBwaGlTdGFydCA9IHBoaVN0YXJ0ICE9PSB1bmRlZmluZWQgPyBwaGlTdGFydCA6IDA7XHJcbiAgICBwaGlMZW5ndGggPSBwaGlMZW5ndGggIT09IHVuZGVmaW5lZCA/IHBoaUxlbmd0aCA6IE1hdGguUEkgKiAyO1xyXG5cclxuICAgIHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcclxuICAgIHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogTWF0aC5QSTtcclxuXHJcbiAgICB2YXIgdGhldGFFbmQgPSB0aGV0YVN0YXJ0ICsgdGhldGFMZW5ndGg7XHJcblxyXG4gICAgdmFyIHZlcnRleENvdW50ID0gKCAoIHdpZHRoU2VnbWVudHMgKyAxICkgKiAoIGhlaWdodFNlZ21lbnRzICsgMSApICk7XHJcblxyXG4gICAgdmFyIHBvc2l0aW9ucyA9IG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRleENvdW50ICogMyApLCAzICk7XHJcbiAgICB2YXIgbm9ybWFscyA9IG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRleENvdW50ICogMyApLCAzICk7XHJcbiAgICB2YXIgdXZzID0gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggdmVydGV4Q291bnQgKiAyICksIDIgKTtcclxuXHJcbiAgICB2YXIgaW5kZXggPSAwLCB2ZXJ0aWNlcyA9IFtdLCBub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgIGZvciAoIHZhciB5ID0gMDsgeSA8PSBoZWlnaHRTZWdtZW50czsgeSArKyApIHtcclxuXHJcbiAgICAgICAgdmFyIHZlcnRpY2VzUm93ID0gW107XHJcblxyXG4gICAgICAgIHZhciB2ID0geSAvIGhlaWdodFNlZ21lbnRzO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgeCA9IDA7IHggPD0gd2lkdGhTZWdtZW50czsgeCArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciB1ID0geCAvIHdpZHRoU2VnbWVudHM7XHJcblxyXG4gICAgICAgICAgICB2YXIgcHggPSAtIHJhZGl1cyAqIE1hdGguY29zKCBwaGlTdGFydCArIHUgKiBwaGlMZW5ndGggKSAqIE1hdGguc2luKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XHJcbiAgICAgICAgICAgIHZhciBweSA9IHJhZGl1cyAqIE1hdGguY29zKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XHJcbiAgICAgICAgICAgIHZhciBweiA9IHJhZGl1cyAqIE1hdGguc2luKCBwaGlTdGFydCArIHUgKiBwaGlMZW5ndGggKSAqIE1hdGguc2luKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XHJcblxyXG4gICAgICAgICAgICBub3JtYWwuc2V0KCBweCwgcHksIHB6ICkubm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgICAgICBwb3NpdGlvbnMuc2V0WFlaKCBpbmRleCwgcHgsIHB5LCBweiApO1xyXG4gICAgICAgICAgICBub3JtYWxzLnNldFhZWiggaW5kZXgsIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcclxuICAgICAgICAgICAgdXZzLnNldFhZKCBpbmRleCwgdSwgMSAtIHYgKTtcclxuXHJcbiAgICAgICAgICAgIHZlcnRpY2VzUm93LnB1c2goIGluZGV4ICk7XHJcblxyXG4gICAgICAgICAgICBpbmRleCArKztcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1JvdyApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB2YXIgaW5kaWNlcyA9IFtdO1xyXG5cclxuICAgIGZvciAoIHZhciB5ID0gMDsgeSA8IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgeCA9IDA7IHggPCB3aWR0aFNlZ21lbnRzOyB4ICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHYxID0gdmVydGljZXNbIHkgXVsgeCArIDEgXTtcclxuICAgICAgICAgICAgdmFyIHYyID0gdmVydGljZXNbIHkgXVsgeCBdO1xyXG4gICAgICAgICAgICB2YXIgdjMgPSB2ZXJ0aWNlc1sgeSArIDEgXVsgeCBdO1xyXG4gICAgICAgICAgICB2YXIgdjQgPSB2ZXJ0aWNlc1sgeSArIDEgXVsgeCArIDEgXTtcclxuXHJcbiAgICAgICAgICAgIGlmICggeSAhPT0gMCB8fCB0aGV0YVN0YXJ0ID4gMCApIGluZGljZXMucHVzaCggdjEsIHYyLCB2NCApO1xyXG4gICAgICAgICAgICBpZiAoIHkgIT09IGhlaWdodFNlZ21lbnRzIC0gMSB8fCB0aGV0YUVuZCA8IE1hdGguUEkgKSBpbmRpY2VzLnB1c2goIHYyLCB2MywgdjQgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNldEluZGV4KCBuZXcgKCBwb3NpdGlvbnMuY291bnQgPiA2NTUzNSA/IFRIUkVFLlVpbnQzMkF0dHJpYnV0ZSA6IFRIUkVFLlVpbnQxNkF0dHJpYnV0ZSApKCBpbmRpY2VzLCAxICkgKTtcclxuICAgIHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBwb3NpdGlvbnMgKTtcclxuICAgIHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbm9ybWFscyApO1xyXG4gICAgdGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIHV2cyApO1xyXG5cclxuICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCBuZXcgVEhSRUUuVmVjdG9yMygpLCByYWRpdXMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TcGhlcmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnk7XHJcblxyXG5USFJFRS5TcGhlcmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5TcGhlcmVCdWZmZXJHZW9tZXRyeShcclxuICAgICAgICBwYXJhbWV0ZXJzLnJhZGl1cyxcclxuICAgICAgICBwYXJhbWV0ZXJzLndpZHRoU2VnbWVudHMsXHJcbiAgICAgICAgcGFyYW1ldGVycy5oZWlnaHRTZWdtZW50cyxcclxuICAgICAgICBwYXJhbWV0ZXJzLnBoaVN0YXJ0LFxyXG4gICAgICAgIHBhcmFtZXRlcnMucGhpTGVuZ3RoLFxyXG4gICAgICAgIHBhcmFtZXRlcnMudGhldGFTdGFydCxcclxuICAgICAgICBwYXJhbWV0ZXJzLnRoZXRhTGVuZ3RoXHJcbiAgICApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1RvcnVzR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG9vc21veGllY29kZVxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBiYXNlZCBvbiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvYXdheTNkL3NvdXJjZS9icm93c2UvdHJ1bmsvZnAxMC9Bd2F5M0RMaXRlL3NyYy9hd2F5M2RsaXRlL3ByaW1pdGl2ZXMvVG9ydXMuYXM/cj0yODg4XHJcbiAqL1xyXG5cclxuVEhSRUUuVG9ydXNHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCB0dWJlLCByYWRpYWxTZWdtZW50cywgdHVidWxhclNlZ21lbnRzLCBhcmMgKSB7XHJcblxyXG4gICAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdUb3J1c0dlb21ldHJ5JztcclxuXHJcbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgcmFkaXVzOiByYWRpdXMsXHJcbiAgICAgICAgdHViZTogdHViZSxcclxuICAgICAgICByYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXHJcbiAgICAgICAgdHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXHJcbiAgICAgICAgYXJjOiBhcmNcclxuICAgIH07XHJcblxyXG4gICAgcmFkaXVzID0gcmFkaXVzIHx8IDEwMDtcclxuICAgIHR1YmUgPSB0dWJlIHx8IDQwO1xyXG4gICAgcmFkaWFsU2VnbWVudHMgPSByYWRpYWxTZWdtZW50cyB8fCA4O1xyXG4gICAgdHVidWxhclNlZ21lbnRzID0gdHVidWxhclNlZ21lbnRzIHx8IDY7XHJcbiAgICBhcmMgPSBhcmMgfHwgTWF0aC5QSSAqIDI7XHJcblxyXG4gICAgdmFyIGNlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIHV2cyA9IFtdLCBub3JtYWxzID0gW107XHJcblxyXG4gICAgZm9yICggdmFyIGogPSAwOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHUgPSBpIC8gdHVidWxhclNlZ21lbnRzICogYXJjO1xyXG4gICAgICAgICAgICB2YXIgdiA9IGogLyByYWRpYWxTZWdtZW50cyAqIE1hdGguUEkgKiAyO1xyXG5cclxuICAgICAgICAgICAgY2VudGVyLnggPSByYWRpdXMgKiBNYXRoLmNvcyggdSApO1xyXG4gICAgICAgICAgICBjZW50ZXIueSA9IHJhZGl1cyAqIE1hdGguc2luKCB1ICk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICAgICAgdmVydGV4LnggPSAoIHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLmNvcyggdSApO1xyXG4gICAgICAgICAgICB2ZXJ0ZXgueSA9ICggcmFkaXVzICsgdHViZSAqIE1hdGguY29zKCB2ICkgKSAqIE1hdGguc2luKCB1ICk7XHJcbiAgICAgICAgICAgIHZlcnRleC56ID0gdHViZSAqIE1hdGguc2luKCB2ICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xyXG5cclxuICAgICAgICAgICAgdXZzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCBpIC8gdHVidWxhclNlZ21lbnRzLCBqIC8gcmFkaWFsU2VnbWVudHMgKSApO1xyXG4gICAgICAgICAgICBub3JtYWxzLnB1c2goIHZlcnRleC5jbG9uZSgpLnN1YiggY2VudGVyICkubm9ybWFsaXplKCkgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBmb3IgKCB2YXIgaiA9IDE7IGogPD0gcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMTsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYSA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogaiArIGkgLSAxO1xyXG4gICAgICAgICAgICB2YXIgYiA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaSAtIDE7XHJcbiAgICAgICAgICAgIHZhciBjID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpO1xyXG4gICAgICAgICAgICB2YXIgZCA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogaiArIGk7XHJcblxyXG4gICAgICAgICAgICB2YXIgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCwgWyBub3JtYWxzWyBhIF0uY2xvbmUoKSwgbm9ybWFsc1sgYiBdLmNsb25lKCksIG5vcm1hbHNbIGQgXS5jbG9uZSgpIF0gKTtcclxuICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKCBmYWNlICk7XHJcbiAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyBhIF0uY2xvbmUoKSwgdXZzWyBiIF0uY2xvbmUoKSwgdXZzWyBkIF0uY2xvbmUoKSBdICk7XHJcblxyXG4gICAgICAgICAgICBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkLCBbIG5vcm1hbHNbIGIgXS5jbG9uZSgpLCBub3JtYWxzWyBjIF0uY2xvbmUoKSwgbm9ybWFsc1sgZCBdLmNsb25lKCkgXSApO1xyXG4gICAgICAgICAgICB0aGlzLmZhY2VzLnB1c2goIGZhY2UgKTtcclxuICAgICAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIGIgXS5jbG9uZSgpLCB1dnNbIGMgXS5jbG9uZSgpLCB1dnNbIGQgXS5jbG9uZSgpIF0gKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlRvcnVzR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLlRvcnVzR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuVG9ydXNHZW9tZXRyeTtcclxuXHJcblRIUkVFLlRvcnVzR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuVG9ydXNHZW9tZXRyeShcclxuICAgICAgICBwYXJhbWV0ZXJzLnJhZGl1cyxcclxuICAgICAgICBwYXJhbWV0ZXJzLnR1YmUsXHJcbiAgICAgICAgcGFyYW1ldGVycy5yYWRpYWxTZWdtZW50cyxcclxuICAgICAgICBwYXJhbWV0ZXJzLnR1YnVsYXJTZWdtZW50cyxcclxuICAgICAgICBwYXJhbWV0ZXJzLmFyY1xyXG4gICAgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9Ub3J1c0tub3RHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igb29zbW94aWVjb2RlXHJcbiAqIGJhc2VkIG9uIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9hd2F5M2Qvc291cmNlL2Jyb3dzZS90cnVuay9mcDEwL0F3YXkzRC9zcmMvYXdheTNkL3ByaW1pdGl2ZXMvVG9ydXNLbm90LmFzP3NwZWM9c3ZuMjQ3MyZyPTI0NzNcclxuICovXHJcblxyXG5USFJFRS5Ub3J1c0tub3RHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCB0dWJlLCByYWRpYWxTZWdtZW50cywgdHVidWxhclNlZ21lbnRzLCBwLCBxLCBoZWlnaHRTY2FsZSApIHtcclxuXHJcbiAgICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ1RvcnVzS25vdEdlb21ldHJ5JztcclxuXHJcbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgcmFkaXVzOiByYWRpdXMsXHJcbiAgICAgICAgdHViZTogdHViZSxcclxuICAgICAgICByYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXHJcbiAgICAgICAgdHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXHJcbiAgICAgICAgcDogcCxcclxuICAgICAgICBxOiBxLFxyXG4gICAgICAgIGhlaWdodFNjYWxlOiBoZWlnaHRTY2FsZVxyXG4gICAgfTtcclxuXHJcbiAgICByYWRpdXMgPSByYWRpdXMgfHwgMTAwO1xyXG4gICAgdHViZSA9IHR1YmUgfHwgNDA7XHJcbiAgICByYWRpYWxTZWdtZW50cyA9IHJhZGlhbFNlZ21lbnRzIHx8IDY0O1xyXG4gICAgdHVidWxhclNlZ21lbnRzID0gdHVidWxhclNlZ21lbnRzIHx8IDg7XHJcbiAgICBwID0gcCB8fCAyO1xyXG4gICAgcSA9IHEgfHwgMztcclxuICAgIGhlaWdodFNjYWxlID0gaGVpZ2h0U2NhbGUgfHwgMTtcclxuXHJcbiAgICB2YXIgZ3JpZCA9IG5ldyBBcnJheSggcmFkaWFsU2VnbWVudHMgKTtcclxuICAgIHZhciB0YW5nID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgIHZhciBuID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgIHZhciBiaXRhbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgcmFkaWFsU2VnbWVudHM7ICsrIGkgKSB7XHJcblxyXG4gICAgICAgIGdyaWRbIGkgXSA9IG5ldyBBcnJheSggdHVidWxhclNlZ21lbnRzICk7XHJcbiAgICAgICAgdmFyIHUgPSBpIC8gcmFkaWFsU2VnbWVudHMgKiAyICogcCAqIE1hdGguUEk7XHJcbiAgICAgICAgdmFyIHAxID0gZ2V0UG9zKCB1LCBxLCBwLCByYWRpdXMsIGhlaWdodFNjYWxlICk7XHJcbiAgICAgICAgdmFyIHAyID0gZ2V0UG9zKCB1ICsgMC4wMSwgcSwgcCwgcmFkaXVzLCBoZWlnaHRTY2FsZSApO1xyXG4gICAgICAgIHRhbmcuc3ViVmVjdG9ycyggcDIsIHAxICk7XHJcbiAgICAgICAgbi5hZGRWZWN0b3JzKCBwMiwgcDEgKTtcclxuXHJcbiAgICAgICAgYml0YW4uY3Jvc3NWZWN0b3JzKCB0YW5nLCBuICk7XHJcbiAgICAgICAgbi5jcm9zc1ZlY3RvcnMoIGJpdGFuLCB0YW5nICk7XHJcbiAgICAgICAgYml0YW4ubm9ybWFsaXplKCk7XHJcbiAgICAgICAgbi5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwgdHVidWxhclNlZ21lbnRzOyArKyBqICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHYgPSBqIC8gdHVidWxhclNlZ21lbnRzICogMiAqIE1hdGguUEk7XHJcbiAgICAgICAgICAgIHZhciBjeCA9IC0gdHViZSAqIE1hdGguY29zKCB2ICk7IC8vIFRPRE86IEhhY2s6IE5lZ2F0aW5nIGl0IHNvIGl0IGZhY2VzIG91dHNpZGUuXHJcbiAgICAgICAgICAgIHZhciBjeSA9IHR1YmUgKiBNYXRoLnNpbiggdiApO1xyXG5cclxuICAgICAgICAgICAgdmFyIHBvcyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgICAgIHBvcy54ID0gcDEueCArIGN4ICogbi54ICsgY3kgKiBiaXRhbi54O1xyXG4gICAgICAgICAgICBwb3MueSA9IHAxLnkgKyBjeCAqIG4ueSArIGN5ICogYml0YW4ueTtcclxuICAgICAgICAgICAgcG9zLnogPSBwMS56ICsgY3ggKiBuLnogKyBjeSAqIGJpdGFuLno7XHJcblxyXG4gICAgICAgICAgICBncmlkWyBpIF1bIGogXSA9IHRoaXMudmVydGljZXMucHVzaCggcG9zICkgLSAxO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHJhZGlhbFNlZ21lbnRzOyArKyBpICkge1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCB0dWJ1bGFyU2VnbWVudHM7ICsrIGogKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgaXAgPSAoIGkgKyAxICkgJSByYWRpYWxTZWdtZW50cztcclxuICAgICAgICAgICAgdmFyIGpwID0gKCBqICsgMSApICUgdHVidWxhclNlZ21lbnRzO1xyXG5cclxuICAgICAgICAgICAgdmFyIGEgPSBncmlkWyBpIF1bIGogXTtcclxuICAgICAgICAgICAgdmFyIGIgPSBncmlkWyBpcCBdWyBqIF07XHJcbiAgICAgICAgICAgIHZhciBjID0gZ3JpZFsgaXAgXVsganAgXTtcclxuICAgICAgICAgICAgdmFyIGQgPSBncmlkWyBpIF1bIGpwIF07XHJcblxyXG4gICAgICAgICAgICB2YXIgdXZhID0gbmV3IFRIUkVFLlZlY3RvcjIoIGkgLyByYWRpYWxTZWdtZW50cywgaiAvIHR1YnVsYXJTZWdtZW50cyApO1xyXG4gICAgICAgICAgICB2YXIgdXZiID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaSArIDEgKSAvIHJhZGlhbFNlZ21lbnRzLCBqIC8gdHVidWxhclNlZ21lbnRzICk7XHJcbiAgICAgICAgICAgIHZhciB1dmMgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpICsgMSApIC8gcmFkaWFsU2VnbWVudHMsICggaiArIDEgKSAvIHR1YnVsYXJTZWdtZW50cyApO1xyXG4gICAgICAgICAgICB2YXIgdXZkID0gbmV3IFRIUkVFLlZlY3RvcjIoIGkgLyByYWRpYWxTZWdtZW50cywgKCBqICsgMSApIC8gdHVidWxhclNlZ21lbnRzICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCApICk7XHJcbiAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZhLCB1dmIsIHV2ZCBdICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYiwgYywgZCApICk7XHJcbiAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZiLmNsb25lKCksIHV2YywgdXZkLmNsb25lKCkgXSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcbiAgICB0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0UG9zKCB1LCBpbl9xLCBpbl9wLCByYWRpdXMsIGhlaWdodFNjYWxlICkge1xyXG5cclxuICAgICAgICB2YXIgY3UgPSBNYXRoLmNvcyggdSApO1xyXG4gICAgICAgIHZhciBzdSA9IE1hdGguc2luKCB1ICk7XHJcbiAgICAgICAgdmFyIHF1T3ZlclAgPSBpbl9xIC8gaW5fcCAqIHU7XHJcbiAgICAgICAgdmFyIGNzID0gTWF0aC5jb3MoIHF1T3ZlclAgKTtcclxuXHJcbiAgICAgICAgdmFyIHR4ID0gcmFkaXVzICogKCAyICsgY3MgKSAqIDAuNSAqIGN1O1xyXG4gICAgICAgIHZhciB0eSA9IHJhZGl1cyAqICggMiArIGNzICkgKiBzdSAqIDAuNTtcclxuICAgICAgICB2YXIgdHogPSBoZWlnaHRTY2FsZSAqIHJhZGl1cyAqIE1hdGguc2luKCBxdU92ZXJQICkgKiAwLjU7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyggdHgsIHR5LCB0eiApO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Ub3J1c0tub3RHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuVG9ydXNLbm90R2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuVG9ydXNLbm90R2VvbWV0cnk7XHJcblxyXG5USFJFRS5Ub3J1c0tub3RHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5Ub3J1c0tub3RHZW9tZXRyeShcclxuICAgICAgICBwYXJhbWV0ZXJzLnJhZGl1cyxcclxuICAgICAgICBwYXJhbWV0ZXJzLnR1YmUsXHJcbiAgICAgICAgcGFyYW1ldGVycy5yYWRpYWxTZWdtZW50cyxcclxuICAgICAgICBwYXJhbWV0ZXJzLnR1YnVsYXJTZWdtZW50cyxcclxuICAgICAgICBwYXJhbWV0ZXJzLnAsXHJcbiAgICAgICAgcGFyYW1ldGVycy5xLFxyXG4gICAgICAgIHBhcmFtZXRlcnMuaGVpZ2h0U2NhbGVcclxuICAgICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvVHViZUdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwczovL2dpdGh1Yi5jb20veno4NVxyXG4gKiBAYXV0aG9yIG1pbmluZ29sZCAvIGh0dHBzOi8vZ2l0aHViLmNvbS9taW5pbmdvbGRcclxuICogQGF1dGhvciBqb25vYnIxIC8gaHR0cHM6Ly9naXRodWIuY29tL2pvbm9icjFcclxuICpcclxuICogTW9kaWZpZWQgZnJvbSB0aGUgVG9ydXNLbm90R2VvbWV0cnkgYnkgQG9vc21veGllY29kZVxyXG4gKlxyXG4gKiBDcmVhdGVzIGEgdHViZSB3aGljaCBleHRydWRlcyBhbG9uZyBhIDNkIHNwbGluZVxyXG4gKlxyXG4gKiBVc2VzIHBhcmFsbGVsIHRyYW5zcG9ydCBmcmFtZXMgYXMgZGVzY3JpYmVkIGluXHJcbiAqIGh0dHA6Ly93d3cuY3MuaW5kaWFuYS5lZHUvcHViL3RlY2hyZXBvcnRzL1RSNDI1LnBkZlxyXG4gKi9cclxuXHJcblRIUkVFLlR1YmVHZW9tZXRyeSA9IGZ1bmN0aW9uICggcGF0aCwgc2VnbWVudHMsIHJhZGl1cywgcmFkaWFsU2VnbWVudHMsIGNsb3NlZCwgdGFwZXIgKSB7XHJcblxyXG4gICAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdUdWJlR2VvbWV0cnknO1xyXG5cclxuICAgIHRoaXMucGFyYW1ldGVycyA9IHtcclxuICAgICAgICBwYXRoOiBwYXRoLFxyXG4gICAgICAgIHNlZ21lbnRzOiBzZWdtZW50cyxcclxuICAgICAgICByYWRpdXM6IHJhZGl1cyxcclxuICAgICAgICByYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXHJcbiAgICAgICAgY2xvc2VkOiBjbG9zZWQsXHJcbiAgICAgICAgdGFwZXI6IHRhcGVyXHJcbiAgICB9O1xyXG5cclxuICAgIHNlZ21lbnRzID0gc2VnbWVudHMgfHwgNjQ7XHJcbiAgICByYWRpdXMgPSByYWRpdXMgfHwgMTtcclxuICAgIHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgODtcclxuICAgIGNsb3NlZCA9IGNsb3NlZCB8fCBmYWxzZTtcclxuICAgIHRhcGVyID0gdGFwZXIgfHwgVEhSRUUuVHViZUdlb21ldHJ5Lk5vVGFwZXI7XHJcblxyXG4gICAgdmFyIGdyaWQgPSBbXTtcclxuXHJcbiAgICB2YXIgc2NvcGUgPSB0aGlzLFxyXG5cclxuICAgICAgICB0YW5nZW50LFxyXG4gICAgICAgIG5vcm1hbCxcclxuICAgICAgICBiaW5vcm1hbCxcclxuXHJcbiAgICAgICAgbnVtcG9pbnRzID0gc2VnbWVudHMgKyAxLFxyXG5cclxuICAgICAgICB1LCB2LCByLFxyXG5cclxuICAgICAgICBjeCwgY3ksXHJcbiAgICAgICAgcG9zLCBwb3MyID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuICAgICAgICBpLCBqLFxyXG4gICAgICAgIGlwLCBqcCxcclxuICAgICAgICBhLCBiLCBjLCBkLFxyXG4gICAgICAgIHV2YSwgdXZiLCB1dmMsIHV2ZDtcclxuXHJcbiAgICB2YXIgZnJhbWVzID0gbmV3IFRIUkVFLlR1YmVHZW9tZXRyeS5GcmVuZXRGcmFtZXMoIHBhdGgsIHNlZ21lbnRzLCBjbG9zZWQgKSxcclxuICAgICAgICB0YW5nZW50cyA9IGZyYW1lcy50YW5nZW50cyxcclxuICAgICAgICBub3JtYWxzID0gZnJhbWVzLm5vcm1hbHMsXHJcbiAgICAgICAgYmlub3JtYWxzID0gZnJhbWVzLmJpbm9ybWFscztcclxuXHJcbiAgICAvLyBwcm94eSBpbnRlcm5hbHNcclxuICAgIHRoaXMudGFuZ2VudHMgPSB0YW5nZW50cztcclxuICAgIHRoaXMubm9ybWFscyA9IG5vcm1hbHM7XHJcbiAgICB0aGlzLmJpbm9ybWFscyA9IGJpbm9ybWFscztcclxuXHJcbiAgICBmdW5jdGlvbiB2ZXJ0KCB4LCB5LCB6ICkge1xyXG5cclxuICAgICAgICByZXR1cm4gc2NvcGUudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIHgsIHksIHogKSApIC0gMTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29uc3RydWN0IHRoZSBncmlkXHJcblxyXG4gICAgZm9yICggaSA9IDA7IGkgPCBudW1wb2ludHM7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIGdyaWRbIGkgXSA9IFtdO1xyXG5cclxuICAgICAgICB1ID0gaSAvICggbnVtcG9pbnRzIC0gMSApO1xyXG5cclxuICAgICAgICBwb3MgPSBwYXRoLmdldFBvaW50QXQoIHUgKTtcclxuXHJcbiAgICAgICAgdGFuZ2VudCA9IHRhbmdlbnRzWyBpIF07XHJcbiAgICAgICAgbm9ybWFsID0gbm9ybWFsc1sgaSBdO1xyXG4gICAgICAgIGJpbm9ybWFsID0gYmlub3JtYWxzWyBpIF07XHJcblxyXG4gICAgICAgIHIgPSByYWRpdXMgKiB0YXBlciggdSApO1xyXG5cclxuICAgICAgICBmb3IgKCBqID0gMDsgaiA8IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xyXG5cclxuICAgICAgICAgICAgdiA9IGogLyByYWRpYWxTZWdtZW50cyAqIDIgKiBNYXRoLlBJO1xyXG5cclxuICAgICAgICAgICAgY3ggPSAtIHIgKiBNYXRoLmNvcyggdiApOyAvLyBUT0RPOiBIYWNrOiBOZWdhdGluZyBpdCBzbyBpdCBmYWNlcyBvdXRzaWRlLlxyXG4gICAgICAgICAgICBjeSA9IHIgKiBNYXRoLnNpbiggdiApO1xyXG5cclxuICAgICAgICAgICAgcG9zMi5jb3B5KCBwb3MgKTtcclxuICAgICAgICAgICAgcG9zMi54ICs9IGN4ICogbm9ybWFsLnggKyBjeSAqIGJpbm9ybWFsLng7XHJcbiAgICAgICAgICAgIHBvczIueSArPSBjeCAqIG5vcm1hbC55ICsgY3kgKiBiaW5vcm1hbC55O1xyXG4gICAgICAgICAgICBwb3MyLnogKz0gY3ggKiBub3JtYWwueiArIGN5ICogYmlub3JtYWwuejtcclxuXHJcbiAgICAgICAgICAgIGdyaWRbIGkgXVsgaiBdID0gdmVydCggcG9zMi54LCBwb3MyLnksIHBvczIueiApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBjb25zdHJ1Y3QgdGhlIG1lc2hcclxuXHJcbiAgICBmb3IgKCBpID0gMDsgaSA8IHNlZ21lbnRzOyBpICsrICkge1xyXG5cclxuICAgICAgICBmb3IgKCBqID0gMDsgaiA8IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xyXG5cclxuICAgICAgICAgICAgaXAgPSAoIGNsb3NlZCApID8gKCBpICsgMSApICUgc2VnbWVudHMgOiBpICsgMTtcclxuICAgICAgICAgICAganAgPSAoIGogKyAxICkgJSByYWRpYWxTZWdtZW50cztcclxuXHJcbiAgICAgICAgICAgIGEgPSBncmlkWyBpIF1bIGogXTtcdFx0Ly8gKioqIE5PVCBORUNFU1NBUklMWSBQTEFOQVIgISAqKipcclxuICAgICAgICAgICAgYiA9IGdyaWRbIGlwIF1bIGogXTtcclxuICAgICAgICAgICAgYyA9IGdyaWRbIGlwIF1bIGpwIF07XHJcbiAgICAgICAgICAgIGQgPSBncmlkWyBpIF1bIGpwIF07XHJcblxyXG4gICAgICAgICAgICB1dmEgPSBuZXcgVEhSRUUuVmVjdG9yMiggaSAvIHNlZ21lbnRzLCBqIC8gcmFkaWFsU2VnbWVudHMgKTtcclxuICAgICAgICAgICAgdXZiID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaSArIDEgKSAvIHNlZ21lbnRzLCBqIC8gcmFkaWFsU2VnbWVudHMgKTtcclxuICAgICAgICAgICAgdXZjID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaSArIDEgKSAvIHNlZ21lbnRzLCAoIGogKyAxICkgLyByYWRpYWxTZWdtZW50cyApO1xyXG4gICAgICAgICAgICB1dmQgPSBuZXcgVEhSRUUuVmVjdG9yMiggaSAvIHNlZ21lbnRzLCAoIGogKyAxICkgLyByYWRpYWxTZWdtZW50cyApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGQgKSApO1xyXG4gICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2YSwgdXZiLCB1dmQgXSApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQgKSApO1xyXG4gICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2Yi5jbG9uZSgpLCB1dmMsIHV2ZC5jbG9uZSgpIF0gKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG4gICAgdGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlR1YmVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuVHViZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlR1YmVHZW9tZXRyeTtcclxuVEhSRUUuVHViZUdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5wYXJhbWV0ZXJzLnBhdGgsXHJcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnNlZ21lbnRzLCB0aGlzLnBhcmFtZXRlcnMucmFkaXVzLCB0aGlzLnBhcmFtZXRlcnMucmFkaWFsU2VnbWVudHMsXHJcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmNsb3NlZCwgdGhpcy5wYXJhbWV0ZXJzLnRhcGVyXHJcbiAgICApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlR1YmVHZW9tZXRyeS5Ob1RhcGVyID0gZnVuY3Rpb24gKCB1ICkge1xyXG5cclxuICAgIHJldHVybiAxO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlR1YmVHZW9tZXRyeS5TaW51c29pZGFsVGFwZXIgPSBmdW5jdGlvbiAoIHUgKSB7XHJcblxyXG4gICAgcmV0dXJuIE1hdGguc2luKCBNYXRoLlBJICogdSApO1xyXG5cclxufTtcclxuXHJcbi8vIEZvciBjb21wdXRpbmcgb2YgRnJlbmV0IGZyYW1lcywgZXhwb3NpbmcgdGhlIHRhbmdlbnRzLCBub3JtYWxzIGFuZCBiaW5vcm1hbHMgdGhlIHNwbGluZVxyXG5USFJFRS5UdWJlR2VvbWV0cnkuRnJlbmV0RnJhbWVzID0gZnVuY3Rpb24gKCBwYXRoLCBzZWdtZW50cywgY2xvc2VkICkge1xyXG5cclxuICAgIHZhclx0bm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHJcbiAgICAgICAgdGFuZ2VudHMgPSBbXSxcclxuICAgICAgICBub3JtYWxzID0gW10sXHJcbiAgICAgICAgYmlub3JtYWxzID0gW10sXHJcblxyXG4gICAgICAgIHZlYyA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcbiAgICAgICAgbWF0ID0gbmV3IFRIUkVFLk1hdHJpeDQoKSxcclxuXHJcbiAgICAgICAgbnVtcG9pbnRzID0gc2VnbWVudHMgKyAxLFxyXG4gICAgICAgIHRoZXRhLFxyXG4gICAgICAgIHNtYWxsZXN0LFxyXG5cclxuICAgICAgICB0eCwgdHksIHR6LFxyXG4gICAgICAgIGksIHU7XHJcblxyXG5cclxuICAgIC8vIGV4cG9zZSBpbnRlcm5hbHNcclxuICAgIHRoaXMudGFuZ2VudHMgPSB0YW5nZW50cztcclxuICAgIHRoaXMubm9ybWFscyA9IG5vcm1hbHM7XHJcbiAgICB0aGlzLmJpbm9ybWFscyA9IGJpbm9ybWFscztcclxuXHJcbiAgICAvLyBjb21wdXRlIHRoZSB0YW5nZW50IHZlY3RvcnMgZm9yIGVhY2ggc2VnbWVudCBvbiB0aGUgcGF0aFxyXG5cclxuICAgIGZvciAoIGkgPSAwOyBpIDwgbnVtcG9pbnRzOyBpICsrICkge1xyXG5cclxuICAgICAgICB1ID0gaSAvICggbnVtcG9pbnRzIC0gMSApO1xyXG5cclxuICAgICAgICB0YW5nZW50c1sgaSBdID0gcGF0aC5nZXRUYW5nZW50QXQoIHUgKTtcclxuICAgICAgICB0YW5nZW50c1sgaSBdLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBpbml0aWFsTm9ybWFsMygpO1xyXG5cclxuICAgIC8qXHJcbiAgICAgZnVuY3Rpb24gaW5pdGlhbE5vcm1hbDEobGFzdEJpbm9ybWFsKSB7XHJcbiAgICAgLy8gZml4ZWQgc3RhcnQgYmlub3JtYWwuIEhhcyBkYW5nZXJzIG9mIDAgdmVjdG9yc1xyXG4gICAgIG5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgYmlub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgIGlmIChsYXN0Qmlub3JtYWw9PT11bmRlZmluZWQpIGxhc3RCaW5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICk7XHJcbiAgICAgbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggbGFzdEJpbm9ybWFsLCB0YW5nZW50c1sgMCBdICkubm9ybWFsaXplKCk7XHJcbiAgICAgYmlub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWxzWyAwIF0gKS5ub3JtYWxpemUoKTtcclxuICAgICB9XHJcblxyXG4gICAgIGZ1bmN0aW9uIGluaXRpYWxOb3JtYWwyKCkge1xyXG5cclxuICAgICAvLyBUaGlzIHVzZXMgdGhlIEZyZW5ldC1TZXJyZXQgZm9ybXVsYSBmb3IgZGVyaXZpbmcgYmlub3JtYWxcclxuICAgICB2YXIgdDIgPSBwYXRoLmdldFRhbmdlbnRBdCggZXBzaWxvbiApO1xyXG5cclxuICAgICBub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpLnN1YlZlY3RvcnMoIHQyLCB0YW5nZW50c1sgMCBdICkubm9ybWFsaXplKCk7XHJcbiAgICAgYmlub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICk7XHJcblxyXG4gICAgIG5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIGJpbm9ybWFsc1sgMCBdLCB0YW5nZW50c1sgMCBdICkubm9ybWFsaXplKCk7IC8vIGxhc3QgYmlub3JtYWwgeCB0YW5nZW50XHJcbiAgICAgYmlub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWxzWyAwIF0gKS5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAgfVxyXG4gICAgICovXHJcblxyXG4gICAgZnVuY3Rpb24gaW5pdGlhbE5vcm1hbDMoKSB7XHJcblxyXG4gICAgICAgIC8vIHNlbGVjdCBhbiBpbml0aWFsIG5vcm1hbCB2ZWN0b3IgcGVycGVuZGljdWxhciB0byB0aGUgZmlyc3QgdGFuZ2VudCB2ZWN0b3IsXHJcbiAgICAgICAgLy8gYW5kIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHNtYWxsZXN0IHRhbmdlbnQgeHl6IGNvbXBvbmVudFxyXG5cclxuICAgICAgICBub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgIGJpbm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICBzbWFsbGVzdCA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgdHggPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS54ICk7XHJcbiAgICAgICAgdHkgPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS55ICk7XHJcbiAgICAgICAgdHogPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS56ICk7XHJcblxyXG4gICAgICAgIGlmICggdHggPD0gc21hbGxlc3QgKSB7XHJcblxyXG4gICAgICAgICAgICBzbWFsbGVzdCA9IHR4O1xyXG4gICAgICAgICAgICBub3JtYWwuc2V0KCAxLCAwLCAwICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCB0eSA8PSBzbWFsbGVzdCApIHtcclxuXHJcbiAgICAgICAgICAgIHNtYWxsZXN0ID0gdHk7XHJcbiAgICAgICAgICAgIG5vcm1hbC5zZXQoIDAsIDEsIDAgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIHR6IDw9IHNtYWxsZXN0ICkge1xyXG5cclxuICAgICAgICAgICAgbm9ybWFsLnNldCggMCwgMCwgMSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZlYy5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIG5vcm1hbCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICBub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCB2ZWMgKTtcclxuICAgICAgICBiaW5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIG5vcm1hbHNbIDAgXSApO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gY29tcHV0ZSB0aGUgc2xvd2x5LXZhcnlpbmcgbm9ybWFsIGFuZCBiaW5vcm1hbCB2ZWN0b3JzIGZvciBlYWNoIHNlZ21lbnQgb24gdGhlIHBhdGhcclxuXHJcbiAgICBmb3IgKCBpID0gMTsgaSA8IG51bXBvaW50czsgaSArKyApIHtcclxuXHJcbiAgICAgICAgbm9ybWFsc1sgaSBdID0gbm9ybWFsc1sgaSAtIDEgXS5jbG9uZSgpO1xyXG5cclxuICAgICAgICBiaW5vcm1hbHNbIGkgXSA9IGJpbm9ybWFsc1sgaSAtIDEgXS5jbG9uZSgpO1xyXG5cclxuICAgICAgICB2ZWMuY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgaSAtIDEgXSwgdGFuZ2VudHNbIGkgXSApO1xyXG5cclxuICAgICAgICBpZiAoIHZlYy5sZW5ndGgoKSA+IE51bWJlci5FUFNJTE9OICkge1xyXG5cclxuICAgICAgICAgICAgdmVjLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICAgICAgdGhldGEgPSBNYXRoLmFjb3MoIFRIUkVFLk1hdGguY2xhbXAoIHRhbmdlbnRzWyBpIC0gMSBdLmRvdCggdGFuZ2VudHNbIGkgXSApLCAtIDEsIDEgKSApOyAvLyBjbGFtcCBmb3IgZmxvYXRpbmcgcHQgZXJyb3JzXHJcblxyXG4gICAgICAgICAgICBub3JtYWxzWyBpIF0uYXBwbHlNYXRyaXg0KCBtYXQubWFrZVJvdGF0aW9uQXhpcyggdmVjLCB0aGV0YSApICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYmlub3JtYWxzWyBpIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgaSBdLCBub3JtYWxzWyBpIF0gKTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIGlmIHRoZSBjdXJ2ZSBpcyBjbG9zZWQsIHBvc3Rwcm9jZXNzIHRoZSB2ZWN0b3JzIHNvIHRoZSBmaXJzdCBhbmQgbGFzdCBub3JtYWwgdmVjdG9ycyBhcmUgdGhlIHNhbWVcclxuXHJcbiAgICBpZiAoIGNsb3NlZCApIHtcclxuXHJcbiAgICAgICAgdGhldGEgPSBNYXRoLmFjb3MoIFRIUkVFLk1hdGguY2xhbXAoIG5vcm1hbHNbIDAgXS5kb3QoIG5vcm1hbHNbIG51bXBvaW50cyAtIDEgXSApLCAtIDEsIDEgKSApO1xyXG4gICAgICAgIHRoZXRhIC89ICggbnVtcG9pbnRzIC0gMSApO1xyXG5cclxuICAgICAgICBpZiAoIHRhbmdlbnRzWyAwIF0uZG90KCB2ZWMuY3Jvc3NWZWN0b3JzKCBub3JtYWxzWyAwIF0sIG5vcm1hbHNbIG51bXBvaW50cyAtIDEgXSApICkgPiAwICkge1xyXG5cclxuICAgICAgICAgICAgdGhldGEgPSAtIHRoZXRhO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoIGkgPSAxOyBpIDwgbnVtcG9pbnRzOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgLy8gdHdpc3QgYSBsaXR0bGUuLi5cclxuICAgICAgICAgICAgbm9ybWFsc1sgaSBdLmFwcGx5TWF0cml4NCggbWF0Lm1ha2VSb3RhdGlvbkF4aXMoIHRhbmdlbnRzWyBpIF0sIHRoZXRhICogaSApICk7XHJcbiAgICAgICAgICAgIGJpbm9ybWFsc1sgaSBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGkgXSwgbm9ybWFsc1sgaSBdICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvUG9seWhlZHJvbkdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBjbG9ja3dvcmtnZWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL2Nsb2Nrd29ya2dlZWtcclxuICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICovXHJcblxyXG5USFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApIHtcclxuXHJcbiAgICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ1BvbHloZWRyb25HZW9tZXRyeSc7XHJcblxyXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xyXG4gICAgICAgIHZlcnRpY2VzOiB2ZXJ0aWNlcyxcclxuICAgICAgICBpbmRpY2VzOiBpbmRpY2VzLFxyXG4gICAgICAgIHJhZGl1czogcmFkaXVzLFxyXG4gICAgICAgIGRldGFpbDogZGV0YWlsXHJcbiAgICB9O1xyXG5cclxuICAgIHJhZGl1cyA9IHJhZGl1cyB8fCAxO1xyXG4gICAgZGV0YWlsID0gZGV0YWlsIHx8IDA7XHJcblxyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMyApIHtcclxuXHJcbiAgICAgICAgcHJlcGFyZSggbmV3IFRIUkVFLlZlY3RvcjMoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzWyBpICsgMSBdLCB2ZXJ0aWNlc1sgaSArIDIgXSApICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHZhciBwID0gdGhpcy52ZXJ0aWNlcztcclxuXHJcbiAgICB2YXIgZmFjZXMgPSBbXTtcclxuXHJcbiAgICBmb3IgKCB2YXIgaSA9IDAsIGogPSAwLCBsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICs9IDMsIGogKysgKSB7XHJcblxyXG4gICAgICAgIHZhciB2MSA9IHBbIGluZGljZXNbIGkgXSBdO1xyXG4gICAgICAgIHZhciB2MiA9IHBbIGluZGljZXNbIGkgKyAxIF0gXTtcclxuICAgICAgICB2YXIgdjMgPSBwWyBpbmRpY2VzWyBpICsgMiBdIF07XHJcblxyXG4gICAgICAgIGZhY2VzWyBqIF0gPSBuZXcgVEhSRUUuRmFjZTMoIHYxLmluZGV4LCB2Mi5pbmRleCwgdjMuaW5kZXgsIFsgdjEuY2xvbmUoKSwgdjIuY2xvbmUoKSwgdjMuY2xvbmUoKSBdLCB1bmRlZmluZWQsIGogKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNlbnRyb2lkID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICBzdWJkaXZpZGUoIGZhY2VzWyBpIF0sIGRldGFpbCApO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBmYWNlIHN0cmFkZGxlcyB0aGUgc2VhbVxyXG5cclxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIHZhciB1dnMgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXVsgaSBdO1xyXG5cclxuICAgICAgICB2YXIgeDAgPSB1dnNbIDAgXS54O1xyXG4gICAgICAgIHZhciB4MSA9IHV2c1sgMSBdLng7XHJcbiAgICAgICAgdmFyIHgyID0gdXZzWyAyIF0ueDtcclxuXHJcbiAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4KCB4MCwgeDEsIHgyICk7XHJcbiAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKCB4MCwgeDEsIHgyICk7XHJcblxyXG4gICAgICAgIGlmICggbWF4ID4gMC45ICYmIG1pbiA8IDAuMSApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIDAuOSBpcyBzb21ld2hhdCBhcmJpdHJhcnlcclxuXHJcbiAgICAgICAgICAgIGlmICggeDAgPCAwLjIgKSB1dnNbIDAgXS54ICs9IDE7XHJcbiAgICAgICAgICAgIGlmICggeDEgPCAwLjIgKSB1dnNbIDEgXS54ICs9IDE7XHJcbiAgICAgICAgICAgIGlmICggeDIgPCAwLjIgKSB1dnNbIDIgXS54ICs9IDE7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIEFwcGx5IHJhZGl1c1xyXG5cclxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgdGhpcy52ZXJ0aWNlc1sgaSBdLm11bHRpcGx5U2NhbGFyKCByYWRpdXMgKTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIE1lcmdlIHZlcnRpY2VzXHJcblxyXG4gICAgdGhpcy5tZXJnZVZlcnRpY2VzKCk7XHJcblxyXG4gICAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHJcbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggbmV3IFRIUkVFLlZlY3RvcjMoKSwgcmFkaXVzICk7XHJcblxyXG5cclxuICAgIC8vIFByb2plY3QgdmVjdG9yIG9udG8gc3BoZXJlJ3Mgc3VyZmFjZVxyXG5cclxuICAgIGZ1bmN0aW9uIHByZXBhcmUoIHZlY3RvciApIHtcclxuXHJcbiAgICAgICAgdmFyIHZlcnRleCA9IHZlY3Rvci5ub3JtYWxpemUoKS5jbG9uZSgpO1xyXG4gICAgICAgIHZlcnRleC5pbmRleCA9IHRoYXQudmVydGljZXMucHVzaCggdmVydGV4ICkgLSAxO1xyXG5cclxuICAgICAgICAvLyBUZXh0dXJlIGNvb3JkcyBhcmUgZXF1aXZhbGVudCB0byBtYXAgY29vcmRzLCBjYWxjdWxhdGUgYW5nbGUgYW5kIGNvbnZlcnQgdG8gZnJhY3Rpb24gb2YgYSBjaXJjbGUuXHJcblxyXG4gICAgICAgIHZhciB1ID0gYXppbXV0aCggdmVjdG9yICkgLyAyIC8gTWF0aC5QSSArIDAuNTtcclxuICAgICAgICB2YXIgdiA9IGluY2xpbmF0aW9uKCB2ZWN0b3IgKSAvIE1hdGguUEkgKyAwLjU7XHJcbiAgICAgICAgdmVydGV4LnV2ID0gbmV3IFRIUkVFLlZlY3RvcjIoIHUsIDEgLSB2ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB2ZXJ0ZXg7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBBcHByb3hpbWF0ZSBhIGN1cnZlZCBmYWNlIHdpdGggcmVjdXJzaXZlbHkgc3ViLWRpdmlkZWQgdHJpYW5nbGVzLlxyXG5cclxuICAgIGZ1bmN0aW9uIG1ha2UoIHYxLCB2MiwgdjMsIG1hdGVyaWFsSW5kZXggKSB7XHJcblxyXG4gICAgICAgIHZhciBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCB2MS5pbmRleCwgdjIuaW5kZXgsIHYzLmluZGV4LCBbIHYxLmNsb25lKCksIHYyLmNsb25lKCksIHYzLmNsb25lKCkgXSwgdW5kZWZpbmVkLCBtYXRlcmlhbEluZGV4ICk7XHJcbiAgICAgICAgdGhhdC5mYWNlcy5wdXNoKCBmYWNlICk7XHJcblxyXG4gICAgICAgIGNlbnRyb2lkLmNvcHkoIHYxICkuYWRkKCB2MiApLmFkZCggdjMgKS5kaXZpZGVTY2FsYXIoIDMgKTtcclxuXHJcbiAgICAgICAgdmFyIGF6aSA9IGF6aW11dGgoIGNlbnRyb2lkICk7XHJcblxyXG4gICAgICAgIHRoYXQuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFtcclxuICAgICAgICAgICAgY29ycmVjdFVWKCB2MS51diwgdjEsIGF6aSApLFxyXG4gICAgICAgICAgICBjb3JyZWN0VVYoIHYyLnV2LCB2MiwgYXppICksXHJcbiAgICAgICAgICAgIGNvcnJlY3RVViggdjMudXYsIHYzLCBhemkgKVxyXG4gICAgICAgIF0gKTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIEFuYWx5dGljYWxseSBzdWJkaXZpZGUgYSBmYWNlIHRvIHRoZSByZXF1aXJlZCBkZXRhaWwgbGV2ZWwuXHJcblxyXG4gICAgZnVuY3Rpb24gc3ViZGl2aWRlKCBmYWNlLCBkZXRhaWwgKSB7XHJcblxyXG4gICAgICAgIHZhciBjb2xzID0gTWF0aC5wb3coIDIsIGRldGFpbCApO1xyXG4gICAgICAgIHZhciBhID0gcHJlcGFyZSggdGhhdC52ZXJ0aWNlc1sgZmFjZS5hIF0gKTtcclxuICAgICAgICB2YXIgYiA9IHByZXBhcmUoIHRoYXQudmVydGljZXNbIGZhY2UuYiBdICk7XHJcbiAgICAgICAgdmFyIGMgPSBwcmVwYXJlKCB0aGF0LnZlcnRpY2VzWyBmYWNlLmMgXSApO1xyXG4gICAgICAgIHZhciB2ID0gW107XHJcblxyXG4gICAgICAgIHZhciBtYXRlcmlhbEluZGV4ID0gZmFjZS5tYXRlcmlhbEluZGV4O1xyXG5cclxuICAgICAgICAvLyBDb25zdHJ1Y3QgYWxsIG9mIHRoZSB2ZXJ0aWNlcyBmb3IgdGhpcyBzdWJkaXZpc2lvbi5cclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8PSBjb2xzOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdlsgaSBdID0gW107XHJcblxyXG4gICAgICAgICAgICB2YXIgYWogPSBwcmVwYXJlKCBhLmNsb25lKCkubGVycCggYywgaSAvIGNvbHMgKSApO1xyXG4gICAgICAgICAgICB2YXIgYmogPSBwcmVwYXJlKCBiLmNsb25lKCkubGVycCggYywgaSAvIGNvbHMgKSApO1xyXG4gICAgICAgICAgICB2YXIgcm93cyA9IGNvbHMgLSBpO1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGogPSAwOyBqIDw9IHJvd3M7IGogKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBqID09PSAwICYmIGkgPT09IGNvbHMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZbIGkgXVsgaiBdID0gYWo7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdlsgaSBdWyBqIF0gPSBwcmVwYXJlKCBhai5jbG9uZSgpLmxlcnAoIGJqLCBqIC8gcm93cyApICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENvbnN0cnVjdCBhbGwgb2YgdGhlIGZhY2VzLlxyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBjb2xzIDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IDIgKiAoIGNvbHMgLSBpICkgLSAxOyBqICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBrID0gTWF0aC5mbG9vciggaiAvIDIgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGogJSAyID09PSAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBtYWtlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2WyBpIF1bIGsgKyAxIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZbIGkgKyAxIF1bIGsgXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdlsgaSBdWyBrIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsSW5kZXhcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG1ha2UoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZbIGkgXVsgayArIDEgXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdlsgaSArIDEgXVsgayArIDEgXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdlsgaSArIDEgXVsgayBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbEluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIEFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzLCBjb3VudGVyLWNsb2Nrd2lzZSB3aGVuIGxvb2tpbmcgZnJvbSBhYm92ZS5cclxuXHJcbiAgICBmdW5jdGlvbiBhemltdXRoKCB2ZWN0b3IgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKCB2ZWN0b3IueiwgLSB2ZWN0b3IueCApO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gQW5nbGUgYWJvdmUgdGhlIFhaIHBsYW5lLlxyXG5cclxuICAgIGZ1bmN0aW9uIGluY2xpbmF0aW9uKCB2ZWN0b3IgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKCAtIHZlY3Rvci55LCBNYXRoLnNxcnQoICggdmVjdG9yLnggKiB2ZWN0b3IueCApICsgKCB2ZWN0b3IueiAqIHZlY3Rvci56ICkgKSApO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gVGV4dHVyZSBmaXhpbmcgaGVscGVyLiBTcGhlcmVzIGhhdmUgc29tZSBvZGQgYmVoYXZpb3Vycy5cclxuXHJcbiAgICBmdW5jdGlvbiBjb3JyZWN0VVYoIHV2LCB2ZWN0b3IsIGF6aW11dGggKSB7XHJcblxyXG4gICAgICAgIGlmICggKCBhemltdXRoIDwgMCApICYmICggdXYueCA9PT0gMSApICkgdXYgPSBuZXcgVEhSRUUuVmVjdG9yMiggdXYueCAtIDEsIHV2LnkgKTtcclxuICAgICAgICBpZiAoICggdmVjdG9yLnggPT09IDAgKSAmJiAoIHZlY3Rvci56ID09PSAwICkgKSB1diA9IG5ldyBUSFJFRS5WZWN0b3IyKCBhemltdXRoIC8gMiAvIE1hdGguUEkgKyAwLjUsIHV2LnkgKTtcclxuICAgICAgICByZXR1cm4gdXYuY2xvbmUoKTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxufTtcclxuXHJcblRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeTtcclxuXHJcblRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkoXHJcbiAgICAgICAgcGFyYW1ldGVycy52ZXJ0aWNlcyxcclxuICAgICAgICBwYXJhbWV0ZXJzLmluZGljZXMsXHJcbiAgICAgICAgcGFyYW1ldGVycy5yYWRpdXMsXHJcbiAgICAgICAgcGFyYW1ldGVycy5kZXRhaWxcclxuICAgICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvRG9kZWNhaGVkcm9uR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIEFiZSBQYXpvcyAvIGh0dHBzOi8vaGFtb2lkLmNvbVxyXG4gKi9cclxuXHJcblRIUkVFLkRvZGVjYWhlZHJvbkdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIGRldGFpbCApIHtcclxuXHJcbiAgICB2YXIgdCA9ICggMSArIE1hdGguc3FydCggNSApICkgLyAyO1xyXG4gICAgdmFyIHIgPSAxIC8gdDtcclxuXHJcbiAgICB2YXIgdmVydGljZXMgPSBbXHJcblxyXG4gICAgICAgIC8vICjvv70xLCDvv70xLCDvv70xKVxyXG4gICAgICAgIC0gMSwgLSAxLCAtIDEsICAgIC0gMSwgLSAxLCAgMSxcclxuICAgICAgICAtIDEsICAxLCAtIDEsICAgIC0gMSwgIDEsICAxLFxyXG4gICAgICAgIDEsIC0gMSwgLSAxLCAgICAgMSwgLSAxLCAgMSxcclxuICAgICAgICAxLCAgMSwgLSAxLCAgICAgMSwgIDEsICAxLFxyXG5cclxuICAgICAgICAvLyAoMCwg77+9MS8/LCDvv70/KVxyXG4gICAgICAgIDAsIC0gciwgLSB0LCAgICAgMCwgLSByLCAgdCxcclxuICAgICAgICAwLCAgciwgLSB0LCAgICAgMCwgIHIsICB0LFxyXG5cclxuICAgICAgICAvLyAo77+9MS8/LCDvv70/LCAwKVxyXG4gICAgICAgIC0gciwgLSB0LCAgMCwgICAgLSByLCAgdCwgIDAsXHJcbiAgICAgICAgciwgLSB0LCAgMCwgICAgIHIsICB0LCAgMCxcclxuXHJcbiAgICAgICAgLy8gKO+/vT8sIDAsIO+/vTEvPylcclxuICAgICAgICAtIHQsICAwLCAtIHIsICAgICB0LCAgMCwgLSByLFxyXG4gICAgICAgIC0gdCwgIDAsICByLCAgICAgdCwgIDAsICByXHJcbiAgICBdO1xyXG5cclxuICAgIHZhciBpbmRpY2VzID0gW1xyXG4gICAgICAgIDMsIDExLCAgNywgICAgICAzLCAgNywgMTUsICAgICAgMywgMTUsIDEzLFxyXG4gICAgICAgIDcsIDE5LCAxNywgICAgICA3LCAxNywgIDYsICAgICAgNywgIDYsIDE1LFxyXG4gICAgICAgIDE3LCAgNCwgIDgsICAgICAxNywgIDgsIDEwLCAgICAgMTcsIDEwLCAgNixcclxuICAgICAgICA4LCAgMCwgMTYsICAgICAgOCwgMTYsICAyLCAgICAgIDgsICAyLCAxMCxcclxuICAgICAgICAwLCAxMiwgIDEsICAgICAgMCwgIDEsIDE4LCAgICAgIDAsIDE4LCAxNixcclxuICAgICAgICA2LCAxMCwgIDIsICAgICAgNiwgIDIsIDEzLCAgICAgIDYsIDEzLCAxNSxcclxuICAgICAgICAyLCAxNiwgMTgsICAgICAgMiwgMTgsICAzLCAgICAgIDIsICAzLCAxMyxcclxuICAgICAgICAxOCwgIDEsICA5LCAgICAgMTgsICA5LCAxMSwgICAgIDE4LCAxMSwgIDMsXHJcbiAgICAgICAgNCwgMTQsIDEyLCAgICAgIDQsIDEyLCAgMCwgICAgICA0LCAgMCwgIDgsXHJcbiAgICAgICAgMTEsICA5LCAgNSwgICAgIDExLCAgNSwgMTksICAgICAxMSwgMTksICA3LFxyXG4gICAgICAgIDE5LCAgNSwgMTQsICAgICAxOSwgMTQsICA0LCAgICAgMTksICA0LCAxNyxcclxuICAgICAgICAxLCAxMiwgMTQsICAgICAgMSwgMTQsICA1LCAgICAgIDEsICA1LCAgOVxyXG4gICAgXTtcclxuXHJcbiAgICBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkuY2FsbCggdGhpcywgdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ0RvZGVjYWhlZHJvbkdlb21ldHJ5JztcclxuXHJcbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgcmFkaXVzOiByYWRpdXMsXHJcbiAgICAgICAgZGV0YWlsOiBkZXRhaWxcclxuICAgIH07XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRG9kZWNhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeTtcclxuXHJcblRIUkVFLkRvZGVjYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcclxuXHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLkRvZGVjYWhlZHJvbkdlb21ldHJ5KFxyXG4gICAgICAgIHBhcmFtZXRlcnMucmFkaXVzLFxyXG4gICAgICAgIHBhcmFtZXRlcnMuZGV0YWlsXHJcbiAgICApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0ljb3NhaGVkcm9uR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIHRpbW90aHlwcmF0bGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL3RpbW90aHlwcmF0bGV5XHJcbiAqL1xyXG5cclxuVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCBkZXRhaWwgKSB7XHJcblxyXG4gICAgdmFyIHQgPSAoIDEgKyBNYXRoLnNxcnQoIDUgKSApIC8gMjtcclxuXHJcbiAgICB2YXIgdmVydGljZXMgPSBbXHJcbiAgICAgICAgLSAxLCAgdCwgIDAsICAgIDEsICB0LCAgMCwgICAtIDEsIC0gdCwgIDAsICAgIDEsIC0gdCwgIDAsXHJcbiAgICAgICAgMCwgLSAxLCAgdCwgICAgMCwgIDEsICB0LCAgICAwLCAtIDEsIC0gdCwgICAgMCwgIDEsIC0gdCxcclxuICAgICAgICB0LCAgMCwgLSAxLCAgICB0LCAgMCwgIDEsICAgLSB0LCAgMCwgLSAxLCAgIC0gdCwgIDAsICAxXHJcbiAgICBdO1xyXG5cclxuICAgIHZhciBpbmRpY2VzID0gW1xyXG4gICAgICAgIDAsIDExLCAgNSwgICAgMCwgIDUsICAxLCAgICAwLCAgMSwgIDcsICAgIDAsICA3LCAxMCwgICAgMCwgMTAsIDExLFxyXG4gICAgICAgIDEsICA1LCAgOSwgICAgNSwgMTEsICA0LCAgIDExLCAxMCwgIDIsICAgMTAsICA3LCAgNiwgICAgNywgIDEsICA4LFxyXG4gICAgICAgIDMsICA5LCAgNCwgICAgMywgIDQsICAyLCAgICAzLCAgMiwgIDYsICAgIDMsICA2LCAgOCwgICAgMywgIDgsICA5LFxyXG4gICAgICAgIDQsICA5LCAgNSwgICAgMiwgIDQsIDExLCAgICA2LCAgMiwgMTAsICAgIDgsICA2LCAgNywgICAgOSwgIDgsICAxXHJcbiAgICBdO1xyXG5cclxuICAgIFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnSWNvc2FoZWRyb25HZW9tZXRyeSc7XHJcblxyXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xyXG4gICAgICAgIHJhZGl1czogcmFkaXVzLFxyXG4gICAgICAgIGRldGFpbDogZGV0YWlsXHJcbiAgICB9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnk7XHJcblxyXG5USFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcclxuXHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkoXHJcbiAgICAgICAgcGFyYW1ldGVycy5yYWRpdXMsXHJcbiAgICAgICAgcGFyYW1ldGVycy5kZXRhaWxcclxuICAgICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvT2N0YWhlZHJvbkdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxyXG4gKi9cclxuXHJcblRIUkVFLk9jdGFoZWRyb25HZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCBkZXRhaWwgKSB7XHJcblxyXG4gICAgdmFyIHZlcnRpY2VzID0gW1xyXG4gICAgICAgIDEsIDAsIDAsICAgLSAxLCAwLCAwLCAgICAwLCAxLCAwLCAgICAwLCAtIDEsIDAsICAgIDAsIDAsIDEsICAgIDAsIDAsIC0gMVxyXG4gICAgXTtcclxuXHJcbiAgICB2YXIgaW5kaWNlcyA9IFtcclxuICAgICAgICAwLCAyLCA0LCAgICAwLCA0LCAzLCAgICAwLCAzLCA1LCAgICAwLCA1LCAyLCAgICAxLCAyLCA1LCAgICAxLCA1LCAzLCAgICAxLCAzLCA0LCAgICAxLCA0LCAyXHJcbiAgICBdO1xyXG5cclxuICAgIFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnT2N0YWhlZHJvbkdlb21ldHJ5JztcclxuXHJcbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgcmFkaXVzOiByYWRpdXMsXHJcbiAgICAgICAgZGV0YWlsOiBkZXRhaWxcclxuICAgIH07XHJcblxyXG59O1xyXG5cclxuVEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk9jdGFoZWRyb25HZW9tZXRyeTtcclxuXHJcblRIUkVFLk9jdGFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5PY3RhaGVkcm9uR2VvbWV0cnkoXHJcbiAgICAgICAgcGFyYW1ldGVycy5yYWRpdXMsXHJcbiAgICAgICAgcGFyYW1ldGVycy5kZXRhaWxcclxuICAgICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvVGV0cmFoZWRyb25HZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcclxuICovXHJcblxyXG5USFJFRS5UZXRyYWhlZHJvbkdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIGRldGFpbCApIHtcclxuXHJcbiAgICB2YXIgdmVydGljZXMgPSBbXHJcbiAgICAgICAgMSwgIDEsICAxLCAgIC0gMSwgLSAxLCAgMSwgICAtIDEsICAxLCAtIDEsICAgIDEsIC0gMSwgLSAxXHJcbiAgICBdO1xyXG5cclxuICAgIHZhciBpbmRpY2VzID0gW1xyXG4gICAgICAgIDIsICAxLCAgMCwgICAgMCwgIDMsICAyLCAgICAxLCAgMywgIDAsICAgIDIsICAzLCAgMVxyXG4gICAgXTtcclxuXHJcbiAgICBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkuY2FsbCggdGhpcywgdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ1RldHJhaGVkcm9uR2VvbWV0cnknO1xyXG5cclxuICAgIHRoaXMucGFyYW1ldGVycyA9IHtcclxuICAgICAgICByYWRpdXM6IHJhZGl1cyxcclxuICAgICAgICBkZXRhaWw6IGRldGFpbFxyXG4gICAgfTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5UZXRyYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5UZXRyYWhlZHJvbkdlb21ldHJ5O1xyXG5cclxuVEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5UZXRyYWhlZHJvbkdlb21ldHJ5KFxyXG4gICAgICAgIHBhcmFtZXRlcnMucmFkaXVzLFxyXG4gICAgICAgIHBhcmFtZXRlcnMuZGV0YWlsXHJcbiAgICApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1BhcmFtZXRyaWNHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHBzOi8vZ2l0aHViLmNvbS96ejg1XHJcbiAqIFBhcmFtZXRyaWMgU3VyZmFjZXMgR2VvbWV0cnlcclxuICogYmFzZWQgb24gdGhlIGJyaWxsaWFudCBhcnRpY2xlIGJ5IEBwcmlkZW91dCBodHRwOi8vcHJpZGVvdXQubmV0L2Jsb2cvP3A9NDRcclxuICpcclxuICogbmV3IFRIUkVFLlBhcmFtZXRyaWNHZW9tZXRyeSggcGFyYW1ldHJpY0Z1bmN0aW9uLCB1U2VnbWVudHMsIHlTZWdlbWVudHMgKTtcclxuICpcclxuICovXHJcblxyXG5USFJFRS5QYXJhbWV0cmljR2VvbWV0cnkgPSBmdW5jdGlvbiAoIGZ1bmMsIHNsaWNlcywgc3RhY2tzICkge1xyXG5cclxuICAgIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnUGFyYW1ldHJpY0dlb21ldHJ5JztcclxuXHJcbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgZnVuYzogZnVuYyxcclxuICAgICAgICBzbGljZXM6IHNsaWNlcyxcclxuICAgICAgICBzdGFja3M6IHN0YWNrc1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgdmVydHMgPSB0aGlzLnZlcnRpY2VzO1xyXG4gICAgdmFyIGZhY2VzID0gdGhpcy5mYWNlcztcclxuICAgIHZhciB1dnMgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXTtcclxuXHJcbiAgICB2YXIgaSwgaiwgcDtcclxuICAgIHZhciB1LCB2O1xyXG5cclxuICAgIHZhciBzbGljZUNvdW50ID0gc2xpY2VzICsgMTtcclxuXHJcbiAgICBmb3IgKCBpID0gMDsgaSA8PSBzdGFja3M7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIHYgPSBpIC8gc3RhY2tzO1xyXG5cclxuICAgICAgICBmb3IgKCBqID0gMDsgaiA8PSBzbGljZXM7IGogKysgKSB7XHJcblxyXG4gICAgICAgICAgICB1ID0gaiAvIHNsaWNlcztcclxuXHJcbiAgICAgICAgICAgIHAgPSBmdW5jKCB1LCB2ICk7XHJcbiAgICAgICAgICAgIHZlcnRzLnB1c2goIHAgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICB2YXIgYSwgYiwgYywgZDtcclxuICAgIHZhciB1dmEsIHV2YiwgdXZjLCB1dmQ7XHJcblxyXG4gICAgZm9yICggaSA9IDA7IGkgPCBzdGFja3M7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIGZvciAoIGogPSAwOyBqIDwgc2xpY2VzOyBqICsrICkge1xyXG5cclxuICAgICAgICAgICAgYSA9IGkgKiBzbGljZUNvdW50ICsgajtcclxuICAgICAgICAgICAgYiA9IGkgKiBzbGljZUNvdW50ICsgaiArIDE7XHJcbiAgICAgICAgICAgIGMgPSAoIGkgKyAxICkgKiBzbGljZUNvdW50ICsgaiArIDE7XHJcbiAgICAgICAgICAgIGQgPSAoIGkgKyAxICkgKiBzbGljZUNvdW50ICsgajtcclxuXHJcbiAgICAgICAgICAgIHV2YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBqIC8gc2xpY2VzLCBpIC8gc3RhY2tzICk7XHJcbiAgICAgICAgICAgIHV2YiA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGogKyAxICkgLyBzbGljZXMsIGkgLyBzdGFja3MgKTtcclxuICAgICAgICAgICAgdXZjID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaiArIDEgKSAvIHNsaWNlcywgKCBpICsgMSApIC8gc3RhY2tzICk7XHJcbiAgICAgICAgICAgIHV2ZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCBqIC8gc2xpY2VzLCAoIGkgKyAxICkgLyBzdGFja3MgKTtcclxuXHJcbiAgICAgICAgICAgIGZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCApICk7XHJcbiAgICAgICAgICAgIHV2cy5wdXNoKCBbIHV2YSwgdXZiLCB1dmQgXSApO1xyXG5cclxuICAgICAgICAgICAgZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkICkgKTtcclxuICAgICAgICAgICAgdXZzLnB1c2goIFsgdXZiLmNsb25lKCksIHV2YywgdXZkLmNsb25lKCkgXSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vIGNvbnNvbGUubG9nKHRoaXMpO1xyXG5cclxuICAgIC8vIG1hZ2ljIGJ1bGxldFxyXG4gICAgLy8gdmFyIGRpZmYgPSB0aGlzLm1lcmdlVmVydGljZXMoKTtcclxuICAgIC8vIGNvbnNvbGUubG9nKCdyZW1vdmVkICcsIGRpZmYsICcgdmVydGljZXMgYnkgbWVyZ2luZycpO1xyXG5cclxuICAgIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcbiAgICB0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGFyYW1ldHJpY0dlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5QYXJhbWV0cmljR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUGFyYW1ldHJpY0dlb21ldHJ5O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvV2lyZWZyYW1lR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLldpcmVmcmFtZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcclxuXHJcbiAgICBUSFJFRS5CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdmFyIGVkZ2UgPSBbIDAsIDAgXSwgaGFzaCA9IHt9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHNvcnRGdW5jdGlvbiggYSwgYiApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIGEgLSBiO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB2YXIga2V5cyA9IFsgJ2EnLCAnYicsICdjJyBdO1xyXG5cclxuICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcclxuXHJcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XHJcbiAgICAgICAgdmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XHJcbiAgICAgICAgdmFyIG51bUVkZ2VzID0gMDtcclxuXHJcbiAgICAgICAgLy8gYWxsb2NhdGUgbWF4aW1hbCBzaXplXHJcbiAgICAgICAgdmFyIGVkZ2VzID0gbmV3IFVpbnQzMkFycmF5KCA2ICogZmFjZXMubGVuZ3RoICk7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgZmFjZSA9IGZhY2VzWyBpIF07XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCAzOyBqICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGVkZ2VbIDAgXSA9IGZhY2VbIGtleXNbIGogXSBdO1xyXG4gICAgICAgICAgICAgICAgZWRnZVsgMSBdID0gZmFjZVsga2V5c1sgKCBqICsgMSApICUgMyBdIF07XHJcbiAgICAgICAgICAgICAgICBlZGdlLnNvcnQoIHNvcnRGdW5jdGlvbiApO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBlZGdlLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBoYXNoWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBlZGdlc1sgMiAqIG51bUVkZ2VzIF0gPSBlZGdlWyAwIF07XHJcbiAgICAgICAgICAgICAgICAgICAgZWRnZXNbIDIgKiBudW1FZGdlcyArIDEgXSA9IGVkZ2VbIDEgXTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNoWyBrZXkgXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgbnVtRWRnZXMgKys7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KCBudW1FZGdlcyAqIDIgKiAzICk7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IG51bUVkZ2VzOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IDI7IGogKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHZlcnRleCA9IHZlcnRpY2VzWyBlZGdlcyBbIDIgKiBpICsgaiBdIF07XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gNiAqIGkgKyAzICogajtcclxuICAgICAgICAgICAgICAgIGNvb3Jkc1sgaW5kZXggKyAwIF0gPSB2ZXJ0ZXgueDtcclxuICAgICAgICAgICAgICAgIGNvb3Jkc1sgaW5kZXggKyAxIF0gPSB2ZXJ0ZXgueTtcclxuICAgICAgICAgICAgICAgIGNvb3Jkc1sgaW5kZXggKyAyIF0gPSB2ZXJ0ZXguejtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggY29vcmRzLCAzICkgKTtcclxuXHJcbiAgICB9IGVsc2UgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xyXG5cclxuICAgICAgICBpZiAoIGdlb21ldHJ5LmluZGV4ICE9PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgLy8gSW5kZXhlZCBCdWZmZXJHZW9tZXRyeVxyXG5cclxuICAgICAgICAgICAgdmFyIGluZGljZXMgPSBnZW9tZXRyeS5pbmRleC5hcnJheTtcclxuICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuICAgICAgICAgICAgdmFyIGRyYXdjYWxscyA9IGdlb21ldHJ5LmRyYXdjYWxscztcclxuICAgICAgICAgICAgdmFyIG51bUVkZ2VzID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmICggZHJhd2NhbGxzLmxlbmd0aCA9PT0gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS5hZGRHcm91cCggMCwgaW5kaWNlcy5sZW5ndGggKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGFsbG9jYXRlIG1heGltYWwgc2l6ZVxyXG4gICAgICAgICAgICB2YXIgZWRnZXMgPSBuZXcgVWludDMyQXJyYXkoIDIgKiBpbmRpY2VzLmxlbmd0aCApO1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIG8gPSAwLCBvbCA9IGRyYXdjYWxscy5sZW5ndGg7IG8gPCBvbDsgKysgbyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZHJhd2NhbGwgPSBkcmF3Y2FsbHNbIG8gXTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBkcmF3Y2FsbC5zdGFydDtcclxuICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IGRyYXdjYWxsLmNvdW50O1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gc3RhcnQsIGlsID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsOyBpICs9IDMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IDM7IGogKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlWyAwIF0gPSBpbmRpY2VzWyBpICsgaiBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlWyAxIF0gPSBpbmRpY2VzWyBpICsgKCBqICsgMSApICUgMyBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlLnNvcnQoIHNvcnRGdW5jdGlvbiApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGVkZ2UudG9TdHJpbmcoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaGFzaFsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGdlc1sgMiAqIG51bUVkZ2VzIF0gPSBlZGdlWyAwIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGdlc1sgMiAqIG51bUVkZ2VzICsgMSBdID0gZWRnZVsgMSBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzaFsga2V5IF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtRWRnZXMgKys7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgY29vcmRzID0gbmV3IEZsb2F0MzJBcnJheSggbnVtRWRnZXMgKiAyICogMyApO1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gbnVtRWRnZXM7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IDI7IGogKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IDYgKiBpICsgMyAqIGo7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4MiA9IGVkZ2VzWyAyICogaSArIGogXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzWyBpbmRleCArIDAgXSA9IHZlcnRpY2VzLmdldFgoIGluZGV4MiApO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkc1sgaW5kZXggKyAxIF0gPSB2ZXJ0aWNlcy5nZXRZKCBpbmRleDIgKTtcclxuICAgICAgICAgICAgICAgICAgICBjb29yZHNbIGluZGV4ICsgMiBdID0gdmVydGljZXMuZ2V0WiggaW5kZXgyICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGNvb3JkcywgMyApICk7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAvLyBub24taW5kZXhlZCBCdWZmZXJHZW9tZXRyeVxyXG5cclxuICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcclxuICAgICAgICAgICAgdmFyIG51bUVkZ2VzID0gdmVydGljZXMubGVuZ3RoIC8gMztcclxuICAgICAgICAgICAgdmFyIG51bVRyaXMgPSBudW1FZGdlcyAvIDM7XHJcblxyXG4gICAgICAgICAgICB2YXIgY29vcmRzID0gbmV3IEZsb2F0MzJBcnJheSggbnVtRWRnZXMgKiAyICogMyApO1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gbnVtVHJpczsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwgMzsgaiArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gMTggKiBpICsgNiAqIGo7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleDEgPSA5ICogaSArIDMgKiBqO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkc1sgaW5kZXggKyAwIF0gPSB2ZXJ0aWNlc1sgaW5kZXgxIF07XHJcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzWyBpbmRleCArIDEgXSA9IHZlcnRpY2VzWyBpbmRleDEgKyAxIF07XHJcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzWyBpbmRleCArIDIgXSA9IHZlcnRpY2VzWyBpbmRleDEgKyAyIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleDIgPSA5ICogaSArIDMgKiAoICggaiArIDEgKSAlIDMgKTtcclxuICAgICAgICAgICAgICAgICAgICBjb29yZHNbIGluZGV4ICsgMyBdID0gdmVydGljZXNbIGluZGV4MiBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkc1sgaW5kZXggKyA0IF0gPSB2ZXJ0aWNlc1sgaW5kZXgyICsgMSBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkc1sgaW5kZXggKyA1IF0gPSB2ZXJ0aWNlc1sgaW5kZXgyICsgMiBdO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb29yZHMsIDMgKSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcblRIUkVFLldpcmVmcmFtZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5XaXJlZnJhbWVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5XaXJlZnJhbWVHZW9tZXRyeTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0F4aXNIZWxwZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIHNyb3VjaGVyYXkgLyBodHRwOi8vc3JvdWNoZXJheS5vcmcvXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQXhpc0hlbHBlciA9IGZ1bmN0aW9uICggc2l6ZSApIHtcclxuXHJcbiAgICBzaXplID0gc2l6ZSB8fCAxO1xyXG5cclxuICAgIHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcclxuICAgICAgICAwLCAwLCAwLCAgc2l6ZSwgMCwgMCxcclxuICAgICAgICAwLCAwLCAwLCAgMCwgc2l6ZSwgMCxcclxuICAgICAgICAwLCAwLCAwLCAgMCwgMCwgc2l6ZVxyXG4gICAgXSApO1xyXG5cclxuICAgIHZhciBjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXHJcbiAgICAgICAgMSwgMCwgMCwgIDEsIDAuNiwgMCxcclxuICAgICAgICAwLCAxLCAwLCAgMC42LCAxLCAwLFxyXG4gICAgICAgIDAsIDAsIDEsICAwLCAwLjYsIDFcclxuICAgIF0gKTtcclxuXHJcbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcclxuICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xyXG4gICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKSApO1xyXG5cclxuICAgIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLlZlcnRleENvbG9ycyB9ICk7XHJcblxyXG4gICAgVEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF4aXNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xyXG5USFJFRS5BeGlzSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkF4aXNIZWxwZXI7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9BcnJvd0hlbHBlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vZ2l0aHViLmNvbS96ejg1XHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICpcclxuICogQ3JlYXRlcyBhbiBhcnJvdyBmb3IgdmlzdWFsaXppbmcgZGlyZWN0aW9uc1xyXG4gKlxyXG4gKiBQYXJhbWV0ZXJzOlxyXG4gKiAgZGlyIC0gVmVjdG9yM1xyXG4gKiAgb3JpZ2luIC0gVmVjdG9yM1xyXG4gKiAgbGVuZ3RoIC0gTnVtYmVyXHJcbiAqICBjb2xvciAtIGNvbG9yIGluIGhleCB2YWx1ZVxyXG4gKiAgaGVhZExlbmd0aCAtIE51bWJlclxyXG4gKiAgaGVhZFdpZHRoIC0gTnVtYmVyXHJcbiAqL1xyXG5cclxuVEhSRUUuQXJyb3dIZWxwZXIgPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgbGluZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcbiAgICBsaW5lR2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDAgKSwgbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKSApO1xyXG5cclxuICAgIHZhciBjb25lR2VvbWV0cnkgPSBuZXcgVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeSggMCwgMC41LCAxLCA1LCAxICk7XHJcbiAgICBjb25lR2VvbWV0cnkudHJhbnNsYXRlKCAwLCAtIDAuNSwgMCApO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiBBcnJvd0hlbHBlciggZGlyLCBvcmlnaW4sIGxlbmd0aCwgY29sb3IsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCApIHtcclxuXHJcbiAgICAgICAgLy8gZGlyIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxyXG5cclxuICAgICAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgICAgIGlmICggY29sb3IgPT09IHVuZGVmaW5lZCApIGNvbG9yID0gMHhmZmZmMDA7XHJcbiAgICAgICAgaWYgKCBsZW5ndGggPT09IHVuZGVmaW5lZCApIGxlbmd0aCA9IDE7XHJcbiAgICAgICAgaWYgKCBoZWFkTGVuZ3RoID09PSB1bmRlZmluZWQgKSBoZWFkTGVuZ3RoID0gMC4yICogbGVuZ3RoO1xyXG4gICAgICAgIGlmICggaGVhZFdpZHRoID09PSB1bmRlZmluZWQgKSBoZWFkV2lkdGggPSAwLjIgKiBoZWFkTGVuZ3RoO1xyXG5cclxuICAgICAgICB0aGlzLnBvc2l0aW9uLmNvcHkoIG9yaWdpbiApO1xyXG5cclxuICAgICAgICBpZiAoIGhlYWRMZW5ndGggPCBsZW5ndGggKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGluZSA9IG5ldyBUSFJFRS5MaW5lKCBsaW5lR2VvbWV0cnksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IgfSApICk7XHJcbiAgICAgICAgICAgIHRoaXMubGluZS5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKCB0aGlzLmxpbmUgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY29uZSA9IG5ldyBUSFJFRS5NZXNoKCBjb25lR2VvbWV0cnksIG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IgfSApICk7XHJcbiAgICAgICAgdGhpcy5jb25lLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmFkZCggdGhpcy5jb25lICk7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0RGlyZWN0aW9uKCBkaXIgKTtcclxuICAgICAgICB0aGlzLnNldExlbmd0aCggbGVuZ3RoLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKTtcclxuXHJcbiAgICB9XHJcblxyXG59KCkgKTtcclxuXHJcblRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5USFJFRS5BcnJvd0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5BcnJvd0hlbHBlcjtcclxuXHJcblRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZS5zZXREaXJlY3Rpb24gPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgYXhpcyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICB2YXIgcmFkaWFucztcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gc2V0RGlyZWN0aW9uKCBkaXIgKSB7XHJcblxyXG4gICAgICAgIC8vIGRpciBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcclxuXHJcbiAgICAgICAgaWYgKCBkaXIueSA+IDAuOTk5OTkgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnF1YXRlcm5pb24uc2V0KCAwLCAwLCAwLCAxICk7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIGRpci55IDwgLSAwLjk5OTk5ICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5xdWF0ZXJuaW9uLnNldCggMSwgMCwgMCwgMCApO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgYXhpcy5zZXQoIGRpci56LCAwLCAtIGRpci54ICkubm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgICAgICByYWRpYW5zID0gTWF0aC5hY29zKCBkaXIueSApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIHJhZGlhbnMgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG59KCkgKTtcclxuXHJcblRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZS5zZXRMZW5ndGggPSBmdW5jdGlvbiAoIGxlbmd0aCwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICkge1xyXG5cclxuICAgIGlmICggaGVhZExlbmd0aCA9PT0gdW5kZWZpbmVkICkgaGVhZExlbmd0aCA9IDAuMiAqIGxlbmd0aDtcclxuICAgIGlmICggaGVhZFdpZHRoID09PSB1bmRlZmluZWQgKSBoZWFkV2lkdGggPSAwLjIgKiBoZWFkTGVuZ3RoO1xyXG5cclxuICAgIGlmICggaGVhZExlbmd0aCA8IGxlbmd0aCApe1xyXG4gICAgICAgIHRoaXMubGluZS5zY2FsZS5zZXQoIDEsIGxlbmd0aCAtIGhlYWRMZW5ndGgsIDEgKTtcclxuICAgICAgICB0aGlzLmxpbmUudXBkYXRlTWF0cml4KCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jb25lLnNjYWxlLnNldCggaGVhZFdpZHRoLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKTtcclxuICAgIHRoaXMuY29uZS5wb3NpdGlvbi55ID0gbGVuZ3RoO1xyXG4gICAgdGhpcy5jb25lLnVwZGF0ZU1hdHJpeCgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZS5zZXRDb2xvciA9IGZ1bmN0aW9uICggY29sb3IgKSB7XHJcblxyXG4gICAgaWYgKCB0aGlzLmxpbmUgIT09IHVuZGVmaW5lZCApIHRoaXMubGluZS5tYXRlcmlhbC5jb2xvci5zZXQoIGNvbG9yICk7XHJcbiAgICB0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3Iuc2V0KCBjb2xvciApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0JveEhlbHBlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQm94SGVscGVyID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG4gICAgdmFyIGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoIFsgMCwgMSwgMSwgMiwgMiwgMywgMywgMCwgNCwgNSwgNSwgNiwgNiwgNywgNywgNCwgMCwgNCwgMSwgNSwgMiwgNiwgMywgNyBdICk7XHJcbiAgICB2YXIgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSggOCAqIDMgKTtcclxuXHJcbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcclxuICAgIGdlb21ldHJ5LnNldEluZGV4KCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBpbmRpY2VzLCAxICkgKTtcclxuICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zLCAzICkgKTtcclxuXHJcbiAgICBUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZmZmMDAgfSApICk7XHJcblxyXG4gICAgaWYgKCBvYmplY3QgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGUoIG9iamVjdCApO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Cb3hIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xyXG5USFJFRS5Cb3hIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQm94SGVscGVyO1xyXG5cclxuVEhSRUUuQm94SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgYm94ID0gbmV3IFRIUkVFLkJveDMoKTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG4gICAgICAgIGJveC5zZXRGcm9tT2JqZWN0KCBvYmplY3QgKTtcclxuXHJcbiAgICAgICAgaWYgKCBib3guZW1wdHkoKSApIHJldHVybjtcclxuXHJcbiAgICAgICAgdmFyIG1pbiA9IGJveC5taW47XHJcbiAgICAgICAgdmFyIG1heCA9IGJveC5tYXg7XHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgIDVfX19fNFxyXG4gICAgICAgICAxL19fXzAvfFxyXG4gICAgICAgICB8IDZfX3xfN1xyXG4gICAgICAgICAyL19fXzMvXHJcblxyXG4gICAgICAgICAwOiBtYXgueCwgbWF4LnksIG1heC56XHJcbiAgICAgICAgIDE6IG1pbi54LCBtYXgueSwgbWF4LnpcclxuICAgICAgICAgMjogbWluLngsIG1pbi55LCBtYXguelxyXG4gICAgICAgICAzOiBtYXgueCwgbWluLnksIG1heC56XHJcbiAgICAgICAgIDQ6IG1heC54LCBtYXgueSwgbWluLnpcclxuICAgICAgICAgNTogbWluLngsIG1heC55LCBtaW4uelxyXG4gICAgICAgICA2OiBtaW4ueCwgbWluLnksIG1pbi56XHJcbiAgICAgICAgIDc6IG1heC54LCBtaW4ueSwgbWluLnpcclxuICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG4gICAgICAgIHZhciBhcnJheSA9IHBvc2l0aW9uLmFycmF5O1xyXG5cclxuICAgICAgICBhcnJheVsgIDAgXSA9IG1heC54OyBhcnJheVsgIDEgXSA9IG1heC55OyBhcnJheVsgIDIgXSA9IG1heC56O1xyXG4gICAgICAgIGFycmF5WyAgMyBdID0gbWluLng7IGFycmF5WyAgNCBdID0gbWF4Lnk7IGFycmF5WyAgNSBdID0gbWF4Lno7XHJcbiAgICAgICAgYXJyYXlbICA2IF0gPSBtaW4ueDsgYXJyYXlbICA3IF0gPSBtaW4ueTsgYXJyYXlbICA4IF0gPSBtYXguejtcclxuICAgICAgICBhcnJheVsgIDkgXSA9IG1heC54OyBhcnJheVsgMTAgXSA9IG1pbi55OyBhcnJheVsgMTEgXSA9IG1heC56O1xyXG4gICAgICAgIGFycmF5WyAxMiBdID0gbWF4Lng7IGFycmF5WyAxMyBdID0gbWF4Lnk7IGFycmF5WyAxNCBdID0gbWluLno7XHJcbiAgICAgICAgYXJyYXlbIDE1IF0gPSBtaW4ueDsgYXJyYXlbIDE2IF0gPSBtYXgueTsgYXJyYXlbIDE3IF0gPSBtaW4uejtcclxuICAgICAgICBhcnJheVsgMTggXSA9IG1pbi54OyBhcnJheVsgMTkgXSA9IG1pbi55OyBhcnJheVsgMjAgXSA9IG1pbi56O1xyXG4gICAgICAgIGFycmF5WyAyMSBdID0gbWF4Lng7IGFycmF5WyAyMiBdID0gbWluLnk7IGFycmF5WyAyMyBdID0gbWluLno7XHJcblxyXG4gICAgICAgIHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy5nZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcclxuXHJcbiAgICB9XHJcblxyXG59ICkoKTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0JvdW5kaW5nQm94SGVscGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqL1xyXG5cclxuLy8gYSBoZWxwZXIgdG8gc2hvdyB0aGUgd29ybGQtYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveCBmb3IgYW4gb2JqZWN0XHJcblxyXG5USFJFRS5Cb3VuZGluZ0JveEhlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0LCBoZXggKSB7XHJcblxyXG4gICAgdmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHg4ODg4ODg7XHJcblxyXG4gICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XHJcblxyXG4gICAgdGhpcy5ib3ggPSBuZXcgVEhSRUUuQm94MygpO1xyXG5cclxuICAgIFRIUkVFLk1lc2guY2FsbCggdGhpcywgbmV3IFRIUkVFLkJveEdlb21ldHJ5KCAxLCAxLCAxICksIG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IsIHdpcmVmcmFtZTogdHJ1ZSB9ICkgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Cb3VuZGluZ0JveEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NZXNoLnByb3RvdHlwZSApO1xyXG5USFJFRS5Cb3VuZGluZ0JveEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Cb3VuZGluZ0JveEhlbHBlcjtcclxuXHJcblRIUkVFLkJvdW5kaW5nQm94SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdGhpcy5ib3guc2V0RnJvbU9iamVjdCggdGhpcy5vYmplY3QgKTtcclxuXHJcbiAgICB0aGlzLmJveC5zaXplKCB0aGlzLnNjYWxlICk7XHJcblxyXG4gICAgdGhpcy5ib3guY2VudGVyKCB0aGlzLnBvc2l0aW9uICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvQ2FtZXJhSGVscGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICpcdC0gc2hvd3MgZnJ1c3R1bSwgbGluZSBvZiBzaWdodCBhbmQgdXAgb2YgdGhlIGNhbWVyYVxyXG4gKlx0LSBzdWl0YWJsZSBmb3IgZmFzdCB1cGRhdGVzXHJcbiAqIFx0LSBiYXNlZCBvbiBmcnVzdHVtIHZpc3VhbGl6YXRpb24gaW4gbGlnaHRnbC5qcyBzaGFkb3dtYXAgZXhhbXBsZVxyXG4gKlx0XHRodHRwOi8vZXZhbncuZ2l0aHViLmNvbS9saWdodGdsLmpzL3Rlc3RzL3NoYWRvd21hcC5odG1sXHJcbiAqL1xyXG5cclxuVEhSRUUuQ2FtZXJhSGVscGVyID0gZnVuY3Rpb24gKCBjYW1lcmEgKSB7XHJcblxyXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcbiAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IDB4ZmZmZmZmLCB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLkZhY2VDb2xvcnMgfSApO1xyXG5cclxuICAgIHZhciBwb2ludE1hcCA9IHt9O1xyXG5cclxuICAgIC8vIGNvbG9yc1xyXG5cclxuICAgIHZhciBoZXhGcnVzdHVtID0gMHhmZmFhMDA7XHJcbiAgICB2YXIgaGV4Q29uZSA9IDB4ZmYwMDAwO1xyXG4gICAgdmFyIGhleFVwID0gMHgwMGFhZmY7XHJcbiAgICB2YXIgaGV4VGFyZ2V0ID0gMHhmZmZmZmY7XHJcbiAgICB2YXIgaGV4Q3Jvc3MgPSAweDMzMzMzMztcclxuXHJcbiAgICAvLyBuZWFyXHJcblxyXG4gICAgYWRkTGluZSggXCJuMVwiLCBcIm4yXCIsIGhleEZydXN0dW0gKTtcclxuICAgIGFkZExpbmUoIFwibjJcIiwgXCJuNFwiLCBoZXhGcnVzdHVtICk7XHJcbiAgICBhZGRMaW5lKCBcIm40XCIsIFwibjNcIiwgaGV4RnJ1c3R1bSApO1xyXG4gICAgYWRkTGluZSggXCJuM1wiLCBcIm4xXCIsIGhleEZydXN0dW0gKTtcclxuXHJcbiAgICAvLyBmYXJcclxuXHJcbiAgICBhZGRMaW5lKCBcImYxXCIsIFwiZjJcIiwgaGV4RnJ1c3R1bSApO1xyXG4gICAgYWRkTGluZSggXCJmMlwiLCBcImY0XCIsIGhleEZydXN0dW0gKTtcclxuICAgIGFkZExpbmUoIFwiZjRcIiwgXCJmM1wiLCBoZXhGcnVzdHVtICk7XHJcbiAgICBhZGRMaW5lKCBcImYzXCIsIFwiZjFcIiwgaGV4RnJ1c3R1bSApO1xyXG5cclxuICAgIC8vIHNpZGVzXHJcblxyXG4gICAgYWRkTGluZSggXCJuMVwiLCBcImYxXCIsIGhleEZydXN0dW0gKTtcclxuICAgIGFkZExpbmUoIFwibjJcIiwgXCJmMlwiLCBoZXhGcnVzdHVtICk7XHJcbiAgICBhZGRMaW5lKCBcIm4zXCIsIFwiZjNcIiwgaGV4RnJ1c3R1bSApO1xyXG4gICAgYWRkTGluZSggXCJuNFwiLCBcImY0XCIsIGhleEZydXN0dW0gKTtcclxuXHJcbiAgICAvLyBjb25lXHJcblxyXG4gICAgYWRkTGluZSggXCJwXCIsIFwibjFcIiwgaGV4Q29uZSApO1xyXG4gICAgYWRkTGluZSggXCJwXCIsIFwibjJcIiwgaGV4Q29uZSApO1xyXG4gICAgYWRkTGluZSggXCJwXCIsIFwibjNcIiwgaGV4Q29uZSApO1xyXG4gICAgYWRkTGluZSggXCJwXCIsIFwibjRcIiwgaGV4Q29uZSApO1xyXG5cclxuICAgIC8vIHVwXHJcblxyXG4gICAgYWRkTGluZSggXCJ1MVwiLCBcInUyXCIsIGhleFVwICk7XHJcbiAgICBhZGRMaW5lKCBcInUyXCIsIFwidTNcIiwgaGV4VXAgKTtcclxuICAgIGFkZExpbmUoIFwidTNcIiwgXCJ1MVwiLCBoZXhVcCApO1xyXG5cclxuICAgIC8vIHRhcmdldFxyXG5cclxuICAgIGFkZExpbmUoIFwiY1wiLCBcInRcIiwgaGV4VGFyZ2V0ICk7XHJcbiAgICBhZGRMaW5lKCBcInBcIiwgXCJjXCIsIGhleENyb3NzICk7XHJcblxyXG4gICAgLy8gY3Jvc3NcclxuXHJcbiAgICBhZGRMaW5lKCBcImNuMVwiLCBcImNuMlwiLCBoZXhDcm9zcyApO1xyXG4gICAgYWRkTGluZSggXCJjbjNcIiwgXCJjbjRcIiwgaGV4Q3Jvc3MgKTtcclxuXHJcbiAgICBhZGRMaW5lKCBcImNmMVwiLCBcImNmMlwiLCBoZXhDcm9zcyApO1xyXG4gICAgYWRkTGluZSggXCJjZjNcIiwgXCJjZjRcIiwgaGV4Q3Jvc3MgKTtcclxuXHJcbiAgICBmdW5jdGlvbiBhZGRMaW5lKCBhLCBiLCBoZXggKSB7XHJcblxyXG4gICAgICAgIGFkZFBvaW50KCBhLCBoZXggKTtcclxuICAgICAgICBhZGRQb2ludCggYiwgaGV4ICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFkZFBvaW50KCBpZCwgaGV4ICkge1xyXG5cclxuICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMygpICk7XHJcbiAgICAgICAgZ2VvbWV0cnkuY29sb3JzLnB1c2goIG5ldyBUSFJFRS5Db2xvciggaGV4ICkgKTtcclxuXHJcbiAgICAgICAgaWYgKCBwb2ludE1hcFsgaWQgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgcG9pbnRNYXBbIGlkIF0gPSBbXTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwb2ludE1hcFsgaWQgXS5wdXNoKCBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggLSAxICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcclxuICAgIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcclxuXHJcbiAgICB0aGlzLm1hdHJpeCA9IGNhbWVyYS5tYXRyaXhXb3JsZDtcclxuICAgIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMucG9pbnRNYXAgPSBwb2ludE1hcDtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkNhbWVyYUhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XHJcblRIUkVFLkNhbWVyYUhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DYW1lcmFIZWxwZXI7XHJcblxyXG5USFJFRS5DYW1lcmFIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgZ2VvbWV0cnksIHBvaW50TWFwO1xyXG5cclxuICAgIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgdmFyIGNhbWVyYSA9IG5ldyBUSFJFRS5DYW1lcmEoKTtcclxuXHJcbiAgICBmdW5jdGlvbiBzZXRQb2ludCggcG9pbnQsIHgsIHksIHogKSB7XHJcblxyXG4gICAgICAgIHZlY3Rvci5zZXQoIHgsIHksIHogKS51bnByb2plY3QoIGNhbWVyYSApO1xyXG5cclxuICAgICAgICB2YXIgcG9pbnRzID0gcG9pbnRNYXBbIHBvaW50IF07XHJcblxyXG4gICAgICAgIGlmICggcG9pbnRzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzWyBwb2ludHNbIGkgXSBdLmNvcHkoIHZlY3RvciApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcclxuICAgICAgICBwb2ludE1hcCA9IHRoaXMucG9pbnRNYXA7XHJcblxyXG4gICAgICAgIHZhciB3ID0gMSwgaCA9IDE7XHJcblxyXG4gICAgICAgIC8vIHdlIG5lZWQganVzdCBjYW1lcmEgcHJvamVjdGlvbiBtYXRyaXhcclxuICAgICAgICAvLyB3b3JsZCBtYXRyaXggbXVzdCBiZSBpZGVudGl0eVxyXG5cclxuICAgICAgICBjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5jb3B5KCB0aGlzLmNhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XHJcblxyXG4gICAgICAgIC8vIGNlbnRlciAvIHRhcmdldFxyXG5cclxuICAgICAgICBzZXRQb2ludCggXCJjXCIsIDAsIDAsIC0gMSApO1xyXG4gICAgICAgIHNldFBvaW50KCBcInRcIiwgMCwgMCwgIDEgKTtcclxuXHJcbiAgICAgICAgLy8gbmVhclxyXG5cclxuICAgICAgICBzZXRQb2ludCggXCJuMVwiLCAtIHcsIC0gaCwgLSAxICk7XHJcbiAgICAgICAgc2V0UG9pbnQoIFwibjJcIiwgICB3LCAtIGgsIC0gMSApO1xyXG4gICAgICAgIHNldFBvaW50KCBcIm4zXCIsIC0gdywgICBoLCAtIDEgKTtcclxuICAgICAgICBzZXRQb2ludCggXCJuNFwiLCAgIHcsICAgaCwgLSAxICk7XHJcblxyXG4gICAgICAgIC8vIGZhclxyXG5cclxuICAgICAgICBzZXRQb2ludCggXCJmMVwiLCAtIHcsIC0gaCwgMSApO1xyXG4gICAgICAgIHNldFBvaW50KCBcImYyXCIsICAgdywgLSBoLCAxICk7XHJcbiAgICAgICAgc2V0UG9pbnQoIFwiZjNcIiwgLSB3LCAgIGgsIDEgKTtcclxuICAgICAgICBzZXRQb2ludCggXCJmNFwiLCAgIHcsICAgaCwgMSApO1xyXG5cclxuICAgICAgICAvLyB1cFxyXG5cclxuICAgICAgICBzZXRQb2ludCggXCJ1MVwiLCAgIHcgKiAwLjcsIGggKiAxLjEsIC0gMSApO1xyXG4gICAgICAgIHNldFBvaW50KCBcInUyXCIsIC0gdyAqIDAuNywgaCAqIDEuMSwgLSAxICk7XHJcbiAgICAgICAgc2V0UG9pbnQoIFwidTNcIiwgICAgICAgICAwLCBoICogMiwgICAtIDEgKTtcclxuXHJcbiAgICAgICAgLy8gY3Jvc3NcclxuXHJcbiAgICAgICAgc2V0UG9pbnQoIFwiY2YxXCIsIC0gdywgICAwLCAxICk7XHJcbiAgICAgICAgc2V0UG9pbnQoIFwiY2YyXCIsICAgdywgICAwLCAxICk7XHJcbiAgICAgICAgc2V0UG9pbnQoIFwiY2YzXCIsICAgMCwgLSBoLCAxICk7XHJcbiAgICAgICAgc2V0UG9pbnQoIFwiY2Y0XCIsICAgMCwgICBoLCAxICk7XHJcblxyXG4gICAgICAgIHNldFBvaW50KCBcImNuMVwiLCAtIHcsICAgMCwgLSAxICk7XHJcbiAgICAgICAgc2V0UG9pbnQoIFwiY24yXCIsICAgdywgICAwLCAtIDEgKTtcclxuICAgICAgICBzZXRQb2ludCggXCJjbjNcIiwgICAwLCAtIGgsIC0gMSApO1xyXG4gICAgICAgIHNldFBvaW50KCBcImNuNFwiLCAgIDAsICAgaCwgLSAxICk7XHJcblxyXG4gICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG4gICAgfTtcclxuXHJcbn0oKTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0RpcmVjdGlvbmFsTGlnaHRIZWxwZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICovXHJcblxyXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyID0gZnVuY3Rpb24gKCBsaWdodCwgc2l6ZSApIHtcclxuXHJcbiAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy5saWdodCA9IGxpZ2h0O1xyXG4gICAgdGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xyXG5cclxuICAgIHRoaXMubWF0cml4ID0gbGlnaHQubWF0cml4V29ybGQ7XHJcbiAgICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcbiAgICBzaXplID0gc2l6ZSB8fCAxO1xyXG5cclxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG4gICAgZ2VvbWV0cnkudmVydGljZXMucHVzaChcclxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMyggLSBzaXplLCAgIHNpemUsIDAgKSxcclxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMyggICBzaXplLCAgIHNpemUsIDAgKSxcclxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMyggICBzaXplLCAtIHNpemUsIDAgKSxcclxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMyggLSBzaXplLCAtIHNpemUsIDAgKSxcclxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMyggLSBzaXplLCAgIHNpemUsIDAgKVxyXG4gICAgKTtcclxuXHJcbiAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgZm9nOiBmYWxzZSB9ICk7XHJcbiAgICBtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XHJcblxyXG4gICAgdGhpcy5saWdodFBsYW5lID0gbmV3IFRIUkVFLkxpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG4gICAgdGhpcy5hZGQoIHRoaXMubGlnaHRQbGFuZSApO1xyXG5cclxuICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcbiAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKFxyXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoKVxyXG4gICAgKTtcclxuXHJcbiAgICBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBmb2c6IGZhbHNlIH0gKTtcclxuICAgIG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcclxuXHJcbiAgICB0aGlzLnRhcmdldExpbmUgPSBuZXcgVEhSRUUuTGluZSggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcbiAgICB0aGlzLmFkZCggdGhpcy50YXJnZXRMaW5lICk7XHJcblxyXG4gICAgdGhpcy51cGRhdGUoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXI7XHJcblxyXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHRoaXMubGlnaHRQbGFuZS5nZW9tZXRyeS5kaXNwb3NlKCk7XHJcbiAgICB0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG4gICAgdGhpcy50YXJnZXRMaW5lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcclxuICAgIHRoaXMudGFyZ2V0TGluZS5tYXRlcmlhbC5kaXNwb3NlKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICB2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgdmFyIHYzID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2MS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKTtcclxuICAgICAgICB2Mi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XHJcbiAgICAgICAgdjMuc3ViVmVjdG9ycyggdjIsIHYxICk7XHJcblxyXG4gICAgICAgIHRoaXMubGlnaHRQbGFuZS5sb29rQXQoIHYzICk7XHJcbiAgICAgICAgdGhpcy5saWdodFBsYW5lLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcclxuXHJcbiAgICAgICAgdGhpcy50YXJnZXRMaW5lLmdlb21ldHJ5LnZlcnRpY2VzWyAxIF0uY29weSggdjMgKTtcclxuICAgICAgICB0aGlzLnRhcmdldExpbmUuZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnRhcmdldExpbmUubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodFBsYW5lLm1hdGVyaWFsLmNvbG9yICk7XHJcblxyXG4gICAgfTtcclxuXHJcbn0oKTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0VkZ2VzSGVscGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqIEBwYXJhbSBvYmplY3QgVEhSRUUuTWVzaCB3aG9zZSBnZW9tZXRyeSB3aWxsIGJlIHVzZWRcclxuICogQHBhcmFtIGhleCBsaW5lIGNvbG9yXHJcbiAqIEBwYXJhbSB0aHJlc2hvbGRBbmdsZSB0aGUgbWluaW11bSBhbmdsZSAoaW4gZGVncmVlcyksXHJcbiAqIGJldHdlZW4gdGhlIGZhY2Ugbm9ybWFscyBvZiBhZGphY2VudCBmYWNlcyxcclxuICogdGhhdCBpcyByZXF1aXJlZCB0byByZW5kZXIgYW4gZWRnZS4gQSB2YWx1ZSBvZiAxMCBtZWFuc1xyXG4gKiBhbiBlZGdlIGlzIG9ubHkgcmVuZGVyZWQgaWYgdGhlIGFuZ2xlIGlzIGF0IGxlYXN0IDEwIGRlZ3JlZXMuXHJcbiAqL1xyXG5cclxuVEhSRUUuRWRnZXNIZWxwZXIgPSBmdW5jdGlvbiAoIG9iamVjdCwgaGV4LCB0aHJlc2hvbGRBbmdsZSApIHtcclxuXHJcbiAgICB2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweGZmZmZmZjtcclxuXHJcbiAgICBUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgbmV3IFRIUkVFLkVkZ2VzR2VvbWV0cnkoIG9iamVjdC5nZW9tZXRyeSwgdGhyZXNob2xkQW5nbGUgKSwgbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciB9ICkgKTtcclxuXHJcbiAgICB0aGlzLm1hdHJpeCA9IG9iamVjdC5tYXRyaXhXb3JsZDtcclxuICAgIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkVkZ2VzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcclxuVEhSRUUuRWRnZXNIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRWRnZXNIZWxwZXI7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9GYWNlTm9ybWFsc0hlbHBlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKi9cclxuXHJcblRIUkVFLkZhY2VOb3JtYWxzSGVscGVyID0gZnVuY3Rpb24gKCBvYmplY3QsIHNpemUsIGhleCwgbGluZXdpZHRoICkge1xyXG5cclxuICAgIC8vIEZhY2VOb3JtYWxzSGVscGVyIG9ubHkgc3VwcG9ydHMgVEhSRUUuR2VvbWV0cnlcclxuXHJcbiAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuXHJcbiAgICB0aGlzLnNpemUgPSAoIHNpemUgIT09IHVuZGVmaW5lZCApID8gc2l6ZSA6IDE7XHJcblxyXG4gICAgdmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHhmZmZmMDA7XHJcblxyXG4gICAgdmFyIHdpZHRoID0gKCBsaW5ld2lkdGggIT09IHVuZGVmaW5lZCApID8gbGluZXdpZHRoIDogMTtcclxuXHJcbiAgICAvL1xyXG5cclxuICAgIHZhciBuTm9ybWFscyA9IDA7XHJcblxyXG4gICAgdmFyIG9iakdlb21ldHJ5ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnk7XHJcblxyXG4gICAgaWYgKCBvYmpHZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xyXG5cclxuICAgICAgICBuTm9ybWFscyA9IG9iakdlb21ldHJ5LmZhY2VzLmxlbmd0aDtcclxuXHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5GYWNlTm9ybWFsc0hlbHBlcjogb25seSBUSFJFRS5HZW9tZXRyeSBpcyBzdXBwb3J0ZWQuIFVzZSBUSFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyLCBpbnN0ZWFkLicgKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy9cclxuXHJcbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcclxuXHJcbiAgICB2YXIgcG9zaXRpb25zID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIG5Ob3JtYWxzICogMiAqIDMsIDMgKTtcclxuXHJcbiAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHBvc2l0aW9ucyApO1xyXG5cclxuICAgIFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciwgbGluZXdpZHRoOiB3aWR0aCB9ICkgKTtcclxuXHJcbiAgICAvL1xyXG5cclxuICAgIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG4gICAgdGhpcy51cGRhdGUoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5GYWNlTm9ybWFsc0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XHJcblRIUkVFLkZhY2VOb3JtYWxzSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkZhY2VOb3JtYWxzSGVscGVyO1xyXG5cclxuVEhSRUUuRmFjZU5vcm1hbHNIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9ICggZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICB2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgdmFyIG5vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCk7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcclxuXHJcbiAgICAgICAgdGhpcy5vYmplY3QudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcclxuXHJcbiAgICAgICAgbm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggdGhpcy5vYmplY3QubWF0cml4V29ybGQgKTtcclxuXHJcbiAgICAgICAgdmFyIG1hdHJpeFdvcmxkID0gdGhpcy5vYmplY3QubWF0cml4V29ybGQ7XHJcblxyXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuXHJcbiAgICAgICAgLy9cclxuXHJcbiAgICAgICAgdmFyIG9iakdlb21ldHJ5ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnk7XHJcblxyXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IG9iakdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cclxuICAgICAgICB2YXIgZmFjZXMgPSBvYmpHZW9tZXRyeS5mYWNlcztcclxuXHJcbiAgICAgICAgdmFyIGlkeCA9IDA7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgZmFjZSA9IGZhY2VzWyBpIF07XHJcblxyXG4gICAgICAgICAgICB2YXIgbm9ybWFsID0gZmFjZS5ub3JtYWw7XHJcblxyXG4gICAgICAgICAgICB2MS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5hIF0gKVxyXG4gICAgICAgICAgICAgICAgLmFkZCggdmVydGljZXNbIGZhY2UuYiBdIClcclxuICAgICAgICAgICAgICAgIC5hZGQoIHZlcnRpY2VzWyBmYWNlLmMgXSApXHJcbiAgICAgICAgICAgICAgICAuZGl2aWRlU2NhbGFyKCAzIClcclxuICAgICAgICAgICAgICAgIC5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XHJcblxyXG4gICAgICAgICAgICB2Mi5jb3B5KCBub3JtYWwgKS5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCB0aGlzLnNpemUgKS5hZGQoIHYxICk7XHJcblxyXG4gICAgICAgICAgICBwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjEueCwgdjEueSwgdjEueiApO1xyXG5cclxuICAgICAgICAgICAgaWR4ID0gaWR4ICsgMTtcclxuXHJcbiAgICAgICAgICAgIHBvc2l0aW9uLnNldFhZWiggaWR4LCB2Mi54LCB2Mi55LCB2Mi56ICk7XHJcblxyXG4gICAgICAgICAgICBpZHggPSBpZHggKyAxO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfVxyXG5cclxufSgpICk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9HcmlkSGVscGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5HcmlkSGVscGVyID0gZnVuY3Rpb24gKCBzaXplLCBzdGVwICkge1xyXG5cclxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG4gICAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogVEhSRUUuVmVydGV4Q29sb3JzIH0gKTtcclxuXHJcbiAgICB0aGlzLmNvbG9yMSA9IG5ldyBUSFJFRS5Db2xvciggMHg0NDQ0NDQgKTtcclxuICAgIHRoaXMuY29sb3IyID0gbmV3IFRIUkVFLkNvbG9yKCAweDg4ODg4OCApO1xyXG5cclxuICAgIGZvciAoIHZhciBpID0gLSBzaXplOyBpIDw9IHNpemU7IGkgKz0gc3RlcCApIHtcclxuXHJcbiAgICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaChcclxuICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoIC0gc2l6ZSwgMCwgaSApLCBuZXcgVEhSRUUuVmVjdG9yMyggc2l6ZSwgMCwgaSApLFxyXG4gICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMyggaSwgMCwgLSBzaXplICksIG5ldyBUSFJFRS5WZWN0b3IzKCBpLCAwLCBzaXplIClcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICB2YXIgY29sb3IgPSBpID09PSAwID8gdGhpcy5jb2xvcjEgOiB0aGlzLmNvbG9yMjtcclxuXHJcbiAgICAgICAgZ2VvbWV0cnkuY29sb3JzLnB1c2goIGNvbG9yLCBjb2xvciwgY29sb3IsIGNvbG9yICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5HcmlkSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcclxuVEhSRUUuR3JpZEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5HcmlkSGVscGVyO1xyXG5cclxuVEhSRUUuR3JpZEhlbHBlci5wcm90b3R5cGUuc2V0Q29sb3JzID0gZnVuY3Rpb24oIGNvbG9yQ2VudGVyTGluZSwgY29sb3JHcmlkICkge1xyXG5cclxuICAgIHRoaXMuY29sb3IxLnNldCggY29sb3JDZW50ZXJMaW5lICk7XHJcbiAgICB0aGlzLmNvbG9yMi5zZXQoIGNvbG9yR3JpZCApO1xyXG5cclxuICAgIHRoaXMuZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvSGVtaXNwaGVyZUxpZ2h0SGVscGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5IZW1pc3BoZXJlTGlnaHRIZWxwZXIgPSBmdW5jdGlvbiAoIGxpZ2h0LCBzcGhlcmVTaXplICkge1xyXG5cclxuICAgIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICB0aGlzLmxpZ2h0ID0gbGlnaHQ7XHJcbiAgICB0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblxyXG4gICAgdGhpcy5tYXRyaXggPSBsaWdodC5tYXRyaXhXb3JsZDtcclxuICAgIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuY29sb3JzID0gWyBuZXcgVEhSRUUuQ29sb3IoKSwgbmV3IFRIUkVFLkNvbG9yKCkgXTtcclxuXHJcbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoIHNwaGVyZVNpemUsIDQsIDIgKTtcclxuICAgIGdlb21ldHJ5LnJvdGF0ZVgoIC0gTWF0aC5QSSAvIDIgKTtcclxuXHJcbiAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gODsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuICAgICAgICBnZW9tZXRyeS5mYWNlc1sgaSBdLmNvbG9yID0gdGhpcy5jb2xvcnNbIGkgPCA0ID8gMCA6IDEgXTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogVEhSRUUuRmFjZUNvbG9ycywgd2lyZWZyYW1lOiB0cnVlIH0gKTtcclxuXHJcbiAgICB0aGlzLmxpZ2h0U3BoZXJlID0gbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG4gICAgdGhpcy5hZGQoIHRoaXMubGlnaHRTcGhlcmUgKTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlcjtcclxuXHJcblRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB0aGlzLmxpZ2h0U3BoZXJlLmdlb21ldHJ5LmRpc3Bvc2UoKTtcclxuICAgIHRoaXMubGlnaHRTcGhlcmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY29sb3JzWyAwIF0uY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xyXG4gICAgICAgIHRoaXMuY29sb3JzWyAxIF0uY29weSggdGhpcy5saWdodC5ncm91bmRDb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xyXG5cclxuICAgICAgICB0aGlzLmxpZ2h0U3BoZXJlLmxvb2tBdCggdmVjdG9yLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC5tYXRyaXhXb3JsZCApLm5lZ2F0ZSgpICk7XHJcbiAgICAgICAgdGhpcy5saWdodFNwaGVyZS5nZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHJcbiAgICB9XHJcblxyXG59KCk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9Qb2ludExpZ2h0SGVscGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5Qb2ludExpZ2h0SGVscGVyID0gZnVuY3Rpb24gKCBsaWdodCwgc3BoZXJlU2l6ZSApIHtcclxuXHJcbiAgICB0aGlzLmxpZ2h0ID0gbGlnaHQ7XHJcbiAgICB0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblxyXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KCBzcGhlcmVTaXplLCA0LCAyICk7XHJcbiAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgd2lyZWZyYW1lOiB0cnVlLCBmb2c6IGZhbHNlIH0gKTtcclxuICAgIG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcclxuXHJcbiAgICBUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxuICAgIHRoaXMubWF0cml4ID0gdGhpcy5saWdodC5tYXRyaXhXb3JsZDtcclxuICAgIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuICAgIC8qXHJcbiAgICAgdmFyIGRpc3RhbmNlR2VvbWV0cnkgPSBuZXcgVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeSggMSwgMiApO1xyXG4gICAgIHZhciBkaXN0YW5jZU1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBoZXhDb2xvciwgZm9nOiBmYWxzZSwgd2lyZWZyYW1lOiB0cnVlLCBvcGFjaXR5OiAwLjEsIHRyYW5zcGFyZW50OiB0cnVlIH0gKTtcclxuXHJcbiAgICAgdGhpcy5saWdodFNwaGVyZSA9IG5ldyBUSFJFRS5NZXNoKCBidWxiR2VvbWV0cnksIGJ1bGJNYXRlcmlhbCApO1xyXG4gICAgIHRoaXMubGlnaHREaXN0YW5jZSA9IG5ldyBUSFJFRS5NZXNoKCBkaXN0YW5jZUdlb21ldHJ5LCBkaXN0YW5jZU1hdGVyaWFsICk7XHJcblxyXG4gICAgIHZhciBkID0gbGlnaHQuZGlzdGFuY2U7XHJcblxyXG4gICAgIGlmICggZCA9PT0gMC4wICkge1xyXG5cclxuICAgICB0aGlzLmxpZ2h0RGlzdGFuY2UudmlzaWJsZSA9IGZhbHNlO1xyXG5cclxuICAgICB9IGVsc2Uge1xyXG5cclxuICAgICB0aGlzLmxpZ2h0RGlzdGFuY2Uuc2NhbGUuc2V0KCBkLCBkLCBkICk7XHJcblxyXG4gICAgIH1cclxuXHJcbiAgICAgdGhpcy5hZGQoIHRoaXMubGlnaHREaXN0YW5jZSApO1xyXG4gICAgICovXHJcblxyXG59O1xyXG5cclxuVEhSRUUuUG9pbnRMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NZXNoLnByb3RvdHlwZSApO1xyXG5USFJFRS5Qb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBvaW50TGlnaHRIZWxwZXI7XHJcblxyXG5USFJFRS5Qb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG4gICAgdGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUG9pbnRMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHRoaXMubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xyXG5cclxuICAgIC8qXHJcbiAgICAgdmFyIGQgPSB0aGlzLmxpZ2h0LmRpc3RhbmNlO1xyXG5cclxuICAgICBpZiAoIGQgPT09IDAuMCApIHtcclxuXHJcbiAgICAgdGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSBmYWxzZTtcclxuXHJcbiAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgdGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSB0cnVlO1xyXG4gICAgIHRoaXMubGlnaHREaXN0YW5jZS5zY2FsZS5zZXQoIGQsIGQsIGQgKTtcclxuXHJcbiAgICAgfVxyXG4gICAgICovXHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvU2tlbGV0b25IZWxwZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIFNlYW4gR3JpZmZpbiAvIGh0dHA6Ly90d2l0dGVyLmNvbS9zZ3JpZlxyXG4gKiBAYXV0aG9yIE1pY2hhZWwgR3VlcnJlcm8gLyBodHRwOi8vcmVhbGl0eW1lbHRkb3duLmNvbVxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGlrZXJyIC8gaHR0cDovL3Zlcm9sZC5jb21cclxuICovXHJcblxyXG5USFJFRS5Ta2VsZXRvbkhlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuICAgIHRoaXMuYm9uZXMgPSB0aGlzLmdldEJvbmVMaXN0KCBvYmplY3QgKTtcclxuXHJcbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHJcbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmJvbmVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgdmFyIGJvbmUgPSB0aGlzLmJvbmVzWyBpIF07XHJcblxyXG4gICAgICAgIGlmICggYm9uZS5wYXJlbnQgaW5zdGFuY2VvZiBUSFJFRS5Cb25lICkge1xyXG5cclxuICAgICAgICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoKSApO1xyXG4gICAgICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMygpICk7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5LmNvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIDAsIDAsIDEgKSApO1xyXG4gICAgICAgICAgICBnZW9tZXRyeS5jb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCAwLCAxLCAwICkgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBnZW9tZXRyeS5keW5hbWljID0gdHJ1ZTtcclxuXHJcbiAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgdmVydGV4Q29sb3JzOiBUSFJFRS5WZXJ0ZXhDb2xvcnMsIGRlcHRoVGVzdDogZmFsc2UsIGRlcHRoV3JpdGU6IGZhbHNlLCB0cmFuc3BhcmVudDogdHJ1ZSB9ICk7XHJcblxyXG4gICAgVEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxuICAgIHRoaXMucm9vdCA9IG9iamVjdDtcclxuXHJcbiAgICB0aGlzLm1hdHJpeCA9IG9iamVjdC5tYXRyaXhXb3JsZDtcclxuICAgIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMudXBkYXRlKCk7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLlNrZWxldG9uSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcclxuVEhSRUUuU2tlbGV0b25IZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU2tlbGV0b25IZWxwZXI7XHJcblxyXG5USFJFRS5Ta2VsZXRvbkhlbHBlci5wcm90b3R5cGUuZ2V0Qm9uZUxpc3QgPSBmdW5jdGlvbiggb2JqZWN0ICkge1xyXG5cclxuICAgIHZhciBib25lTGlzdCA9IFtdO1xyXG5cclxuICAgIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuQm9uZSApIHtcclxuXHJcbiAgICAgICAgYm9uZUxpc3QucHVzaCggb2JqZWN0ICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG9iamVjdC5jaGlsZHJlbi5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIGJvbmVMaXN0LnB1c2guYXBwbHkoIGJvbmVMaXN0LCB0aGlzLmdldEJvbmVMaXN0KCBvYmplY3QuY2hpbGRyZW5bIGkgXSApICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBib25lTGlzdDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Ta2VsZXRvbkhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XHJcblxyXG4gICAgdmFyIG1hdHJpeFdvcmxkSW52ID0gbmV3IFRIUkVFLk1hdHJpeDQoKS5nZXRJbnZlcnNlKCB0aGlzLnJvb3QubWF0cml4V29ybGQgKTtcclxuXHJcbiAgICB2YXIgYm9uZU1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG4gICAgdmFyIGogPSAwO1xyXG5cclxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuYm9uZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuICAgICAgICB2YXIgYm9uZSA9IHRoaXMuYm9uZXNbIGkgXTtcclxuXHJcbiAgICAgICAgaWYgKCBib25lLnBhcmVudCBpbnN0YW5jZW9mIFRIUkVFLkJvbmUgKSB7XHJcblxyXG4gICAgICAgICAgICBib25lTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeFdvcmxkSW52LCBib25lLm1hdHJpeFdvcmxkICk7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzWyBqIF0uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBib25lTWF0cml4ICk7XHJcblxyXG4gICAgICAgICAgICBib25lTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeFdvcmxkSW52LCBib25lLnBhcmVudC5tYXRyaXhXb3JsZCApO1xyXG4gICAgICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlc1sgaiArIDEgXS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGJvbmVNYXRyaXggKTtcclxuXHJcbiAgICAgICAgICAgIGogKz0gMjtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxuICAgIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL1Nwb3RMaWdodEhlbHBlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKi9cclxuXHJcblRIUkVFLlNwb3RMaWdodEhlbHBlciA9IGZ1bmN0aW9uICggbGlnaHQgKSB7XHJcblxyXG4gICAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMubGlnaHQgPSBsaWdodDtcclxuICAgIHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcclxuXHJcbiAgICB0aGlzLm1hdHJpeCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xyXG4gICAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoIDAsIDEsIDEsIDgsIDEsIHRydWUgKTtcclxuXHJcbiAgICBnZW9tZXRyeS50cmFuc2xhdGUoIDAsIC0gMC41LCAwICk7XHJcbiAgICBnZW9tZXRyeS5yb3RhdGVYKCAtIE1hdGguUEkgLyAyICk7XHJcblxyXG4gICAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IHdpcmVmcmFtZTogdHJ1ZSwgZm9nOiBmYWxzZSB9ICk7XHJcblxyXG4gICAgdGhpcy5jb25lID0gbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG4gICAgdGhpcy5hZGQoIHRoaXMuY29uZSApO1xyXG5cclxuICAgIHRoaXMudXBkYXRlKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5USFJFRS5TcG90TGlnaHRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU3BvdExpZ2h0SGVscGVyO1xyXG5cclxuVEhSRUUuU3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHRoaXMuY29uZS5nZW9tZXRyeS5kaXNwb3NlKCk7XHJcbiAgICB0aGlzLmNvbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgdmFyIHZlY3RvcjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBjb25lTGVuZ3RoID0gdGhpcy5saWdodC5kaXN0YW5jZSA/IHRoaXMubGlnaHQuZGlzdGFuY2UgOiAxMDAwMDtcclxuICAgICAgICB2YXIgY29uZVdpZHRoID0gY29uZUxlbmd0aCAqIE1hdGgudGFuKCB0aGlzLmxpZ2h0LmFuZ2xlICk7XHJcblxyXG4gICAgICAgIHRoaXMuY29uZS5zY2FsZS5zZXQoIGNvbmVXaWR0aCwgY29uZVdpZHRoLCBjb25lTGVuZ3RoICk7XHJcblxyXG4gICAgICAgIHZlY3Rvci5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKTtcclxuICAgICAgICB2ZWN0b3IyLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcclxuXHJcbiAgICAgICAgdGhpcy5jb25lLmxvb2tBdCggdmVjdG9yMi5zdWIoIHZlY3RvciApICk7XHJcblxyXG4gICAgICAgIHRoaXMuY29uZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XHJcblxyXG4gICAgfTtcclxuXHJcbn0oKTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL1ZlcnRleE5vcm1hbHNIZWxwZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICovXHJcblxyXG5USFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyID0gZnVuY3Rpb24gKCBvYmplY3QsIHNpemUsIGhleCwgbGluZXdpZHRoICkge1xyXG5cclxuICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG5cclxuICAgIHRoaXMuc2l6ZSA9ICggc2l6ZSAhPT0gdW5kZWZpbmVkICkgPyBzaXplIDogMTtcclxuXHJcbiAgICB2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweGZmMDAwMDtcclxuXHJcbiAgICB2YXIgd2lkdGggPSAoIGxpbmV3aWR0aCAhPT0gdW5kZWZpbmVkICkgPyBsaW5ld2lkdGggOiAxO1xyXG5cclxuICAgIC8vXHJcblxyXG4gICAgdmFyIG5Ob3JtYWxzID0gMDtcclxuXHJcbiAgICB2YXIgb2JqR2VvbWV0cnkgPSB0aGlzLm9iamVjdC5nZW9tZXRyeTtcclxuXHJcbiAgICBpZiAoIG9iakdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XHJcblxyXG4gICAgICAgIG5Ob3JtYWxzID0gb2JqR2VvbWV0cnkuZmFjZXMubGVuZ3RoICogMztcclxuXHJcbiAgICB9IGVsc2UgaWYgKCBvYmpHZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xyXG5cclxuICAgICAgICBuTm9ybWFscyA9IG9iakdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsLmNvdW50XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vXHJcblxyXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XHJcblxyXG4gICAgdmFyIHBvc2l0aW9ucyA9IG5ldyBUSFJFRS5GbG9hdDMyQXR0cmlidXRlKCBuTm9ybWFscyAqIDIgKiAzLCAzICk7XHJcblxyXG4gICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBwb3NpdGlvbnMgKTtcclxuXHJcbiAgICBUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IsIGxpbmV3aWR0aDogd2lkdGggfSApICk7XHJcblxyXG4gICAgLy9cclxuXHJcbiAgICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlZlcnRleE5vcm1hbHNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xyXG5USFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlZlcnRleE5vcm1hbHNIZWxwZXI7XHJcblxyXG5USFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgdmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgIHZhciBub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XHJcblxyXG4gICAgICAgIHZhciBrZXlzID0gWyAnYScsICdiJywgJ2MnIF07XHJcblxyXG4gICAgICAgIHRoaXMub2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XHJcblxyXG4gICAgICAgIG5vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG4gICAgICAgIHZhciBtYXRyaXhXb3JsZCA9IHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkO1xyXG5cclxuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XHJcblxyXG4gICAgICAgIC8vXHJcblxyXG4gICAgICAgIHZhciBvYmpHZW9tZXRyeSA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuICAgICAgICBpZiAoIG9iakdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgdmVydGljZXMgPSBvYmpHZW9tZXRyeS52ZXJ0aWNlcztcclxuXHJcbiAgICAgICAgICAgIHZhciBmYWNlcyA9IG9iakdlb21ldHJ5LmZhY2VzO1xyXG5cclxuICAgICAgICAgICAgdmFyIGlkeCA9IDA7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBmYWNlID0gZmFjZXNbIGkgXTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmVydGV4ID0gdmVydGljZXNbIGZhY2VbIGtleXNbIGogXSBdIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBub3JtYWwgPSBmYWNlLnZlcnRleE5vcm1hbHNbIGogXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdjEuY29weSggdmVydGV4ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2Mi5jb3B5KCBub3JtYWwgKS5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCB0aGlzLnNpemUgKS5hZGQoIHYxICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uLnNldFhZWiggaWR4LCB2MS54LCB2MS55LCB2MS56ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlkeCA9IGlkeCArIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uLnNldFhZWiggaWR4LCB2Mi54LCB2Mi55LCB2Mi56ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlkeCA9IGlkeCArIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCBvYmpHZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIG9ialBvcyA9IG9iakdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XHJcblxyXG4gICAgICAgICAgICB2YXIgb2JqTm9ybSA9IG9iakdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsO1xyXG5cclxuICAgICAgICAgICAgdmFyIGlkeCA9IDA7XHJcblxyXG4gICAgICAgICAgICAvLyBmb3Igc2ltcGxpY2l0eSwgaWdub3JlIGluZGV4IGFuZCBkcmF3Y2FsbHMsIGFuZCByZW5kZXIgZXZlcnkgbm9ybWFsXHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gb2JqUG9zLmNvdW50OyBqIDwgamw7IGogKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdjEuc2V0KCBvYmpQb3MuZ2V0WCggaiApLCBvYmpQb3MuZ2V0WSggaiApLCBvYmpQb3MuZ2V0WiggaiApICkuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xyXG5cclxuICAgICAgICAgICAgICAgIHYyLnNldCggb2JqTm9ybS5nZXRYKCBqICksIG9iak5vcm0uZ2V0WSggaiApLCBvYmpOb3JtLmdldFooIGogKSApO1xyXG5cclxuICAgICAgICAgICAgICAgIHYyLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIHRoaXMuc2l6ZSApLmFkZCggdjEgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjEueCwgdjEueSwgdjEueiApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlkeCA9IGlkeCArIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb24uc2V0WFlaKCBpZHgsIHYyLngsIHYyLnksIHYyLnogKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZHggPSBpZHggKyAxO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfVxyXG5cclxufSgpICk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9XaXJlZnJhbWVIZWxwZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLldpcmVmcmFtZUhlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0LCBoZXggKSB7XHJcblxyXG4gICAgdmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHhmZmZmZmY7XHJcblxyXG4gICAgVEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIG5ldyBUSFJFRS5XaXJlZnJhbWVHZW9tZXRyeSggb2JqZWN0Lmdlb21ldHJ5ICksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IgfSApICk7XHJcblxyXG4gICAgdGhpcy5tYXRyaXggPSBvYmplY3QubWF0cml4V29ybGQ7XHJcbiAgICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5XaXJlZnJhbWVIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xyXG5USFJFRS5XaXJlZnJhbWVIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuV2lyZWZyYW1lSGVscGVyO1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL29iamVjdHMvSW1tZWRpYXRlUmVuZGVyT2JqZWN0LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3QgPSBmdW5jdGlvbiAoIG1hdGVyaWFsICkge1xyXG5cclxuICAgIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICB0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWw7XHJcbiAgICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggcmVuZGVyQ2FsbGJhY2sgKSB7fTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblRIUkVFLkltbWVkaWF0ZVJlbmRlck9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3Q7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvb2JqZWN0cy9Nb3JwaEJsZW5kTWVzaC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2ggPSBmdW5jdGlvbiggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xyXG5cclxuICAgIFRIUkVFLk1lc2guY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG4gICAgdGhpcy5hbmltYXRpb25zTWFwID0ge307XHJcbiAgICB0aGlzLmFuaW1hdGlvbnNMaXN0ID0gW107XHJcblxyXG4gICAgLy8gcHJlcGFyZSBkZWZhdWx0IGFuaW1hdGlvblxyXG4gICAgLy8gKGFsbCBmcmFtZXMgcGxheWVkIHRvZ2V0aGVyIGluIDEgc2Vjb25kKVxyXG5cclxuICAgIHZhciBudW1GcmFtZXMgPSB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7XHJcblxyXG4gICAgdmFyIG5hbWUgPSBcIl9fZGVmYXVsdFwiO1xyXG5cclxuICAgIHZhciBzdGFydEZyYW1lID0gMDtcclxuICAgIHZhciBlbmRGcmFtZSA9IG51bUZyYW1lcyAtIDE7XHJcblxyXG4gICAgdmFyIGZwcyA9IG51bUZyYW1lcyAvIDE7XHJcblxyXG4gICAgdGhpcy5jcmVhdGVBbmltYXRpb24oIG5hbWUsIHN0YXJ0RnJhbWUsIGVuZEZyYW1lLCBmcHMgKTtcclxuICAgIHRoaXMuc2V0QW5pbWF0aW9uV2VpZ2h0KCBuYW1lLCAxICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWVzaC5wcm90b3R5cGUgKTtcclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTW9ycGhCbGVuZE1lc2g7XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuY3JlYXRlQW5pbWF0aW9uID0gZnVuY3Rpb24gKCBuYW1lLCBzdGFydCwgZW5kLCBmcHMgKSB7XHJcblxyXG4gICAgdmFyIGFuaW1hdGlvbiA9IHtcclxuXHJcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG4gICAgICAgIGVuZDogZW5kLFxyXG5cclxuICAgICAgICBsZW5ndGg6IGVuZCAtIHN0YXJ0ICsgMSxcclxuXHJcbiAgICAgICAgZnBzOiBmcHMsXHJcbiAgICAgICAgZHVyYXRpb246ICggZW5kIC0gc3RhcnQgKSAvIGZwcyxcclxuXHJcbiAgICAgICAgbGFzdEZyYW1lOiAwLFxyXG4gICAgICAgIGN1cnJlbnRGcmFtZTogMCxcclxuXHJcbiAgICAgICAgYWN0aXZlOiBmYWxzZSxcclxuXHJcbiAgICAgICAgdGltZTogMCxcclxuICAgICAgICBkaXJlY3Rpb246IDEsXHJcbiAgICAgICAgd2VpZ2h0OiAxLFxyXG5cclxuICAgICAgICBkaXJlY3Rpb25CYWNrd2FyZHM6IGZhbHNlLFxyXG4gICAgICAgIG1pcnJvcmVkTG9vcDogZmFsc2VcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdID0gYW5pbWF0aW9uO1xyXG4gICAgdGhpcy5hbmltYXRpb25zTGlzdC5wdXNoKCBhbmltYXRpb24gKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuYXV0b0NyZWF0ZUFuaW1hdGlvbnMgPSBmdW5jdGlvbiAoIGZwcyApIHtcclxuXHJcbiAgICB2YXIgcGF0dGVybiA9IC8oW2Etel0rKV8/KFxcZCspLztcclxuXHJcbiAgICB2YXIgZmlyc3RBbmltYXRpb24sIGZyYW1lUmFuZ2VzID0ge307XHJcblxyXG4gICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcclxuXHJcbiAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuICAgICAgICB2YXIgbW9ycGggPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXTtcclxuICAgICAgICB2YXIgY2h1bmtzID0gbW9ycGgubmFtZS5tYXRjaCggcGF0dGVybiApO1xyXG5cclxuICAgICAgICBpZiAoIGNodW5rcyAmJiBjaHVua3MubGVuZ3RoID4gMSApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gY2h1bmtzWyAxIF07XHJcblxyXG4gICAgICAgICAgICBpZiAoICEgZnJhbWVSYW5nZXNbIG5hbWUgXSApIGZyYW1lUmFuZ2VzWyBuYW1lIF0gPSB7IHN0YXJ0OiBJbmZpbml0eSwgZW5kOiAtIEluZmluaXR5IH07XHJcblxyXG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBmcmFtZVJhbmdlc1sgbmFtZSBdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBpIDwgcmFuZ2Uuc3RhcnQgKSByYW5nZS5zdGFydCA9IGk7XHJcbiAgICAgICAgICAgIGlmICggaSA+IHJhbmdlLmVuZCApIHJhbmdlLmVuZCA9IGk7XHJcblxyXG4gICAgICAgICAgICBpZiAoICEgZmlyc3RBbmltYXRpb24gKSBmaXJzdEFuaW1hdGlvbiA9IG5hbWU7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZm9yICggdmFyIG5hbWUgaW4gZnJhbWVSYW5nZXMgKSB7XHJcblxyXG4gICAgICAgIHZhciByYW5nZSA9IGZyYW1lUmFuZ2VzWyBuYW1lIF07XHJcbiAgICAgICAgdGhpcy5jcmVhdGVBbmltYXRpb24oIG5hbWUsIHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQsIGZwcyApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmZpcnN0QW5pbWF0aW9uID0gZmlyc3RBbmltYXRpb247XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkRpcmVjdGlvbkZvcndhcmQgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG4gICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuICAgIGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuICAgICAgICBhbmltYXRpb24uZGlyZWN0aW9uID0gMTtcclxuICAgICAgICBhbmltYXRpb24uZGlyZWN0aW9uQmFja3dhcmRzID0gZmFsc2U7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25EaXJlY3Rpb25CYWNrd2FyZCA9IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcbiAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG4gICAgaWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG4gICAgICAgIGFuaW1hdGlvbi5kaXJlY3Rpb24gPSAtIDE7XHJcbiAgICAgICAgYW5pbWF0aW9uLmRpcmVjdGlvbkJhY2t3YXJkcyA9IHRydWU7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25GUFMgPSBmdW5jdGlvbiAoIG5hbWUsIGZwcyApIHtcclxuXHJcbiAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG4gICAgaWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG4gICAgICAgIGFuaW1hdGlvbi5mcHMgPSBmcHM7XHJcbiAgICAgICAgYW5pbWF0aW9uLmR1cmF0aW9uID0gKCBhbmltYXRpb24uZW5kIC0gYW5pbWF0aW9uLnN0YXJ0ICkgLyBhbmltYXRpb24uZnBzO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uRHVyYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUsIGR1cmF0aW9uICkge1xyXG5cclxuICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcbiAgICBpZiAoIGFuaW1hdGlvbiApIHtcclxuXHJcbiAgICAgICAgYW5pbWF0aW9uLmR1cmF0aW9uID0gZHVyYXRpb247XHJcbiAgICAgICAgYW5pbWF0aW9uLmZwcyA9ICggYW5pbWF0aW9uLmVuZCAtIGFuaW1hdGlvbi5zdGFydCApIC8gYW5pbWF0aW9uLmR1cmF0aW9uO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uV2VpZ2h0ID0gZnVuY3Rpb24gKCBuYW1lLCB3ZWlnaHQgKSB7XHJcblxyXG4gICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuICAgIGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuICAgICAgICBhbmltYXRpb24ud2VpZ2h0ID0gd2VpZ2h0O1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uVGltZSA9IGZ1bmN0aW9uICggbmFtZSwgdGltZSApIHtcclxuXHJcbiAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG4gICAgaWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG4gICAgICAgIGFuaW1hdGlvbi50aW1lID0gdGltZTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLmdldEFuaW1hdGlvblRpbWUgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG4gICAgdmFyIHRpbWUgPSAwO1xyXG5cclxuICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcbiAgICBpZiAoIGFuaW1hdGlvbiApIHtcclxuXHJcbiAgICAgICAgdGltZSA9IGFuaW1hdGlvbi50aW1lO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGltZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uRHVyYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG4gICAgdmFyIGR1cmF0aW9uID0gLSAxO1xyXG5cclxuICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcbiAgICBpZiAoIGFuaW1hdGlvbiApIHtcclxuXHJcbiAgICAgICAgZHVyYXRpb24gPSBhbmltYXRpb24uZHVyYXRpb247XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkdXJhdGlvbjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUucGxheUFuaW1hdGlvbiA9IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcbiAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG4gICAgaWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG4gICAgICAgIGFuaW1hdGlvbi50aW1lID0gMDtcclxuICAgICAgICBhbmltYXRpb24uYWN0aXZlID0gdHJ1ZTtcclxuXHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oIFwiVEhSRUUuTW9ycGhCbGVuZE1lc2g6IGFuaW1hdGlvbltcIiArIG5hbWUgKyBcIl0gdW5kZWZpbmVkIGluIC5wbGF5QW5pbWF0aW9uKClcIiApO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc3RvcEFuaW1hdGlvbiA9IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcbiAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG4gICAgaWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG4gICAgICAgIGFuaW1hdGlvbi5hY3RpdmUgPSBmYWxzZTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICggZGVsdGEgKSB7XHJcblxyXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMuYW5pbWF0aW9uc0xpc3QubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNMaXN0WyBpIF07XHJcblxyXG4gICAgICAgIGlmICggISBhbmltYXRpb24uYWN0aXZlICkgY29udGludWU7XHJcblxyXG4gICAgICAgIHZhciBmcmFtZVRpbWUgPSBhbmltYXRpb24uZHVyYXRpb24gLyBhbmltYXRpb24ubGVuZ3RoO1xyXG5cclxuICAgICAgICBhbmltYXRpb24udGltZSArPSBhbmltYXRpb24uZGlyZWN0aW9uICogZGVsdGE7XHJcblxyXG4gICAgICAgIGlmICggYW5pbWF0aW9uLm1pcnJvcmVkTG9vcCApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggYW5pbWF0aW9uLnRpbWUgPiBhbmltYXRpb24uZHVyYXRpb24gfHwgYW5pbWF0aW9uLnRpbWUgPCAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5kaXJlY3Rpb24gKj0gLSAxO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggYW5pbWF0aW9uLnRpbWUgPiBhbmltYXRpb24uZHVyYXRpb24gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi50aW1lID0gYW5pbWF0aW9uLmR1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGFuaW1hdGlvbi50aW1lIDwgMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLnRpbWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICBhbmltYXRpb24udGltZSA9IGFuaW1hdGlvbi50aW1lICUgYW5pbWF0aW9uLmR1cmF0aW9uO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBhbmltYXRpb24udGltZSA8IDAgKSBhbmltYXRpb24udGltZSArPSBhbmltYXRpb24uZHVyYXRpb247XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGtleWZyYW1lID0gYW5pbWF0aW9uLnN0YXJ0ICsgVEhSRUUuTWF0aC5jbGFtcCggTWF0aC5mbG9vciggYW5pbWF0aW9uLnRpbWUgLyBmcmFtZVRpbWUgKSwgMCwgYW5pbWF0aW9uLmxlbmd0aCAtIDEgKTtcclxuICAgICAgICB2YXIgd2VpZ2h0ID0gYW5pbWF0aW9uLndlaWdodDtcclxuXHJcbiAgICAgICAgaWYgKCBrZXlmcmFtZSAhPT0gYW5pbWF0aW9uLmN1cnJlbnRGcmFtZSApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24ubGFzdEZyYW1lIF0gPSAwO1xyXG4gICAgICAgICAgICB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgYW5pbWF0aW9uLmN1cnJlbnRGcmFtZSBdID0gMSAqIHdlaWdodDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBrZXlmcmFtZSBdID0gMDtcclxuXHJcbiAgICAgICAgICAgIGFuaW1hdGlvbi5sYXN0RnJhbWUgPSBhbmltYXRpb24uY3VycmVudEZyYW1lO1xyXG4gICAgICAgICAgICBhbmltYXRpb24uY3VycmVudEZyYW1lID0ga2V5ZnJhbWU7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG1peCA9ICggYW5pbWF0aW9uLnRpbWUgJSBmcmFtZVRpbWUgKSAvIGZyYW1lVGltZTtcclxuXHJcbiAgICAgICAgaWYgKCBhbmltYXRpb24uZGlyZWN0aW9uQmFja3dhcmRzICkgbWl4ID0gMSAtIG1peDtcclxuXHJcbiAgICAgICAgaWYgKCBhbmltYXRpb24uY3VycmVudEZyYW1lICE9PSBhbmltYXRpb24ubGFzdEZyYW1lICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgXSA9IG1peCAqIHdlaWdodDtcclxuICAgICAgICAgICAgdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5sYXN0RnJhbWUgXSA9ICggMSAtIG1peCApICogd2VpZ2h0O1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgXSA9IHdlaWdodDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqIEZvciBjcmVhdGluZyAzRCB0ZXh0IGdlb21ldHJ5IGluIHRocmVlLmpzXHJcbiAqXHJcbiAqIFRleHQgPSAzRCBUZXh0XHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqICBzaXplOiBcdFx0XHQ8ZmxvYXQ+LCBcdC8vIHNpemUgb2YgdGhlIHRleHRcclxuICogIGhlaWdodDogXHRcdDxmbG9hdD4sIFx0Ly8gdGhpY2tuZXNzIHRvIGV4dHJ1ZGUgdGV4dFxyXG4gKiAgY3VydmVTZWdtZW50czogXHQ8aW50PixcdFx0Ly8gbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgY3VydmVzXHJcbiAqXHJcbiAqICBmb250OiBcdFx0XHQ8c3RyaW5nPixcdFx0Ly8gZm9udCBuYW1lXHJcbiAqICB3ZWlnaHQ6IFx0XHQ8c3RyaW5nPixcdFx0Ly8gZm9udCB3ZWlnaHQgKG5vcm1hbCwgYm9sZClcclxuICogIHN0eWxlOiBcdFx0XHQ8c3RyaW5nPixcdFx0Ly8gZm9udCBzdHlsZSAgKG5vcm1hbCwgaXRhbGljcylcclxuICpcclxuICogIGJldmVsRW5hYmxlZDpcdDxib29sPixcdFx0XHQvLyB0dXJuIG9uIGJldmVsXHJcbiAqICBiZXZlbFRoaWNrbmVzczogPGZsb2F0PiwgXHRcdC8vIGhvdyBkZWVwIGludG8gdGV4dCBiZXZlbCBnb2VzXHJcbiAqICBiZXZlbFNpemU6XHRcdDxmbG9hdD4sIFx0XHQvLyBob3cgZmFyIGZyb20gdGV4dCBvdXRsaW5lIGlzIGJldmVsXHJcbiAqICB9XHJcbiAqXHJcbiAqL1xyXG5cclxuLypcdFVzYWdlIEV4YW1wbGVzXHJcblxyXG4gLy8gVGV4dEdlb21ldHJ5IHdyYXBwZXJcclxuXHJcbiB2YXIgdGV4dDNkID0gbmV3IFRleHRHZW9tZXRyeSggdGV4dCwgb3B0aW9ucyApO1xyXG5cclxuIC8vIENvbXBsZXRlIG1hbm5lclxyXG5cclxuIHZhciB0ZXh0U2hhcGVzID0gVEhSRUUuRm9udFV0aWxzLmdlbmVyYXRlU2hhcGVzKCB0ZXh0LCBvcHRpb25zICk7XHJcbiB2YXIgdGV4dDNkID0gbmV3IEV4dHJ1ZGVHZW9tZXRyeSggdGV4dFNoYXBlcywgb3B0aW9ucyApO1xyXG5cclxuICovXHJcblxyXG5USFJFRS5UZXh0R2VvbWV0cnkgPSBmdW5jdGlvbiAoIHRleHQsIHBhcmFtZXRlcnMgKSB7XHJcblxyXG4gICAgcGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XHJcblxyXG4gICAgdmFyIHRleHRTaGFwZXMgPSBUSFJFRS5Gb250VXRpbHMuZ2VuZXJhdGVTaGFwZXMoIHRleHQsIHBhcmFtZXRlcnMgKTtcclxuXHJcbiAgICAvLyB0cmFuc2xhdGUgcGFyYW1ldGVycyB0byBFeHRydWRlR2VvbWV0cnkgQVBJXHJcblxyXG4gICAgcGFyYW1ldGVycy5hbW91bnQgPSBwYXJhbWV0ZXJzLmhlaWdodCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5oZWlnaHQgOiA1MDtcclxuXHJcbiAgICAvLyBkZWZhdWx0c1xyXG5cclxuICAgIGlmICggcGFyYW1ldGVycy5iZXZlbFRoaWNrbmVzcyA9PT0gdW5kZWZpbmVkICkgcGFyYW1ldGVycy5iZXZlbFRoaWNrbmVzcyA9IDEwO1xyXG4gICAgaWYgKCBwYXJhbWV0ZXJzLmJldmVsU2l6ZSA9PT0gdW5kZWZpbmVkICkgcGFyYW1ldGVycy5iZXZlbFNpemUgPSA4O1xyXG4gICAgaWYgKCBwYXJhbWV0ZXJzLmJldmVsRW5hYmxlZCA9PT0gdW5kZWZpbmVkICkgcGFyYW1ldGVycy5iZXZlbEVuYWJsZWQgPSBmYWxzZTtcclxuXHJcbiAgICBUSFJFRS5FeHRydWRlR2VvbWV0cnkuY2FsbCggdGhpcywgdGV4dFNoYXBlcywgcGFyYW1ldGVycyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdUZXh0R2VvbWV0cnknO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlRleHRHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLlRleHRHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5UZXh0R2VvbWV0cnk7XHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKlxyXG4gKiBGb3IgVGV4dCBvcGVyYXRpb25zIGluIHRocmVlLmpzIChTZWUgVGV4dEdlb21ldHJ5KVxyXG4gKlxyXG4gKiBJdCB1c2VzIHRlY2huaXF1ZXMgdXNlZCBpbjpcclxuICpcclxuICpcdFRyaWFuZ3VsYXRpb24gcG9ydGVkIGZyb20gQVMzXHJcbiAqXHRcdFNpbXBsZSBQb2x5Z29uIFRyaWFuZ3VsYXRpb25cclxuICpcdFx0aHR0cDovL2FjdGlvbnNuaXBwZXQuY29tLz9wPTE0NjJcclxuICpcclxuICogXHRBIE1ldGhvZCB0byB0cmlhbmd1bGF0ZSBzaGFwZXMgd2l0aCBob2xlc1xyXG4gKlx0XHRodHRwOi8vd3d3LnNha3JpLm5ldC9ibG9nLzIwMDkvMDYvMTIvYW4tYXBwcm9hY2gtdG8tdHJpYW5ndWxhdGluZy1wb2x5Z29ucy13aXRoLWhvbGVzL1xyXG4gKlxyXG4gKi9cclxuXHJcblRIUkVFLkZvbnRVdGlscyA9IHtcclxuXHJcbiAgICBmYWNlczoge30sXHJcblxyXG4gICAgLy8gSnVzdCBmb3Igbm93LiBmYWNlW3dlaWdodF1bc3R5bGVdXHJcblxyXG4gICAgZmFjZTogJ2hlbHZldGlrZXInLFxyXG4gICAgd2VpZ2h0OiAnbm9ybWFsJyxcclxuICAgIHN0eWxlOiAnbm9ybWFsJyxcclxuICAgIHNpemU6IDE1MCxcclxuICAgIGRpdmlzaW9uczogMTAsXHJcblxyXG4gICAgZ2V0RmFjZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0cnkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFjZXNbIHRoaXMuZmFjZS50b0xvd2VyQ2FzZSgpIF1bIHRoaXMud2VpZ2h0IF1bIHRoaXMuc3R5bGUgXTtcclxuXHJcbiAgICAgICAgfSBjYXRjaCAoIGUgKSB7XHJcblxyXG4gICAgICAgICAgICB0aHJvdyBcIlRoZSBmb250IFwiICsgdGhpcy5mYWNlICsgXCIgd2l0aCBcIiArIHRoaXMud2VpZ2h0ICsgXCIgd2VpZ2h0IGFuZCBcIiArIHRoaXMuc3R5bGUgKyBcIiBzdHlsZSBpcyBtaXNzaW5nLlwiXHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGxvYWRGYWNlOiBmdW5jdGlvbiAoIGRhdGEgKSB7XHJcblxyXG4gICAgICAgIHZhciBmYW1pbHkgPSBkYXRhLmZhbWlseU5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICAgICAgdmFyIFRocmVlRm9udCA9IHRoaXM7XHJcblxyXG4gICAgICAgIFRocmVlRm9udC5mYWNlc1sgZmFtaWx5IF0gPSBUaHJlZUZvbnQuZmFjZXNbIGZhbWlseSBdIHx8IHt9O1xyXG5cclxuICAgICAgICBUaHJlZUZvbnQuZmFjZXNbIGZhbWlseSBdWyBkYXRhLmNzc0ZvbnRXZWlnaHQgXSA9IFRocmVlRm9udC5mYWNlc1sgZmFtaWx5IF1bIGRhdGEuY3NzRm9udFdlaWdodCBdIHx8IHt9O1xyXG4gICAgICAgIFRocmVlRm9udC5mYWNlc1sgZmFtaWx5IF1bIGRhdGEuY3NzRm9udFdlaWdodCBdWyBkYXRhLmNzc0ZvbnRTdHlsZSBdID0gZGF0YTtcclxuXHJcbiAgICAgICAgVGhyZWVGb250LmZhY2VzWyBmYW1pbHkgXVsgZGF0YS5jc3NGb250V2VpZ2h0IF1bIGRhdGEuY3NzRm9udFN0eWxlIF0gPSBkYXRhO1xyXG5cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRyYXdUZXh0OiBmdW5jdGlvbiAoIHRleHQgKSB7XHJcblxyXG4gICAgICAgIC8vIFJlbmRlclRleHRcclxuXHJcbiAgICAgICAgdmFyIGksXHJcbiAgICAgICAgICAgIGZhY2UgPSB0aGlzLmdldEZhY2UoKSxcclxuICAgICAgICAgICAgc2NhbGUgPSB0aGlzLnNpemUgLyBmYWNlLnJlc29sdXRpb24sXHJcbiAgICAgICAgICAgIG9mZnNldCA9IDAsXHJcbiAgICAgICAgICAgIGNoYXJzID0gU3RyaW5nKCB0ZXh0ICkuc3BsaXQoICcnICksXHJcbiAgICAgICAgICAgIGxlbmd0aCA9IGNoYXJzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgdmFyIGZvbnRQYXRocyA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBwYXRoID0gbmV3IFRIUkVFLlBhdGgoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciByZXQgPSB0aGlzLmV4dHJhY3RHbHlwaFBvaW50cyggY2hhcnNbIGkgXSwgZmFjZSwgc2NhbGUsIG9mZnNldCwgcGF0aCApO1xyXG4gICAgICAgICAgICBvZmZzZXQgKz0gcmV0Lm9mZnNldDtcclxuXHJcbiAgICAgICAgICAgIGZvbnRQYXRocy5wdXNoKCByZXQucGF0aCApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGdldCB0aGUgd2lkdGhcclxuXHJcbiAgICAgICAgdmFyIHdpZHRoID0gb2Zmc2V0IC8gMjtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIGZvciAoIHAgPSAwOyBwIDwgYWxsUHRzLmxlbmd0aDsgcCsrICkge1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gXHRhbGxQdHNbIHAgXS54IC09IHdpZHRoO1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICAvL3ZhciBleHRyYWN0ID0gdGhpcy5leHRyYWN0UG9pbnRzKCBhbGxQdHMsIGNoYXJhY3RlclB0cyApO1xyXG4gICAgICAgIC8vZXh0cmFjdC5jb250b3VyID0gYWxsUHRzO1xyXG5cclxuICAgICAgICAvL2V4dHJhY3QucGF0aHMgPSBmb250UGF0aHM7XHJcbiAgICAgICAgLy9leHRyYWN0Lm9mZnNldCA9IHdpZHRoO1xyXG5cclxuICAgICAgICByZXR1cm4geyBwYXRoczogZm9udFBhdGhzLCBvZmZzZXQ6IHdpZHRoIH07XHJcblxyXG4gICAgfSxcclxuXHJcblxyXG5cclxuXHJcbiAgICBleHRyYWN0R2x5cGhQb2ludHM6IGZ1bmN0aW9uICggYywgZmFjZSwgc2NhbGUsIG9mZnNldCwgcGF0aCApIHtcclxuXHJcbiAgICAgICAgdmFyIHB0cyA9IFtdO1xyXG5cclxuICAgICAgICB2YXIgYjIgPSBUSFJFRS5TaGFwZVV0aWxzLmIyO1xyXG4gICAgICAgIHZhciBiMyA9IFRIUkVFLlNoYXBlVXRpbHMuYjM7XHJcblxyXG4gICAgICAgIHZhciBpLCBpMiwgZGl2aXNpb25zLFxyXG4gICAgICAgICAgICBvdXRsaW5lLCBhY3Rpb24sIGxlbmd0aCxcclxuICAgICAgICAgICAgc2NhbGVYLCBzY2FsZVksXHJcbiAgICAgICAgICAgIHgsIHksIGNweCwgY3B5LCBjcHgwLCBjcHkwLCBjcHgxLCBjcHkxLCBjcHgyLCBjcHkyLFxyXG4gICAgICAgICAgICBsYXN0ZSxcclxuICAgICAgICAgICAgZ2x5cGggPSBmYWNlLmdseXBoc1sgYyBdIHx8IGZhY2UuZ2x5cGhzWyAnPycgXTtcclxuXHJcbiAgICAgICAgaWYgKCAhIGdseXBoICkgcmV0dXJuO1xyXG5cclxuICAgICAgICBpZiAoIGdseXBoLm8gKSB7XHJcblxyXG4gICAgICAgICAgICBvdXRsaW5lID0gZ2x5cGguX2NhY2hlZE91dGxpbmUgfHwgKCBnbHlwaC5fY2FjaGVkT3V0bGluZSA9IGdseXBoLm8uc3BsaXQoICcgJyApICk7XHJcbiAgICAgICAgICAgIGxlbmd0aCA9IG91dGxpbmUubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgc2NhbGVYID0gc2NhbGU7XHJcbiAgICAgICAgICAgIHNjYWxlWSA9IHNjYWxlO1xyXG5cclxuICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBsZW5ndGg7ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGFjdGlvbiA9IG91dGxpbmVbIGkgKysgXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCBhY3Rpb24gKTtcclxuXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKCBhY3Rpb24gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ20nOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSBUb1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlWCArIG9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlWTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGgubW92ZVRvKCB4LCB5ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdsJzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExpbmUgVG9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZVggKyBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZVk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGgubGluZVRvKCB4LCB5ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdxJzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFF1YWRyYXRpY0N1cnZlVG9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCAgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZVggKyBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSAgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZVk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweDEgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZVggKyBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweTEgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZVk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLnF1YWRyYXRpY0N1cnZlVG8oIGNweDEsIGNweTEsIGNweCwgY3B5ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0ZSA9IHB0c1sgcHRzLmxlbmd0aCAtIDEgXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbGFzdGUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3B4MCA9IGxhc3RlLng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcHkwID0gbGFzdGUueTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBpMiA9IDEsIGRpdmlzaW9ucyA9IHRoaXMuZGl2aXNpb25zOyBpMiA8PSBkaXZpc2lvbnM7IGkyICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGkyIC8gZGl2aXNpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIyKCB0LCBjcHgwLCBjcHgxLCBjcHggKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiMiggdCwgY3B5MCwgY3B5MSwgY3B5ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2InOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3ViaWMgQmV6aWVyIEN1cnZlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggID0gb3V0bGluZVsgaSArKyBdICogc2NhbGVYICsgb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgID0gb3V0bGluZVsgaSArKyBdICogc2NhbGVZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHgxID0gb3V0bGluZVsgaSArKyBdICogc2NhbGVYICsgb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkxID0gb3V0bGluZVsgaSArKyBdICogc2NhbGVZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHgyID0gb3V0bGluZVsgaSArKyBdICogc2NhbGVYICsgb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkyID0gb3V0bGluZVsgaSArKyBdICogc2NhbGVZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5iZXppZXJDdXJ2ZVRvKCBjcHgxLCBjcHkxLCBjcHgyLCBjcHkyLCBjcHgsIGNweSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdGUgPSBwdHNbIHB0cy5sZW5ndGggLSAxIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGxhc3RlICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNweDAgPSBsYXN0ZS54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3B5MCA9IGxhc3RlLnk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggaTIgPSAxLCBkaXZpc2lvbnMgPSB0aGlzLmRpdmlzaW9uczsgaTIgPD0gZGl2aXNpb25zOyBpMiArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBpMiAvIGRpdmlzaW9ucztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiMyggdCwgY3B4MCwgY3B4MSwgY3B4MiwgY3B4ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYjMoIHQsIGNweTAsIGNweTEsIGNweTIsIGNweSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuXHJcblxyXG4gICAgICAgIHJldHVybiB7IG9mZnNldDogZ2x5cGguaGEgKiBzY2FsZSwgcGF0aDogcGF0aCB9O1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5cclxuVEhSRUUuRm9udFV0aWxzLmdlbmVyYXRlU2hhcGVzID0gZnVuY3Rpb24gKCB0ZXh0LCBwYXJhbWV0ZXJzICkge1xyXG5cclxuICAgIC8vIFBhcmFtZXRlcnNcclxuXHJcbiAgICBwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCB7fTtcclxuXHJcbiAgICB2YXIgc2l6ZSA9IHBhcmFtZXRlcnMuc2l6ZSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5zaXplIDogMTAwO1xyXG4gICAgdmFyIGN1cnZlU2VnbWVudHMgPSBwYXJhbWV0ZXJzLmN1cnZlU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY3VydmVTZWdtZW50cyA6IDQ7XHJcblxyXG4gICAgdmFyIGZvbnQgPSBwYXJhbWV0ZXJzLmZvbnQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuZm9udCA6ICdoZWx2ZXRpa2VyJztcclxuICAgIHZhciB3ZWlnaHQgPSBwYXJhbWV0ZXJzLndlaWdodCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy53ZWlnaHQgOiAnbm9ybWFsJztcclxuICAgIHZhciBzdHlsZSA9IHBhcmFtZXRlcnMuc3R5bGUgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuc3R5bGUgOiAnbm9ybWFsJztcclxuXHJcbiAgICBUSFJFRS5Gb250VXRpbHMuc2l6ZSA9IHNpemU7XHJcbiAgICBUSFJFRS5Gb250VXRpbHMuZGl2aXNpb25zID0gY3VydmVTZWdtZW50cztcclxuXHJcbiAgICBUSFJFRS5Gb250VXRpbHMuZmFjZSA9IGZvbnQ7XHJcbiAgICBUSFJFRS5Gb250VXRpbHMud2VpZ2h0ID0gd2VpZ2h0O1xyXG4gICAgVEhSRUUuRm9udFV0aWxzLnN0eWxlID0gc3R5bGU7XHJcblxyXG4gICAgLy8gR2V0IGEgRm9udCBkYXRhIGpzb24gb2JqZWN0XHJcblxyXG4gICAgdmFyIGRhdGEgPSBUSFJFRS5Gb250VXRpbHMuZHJhd1RleHQoIHRleHQgKTtcclxuXHJcbiAgICB2YXIgcGF0aHMgPSBkYXRhLnBhdGhzO1xyXG4gICAgdmFyIHNoYXBlcyA9IFtdO1xyXG5cclxuICAgIGZvciAoIHZhciBwID0gMCwgcGwgPSBwYXRocy5sZW5ndGg7IHAgPCBwbDsgcCArKyApIHtcclxuXHJcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoIHNoYXBlcywgcGF0aHNbIHAgXS50b1NoYXBlcygpICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzaGFwZXM7XHJcblxyXG59O1xyXG5cclxuLy8gVG8gdXNlIHRoZSB0eXBlZmFjZS5qcyBmYWNlIGZpbGVzLCBob29rIHVwIHRoZSBBUElcclxuXHJcblRIUkVFLnR5cGVmYWNlX2pzID0geyBmYWNlczogVEhSRUUuRm9udFV0aWxzLmZhY2VzLCBsb2FkRmFjZTogVEhSRUUuRm9udFV0aWxzLmxvYWRGYWNlIH07XHJcbmlmICggdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICkgc2VsZi5fdHlwZWZhY2VfanMgPSBUSFJFRS50eXBlZmFjZV9qcztcclxuXHJcblxyXG5cclxuXHJcbi8vIEZyb20gZ2l0aHViIHJlcG9zaXRvcnkgYXQgdGhyZWUuanNcXGV4YW1wbGVzXFxmb250c2hlbHZldGlrZXJfcmVndWxhci50eXBlZmFjZS5qc1xyXG5pZiAoX3R5cGVmYWNlX2pzICYmIF90eXBlZmFjZV9qcy5sb2FkRmFjZSkgX3R5cGVmYWNlX2pzLmxvYWRGYWNlKHtcImdseXBoc1wiOntcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjcxMixcImhhXCI6ODE1LFwib1wiOlwibSAzNTYgLTI1IHEgOTYgODggMTkyIC0yNSBxIDAgMzY4IDAgMjAxIHEgOTIgNjQyIDAgNTMzIHEgMzU2IDc2MSAxOTIgNzYxIHEgNjE3IDY0NCA1MTcgNzYxIHEgNzEyIDM2OCA3MTIgNTMzIHEgNjE5IDkxIDcxMiAyMDEgcSAzNTYgLTI1IDUyMCAtMjUgbSAzNTYgODUgcSA1MjcgMTc1IDQ2NSA4NSBxIDU4MyAzNjkgNTgzIDI1NSBxIDUyOCA1NjIgNTgzIDQ4NCBxIDM1NiA2NTEgNDY2IDY1MSBxIDE4OSA1NjAgMjUwIDY1MSBxIDEzNSAzNjkgMTM1IDQ4MSBxIDE4NyAxNzcgMTM1IDI1NyBxIDM1NiA4NSAyNTAgODUgXCJ9LFwiU1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6Nzg4LFwiaGFcIjo4OTAsXCJvXCI6XCJtIDc4OCAyOTEgcSA2NjIgNTQgNzg4IDE0NCBxIDM5NyAtMjYgNTUwIC0yNiBxIDExNiA2OCAyMjYgLTI2IHEgMCAzMzcgMCAxNjggbCAxMzEgMzM3IHEgMjAwIDE1MiAxMzEgMjIwIHEgMzg0IDg1IDI2OSA4NSBxIDU1NyAxMjkgNDc5IDg1IHEgNjUwIDI3MCA2NTAgMTgzIHEgNDkwIDQyOSA2NTAgMzc5IHEgMTk0IDUxMyAzNDEgNDcwIHEgMzMgNzM5IDMzIDU4NCBxIDE0MiA5NjQgMzMgODgxIHEgMzg4IDEwNDEgMjQyIDEwNDEgcSA2NDQgOTU3IDU0MyAxMDQxIHEgNzU2IDcxNiA3NTYgODY3IGwgNjI1IDcxNiBxIDU2MSA4NzQgNjI1IDgxNiBxIDM5NSA5MzMgNDk3IDkzMyBxIDI0MyA4OTEgMzA5IDkzMyBxIDE2NCA3NTkgMTY0IDg0MSBxIDMyNSA2MDkgMTY0IDY1NiBxIDYyNSA1MjYgNDc1IDU2OCBxIDc4OCAyOTEgNzg4IDQ1NCBcIn0sXCLvv71cIjp7XCJ4X21pblwiOjM0MyxcInhfbWF4XCI6NDQ5LFwiaGFcIjo3OTIsXCJvXCI6XCJtIDQ0OSA0NjIgbCAzNDMgNDYyIGwgMzQzIDk4NiBsIDQ0OSA5ODYgbCA0NDkgNDYyIG0gNDQ5IC0yNDIgbCAzNDMgLTI0MiBsIDM0MyAyODAgbCA0NDkgMjgwIGwgNDQ5IC0yNDIgXCJ9LFwiL1wiOntcInhfbWluXCI6MTgzLjI1LFwieF9tYXhcIjo2MDguMzI4MTI1LFwiaGFcIjo3OTIsXCJvXCI6XCJtIDYwOCAxMDQxIGwgMjY2IC0xMjkgbCAxODMgLTEyOSBsIDUyMCAxMDQxIGwgNjA4IDEwNDEgXCJ9LFwiP1wiOntcInhfbWluXCI6LTAuNDM3NSxcInhfbWF4XCI6Nzc3LjQ1MzEyNSxcImhhXCI6ODM5LFwib1wiOlwibSA3NzcgODkzIGwgNDU4IDg5MyBsIDQ1OCAwIGwgMzE5IDAgbCAzMTkgODkyIGwgMCA4OTIgbCAwIDEwMTMgbCA3NzcgMTAxMyBsIDc3NyA4OTMgXCJ9LFwieVwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6Njg0Ljc4MTI1LFwiaGFcIjo3NzEsXCJvXCI6XCJtIDY4NCA3MzggbCAzODggLTgzIHEgMzExIC0yMTYgMzU2IC0xNjcgcSAxNzMgLTI3OSAyNTIgLTI3OSBxIDk3IC0yNjYgMTMzIC0yNzkgbCA5NyAtMTQ5IHEgMTMyIC0xNTUgMTA5IC0xNTEgcSAxNjggLTE2MCAxNTUgLTE2MCBxIDI0MCAtMTE0IDIxMyAtMTYwIHEgMjc0IC0yNiAyNDggLTk4IGwgMCA3MzggbCAxMzcgNzM3IGwgMzQxIDEzOSBsIDU0OCA3MzcgbCA2ODQgNzM4IFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjgwMyxcImhhXCI6OTE3LFwib1wiOlwibSA4MDMgMCBsIDY2NyAwIGwgNjY3IDg4NiBsIDE0MCA4ODYgbCAxNDAgMCBsIDAgMCBsIDAgMTAxMiBsIDgwMyAxMDEyIGwgODAzIDAgXCJ9LFwiP1wiOntcInhfbWluXCI6LTExMSxcInhfbWF4XCI6MzM5LFwiaGFcIjozNjEsXCJvXCI6XCJtIDMzOSA4MDAgbCAyMjkgODAwIGwgMjI5IDkyNSBsIDMzOSA5MjUgbCAzMzkgODAwIG0gLTEgODAwIGwgLTExMSA4MDAgbCAtMTExIDkyNSBsIC0xIDkyNSBsIC0xIDgwMCBtIDI4NCAzIHEgMjMzIC0xMCAyNTggLTUgcSAxODIgLTE1IDIwNyAtMTUgcSA4NSAyNiAxMTkgLTE1IHEgNDIgMjAwIDQyIDc5IGwgNDIgNzM3IGwgMTY3IDczNyBsIDE2OCAyMTUgcSAxNzIgMTQxIDE2OCAxNTcgcSAyMjYgMTAxIDE4MyAxMDEgcSAyNDggMTAzIDIzOSAxMDEgcSAyODQgMTEyIDI1NyAxMDQgbCAyODQgMyBtIDMwMiAxMDQwIGwgMTEzIDgxOSBsIDMwIDgxOSBsIDE2NSAxMDQwIGwgMzAyIDEwNDAgXCJ9LFwiZ1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6Njg2LFwiaGFcIjo4MzgsXCJvXCI6XCJtIDY4NiAzNCBxIDU4NiAtMjEzIDY4NiAtMTIxIHEgMzMxIC0zMDYgNDg3IC0zMDYgcSAxMzEgLTI1MiAyMTYgLTMwNiBxIDMxIC04NCAzMSAtMTkwIGwgMTU1IC04NCBxIDIyOCAtMTc0IDE2NiAtMTM4IHEgMzQ1IC0yMDcgMjg0IC0yMDcgcSA1MTQgLTEwOSA0NTQgLTIwNyBxIDU2NCA4OSA1NjQgLTI3IHEgNDYxIDYgNTIxIDM2IHEgMzM1IC0yMyA0MDEgLTIzIHEgODggMTAwIDE4NCAtMjMgcSAwIDM3MCAwIDIxNSBxIDg3IDYzNCAwIDUyMiBxIDMzMCA3NTggMTgzIDc1OCBxIDQ1NyA3MjggMzk4IDc1OCBxIDU2NCA2NDQgNTE1IDY5OSBsIDU2NCA3MzcgbCA2ODYgNzM3IGwgNjg2IDM0IG0gNTgyIDM2NyBxIDUyOSA1NjAgNTgyIDQ4MSBxIDM1OCA2NTIgNDY4IDY1MiBxIDE4OSA1NjEgMjUwIDY1MiBxIDEzNSAzNjkgMTM1IDQ4MiBxIDE4OSAxNzYgMTM1IDI1NSBxIDM2MSA4NSAyNTEgODUgcSA1MjkgMTc2IDQ2OCA4NSBxIDU4MiAzNjcgNTgyIDI1NSBcIn0sXCLvv71cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjQ0MixcImhhXCI6NTM5LFwib1wiOlwibSA0NDIgMzgzIGwgMCAzODMgcSA5MSA1NjYgMCA0OTIgcSAyNjAgNjY4IDE3NiA2MTcgcSAzNTQgNzk4IDM1NCA3MjcgcSAzMTUgODc1IDM1NCA4NDUgcSAyMjcgOTA1IDI3NyA5MDUgcSAxMzYgODY5IDE3MyA5MDUgcSA5OSA3NjEgOTkgODMzIGwgMTQgNzYxIHEgODIgOTIyIDE0IDg2NCBxIDIzMiA5NzQgMTQxIDk3NCBxIDM3OSA5MjYgMzE2IDk3NCBxIDQ0MiA3OTcgNDQyIDg3OCBxIDM1MSA2MzUgNDQyIDcwNCBxIDE4MyA1MzkgMzIxIDYxMSBxIDkyIDQ1NSA5MiA0OTEgbCA0NDIgNDU1IGwgNDQyIDM4MyBcIn0sXCLvv71cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjcwNS41NjI1LFwiaGFcIjo4MDMsXCJvXCI6XCJtIDcwNSAzMzQgbCAwIDMzNCBsIDAgNDEwIGwgNzA1IDQxMCBsIDcwNSAzMzQgXCJ9LFwiP1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6ODE5LjU2MjUsXCJoYVwiOjg5MyxcIm9cIjpcIm0gODE5IDAgbCA2NTAgMCBsIDI5NCA1MDkgbCAxMzkgMzU2IGwgMTM5IDAgbCAwIDAgbCAwIDEwMTMgbCAxMzkgMTAxMyBsIDEzOSA1MjYgbCA2MjYgMTAxMyBsIDgwOSAxMDEzIGwgMzk1IDYwMCBsIDgxOSAwIFwifSxcIu+/vVwiOntcInhfbWluXCI6LTQ2LjI2NTYyNSxcInhfbWF4XCI6MzkyLFwiaGFcIjo1MTMsXCJvXCI6XCJtIDM5MiA2NTEgbCAyNTkgNjUxIGwgNzkgLTI3OSBsIC00NiAtMjc4IGwgMTM0IDY1MSBsIDE0IDY1MSBsIDE0IDc1MSBsIDEzNSA3NTEgcSAxNTEgOTQ4IDEzNSA5MDAgcSAzMDQgMTA0MSAxODUgMTA0MSBxIDMzNCAxMDQwIDMxOSAxMDQxIHEgMzkyIDEwMzQgMzQ4IDEwMzkgbCAzOTIgOTIyIHEgMzM3IDkzMSAzNjAgOTMxIHEgMjcxIDg4MyAyODcgOTMxIHEgMjYwIDc5MyAyNjAgODUzIGwgMjYwIDc1MSBsIDM5MiA3NTEgbCAzOTIgNjUxIFwifSxcImVcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjcxNCxcImhhXCI6ODEzLFwib1wiOlwibSA3MTQgMzI2IGwgMTQwIDMyNiBxIDIwMCAxNTcgMTQwIDIyNyBxIDM1OSA4NyAyNjAgODcgcSA0ODggMTMwIDQzMSA4NyBxIDU2MSAyNDUgNTQ1IDE3NCBsIDY5NyAyNDUgcSA1NzcgNDggNjcwIDEyMyBxIDM1OCAtMjYgNDg0IC0yNiBxIDk3IDg1IDE5NSAtMjYgcSAwIDM2MyAwIDE5NyBxIDk0IDY0MiAwIDUyOSBxIDM1OCA3NjUgMTk1IDc2NSBxIDYyNiA2MjcgNTI5IDc2NSBxIDcxNCAzMjYgNzE0IDUwMyBtIDU3NiA0MjkgcSA1MDcgNTgzIDU2NCA1MjIgcSAzNTUgNjUwIDQ0NSA2NTAgcSAyMDYgNTgzIDI2NiA2NTAgcSAxNDAgNDI5IDE1MiA1MjIgbCA1NzYgNDI5IFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjcxMixcImhhXCI6ODE1LFwib1wiOlwibSAzNTYgLTI1IHEgOTQgOTEgMTk0IC0yNSBxIDAgMzY4IDAgMjAyIHEgOTIgNjQyIDAgNTMzIHEgMzU2IDc2MSAxOTIgNzYxIHEgNjE3IDY0NCA1MTcgNzYxIHEgNzEyIDM2OCA3MTIgNTMzIHEgNjE5IDkxIDcxMiAyMDEgcSAzNTYgLTI1IDUyMCAtMjUgbSAzNTYgODUgcSA1MjcgMTc1IDQ2NSA4NSBxIDU4MyAzNjkgNTgzIDI1NSBxIDUyOCA1NjIgNTgzIDQ4NCBxIDM1NiA2NTEgNDY2IDY1MSBxIDE4OSA1NjAgMjUwIDY1MSBxIDEzNSAzNjkgMTM1IDQ4MSBxIDE4NyAxNzcgMTM1IDI1NyBxIDM1NiA4NSAyNTAgODUgbSA1NzYgMTA0MCBsIDM4NyA4MTkgbCAzMDMgODE5IGwgNDM4IDEwNDAgbCA1NzYgMTA0MCBcIn0sXCJKXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo1ODgsXCJoYVwiOjY5OSxcIm9cIjpcIm0gNTg4IDI3OSBxIDI4NyAtMjYgNTg4IC0yNiBxIDU4IDczIDEyNiAtMjYgcSAwIDMyNyAwIDE1OCBsIDEzMyAzMjcgcSAxNjAgMTcyIDEzMyAyMjcgcSAyODggOTYgMTk4IDk2IHEgNDI2IDE3MSAzOTEgOTYgcSA0NDkgMzM2IDQ0OSAyMTkgbCA0NDkgMTAxMyBsIDU4OCAxMDEzIGwgNTg4IDI3OSBcIn0sXCLvv71cIjp7XCJ4X21pblwiOi0xLFwieF9tYXhcIjo1MDMsXCJoYVwiOjYwMSxcIm9cIjpcIm0gNTAzIDMwMiBsIDI4MCAxMzYgbCAyODEgMjU2IGwgNDI5IDM3MyBsIDI4MSA0ODYgbCAyODAgNjA4IGwgNTAzIDQ0MCBsIDUwMyAzMDIgbSAyMjEgMzAyIGwgMCAxMzYgbCAwIDI1NSBsIDE0NSAzNzIgbCAwIDQ4NiBsIC0xIDYwOCBsIDIyMSA0NDAgbCAyMjEgMzAyIFwifSxcIu+/vVwiOntcInhfbWluXCI6LTMsXCJ4X21heFwiOjEwMDgsXCJoYVwiOjExMDYsXCJvXCI6XCJtIDUwMiAtNyBxIDEyMyAxNTEgMjYzIC03IHEgLTMgNTAxIC0zIDI5NCBxIDEyMyA4NTEgLTMgNzA2IHEgNTAyIDEwMTEgMjYzIDEwMTEgcSA4ODEgODUxIDczOSAxMDExIHEgMTAwOCA1MDEgMTAwOCA3MDggcSA4ODMgMTUxIDEwMDggMjkyIHEgNTAyIC03IDc0NCAtNyBtIDUwMiA2MCBxIDgzMCAxOTcgNzA5IDYwIHEgOTQwIDUwMSA5NDAgMzIyIHEgODMxIDgwNSA5NDAgNjgxIHEgNTAyIDk0NCA3MDkgOTQ0IHEgMTc0IDgwNSAyOTYgOTQ0IHEgNjUgNTAxIDY1IDY4MCBxIDE3MyAxOTcgNjUgMzIwIHEgNTAyIDYwIDI5NCA2MCBtIDc0MSAzOTQgcSA2NjEgMjQ2IDczMSAzMDIgcSA0OTYgMTkwIDU5MSAxOTAgcSAyOTQgMjg1IDM2OSAxOTAgcSAyMjggNDk3IDIyOCAzNzAgcSAyOTUgNzE0IDIyOCA2MjUgcSA0OTkgODEzIDM3MCA4MTMgcSA2NTYgNzYyIDU4OCA4MTMgcSA3MzMgNjI1IDcyNCA3MTEgbCA2MzQgNjI1IHEgNTg5IDcwNCA2MjkgNjczIHEgNDk4IDczNSA1NTAgNzM1IHEgMzc3IDY2NiA0MjEgNzM1IHEgMzM0IDUwNCAzMzQgNTk3IHEgMzc0IDM0MCAzMzQgNDA4IHEgNDkwIDI3MiA0MTUgMjcyIHEgNTg5IDMwNCA1NDkgMjcyIHEgNjM4IDM5NCA2MjggMzM3IGwgNzQxIDM5NCBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo5MjIsXCJoYVwiOjEwMzAsXCJvXCI6XCJtIDY4NyAxMDQwIGwgNDk4IDgxOSBsIDQxNSA4MTkgbCA1NDkgMTA0MCBsIDY4NyAxMDQwIG0gOTIyIDMzOSBxIDg1NiA5NyA5MjIgMjAzIHEgNjUwIC0yNiA3ODAgLTI2IHEgNTM4IDkgNTg3IC0yNiBxIDQ2MSAxMDMgNDg5IDQ0IHEgMzg3IDEyIDQzNiA0NiBxIDI3NyAtMjIgMzM5IC0yMiBxIDY5IDk3IDE0NyAtMjIgcSAwIDMzOCAwIDIwMiBxIDQ1IDU1MSAwIDQ0NCBxIDE2MSA3MzcgODQgNjQzIGwgMzAyIDczNyBxIDE3NSA1NTIgMjE5IDY0NyBxIDEyNCAzMzYgMTI0IDQ0NiBxIDE1NSAxNzkgMTI0IDI0OCBxIDI3NSA4OCAxOTcgODggcSAzNzUgMTYzIDM0MSA4OCBxIDQwMCAyOTQgNDAwIDIxOSBsIDQwMCA1NzIgbCA1MjQgNTcyIGwgNTI0IDI5NCBxIDU2MSAxMzUgNTI0IDE5MiBxIDY0MyA4OCA1OTEgODggcSA3NjIgMTgyIDcxOSA4OCBxIDc5NyAzNDEgNzk3IDI1NyBxIDc0NSA1NTUgNzk3IDQ1MCBxIDYxOSA3MzcgNzA1IDYzNyBsIDc2MCA3MzcgcSA4NzQgNTUxIDgzNSA2NDAgcSA5MjIgMzM5IDkyMiA0NDQgXCJ9LFwiXlwiOntcInhfbWluXCI6MTkzLjA2MjUsXCJ4X21heFwiOjU5OC42MDkzNzUsXCJoYVwiOjc5MixcIm9cIjpcIm0gNTk4IDc3MiBsIDUxNSA3NzIgbCAzOTUgOTMxIGwgMjc3IDc3MiBsIDE5MyA3NzIgbCAzMjYgMTAxMyBsIDQ2MiAxMDEzIGwgNTk4IDc3MiBcIn0sXCLvv71cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjUwNy4yMDMxMjUsXCJoYVwiOjYwNCxcIm9cIjpcIm0gNTA2IDEzNiBsIDI4NCAzMDIgbCAyODQgNDQwIGwgNTA2IDYwOCBsIDUwNyA0ODUgbCAzNjAgMzcxIGwgNTA2IDI1NSBsIDUwNiAxMzYgbSAyMjIgMTM2IGwgMCAzMDIgbCAwIDQ0MCBsIDIyMiA2MDggbCAyMjEgNDg2IGwgNzMgMzczIGwgMjIyIDI1NiBsIDIyMiAxMzYgXCJ9LFwiRFwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6ODI4LFwiaGFcIjo5MzUsXCJvXCI6XCJtIDM4OSAxMDEzIHEgNzE0IDg2NyA1OTMgMTAxMyBxIDgyOCA1MjEgODI4IDcyOSBxIDcxMiAxNjEgODI4IDMwOSBxIDM4MiAwIDU4NyAwIGwgMCAwIGwgMCAxMDEzIGwgMzg5IDEwMTMgbSAzNzYgMTI0IHEgNjA3IDI0NyA1MjMgMTI0IHEgNjgxIDUxMCA2ODEgMzU1IHEgNjA3IDc3MSA2ODEgNjYyIHEgMzc2IDg5NiA1MjIgODk2IGwgMTM5IDg5NiBsIDEzOSAxMjQgbCAzNzYgMTI0IFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjE0MixcImhhXCI6MjM5LFwib1wiOlwibSAxNDIgNTg1IGwgMCA1ODUgbCAwIDczOCBsIDE0MiA3MzggbCAxNDIgNTg1IFwifSxcIu+/vVwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NDcsXCJoYVwiOjEyNSxcIm9cIjpcIm0gNDcgMyBxIDM3IC03IDQ3IC03IHEgMjggMCAzMCAtNyBxIDM5IC00IDMyIC00IHEgNDUgMyA0NSAtMSBsIDM3IDAgcSAyOCA5IDI4IDAgcSAzOSAxOSAyOCAxOSBsIDQ3IDE2IGwgNDcgMTkgbCA0NyAzIG0gMzcgMSBxIDQ0IDggNDQgMSBxIDM3IDE2IDQ0IDE2IHEgMzAgOCAzMCAxNiBxIDM3IDEgMzAgMSBtIDI2IDEgbCAyMyAyMiBsIDE0IDAgbCAzIDIyIGwgMyAzIGwgMCAyNSBsIDEzIDEgbCAyMiAyNSBsIDI2IDEgXCJ9LFwid1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6MTAwOS43MTg3NSxcImhhXCI6MTEwMCxcIm9cIjpcIm0gMTAwOSA3MzggbCA3ODMgMCBsIDY1OCAwIGwgNTAxIDU2NyBsIDM0NSAwIGwgMjIyIDAgbCAwIDczOCBsIDEzMCA3MzggbCAyODQgMTc0IGwgNDMyIDczNyBsIDU3NiA3MzggbCA3MjEgMTczIGwgODgxIDczNyBsIDEwMDkgNzM4IFwifSxcIiRcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjcwMCxcImhhXCI6NzkzLFwib1wiOlwibSA2NjQgNzE3IGwgNTQyIDcxNyBxIDQ5MCA4MjUgNTMxIDc4NSBxIDM4MSA4NzIgNDUwIDg2NSBsIDM4MSA1NTEgcSA2MjAgNDQ2IDU0MCA1MjIgcSA3MDAgMjQxIDcwMCAzNzAgcSA2MTggNDUgNzAwIDExNiBxIDM4MSAtMjUgNTM2IC0yNSBsIDM4MSAtMTUyIGwgMzA3IC0xNTIgbCAzMDcgLTI1IHEgODEgNjIgMTYyIC0yNSBxIDAgMjk3IDAgMTQ5IGwgMTI0IDI5NyBxIDE2OSAxNDYgMTI0IDIwNCBxIDMwNyA4MSAyMTUgODkgbCAzMDcgNDQxIHEgODAgNTM2IDE0OCA0NjkgcSAxMyA3MjUgMTMgNjAzIHEgOTYgOTEwIDEzIDgzOSBxIDMwNyA5ODIgMTgwIDk4MiBsIDMwNyAxMDc3IGwgMzgxIDEwNzcgbCAzODEgOTgyIHEgNTc0IDkxNyA0OTQgOTgyIHEgNjY0IDcxNyA2NjQgODQ1IG0gMzA3IDU2NSBsIDMwNyA4NzIgcSAxODcgODMxIDIzMyA4NzIgcSAxNDIgNzI0IDE0MiA3OTEgcSAxODAgNjE4IDE0MiA2NTYgcSAzMDcgNTY1IDIxOCA1ODAgbSAzODEgNzYgcSA1NjIgMjM3IDU2MiA5NiBxIDUxNyAzNjEgNTYyIDMxMyBxIDM4MSA0MjMgNDcyIDQwOSBsIDM4MSA3NiBcIn0sXCJcXFxcXCI6e1wieF9taW5cIjotMC4wMTU2MjUsXCJ4X21heFwiOjQyNS4wNjI1LFwiaGFcIjo1MjIsXCJvXCI6XCJtIDQyNSAtMTI5IGwgMzM3IC0xMjkgbCAwIDEwNDEgbCA4MyAxMDQxIGwgNDI1IC0xMjkgXCJ9LFwi77+9XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo2OTcuMjE4NzUsXCJoYVwiOjc0NyxcIm9cIjpcIm0gNjk3IC00IHEgNjI5IC0xNCA2NTggLTE0IHEgNDk4IDk3IDUxMyAtMTQgcSA0MjIgOSA0NzAgNDEgcSAzMTMgLTIzIDM3NCAtMjMgcSAyMDcgNCAyNTggLTIzIHEgMTE5IDgxIDE1NiAzMiBsIDExOSAtMjc4IGwgMCAtMjc4IGwgMCA3MzggbCAxMjQgNzM4IGwgMTI0IDM0MyBxIDE2NSAxNzMgMTI0IDI0NiBxIDMwOCA4MyAyMTYgODMgcSA0NTIgMTc4IDQwMiA4MyBxIDQ5MyAzNTkgNDkzIDI1NSBsIDQ5MyA3MzggbCA2MTcgNzM4IGwgNjE3IDIxNCBxIDYyMyAxMzYgNjE3IDE2MCBxIDY3MyA5MiA2MzcgOTIgcSA2OTcgOTYgNjg0IDkyIGwgNjk3IC00IFwifSxcIj9cIjp7XCJ4X21pblwiOjQyLFwieF9tYXhcIjoxODEsXCJoYVwiOjI5NyxcIm9cIjpcIm0gMTgxIDAgbCA0MiAwIGwgNDIgMTAxMyBsIDE4MSAxMDEzIGwgMTgxIDAgXCJ9LFwiP1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6MTE0NC41LFwiaGFcIjoxMjE0LFwib1wiOlwibSAxMTQ0IDEwMTIgbCA4MDcgNDE2IGwgODA3IDAgbCA2NjcgMCBsIDY2NyA0MTYgbCAzMjUgMTAxMiBsIDQ2NSAxMDEyIGwgNzM2IDUzMyBsIDEwMDQgMTAxMiBsIDExNDQgMTAxMiBtIDI3NyAxMDQwIGwgODMgNzk5IGwgMCA3OTkgbCAxNDAgMTA0MCBsIDI3NyAxMDQwIFwifSxcIu+/vVwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6MTM5LFwiaGFcIjoyMzYsXCJvXCI6XCJtIDEzOSA4NTEgcSAxMDIgNzM3IDEzOSA3ODQgcSAwIDY2OSA2NSA2OTAgbCAwIDczNCBxIDU5IDc4NyA0MiA3NDEgcSA3MiA4NzMgNzIgODIxIGwgMCA4NzMgbCAwIDEwMTMgbCAxMzkgMTAxMyBsIDEzOSA4NTEgXCJ9LFwiP1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6ODAxLFwiaGFcIjo5MTUsXCJvXCI6XCJtIDgwMSAwIGwgNjUxIDAgbCAxMzEgODIyIGwgMTMxIDAgbCAwIDAgbCAwIDEwMTMgbCAxNTEgMTAxMyBsIDY3MCAxOTEgbCA2NzAgMTAxMyBsIDgwMSAxMDEzIGwgODAxIDAgXCJ9LFwiLVwiOntcInhfbWluXCI6OC43MTg3NSxcInhfbWF4XCI6MzUwLjM5MDYyNSxcImhhXCI6NDc4LFwib1wiOlwibSAzNTAgMzE3IGwgOCAzMTcgbCA4IDQyOCBsIDM1MCA0MjggbCAzNTAgMzE3IFwifSxcIlFcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjk2OCxcImhhXCI6MTA3MixcIm9cIjpcIm0gOTU0IDUgbCA4ODcgLTc5IGwgNzQ0IDM1IHEgNjIyIC0xMSA2ODcgMiBxIDQ4MyAtMjYgNTU2IC0yNiBxIDEyNyAxMzAgMjYyIC0yNiBxIDAgNTA0IDAgMjc5IHEgMTI3IDg4MCAwIDcyOCBxIDQ4NCAxMDQxIDI2MiAxMDQxIHEgODQxIDg4NCA3MDggMTA0MSBxIDk2OCA1MDcgOTY4IDczNSBxIDkzMyAyOTMgOTY4IDM5OCBxIDgzMiAxMDQgODk5IDE4OCBsIDk1NCA1IG0gNzIzIDE5MSBxIDgwMiAzMzAgNzc3IDI0OCBxIDgyOCA0OTkgODI4IDQxMiBxIDc0NCA3OTAgODI4IDY3MyBxIDQ4MyA5MjIgNjUwIDkyMiBxIDIyOCA3OTEgMzIyIDkyMiBxIDE0MiA1MDUgMTQyIDY3MyBxIDIyNyAyMjEgMTQyIDMzNyBxIDQ4NyA5MSAzMjMgOTEgcSA2MzIgMTIzIDU2NiA5MSBsIDUyMCAyMTUgbCA1ODcgMzAxIGwgNzIzIDE5MSBcIn0sXCI/XCI6e1wieF9taW5cIjoxLFwieF9tYXhcIjo2NzYuMjgxMjUsXCJoYVwiOjc0MCxcIm9cIjpcIm0gNjc2IDQ2MCBsIDU1MSA0NjAgcSA0OTggNTk1IDU0MiA1NDYgcSAzNjUgNjUxIDQ0OCA2NTEgcSAxOTkgNTc4IDI2MyA2NTEgcSAxMzYgNDAxIDEzNiA1MDUgcSAyNjYgMTc4IDEzNiAyNDEgcSA1MDggMTA2IDM4NyAxNDIgcSA2NDAgLTUwIDY0MCA2MiBxIDYyNSAtMTU4IDY0MCAtMTA1IHEgNTgzIC0yNzggNjExIC0yMTEgbCA0NjUgLTI3OCBxIDQ5OCAtMTgyIDQ5MCAtMjExIHEgNTE1IC04MCA1MTUgLTEyNiBxIDM4MSAxMiA1MTUgLTE1IHEgMTM0IDkxIDE5NyA1MSBxIDEgMzg4IDEgMTc5IHEgMTAwIDY1MSAxIDU0MiBxIDM1NCA3NjEgMTk5IDc2MSBxIDU4NyA2ODAgNDk4IDc2MSBxIDY3NiA0NjAgNjc2IDU5OSBcIn0sXCJNXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo5NTQsXCJoYVwiOjEwNjcsXCJvXCI6XCJtIDk1NCAwIGwgODE5IDAgbCA4MTkgODY5IGwgNTM3IDAgbCA0MDUgMCBsIDEyOCA4NjYgbCAxMjggMCBsIDAgMCBsIDAgMTAxMyBsIDIwMCAxMDEzIGwgNDcyIDE2MCBsIDc1NyAxMDEzIGwgOTU0IDEwMTMgbCA5NTQgMCBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjoxMDA2LFwiaGFcIjoxMDk0LFwib1wiOlwibSAxMDA2IDY3OCBxIDkxNCAzMTkgMTAwNiA0MjkgcSA1NzEgMjAwIDgxNCAyMDAgbCA1NzEgMCBsIDQzMyAwIGwgNDMzIDIwMCBxIDkyIDMxOSAxOTQgMjAwIHEgMCA2NzggMCA0MjkgbCAwIDEwMTMgbCAxMzkgMTAxMyBsIDEzOSA2NzkgcSAxOTEgNDE3IDEzOSA0OTIgcSA0MzMgMzI2IDI1NSAzMjYgbCA0MzMgMTAxMyBsIDU3MSAxMDEzIGwgNTcxIDMyNiBsIDU4MCAzMjYgcSA4MTMgNDIzIDc0NyAzMjYgcSA4NjggNjc5IDg2OCA1MDIgbCA4NjggMTAxMyBsIDEwMDYgMTAxMyBsIDEwMDYgNjc4IFwifSxcIkNcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjg4NixcImhhXCI6OTQ0LFwib1wiOlwibSA4ODYgMzc5IHEgNzYwIDg3IDg4NiAyMDEgcSA0NTUgLTI2IDYzNCAtMjYgcSAxMTIgMTM2IDIzNiAtMjYgcSAwIDUwOSAwIDI4MyBxIDExOCA4ODIgMCA3MzcgcSA0NjkgMTA0MSAyNDUgMTA0MSBxIDc0OCA5NTUgNjMwIDEwNDEgcSA4NzkgNzA4IDg3OSA4NTkgbCA3NDUgNzA4IHEgNjQ5IDg2MiA3MjQgODA1IHEgNDczIDkyMCA1NzMgOTIwIHEgMjE5IDc5MSAzMTIgOTIwIHEgMTM2IDUwOSAxMzYgNjc1IHEgMjE3IDIyOSAxMzYgMzQ0IHEgNDcwIDk5IDMxMSA5OSBxIDY3MiAxNzkgNTkxIDk5IHEgNzUzIDM3OSA3NTMgMjU5IGwgODg2IDM3OSBcIn0sXCIhXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjoxMzgsXCJoYVwiOjIzNixcIm9cIjpcIm0gMTM4IDY4NCBxIDExNiA0MDkgMTM4IDYyOSBxIDEwNSAyNDQgMTA1IDI5OSBsIDMzIDI0NCBxIDE2IDQ2NSAzMyAzMTMgcSAwIDY4NCAwIDYxNiBsIDAgMTAxMyBsIDEzOCAxMDEzIGwgMTM4IDY4NCBtIDEzOCAwIGwgMCAwIGwgMCAxNTEgbCAxMzggMTUxIGwgMTM4IDAgXCJ9LFwie1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NDgwLjU2MjUsXCJoYVwiOjU3OCxcIm9cIjpcIm0gNDgwIC0yODYgcSAyMzcgLTIxMyAzMDMgLTI4NiBxIDE4NyAtNDUgMTg3IC0xNTkgcSAxOTQgNDggMTg3IC0xNSBxIDIwMSAxNDEgMjAxIDExMiBxIDE2NCAyNjQgMjAxIDIyNSBxIDAgMzE0IDExOCAzMTQgbCAwIDQxNyBxIDE2NCA0NzEgMTE5IDQxNyBxIDIwMSA2MDUgMjAxIDUxNCBxIDE5OSA2NjUgMjAxIDY0NCBxIDE5MyA3NzIgMTkzIDc2OSBxIDI0MSA5NDEgMTkzIDg4NyBxIDQ4MCAxMDE1IDMwOCAxMDE1IGwgNDgwIDkxNSBxIDMzNiA4NjYgMzc1IDkxNSBxIDMwNiA3NDIgMzA2IDgyOCBxIDMxMCA2NjIgMzA2IDcxNyBxIDMxNCA1NzcgMzE0IDYwNiBxIDI4OCA0NTIgMzE0IDUwMCBxIDE3NiAzNjUgMjU2IDM5MSBxIDI4OSAyNzUgMjU3IDMzNyBxIDMxNCAxNDMgMzE0IDIyNiBxIDMxMyA4NCAzMTQgMTA3IHEgMzEwIC0xMSAzMTAgLTUgcSAzMzkgLTEzMSAzMTAgLTk0IHEgNDgwIC0xODIgMzc3IC0xODIgbCA0ODAgLTI4NiBcIn0sXCJYXCI6e1wieF9taW5cIjotMC4wMTU2MjUsXCJ4X21heFwiOjg1NC4xNTYyNSxcImhhXCI6OTQwLFwib1wiOlwibSA4NTQgMCBsIDY4MyAwIGwgNDIzIDQwOSBsIDE2NiAwIGwgMCAwIGwgMzQ3IDUxOSBsIDE4IDEwMTMgbCAxODYgMTAxMyBsIDQyOCA2MzcgbCA2NzUgMTAxMyBsIDgzNiAxMDEzIGwgNTA0IDUyMCBsIDg1NCAwIFwifSxcIiNcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjk2My44OTA2MjUsXCJoYVwiOjEwNjEsXCJvXCI6XCJtIDk2MyA2OTAgbCA5MjcgNTkwIGwgNzE5IDU5MCBsIDY1NSA0MTAgbCA4NzYgNDEwIGwgODQwIDMxMCBsIDYxOCAzMTAgbCA1MDggLTMgbCAzOTMgLTIgbCA1MDYgMzA5IGwgMzI5IDMxMCBsIDIxNSAtMiBsIDEwMiAtMyBsIDIxMiAzMTAgbCAwIDMxMCBsIDM2IDQxMCBsIDI0OCA0MDkgbCAzMTIgNTkwIGwgODYgNTkwIGwgMTIwIDY5MCBsIDM0NyA2OTAgbCA0NTkgMTAwNiBsIDU3MyAxMDA2IGwgNDYyIDY5MCBsIDY0MCA2OTAgbCA3NTEgMTAwNiBsIDg2NSAxMDA2IGwgNzU0IDY5MCBsIDk2MyA2OTAgbSA2MDYgNTkwIGwgNDI1IDU5MCBsIDM2MiA0MTAgbCA1NDMgNDEwIGwgNjA2IDU5MCBcIn0sXCI/XCI6e1wieF9taW5cIjo0MixcInhfbWF4XCI6Mjg0LFwiaGFcIjozNjEsXCJvXCI6XCJtIDI4NCAzIHEgMjMzIC0xMCAyNTggLTUgcSAxODIgLTE1IDIwNyAtMTUgcSA4NSAyNiAxMTkgLTE1IHEgNDIgMjAwIDQyIDc5IGwgNDIgNzM4IGwgMTY3IDczOCBsIDE2OCAyMTUgcSAxNzIgMTQxIDE2OCAxNTcgcSAyMjYgMTAxIDE4MyAxMDEgcSAyNDggMTAzIDIzOSAxMDEgcSAyODQgMTEyIDI1NyAxMDQgbCAyODQgMyBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo5MDYuOTUzMTI1LFwiaGFcIjo5ODIsXCJvXCI6XCJtIDI4MyAxMDQwIGwgODggNzk5IGwgNSA3OTkgbCAxNDUgMTA0MCBsIDI4MyAxMDQwIG0gOTA2IDAgbCA3NTYgMCBsIDY1MCAzMDMgbCAyNTEgMzAzIGwgMTQzIDAgbCAwIDAgbCAzNzYgMTAxMiBsIDUyOSAxMDEyIGwgOTA2IDAgbSA2MDkgNDIxIGwgNDUyIDg2NiBsIDI5MyA0MjEgbCA2MDkgNDIxIFwifSxcIilcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjMxOCxcImhhXCI6NDE1LFwib1wiOlwibSAzMTggMzY1IHEgMjU3IDI1IDMxOCAxOTEgcSA4NyAtMjkwIDE5NyAtMTQxIGwgMCAtMjkwIHEgMTQwIDIxIDkzIC0xMjggcSAxOTMgMzYwIDE5MyAxODkgcSAxNDEgNzA0IDE5MyA1MzcgcSAwIDEwMjQgOTcgODUwIGwgODcgMTAyNCBxIDI1NyA3MDYgMTk3IDg3MSBxIDMxOCAzNjUgMzE4IDU0MiBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo2MzQuNzE4NzUsXCJoYVwiOjcxNCxcIm9cIjpcIm0gNjM0IDIzNCBxIDUyNyAzOCA2MzQgMTEwIHEgMzAwIC0yNSA0MzMgLTI1IHEgOTggMjkgMTgzIC0yNSBxIDAgMjA0IDAgOTMgcSAzNyAzMTQgMCAyNjUgcSAxMjggMzkwIDY3IDM1MyBxIDU2IDQ2MCA4MiA0MTkgcSAyNiA1NTUgMjYgNTA1IHEgMTE0IDcxMiAyNiA2NTQgcSAyOTUgNzYzIDE5MSA3NjMgcSA0OTkgNzAwIDQxNiA3NjMgcSA1ODkgNTE1IDU4OSA2MzEgbCA0NzggNTE1IHEgNDE5IDYxOCA0NjQgNTgwIHEgMzA3IDY1NyAzNzQgNjU3IHEgMjA3IDYzMCAyNTMgNjU3IHEgMTUxIDU0NyAxNTEgNTk4IHEgMjM4IDQ0NSAxNTEgNDY5IHEgMzg5IDQzNCAyODAgNDM0IGwgMzg5IDMzMSBsIDM0OSAzMzEgcSAyMDYgMzE1IDI1NSAzMzEgcSAxMjUgMjEwIDEyNSAyODcgcSAxODMgMTA3IDEyNSAxNDUgcSAzMDIgNzYgMjMzIDc2IHEgNDM2IDExNyAzNzkgNzYgcSA1MDkgMjM0IDQ5MyAxNTkgbCA2MzQgMjM0IFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjk1Mi43ODEyNSxcImhhXCI6MTAyOCxcIm9cIjpcIm0gOTUyIDAgbCAwIDAgbCA0MDAgMTAxMyBsIDU1MSAxMDEzIGwgOTUyIDAgbSA3NjIgMTI0IGwgNDc2IDg2NyBsIDE4NyAxMjQgbCA3NjIgMTI0IFwifSxcIn1cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjQ4MSxcImhhXCI6NTc4LFwib1wiOlwibSA0ODEgMzE0IHEgMzE4IDI2MiAzNjQgMzE0IHEgMjgyIDEzNiAyODIgMjIyIHEgMjg0IDY1IDI4MiA5NyBxIDI5MyAtNTggMjkzIC00OCBxIDI0MSAtMjE3IDI5MyAtMTY2IHEgMCAtMjg2IDE3NCAtMjg2IGwgMCAtMTgyIHEgMTQzIC0xMzAgMTA1IC0xODIgcSAxNzEgLTIgMTcxIC05MyBxIDE2OCA4MSAxNzEgMjIgcSAxNjUgMTQ0IDE2NSAxNDAgcSAxODggMjc1IDE2NSAyMjkgcSAzMDYgMzY1IDIyMCAzMzkgcSAxOTEgNDU1IDIyNCAzOTEgcSAxNjUgNTg4IDE2NSA1MDUgcSAxNjggNjgxIDE2NSA2MjQgcSAxNzEgNzQyIDE3MSA3MzcgcSAxNDEgODY1IDE3MSA4MjcgcSAwIDkxNSAxMDIgOTE1IGwgMCAxMDE1IHEgMjQzIDk0MiAxNzYgMTAxNSBxIDI5MyA3NzMgMjkzIDg4OCBxIDI4NyA2NzUgMjkzIDc0MSBxIDI4MiA1OTAgMjgyIDYwOCBxIDMxOCA0NjYgMjgyIDUwNSBxIDQ4MSA0MTcgMzY0IDQxNyBsIDQ4MSAzMTQgXCJ9LFwi77+9XCI6e1wieF9taW5cIjotMyxcInhfbWF4XCI6MTY3MixcImhhXCI6MTgyMSxcIm9cIjpcIm0gODQ2IDAgcSA2NjQgNzYgNzMyIDAgcSA2MDMgMjQ0IDYwMyAxNDUgcSA2NjIgNDEyIDYwMyAzNDQgcSA4NDYgNDg5IDcyOSA0ODkgcSAxMDI3IDQxMiA5NTkgNDg5IHEgMTA4OSAyNDQgMTA4OSAzNDMgcSAxMDI5IDc2IDEwODkgMTQ0IHEgODQ2IDAgOTYyIDAgbSA4NDUgMTAzIHEgOTQ1IDE0MyA5MTAgMTAzIHEgOTgxIDI0MyA5ODEgMTg0IHEgOTQ3IDM0MCA5ODEgMzAxIHEgODQ1IDM4NSA5MTAgMzg1IHEgNzQ1IDM0MiA3ODIgMzg1IHEgNzA5IDI0MyA3MDkgMzAwIHEgNzQyIDE0NyA3MDkgMTg2IHEgODQ1IDEwMyA3ODEgMTAzIG0gODg4IDk4NiBsIDI4NCAtMjUgbCAxOTkgLTI1IGwgODAzIDk4NiBsIDg4OCA5ODYgbSAyNDEgNDY4IHEgNTggNTQ1IDEyNiA0NjggcSAtMyA3MTUgLTMgNjE1IHEgNTYgODgxIC0zIDgxMyBxIDIzOCA5NTggMTI0IDk1OCBxIDQyMSA4ODEgMzUzIDk1OCBxIDQ4MyA3MTIgNDgzIDgxMyBxIDQyMyA1NDQgNDgzIDYxMiBxIDI0MSA0NjggMzU2IDQ2OCBtIDI0MSA4NTUgcSAxMzcgODExIDE3NSA4NTUgcSAxMDAgNzEwIDEwMCA3NjggcSAxMzYgNjEyIDEwMCA2NTMgcSAyNDAgNTcyIDE3MiA1NzIgcSAzNDQgNjE0IDMwNiA1NzIgcSAzODIgNzEzIDM4MiA2NTYgcSAzNDcgODEwIDM4MiA3NzEgcSAyNDEgODU1IDMwOCA4NTUgbSAxNDI4IDAgcSAxMjQ2IDc2IDEzMTQgMCBxIDExODUgMjQ0IDExODUgMTQ1IHEgMTI0NCA0MTIgMTE4NSAzNDQgcSAxNDI4IDQ4OSAxMzExIDQ4OSBxIDE2MTAgNDEyIDE1NDIgNDg5IHEgMTY3MiAyNDQgMTY3MiAzNDMgcSAxNjEyIDc2IDE2NzIgMTQ0IHEgMTQyOCAwIDE1NDUgMCBtIDE0MjcgMTAzIHEgMTUyOCAxNDMgMTQ5MiAxMDMgcSAxNTY0IDI0MyAxNTY0IDE4NCBxIDE1MzAgMzQwIDE1NjQgMzAxIHEgMTQyNyAzODUgMTQ5MiAzODUgcSAxMzI3IDM0MiAxMzY0IDM4NSBxIDEyOTEgMjQzIDEyOTEgMzAwIHEgMTMyNCAxNDcgMTI5MSAxODYgcSAxNDI3IDEwMyAxMzYzIDEwMyBcIn0sXCJhXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo2OTguNjA5Mzc1LFwiaGFcIjo3OTQsXCJvXCI6XCJtIDY5OCAwIHEgNjYxIC0xMiA2NzkgLTcgcSA2MTUgLTE3IDY0MyAtMTcgcSA1MzYgMTIgNTY0IC0xNyBxIDUwMCA5NiA1MDggNDEgcSAzODQgNiA0NTYgMzcgcSAyMzYgLTI1IDMxMiAtMjUgcSA2NSAzMSAxMzAgLTI1IHEgMCAxOTQgMCA4OCBxIDExOCAzOTAgMCAzMzQgcSAzMjggNDM1IDE4MCA0MjAgcSA0ODggNDgzIDQ3NiA0NTEgcSA0OTUgNTIzIDQ5NSA1MDQgcSA0NDIgNjE5IDQ5NSA1ODQgcSAzMjUgNjU0IDM4OSA2NTQgcSAyMDkgNjE3IDI1NyA2NTQgcSAxNTIgNTEzIDE2MSA1ODAgbCAzMyA1MTMgcSAxMjMgNzA1IDMzIDYzMyBxIDMzMiA3NzIgMjA3IDc3MiBxIDUyOCA3MTIgNDQ4IDc3MiBxIDYxNyA1MzEgNjE3IDY0NSBsIDYxNyAxNjMgcSA2MjQgMTA4IDYxNyAxMjYgcSA2NjQgOTAgNjMyIDkwIGwgNjk4IDk0IGwgNjk4IDAgbSA0OTEgMjYyIGwgNDkxIDM3MiBxIDI3MiAzMjkgMzUwIDM0NyBxIDEyOCAyMDEgMTI4IDI5NCBxIDE2NiAxMTMgMTI4IDE0NCBxIDI2NCA4MyAyMDUgODMgcSA0MTQgMTMwIDM0NiA4MyBxIDQ5MSAyNjIgNDkxIDE4MyBcIn0sXCLvv71cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjk0MS42NzE4NzUsXCJoYVwiOjEwMzksXCJvXCI6XCJtIDk0MSAzMzQgbCAwIDMzNCBsIDAgNDEwIGwgOTQxIDQxMCBsIDk0MSAzMzQgXCJ9LFwiPVwiOntcInhfbWluXCI6OC43MTg3NSxcInhfbWF4XCI6NzgwLjk1MzEyNSxcImhhXCI6NzkyLFwib1wiOlwibSA3ODAgNTEwIGwgOCA1MTAgbCA4IDYwNiBsIDc4MCA2MDYgbCA3ODAgNTEwIG0gNzgwIDIzNSBsIDggMjM1IGwgOCAzMzIgbCA3ODAgMzMyIGwgNzgwIDIzNSBcIn0sXCJOXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo4MDEsXCJoYVwiOjkxNCxcIm9cIjpcIm0gODAxIDAgbCA2NTEgMCBsIDEzMSA4MjMgbCAxMzEgMCBsIDAgMCBsIDAgMTAxMyBsIDE1MSAxMDEzIGwgNjcwIDE5MyBsIDY3MCAxMDEzIGwgODAxIDEwMTMgbCA4MDEgMCBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo3MTIsXCJoYVwiOjc5NyxcIm9cIjpcIm0gNzEyIDM2OSBxIDYyMCA5NCA3MTIgMjA3IHEgMzYyIC0yNiA1MjEgLTI2IHEgMjMwIDIgMjkyIC0yNiBxIDExOSA4MyAxNjcgMzAgbCAxMTkgLTI3OCBsIDAgLTI3OCBsIDAgMzYyIHEgOTEgNjQzIDAgNTMxIHEgMzU1IDc2NCAxOTAgNzY0IHEgNjE3IDY0NyA1MTcgNzY0IHEgNzEyIDM2OSA3MTIgNTM2IG0gNTgzIDM2NiBxIDUzMCA1NTkgNTgzIDQ4MCBxIDM1OSA2NTEgNDY5IDY1MSBxIDE5MCA1NjIgMjUyIDY1MSBxIDEzNSAzNzAgMTM1IDQ4MyBxIDE4OSAxNzYgMTM1IDI1NyBxIDM1OSA4NSAyNTAgODUgcSA1MjggMTc1IDQ2NiA4NSBxIDU4MyAzNjYgNTgzIDI1NCBcIn0sXCIyXCI6e1wieF9taW5cIjo1OSxcInhfbWF4XCI6NzMxLFwiaGFcIjo3OTIsXCJvXCI6XCJtIDczMSAwIGwgNTkgMCBxIDE5NyAzMTQgNTkgMTg4IHEgNDU3IDQ4NyAxOTkgMzE1IHEgNTk4IDY5MSA1OTggNTgwIHEgNTQzIDgxOSA1OTggNzcyIHEgNDExIDg2NyA0ODggODY3IHEgMjcyIDgxMSAzMjggODY3IHEgMjA5IDYzMCAyMDkgNzQ3IGwgODEgNjMwIHEgMTgyIDkwMSA4MSA4MDUgcSA0MDggOTg2IDI3MSA5ODYgcSA2MjkgOTA5IDUzNiA5ODYgcSA3MzEgNjk0IDczMSA4MjYgcSA2MTMgNDQ5IDczMSA1NDEgcSAzNzggMzE2IDQ5NSAzODMgcSAyMDEgMTIyIDIzNSAyMzQgbCA3MzEgMTIyIGwgNzMxIDAgXCJ9LFwi77+9XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo5NDEuNjcxODc1LFwiaGFcIjo5MzgsXCJvXCI6XCJtIDk0MSAxMDMzIGwgMCAxMDMzIGwgMCAxMTA5IGwgOTQxIDExMDkgbCA5NDEgMTAzMyBcIn0sXCJaXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo3NzksXCJoYVwiOjg0OSxcIm9cIjpcIm0gNzc5IDAgbCAwIDAgbCAwIDExMyBsIDYyMSA4OTYgbCA0MCA4OTYgbCA0MCAxMDEzIGwgNzc5IDEwMTMgbCA3NzggODg3IGwgMTcxIDEyNCBsIDc3OSAxMjQgbCA3NzkgMCBcIn0sXCJ1XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo2MTcsXCJoYVwiOjcyOSxcIm9cIjpcIm0gNjE3IDAgbCA0OTkgMCBsIDQ5OSAxMTAgcSAzOTEgMTAgNDYwIDQ1IHEgMjQ2IC0yNSAzMjIgLTI1IHEgNjEgNTggMTI3IC0yNSBxIDAgMjU4IDAgMTM2IGwgMCA3MzggbCAxMjUgNzM4IGwgMTI1IDI4NCBxIDE1NiAxNDggMTI1IDIwMiBxIDI3MyA4MiAxOTcgODIgcSA0MzMgMTY1IDM2OSA4MiBxIDQ5MyAzNDAgNDkzIDI0MyBsIDQ5MyA3MzggbCA2MTcgNzM4IGwgNjE3IDAgXCJ9LFwia1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NjEyLjQ4NDM3NSxcImhhXCI6Njk3LFwib1wiOlwibSA2MTIgNzM4IGwgMzM4IDQ2NSBsIDYwOCAwIGwgNDY5IDAgbCAyNTEgMzgyIGwgMTIxIDI1MSBsIDEyMSAwIGwgMCAwIGwgMCAxMDEzIGwgMTIxIDEwMTMgbCAxMjEgNDAyIGwgNDU2IDczOCBsIDYxMiA3MzggXCJ9LFwiP1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6ODAzLFwiaGFcIjo5MTcsXCJvXCI6XCJtIDgwMyAwIGwgNjY3IDAgbCA2NjcgNDc1IGwgMTQwIDQ3NSBsIDE0MCAwIGwgMCAwIGwgMCAxMDEzIGwgMTQwIDEwMTMgbCAxNDAgNTk5IGwgNjY3IDU5OSBsIDY2NyAxMDEzIGwgODAzIDEwMTMgbCA4MDMgMCBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo5MDYuOTUzMTI1LFwiaGFcIjo5ODUsXCJvXCI6XCJtIDkwNiAwIGwgNzU2IDAgbCA2NTAgMzAzIGwgMjUxIDMwMyBsIDE0MyAwIGwgMCAwIGwgMzc2IDEwMTMgbCA1MjkgMTAxMyBsIDkwNiAwIG0gNjA5IDQyMSBsIDQ1MiA4NjYgbCAyOTMgNDIxIGwgNjA5IDQyMSBcIn0sXCJzXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo2MDQsXCJoYVwiOjY5NyxcIm9cIjpcIm0gNjA0IDIxNyBxIDUwMSAzNiA2MDQgMTA0IHEgMjkyIC0yMyA0MTEgLTIzIHEgODYgNDMgMTY2IC0yMyBxIDAgMjM4IDAgMTE0IGwgMTIxIDIzNyBxIDE3NSAxMjIgMTIxIDE2NCBxIDMwMCA4NSAyMjMgODUgcSA0MTUgMTEyIDM2MyA4NSBxIDQ3OSAyMDcgNDc5IDE0NyBxIDM2MSAzMDkgNDc5IDI3NiBxIDE0MCAzNzIgMTQxIDM3MCBxIDIxIDU0NCAyMSA0MjYgcSAxMTEgNzA4IDIxIDY0NyBxIDI5OCA3NjEgMTkwIDc2MSBxIDQ5MiA3MDUgNDEzIDc2MSBxIDU4MyA1MzEgNTgzIDY0MyBsIDQ2MiA1MzEgcSA0MTIgNjI1IDQ2MiA1OTQgcSAyOTggNjU3IDM2MyA2NTcgcSAxOTkgNjM2IDI0MiA2NTcgcSAxNDMgNTU4IDE0MyA2MDggcSAyNjIgNDU0IDE0MyA0ODYgcSA0ODQgMzk0IDQ3OSAzOTcgcSA2MDQgMjE3IDYwNCAzNDEgXCJ9LFwiQlwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6Nzc4LFwiaGFcIjo4NzYsXCJvXCI6XCJtIDU4MCA1NDYgcSA3MjQgNDY5IDY3MCA1MzUgcSA3NzggMzExIDc3OCA0MDMgcSA2NzMgODMgNzc4IDE3MSBxIDQzMiAwIDU3NSAwIGwgMCAwIGwgMCAxMDEzIGwgNDExIDEwMTMgcSA2MjkgOTU3IDU0MSAxMDEzIHEgNzMyIDc2OCA3MzIgODkyIHEgNjkxIDYzMyA3MzIgNjkzIHEgNTgwIDU0NiA2NTAgNTcyIG0gMzkzIDg5OSBsIDEzOSA4OTkgbCAxMzkgNTg4IGwgMzc5IDU4OCBxIDUyMSA2MjQgNDYyIDU4OCBxIDU5MiA3NDQgNTkyIDY2NyBxIDUzMSA4NTkgNTkyIDgxOSBxIDM5MyA4OTkgNDcxIDg5OSBtIDQxOSAxMjQgcSA1NjYgMTY5IDUwNCAxMjQgcSA2MzUgMzAzIDYzNSAyMTkgcSA1NTkgNDM2IDYzNSAzODkgcSA0MDIgNDc3IDQ5NCA0NzcgbCAxMzkgNDc3IGwgMTM5IDEyNCBsIDQxOSAxMjQgXCJ9LFwi77+9XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo2MTQsXCJoYVwiOjcwOCxcIm9cIjpcIm0gMTQyIDAgbCAwIDAgbCAwIDE1MSBsIDE0MiAxNTEgbCAxNDIgMCBtIDM3OCAwIGwgMjM2IDAgbCAyMzYgMTUxIGwgMzc4IDE1MSBsIDM3OCAwIG0gNjE0IDAgbCA0NzIgMCBsIDQ3MiAxNTEgbCA2MTQgMTUxIGwgNjE0IDAgXCJ9LFwiP1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NjA3LFwiaGFcIjo3MDQsXCJvXCI6XCJtIDYwNyA3NzcgcSA1NDMgNTk5IDYwNyA2NzQgcSA0MjIgNDc0IDQ4MiA1MzcgcSAzNTcgMjcyIDM1NyAzOTEgbCAyMzYgMjcyIHEgMjk3IDQ4NyAyMzYgMzk1IHEgNDExIDYxOSAyOTggNDkwIHEgNDc0IDc2MiA0NzQgNjkxIHEgNDIyIDg4NSA0NzQgODM4IHEgMzAxIDkzMyAzNzEgOTMzIHEgMTc5IDg4MCAyMjggOTMzIHEgMTI0IDcwNiAxMjQgODE5IGwgMCA3MDYgcSA5NCA5NjMgMCA4NzIgcSAzMDIgMTA0NCAxNzcgMTA0NCBxIDUxMSA5NzMgNDIzIDEwNDQgcSA2MDcgNzc3IDYwNyA4OTUgbSAzNzAgMCBsIDIzMCAwIGwgMjMwIDE1MSBsIDM3MCAxNTEgbCAzNzAgMCBcIn0sXCJIXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo4MDMsXCJoYVwiOjkxNSxcIm9cIjpcIm0gODAzIDAgbCA2NjcgMCBsIDY2NyA0NzUgbCAxNDAgNDc1IGwgMTQwIDAgbCAwIDAgbCAwIDEwMTMgbCAxNDAgMTAxMyBsIDE0MCA1OTkgbCA2NjcgNTk5IGwgNjY3IDEwMTMgbCA4MDMgMTAxMyBsIDgwMyAwIFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjY3NSxcImhhXCI6NzYxLFwib1wiOlwibSA2NzUgNzM4IGwgNDA0IDAgbCAyNzIgMCBsIDAgNzM4IGwgMTMzIDczOCBsIDM0MCAxNDcgbCA1NDEgNzM4IGwgNjc1IDczOCBcIn0sXCJjXCI6e1wieF9taW5cIjoxLFwieF9tYXhcIjo3MDEuMzkwNjI1LFwiaGFcIjo3NzUsXCJvXCI6XCJtIDcwMSAyNjQgcSA1ODQgNTMgNjgxIDEzMyBxIDM1MyAtMjYgNDg3IC0yNiBxIDkxIDkxIDE4OCAtMjYgcSAxIDM3MCAxIDIwMSBxIDkyIDY0NSAxIDUzNyBxIDM1MyA3NjEgMTkwIDc2MSBxIDU3MiA2ODggNDc5IDc2MSBxIDY5MCA0OTMgNjY2IDYxNSBsIDU1NiA0OTMgcSA0ODcgNjA2IDU0NSA1NjIgcSAzNTYgNjUwIDQyOCA2NTAgcSAxODYgNTYzIDI0NiA2NTAgcSAxMzQgMzcyIDEzNCA0ODcgcSAxODggMTc5IDEzNCAyNTggcSAzNTkgODggMjUwIDg4IHEgNDkyIDEzNiA0MzcgODggcSA1NjYgMjY0IDU0OCAxODUgbCA3MDEgMjY0IFwifSxcIu+/vVwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NTY2LjY3MTg3NSxcImhhXCI6Njc4LFwib1wiOlwibSAyMSA4OTIgbCA1MiA4OTIgbCA5OCA3NjEgbCAxNDUgODkyIGwgMTc2IDg5MiBsIDE3OCA3NDEgbCAxNTcgNzQxIGwgMTU3IDg2NyBsIDEwOCA3NDEgbCA4OCA3NDEgbCA0MCA4NzEgbCA0MCA3NDEgbCAyMSA3NDEgbCAyMSA4OTIgbSAzMDggODU0IGwgMzA4IDczMSBxIDI1MiA2OTEgMzA4IDY5MSBxIDIyNyA2OTEgMjQwIDY5MSBxIDIwNyA2OTYgMjEzIDY5NSBsIDIwNyA3MTIgbCAyNTMgNzA2IHEgMjg4IDczMyAyODggNzA2IGwgMjg4IDc2MyBxIDI0NCA3NDEgMjc5IDc0MSBxIDE5MyA3OTcgMTkzIDc0MSBxIDI2MSA4NjAgMTkzIDg2MCBxIDI4NyA4NjAgMjczIDg2MCBxIDMwOCA4NTQgMzAyIDg1NSBtIDI4OCA4NDIgbCAyNjMgODQzIHEgMjEzIDc5NiAyMTMgODQzIHEgMjQ4IDc1NiAyMTMgNzU2IHEgMjg4IDc5NiAyODggNzU2IGwgMjg4IDg0MiBtIDU2NiA5ODggbCA1MDIgOTg4IGwgNTAyIC0xIGwgNDM5IC0xIGwgNDM5IDk4OCBsIDMxNyA5ODggbCAzMTcgLTEgbCAyNTIgLTEgbCAyNTIgNjAyIHEgODEgNjUzIDE1NSA2MDIgcSAwIDgwNSAwIDcxMSBxIDEwMSA5ODkgMCA5MTggcSAzMDkgMTA1MyAxOTQgMTA1MyBsIDU2NiAxMDUzIGwgNTY2IDk4OCBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo2NjAsXCJoYVwiOjc0NSxcIm9cIjpcIm0gNDcxIDU1MCBxIDYxMCA0NTAgNTYxIDUyMiBxIDY2MCAyODAgNjYwIDM3OCBxIDU3OCA2NCA2NjAgMTUxIHEgMzY3IC0yMiA0OTcgLTIyIHEgMjM5IDUgMjk5IC0yMiBxIDEyNiA4MiAxNzggMzIgbCAxMjYgLTI3OCBsIDAgLTI3OCBsIDAgNTkzIHEgNTQgOTAzIDAgODAxIHEgMzE4IDEwNDIgMTI3IDEwNDIgcSA1MTkgOTY0IDQzNiAxMDQyIHEgNjAzIDc3MSA2MDMgODg3IHEgNTY3IDY0NCA2MDMgNzAxIHEgNDcxIDU1MCA1MzIgNTg2IG0gMzM3IDc5IHEgNDc2IDEzOCA0MTggNzkgcSA1MzUgMjc5IDUzNSAxOTggcSA0MjcgNDM3IDUzNSAzODYgcSAyMjYgNDc3IDM0NCA0NzcgbCAyMjYgNTgzIHEgMzk4IDYyMCAzMjkgNTgzIHEgNDg2IDc2MiA0ODYgNjY4IHEgNDM1IDg4NCA0ODYgODMzIHEgMzEyIDkzNSAzODQgOTM1IHEgMTY5IDg2MSAyMTkgOTM1IHEgMTI2IDY5OCAxMjYgNzk3IGwgMTI2IDM2MiBxIDE3MCAxNjkgMTI2IDI0MiBxIDMzNyA3OSAyMjQgNzkgXCJ9LFwiP1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6OTU0LFwiaGFcIjoxMDY4LFwib1wiOlwibSA5NTQgMCBsIDgxOSAwIGwgODE5IDg2OCBsIDUzNyAwIGwgNDA1IDAgbCAxMjggODY1IGwgMTI4IDAgbCAwIDAgbCAwIDEwMTMgbCAxOTkgMTAxMyBsIDQ3MiAxNTggbCA3NTggMTAxMyBsIDk1NCAxMDEzIGwgOTU0IDAgXCJ9LFwiP1wiOntcInhfbWluXCI6MC4xMDkzNzUsXCJ4X21heFwiOjExMjAsXCJoYVwiOjEyMTcsXCJvXCI6XCJtIDExMjAgNTA1IHEgOTk0IDEzMiAxMTIwIDI4MiBxIDY0MiAtMjkgODYxIC0yOSBxIDI5MCAxMzAgNDIyIC0yOSBxIDE2NyA1MDUgMTY3IDI4MCBxIDI5NCA4ODMgMTY3IDczMCBxIDY1MCAxMDQ2IDQzMCAxMDQ2IHEgOTk5IDg4MiA4NjggMTA0NiBxIDExMjAgNTA1IDExMjAgNzMwIG0gOTc3IDUwNCBxIDg5NiA3ODQgOTc3IDY2OSBxIDY0NCA5MTUgODA0IDkxNSBxIDM5MSA3ODUgNDg0IDkxNSBxIDMwNyA1MDQgMzA3IDY2OSBxIDM5MSAyMjQgMzA3IDMzOSBxIDY0NCA5NSA0ODYgOTUgcSA4OTQgMjI0IDgwMyA5NSBxIDk3NyA1MDQgOTc3IDMzOSBtIDI3NyAxMDQwIGwgODMgNzk5IGwgMCA3OTkgbCAxNDAgMTA0MCBsIDI3NyAxMDQwIFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjExNTgsXCJoYVwiOjEyNzUsXCJvXCI6XCJtIDExNTggMCBsIDEwMjIgMCBsIDEwMjIgNDc1IGwgNDk2IDQ3NSBsIDQ5NiAwIGwgMzU2IDAgbCAzNTYgMTAxMiBsIDQ5NiAxMDEyIGwgNDk2IDU5OSBsIDEwMjIgNTk5IGwgMTAyMiAxMDEyIGwgMTE1OCAxMDEyIGwgMTE1OCAwIG0gMjc3IDEwNDAgbCA4MyA3OTkgbCAwIDc5OSBsIDE0MCAxMDQwIGwgMjc3IDEwNDAgXCJ9LFwi77+9XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo2NjMuODkwNjI1LFwiaGFcIjo3NzUsXCJvXCI6XCJtIDY2MyA1MjkgcSA1NjYgMjkzIDY2MyAzOTEgcSAzMzEgMTk2IDQ2OSAxOTYgcSA5NyAyOTQgMTk0IDE5NiBxIDAgNTI5IDAgMzkzIHEgOTYgNzYzIDAgNjY1IHEgMzMxIDg2MSAxOTMgODYxIHEgNTY2IDc2MyA0NjkgODYxIHEgNjYzIDUyOSA2NjMgNjY1IFwifSxcIu+/vVwiOntcInhfbWluXCI6MC4xODc1LFwieF9tYXhcIjo4MTkuNTQ2ODc1LFwiaGFcIjo4ODYsXCJvXCI6XCJtIDU2MyA1NjEgbCA2OTcgNTYxIGwgNjk2IDQ4NyBsIDUyMCA0ODcgbCA0ODIgNDE2IGwgNDgyIDM4MCBsIDY5NyAzODAgbCA2OTUgMzA4IGwgNDgyIDMwOCBsIDQ4MiAwIGwgMzQyIDAgbCAzNDIgMzA4IGwgMTI1IDMwOCBsIDEyNSAzODAgbCAzNDIgMzgwIGwgMzQyIDQxNyBsIDMwMyA0ODcgbCAxMjUgNDg3IGwgMTI1IDU2MSBsIDI1OCA1NjEgbCAwIDEwMTMgbCAxNDAgMTAxMyBsIDQxMSA1MzMgbCA2NzkgMTAxMyBsIDgxOSAxMDEzIGwgNTYzIDU2MSBcIn0sXCIoXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjozMTguMDYyNSxcImhhXCI6NDE1LFwib1wiOlwibSAzMTggLTI5MCBsIDIzMCAtMjkwIHEgNjEgMjMgMTIyIC0xNDIgcSAwIDM2NSAwIDE5MCBxIDYyIDcxMiAwIDU0MCBxIDIzMCAxMDI0IDExOSA4NjkgbCAzMTggMTAyNCBxIDE3NSA3MDUgMjE5IDg1MyBxIDEyNSAzNjAgMTI1IDU0MiBxIDE3NiAyMiAxMjUgMTg3IHEgMzE4IC0yOTAgMjIzIC0xMjcgXCJ9LFwiVVwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6Nzk2LFwiaGFcIjo5MDQsXCJvXCI6XCJtIDc5NiAzOTMgcSA2ODEgOTMgNzk2IDIxMiBxIDM4NiAtMjUgNTY2IC0yNSBxIDEwMSA5NSAyMDggLTI1IHEgMCAzOTMgMCAyMTEgbCAwIDEwMTMgbCAxMzggMTAxMyBsIDEzOCAzOTEgcSAyMDQgMTkxIDEzOCAyNzAgcSAzOTQgMTA3IDI3NiAxMDcgcSA1ODYgMTkxIDUxMiAxMDcgcSA2NTYgMzkxIDY1NiAyNzAgbCA2NTYgMTAxMyBsIDc5NiAxMDEzIGwgNzk2IDM5MyBcIn0sXCI/XCI6e1wieF9taW5cIjowLjUsXCJ4X21heFwiOjc0NC45NTMxMjUsXCJoYVwiOjgyMixcIm9cIjpcIm0gNzQ0IDczNyBsIDQ2MyA1NCBsIDQ2MyAtMjc4IGwgMzM4IC0yNzggbCAzMzggNTQgbCAxNTQgNDk1IHEgMTA0IDU5NyAxMjQgNTY5IHEgMTMgNjUxIDY3IDY1MSBsIDAgNjUxIGwgMCA3NTEgbCAzOSA3NTMgcSAxNjggNzExIDEyMSA3NTMgcSAyNDIgNTk0IDIwNyA2NzYgbCA0MDMgMjA4IGwgNjE3IDczNyBsIDc0NCA3MzcgXCJ9LFwiP1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NzY1LjU2MjUsXCJoYVwiOjgwOSxcIm9cIjpcIm0gNzY1IC00IHEgNjk4IC0xNCA3MjYgLTE0IHEgNTY0IDk3IDU4NiAtMTQgcSA0NjYgNyA1MjUgNDAgcSAzMzcgLTI2IDQwNyAtMjYgcSA4OCA5OCAxODYgLTI2IHEgMCAzNjkgMCAyMTIgcSA4OCA2MzcgMCA1MjUgcSAzMzcgNzYwIDE4NCA3NjAgcSA0NjUgNzI4IDQwNyA3NjAgcSA1NjMgNjM3IDUyNCA2OTYgbCA1NjMgNzM5IGwgNjg1IDczOSBsIDY4NSAyMjIgcSA2OTMgMTQxIDY4NSAxNjggcSA3NDggOTQgNzA4IDk0IHEgNzY1IDk2IDc2MCA5NCBsIDc2NSAtNCBtIDU4NCAzNzEgcSA1MzEgNTYyIDU4NCA0ODUgcSAzNjAgNjUzIDQ3MCA2NTMgcSAxOTIgNTY2IDI1NCA2NTMgcSAxMzUgMzc5IDEzNSA0ODkgcSAxODYgMTgxIDEzNSAyNjEgcSAzNTggODQgMjQ3IDg0IHEgNTI4IDE3NiA0NjUgODQgcSA1ODQgMzcxIDU4NCAyNjAgXCJ9LFwiRlwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NjgzLjMyODEyNSxcImhhXCI6NzE3LFwib1wiOlwibSA2ODMgODg4IGwgMTQwIDg4OCBsIDE0MCA1ODMgbCA2MTMgNTgzIGwgNjEzIDQ1OCBsIDE0MCA0NTggbCAxNDAgMCBsIDAgMCBsIDAgMTAxMyBsIDY4MyAxMDEzIGwgNjgzIDg4OCBcIn0sXCLvv71cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjcwNS41NjI1LFwiaGFcIjo4MDMsXCJvXCI6XCJtIDcwNSAzMzQgbCAwIDMzNCBsIDAgNDEwIGwgNzA1IDQxMCBsIDcwNSAzMzQgXCJ9LFwiOlwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6MTQyLFwiaGFcIjoyMzksXCJvXCI6XCJtIDE0MiA1ODUgbCAwIDU4NSBsIDAgNzM4IGwgMTQyIDczOCBsIDE0MiA1ODUgbSAxNDIgMCBsIDAgMCBsIDAgMTUxIGwgMTQyIDE1MSBsIDE0MiAwIFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjg1NC4xNzE4NzUsXCJoYVwiOjkzNSxcIm9cIjpcIm0gODU0IDAgbCA2ODMgMCBsIDQyMyA0MDkgbCAxNjYgMCBsIDAgMCBsIDM0NyA1MTkgbCAxOCAxMDEzIGwgMTg2IDEwMTMgbCA0MjcgNjM3IGwgNjc1IDEwMTMgbCA4MzYgMTAxMyBsIDUwNCA1MjEgbCA4NTQgMCBcIn0sXCIqXCI6e1wieF9taW5cIjoxMTYsXCJ4X21heFwiOjY3NCxcImhhXCI6NzkyLFwib1wiOlwibSA2NzQgNzY4IGwgNDc1IDcxMyBsIDYxMCA1NDQgbCA1MTcgNDc3IGwgMzk0IDY1MiBsIDI3MiA0NzggbCAxNzggNTQ0IGwgMzE0IDcxMyBsIDExNiA3NjYgbCAxNTMgODc2IGwgMzQxIDgxMiBsIDM0MiAxMDEzIGwgNDQ2IDEwMTMgbCA0NDYgODExIGwgNjM1IDg3NCBsIDY3NCA3NjggXCJ9LFwi77+9XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo3NzcsXCJoYVwiOjgzNSxcIm9cIjpcIm0gNDU4IDgwNCBsIDc3NyA4MDQgbCA3NzcgNjgzIGwgNDU4IDY4MyBsIDQ1OCAwIGwgMzE5IDAgbCAzMTkgNjgxIGwgMCA2ODMgbCAwIDgwNCBsIDMxOSA4MDQgbCAzMTkgMTAxNSBsIDQ1OCAxMDEzIGwgNDU4IDgwNCBcIn0sXCLvv71cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjM0NyxcImhhXCI6NDQ0LFwib1wiOlwibSAxNzMgODAyIHEgNDMgODU2IDkxIDgwMiBxIDAgOTc3IDAgOTA1IHEgNDUgMTEwMSAwIDEwNDkgcSAxNzMgMTE1MyA5MCAxMTUzIHEgMzAzIDEwOTggMjU1IDExNTMgcSAzNDcgOTc3IDM0NyAxMDQ5IHEgMzAzIDg1NiAzNDcgOTA1IHEgMTczIDgwMiAyNTYgODAyIG0gMTczIDg4NCBxIDIzOCA5MTAgMjE0IDg4NCBxIDI2MiA5NzMgMjYyIDkzNyBxIDIzOSAxMDM4IDI2MiAxMDEyIHEgMTczIDEwNjQgMjE3IDEwNjQgcSAxMDggMTAzNyAxMzIgMTA2NCBxIDg1IDk3MyA4NSAxMDEwIHEgMTA4IDkxMCA4NSA5MzcgcSAxNzMgODg0IDEzMiA4ODQgXCJ9LFwiVlwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6ODYyLjcxODc1LFwiaGFcIjo5NDAsXCJvXCI6XCJtIDg2MiAxMDEzIGwgNTA1IDAgbCAzNjEgMCBsIDAgMTAxMyBsIDE0MyAxMDEzIGwgNDM0IDE2NSBsIDcxOCAxMDEyIGwgODYyIDEwMTMgXCJ9LFwiP1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NzM0LjcxODc1LFwiaGFcIjo3NjMsXCJvXCI6XCJtIDcyMyA4ODkgbCA5IDg4OSBsIDkgMTAxMyBsIDcyMyAxMDEzIGwgNzIzIDg4OSBtIDY3MyA0NjMgbCA2MSA0NjMgbCA2MSA1ODkgbCA2NzMgNTg5IGwgNjczIDQ2MyBtIDczNCAwIGwgMCAwIGwgMCAxMjQgbCA3MzQgMTI0IGwgNzM0IDAgXCJ9LFwi77+9XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjowLFwiaGFcIjo4NTN9LFwiP1wiOntcInhfbWluXCI6MC4zMjgxMjUsXCJ4X21heFwiOjgxOS41MTU2MjUsXCJoYVwiOjg4OSxcIm9cIjpcIm0gNTg4IDEwNDYgbCA0NjAgMTA0NiBsIDQ2MCAxMTg5IGwgNTg4IDExODkgbCA1ODggMTA0NiBtIDM2MCAxMDQ2IGwgMjMyIDEwNDYgbCAyMzIgMTE4OSBsIDM2MCAxMTg5IGwgMzYwIDEwNDYgbSA4MTkgMTAxMiBsIDQ4MiA0MTYgbCA0ODIgMCBsIDM0MiAwIGwgMzQyIDQxNiBsIDAgMTAxMiBsIDE0MCAxMDEyIGwgNDExIDUzMyBsIDY3OSAxMDEyIGwgODE5IDEwMTIgXCJ9LFwiMFwiOntcInhfbWluXCI6NzMsXCJ4X21heFwiOjcxNSxcImhhXCI6NzkyLFwib1wiOlwibSAzOTQgLTI5IHEgMTUzIDEyOSAyNDIgLTI5IHEgNzMgNDc5IDczIDI3MiBxIDE1MiA4MjkgNzMgNjg3IHEgMzk0IDk4OSAyNDEgOTg5IHEgNjM0IDgyOSA1NDUgOTg5IHEgNzE1IDQ3OSA3MTUgNjg0IHEgNjM1IDEyOSA3MTUgMjcwIHEgMzk0IC0yOSA1NDYgLTI5IG0gMzk0IDg5IHEgNTQ2IDIxMSA0ODkgODkgcSA1OTggNDc5IDU5OCAzMjIgcSA1NDggNzQ4IDU5OCA2NDAgcSAzOTQgODcxIDQ5MSA4NzEgcSAyNDEgNzQ4IDI5OCA4NzEgcSAxOTAgNDc5IDE5MCA2MzcgcSAyMzkgMjExIDE5MCAzMTkgcSAzOTQgODkgMjk2IDg5IFwifSxcIu+/vVwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6MzQ3LFwiaGFcIjo0NTQsXCJvXCI6XCJtIDEzOSA4NTEgcSAxMDIgNzM3IDEzOSA3ODQgcSAwIDY2OSA2NSA2OTAgbCAwIDczNCBxIDU5IDc4NyA0MiA3NDEgcSA3MiA4NzMgNzIgODIxIGwgMCA4NzMgbCAwIDEwMTMgbCAxMzkgMTAxMyBsIDEzOSA4NTEgbSAzNDcgODUxIHEgMzEwIDczNyAzNDcgNzg0IHEgMjA4IDY2OSAyNzMgNjkwIGwgMjA4IDczNCBxIDI2NyA3ODcgMjUwIDc0MSBxIDI4MCA4NzMgMjgwIDgyMSBsIDIwOCA4NzMgbCAyMDggMTAxMyBsIDM0NyAxMDEzIGwgMzQ3IDg1MSBcIn0sXCJAXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjoxMjYwLFwiaGFcIjoxMzU3LFwib1wiOlwibSAxMDk4IC00NSBxIDg3NyAtMTYwIDEwMDEgLTExNyBxIDYzMyAtMjAzIDc1MiAtMjAzIHEgMTU1IC0yOSAzMjcgLTIwMyBxIDAgMzYwIDAgMTI3IHEgMTc2IDgwMiAwIDYxNiBxIDY4NyAxMDA4IDM3MiAxMDA4IHEgMTEyMyA4NTQgOTY5IDEwMDggcSAxMjYwIDUxNyAxMjYwIDcxOCBxIDExNTUgMjE2IDEyNjAgMzQxIHEgODY4IDgyIDEwNDQgODIgcSA3NzIgMTA2IDgwMSA4MiBxIDczNyAyMDIgNzM3IDEzNSBxIDY0NyAxMTMgNzAwIDE0NCBxIDUyNyA4MiA1OTQgODIgcSAzNjcgMTQ3IDQyMCA4MiBxIDMxNCAzMTIgMzE0IDIxMiBxIDQwMSA1NjUgMzE0IDQ1MiBxIDYzOSA2OTAgNDk4IDY5MCBxIDgxMCA1ODggNzYwIDY5MCBsIDg0OSA2NjggbCA5MzggNjY4IHEgODc3IDQ0MSA5MDAgNTMyIHEgODMzIDIyNiA4MzMgMjY4IHEgODUzIDE4MiA4MzMgMTk4IHEgOTAyIDE2NyA4NzMgMTY3IHEgMTA4OCAyNzIgMTAxMiAxNjcgcSAxMTU5IDUxMiAxMTU5IDM3MiBxIDEwNTEgNzkzIDExNTkgNjgxIHEgNjg3IDkyNSA5MjUgOTI1IHEgMjQ4IDc0NyA0MTUgOTI1IHEgOTcgMzYxIDk3IDU4NiBxIDIyNiAyNiA5NyAxNTkgcSA2MjcgLTEyMiAzNzAgLTEyMiBxIDg1NiAtODcgNzM3IC0xMjIgcSAxMDYxIDggOTc2IC01MyBsIDEwOTggLTQ1IG0gNzg2IDQ4OCBxIDczOCA1ODAgNzc3IDU0NSBxIDY0MyA2MTUgNzAwIDYxNSBxIDQ4MyA1MTcgNTQ4IDYxNSBxIDQyNSAzMjIgNDI1IDQzMCBxIDQ1NyAyMDMgNDI1IDI1MCBxIDU1MiAxNTYgNDkwIDE1NiBxIDcyMiAyNzMgNjY1IDE1NiBxIDc4NiA0ODggNzM4IDMwOSBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo0OTksXCJoYVwiOjYxMyxcIm9cIjpcIm0gMjc3IDEwNDAgbCA4MyA3OTkgbCAwIDc5OSBsIDE0MCAxMDQwIGwgMjc3IDEwNDAgbSA0OTkgMCBsIDM2MCAwIGwgMzYwIDEwMTIgbCA0OTkgMTAxMiBsIDQ5OSAwIFwifSxcImlcIjp7XCJ4X21pblwiOjE0LFwieF9tYXhcIjoxMzYsXCJoYVwiOjI3NSxcIm9cIjpcIm0gMTM2IDg3MyBsIDE0IDg3MyBsIDE0IDEwMTMgbCAxMzYgMTAxMyBsIDEzNiA4NzMgbSAxMzYgMCBsIDE0IDAgbCAxNCA3MzcgbCAxMzYgNzM3IGwgMTM2IDAgXCJ9LFwiP1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6Nzc4LFwiaGFcIjo4NzcsXCJvXCI6XCJtIDU4MCA1NDUgcSA3MjQgNDY4IDY3MSA1MzQgcSA3NzggMzEwIDc3OCA0MDIgcSA2NzMgODMgNzc4IDE3MCBxIDQzMiAwIDU3NSAwIGwgMCAwIGwgMCAxMDEzIGwgNDExIDEwMTMgcSA2MjkgOTU3IDU0MSAxMDEzIHEgNzMyIDc2OCA3MzIgODkxIHEgNjkxIDYzMiA3MzIgNjkyIHEgNTgwIDU0NSA2NTAgNTcxIG0gMzkzIDg5OSBsIDEzOSA4OTkgbCAxMzkgNTg3IGwgMzc5IDU4NyBxIDUyMSA2MjMgNDYyIDU4NyBxIDU5MiA3NDQgNTkyIDY2NiBxIDUzMSA4NTkgNTkyIDgxOSBxIDM5MyA4OTkgNDcxIDg5OSBtIDQxOSAxMjQgcSA1NjYgMTY5IDUwNCAxMjQgcSA2MzUgMzAyIDYzNSAyMTkgcSA1NTkgNDM1IDYzNSAzODggcSA0MDIgNDc2IDQ5NCA0NzYgbCAxMzkgNDc2IGwgMTM5IDEyNCBsIDQxOSAxMjQgXCJ9LFwiP1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NjE3LFwiaGFcIjo3MjUsXCJvXCI6XCJtIDYxNyAzNTIgcSA1NDAgOTQgNjE3IDE5OSBxIDMwOCAtMjQgNDU1IC0yNCBxIDc2IDk0IDE2MSAtMjQgcSAwIDM1MiAwIDE5OSBsIDAgNzM5IGwgMTI2IDczOSBsIDEyNiAzNTUgcSAxNjkgMTg1IDEyNiAyNTcgcSAzMTIgOTggMjIwIDk4IHEgNDUxIDE4NSA0MDIgOTggcSA0OTIgMzU1IDQ5MiAyNTcgbCA0OTIgNzM5IGwgNjE3IDczOSBsIDYxNyAzNTIgXCJ9LFwiXVwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6Mjc1LFwiaGFcIjozNzIsXCJvXCI6XCJtIDI3NSAtMjgxIGwgMCAtMjgxIGwgMCAtMTg3IGwgMTUxIC0xODcgbCAxNTEgOTIwIGwgMCA5MjAgbCAwIDEwMTMgbCAyNzUgMTAxMyBsIDI3NSAtMjgxIFwifSxcIm1cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjEwMTksXCJoYVwiOjExMjgsXCJvXCI6XCJtIDEwMTkgMCBsIDg5NyAwIGwgODk3IDQ1NCBxIDg2MCA1OTEgODk3IDUzNiBxIDczOSA2NjAgODE2IDY2MCBxIDYxMyA1ODYgNjU5IDY2MCBxIDU3MyA0MzYgNTczIDUyMiBsIDU3MyAwIGwgNDQ3IDAgbCA0NDcgNDU1IHEgNDEyIDU5MSA0NDcgNTM1IHEgMjk0IDY1NyAzNzIgNjU3IHEgMTY1IDU4NiAyMTMgNjU3IHEgMTIyIDQzNyAxMjIgNTIxIGwgMTIyIDAgbCAwIDAgbCAwIDczOCBsIDExNyA3MzggbCAxMTcgNjQwIHEgMjAyIDczMCAxNTAgNjk3IHEgMzE2IDc2MyAyNTQgNzYzIHEgNDM3IDczMCAzODEgNzYzIHEgNTI1IDY0MiA0OTQgNjk3IHEgNjIxIDczMSA1NTkgNzAwIHEgNzUzIDc2MyA2ODIgNzYzIHEgOTQzIDY5NCA4NjcgNzYzIHEgMTAxOSA1MTIgMTAxOSA2MjUgbCAxMDE5IDAgXCJ9LFwiP1wiOntcInhfbWluXCI6OC4zMjgxMjUsXCJ4X21heFwiOjc4MC41NjI1LFwiaGFcIjo4MTUsXCJvXCI6XCJtIDc4MCAtMjc4IHEgNzE1IC0yOTQgNzQ3IC0yOTQgcSA2MTYgLTI1NyA2NjMgLTI5NCBxIDU0OCAtMTc1IDU3NiAtMjI3IGwgMzc5IDEzMyBsIDE0MyAtMjc3IGwgOSAtMjc3IGwgMzEzIDI1NCBsIDE2MyA1MjIgcSAxMjcgNTg2IDEzMSA1ODAgcSAzNiA2NDAgOTEgNjQwIHEgOCA2MzcgMjcgNjQwIGwgOCA3NTIgbCA1MiA3NTcgcSAxNjIgNzE5IDExMyA3NTcgcSAyMzYgNjI3IDIwMCA2OTAgbCAzODMgMzcyIGwgNTk0IDczNyBsIDcyNiA3MzcgbCA0NDggMjUwIGwgNjI1IC02OSBxIDY3MCAtMTUzIDY0NyAtMTEwIHEgNzQzIC0xODggNjk1IC0xODggcSA3ODAgLTE4NCA3NTkgLTE4OCBsIDc4MCAtMjc4IFwifSxcIjhcIjp7XCJ4X21pblwiOjU1LFwieF9tYXhcIjo3MzYsXCJoYVwiOjc5MixcIm9cIjpcIm0gNTcxIDUyNyBxIDY5NCA0MjQgNjUyIDQ5MSBxIDczNiAyODAgNzM2IDM1OCBxIDY0OCA3MSA3MzYgMTU4IHEgMzk1IC0yNiA1NTEgLTI2IHEgMTQyIDY5IDIzOCAtMjYgcSA1NSAyNzkgNTUgMTU3IHEgOTYgNDI1IDU1IDM1OSBxIDIyMCA1MjcgMTM4IDQ5MSBxIDEyMCA2MTUgMTUzIDU2MiBxIDg4IDcyNiA4OCA2NjggcSAxNzEgOTA0IDg4IDgyNyBxIDM5NSA5ODYgMjYxIDk4NiBxIDYxOCA5MDUgNTI5IDk4NiBxIDcwMiA3MjcgNzAyIDgzMCBxIDY3MCA2MTYgNzAyIDY2NyBxIDU3MSA1MjcgNjM4IDU2NSBtIDM5NCA1NjUgcSA1MTkgNjEwIDQ3NSA1NjUgcSA1NjMgNzE3IDU2MyA2NTUgcSA1MjEgODIzIDU2MyA3ODEgcSAzOTIgODcyIDQ3NCA4NzIgcSAyNjUgODI0IDMxMiA4NzIgcSAyMjQgNzIwIDIyNCA3ODMgcSAyNjUgNjEzIDIyNCA2NTYgcSAzOTQgNTY1IDMxMiA1NjUgbSAzOTUgOTEgcSA1NDUgMTUwIDQ4OCA5MSBxIDU5NyAyODAgNTk3IDIwNCBxIDU0NiA0MDggNTk3IDM1NSBxIDM5NSA0NjUgNDkyIDQ2NSBxIDI0NCA0MDggMjk5IDQ2NSBxIDE5NCAyODAgMTk0IDM1NiBxIDI0NCAxNTAgMTk0IDIwMyBxIDM5NSA5MSAyOTkgOTEgXCJ9LFwiP1wiOntcInhfbWluXCI6NDIsXCJ4X21heFwiOjMyNi43MTg3NSxcImhhXCI6MzYxLFwib1wiOlwibSAyODQgMyBxIDIzMyAtMTAgMjU4IC01IHEgMTgyIC0xNSAyMDcgLTE1IHEgODUgMjYgMTE5IC0xNSBxIDQyIDIwMCA0MiA3OSBsIDQyIDczNyBsIDE2NyA3MzcgbCAxNjggMjE1IHEgMTcyIDE0MSAxNjggMTU3IHEgMjI2IDEwMSAxODMgMTAxIHEgMjQ4IDEwMiAyMzkgMTAxIHEgMjg0IDExMiAyNTcgMTA0IGwgMjg0IDMgbSAzMjYgMTA0MCBsIDEzNyA4MTkgbCA1NCA4MTkgbCAxODkgMTA0MCBsIDMyNiAxMDQwIFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjc3OS4xNzE4NzUsXCJoYVwiOjg1MCxcIm9cIjpcIm0gNzc5IDAgbCAwIDAgbCAwIDExMyBsIDYyMCA4OTYgbCA0MCA4OTYgbCA0MCAxMDEzIGwgNzc5IDEwMTMgbCA3NzkgODg3IGwgMTcwIDEyNCBsIDc3OSAxMjQgbCA3NzkgMCBcIn0sXCJSXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo3ODEuOTUzMTI1LFwiaGFcIjo5MDcsXCJvXCI6XCJtIDc4MSAwIGwgNjIzIDAgcSA1ODcgMjQyIDU5MCA1MiBxIDQwNyA0MzMgNTg1IDQzMyBsIDEzOCA0MzMgbCAxMzggMCBsIDAgMCBsIDAgMTAxMyBsIDM5NiAxMDEzIHEgNjM2IDk0NiA1MzkgMTAxMyBxIDc0OSA3MzEgNzQ5IDg2OCBxIDcxMSA1OTcgNzQ5IDY1OSBxIDYwOCA1MDIgNjc0IDUzNCBxIDcxOCAzNzAgNjk2IDQ3NCBxIDcyOSAyMDcgNzIyIDM1MiBxIDc4MSAyNiA3MzYgNjIgbCA3ODEgMCBtIDM3MyA1NTEgcSA1MzMgNTk0IDQ2NSA1NTEgcSA2MTQgNzMxIDYxNCA2NDUgcSA1MzIgODU5IDYxNCA4MTUgcSAzNzMgODk2IDQ2NSA4OTYgbCAxMzggODk2IGwgMTM4IDU1MSBsIDM3MyA1NTEgXCJ9LFwib1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NzEzLFwiaGFcIjo4MjEsXCJvXCI6XCJtIDM1NyAtMjUgcSA5NCA5MSAxOTQgLTI1IHEgMCAzNjggMCAyMDIgcSA5MyA2NDIgMCA1MzMgcSAzNTcgNzYxIDE5MyA3NjEgcSA2MTggNjQ0IDUxOCA3NjEgcSA3MTMgMzY4IDcxMyA1MzMgcSA2MTkgOTEgNzEzIDIwMSBxIDM1NyAtMjUgNTIxIC0yNSBtIDM1NyA4NSBxIDUyOCAxNzUgNDY1IDg1IHEgNTg0IDM2OSA1ODQgMjU1IHEgNTI5IDU2MiA1ODQgNDg0IHEgMzU3IDY1MSA0NjcgNjUxIHEgMTg5IDU2MCAyNTAgNjUxIHEgMTM1IDM2OSAxMzUgNDgxIHEgMTg3IDE3NyAxMzUgMjU3IHEgMzU3IDg1IDI1MCA4NSBcIn0sXCI1XCI6e1wieF9taW5cIjo1NC4xNzE4NzUsXCJ4X21heFwiOjczOCxcImhhXCI6NzkyLFwib1wiOlwibSA3MzggMzE0IHEgNjI2IDYwIDczOCAxNTMgcSAzODIgLTIzIDUyNiAtMjMgcSAxNTUgNDcgMjQ4IC0yMyBxIDU0IDI1NiA1NCAxMjUgbCAxODMgMjU2IHEgMjU5IDEzMiAyMDQgMTc0IHEgMzgyIDkxIDMxNCA5MSBxIDUzMyAxNDkgNDcxIDkxIHEgNjAyIDMxNCA2MDIgMjEzIHEgNTM4IDQ2OSA2MDIgNDExIHEgMzg2IDUyOCA0NzUgNTI4IHEgMjg0IDUwNiAzMzIgNTI4IHEgMTk3IDQzOSAyMzcgNDg0IGwgODEgNDM5IGwgMTU5IDk1OCBsIDY4NCA5NTggbCA2ODQgODQwIGwgMjU0IDg0MCBsIDIxNCA1NzkgcSAzMDYgNjI3IDI1OCA2MTIgcSA0MDcgNjQzIDM1NCA2NDMgcSA2MzYgNTUyIDU0MCA2NDMgcSA3MzggMzE0IDczOCA0NTcgXCJ9LFwiN1wiOntcInhfbWluXCI6NTguNzE4NzUsXCJ4X21heFwiOjczMC45NTMxMjUsXCJoYVwiOjc5MixcIm9cIjpcIm0gNzMwIDgzOSBxIDQ2OSA0NDggNTYwIDY0MSBxIDMzNSAwIDM3OCAyNTUgbCAxOTIgMCBxIDMyOCA0NDEgMjM1IDI1MiBxIDU5MyA4MzAgNDIxIDYzMCBsIDU4IDgzMCBsIDU4IDk1OCBsIDczMCA5NTggbCA3MzAgODM5IFwifSxcIktcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjgxOS40Njg3NSxcImhhXCI6OTA2LFwib1wiOlwibSA4MTkgMCBsIDY0OSAwIGwgMjk0IDUwOSBsIDEzOSAzNTUgbCAxMzkgMCBsIDAgMCBsIDAgMTAxMyBsIDEzOSAxMDEzIGwgMTM5IDUyNiBsIDYyNiAxMDEzIGwgODA5IDEwMTMgbCAzOTUgNjAwIGwgODE5IDAgXCJ9LFwiLFwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6MTQyLFwiaGFcIjoyMzksXCJvXCI6XCJtIDE0MiAtMTIgcSAxMDUgLTEzMiAxNDIgLTgyIHEgMCAtMjA1IDY4IC0xODIgbCAwIC0xMzggcSA1NyAtODIgNDAgLTEyNCBxIDcwIDAgNzAgLTUxIGwgMCAwIGwgMCAxNTEgbCAxNDIgMTUxIGwgMTQyIC0xMiBcIn0sXCJkXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo2ODMsXCJoYVwiOjc5NixcIm9cIjpcIm0gNjgzIDAgbCA1NjQgMCBsIDU2NCA5MyBxIDQ1NiA2IDUxNiAzOCBxIDMyNyAtMjUgMzk1IC0yNSBxIDg3IDEwMCAxODEgLTI1IHEgMCAzNjUgMCAyMTUgcSA5MCA2MzkgMCA1MjUgcSAzNDMgNzYzIDE4NyA3NjMgcSA1NjQgNjQ3IDQ4NiA3NjMgbCA1NjQgMTAxMyBsIDY4MyAxMDEzIGwgNjgzIDAgbSA1ODIgMzczIHEgNTI5IDU2MiA1ODIgNDg0IHEgMzYxIDY1MyA0NjggNjUzIHEgMTkwIDU2MSAyNTMgNjUzIHEgMTM1IDM2NSAxMzUgNDc5IHEgMTg5IDE3NSAxMzUgMjU0IHEgMzU4IDg1IDI1MSA4NSBxIDUyOSAxNzggNDY4IDg1IHEgNTgyIDM3MyA1ODIgMjU4IFwifSxcIu+/vVwiOntcInhfbWluXCI6LTEwOSxcInhfbWF4XCI6MjQ3LFwiaGFcIjoyMzIsXCJvXCI6XCJtIDI0NyAxMDQ2IGwgMTE5IDEwNDYgbCAxMTkgMTE4OSBsIDI0NyAxMTg5IGwgMjQ3IDEwNDYgbSAxOSAxMDQ2IGwgLTEwOSAxMDQ2IGwgLTEwOSAxMTg5IGwgMTkgMTE4OSBsIDE5IDEwNDYgXCJ9LFwiRVwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NzM2LjEwOTM3NSxcImhhXCI6Nzg5LFwib1wiOlwibSA3MzYgMCBsIDAgMCBsIDAgMTAxMyBsIDcyNSAxMDEzIGwgNzI1IDg4OSBsIDEzOSA4ODkgbCAxMzkgNTg1IGwgNjc3IDU4NSBsIDY3NyA0NjcgbCAxMzkgNDY3IGwgMTM5IDEyNSBsIDczNiAxMjUgbCA3MzYgMCBcIn0sXCJZXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo4MjAsXCJoYVwiOjg4NixcIm9cIjpcIm0gODIwIDEwMTMgbCA0ODIgNDE2IGwgNDgyIDAgbCAzNDIgMCBsIDM0MiA0MTYgbCAwIDEwMTMgbCAxNDAgMTAxMyBsIDQxMSA1MzQgbCA2NzkgMTAxMiBsIDgyMCAxMDEzIFwifSxcIlxcXCJcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjI5OSxcImhhXCI6Mzk2LFwib1wiOlwibSAyOTkgNjA2IGwgMjAzIDYwNiBsIDIwMyA5ODggbCAyOTkgOTg4IGwgMjk5IDYwNiBtIDk2IDYwNiBsIDAgNjA2IGwgMCA5ODggbCA5NiA5ODggbCA5NiA2MDYgXCJ9LFwi77+9XCI6e1wieF9taW5cIjoxNy45ODQzNzUsXCJ4X21heFwiOjc3My42MDkzNzUsXCJoYVwiOjc5MixcIm9cIjpcIm0gNzczIDQwIGwgMTggMzc2IGwgMTcgNDY1IGwgNzczIDc5OSBsIDc3MyA2OTIgbCAxNTkgNDIwIGwgNzczIDE0OSBsIDc3MyA0MCBcIn0sXCLvv71cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjM2NCxcImhhXCI6NDY3LFwib1wiOlwibSAxNDEgLTEyIHEgMTA0IC0xMzIgMTQxIC04MiBxIDAgLTIwNSA2NyAtMTgyIGwgMCAtMTM4IHEgNTYgLTgyIDQwIC0xMjQgcSA2OSAwIDY5IC01MSBsIDAgMCBsIDAgMTUxIGwgMTQxIDE1MSBsIDE0MSAtMTIgbSAzNjQgLTEyIHEgMzI3IC0xMzIgMzY0IC04MiBxIDIyMiAtMjA1IDI5MCAtMTgyIGwgMjIyIC0xMzggcSAyNzkgLTgyIDI2MiAtMTI0IHEgMjkyIDAgMjkyIC01MSBsIDIyMiAwIGwgMjIyIDE1MSBsIDM2NCAxNTEgbCAzNjQgLTEyIFwifSxcIj9cIjp7XCJ4X21pblwiOjEsXCJ4X21heFwiOjcxMCxcImhhXCI6ODEwLFwib1wiOlwibSA3MTAgMzYwIHEgNjE2IDg3IDcxMCAxOTYgcSAzNTYgLTI4IDUxOCAtMjggcSA5OSA4MiAxOTcgLTI4IHEgMSAzNTYgMSAxOTIgcSAxMDAgNjA2IDEgNTA5IHEgMzU1IDcwMyAxOTkgNzAzIHEgMTgwIDgyOSAyODggNzU0IHEgNzAgOTAzIDEyNCA4NjYgbCA3MCAxMDEyIGwgNjQzIDEwMTIgbCA2NDMgOTAxIGwgMjU4IDkwMSBxIDQ2MiA3NjMgNDIyIDc5NCBxIDYzNiA1OTIgNTc3IDY3NyBxIDcxMCAzNjAgNzEwIDQ4NSBtIDU4NCAzNjUgcSA1NTIgNTAxIDU4NCA0NDcgcSA0NTEgNjAyIDUyMSA1NTUgcSAzNzIgNjExIDQxMSA2MTEgcSAxOTcgNTQxIDI1OCA2MTEgcSAxMzYgMzU1IDEzNiA0NzIgcSAxOTAgMTcxIDEzNiAyNDUgcSAzNTggODUgMjUyIDg1IHEgNTI4IDE3MyA0NjUgODUgcSA1ODQgMzY1IDU4NCAyNTIgXCJ9LFwiP1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NjM0LjcxODc1LFwiaGFcIjo3MTQsXCJvXCI6XCJtIDYzNCAyMzQgcSA1MjcgMzggNjM0IDExMCBxIDMwMCAtMjUgNDMzIC0yNSBxIDk4IDI5IDE4MyAtMjUgcSAwIDIwNCAwIDkzIHEgMzcgMzEzIDAgMjY1IHEgMTI4IDM5MCA2NyAzNTIgcSA1NiA0NTkgODIgNDE5IHEgMjYgNTU1IDI2IDUwNSBxIDExNCA3MTIgMjYgNjU0IHEgMjk1IDc2MyAxOTEgNzYzIHEgNDk5IDcwMCA0MTYgNzYzIHEgNTg5IDUxNSA1ODkgNjMxIGwgNDc4IDUxNSBxIDQxOSA2MTggNDY0IDU4MCBxIDMwNyA2NTcgMzc0IDY1NyBxIDIwNyA2MzAgMjUzIDY1NyBxIDE1MSA1NDcgMTUxIDU5OCBxIDIzOCA0NDUgMTUxIDQ2OSBxIDM4OSA0MzQgMjgwIDQzNCBsIDM4OSAzMzEgbCAzNDkgMzMxIHEgMjA2IDMxNSAyNTUgMzMxIHEgMTI1IDIxMCAxMjUgMjg3IHEgMTgzIDEwNyAxMjUgMTQ1IHEgMzAyIDc2IDIzMyA3NiBxIDQzNiAxMTcgMzc5IDc2IHEgNTA5IDIzNCA0OTMgMTU5IGwgNjM0IDIzNCBtIDUyMCAxMDQwIGwgMzMxIDgxOSBsIDI0OCA4MTkgbCAzODMgMTA0MCBsIDUyMCAxMDQwIFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjkyMixcImhhXCI6MTAzMSxcIm9cIjpcIm0gOTIyIDMzOSBxIDg1NiA5NyA5MjIgMjAzIHEgNjUwIC0yNiA3ODAgLTI2IHEgNTM4IDkgNTg3IC0yNiBxIDQ2MSAxMDMgNDg5IDQ0IHEgMzg3IDEyIDQzNiA0NiBxIDI3NyAtMjIgMzM5IC0yMiBxIDY5IDk3IDE0NyAtMjIgcSAwIDMzOSAwIDIwMyBxIDQ1IDU1MSAwIDQ0NCBxIDE2MSA3MzggODQgNjQzIGwgMzAyIDczOCBxIDE3NSA1NTMgMjE5IDY0NyBxIDEyNCAzMzYgMTI0IDQ0NiBxIDE1NSAxNzkgMTI0IDI0OSBxIDI3NSA4OCAxOTcgODggcSAzNzUgMTYzIDM0MSA4OCBxIDQwMCAyOTQgNDAwIDIxOSBsIDQwMCA1NzIgbCA1MjQgNTcyIGwgNTI0IDI5NCBxIDU2MSAxMzUgNTI0IDE5MiBxIDY0MyA4OCA1OTEgODggcSA3NjIgMTgyIDcxOSA4OCBxIDc5NyAzNDIgNzk3IDI1NyBxIDc0NSA1NTYgNzk3IDQ1MCBxIDYxOSA3MzggNzA1IDYzOCBsIDc2MCA3MzggcSA4NzQgNTUxIDgzNSA2NDAgcSA5MjIgMzM5IDkyMiA0NDQgXCJ9LFwi77+9XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo5NixcImhhXCI6MjUxLFwib1wiOlwibSA5NiA2MDYgbCAwIDYwNiBsIDAgOTg4IGwgOTYgOTg4IGwgOTYgNjA2IFwifSxcIu+/vVwiOntcInhfbWluXCI6MTEsXCJ4X21heFwiOjc4MSxcImhhXCI6NzkyLFwib1wiOlwibSA3ODEgNDkwIGwgNDQ2IDQ5MCBsIDQ0NiAyNTUgbCAzNDkgMjU1IGwgMzQ5IDQ5MCBsIDExIDQ5MCBsIDExIDU4NiBsIDM0OSA1ODYgbCAzNDkgODE5IGwgNDQ2IDgxOSBsIDQ0NiA1ODYgbCA3ODEgNTg2IGwgNzgxIDQ5MCBtIDc4MSAyMSBsIDExIDIxIGwgMTEgMTE1IGwgNzgxIDExNSBsIDc4MSAyMSBcIn0sXCJ8XCI6e1wieF9taW5cIjozNDMsXCJ4X21heFwiOjQ0OSxcImhhXCI6NzkyLFwib1wiOlwibSA0NDkgNDYyIGwgMzQzIDQ2MiBsIDM0MyA5ODYgbCA0NDkgOTg2IGwgNDQ5IDQ2MiBtIDQ0OSAtMjQyIGwgMzQzIC0yNDIgbCAzNDMgMjgwIGwgNDQ5IDI4MCBsIDQ0OSAtMjQyIFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjYxNyxcImhhXCI6NzI1LFwib1wiOlwibSA0ODIgODAwIGwgMzcyIDgwMCBsIDM3MiA5MjUgbCA0ODIgOTI1IGwgNDgyIDgwMCBtIDIzOSA4MDAgbCAxMjkgODAwIGwgMTI5IDkyNSBsIDIzOSA5MjUgbCAyMzkgODAwIG0gNjE3IDM1MiBxIDU0MCA5MyA2MTcgMTk5IHEgMzA4IC0yNCA0NTUgLTI0IHEgNzYgOTMgMTYxIC0yNCBxIDAgMzUyIDAgMTk5IGwgMCA3MzggbCAxMjYgNzM4IGwgMTI2IDM1NCBxIDE2OSAxODUgMTI2IDI1NyBxIDMxMiA5OCAyMjAgOTggcSA0NTEgMTg1IDQwMiA5OCBxIDQ5MiAzNTQgNDkyIDI1NyBsIDQ5MiA3MzggbCA2MTcgNzM4IGwgNjE3IDM1MiBcIn0sXCLvv71cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjU5MyxcImhhXCI6NjkwLFwib1wiOlwibSA1OTMgNDI1IHEgNTU0IDMxMiA1OTMgMzY5IHEgNDY3IDIzMyA1MTYgMjU0IHEgNTM3IDgzIDUzNyAxNzIgcSA0NTkgLTc0IDUzNyAtMTIgcSAyODggLTEzMyAzODcgLTEzMyBxIDExNSAtNjkgMTg0IC0xMzMgcSA0NyA5NiA0NyAtNiBsIDE2NiA5NiBxIDE5OSA3IDE2NiA0MCBxIDI4OCAtMjYgMjMyIC0yNiBxIDM3MSAtNSAzMzIgLTI2IHEgNDIwIDYwIDQyMCAyMSBxIDMxMSAyMDEgNDIwIDEzOSBxIDEwOCAzMDkgMjEwIDI1NSBxIDAgNDkwIDAgMzgzIHEgMzMgNjAyIDAgNTUxIHEgMTI0IDY4NyA2NiA2NTQgcSA3NSA3NDMgOTMgNzEyIHEgNTggODEyIDU4IDc3MyBxIDEzMyA5ODQgNTggOTIwIHEgMzAwIDEwNDMgMjAxIDEwNDMgcSA0NTggOTg3IDM5NCAxMDQzIHEgNTI5IDgxNCA1MjkgOTI1IGwgNDExIDgxNCBxIDM3MCA5MDggNDA0IDg3NyBxIDI4OSA5MzkgMzM2IDkzOSBxIDIxMyA5MTEgMjQ2IDkzOSBxIDE4MCA4NDEgMTgwIDg4MyBxIDI4NiA3MjAgMTgwIDc3OSBxIDQ4NCA2MTIgNDgwIDYxNSBxIDU5MyA0MjUgNTkzIDUzNCBtIDQ2NyA0MDkgcSAzNTUgNTQ0IDQ2NyA0NzMgcSAxOTYgNjMwIDIyOCA2MTIgcSAxNDYgNTg3IDE2MiA2MDkgcSAxMjQgNTI1IDEyNCA1NTggcSAyMzkgMzg3IDEyNCA0NjIgcSAzOTggMjk4IDM2OSAzMTUgcSA0NDggMzQ1IDQyOSAzMTYgcSA0NjcgNDA5IDQ2NyAzNzUgXCJ9LFwiYlwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6Njg1LFwiaGFcIjo3ODMsXCJvXCI6XCJtIDY4NSAzNzIgcSA1OTcgOTkgNjg1IDIxMyBxIDM0NyAtMjUgNTAxIC0yNSBxIDIxOSA1IDI3NyAtMjUgcSAxMjEgOTMgMTYxIDM2IGwgMTIxIDAgbCAwIDAgbCAwIDEwMTMgbCAxMjEgMTAxMyBsIDEyMSA2MzQgcSAyMTQgNzIzIDE1NyA2OTIgcSAzNDEgNzU0IDI3MiA3NTQgcSA1OTEgNjM3IDQ5MyA3NTQgcSA2ODUgMzcyIDY4NSA1MjYgbSA1NTQgMzU2IHEgNDk5IDU1MCA1NTQgNDcwIHEgMzI4IDY0NCA0MzcgNjQ0IHEgMTYyIDU1NiAyMjMgNjQ0IHEgMTA4IDM2OSAxMDggNDc4IHEgMTYwIDE3NiAxMDggMjU2IHEgMzMwIDgzIDIyMSA4MyBxIDQ5OCAxNjkgNDM1IDgzIHEgNTU0IDM1NiA1NTQgMjQ1IFwifSxcInFcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjY4MyxcImhhXCI6ODc2LFwib1wiOlwibSA2ODMgLTI3OCBsIDU2NCAtMjc4IGwgNTY0IDk3IHEgNDc0IDggNTMzIDM5IHEgMzQ1IC0yMyA0MTUgLTIzIHEgOTEgOTMgMTg4IC0yMyBxIDAgMzY0IDAgMjAzIHEgODcgNjM1IDAgNTIyIHEgMzM3IDc2MCAxODQgNzYwIHEgNDY2IDcyNyA0MDggNzYwIHEgNTY0IDYzNyA1MjMgNjk1IGwgNTY0IDczNyBsIDY4MyA3MzcgbCA2ODMgLTI3OCBtIDU4MiAzNzUgcSA1MjcgNTY0IDU4MiA0ODggcSAzNTggNjUyIDQ2NiA2NTIgcSAxOTAgNTY1IDI1MyA2NTIgcSAxMzUgMzc3IDEzNSA0ODggcSAxODkgMTc5IDEzNSAyNjEgcSAzNjEgODQgMjUxIDg0IHEgNTMwIDE3OSA0NjkgODQgcSA1ODIgMzc1IDU4MiAyNjAgXCJ9LFwiP1wiOntcInhfbWluXCI6LTAuMTcxODc1LFwieF9tYXhcIjo5NjkuNTYyNSxcImhhXCI6MTA2OCxcIm9cIjpcIm0gOTY5IDAgbCA1NTUgMCBsIDU1NSAxMjMgcSA3NDQgMzA4IDY3NSAxOTQgcSA4MTQgNTU4IDgxNCA0MjMgcSA3MjYgODEyIDgxNCA3MDkgcSA0ODQgOTIyIDYzMyA5MjIgcSAyNDQgODIwIDMzNCA5MjIgcSAxNTQgNTY3IDE1NCA3MTkgcSAyMjMgMzE2IDE1NCA0MzMgcSA0MTIgMTIzIDI5MiAxOTkgbCA0MTIgMCBsIDAgMCBsIDAgMTI0IGwgMjE3IDEyNCBxIDY4IDMyNyAxMjIgMjEwIHEgMTUgNTcyIDE1IDQ0NCBxIDE0NCA5MTEgMTUgNzgxIHEgNDg0IDEwNDEgMjc0IDEwNDEgcSA4MjIgOTA5IDY5MSAxMDQxIHEgOTUzIDU2OSA5NTMgNzc3IHEgODk5IDMyNiA5NTMgNDQzIHEgNzUwIDEyNCA4NDYgMjEwIGwgOTY5IDEyNCBsIDk2OSAwIFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjYxNyxcImhhXCI6NzI1LFwib1wiOlwibSA2MTcgMzUyIHEgNTQwIDkzIDYxNyAxOTkgcSAzMDggLTI0IDQ1NSAtMjQgcSA3NiA5MyAxNjEgLTI0IHEgMCAzNTIgMCAxOTkgbCAwIDczOCBsIDEyNiA3MzggbCAxMjYgMzU0IHEgMTY5IDE4NSAxMjYgMjU3IHEgMzEyIDk4IDIyMCA5OCBxIDQ1MSAxODUgNDAyIDk4IHEgNDkyIDM1NCA0OTIgMjU3IGwgNDkyIDczOCBsIDYxNyA3MzggbCA2MTcgMzUyIG0gNTM1IDEwNDAgbCAzNDYgODE5IGwgMjYyIDgxOSBsIDM5NyAxMDQwIGwgNTM1IDEwNDAgXCJ9LFwielwiOntcInhfbWluXCI6LTAuMDE1NjI1LFwieF9tYXhcIjo2MTMuODkwNjI1LFwiaGFcIjo2OTcsXCJvXCI6XCJtIDYxMyAwIGwgMCAwIGwgMCAxMDAgbCA0MzMgNjMwIGwgMjAgNjMwIGwgMjAgNzM4IGwgNTk0IDczOCBsIDU5MyA2MzYgbCAxNjMgMTEwIGwgNjEzIDExMCBsIDYxMyAwIFwifSxcIu+/vVwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6ODk0LFwiaGFcIjoxMDAwLFwib1wiOlwibSAzODkgOTUxIGwgMjI5IDk1MSBsIDIyOSA1MDMgbCAxNjAgNTAzIGwgMTYwIDk1MSBsIDAgOTUxIGwgMCAxMDExIGwgMzg5IDEwMTEgbCAzODkgOTUxIG0gODk0IDUwMyBsIDgyNyA1MDMgbCA4MjcgOTM5IGwgNjg1IDUwMyBsIDYyMCA1MDMgbCA0ODEgOTM3IGwgNDgxIDUwMyBsIDQxNyA1MDMgbCA0MTcgMTAxMSBsIDUxNyAxMDExIGwgNjUzIDU4MCBsIDc5NiAxMDEwIGwgODk0IDEwMTEgbCA4OTQgNTAzIFwifSxcIj9cIjp7XCJ4X21pblwiOjAuNzgxMjUsXCJ4X21heFwiOjY5NyxcImhhXCI6ODEwLFwib1wiOlwibSA2OTcgLTI3OCBsIDU3MiAtMjc4IGwgNTcyIDQ1NCBxIDU0MCA1ODcgNTcyIDUzNiBxIDQyNSA2NTAgNTAxIDY1MCBxIDI3MSA1NzkgMzM3IDY1MCBxIDIwNiA0MjAgMjA2IDUwOSBsIDIwNiAwIGwgODEgMCBsIDgxIDQ4OSBxIDczIDU4OCA4MSA1NjIgcSAwIDY0NCA1NiA2NDQgbCAwIDc0MSBxIDY4IDc1NSAzOCA3NTUgcSAxNTggNzIxIDEyNCA3NTUgcSAyMDAgNjMwIDE5MyA2ODcgcSAyOTcgNzI2IDIzNCA2OTIgcSA0MzQgNzYxIDM1OSA3NjEgcSA2MjAgNjkyIDU0NCA3NjEgcSA2OTcgNTE2IDY5NyA2MjQgbCA2OTcgLTI3OCBtIDQ3OSAxMDQwIGwgMjkwIDgxOSBsIDIwNyA4MTkgbCAzNDEgMTA0MCBsIDQ3OSAxMDQwIFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjk2MCxcImhhXCI6MTA1NixcIm9cIjpcIm0gOTYwIDUwNyBxIDgzMyAxMjkgOTYwIDI4MCBxIDQ3NiAtMzIgNjk4IC0zMiBxIDEyMyAxMjkgMjU1IC0zMiBxIDAgNTA3IDAgMjgwIHEgMTIzIDg4MyAwIDczMiBxIDQ3NiAxMDQ1IDI1NSAxMDQ1IHEgODMyIDg4MyA2OTYgMTA0NSBxIDk2MCA1MDcgOTYwIDczMiBtIDgxNyA1MDAgcSA3MzMgNzg5IDgxNyA2NjkgcSA0NzYgOTI0IDYzOSA5MjQgcSAyMjMgNzkyIDMxNyA5MjQgcSAxNDIgNTA3IDE0MiA2NzUgcSAyMjIgMjIyIDE0MiAzMzkgcSA0NzYgODkgMzE1IDg5IHEgNzMwIDIxOCA2MzYgODkgcSA4MTcgNTAwIDgxNyAzMzQgbSA3MTYgNDQ5IGwgMjQzIDQ0OSBsIDI0MyA1NzEgbCA3MTYgNTcxIGwgNzE2IDQ0OSBcIn0sXCLvv71cIjp7XCJ4X21pblwiOi0zLFwieF9tYXhcIjoxMDA4LFwiaGFcIjoxMTA2LFwib1wiOlwibSA1MDMgNTMyIHEgNjE0IDU2MiA1NjYgNTMyIHEgNjcyIDY1OCA2NzIgNTk4IHEgNjE0IDc0NyA2NzIgNzE2IHEgNTAzIDc3MiA1NjkgNzcyIGwgMzM4IDc3MiBsIDMzOCA1MzIgbCA1MDMgNTMyIG0gNTAyIC03IHEgMTIzIDE1MSAyNjMgLTcgcSAtMyA1MDEgLTMgMjk0IHEgMTIzIDg1MSAtMyA3MDYgcSA1MDIgMTAxMSAyNjMgMTAxMSBxIDg4MSA4NTEgNzM5IDEwMTEgcSAxMDA4IDUwMSAxMDA4IDcwOCBxIDg4MyAxNTEgMTAwOCAyOTIgcSA1MDIgLTcgNzQ0IC03IG0gNTAyIDYwIHEgODMwIDE5NyA3MDkgNjAgcSA5NDAgNTAxIDk0MCAzMjIgcSA4MzEgODA1IDk0MCA2ODEgcSA1MDIgOTQ0IDcwOSA5NDQgcSAxNzQgODA1IDI5NiA5NDQgcSA2NSA1MDEgNjUgNjgwIHEgMTczIDE5NyA2NSAzMjAgcSA1MDIgNjAgMjk0IDYwIG0gNzg4IDE0NiBsIDY3OCAxNDYgcSA2NTMgMzE2IDY1NSAxODMgcSA1MjcgNDQ5IDY1MiA0NDkgbCAzMzggNDQ5IGwgMzM4IDE0NiBsIDI0MSAxNDYgbCAyNDEgODU0IGwgNTE4IDg1NCBxIDY4OCA4MDggNjIxIDg1NCBxIDc2NiA2NTggNzY2IDc1NSBxIDczOSA1NjMgNzY2IDYwNyBxIDY2OCA0OTcgNzEzIDUxOSBxIDc1MSAzMzEgNzQ3IDQ3MiBxIDc4OCAxNjQgNzU2IDE5MCBsIDc4OCAxNDYgXCJ9LFwiflwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6ODMzLFwiaGFcIjo5MzEsXCJvXCI6XCJtIDgzMyA5NTggcSA3NzggNzUzIDgzMyA4MzEgcSA1OTQgNjY1IDcxNiA2NjUgcSA0MDIgNzYxIDUwMiA2NjUgcSAyNDAgODU3IDMwMiA4NTcgcSAxMzEgNzk1IDE2NiA4NTcgcSAxMDQgNjY1IDEwNCA3NDUgbCAwIDY2NSBxIDU0IDg2NyAwIDc4OSBxIDIzNyA5NTggMTE2IDk1OCBxIDQyOSA4NjEgMzMxIDk1OCBxIDU5NCA3NjUgNTI3IDc2NSBxIDcwNCA4MjcgNjcwIDc2NSBxIDcyOSA5NTggNzI5IDg3NCBsIDgzMyA5NTggXCJ9LFwiP1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NzM2LjIxODc1LFwiaGFcIjo3NzgsXCJvXCI6XCJtIDczNiAwIGwgMCAwIGwgMCAxMDEzIGwgNzI1IDEwMTMgbCA3MjUgODg5IGwgMTM5IDg4OSBsIDEzOSA1ODUgbCA2NzcgNTg1IGwgNjc3IDQ2NyBsIDEzOSA0NjcgbCAxMzkgMTI1IGwgNzM2IDEyNSBsIDczNiAwIFwifSxcIu+/vVwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NDUwLFwiaGFcIjo1NDcsXCJvXCI6XCJtIDQ1MCA1NTIgcSAzNzkgNDEzIDQ1MCA0NjQgcSAyMjAgMzY2IDMxMyAzNjYgcSA2OSA0MTQgMTMwIDM2NiBxIDAgNTY3IDAgNDcwIGwgODUgNTY3IHEgMTI2IDQ3MCA4NSA1MDQgcSAyMjUgNDM3IDE2OCA0MzcgcSAzMjAgNDY3IDI4MCA0MzcgcSAzNjAgNTUyIDM2MCA0OTggcSAzMTggNjMyIDM2MCA2MDggcSAyMTMgNjU3IDI3NiA2NTcgcSAxOTUgNjU3IDIwMyA2NTcgcSAxNzYgNjU3IDE4MSA2NTcgbCAxNzYgNzIyIHEgMjc5IDczMyAyNDkgNzIyIHEgMzM0IDgxNSAzMzQgNzUyIHEgMzAwIDg4MSAzMzQgODU2IHEgMjIwIDkwNyAyNjcgOTA3IHEgMTMzIDg3NSAxNjkgOTA3IHEgOTcgNzgxIDk3IDg0NCBsIDE1IDc4MSBxIDc4IDkyNiAxNSA4NzUgcSAyMjAgOTcyIDEzNSA5NzIgcSAzNjQgOTMwIDMwMyA5NzIgcSA0MjYgODE3IDQyNiA4ODggcSAzNDQgNjk3IDQyNiA3MzMgcSA0MjEgNjQyIDM5MiA2ODEgcSA0NTAgNTUyIDQ1MCA2MDMgXCJ9LFwiW1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6MjczLjYwOTM3NSxcImhhXCI6MzcxLFwib1wiOlwibSAyNzMgLTI4MSBsIDAgLTI4MSBsIDAgMTAxMyBsIDI3MyAxMDEzIGwgMjczIDkyMCBsIDEyNCA5MjAgbCAxMjQgLTE4NyBsIDI3MyAtMTg3IGwgMjczIC0yODEgXCJ9LFwiTFwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NjQ1LjgyODEyNSxcImhhXCI6Njk2LFwib1wiOlwibSA2NDUgMCBsIDAgMCBsIDAgMTAxMyBsIDE0MCAxMDEzIGwgMTQwIDEyNiBsIDY0NSAxMjYgbCA2NDUgMCBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo4MDMuMzkwNjI1LFwiaGFcIjo4OTQsXCJvXCI6XCJtIDgwMyA2MjggbCA2MzMgNjI4IHEgNzEzIDM2OCA3MTMgNTEyIHEgNjE4IDkzIDcxMyAyMDQgcSAzNTcgLTI1IDUxOCAtMjUgcSA5NCA5MSAxOTQgLTI1IHEgMCAzNjggMCAyMDEgcSA5NCA2NDQgMCA1MzMgcSAzNTYgNzYxIDE5NCA3NjEgcSA0ODEgNzUwIDM5OCA3NjEgcSA2MDggNzM5IDU2NCA3MzkgbCA4MDMgNzM5IGwgODAzIDYyOCBtIDM2MCA4NSBxIDUyOSAxODAgNDY3IDg1IHEgNTg0IDM3NCA1ODQgMjYyIHEgNTI3IDU2NiA1ODQgNDkwIHEgMzUyIDY1MSA0NjMgNjUxIHEgMTg3IDU1OSAyNDcgNjUxIHEgMTM1IDM2OCAxMzUgNDc4IHEgMTg5IDE3NSAxMzUgMjU0IHEgMzYwIDg1IDI1MSA4NSBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo1NzMsXCJoYVwiOjY0MixcIm9cIjpcIm0gNTczIC00MCBxIDU1MyAtMTYyIDU3MyAtOTcgcSA1MTAgLTI3OCA1NDMgLTE5MyBsIDQwMCAtMjc4IHEgNDQxIC0xODcgNDI4IC0yMTkgcSA0NjIgLTkwIDQ2MiAtMTMyIHEgMzc4IC0xNCA0NjIgLTE0IHEgMTA4IDQ1IDE5NyAtMTQgcSAwIDI5MCAwIDExNyBxIDEwOCA2MzEgMCA0NjIgcSAzNTMgOTAxIDE5NCA3NjcgbCA1NSA5MDEgbCA1NSAxMDEyIGwgNTYxIDEwMTIgbCA1NjEgOTI0IHEgMjYxIDY2OSAzODIgODMxIHEgMTI4IDMwMSAxMjggNDg5IHEgMjQzIDExNyAxMjggMTQ5IHEgNDU4IDk4IDM1MCAxMDggcSA1NzMgLTQwIDU3MyA4MCBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo2NzQsXCJoYVwiOjc3OCxcIm9cIjpcIm0gNjc0IDQ5NiBxIDYwMSAxNjAgNjc0IDMwNCBxIDMzNiAtMjYgNTA4IC0yNiBxIDczIDE1MyAxNjUgLTI2IHEgMCA0ODUgMCAyOTYgcSA3MiA4NDAgMCA2ODMgcSAzNDMgMTA0NSAxNjYgMTA0NSBxIDYwNSA4NDQgNTE2IDEwNDUgcSA2NzQgNDk2IDY3NCA2OTIgbSA1NDYgNTc5IHEgNDk4IDc5OCA1NDYgNjkxIHEgMzM2IDkzNSA0MzcgOTM1IHEgMTc4IDc5OCAyMzcgOTM1IHEgMTI2IDU3OSAxMzcgNzAxIGwgNTQ2IDU3OSBtIDU0NiA0NzUgbCAxMjYgNDc1IHEgMTcwIDIzMyAxMjYgMzQ4IHEgMzM4IDgwIDIzMCA4MCBxIDUwNCAyMzMgNDQ3IDgwIHEgNTQ2IDQ3NSA1NDYgMzQ2IFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjk1OCxcImhhXCI6MTA1NCxcIm9cIjpcIm0gNDg1IDEwNDIgcSA4MzQgODgzIDcwMyAxMDQyIHEgOTU4IDUxMSA5NTggNzM1IHEgODM0IDEzNiA5NTggMjg3IHEgNDgxIC0yNiA3MDEgLTI2IHEgMTI2IDEzMCAyNjEgLTI2IHEgMCA1MDQgMCAyNzkgcSAxMjcgODgwIDAgNzI5IHEgNDg1IDEwNDIgMjYzIDEwNDIgbSA0ODAgOTggcSA3MzEgMjI1IDYzOCA5OCBxIDgxNSA1MDQgODE1IDM0MCBxIDczMyA3ODMgODE1IDY3MCBxIDQ4MCA5MTMgNjQwIDkxMyBxIDIyNiA3ODUgMzIxIDkxMyBxIDE0MiA1MDQgMTQyIDY3MSBxIDIyNiAyMjQgMTQyIDMzOSBxIDQ4MCA5OCAzMTkgOTggXCJ9LFwiP1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NzA1LjI4MTI1LFwiaGFcIjo3NDksXCJvXCI6XCJtIDcwNSA4ODYgbCAxNDAgODg2IGwgMTQwIDAgbCAwIDAgbCAwIDEwMTIgbCA3MDUgMTAxMiBsIDcwNSA4ODYgXCJ9LFwiIFwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6MCxcImhhXCI6Mzc1fSxcIiVcIjp7XCJ4X21pblwiOi0zLFwieF9tYXhcIjoxMDg5LFwiaGFcIjoxMTg2LFwib1wiOlwibSA4NDUgMCBxIDY2MyA3NiA3MzEgMCBxIDYwMiAyNDQgNjAyIDE0NSBxIDY2MSA0MTIgNjAyIDM0NCBxIDg0NSA0ODkgNzI4IDQ4OSBxIDEwMjcgNDEyIDk1OSA0ODkgcSAxMDg5IDI0NCAxMDg5IDM0MyBxIDEwMjkgNzYgMTA4OSAxNDQgcSA4NDUgMCA5NjIgMCBtIDg0NCAxMDMgcSA5NDUgMTQzIDkwOSAxMDMgcSA5ODEgMjQzIDk4MSAxODQgcSA5NDcgMzQwIDk4MSAzMDEgcSA4NDQgMzg1IDkwOSAzODUgcSA3NDQgMzQyIDc4MSAzODUgcSA3MDggMjQzIDcwOCAzMDAgcSA3NDEgMTQ3IDcwOCAxODYgcSA4NDQgMTAzIDc4MCAxMDMgbSA4ODggOTg2IGwgMjg0IC0yNSBsIDE5OSAtMjUgbCA4MDMgOTg2IGwgODg4IDk4NiBtIDI0MSA0NjggcSA1OCA1NDUgMTI2IDQ2OCBxIC0zIDcxNSAtMyA2MTUgcSA1NiA4ODEgLTMgODEzIHEgMjM4IDk1OCAxMjQgOTU4IHEgNDIxIDg4MSAzNTMgOTU4IHEgNDgzIDcxMiA0ODMgODEzIHEgNDIzIDU0NCA0ODMgNjEyIHEgMjQxIDQ2OCAzNTYgNDY4IG0gMjQxIDg1NSBxIDEzNyA4MTEgMTc1IDg1NSBxIDEwMCA3MTAgMTAwIDc2OCBxIDEzNiA2MTIgMTAwIDY1MyBxIDI0MCA1NzIgMTcyIDU3MiBxIDM0NCA2MTQgMzA2IDU3MiBxIDM4MiA3MTMgMzgyIDY1NiBxIDM0NyA4MTAgMzgyIDc3MSBxIDI0MSA4NTUgMzA4IDg1NSBcIn0sXCJQXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo3MjYsXCJoYVwiOjgwNixcIm9cIjpcIm0gNDI0IDEwMTMgcSA2NDAgOTMxIDU1NSAxMDEzIHEgNzI2IDcxOSA3MjYgODUwIHEgNjM3IDUwNiA3MjYgNTg3IHEgNDEzIDQyNiA1NDggNDI2IGwgMTQwIDQyNiBsIDE0MCAwIGwgMCAwIGwgMCAxMDEzIGwgNDI0IDEwMTMgbSAzNzkgODg5IGwgMTQwIDg4OSBsIDE0MCA1NDggbCAzNzIgNTQ4IHEgNTIyIDU4OSA0NTkgNTQ4IHEgNTkzIDcyMCA1OTMgNjM3IHEgNTI4IDg0NSA1OTMgODAxIHEgMzc5IDg4OSA0NjMgODg5IFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjEwNzguMjE4NzUsXCJoYVwiOjExMTgsXCJvXCI6XCJtIDEwNzggMCBsIDM0MiAwIGwgMzQyIDEwMTMgbCAxMDY3IDEwMTMgbCAxMDY3IDg4OSBsIDQ4MSA4ODkgbCA0ODEgNTg1IGwgMTAxOSA1ODUgbCAxMDE5IDQ2NyBsIDQ4MSA0NjcgbCA0ODEgMTI1IGwgMTA3OCAxMjUgbCAxMDc4IDAgbSAyNzcgMTA0MCBsIDgzIDc5OSBsIDAgNzk5IGwgMTQwIDEwNDAgbCAyNzcgMTA0MCBcIn0sXCI/XCI6e1wieF9taW5cIjowLjEyNSxcInhfbWF4XCI6MTEzNi41NDY4NzUsXCJoYVwiOjEyMzUsXCJvXCI6XCJtIDExMzYgMCBsIDcyMiAwIGwgNzIyIDEyMyBxIDkxMSAzMDkgODQyIDE5NCBxIDk4MSA1NTggOTgxIDQyMyBxIDg5MyA4MTMgOTgxIDcxMCBxIDY1MSA5MjMgODAwIDkyMyBxIDQxMSA4MjEgNTAxIDkyMyBxIDMyMSA1NjggMzIxIDcyMCBxIDM5MCAzMTYgMzIxIDQzMyBxIDU3OSAxMjMgNDU5IDIwMCBsIDU3OSAwIGwgMTY2IDAgbCAxNjYgMTI0IGwgMzg0IDEyNCBxIDIzNSAzMjcgMjg5IDIxMCBxIDE4MiA1NzIgMTgyIDQ0NCBxIDMxMSA5MTIgMTgyIDc4MiBxIDY1MSAxMDQyIDQ0MSAxMDQyIHEgOTg5IDkxMCA4NTggMTA0MiBxIDExMjAgNTY5IDExMjAgNzc4IHEgMTA2NiAzMjYgMTEyMCA0NDMgcSA5MTcgMTI0IDEwMTMgMjEwIGwgMTEzNiAxMjQgbCAxMTM2IDAgbSAyNzcgMTA0MCBsIDgzIDgwMCBsIDAgODAwIGwgMTQwIDEwNDEgbCAyNzcgMTA0MCBcIn0sXCJfXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo3MDUuNTYyNSxcImhhXCI6ODAzLFwib1wiOlwibSA3MDUgLTMzNCBsIDAgLTMzNCBsIDAgLTIzNCBsIDcwNSAtMjM0IGwgNzA1IC0zMzQgXCJ9LFwiP1wiOntcInhfbWluXCI6LTExMCxcInhfbWF4XCI6MjQ2LFwiaGFcIjoyNzUsXCJvXCI6XCJtIDI0NiAxMDQ2IGwgMTE4IDEwNDYgbCAxMTggMTE4OSBsIDI0NiAxMTg5IGwgMjQ2IDEwNDYgbSAxOCAxMDQ2IGwgLTExMCAxMDQ2IGwgLTExMCAxMTg5IGwgMTggMTE4OSBsIDE4IDEwNDYgbSAxMzYgMCBsIDAgMCBsIDAgMTAxMiBsIDEzNiAxMDEyIGwgMTM2IDAgXCJ9LFwiK1wiOntcInhfbWluXCI6MjMsXCJ4X21heFwiOjc2OCxcImhhXCI6NzkyLFwib1wiOlwibSA3NjggMzcyIGwgNDQ0IDM3MiBsIDQ0NCAwIGwgMzQ3IDAgbCAzNDcgMzcyIGwgMjMgMzcyIGwgMjMgNDY4IGwgMzQ3IDQ2OCBsIDM0NyA4NDAgbCA0NDQgODQwIGwgNDQ0IDQ2OCBsIDc2OCA0NjggbCA3NjggMzcyIFwifSxcIu+/vVwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6MTA1MCxcImhhXCI6MTE0OSxcIm9cIjpcIm0gMTA1MCAwIGwgNjI1IDAgcSA3MTIgMTc4IDYyNSAxMDggcSA4NzggMjc3IDcyMiAxODcgcSA5NjcgMzg1IDk2NyAzMjggcSA5MzIgNDU2IDk2NyA0MjkgcSA4NTAgNDg0IDg5NyA0ODQgcSA3NTkgNDUwIDc5OCA0ODQgcSA3MjEgMzUyIDcyMSA0MTYgbCA2NDAgMzUyIHEgNzA2IDUwMiA2NDAgNDQ4IHEgODUxIDU1MSA3NjYgNTUxIHEgOTg3IDUwOSA5MzEgNTUxIHEgMTA1MCAzODUgMTA1MCA0NjIgcSA5NzYgMjUxIDEwNTAgMzAxIHEgODI5IDE3OSA5MDIgMjE1IHEgNzE3IDY4IDc0MCAxMzMgbCAxMDUwIDY4IGwgMTA1MCAwIG0gODM0IDk4NSBsIDIxNSAtMjggbCAxMzAgLTI4IGwgNzUwIDk4NCBsIDgzNCA5ODUgbSAyMjQgNDIyIGwgMTQyIDQyMiBsIDE0MiA4MTEgbCAwIDgxMSBsIDAgODY3IHEgMTA0IDg4OSA2MiA4NjcgcSAxNjQgOTczIDE1NyA5MTYgbCAyMjQgOTczIGwgMjI0IDQyMiBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo3MjAsXCJoYVwiOjc4MyxcIm9cIjpcIm0gNDI0IDEwMTMgcSA2MzcgOTMzIDU1NCAxMDEzIHEgNzIwIDcyMyA3MjAgODUzIHEgNjMzIDUwOCA3MjAgNTkxIHEgNDEzIDQyNiA1NDYgNDI2IGwgMTQwIDQyNiBsIDE0MCAwIGwgMCAwIGwgMCAxMDEzIGwgNDI0IDEwMTMgbSAzNzggODg5IGwgMTQwIDg4OSBsIDE0MCA1NDggbCAzNzEgNTQ4IHEgNTIxIDU4OSA0NTggNTQ4IHEgNTkyIDcyMCA1OTIgNjM3IHEgNTI3IDg0NSA1OTIgODAxIHEgMzc4IDg4OSA0NjMgODg5IFwifSxcIidcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjEzOSxcImhhXCI6MjM2LFwib1wiOlwibSAxMzkgODUxIHEgMTAyIDczNyAxMzkgNzg0IHEgMCA2NjkgNjUgNjkwIGwgMCA3MzQgcSA1OSA3ODcgNDIgNzQxIHEgNzIgODczIDcyIDgyMSBsIDAgODczIGwgMCAxMDEzIGwgMTM5IDEwMTMgbCAxMzkgODUxIFwifSxcIu+/vVwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6MzUwLFwiaGFcIjozOTcsXCJvXCI6XCJtIDM1MCA2MjUgcSAzMDcgNjE2IDMyOCA2MTYgcSAyNjYgNjMxIDI4MSA2MTYgcSAyNDcgNjczIDI1MSA2NDUgcSAxOTAgNjI4IDIyNSA2NDQgcSAxMTYgNjEzIDE1NiA2MTMgcSAzMiA2NDEgNjQgNjEzIHEgMCA3MjIgMCA2NjkgcSA3MiA4MjYgMCA4MDAgcSAyNDcgODY2IDE1OSA4NDYgbCAyNDcgODg3IHEgMjIwIDkzNCAyNDcgOTE2IHEgMTYyIDk1MyAxOTQgOTUzIHEgMTA0IDkzNCAxMjkgOTUzIHEgNzYgODgyIDgwIDkxNSBsIDE2IDg4MiBxIDYwIDk3NiAxNiA5NDEgcSAxNjYgMTAxMSAxMDQgMTAxMSBxIDI2NiA5NzkgMjI0IDEwMTEgcSAzMDggODkxIDMwOCA5NDggbCAzMDggNzA2IHEgMzExIDY3OSAzMDggNjg4IHEgMzMxIDY3MCAzMTUgNjcwIGwgMzUwIDY3MiBsIDM1MCA2MjUgbSAyNDcgNzU3IGwgMjQ3IDgxMSBxIDEzNiA3OTAgMTc1IDc5OCBxIDY0IDcyNiA2NCA3NzMgcSA4MyA2ODIgNjQgNjk3IHEgMTMyIDY2NyAxMDMgNjY3IHEgMjA3IDY5MCAxNzQgNjY3IHEgMjQ3IDc1NyAyNDcgNzE4IFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjQ1MCxcImhhXCI6NTUzLFwib1wiOlwibSA0NTAgODAwIGwgMzQwIDgwMCBsIDM0MCA5MjUgbCA0NTAgOTI1IGwgNDUwIDgwMCBtIDQwNiAxMDQwIGwgMjEyIDgwMCBsIDEyOSA4MDAgbCAyNjkgMTA0MCBsIDQwNiAxMDQwIG0gMTEwIDgwMCBsIDAgODAwIGwgMCA5MjUgbCAxMTAgOTI1IGwgMTEwIDgwMCBcIn0sXCJUXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo3NzcsXCJoYVwiOjgzNSxcIm9cIjpcIm0gNzc3IDg5NCBsIDQ1OCA4OTQgbCA0NTggMCBsIDMxOSAwIGwgMzE5IDg5NCBsIDAgODk0IGwgMCAxMDEzIGwgNzc3IDEwMTMgbCA3NzcgODk0IFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjkxNSxcImhhXCI6OTk3LFwib1wiOlwibSA1MjcgMCBsIDM4OSAwIGwgMzg5IDEyMiBxIDExMCAyMzEgMjIwIDEyMiBxIDAgNTA5IDAgMzQwIHEgMTEwIDc4NSAwIDY3NyBxIDM4OSA4OTMgMjIwIDg5MyBsIDM4OSAxMDEzIGwgNTI3IDEwMTMgbCA1MjcgODkzIHEgODA0IDc4NiA2OTMgODkzIHEgOTE1IDUwOSA5MTUgNjc5IHEgODA1IDIzMSA5MTUgMzQxIHEgNTI3IDEyMiA2OTYgMTIyIGwgNTI3IDAgbSA1MjcgMjI2IHEgNzEyIDMxMCA2NDEgMjI2IHEgNzc5IDUwNyA3NzkgMzg5IHEgNzEyIDcwNSA3NzkgNjI3IHEgNTI3IDc4NyA2NDEgNzg3IGwgNTI3IDIyNiBtIDM4OSAyMjYgbCAzODkgNzg3IHEgMjA1IDY5OCAyNzUgNzc1IHEgMTM2IDUwNSAxMzYgNjIwIHEgMjA2IDMwOCAxMzYgMzkxIHEgMzg5IDIyNiAyNzYgMjI2IFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjAsXCJoYVwiOjY5NH0sXCJqXCI6e1wieF9taW5cIjotNzcuNzgxMjUsXCJ4X21heFwiOjE2NyxcImhhXCI6MzQ5LFwib1wiOlwibSAxNjcgODcxIGwgNDIgODcxIGwgNDIgMTAxMyBsIDE2NyAxMDEzIGwgMTY3IDg3MSBtIDE2NyAtODAgcSAxMjEgLTIzMSAxNjcgLTE4NCBxIC0yNiAtMjc4IDc2IC0yNzggbCAtNzcgLTI3OCBsIC03NyAtMTY0IGwgLTQxIC0xNjQgcSAyNiAtMTQzIDExIC0xNjQgcSA0MiAtNjUgNDIgLTEyMiBsIDQyIDczNyBsIDE2NyA3MzcgbCAxNjcgLTgwIFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjc1Ni45NTMxMjUsXCJoYVwiOjgxOSxcIm9cIjpcIm0gNzU2IDAgbCAwIDAgbCAwIDEwNyBsIDM5NSA1MjMgbCAyMiA5MDQgbCAyMiAxMDEzIGwgNzQ1IDEwMTMgbCA3NDUgODg5IGwgMjA5IDg4OSBsIDU2NiA1MjMgbCAxODcgMTI1IGwgNzU2IDEyNSBsIDc1NiAwIFwifSxcIjFcIjp7XCJ4X21pblwiOjIxNS42NzE4NzUsXCJ4X21heFwiOjU3NCxcImhhXCI6NzkyLFwib1wiOlwibSA1NzQgMCBsIDQ0MiAwIGwgNDQyIDY5NyBsIDIxNSA2OTcgbCAyMTUgNzk2IHEgMzg2IDgzMyAzMzAgNzk2IHEgNDc1IDk4NiA0NDcgODc1IGwgNTc0IDk4NiBsIDU3NCAwIFwifSxcIu+/vVwiOntcInhfbWluXCI6MTguMDYyNSxcInhfbWF4XCI6Nzc0LFwiaGFcIjo3OTIsXCJvXCI6XCJtIDc3NCAzNzYgbCAxOCA0MCBsIDE4IDE0OSBsIDYzMSA0MjEgbCAxOCA2OTIgbCAxOCA3OTkgbCA3NzQgNDY1IGwgNzc0IDM3NiBcIn0sXCI8XCI6e1wieF9taW5cIjoxNy45ODQzNzUsXCJ4X21heFwiOjc3My42MDkzNzUsXCJoYVwiOjc5MixcIm9cIjpcIm0gNzczIDQwIGwgMTggMzc2IGwgMTcgNDY1IGwgNzczIDc5OSBsIDc3MyA2OTIgbCAxNTkgNDIwIGwgNzczIDE0OSBsIDc3MyA0MCBcIn0sXCLvv71cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjcwNC40ODQzNzUsXCJoYVwiOjgwMSxcIm9cIjpcIm0gNzA0IDQxIHEgNjIzIC0xMCA2NjQgNSBxIDU0MyAtMjYgNTgzIC0yNiBxIDM1OSAxNSA1MDEgLTI2IHEgMjQzIDM2IDI4OCAzNiBxIDE1OCAyMyAxOTcgMzYgcSA3MyAtMjEgMTE5IDEwIGwgNiA3NiBxIDEyNSAxOTUgOTAgMTUwIHEgMTc1IDMzMSAxNzUgMjYyIHEgMTQ3IDQ0MyAxNzUgMzgzIGwgMCA0NDMgbCAwIDUxMiBsIDEwOCA1MTIgcSA0MyA3MzQgNDMgNjIzIHEgMTIwIDkyOSA0MyA4NTQgcSAzNTggMTAxMCAyMDQgMTAxMCBxIDU3OSA5MzYgNDg3IDEwMTAgcSA2NzggNzI5IDY3OCA4NTcgbCA2NzggNjg0IGwgNTUyIDY4NCBxIDUwNCA4MzggNTUyIDc4MCBxIDM2MiA4OTYgNDU3IDg5NiBxIDIxNiA4NTIgMjYzIDg5NiBxIDE3NiA3NDcgMTc2IDgxNSBxIDE5OSA2MjcgMTc2IDY5NyBxIDI0OCA1MTIgMjE3IDU3NCBsIDQ2OCA1MTIgbCA0NjggNDQzIGwgMjc5IDQ0MyBxIDI5NyAzNTYgMjk3IDM5OCBxIDIzMCAxOTQgMjk3IDI3OSBxIDE1MyAxMDcgMjExIDE3MCBxIDIyNyAxMzMgMTkwIDEyNSBxIDI5MyAxNDIgMjY0IDE0MiBxIDQxMCAxMTkgMzM5IDE0MiBxIDUxNiA5NiA0ODIgOTYgcSA1NzkgMTA1IDU1MCA5NiBxIDY0OCAxNDIgNjA4IDExNSBsIDcwNCA0MSBcIn0sXCJ0XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjozNjcsXCJoYVwiOjQ1OCxcIm9cIjpcIm0gMzY3IDAgcSAzMTIgLTUgMzM5IC0yIHEgMjYyIC04IDI4NCAtOCBxIDE0NSAyOCAxODMgLTggcSAxMDggMTQzIDEwOCA2NCBsIDEwOCA2MzggbCAwIDYzOCBsIDAgNzM4IGwgMTA4IDczOCBsIDEwOCA5NDQgbCAyMzIgOTQ0IGwgMjMyIDczOCBsIDM2NyA3MzggbCAzNjcgNjM4IGwgMjMyIDYzOCBsIDIzMiAxODUgcSAyNDggMTIxIDIzMiAxNDAgcSAzMDcgMTAyIDI2NCAxMDIgcSAzNDUgMTA0IDMzMCAxMDIgcSAzNjcgMTA3IDM2MCAxMDcgbCAzNjcgMCBcIn0sXCLvv71cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjcwNixcImhhXCI6ODAzLFwib1wiOlwibSA3MDYgNDExIGwgNzA2IDE1OCBsIDYzMCAxNTggbCA2MzAgMzM1IGwgMCAzMzUgbCAwIDQxMSBsIDcwNiA0MTEgXCJ9LFwiP1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NzUwLFwiaGFcIjo4MDMsXCJvXCI6XCJtIDc1MCAtNyBxIDY3OSAtMTUgNzE2IC0xNSBxIDUzOCA1OSA1OTEgLTE1IHEgNDY2IDIxNCA1MTIgOTcgbCAzMzYgNTUxIGwgMTI2IDAgbCAwIDAgbCAyNzAgNzA1IHEgMjIzIDgzNyAyNDcgNzcwIHEgMTE2IDg5OSAxOTAgODk5IHEgOTAgODk4IDEwMCA4OTkgbCA5MCAxMDA0IHEgMTUyIDEwMTEgMTI1IDEwMTEgcSAyOTggOTM4IDI0NCAxMDExIHEgMzczIDc4MyAzMjYgOTAxIGwgNjA1IDE5MiBxIDY0OSAxMTUgNjI5IDEzNiBxIDcxNiA5NSA2NjkgOTUgbCA3MzYgOTUgcSA3NTAgOTcgNzQ1IDk3IGwgNzUwIC03IFwifSxcIldcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjEyNjMuODkwNjI1LFwiaGFcIjoxMzUxLFwib1wiOlwibSAxMjYzIDEwMTMgbCA5OTUgMCBsIDg1OSAwIGwgNjI3IDgzNyBsIDQwNSAwIGwgMjY1IDAgbCAwIDEwMTMgbCAxMzYgMTAxMyBsIDM0MiAyMDIgbCA1NTYgMTAxMyBsIDcwMSAxMDEzIGwgOTIxIDIwNyBsIDExMzMgMTAxMiBsIDEyNjMgMTAxMyBcIn0sXCI+XCI6e1wieF9taW5cIjoxOC4wNjI1LFwieF9tYXhcIjo3NzQsXCJoYVwiOjc5MixcIm9cIjpcIm0gNzc0IDM3NiBsIDE4IDQwIGwgMTggMTQ5IGwgNjMxIDQyMSBsIDE4IDY5MiBsIDE4IDc5OSBsIDc3NCA0NjUgbCA3NzQgMzc2IFwifSxcInZcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjY3NS4xNTYyNSxcImhhXCI6NzYxLFwib1wiOlwibSA2NzUgNzM4IGwgNDA0IDAgbCAyNzIgMCBsIDAgNzM4IGwgMTMzIDczNyBsIDM0MCAxNDcgbCA1NDEgNzM3IGwgNjc1IDczOCBcIn0sXCI/XCI6e1wieF9taW5cIjowLjI4MTI1LFwieF9tYXhcIjo2NDQuNSxcImhhXCI6NzAzLFwib1wiOlwibSA2NDQgNjI4IGwgMzgyIDYyOCBsIDM4MiAxNzkgcSAzODggMTIwIDM4MiAxMzcgcSA0MzYgOTEgNDAxIDkxIHEgNDc0IDk0IDQ0NyA5MSBxIDUwNCA5NyA1MDEgOTcgbCA1MDQgMCBxIDQ1NCAtOSA0ODIgLTUgcSA0MDEgLTE0IDQyNiAtMTQgcSAyNzggNjcgMzA4IC0xNCBxIDI2MCAyMzMgMjYwIDExOCBsIDI2MCA2MjggbCAwIDYyOCBsIDAgNzM5IGwgNjQ0IDczOSBsIDY0NCA2MjggXCJ9LFwiP1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NjI0LjkzNzUsXCJoYVwiOjY5OSxcIm9cIjpcIm0gNjI0IC0zNyBxIDYwOCAtMTUzIDYyNCAtOTYgcSA1NjMgLTI3OCA1OTMgLTIxMSBsIDQ1NCAtMjc4IHEgNDkxIC0xODMgNDg2IC0yMDAgcSA1MTEgLTgzIDUxMSAtMTI2IHEgNDg0IC0yMyA1MTEgLTQ0IHEgMzcwIDEgNDUyIDEgcSAzMjMgMCAzNTQgMSBxIDI4MyAtMSAyOTMgLTEgcSA4NCA3NiAxNjkgLTEgcSAwIDI2NiAwIDE1NCBxIDU2IDQzMSAwIDM1OCBxIDE5NyA1MzggMTA4IDQ5OCBxIDk0IDYxMyAxMzQgNTYyIHEgNTQgNzMwIDU0IDY2NSBxIDc3IDgyMyA1NCA3ODAgcSAxNDMgOTAxIDEwMSA4NjcgbCAyNyA5MDEgbCAyNyAxMDEyIGwgNTc2IDEwMTIgbCA1NzYgOTAxIGwgMzgwIDkwMSBxIDI0NCA4NjMgMzAzIDkwMSBxIDE3OCA3NDUgMTc4IDgyMCBxIDMxMiA2MDAgMTc4IDYzNiBxIDUzMiA1ODIgMzgwIDU4MiBsIDUzMiA0NzkgcSAyNzYgNDU1IDM2MSA0NzkgcSAxMTggMjgxIDExOCA0MTAgcSAxNjUgMTczIDExOCAyMTcgcSAyNzQgMTIwIDIwOCAxMzMgcSA0OTQgMTAxIDM4NCAxMTAgcSA2MjQgLTM3IDYyNCA3NiBcIn0sXCImXCI6e1wieF9taW5cIjotMyxcInhfbWF4XCI6ODk0LjI1LFwiaGFcIjo5OTIsXCJvXCI6XCJtIDg5NCAwIGwgNzI1IDAgbCA2MjQgMTIzIHEgNDcxIDAgNTUzIDQwIHEgMzA2IC00MSAzOTAgLTQxIHEgMTY4IC03IDIzMSAtNDEgcSA2MiA5MiAxMDUgMjYgcSAxNCAxODcgMzEgMTM5IHEgLTMgMjc2IC0zIDIzNSBxIDU1IDQzMyAtMyAzNTggcSAyNDggNTgxIDExNCA1MDggcSAxNzAgNjg5IDE5NiA2NDAgcSAxMzcgODE3IDEzNyA3NTEgcSAyMTQgOTg1IDEzNyA5MjIgcSAzODQgMTA0MSAyODQgMTA0MSBxIDU0OCA5ODggNDgzIDEwNDEgcSA2MjIgODI0IDYyMiA5MjggcSA1NjMgNjY2IDYyMiA3MzkgcSA0MzEgNTU2IDUxNiA2MDggbCA2MjEgMzI2IHEgNjQ5IDQwNyA2MzkgMzYxIHEgNjYzIDQ5MyA2NTMgNDI2IGwgNzgxIDQ5MyBxIDcwMyAyMjkgNzgxIDM1MiBsIDg5NCAwIG0gNTA0IDgxOCBxIDQ2OCA5MDggNTA0IDg3NyBxIDM4NCA5NDAgNDMzIDk0MCBxIDI5MyA5MDcgMzMxIDk0MCBxIDI1NSA4MTggMjU1IDg3NSBxIDI4OSA3MTQgMjU1IDc2NyBxIDM2MyA2MjggMzEzIDY3OCBxIDQ3NyA3MjkgNDQ2IDY4MiBxIDUwNCA4MTggNTA0IDc3MSBtIDU1NiAyMDkgbCAzMTQgNDk5IHEgMTc5IDM5NSAyMjMgNDQ5IHEgMTM1IDI4MyAxMzUgMzQxIHEgMTQ2IDIyMiAxMzUgMjUzIHEgMTgzIDE1OCAxNTggMTkyIHEgMzMzIDgwIDI0MSA4MCBxIDU1NiAyMDkgNDQ4IDgwIFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjg2Mi41LFwiaGFcIjo5NDIsXCJvXCI6XCJtIDg2MiAwIGwgNzE5IDAgbCA0MjYgODQ3IGwgMTQzIDAgbCAwIDAgbCAzNTYgMTAxMyBsIDUwMSAxMDEzIGwgODYyIDAgXCJ9LFwiSVwiOntcInhfbWluXCI6NDEsXCJ4X21heFwiOjE4MCxcImhhXCI6MjkzLFwib1wiOlwibSAxODAgMCBsIDQxIDAgbCA0MSAxMDEzIGwgMTgwIDEwMTMgbCAxODAgMCBcIn0sXCJHXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo5MjEsXCJoYVwiOjEwMTEsXCJvXCI6XCJtIDkyMSAwIGwgODMyIDAgbCA4MDEgMTM2IHEgNjU1IDE1IDc0MSA1OCBxIDQ3MCAtMjggNTY4IC0yOCBxIDEyNiAxMzMgMjU5IC0yOCBxIDAgNDk5IDAgMjg0IHEgMTI1IDg4MSAwIDczMSBxIDQ4NiAxMDQzIDI1OSAxMDQzIHEgNzYzIDk1NyA2NDcgMTA0MyBxIDkwNSA3MDkgODkwIDg2NCBsIDc3MiA3MDkgcSA2NjggODY2IDc0NyA4MDcgcSA0ODYgOTI2IDU4OSA5MjYgcSAyMjggNzk1IDMyMiA5MjYgcSAxNDIgNTA3IDE0MiA2NzcgcSAyMjggMjI0IDE0MiAzNDIgcSA0ODMgOTQgMzIzIDk0IHEgNzEyIDE5NSA2MjUgOTQgcSA3OTYgNDM1IDc5NiAyOTEgbCA0NzcgNDM1IGwgNDc3IDU0OSBsIDkyMSA1NDkgbCA5MjEgMCBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo2MTcsXCJoYVwiOjcyNSxcIm9cIjpcIm0gNTI0IDgwMCBsIDQxNCA4MDAgbCA0MTQgOTI1IGwgNTI0IDkyNSBsIDUyNCA4MDAgbSAxODMgODAwIGwgNzMgODAwIGwgNzMgOTI1IGwgMTgzIDkyNSBsIDE4MyA4MDAgbSA2MTcgMzUyIHEgNTQwIDkzIDYxNyAxOTkgcSAzMDggLTI0IDQ1NSAtMjQgcSA3NiA5MyAxNjEgLTI0IHEgMCAzNTIgMCAxOTkgbCAwIDczOCBsIDEyNiA3MzggbCAxMjYgMzU0IHEgMTY5IDE4NSAxMjYgMjU3IHEgMzEyIDk4IDIyMCA5OCBxIDQ1MSAxODUgNDAyIDk4IHEgNDkyIDM1NCA0OTIgMjU3IGwgNDkyIDczOCBsIDYxNyA3MzggbCA2MTcgMzUyIG0gNDg5IDEwNDAgbCAzMDAgODE5IGwgMjE2IDgxOSBsIDM1MSAxMDQwIGwgNDg5IDEwNDAgXCJ9LFwiYFwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6MTM4Ljg5MDYyNSxcImhhXCI6MjM2LFwib1wiOlwibSAxMzggNjk5IGwgMCA2OTkgbCAwIDg2MSBxIDM2IDk3NCAwIDkyOSBxIDEzOCAxMDQxIDcyIDEwMjAgbCAxMzggOTc3IHEgODIgOTMxIDk1IDk2OSBxIDY5IDgzOSA2OSA4OTMgbCAxMzggODM5IGwgMTM4IDY5OSBcIn0sXCLvv71cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjE0MixcImhhXCI6MjM5LFwib1wiOlwibSAxNDIgNTg1IGwgMCA1ODUgbCAwIDczOCBsIDE0MiA3MzggbCAxNDIgNTg1IFwifSxcIj9cIjp7XCJ4X21pblwiOjAuMzI4MTI1LFwieF9tYXhcIjo4MTkuNTE1NjI1LFwiaGFcIjo4ODksXCJvXCI6XCJtIDgxOSAxMDEzIGwgNDgyIDQxNiBsIDQ4MiAwIGwgMzQyIDAgbCAzNDIgNDE2IGwgMCAxMDEzIGwgMTQwIDEwMTMgbCA0MTEgNTMzIGwgNjc5IDEwMTMgbCA4MTkgMTAxMyBcIn0sXCJyXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjozNTUuNTYyNSxcImhhXCI6NDMyLFwib1wiOlwibSAzNTUgNjIxIGwgMzQzIDYyMSBxIDE3OSA1NjkgMjM2IDYyMSBxIDEyMiA0MTEgMTIyIDUxOCBsIDEyMiAwIGwgMCAwIGwgMCA3MzcgbCAxMTcgNzM3IGwgMTE3IDYwNCBxIDIwNCA3MTkgMTQ2IDY4NiBxIDM1NSA3NTMgMjYyIDc1MyBsIDM1NSA2MjEgXCJ9LFwieFwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6Njc1LFwiaGFcIjo3NjQsXCJvXCI6XCJtIDY3NSAwIGwgNTI1IDAgbCAzMzEgMjg2IGwgMTQ0IDAgbCAwIDAgbCAyNTYgMzc5IGwgMTIgNzM4IGwgMTU3IDczNyBsIDMzNiA0NzMgbCA1MTYgNzM4IGwgNjYxIDczOCBsIDQxMiAzODAgbCA2NzUgMCBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo2OTYuNjA5Mzc1LFwiaGFcIjo3NDcsXCJvXCI6XCJtIDY5NiAtNCBxIDYyOCAtMTQgNjU3IC0xNCBxIDQ5OCA5NyA1MTMgLTE0IHEgNDIyIDggNDcwIDQxIHEgMzEzIC0yNCAzNzQgLTI0IHEgMjA3IDMgMjU4IC0yNCBxIDEyMCA4MCAxNTcgMzEgbCAxMjAgLTI3OCBsIDAgLTI3OCBsIDAgNzM4IGwgMTI0IDczOCBsIDEyNCAzNDMgcSAxNjUgMTcyIDEyNCAyNDYgcSAzMDggODIgMjE2IDgyIHEgNDUxIDE3NyA0MDIgODIgcSA0OTIgMzU4IDQ5MiAyNTQgbCA0OTIgNzM4IGwgNjE2IDczOCBsIDYxNiAyMTQgcSA2MjMgMTM2IDYxNiAxNjAgcSA2NzMgOTIgNjM2IDkyIHEgNjk2IDk1IDY4NCA5MiBsIDY5NiAtNCBcIn0sXCJoXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo2MTUsXCJoYVwiOjcyNCxcIm9cIjpcIm0gNjE1IDQ3MiBsIDYxNSAwIGwgNDkwIDAgbCA0OTAgNDU0IHEgNDU2IDU5MCA0OTAgNTM1IHEgMzM4IDY1NCA0MTYgNjU0IHEgMTg2IDU4OCAyNTEgNjU0IHEgMTIyIDQzNiAxMjIgNTIyIGwgMTIyIDAgbCAwIDAgbCAwIDEwMTMgbCAxMjIgMTAxMyBsIDEyMiA2MzMgcSAyMTggNzI3IDE0OSA2OTQgcSAzNjIgNzYwIDI4NyA3NjAgcSA1NTIgNjc2IDQ4NCA3NjAgcSA2MTUgNDcyIDYxNSA2MDAgXCJ9LFwiLlwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6MTQyLFwiaGFcIjoyMzksXCJvXCI6XCJtIDE0MiAwIGwgMCAwIGwgMCAxNTEgbCAxNDIgMTUxIGwgMTQyIDAgXCJ9LFwiP1wiOntcInhfbWluXCI6LTIsXCJ4X21heFwiOjg3OCxcImhhXCI6OTc0LFwib1wiOlwibSA0OTYgLTI3OSBsIDM3OCAtMjc5IGwgMzc4IC0xNyBxIDEwMSA4OCAyMDQgLTE3IHEgLTIgMzY3IC0yIDE5NCBxIDY4IDYyNiAtMiA1MTAgcSAyODMgNzU4IDE1MSA3NTggbCAyODMgNjQ2IHEgMTY3IDUzNyAyMDkgNjI2IHEgMTMzIDM3MyAxMzMgNDYyIHEgMTkyIDE3NyAxMzMgMjU0IHEgMzc4IDkzIDI1OSA5MyBsIDM3OCA3NTggcSA0NDUgNzY0IDQyNiA3NjMgcSA0NzYgNzY1IDQ2NCA3NjUgcSA3NjUgNjU5IDY1MyA3NjUgcSA4NzggMzc3IDg3OCA1NTMgcSA3NzEgOTYgODc4IDIwOSBxIDQ5NiAtMTcgNjY1IC0xNyBsIDQ5NiAtMjc5IG0gNDk2IDkzIGwgNTE0IDkzIHEgNjg3IDE4MyA2MjMgOTMgcSA3NDYgMzgwIDc0NiAyNjUgcSA2OTEgNTY5IDc0NiA0OTEgcSA1MjIgNjU4IDYyOSA2NTggbCA0OTYgNjU2IGwgNDk2IDkzIFwifSxcIjtcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjE0MixcImhhXCI6MjM5LFwib1wiOlwibSAxNDIgNTg1IGwgMCA1ODUgbCAwIDczOCBsIDE0MiA3MzggbCAxNDIgNTg1IG0gMTQyIC0xMiBxIDEwNSAtMTMyIDE0MiAtODIgcSAwIC0yMDYgNjggLTE4MiBsIDAgLTEzOCBxIDU4IC04MiA0MyAtMTIzIHEgNjggMCA2OCAtNTYgbCAwIDAgbCAwIDE1MSBsIDE0MiAxNTEgbCAxNDIgLTEyIFwifSxcImZcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjM3OCxcImhhXCI6NDcyLFwib1wiOlwibSAzNzggNjM4IGwgMjQ2IDYzOCBsIDI0NiAwIGwgMTIxIDAgbCAxMjEgNjM4IGwgMCA2MzggbCAwIDczOCBsIDEyMSA3MzggcSAxMzcgOTM1IDEyMSA4ODcgcSAyOTAgMTAyOCAxNzEgMTAyOCBxIDMyMCAxMDI3IDMwNSAxMDI4IHEgMzc4IDEwMjEgMzM0IDEwMjYgbCAzNzggOTA4IHEgMzIzIDkxOCAzNDYgOTE4IHEgMjU3IDg3MCAyNzMgOTE4IHEgMjQ2IDc4MCAyNDYgODQwIGwgMjQ2IDczOCBsIDM3OCA3MzggbCAzNzggNjM4IFwifSxcIu+/vVwiOntcInhfbWluXCI6MSxcInhfbWF4XCI6MzQ4LjIxODc1LFwiaGFcIjo0NTQsXCJvXCI6XCJtIDE0MCA2NzAgbCAxIDY3MCBsIDEgODMwIHEgMzcgOTQzIDEgODk3IHEgMTQwIDEwMTEgNzQgOTkwIGwgMTQwIDk0NyBxIDgyIDkwMCA5NyA5NDAgcSA2OCA4MTAgNjggODYxIGwgMTQwIDgxMCBsIDE0MCA2NzAgbSAzNDggNjcwIGwgMjA5IDY3MCBsIDIwOSA4MzAgcSAyNDUgOTQzIDIwOSA4OTcgcSAzNDggMTAxMSAyODIgOTkwIGwgMzQ4IDk0NyBxIDI5MCA5MDAgMzA1IDk0MCBxIDI3NiA4MTAgMjc2IDg2MSBsIDM0OCA4MTAgbCAzNDggNjcwIFwifSxcIkFcIjp7XCJ4X21pblwiOjAuMDMxMjUsXCJ4X21heFwiOjkwNi45NTMxMjUsXCJoYVwiOjEwMDgsXCJvXCI6XCJtIDkwNiAwIGwgNzU2IDAgbCA2NDggMzAzIGwgMjUxIDMwMyBsIDE0MiAwIGwgMCAwIGwgMzc2IDEwMTMgbCA1MjkgMTAxMyBsIDkwNiAwIG0gNjEwIDQyMSBsIDQ1MiA4NjcgbCAyOTMgNDIxIGwgNjEwIDQyMSBcIn0sXCI2XCI6e1wieF9taW5cIjo1MyxcInhfbWF4XCI6NzM5LFwiaGFcIjo3OTIsXCJvXCI6XCJtIDczOSAzMTIgcSA2MzMgNjIgNzM5IDE2MiBxIDQwMCAtMzEgNTM0IC0zMSBxIDE2MiA3OCAyNTcgLTMxIHEgNTMgNDM5IDUzIDIwNiBxIDE3OCA4NTkgNTMgNzEyIHEgNDQxIDk4NiAyODQgOTg2IHEgNjQzIDkxMiA1NTkgOTg2IHEgNzMyIDcxMyA3MzIgODMzIGwgNjAxIDcxMyBxIDU0NCA4MzAgNTk0IDc4NiBxIDQyNiA4NzUgNDk0IDg3NSBxIDI2OCA3OTMgMzMxIDg3NSBxIDE5MyA1MTcgMTkzIDY5NyBxIDMwMSA1OTcgMjQwIDU3MCBxIDQyNyA2MjQgMzYyIDYyNCBxIDY0MyA1NDAgNTUyIDYyNCBxIDczOSAzMTIgNzM5IDQ1MSBtIDYwMyAyOTggcSA1NDAgNDYxIDYwMyA0MDAgcSA0MDQgNTE2IDQ4NCA1MTYgcSAyNjggNDYxIDMyMyA1MTYgcSAyMDcgMzAwIDIwNyA0MDEgcSAyNjkgMTM3IDIwNyAxOTggcSA0MDUgODMgMzI1IDgzIHEgNTQxIDEzNyA0ODYgODMgcSA2MDMgMjk4IDYwMyAxOTcgXCJ9LFwi77+9XCI6e1wieF9taW5cIjoxLFwieF9tYXhcIjoxMzkuODkwNjI1LFwiaGFcIjoyMzYsXCJvXCI6XCJtIDEzOSA2NzAgbCAxIDY3MCBsIDEgODMwIHEgMzcgOTQzIDEgODk3IHEgMTM5IDEwMTEgNzQgOTkwIGwgMTM5IDk0NyBxIDgyIDkwMCA5NyA5NDAgcSA2OCA4MTAgNjggODYxIGwgMTM5IDgxMCBsIDEzOSA2NzAgXCJ9LFwiP1wiOntcInhfbWluXCI6LTcwLFwieF9tYXhcIjoyODMsXCJoYVwiOjM2MSxcIm9cIjpcIm0gMjgzIDgwMCBsIDE3MyA4MDAgbCAxNzMgOTI1IGwgMjgzIDkyNSBsIDI4MyA4MDAgbSA0MCA4MDAgbCAtNzAgODAwIGwgLTcwIDkyNSBsIDQwIDkyNSBsIDQwIDgwMCBtIDI4MyAzIHEgMjMyIC0xMCAyNTcgLTUgcSAxODEgLTE1IDIwNiAtMTUgcSA4NCAyNiAxMTggLTE1IHEgNDEgMjAwIDQxIDc5IGwgNDEgNzM3IGwgMTY2IDczNyBsIDE2NyAyMTUgcSAxNzEgMTQxIDE2NyAxNTcgcSAyMjUgMTAxIDE4MiAxMDEgcSAyNDcgMTAzIDIzOCAxMDEgcSAyODMgMTEyIDI1NiAxMDQgbCAyODMgMyBcIn0sXCI/XCI6e1wieF9taW5cIjotMC4yMTg3NSxcInhfbWF4XCI6NzczLjIxODc1LFwiaGFcIjo4NTcsXCJvXCI6XCJtIDc3MyAtNyBsIDcwNyAtMTEgcSA1NzUgNDAgNjA3IC0xMSBxIDU1MiAxNzQgNTUyIDc3IGwgNTUyIDIyNiBsIDU1MiA2MjYgbCAyMjIgNjI2IGwgMjIyIDAgbCA5NyAwIGwgOTcgNjI2IGwgMCA2MjYgbCAwIDczNyBsIDc3MyA3MzcgbCA3NzMgNjI2IGwgNjc2IDYyNiBsIDY3NiAxNzEgcSA2OTUgMTAzIDY3NiAxMTcgcSA3NzMgOTAgNzE0IDkwIGwgNzczIC03IFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjc2NS41NjI1LFwiaGFcIjo4MDksXCJvXCI6XCJtIDc2NSAtNCBxIDY5OCAtMTQgNzI2IC0xNCBxIDU2NCA5NyA1ODYgLTE0IHEgNDY2IDcgNTI1IDQwIHEgMzM3IC0yNiA0MDcgLTI2IHEgODggOTggMTg2IC0yNiBxIDAgMzY5IDAgMjEyIHEgODggNjM3IDAgNTI1IHEgMzM3IDc2MCAxODQgNzYwIHEgNDY1IDcyNyA0MDcgNzYwIHEgNTYzIDYzNyA1MjQgNjk1IGwgNTYzIDczOCBsIDY4NSA3MzggbCA2ODUgMjIyIHEgNjkzIDE0MSA2ODUgMTY4IHEgNzQ4IDk0IDcwOCA5NCBxIDc2NSA5NSA3NjAgOTQgbCA3NjUgLTQgbSA1ODQgMzcxIHEgNTMxIDU2MiA1ODQgNDg1IHEgMzYwIDY1MyA0NzAgNjUzIHEgMTkyIDU2NiAyNTQgNjUzIHEgMTM1IDM3OSAxMzUgNDg5IHEgMTg2IDE4MSAxMzUgMjYxIHEgMzU4IDg0IDI0NyA4NCBxIDUyOCAxNzYgNDY1IDg0IHEgNTg0IDM3MSA1ODQgMjYwIG0gNjA0IDEwNDAgbCA0MTUgODE5IGwgMzMyIDgxOSBsIDQ2NiAxMDQwIGwgNjA0IDEwNDAgXCJ9LFwiT1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6OTU4LFwiaGFcIjoxMDU3LFwib1wiOlwibSA0ODUgMTA0MSBxIDgzNCA4ODIgNzAyIDEwNDEgcSA5NTggNTEyIDk1OCA3MzQgcSA4MzQgMTM2IDk1OCAyODcgcSA0ODEgLTI2IDcwMiAtMjYgcSAxMjYgMTMwIDI2MSAtMjYgcSAwIDUwNCAwIDI3OSBxIDEyNyA4ODAgMCA3MjggcSA0ODUgMTA0MSAyNjMgMTA0MSBtIDQ4MCA5OCBxIDczMSAyMjUgNjM4IDk4IHEgODE1IDUwNCA4MTUgMzQwIHEgNzMzIDc4MyA4MTUgNjY5IHEgNDgwIDkxMiA2NDAgOTEyIHEgMjI2IDc4NCAzMjEgOTEyIHEgMTQyIDUwNCAxNDIgNjcwIHEgMjI2IDIyNCAxNDIgMzM5IHEgNDgwIDk4IDMxOSA5OCBcIn0sXCJuXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo2MTUsXCJoYVwiOjcyNCxcIm9cIjpcIm0gNjE1IDQ2MyBsIDYxNSAwIGwgNDkwIDAgbCA0OTAgNDU0IHEgNDUzIDU5MiA0OTAgNTM3IHEgMzMxIDY1NiA0MTAgNjU2IHEgMTc4IDU4NSAyNDAgNjU2IHEgMTE3IDQyMSAxMTcgNTE0IGwgMTE3IDAgbCAwIDAgbCAwIDczOCBsIDExNyA3MzggbCAxMTcgNjMwIHEgMjE4IDcyOCAxNTAgNjkzIHEgMzU5IDc2NCAyODYgNzY0IHEgNTUyIDY3NSA0ODQgNzY0IHEgNjE1IDQ2MyA2MTUgNTkzIFwifSxcIjNcIjp7XCJ4X21pblwiOjU0LFwieF9tYXhcIjo3MzcsXCJoYVwiOjc5MixcIm9cIjpcIm0gNzM3IDI4NCBxIDYzNSA1NSA3MzcgMTQxIHEgMzk5IC0yNSA1NDEgLTI1IHEgMTU2IDUyIDI0OCAtMjUgcSA1NCAzMDggNTQgMTQwIGwgMTg1IDMwOCBxIDI0NSAxNDcgMTg1IDIwMiBxIDM5NSA5NiAzMDIgOTYgcSA1MzkgMTQwIDQ4NCA5NiBxIDYwMiAyODAgNjAyIDE5MCBxIDUxMCA0MjkgNjAyIDM5MCBxIDMyNCA0NTQgNDUxIDQ1NCBsIDMyNCA1NjUgcSA0ODcgNTg0IDQ0MSA1NjUgcSA1NjUgNzE5IDU2NSA2MTcgcSA1MTUgODM1IDU2NSA3OTEgcSAzOTUgODc5IDQ2NiA4NzkgcSAyNTUgODI0IDMwNyA4NzkgcSAyMDMgNjYxIDIwMyA3NjkgbCA3OCA2NjEgcSAxNjYgOTA5IDc4IDgyMiBxIDM4NyA5OTIgMjUwIDk5MiBxIDYwMyA5MjEgNTEzIDk5MiBxIDcwMSA3MjMgNzAxIDg0NCBxIDY2OSA2MDcgNzAxIDY1NiBxIDU3OCA1MjQgNjM3IDU1OCBxIDY5NiA0MzQgNjU1IDQ5OSBxIDczNyAyODQgNzM3IDM2OSBcIn0sXCI5XCI6e1wieF9taW5cIjo1MyxcInhfbWF4XCI6NzM5LFwiaGFcIjo3OTIsXCJvXCI6XCJtIDczOSA1MjQgcSA2MTkgOTQgNzM5IDI0MSBxIDM2MiAtMzIgNTE2IC0zMiBxIDE1MCA0NyAyNDIgLTMyIHEgNTkgMjQ0IDU5IDEyNiBsIDE5MSAyNDQgcSAyNDYgMTI5IDE5MSAxNzYgcSAzNzMgODIgMzAxIDgyIHEgNTI2IDE2MSA0NjYgODIgcSA1OTcgNDQwIDU5NyAyNTUgcSAzNjMgMzM0IDUwMSAzMzQgcSAxMzAgNDMyIDIxNiAzMzQgcSA1MyA2NTAgNTMgNTIxIHEgMTM0IDg4MCA1MyA3ODYgcSAzODMgOTg2IDIyNiA5ODYgcSA2NTkgODQxIDU2NiA5ODYgcSA3MzkgNTI0IDczOSA3MTkgbSAzODggNDQ5IHEgNTM1IDUxNCA0ODAgNDQ5IHEgNTg1IDY1OCA1ODUgNTczIHEgNTM1IDgwNSA1ODUgNzQ0IHEgMzg4IDg3MyA0ODAgODczIHEgMjQyIDgwOSAyOTQgODczIHEgMTkxIDY1OCAxOTEgNzQ1IHEgMjM5IDUxNCAxOTEgNTcyIHEgMzg4IDQ0OSAyOTIgNDQ5IFwifSxcImxcIjp7XCJ4X21pblwiOjQxLFwieF9tYXhcIjoxNjYsXCJoYVwiOjI3OSxcIm9cIjpcIm0gMTY2IDAgbCA0MSAwIGwgNDEgMTAxMyBsIDE2NiAxMDEzIGwgMTY2IDAgXCJ9LFwi77+9XCI6e1wieF9taW5cIjo0MC4wOTM3NSxcInhfbWF4XCI6NzI4Ljc5Njg3NSxcImhhXCI6ODI1LFwib1wiOlwibSA3MjggMzA0IGwgNjQ5IDIyNCBsIDUxMiAzNjMgcSAzODMgMzMxIDQ1OCAzMzEgcSAyNTYgMzYzIDMxMCAzMzEgbCAxMTkgMjI0IGwgNDAgMzA0IGwgMTc3IDQ0MSBxIDE1MCA1NTMgMTUwIDQ5MyBxIDE4NCA2NzMgMTUwIDYyMSBsIDQwIDgxOCBsIDExOSA4OTggbCAyNjcgNzQ5IHEgMzIxIDc2NiAyOTEgNzU5IHEgMzg0IDc3MyAzNTEgNzczIHEgNDQ3IDc2NiA0MTcgNzczIHEgNTAxIDc0OSA0NzcgNzU5IGwgNjQ5IDg5OCBsIDcyOCA4MTggbCA1ODUgNjc1IHEgNjEyIDYxOCA2MDQgNjQ4IHEgNjIxIDU1MyA2MjEgNTg3IHEgNTkxIDQ0MSA2MjEgNDkxIGwgNzI4IDMwNCBtIDM4NCA2ODIgcSAyODAgNjQzIDMxOCA2ODIgcSAyNDMgNTUxIDI0MyA2MDQgcSAyNzkgNDYxIDI0MyA0OTkgcSAzODMgNDIzIDMxNiA0MjMgcSA0ODcgNDYxIDQ0OSA0MjMgcSA1MjUgNTUzIDUyNSA1MDAgcSA0OTAgNjQxIDUyNSA2MDUgcSAzODQgNjgyIDQ1MSA2ODIgXCJ9LFwiP1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NjMyLjMyODEyNSxcImhhXCI6Njc5LFwib1wiOlwibSA2MzIgMCBsIDQ4MiAwIGwgMjI1IDM4NCBsIDEyNCAyODggbCAxMjQgMCBsIDAgMCBsIDAgNzM4IGwgMTI0IDczOCBsIDEyNCA0NDYgbCA0MzMgNzM4IGwgNTk2IDczOCBsIDMxMiA0NjYgbCA2MzIgMCBcIn0sXCI0XCI6e1wieF9taW5cIjo0OCxcInhfbWF4XCI6NzQyLjQ1MzEyNSxcImhhXCI6NzkyLFwib1wiOlwibSA3NDIgMjQzIGwgNjAyIDI0MyBsIDYwMiAwIGwgNDc2IDAgbCA0NzYgMjQzIGwgNDggMjQzIGwgNDggMzY4IGwgNDc2IDk1OCBsIDYwMiA5NTggbCA2MDIgMzU0IGwgNzQyIDM1NCBsIDc0MiAyNDMgbSA0NzYgMzU0IGwgNDc2IDc5MiBsIDE2MiAzNTQgbCA0NzYgMzU0IFwifSxcInBcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjY4NSxcImhhXCI6Nzg2LFwib1wiOlwibSA2ODUgMzY0IHEgNTk4IDk2IDY4NSAyMDUgcSAzNTAgLTIzIDUwNCAtMjMgcSAxMjEgODkgMjA1IC0yMyBsIDEyMSAtMjc4IGwgMCAtMjc4IGwgMCA3MzggbCAxMjEgNzM4IGwgMTIxIDYzMyBxIDIyMCA3MjYgMTU5IDY5MSBxIDM1MSA3NjEgMjgwIDc2MSBxIDU5OCA2MzYgNTA0IDc2MSBxIDY4NSAzNjQgNjg1IDUyMiBtIDU1NyAzNzEgcSA1MDEgNTYwIDU1NyA0ODEgcSAzMzAgNjUxIDQzNyA2NTEgcSAxNjIgNTU5IDIyMyA2NTEgcSAxMDggMzY2IDEwOCA0NzkgcSAxNjIgMTc3IDEwOCAyNTQgcSAzMzMgODcgMjI0IDg3IHEgNTAyIDE3OCA0NDEgODcgcSA1NTcgMzcxIDU1NyAyNTggXCJ9LFwi77+9XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo3NzcsXCJoYVwiOjgzNSxcIm9cIjpcIm0gNDU4IDIzOCBsIDQ1OCAwIGwgMzE5IDAgbCAzMTkgMjM4IGwgMCAyMzggbCAwIDM2MCBsIDMxOSAzNjAgbCAzMTkgNjgxIGwgMCA2ODMgbCAwIDgwNCBsIDMxOSA4MDQgbCAzMTkgMTAxNSBsIDQ1OCAxMDEzIGwgNDU4IDgwNCBsIDc3NyA4MDQgbCA3NzcgNjgzIGwgNDU4IDY4MyBsIDQ1OCAzNjAgbCA3NzcgMzYwIGwgNzc3IDIzOCBsIDQ1OCAyMzggXCJ9LFwiP1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6ODA4LFwiaGFcIjo5MDcsXCJvXCI6XCJtIDQ2NSAtMjc4IGwgMzQxIC0yNzggbCAzNDEgLTE1IHEgODcgMTAyIDE4MCAtMTUgcSAwIDM3OCAwIDIxMCBsIDAgNzM5IGwgMTMzIDczOSBsIDEzMyAzNzkgcSAxODIgMTk1IDEzMyAyNzUgcSAzNDEgOTggMjQyIDk4IGwgMzQxIDkyMiBsIDQ2NSA5MjIgbCA0NjUgOTggcSA2MjMgMTk1IDU2MyA5OCBxIDY3NSAzODIgNjc1IDI3OCBsIDY3NSA3NDIgbCA4MDggNzQyIGwgODA4IDM4MSBxIDcyMCAxMDQgODA4IDIxMyBxIDQ2NiAtMTMgNjI3IC0xMyBsIDQ2NSAtMjc4IFwifSxcIj9cIjp7XCJ4X21pblwiOjAuNzgxMjUsXCJ4X21heFwiOjY5NyxcImhhXCI6ODEwLFwib1wiOlwibSA2OTcgLTI3OCBsIDU3MiAtMjc4IGwgNTcyIDQ1NCBxIDU0MCA1ODcgNTcyIDUzNiBxIDQyNSA2NTAgNTAxIDY1MCBxIDI3MSA1NzkgMzM3IDY1MCBxIDIwNiA0MjAgMjA2IDUwOSBsIDIwNiAwIGwgODEgMCBsIDgxIDQ4OSBxIDczIDU4OCA4MSA1NjIgcSAwIDY0NCA1NiA2NDQgbCAwIDc0MSBxIDY4IDc1NSAzOCA3NTUgcSAxNTggNzIwIDEyNCA3NTUgcSAyMDAgNjMwIDE5MyA2ODYgcSAyOTcgNzI2IDIzNCA2OTIgcSA0MzQgNzYxIDM1OSA3NjEgcSA2MjAgNjkyIDU0NCA3NjEgcSA2OTcgNTE2IDY5NyA2MjQgbCA2OTcgLTI3OCBcIn19LFwiY3NzRm9udFdlaWdodFwiOlwibm9ybWFsXCIsXCJhc2NlbmRlclwiOjExODksXCJ1bmRlcmxpbmVQb3NpdGlvblwiOi0xMDAsXCJjc3NGb250U3R5bGVcIjpcIm5vcm1hbFwiLFwiYm91bmRpbmdCb3hcIjp7XCJ5TWluXCI6LTMzNCxcInhNaW5cIjotMTExLFwieU1heFwiOjExODksXCJ4TWF4XCI6MTY3Mn0sXCJyZXNvbHV0aW9uXCI6MTAwMCxcIm9yaWdpbmFsX2ZvbnRfaW5mb3JtYXRpb25cIjp7XCJwb3N0c2NyaXB0X25hbWVcIjpcIkhlbHZldGlrZXItUmVndWxhclwiLFwidmVyc2lvbl9zdHJpbmdcIjpcIlZlcnNpb24gMS4wMCAyMDA0IGluaXRpYWwgcmVsZWFzZVwiLFwidmVuZG9yX3VybFwiOlwiaHR0cDovL3d3dy5tYWdlbnRhLmdyL1wiLFwiZnVsbF9mb250X25hbWVcIjpcIkhlbHZldGlrZXJcIixcImZvbnRfZmFtaWx5X25hbWVcIjpcIkhlbHZldGlrZXJcIixcImNvcHlyaWdodFwiOlwiQ29weXJpZ2h0IChjKSA/YWdlbnRhIGx0ZCwgMjAwNFwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwidHJhZGVtYXJrXCI6XCJcIixcImRlc2lnbmVyXCI6XCJcIixcImRlc2lnbmVyX3VybFwiOlwiXCIsXCJ1bmlxdWVfZm9udF9pZGVudGlmaWVyXCI6XCI/YWdlbnRhIGx0ZDpIZWx2ZXRpa2VyOjIyLTEwLTEwNFwiLFwibGljZW5zZV91cmxcIjpcImh0dHA6Ly93d3cuZWxsYWsuZ3IvZm9udHMvTWdPcGVuL2xpY2Vuc2UuaHRtbFwiLFwibGljZW5zZV9kZXNjcmlwdGlvblwiOlwiQ29weXJpZ2h0IChjKSAyMDA0IGJ5IE1BR0VOVEEgTHRkLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxcclxcblxcclxcblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhlIGZvbnRzIGFjY29tcGFueWluZyB0aGlzIGxpY2Vuc2UgKFxcXCJGb250c1xcXCIpIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcXFwiRm9udCBTb2Z0d2FyZVxcXCIpLCB0byByZXByb2R1Y2UgYW5kIGRpc3RyaWJ1dGUgdGhlIEZvbnQgU29mdHdhcmUsIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIEZvbnQgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBGb250IFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6IFxcclxcblxcclxcblRoZSBhYm92ZSBjb3B5cmlnaHQgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvZiBvbmUgb3IgbW9yZSBvZiB0aGUgRm9udCBTb2Z0d2FyZSB0eXBlZmFjZXMuXFxyXFxuXFxyXFxuVGhlIEZvbnQgU29mdHdhcmUgbWF5IGJlIG1vZGlmaWVkLCBhbHRlcmVkLCBvciBhZGRlZCB0bywgYW5kIGluIHBhcnRpY3VsYXIgdGhlIGRlc2lnbnMgb2YgZ2x5cGhzIG9yIGNoYXJhY3RlcnMgaW4gdGhlIEZvbnRzIG1heSBiZSBtb2RpZmllZCBhbmQgYWRkaXRpb25hbCBnbHlwaHMgb3IgY2hhcmFjdGVycyBtYXkgYmUgYWRkZWQgdG8gdGhlIEZvbnRzLCBvbmx5IGlmIHRoZSBmb250cyBhcmUgcmVuYW1lZCB0byBuYW1lcyBub3QgY29udGFpbmluZyB0aGUgd29yZCBcXFwiTWdPcGVuXFxcIiwgb3IgaWYgdGhlIG1vZGlmaWNhdGlvbnMgYXJlIGFjY2VwdGVkIGZvciBpbmNsdXNpb24gaW4gdGhlIEZvbnQgU29mdHdhcmUgaXRzZWxmIGJ5IHRoZSBlYWNoIGFwcG9pbnRlZCBBZG1pbmlzdHJhdG9yLlxcclxcblxcclxcblRoaXMgTGljZW5zZSBiZWNvbWVzIG51bGwgYW5kIHZvaWQgdG8gdGhlIGV4dGVudCBhcHBsaWNhYmxlIHRvIEZvbnRzIG9yIEZvbnQgU29mdHdhcmUgdGhhdCBoYXMgYmVlbiBtb2RpZmllZCBhbmQgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIFxcXCJNZ09wZW5cXFwiIG5hbWUuXFxyXFxuXFxyXFxuVGhlIEZvbnQgU29mdHdhcmUgbWF5IGJlIHNvbGQgYXMgcGFydCBvZiBhIGxhcmdlciBzb2Z0d2FyZSBwYWNrYWdlIGJ1dCBubyBjb3B5IG9mIG9uZSBvciBtb3JlIG9mIHRoZSBGb250IFNvZnR3YXJlIHR5cGVmYWNlcyBtYXkgYmUgc29sZCBieSBpdHNlbGYuIFxcclxcblxcclxcblRIRSBGT05UIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBBTlkgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQgT0YgQ09QWVJJR0hULCBQQVRFTlQsIFRSQURFTUFSSywgT1IgT1RIRVIgUklHSFQuIElOIE5PIEVWRU5UIFNIQUxMIE1BR0VOVEEgT1IgUEVSU09OUyBPUiBCT0RJRVMgSU4gQ0hBUkdFIE9GIEFETUlOSVNUUkFUSU9OIEFORCBNQUlOVEVOQU5DRSBPRiBUSEUgRk9OVCBTT0ZUV0FSRSBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIElOQ0xVRElORyBBTlkgR0VORVJBTCwgU1BFQ0lBTCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBUSEUgVVNFIE9SIElOQUJJTElUWSBUTyBVU0UgVEhFIEZPTlQgU09GVFdBUkUgT1IgRlJPTSBPVEhFUiBERUFMSU5HUyBJTiBUSEUgRk9OVCBTT0ZUV0FSRS5cIixcIm1hbnVmYWN0dXJlcl9uYW1lXCI6XCI/YWdlbnRhIGx0ZFwiLFwiZm9udF9zdWJfZmFtaWx5X25hbWVcIjpcIlJlZ3VsYXJcIn0sXCJkZXNjZW5kZXJcIjotMzM0LFwiZmFtaWx5TmFtZVwiOlwiSGVsdmV0aWtlclwiLFwibGluZUhlaWdodFwiOjE1MjIsXCJ1bmRlcmxpbmVUaGlja25lc3NcIjo1MH0pOyJdfQ==
