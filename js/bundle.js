(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],2:[function(require,module,exports){
"use strict";

let GameObject = require("../common/gameobject");
let THREE = require("../../lib/three");
let Point = require("../common/point");
let Tween = require("../common/tween");
let Deferred = require("../../lib/mt-promise");
let TaskList = require("../common/tasklist").TaskList;
let Inventory = require("./inventory");

class Actor extends GameObject {

    /**
     *
     * @param node MapNode
     */
    constructor(node) {

        super();

        this.node = node; // mapnode

        this.node.lock(this);

        this.mesh = this.generate_model();

        this.mesh.userData = this;

        this.task_list = new TaskList();

        // describes items

        this.inventory = new Inventory();

    }



    /**
     *
     * @returns {THREE.Mesh}
     */
    generate_model() {
        let geometry = new THREE.BoxGeometry(1, 1, 1);
        let material = new THREE.MeshLambertMaterial({color: 0xff0000});
        let mesh = new THREE.Mesh(geometry, material);
        mesh.position.x = this.node.point.x;
        mesh.position.y = this.node.point.y;
        mesh.position.z = this.node.point.z;
        return mesh;
    }

}


module.exports = Actor;

},{"../../lib/mt-promise":24,"../../lib/three":25,"../common/gameobject":8,"../common/point":10,"../common/tasklist":11,"../common/tween":12,"./inventory":3}],3:[function(require,module,exports){
"use strict";

class Inventory {


    constructor(capacity) {
        this.capacity = capacity || 10;
        this.__items = [];
    }

    /**
     * Adds the items
     * @param items
     * @returns {boolean} whether it's still possible to carry more
     */
    add(items) {

        items = Array.isArray(items) ? items : [items];

        if(this.__items.length >= this.capacity){

            return false;

        } if (items.length + this.__items.length >= this.capacity) {

            let to_add = items.slice(0, this.capacity - this.__items.length + 1);

            this.__items.push(...to_add);

            return false;

        } else {

            this.__items.push(...items);

            return true;
        }

    }


}

module.exports = Inventory;

},{}],4:[function(require,module,exports){
"use strict";

let TaskList = require("../common/tasklist").TaskList;
let Task = require("../common/tasklist").Task;
let Deferred = require("../../lib/mt-promise");
let MapError = require("../common/errors").MapError;
let PathError = require("../common/errors").PathError;
let Resource = require("../resource/resource");
let ActorTasks = require("./tasks");


/**
 * Helper class for actor movement
 */
class Taskmaster {


    /**
     *
     * @param actor
     * @param target {MapNode}
     * @param map
     */
    static send(actor, target, map) {

        console.log("#Obj:", target.__lock_object);

        if (!target.passable) {

            // can't do anything there, abort

            //noinspection UnnecessaryReturnStatementJS
            return

        } else if (!target.object) {

            // if no object is there, just move the actor

            Taskmaster.move(actor, target, map);

        } else if (target.object instanceof Resource) {

            // if an object is on this field

            Taskmaster.occupy(actor, target, map);

        }

    }


    /**
     *
     * @param actor
     * @param target
     * @param map
     */
    static occupy(actor, target, map) {

        // step 1: find best field to go to

        let surrounding = map.structure.get_surrounding(target.point.x, target.point.y);

        let possible_nodes = surrounding.filter(node => node.passable && !node.locked);

        // abort if target can't be reached

        if(possible_nodes.length === 0){

            console.warn("#Taskmaster: Can't find a way to reach this resource, doing nothing");

            return;

        }

        // sort to find closest

        possible_nodes.sort((a, b) => a.point.distance_to(actor.node.point) - b.point.distance_to(actor.node.point));

        let move_target = possible_nodes[0];


        // create tasks to move actor there

        actor.task_list.clear().then(()=> {

            let nodes = Taskmaster._get_clean_path(actor, move_target, map);

            // create a task for each node-to-node move action required

            let move_tasks = nodes.map(node => {

                return new Task(ActorTasks.move_task, [node], actor);

            });

            actor.task_list.add_tasks(move_tasks);


            // create task for resource gathering

            let gather_task =  new Task(ActorTasks.gather_task, target.object, actor);

            actor.task_list.add_tasks(gather_task);

            // start running the tasklist. if it fails, try again
            // TODO FIXME need some way to limit the re-trys
            // currently, it's only working because a new path can't be calculated so it's aborted the 2nd time

            actor.task_list.start().then(
                () => {
                },
                () => setTimeout(Taskmaster.occupy.bind(null, actor, target, map), 100)
            );

        });

    }


    /**
     *
     * @param actor
     * @param target
     * @param map
     */
    static move(actor, target, map) {

        let tasks,
            nodes;

        actor.task_list.clear().then(()=> {

            nodes = Taskmaster._get_clean_path(actor, target, map);

            // create a task for each node-to-node move action required

            tasks = nodes.map(node => {

                return new Task(ActorTasks.move_task, [node], actor);

            });

            actor.task_list.add_tasks(tasks);

            // start running the tasklist. if it fails, try again
            // TODO FIXME need some way to limit the re-trys
            // currently, it's only working because a new path can't be calculated so it's aborted the 2nd time

            actor.task_list.start().then(
                () => {
                },
                () => setTimeout(Taskmaster.move.bind(null, actor, target, map), 100)
            );
        });


    }

    /**
     *
     * @param actor
     * @param target
     * @param map
     * @returns {*}
     * @private
     */
    static _get_clean_path(actor, target, map) {

        let nodes;

        try {

            // get the path

            nodes = map.get_path(actor.node.point, target.point);

            nodes = Array.from(nodes).slice(1);

            // remove the starting node

            nodes.shift();

        } catch (e) {

            // abort if the target field is already locked or generally unpassable
            // because honestly, this will happen often

            if (e instanceof PathError) {

                console.info("#Taskmaster: Can't find path", e);

                return [];

            } else {

                // something unexpected happened, in that case

                throw e;

            }
        }

        return nodes;
    }




}

module.exports = Taskmaster;

},{"../../lib/mt-promise":24,"../common/errors":7,"../common/tasklist":11,"../resource/resource":22,"./tasks":5}],5:[function(require,module,exports){
"use strict";

let Tween = require("../common/tween");
let MapError = require("../common/errors").MapError;
let Deferred = require("../../lib/mt-promise");

/**
 * This class contains "tasks" for the actor.
 * Tasks are functions that are executed with the context of the actor to perform specific actions.
 */






/**
 * Moves to a neighbouring node
 * @param target MAKE SURE ITS A NEIGHBOUR OR IT'LL LOOK WEIRD
 * @returns promise that resolves when target is reaches and rejects if it's impossible
 */
function move_task(target) {

    let def = new Deferred();

    try {

        target.lock(this);

    } catch (e) {

        // if locking is not possible because something already is there, abort

        if (!(e instanceof MapError)) throw e;

        def.reject();

        return def.promise;

    }

    // get the tweening points

    let points = new Tween(
        this.node.point,

        target.point,

        this.node.point.distance_to(target.point) * 10
    );

    points = Array.from(points);

    // put the move-function into the current hooks
    var update_func = function () {

        let current = points.shift();

        this.mesh.position.x = current.x;

        this.mesh.position.y = current.y;

        this.mesh.position.z = current.z;

        if (points.length === 0) {

            // stop moving

            this.removeEventListener("scene_updated", update_func);

            // unlock the old node and set the current node to the new position

            this.node.unlock();

            this.node = target;

            def.resolve();
        }
    }.bind(this);

    this.addEventListener("scene_updated", update_func);

    return def.promise;
}


/**
 *
 * @param resource
 * @returns {*}
 */
function gather_task(resource, abort){

    let def = new Deferred();


    let finish_gathering = function(){

        this.mesh.rotation.z = 0;

        this.removeEventListener("scene_updated", update_func);

        debugger;

        def.resolve();

    }.bind(this);


    // put the move-function into the current hooks
    var update_func = function () {

        // play animation
        // FIXME you know why

        this.mesh.rotateZ(0.05);

        // get resource

        let res =  resource.work_on();

        if(!res) finish_gathering();

        let has_inventory_space = this.inventory.add(res);

        if(!has_inventory_space) finish_gathering();


    }.bind(this);

    this.addEventListener("scene_updated", update_func);

    return def.promise;

}



module.exports = {
    move_task: move_task,
    gather_task: gather_task
};

},{"../../lib/mt-promise":24,"../common/errors":7,"../common/tween":12}],6:[function(require,module,exports){
"use strict";

var THREE = require("../lib/three");
var GameObject = require("./common/gameobject");
/**
 * This class is responsible for the renderer, scene etc.
 * It basically handles all the animation-related stuff
 *
 * TODO: Handle window resize here
 */
class Animation {

    /**
     * Creates new Animation-Object and sets up the surrounding (everything but the bodies themselves)
     */
    constructor() {

        THREE.EventDispatcher.prototype.apply(this);
        this.canvas = document.getElementById("main_canvas");


        this.context = this.canvas.getContext("webgl");

        this.renderer = new THREE.WebGLRenderer({
            canvas: this.canvas,
            context: this.context,
            antialias: true
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);

        this.scene = new THREE.Scene();


        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.camera.position.x = 50;
        this.camera.position.y = 25;
        this.camera.position.z = 50;
        this.camera.rotation.x = 0.3;


        var directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(0, 6, 12);
        this.scene.add(directionalLight);

        this.actors = [];

    }


    /**
     * Loads the map
     * @param map
     */
    load_map(map) {
        this.scene.add(map.mesh);
        map.resources.forEach(res => this.scene.add(res.mesh));
    }

    /**
     * Adds an element to the scene
     *
     * @param obj
     */
    add_element(obj) {
        if (!(obj instanceof GameObject)) throw new TypeError("#Animation: Can only add gameobjects to the scene");
        this.actors.push(obj);
        this.scene.add(obj.mesh);
    }


    /**
     * Starts the animation
     */
    start() {
        // recursive call
        requestAnimationFrame(this.start.bind(this));
        // this way we can hook tweens and stuff like that on each frame
        this.actors.forEach(x => x.dispatchEvent({type: "scene_updated"}));
        this.dispatchEvent({type: "scene_updated"});
        this.renderer.render(this.scene, this.camera);
    }


}

module.exports = Animation;

},{"../lib/three":25,"./common/gameobject":8}],7:[function(require,module,exports){
"use strict";

class MapError extends Error{

    constructor(...args){
        super(args)
    }

}

class PathError extends Error{

    constructor(...args){
        super(args)
    }

}


module.exports = {
    MapError: MapError,
    PathError: PathError
};

},{}],8:[function(require,module,exports){
"use strict";

var THREE = require("../../lib/three");

// just for fun; need a git-hook or something that throws errors if it sees "getownpropertysymbols"
var meshSymbol = Symbol();

/**
 * Parent class for all Gameobjects which guarantees availability of common gameobject-properties like meshes
 */
class GameObject {

    /**
     * we __NEED__ to call this in all subclasses!
     */
    constructor(){
        THREE.EventDispatcher.prototype.apply(this);

    }

    /**
     * Overwrite!
     */
    progress(){

    }

    /**
     * returns the mesh if asked for it
     * @returns {*}
     */
    get mesh(){
        if (this[meshSymbol]) return this[meshSymbol];
        else{
            let geometry = new THREE.BoxGeometry(1, 1, 1);
            let material = new THREE.MeshLambertMaterial({color: 0xffffff});
            return new THREE.Mesh(geometry, material);
        }
    }

    /**
     * make sure we can not overwrite the mesh
     * @param mesh
     */
    set mesh(mesh){
        if (this[meshSymbol]) throw new ReferenceError("Can't overwrite existing meshes!");
        this[meshSymbol] = mesh;
    }

}

module.exports = GameObject;

},{"../../lib/three":25}],9:[function(require,module,exports){
"use strict";

var listSymbol = Symbol();

/**
 * A simple 2d-list class
 *
 * TODO: maybe invert rows/cols in the data structure because we have to query rows more often
 * and it's currently more expensive
 */
class List2D {

    /**
     * initializes an empty 2d list with null-values
     * @param width: first value, akin to X in a screen coordinate system
     * @param length: second value, akin to Y in a screen coordinate system
     */
    constructor(width, length) {

        this.width = this.columns = width || 1;

        this.length = this.rows = length || this.width;

        let col_array = new Array(this.length);

        col_array.fill(null);

        this[listSymbol] = [];

        for (let i = 0; i < this.width; i++) {

            this[listSymbol][i] = col_array.slice(0);

        }

    }


    /**
     *
     * @param x
     * @param y
     * @returns {*}
     */
    get(x, y) {

        return this[listSymbol][x][y];

    }

    /**
     * returns all surrounding points of a point x:y
     * @param x
     * @param y
     */
    get_surrounding(x, y) {

        let list = [];

        for (let xi = x - 1; xi <= x + 1; xi++) {

            for (let yi = y - 1; yi <= y + 1; yi++) {

                if (xi === x && yi === y) continue;

                if (xi < 0 || xi >= this.width || yi < 0 || yi >= this.length) continue;

                let elem = this.get(xi, yi);

                if (!elem) debugger;

                list.push(elem);

            }

        }

        return list;

    }

    /**
     *
     * @returns {MapNode}
     */
    get_random() {

        let x = Math.floor(Math.random() * this.columns),
            y = Math.floor(Math.random() * this.rows);

        return this.get(x, y);

    }


    /**
     *
     * @param x
     * @param y
     * @param value
     * @returns {*}
     */
    set(x, y, value) {

        return this[listSymbol][x][y] = value;

    }

    /**
     * foreach goes from top-left to bottom-right
     * @param callback
     */
    for_each(callback) {

        for (let i = 0; i < this.rows; i++) {

            this.get_row(i).forEach((elem, j) => callback(elem, j, i));

        }

    }


    get_row(index) {

        return this[listSymbol].map(sublist => sublist[index]);

    }

    get_col(index) {

        return this[listSymbol][index].slice(0);

    }


    /**
     * prints the list from top-left to bottom-right;
     */
    print() {

        let output = "";

        let current_row = 0;

        this.for_each(function (elem, x, y) {

            if (y > current_row) output += "\n";

            output += " | " + String(elem) + " | ";

            current_row = y;

        });

        console.log(output);

    }


}

module.exports = List2D;

},{}],10:[function(require,module,exports){
"use strict";

var THREE = require("../../lib/three");

class Point {

    constructor(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z || 0;
    }

    static from(vec){
        return new Point(vec.x, vec.y, vec.z);
    }

    to_vector(){
        return new THREE.Vector3(this.x, this.y, this.z);
    }

    /**
     * Calculates the distance between two points
     * @param other
     * @param include_z
     * @returns {number}
     */
    distance_to(other, include_z){

        include_z = include_z || false;
        if(include_z) throw new ReferenceError("#Point: Distance based on Z not implemented!");

        return Math.sqrt(Math.pow(other.x - this.x, 2) + Math.pow(other.y - this.y, 2));

    };

    equals(other){
        return this.x === other.x && this.y === other.y;
    }

    /**
     * Pretty prints
     * @returns {*}
     */
    toString(){
        return `(${this.x}:${this.y}:${this.z})`;
    }

}

module.exports = Point;

},{"../../lib/three":25}],11:[function(require,module,exports){
(function (process){
"use strict";

let Deferred = require("../../lib/mt-promise");


/**
 * A Task is a wrapper around functions that allows someone to store a function and run it later.
 * The call to .run() will ALWAYS return a promise.
 * Arguments for the function will be accessible via arguments[0].arguments and additional information
 * supplied by run(arg1, arg2) will be available via arguments[0].additional.
 */
class Task {


    /**
     *
     * Creates a task based on the given function, args, and context
     *
     * @param func
     * @param args
     * @param context
     */
    constructor(func, args, context) {

        this.func = !!context ? func.bind(context) : func;

        this.args = Array.isArray(args) ? args : [args];

    }


    /**
     *
     * Run a given task with all provided arguments appended on the original
     * arguments list that is given to the function
     * @param add_args
     * @returns {*}
     */
    run(...add_args) {

        add_args = add_args || [];

        // call the function with the supplied arguments and bonus arguments

        let promise = this.func(...this.args, ...add_args);


        // make sure to always return a promise for consistency
        if (promise instanceof Deferred.Promise) {

            return promise;

        } else {

            let d = new Deferred();

            d.resolve(promise);

            return d.promise;

        }
    }

}


class TaskList {

    /**
     * Quasi-static variable holding the possible states of the task-list
     *
     * @returns {{RUNNING: number, PAUSING: number, STOPPED: number}}
     * @constructor
     */
    static get STATES() {
        return {
            RUNNING: 1,
            PAUSING: 2,
            STOPPED: 3
        }
    }


    /**
     * Creates a new tasklist with the given array of tasks or an empty one
     * @param tasks <optional> array of tasks
     */
    constructor(tasks) {

        this.tasks = Array.isArray(tasks) ? tasks : [];

        this.state = TaskList.STATES.STOPPED;

        this.deferred = null;

    }

    /**
     * @returns {Task|null} the currently active task
     */
    get current_task() {

        return this.tasks.length > 0 ? this.tasks[0] : null;

    }


    /**
     * Adds another task to the tasklist
     * @param tasks
     */
    add_tasks(tasks) {

        tasks = Array.isArray(tasks) ? tasks : [tasks];

        tasks.forEach(task => this.tasks.push(task));

    }


    /**
     * Is guaranteed to be async/next tick
     * Returns a promise that behaves as following:
     *
     * resolves with value: When the tasklist has been completely empties, resolves with the value of the last promise
     * resolves with TaskList.STATES.PAUSING: Indicates that the tasklist has been paused
     * rejects: When a task has failed
     * updates: on every task completion, independent whether it was successful
     *
     *
     * @returns {*}
     */
    start(...additions) {

        // if the thing is already running, return the current promise and warn
        if (this.state === TaskList.STATES.RUNNING) {

            return this.deferred.promise;

        }

        additions = additions || [];

        this.state = TaskList.STATES.RUNNING;

        this.deferred = new Deferred();


        /**
         *
         * @type {function(this:TaskList)}
         */
        let on_next_task = function (...args) {

            this.deferred.update(...args);

            // resolve with pause notice

            if (this.state === TaskList.STATES.PAUSING) {

                this.state = TaskList.STATES.STOPPED;

                let buffer_deferred = this.deferred;

                this.deferred = null;

                buffer_deferred.resolve(TaskList.STATES.PAUSING);

                return;

            }

            // resolve with last value

            if (!this.current_task) {

                this.state = TaskList.STATES.STOPPED;

                let buffer_deferred = this.deferred;

                this.deferred = null;

                buffer_deferred.resolve(...args);

                return;

            }

            // if no abort conditions are met, continue

            this._run_next(...args).then(on_next_task, on_task_failure);

        }.bind(this);

        /**
         *
         * @type {function(this:TaskList)}
         */
        let on_task_failure = function (...args) {

            this.deferred.update(...args);

            this.state = TaskList.STATES.STOPPED;

            let buffer_deferred = this.deferred;

            this.deferred = null;

            buffer_deferred.reject(...args);

        }.bind(this);


        // need to enforce async here because empty task lists would resolve immediately otherwise

        //noinspection JSUnresolvedVariable
        process.nextTick(() => this._run_next(...additions).then(on_next_task, on_task_failure));

        return this.deferred.promise;

    }


    /**
     *
     * @param additions
     * @returns {Deferred.promise}
     * @private
     */
    _run_next(...additions) {

        let def = new Deferred();

        additions = additions || [];

        // fix error when empty tasklist gets started

        if (this.tasks.length === 0) {

            def.resolve();

            return def.promise;

        }


        let p = this.tasks[0].run(...additions);

        p.then((...args) => {

            this.tasks.shift();

            def.resolve(...args);

        }, (...args) => {

            this.tasks.shift();

            def.reject(...args);

        });

        return def.promise;
    }


    /**
     * Removes all tasks and returns a promise that resolves once the task has been aborted
     * @returns {Promise} promise that is guaranteed to resolve async
     */
    clear() {

        this.tasks.length = 0;

        if (this.deferred) return this.deferred.promise;

        let d = new Deferred();

        //noinspection JSUnresolvedVariable
        process.nextTick(() => d.resolve());

        return d.promise;

    }


}


module.exports = {
    TaskList: TaskList,
    Task: Task
};

}).call(this,require('_process'))

},{"../../lib/mt-promise":24,"_process":1}],12:[function(require,module,exports){
"use strict";


/**
 * Usage:
 *
 * let a = new Tween({x: 0}, {x: 10}, 4);
 * for(var i of a){
 *   console.log(i);
 * }
 *
 */
class Tween {

    constructor(from, to, steps) {

        let keys = Object.keys(from);

        let current_step = 0;
        let current_val = {};
        let step_size = {};

        keys.forEach(function (key) {
            current_val[key] = from[key];
            step_size[key] = (to[key] - from[key]) / steps;
        });


        this[Symbol.iterator] = function* () {

            while (current_step < steps) {
                current_step++;
                keys.forEach(key => current_val[key] += step_size[key]);

                // clone and return object
                let clone = {};
                keys.forEach(key=> clone[key] = current_val[key]);

                yield clone;
            }
        }


    }

}


module.exports = Tween;

},{}],13:[function(require,module,exports){
"use strict";

var THREE = require("../../lib/three");

class InputHandler {

    constructor(camera, scene){

        THREE.EventDispatcher.call(this);

        this.camera = camera;
        this.scene = scene;

        window.onkeydown = this.handle_keydown.bind(this);
        window.onmousewheel = this.handle_mousewheel.bind(this);
    }




    handle_mousewheel(evt){
        this.camera.position.z += evt.wheelDelta > 0 ? -1 : 1;
    }

    handle_keydown(evt){
        let keybinds = {
            D: [1, 0],
            S: [0, -1],
            A:  [-1, 0],
            W: [0, 1]
        };

        let key = evt.code.substring(3);

        if(!keybinds[key]){
            return;
        }

        let delta = keybinds[key];

        this.camera.position.x += delta[0] * 4;
        this.camera.position.y += delta[1] * 4;

    }





}

module.exports = InputHandler;

},{"../../lib/three":25}],14:[function(require,module,exports){
"use strict";

let InputHandler = require("./inputhandler");
let THREE = require("../../lib/three");
let Map = require("../map/map");
let MapNode = require("../map/mapnode");
let Actor = require("../actor/actor");
let Taskmaster = require("../actor/taskmaster");
let GameObject = require("../common/gameobject");
let Path = require("../map/path");
let MouseHandler = require("./mousehandler");
let Point = require("../common/point");

/**
 *
 */
class MainController {

    constructor(animation, map, actors) {

        this.animation = animation;

        this.map = map;

        this.actors = actors;

        this.selection = [];

        this.input_handler = new InputHandler(animation.camera, animation.scene);

        this.mouse_handler = new MouseHandler(animation, map, actors);

        this.mouse_handler.on("click", this.handle_click.bind(this));

        this.mouse_handler.on("selection", this.handle_select.bind(this));

        this.mouse_handler.on("rightclick", this.handle_rightclick.bind(this));


    }

    /**
     *
     * @param clicked Object{object, face, point, ...)
     */
    handle_click(clicked) {

        console.log("#MC: click", clicked);

        let obj = clicked.object;

        if (obj.userData instanceof Actor) this.selection = [obj.userData];

        else this.selection.length = 0;

    }

    /**
     *
     * @param selections Array<Actor>
     */
    handle_select(selections) {

        console.log("#MC: select", selections);

        this.selection.length = 0;

        this.selection.push.apply(this.selection, selections);

    }


    /**
     * Returns the map-node closest for a given click-event
     *
     * @param clicked
     * @returns {*}
     */
    get_closest_node(clicked){

        let point = Point.from(clicked.point);

        // determine the vertices (and thereby the possible positions) based on the clicked face

        let all_vertices = clicked.object.geometry.vertices;

        let vertices = [
            all_vertices[clicked.face.a],
            all_vertices[clicked.face.b],
            all_vertices[clicked.face.c]
        ];

        // find out which point is the closest via Point.distance_to

        let distances = vertices.map(p =>  point.distance_to(Point.from(p)) );

        let smallest_dist = Math.min.apply(Math, distances);

        // get the closest vertice

        let closest_point = vertices[distances.indexOf(smallest_dist)];

        return this.map.structure.get(closest_point.x, closest_point.y);

    }

    /**
     * If actors are selected, will send them to the target field
     *
     * @param clicked Object{object, face, point, ...)
     */
    handle_rightclick(clicked) {

        // rightclick only does stuff when we have something selected

        if(this.selection.length === 0) return;

        clicked = clicked.filter(evt => evt.object.userData instanceof Map)[0];

        // get the target node

        let target = this.get_closest_node(clicked);

        // move each actor somewhere

        this.selection.forEach( actor => Taskmaster.send(actor, target, this.map) );

    }


}

module.exports = MainController;

},{"../../lib/three":25,"../actor/actor":2,"../actor/taskmaster":4,"../common/gameobject":8,"../common/point":10,"../map/map":17,"../map/mapnode":18,"../map/path":20,"./inputhandler":13,"./mousehandler":15}],15:[function(require,module,exports){
"use strict";

let THREE = require("../../lib/three");
let Evented = require("../../lib/mt-event");


class MouseHandler {


    /**
     *
     * @param animation
     * @param map
     * @param actors
     */
    constructor(animation, map, actors) {

        Evented.makeEvented(this);

        this.click_delay = 0.15 * 1000;

        this.animation = animation;
        this.map = map;
        this.actors = actors;

        this.mousedown = false;
        this.mousedown_evt = null;
        this.mousedown_obj_buffer = null;
        this.mousedown_time = null;


        // special three js mesh that we use to display selection
        this.selection_model = this.load_selection_model();
        this.animation.scene.add(this.selection_model);

        this.load_hooks();

    }

    /**
     *
     */
    load_hooks() {

        window.onmousedown = this.onmousedown.bind(this);
        window.onmouseup = this.onmouseup.bind(this);
        window.oncontextmenu = this.oncontextmenu.bind(this);
        window.onmousemove = this.onmousemove.bind(this);

    }


    /**
     *
     * @param evt
     */
    onmousedown(evt) {
        // in the case of rightclicks:
        if (evt.button !== 0) return;

        this.mousedown = true;
        this.mousedown_evt = evt;
        this.mousedown_time = Date.now();
    }

    /**
     *
     * @param evt
     */
    onmousemove(evt) {

        if (!this.mousedown || this.mousedown_time + this.click_delay > Date.now()) return;

        let geometry = this.selection_model.geometry;

        // if this is the first move-action, buffer the original move coordinates to draw the selection rectangle
        if (!this.mousedown_obj_buffer) this.mousedown_obj_buffer = this._get_object(this.mousedown_evt)[0];


        let p1 = this.mousedown_obj_buffer.point;
        let p4 = this._get_object(evt)[0].point;
        var p2, p3;

        // need to switch vertices in top-right and bottom-left quadrants
        // so we can make sure that faces always face upwards

        // if in top-left or bottom-right quadrant:
        if ((p4.x > p1.x && p4.y < p1.y) || (p4.x < p1.x && p4.y > p1.y)) {
            p2 = p1.clone();
            p2.x = p4.x;
            p3 = p1.clone();
            p3.y = p4.y;
        } else {
            p3 = p1.clone();
            p3.x = p4.x;
            p2 = p1.clone();
            p2.y = p4.y;
        }

        [p1, p2, p3, p4].forEach((p, i) => {
            geometry.vertices[i].x = p.x;
            geometry.vertices[i].y = p.y;
            geometry.vertices[i].z = 5;
        });

        geometry.verticesNeedUpdate = true;

        this.selection_model.visible = true;


    }


    /**
     *
     * @param evt
     */
    onmouseup(evt) {

        // in the case of rightclicks:
        if (evt.button !== 0) return;

        if (this.mousedown_time + this.click_delay > Date.now()) {
            this.emit("click", this._get_object(evt)[0]);
        } else {
            this._calculate_selection();
        }

        // cleanup the mess
        this.mousedown = false;
        this.mousedown_evt = null;
        this.mousedown_time = null;
        this.mousedown_obj_buffer = null;
        this.selection_model.visible = false;

    }


    /**
     *
     * @param evt
     * @returns {boolean}
     */
    oncontextmenu(evt) {
        this.emit("rightclick", this._get_object(evt));
        return false;
    }


    /**
     *
     * @param evt
     * @returns {*}
     * @private
     */
    _get_object(evt) {
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();

        mouse.x = ( evt.clientX / this.animation.renderer.domElement.width ) * 2 - 1;
        mouse.y = -( evt.clientY / this.animation.renderer.domElement.height ) * 2 + 1;
        raycaster.setFromCamera(mouse, this.animation.camera);

        return raycaster.intersectObjects(this.animation.scene.children);
    }


    /**
     * Calculates all gameobjects inside of the current selection
     * @private
     */
    _calculate_selection() {

        this.selection_model.geometry.vertices.forEach(v => v.z = 0);

        let bounding_box_height = 100; // FIXME: should be safe
        let bbox = new THREE.Box3().setFromObject(this.selection_model);

        // calculate all intersecting actors
        let hits = this.actors.filter(x => {

            let b = new THREE.Box3().setFromObject(x.mesh);

            // change the actors bounding boxes to go pretty high in the Z-axis
            // so the selection model will definitely intersect it
            b.expandByVector(new THREE.Vector3(0, 0, bounding_box_height));

            return bbox.isIntersectionBox(b);
        });

        this.emit("selection", hits);

    }


    /**
     *
     * @returns {THREE.Mesh}
     */
    load_selection_model() {

        let geometry = new THREE.Geometry();
        geometry.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0));
        geometry.faces.push(new THREE.Face3(0, 2, 1), new THREE.Face3(2, 3, 1));


        let material = new THREE.MeshLambertMaterial({color: 0xff0000});
        material.transparent = true;
        material.opacity = 0.5;

        let mesh = new THREE.Mesh(geometry, material);
        mesh.visible = false;

        return mesh;
    }
}

module.exports = MouseHandler;

},{"../../lib/mt-event":23,"../../lib/three":25}],16:[function(require,module,exports){
"use strict";

let Animation = require("./animation");
let Map = require("./map/map");
let MainController = require("./controllers/maincontroller");
let Actor = require("./actor/actor");
let Resource = require("./resource/resource");




let animation = new Animation();

let map = new Map();

//let resource = new Resource();
//map.add_resource(resource);





animation.load_map(map);



let actors = [new Actor(map.structure.get(20, 20)), new Actor(map.structure.get(30, 20))];
animation.add_element(actors[0]);
animation.add_element(actors[1]);



let c = new MainController(animation, map, actors);
animation.start();




console.log("loaded");

},{"./actor/actor":2,"./animation":6,"./controllers/maincontroller":14,"./map/map":17,"./resource/resource":22}],17:[function(require,module,exports){
"use strict";

let GameObject = require("../common/gameobject");
let THREE = require("../../lib/three");
let List2D = require("../common/list2d");
let Point = require("../common/point");
let StructureBuilder = require("./structurebuilder");
let MapError = require("../common/errors").MapError;
let Model = require("./model");
let Path = require("./path");


let default_properties = {
    size_x: 100,
    size_y: 100,
    structure: null,
    groundwater: -0.8,
    mountain: 1,
    highlight_chance: 300 // 1000 means 1 in 1000
};

class Map extends GameObject {

    /**
     *
     * @param properties: Map with keys: size_x, size_y
     */
    constructor(properties) {

        super();

        this.properties = properties || default_properties;

        // structure is a List2D filled with MapNodes

        this.structure = StructureBuilder.create_random(this.properties);

        this.mesh = Model.generate_model(this.properties, this.structure);

        this.mesh.userData = this;


        // generate the resources

        this.resources = StructureBuilder.calculate_resources(this.structure);

        // place the resources on the nodes
        // FIXME Make sure that two resources can't overlap!

        this.resources.forEach(resource => {

            resource.fields.forEach(field =>{

                let node = this.structure.get(field.x, field.y);

                node.lock(resource);

            })

        })


    }


    /**
     * Adds a resource to this map
     * @param resource
     */
    add_resource(resource){
        this.resources.push(resource);
    }


    /**
     * Determines the best possible path between two points
     * @param from
     * @param to
     * @returns {Path|exports|module.exports}
     */
    get_path(from, to){

        if(!from.x || !from.y || !to.x || !to.y) throw new TypeError("#Map: Need to pass two points with x/y val!");

        return new Path(from, to, this.structure);
    };


}

module.exports = Map;

},{"../../lib/three":25,"../common/errors":7,"../common/gameobject":8,"../common/list2d":9,"../common/point":10,"./model":19,"./path":20,"./structurebuilder":21}],18:[function(require,module,exports){
"use strict";

let MapError = require("../common/errors").MapError;

class MapNode {

    constructor(point, passable) {
        this.point = point;
        this.passable = passable || false;

        this.__lock_object = null;
    }

    lock(lock_obj) {
        if (!!this.__lock_object) throw new MapError("#Mapnode: Node is already locked!");
        this.__lock_object = lock_obj;
    }

    unlock() {
        this.__lock_object = null;
    }

    get locked() {
        return !!this.__lock_object;
    }

    get object(){
        return this.__lock_object;
    }

    toString() {
        return `(${this.point.x}:${this.point.y}) ${this.point.z.toString().substring(0, 3)} ${this.passable ? "o" : "x"}`;
    }

}

module.exports = MapNode;

},{"../common/errors":7}],19:[function(require,module,exports){
"use strict";

var THREE = require("../../lib/three");

class Model {


    /**
     * Creates the rather complex map-mesh including textures
     *
     * @returns {THREE.Mesh}
     * @private
     */
    static generate_model(properties, structure) {


        let geometry = new THREE.Geometry();

        let width = structure.width;
        let length = structure.length;

        // determine which faces are water and mountains
        let water = properties.groundwater;
        let mountain = properties.mountain;


        let material = new THREE.MeshLambertMaterial({vertexColors: THREE.VertexColors});


        // 0: water, 1: earth, 2: mountaintop
        let vertice_colors = [
            new THREE.Color(0x229CE4),
            new THREE.Color(0x006400),
            new THREE.Color(0xf4a460)
        ];




        // create vertices based on the structure
        structure.for_each(function (node, x, y) {
            // add the vertices for each point
            let vert = new THREE.Vector3(node.point.x, node.point.y, node.point.z);
            geometry.vertices.push(vert);
        });


        // create 2 faces for each point, excluding the points at the corners
        structure.for_each(function (node, x, y) {

            // no faces if we are at the right or bottom/top(?) border
            if (x === width - 1 || y === length - 1) return;


            // calculate the index of the corresponding vertices/vertix/vertixes??
            let face1_coords = {
                a: x + y * width,
                b: x + 1 + y * width,
                c: x + (y + 1) * width
            };

            // determine the vertice colors by cross-checking their values with the threshholds
            let face1_colors = ["a", "b", "c"].map(mat_coord => {
                let vert = geometry.vertices[face1_coords[mat_coord]];
                let i = vert.z <= water ? 0 : vert.z >= mountain ? 2: 1;
                return vertice_colors[i];
            });

            let face1 = new THREE.Face3(
                face1_coords.a,
                face1_coords.b,
                face1_coords.c,
                null,
                face1_colors
            );

            //++++++++++++++

            // calculate the index of the corresponding vertices/vertix/vertixes??
            let face2_coords = {
                a: x + (y + 1) * width,
                b: x + 1 + y * width,
                c: x + 1 + (y + 1) * width
            };

            // determine the vertice colors by cross-checking their values with the threshholds
            let face2_colors = ["a", "b", "c"].map(mat_coord => {
                let vert = geometry.vertices[face2_coords[mat_coord]];
                let i = vert.z <= water ? 0 : vert.z >= mountain ? 2: 1;
                return vertice_colors[i];
            });


            let face2 = new THREE.Face3(
                face2_coords.a,
                face2_coords.b,
                face2_coords.c,
                null,
                face2_colors
            );

            geometry.faces.push(face1, face2);


        });


        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        geometry.computeBoundingSphere();
        //geometry.colorsNeedUpdate = true;

        return new THREE.Mesh(geometry, material);
    }

}

module.exports = Model;

},{"../../lib/three":25}],20:[function(require,module,exports){
"use strict";

let PathError = require("../common/errors").PathError;


/**
 * Helper class to encapsulate the distance/heuristics values
 */
class PathNode {

    constructor(node, distance, heuristics, parent) {
        this.node = node;
        this.d = distance;
        this.h = heuristics;
        this.parent = parent;
    }
}


/**
 * Creates a path between two points based on a given structure
 */
class Path {

    /**
     * Creates a path between two points and makes the path-instance an iterable
     *
     * @param from
     * @param to
     * @param structure
     */
    constructor(from, to, structure) {

        // sanitize input
        from = structure.get(from.x, from.y);
        to = structure.get(to.x, to.y);


        // throw error if impossible
        if(!from.passable || !to.passable || to.locked){
            throw new PathError("#Path: Can't determine a path because either origin or target isn't passable");
        }

        let current,
            surrounding = [],
            candidates = [],
            path = [],
            known = [];


        // before the first iteration, we'll set the current point to the start node
        current = new PathNode(from, 0, from.point.distance_to(to.point), null);

        while (!current.node.point.equals(to.point)) {

            // determine surrounding nodes
            surrounding = structure.get_surrounding(current.node.point.x, current.node.point.y);

            // filter alread known ones
            surrounding = surrounding.filter(elem => known.indexOf(elem) === -1);
            // add the new ones to the known-list
            known = known.concat(surrounding);
            // filter blocked ones
            surrounding = surrounding.filter(elem => elem.passable && !elem.locked);

            // determine distances and turn them into PathNodes
            // concat with previous candidates to we'll more easily be able to switch paths if needed
            candidates = candidates.concat(
                surrounding.map(elem => new PathNode(
                    elem,
                    current.d + current.node.point.distance_to(elem.point),
                    elem.point.distance_to(to.point),
                    current
                ))
            );

            // sort list so the lowest index has the best expected value
            candidates.sort((a, b) => (a.d + a.h) - (b.d + b.h));

            current = candidates.shift();

            if(!current) throw new PathError("#Path: Can't find a path to the target!");
        }


        // go back to collect the chosen nodes
        while(current !== null){
            path.unshift(current.node);
            current = current.parent;
        }


        // make it iterable
        this[Symbol.iterator] = function* () {
            while (path.length > 0){
                yield path.shift();
            }
        }


    }


}


module.exports = Path;

},{"../common/errors":7}],21:[function(require,module,exports){
"use strict";

let List2D = require("../common/list2d");
let MapNode = require("./mapnode");
let Point = require("../common/point");
let Resource = require("../resource/resource");

/**
 * Helper class for map structures
 */
class StructureBuilder {

    /**
     * Create random structure
     * @param properties
     * @returns {List2D|exports|module.exports}
     */
    static create_random(properties) {

        let l2d = StructureBuilder.get_basic_structure(properties);

        StructureBuilder.refine(l2d, 20);

        StructureBuilder.block_areas(l2d, properties);

        return l2d;
    }

    /**
     *
     * @param properties
     * @returns {List2D|exports|module.exports}
     */
    static get_basic_structure(properties) {

        let l2d = new List2D(properties.size_x, properties.size_y);

        // fill each point with a random height
        l2d.for_each(function (elem, x, y) {

            let height = Math.random() * 10 - 5;

            // chance for highlight:

            if (Math.random() * properties.highlight_chance < 1) height *= 10;

            let point = new Point(x, y, height);

            let node = new MapNode(point, true);

            l2d.set(x, y, node);

        });

        return l2d;
    }


    /**
     *
     * @param l2d
     * @param clean_runs
     */
    static refine(l2d, clean_runs) {

        clean_runs = clean_runs || 5;

        // smooth the heights to get a natural looking map

        for (let i = 0; i < clean_runs; i++) {

            // harmonize each node with the surrounding nodes

            l2d.for_each(function (elem, x, y) {

                let surrounding = l2d.get_surrounding(x, y);

                let avg = surrounding.reduce((val, elem) => val + elem.point.z, 0) / surrounding.length;

                // change the.point.z to be 20% closer to the average

                elem.point.z = ( elem.point.z * 4 + avg ) / 5

            });

        }

        return l2d;

    }


    /**
     *
     * @param l2d
     */
    static block_areas(l2d, properties) {

        // block water/mountain fields

        l2d.for_each(function (elem) {

            if (elem.point.z <= properties.groundwater ||
                elem.point.z >= properties.mountain)

                elem.passable = false;

        });

    }


    /**
     *
     * @param l2d
     */
    static calculate_resources(l2d, amount) {

        amount = amount || 1;

        let resources = [];

        for (let i = 0; i < amount; i++) {

            // generate a spot of random, free resources

            let random = l2d.get_random();

            while (!random.passable) random = l2d.get_random();

            let spot = l2d.get_surrounding(random.point.x, random.point.y);

            spot = spot.filter(node => node.passable);

            spot.push(random);

            // calculate the positions of the resource

            let coords = spot.map(node => {
                return {
                    x: node.point.x,
                    y: node.point.y
                }
            });

            let res = new Resource({
                res: Resource.RES.WOOD,
                amount: 10,
                fields: coords
            });

            resources.push(res);
        }

        return resources;

    }

}


module.exports = StructureBuilder;

},{"../common/list2d":9,"../common/point":10,"../resource/resource":22,"./mapnode":18}],22:[function(require,module,exports){
"use strict";

let GameObject = require("../common/gameobject");
let THREE = require("../../lib/three");


let default_properties = {
    res: "WOOD",
    amount: 10,
    fields: [
        {x: 20, y: 40},
        {x: 20, y: 41},
        {x: 21, y: 40},
        {x: 21, y: 41}
    ]
};


class Resource extends GameObject {

    constructor(properties) {

        super();

        properties = properties || default_properties;

        this.type = Resource.RES[properties.res];

        this.amount = properties.amount;

        this.fields = properties.fields;

        this.mesh = this.generate_mesh();

    }

    static get RES(){

        return {
            "WOOD": "WOOD",
            "STONE": "STONE"
        }

    }


    generate_mesh() {

        // generate the geometry
        let geometry = this.fields.map(field => {

            // create a geometry object for each field this resource is on
            let geo = new THREE.BoxGeometry(0.25, 0.25, 5);
            geo.vertices.forEach(vert => {
                vert.x += field.x;
                vert.y += field.y;
            });
            return geo;

            // merge all those geometries into one
        }).reduce((prev, curr) => {
            if (prev) curr.merge(prev);
            return curr;
        });

        let material = new THREE.MeshLambertMaterial({color: 0xffffff});
        return new THREE.Mesh(geometry, material);

    }


    work_on() {

        return "WOOD";

    }

}

module.exports = Resource;

},{"../../lib/three":25,"../common/gameobject":8}],23:[function(require,module,exports){
var MtEventHandler = function MtEventHandler(){

    this.__channels = {};

    //DO NOT CHANGE DURING RUNTIME!!!
    this.__eventlistPropertyName = "__mt_evts__";


    this.__defineProperty = function(obj, val, func){
        Object.defineProperty(obj, val, {
          value: func,
          writable: false,
          enumerable: false,
          configurable: false
        });
    };

    /*
     * This initializes while loading and sets the property-name of the eventlist for all objects
     */
    this.__eventFunctions = {
        "on": (function(propertyName){
            return function(eventName, func){
                var eventMap = this[propertyName];
                if(!eventMap) throw TypeError("This is not an mt-Evented Object!");
                if(!(func instanceof Function)) throw TypeError("Need to provide Function Object to \"ON\"");
                // if this is the first event with this name, create new array for this event type
                if(!eventMap[eventName]) eventMap[eventName] = [];
                var identifier = eventMap[eventName].length;
                eventMap[eventName].push(func);
                return identifier;
            };
        })(this.__eventlistPropertyName),

        "emit": (function(propertyName){
            return function(eventName, infoObj){
                var eventMap = this[propertyName];
                if(!eventMap || !(eventMap instanceof Object)) throw TypeError("This is not an mt-Evented Object!");
                // abort if there are no subscriptions on this event
                if(!eventMap[eventName]) return;
                // call all subscriptions
                eventMap[eventName].forEach(function(func){
                    !!func && func(infoObj);
                });
            };
        })(this.__eventlistPropertyName),

        "ignore": (function(propertyName){
            return function(eventName, identifier){
                var eventMap = this[propertyName];
                if(!eventMap ) throw TypeError("This is not an mt-Evented Object!");
                if(!eventMap[eventName] || !eventMap[eventName][identifier]) throw RangeError("Don't have this event!");

                var eventFunc = eventMap[eventName][identifier];
                eventMap[eventName][identifier] = undefined;
                return eventFunc;
            };
        })(this.__eventlistPropertyName)
    };

    this.makeEvented = function(obj){
        this.__defineProperty(obj, this.__eventlistPropertyName, {});
        this.__defineProperty(obj, "on", this.__eventFunctions.on);
        this.__defineProperty(obj, "emit", this.__eventFunctions.emit);
        this.__defineProperty(obj, "ignore", this.__eventFunctions.ignore);
    };

};

if(typeof module !== "undefined" && typeof module.exports !== "undefined") module.exports = new MtEventHandler();

},{}],24:[function(require,module,exports){
var Deferred = function () {
    this.promise = new Promise();
    this.state = Deferred.PENDING;
};

Deferred.FULFILLED = 0;
Deferred.REJECTED = 1;
Deferred.PENDING = 2;

Deferred.debug = false;

/**
 * This is a utility-function that returns a single promise for an array of promises.
 * It updates the promise for every resolved deferred in the same order as the original error.
 * It resolves once all promises have been resolved.
 */
Deferred.when = function () {
    var __deferred = new Deferred();

    // exclude non-promise values and convert arguments to array in one go
    var promises = Array.prototype.filter.call(arguments, function (arg) {
        return (arg instanceof Promise);
    });

    var toGo = promises.length;

    if (toGo < 1) throw RangeError("No Promises have been submitted to Deferred.when, need at least one.");

    // save the solved values for the promises in the same order
    var solveValues = [];
    solveValues.length = toGo;

    promises.forEach(function (promise, index) {

        // after the promise is fulfilled
        promise.then(function (value) {

            solveValues[index] = value;
            __deferred.update(solveValues);

            // decrement counter and resolve if we're done
            if (--toGo === 0) __deferred.resolve(solveValues);
        });
    });

    return __deferred.promise;
};

Deferred.prototype.resolve = function (value, strict) {

    // If the deferred is already closed, we check for the debug-flag and the strict-parameter
    // and give feedback to the caller accordingly
    if (this.state !== Deferred.PENDING) {
        Deferred.debug && console.warn("Promise already", this.state, ", can't resolve again");
        if (strict) throw new Error("Promise already", this.state);
        return false;
    }

    // If everything is normal (what is normal anyways?), we mark the deferred and its promise as resolved
    this.state = Deferred.FULFILLED;
    this.promise.state = Deferred.FULFILLED;
    this.promise.endValue = value;

    // last thing to do is execute all cached "then"-calls with the given value
    // NOTE: chaining of promises gets handled by the promises "then" function
    this.promise._resolveFunctions.forEach(function (func) {
        func(value);
    });

    // the reason for returning a boolean depending on whether resolving was successful is
    // that you can strip out the "strict = true" parameter and improve performance
    // for production code by just checking for the return value of "resolve"
    return true;

};

Deferred.prototype.reject = function (errorValue, strict) {

    if (this.state !== Deferred.PENDING) {
        Deferred.debug && console.warn("Promise already", this.state, ", can't resolve again");
        if (strict) throw new Error("Promise already", this.state);
        return false;
    }

    this.state = Deferred.REJECTED;
    this.promise.state = Deferred.REJECTED;
    this.promise.endValue = errorValue;
    this.promise._rejectFunctions.forEach(function (func) {
        func(errorValue);
    });

    return true;
};

Deferred.prototype.update = function (value, strict) {

    if (this.state !== Deferred.PENDING) {
        Deferred.debug && console.warn("Promise already", this.state, ", can't resolve again");
        if (strict) throw new Error("Promise already", this.state);
        return false;
    }

    this.promise._updateFunctions.forEach(function (func) {
        func(value);
    });
    return true;
};


var Promise = function () {

    this.state = Deferred.PENDING;

    this.endValue = null;

    this._resolveFunctions = [];

    this._rejectFunctions = [];

    this._updateFunctions = [];

};

Promise.prototype.then = function (onResolve, onError, onUpdate) {

    // we need to return a promise at the end of the "then"-call to allow chaining
    var deferred = new Deferred();

    if (onResolve) {
        //if the deferred is already resolved, trigger the function right now
        if (this.state === Deferred.FULFILLED) {
            Deferred.debug && console.info("Promise already resolved, executing \"then\" immediately")
            // execute the function and use its return value as derived value...
            var derivedValue = onResolve(this.endValue);
            // .. for the promise of the current "then"-call to allow promise-chaining
            deferred.resolve(derivedValue);
        } else {
            // if the deferred is still pending, put the resolve function in queue
            // so it can be executed later by the parenting deferred
            this._resolveFunctions.push(function (value) {
                // as above, save the return-value of the function call for the
                // deferred/promise of the current "then"-call
                var derivedValue = onResolve(value);
                deferred.resolve(derivedValue);
            }.bind(this));
        }
    }

    // Same as above for onResolve, so no comments here
    if (onError) {
        if (this.state === Deferred.REJECTED) {
            Deferred.debug && console.info("Promise already rejected, executing \"then\" immediately")
            var derivedErrorValue = onError(this.endValue);
            deferred.reject(derivedErrorValue);
        } else {
            this._rejectFunctions.push(function (errorValue) {
                var derivedErrorValue = onError(errorValue);
                deferred.reject(derivedErrorValue);
            }.bind(this));
        }
    }

    if (onUpdate) {
        // when updating we DON'T pass values to the derived promise because
        // we can't do that in a way that makes sense for the user
        if (this.state !== Deferred.PENDING) {
            Deferred.debug && console.warn("Trying to add onUpdate function to already fulfilled promise");
        } else {
            this._updateFunctions.push(function (value) {
                deferred.update(onUpdate(value));
            }.bind(this));
        }
    }

    return deferred.promise;

};

Deferred.Promise = Promise;

module.exports = Deferred;

},{}],25:[function(require,module,exports){
// File:src/Three.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

var THREE = { REVISION: '73' };

//

if ( typeof define === 'function' && define.amd ) {

    define( 'three', THREE );

} else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {

    module.exports = THREE;

}


// polyfills

if ( self.requestAnimationFrame === undefined || self.cancelAnimationFrame === undefined ) {

    // Missing in Android stock browser.

    ( function () {

        var lastTime = 0;
        var vendors = [ 'ms', 'moz', 'webkit', 'o' ];

        for ( var x = 0; x < vendors.length && ! self.requestAnimationFrame; ++ x ) {

            self.requestAnimationFrame = self[ vendors[ x ] + 'RequestAnimationFrame' ];
            self.cancelAnimationFrame = self[ vendors[ x ] + 'CancelAnimationFrame' ] || self[ vendors[ x ] + 'CancelRequestAnimationFrame' ];

        }

        if ( self.requestAnimationFrame === undefined && self.setTimeout !== undefined ) {

            self.requestAnimationFrame = function ( callback ) {

                var currTime = Date.now(), timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
                var id = self.setTimeout( function () {

                    callback( currTime + timeToCall );

                }, timeToCall );
                lastTime = currTime + timeToCall;
                return id;

            };

        }

        if ( self.cancelAnimationFrame === undefined && self.clearTimeout !== undefined ) {

            self.cancelAnimationFrame = function ( id ) {

                self.clearTimeout( id );

            };

        }

    } )();

}

//

if ( self.performance === undefined ) {

    self.performance = {};

}

if ( self.performance.now === undefined ) {

    ( function () {

        var start = Date.now();

        self.performance.now = function () {

            return Date.now() - start;

        }

    } )();

}

//

if ( Number.EPSILON === undefined ) {

    Number.EPSILON = Math.pow( 2, -52 );

}

//

if ( Math.sign === undefined ) {

    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

    Math.sign = function ( x ) {

        return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

    };

}

if ( Function.prototype.name === undefined && Object.defineProperty !== undefined ) {

    // Missing in IE9-11.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

    Object.defineProperty( Function.prototype, 'name', {

        get: function () {

            return this.toString().match( /^\s*function\s*(\S*)\s*\(/ )[ 1 ];

        }

    } );

}

// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button

THREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };

// GL STATE CONSTANTS

THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;

THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;

// SHADOWING TYPES

THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;

// MATERIAL CONSTANTS

// side

THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;

// shading

THREE.FlatShading = 1;
THREE.SmoothShading = 2;

// colors

THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;

// blending modes

THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;

// custom blending equations
// (numbers start from 100 not to clash with other
// mappings to OpenGL constants defined in Texture.js)

THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;
THREE.MinEquation = 103;
THREE.MaxEquation = 104;

// custom blending destination factors

THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;

// custom blending source factors

//THREE.ZeroFactor = 200;
//THREE.OneFactor = 201;
//THREE.SrcAlphaFactor = 204;
//THREE.OneMinusSrcAlphaFactor = 205;
//THREE.DstAlphaFactor = 206;
//THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;

// depth modes

THREE.NeverDepth = 0;
THREE.AlwaysDepth = 1;
THREE.LessDepth = 2;
THREE.LessEqualDepth = 3;
THREE.EqualDepth = 4;
THREE.GreaterEqualDepth = 5;
THREE.GreaterDepth = 6;
THREE.NotEqualDepth = 7;


// TEXTURE CONSTANTS

THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;

// Mapping modes

THREE.UVMapping = 300;

THREE.CubeReflectionMapping = 301;
THREE.CubeRefractionMapping = 302;

THREE.EquirectangularReflectionMapping = 303;
THREE.EquirectangularRefractionMapping = 304;

THREE.SphericalReflectionMapping = 305;

// Wrapping modes

THREE.RepeatWrapping = 1000;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;

// Filters

THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;

// Data types

THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;
THREE.HalfFloatType = 1025;

// Pixel types

//THREE.UnsignedByteType = 1009;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;

// Pixel formats

THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;
// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders
THREE.RGBEFormat = THREE.RGBAFormat; //1024;

// DDS / ST3C Compressed texture formats

THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;


// PVRTC compressed texture formats

THREE.RGB_PVRTC_4BPPV1_Format = 2100;
THREE.RGB_PVRTC_2BPPV1_Format = 2101;
THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
THREE.RGBA_PVRTC_2BPPV1_Format = 2103;

// Loop styles for AnimationAction

THREE.LoopOnce = 2200;
THREE.LoopRepeat = 2201;
THREE.LoopPingPong = 2202;

// DEPRECATED

THREE.Projector = function () {

    console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

    this.projectVector = function ( vector, camera ) {

        console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
        vector.project( camera );

    };

    this.unprojectVector = function ( vector, camera ) {

        console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
        vector.unproject( camera );

    };

    this.pickingRay = function ( vector, camera ) {

        console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

    };

};

THREE.CanvasRenderer = function () {

    console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

    this.domElement = document.createElement( 'canvas' );
    this.clear = function () {};
    this.render = function () {};
    this.setClearColor = function () {};
    this.setSize = function () {};

};

// File:src/math/Color.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Color = function ( color ) {

    if ( arguments.length === 3 ) {

        return this.fromArray( arguments );

    }

    return this.set( color );

};

THREE.Color.prototype = {

    constructor: THREE.Color,

    r: 1, g: 1, b: 1,

    set: function ( value ) {

        if ( value instanceof THREE.Color ) {

            this.copy( value );

        } else if ( typeof value === 'number' ) {

            this.setHex( value );

        } else if ( typeof value === 'string' ) {

            this.setStyle( value );

        }

        return this;

    },

    setHex: function ( hex ) {

        hex = Math.floor( hex );

        this.r = ( hex >> 16 & 255 ) / 255;
        this.g = ( hex >> 8 & 255 ) / 255;
        this.b = ( hex & 255 ) / 255;

        return this;

    },

    setRGB: function ( r, g, b ) {

        this.r = r;
        this.g = g;
        this.b = b;

        return this;

    },

    setHSL: function () {

        function hue2rgb( p, q, t ) {

            if ( t < 0 ) t += 1;
            if ( t > 1 ) t -= 1;
            if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
            if ( t < 1 / 2 ) return q;
            if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
            return p;

        }

        return function ( h, s, l ) {

            // h,s,l ranges are in 0.0 - 1.0
            h = THREE.Math.euclideanModulo( h, 1 );
            s = THREE.Math.clamp( s, 0, 1 );
            l = THREE.Math.clamp( l, 0, 1 );

            if ( s === 0 ) {

                this.r = this.g = this.b = l;

            } else {

                var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
                var q = ( 2 * l ) - p;

                this.r = hue2rgb( q, p, h + 1 / 3 );
                this.g = hue2rgb( q, p, h );
                this.b = hue2rgb( q, p, h - 1 / 3 );

            }

            return this;

        };

    }(),

    setStyle: function ( style ) {

        function handleAlpha( string ) {

            if ( string === undefined ) return;

            if ( parseFloat( string ) < 1 ) {

                console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

            }

        }


        var m;

        if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

            // rgb / hsl

            var color;
            var name = m[ 1 ];
            var components = m[ 2 ];

            switch ( name ) {

                case 'rgb':
                case 'rgba':

                    if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

                        // rgb(255,0,0) rgba(255,0,0,0.5)
                        this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
                        this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
                        this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

                        handleAlpha( color[ 5 ] );

                        return this;

                    }

                    if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

                        // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
                        this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
                        this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
                        this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

                        handleAlpha( color[ 5 ] );

                        return this;

                    }

                    break;

                case 'hsl':
                case 'hsla':

                    if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

                        // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
                        var h = parseFloat( color[ 1 ] ) / 360;
                        var s = parseInt( color[ 2 ], 10 ) / 100;
                        var l = parseInt( color[ 3 ], 10 ) / 100;

                        handleAlpha( color[ 5 ] );

                        return this.setHSL( h, s, l );

                    }

                    break;

            }

        } else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

            // hex color

            var hex = m[ 1 ];
            var size = hex.length;

            if ( size === 3 ) {

                // #ff0
                this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
                this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
                this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

                return this;

            } else if ( size === 6 ) {

                // #ff0000
                this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
                this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
                this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

                return this;

            }

        }

        if ( style && style.length > 0 ) {

            // color keywords
            var hex = THREE.ColorKeywords[ style ];

            if ( hex !== undefined ) {

                // red
                this.setHex( hex );

            } else {

                // unknown color
                console.warn( 'THREE.Color: Unknown color ' + style );

            }

        }

        return this;

    },

    clone: function () {

        return new this.constructor( this.r, this.g, this.b );

    },

    copy: function ( color ) {

        this.r = color.r;
        this.g = color.g;
        this.b = color.b;

        return this;

    },

    copyGammaToLinear: function ( color, gammaFactor ) {

        if ( gammaFactor === undefined ) gammaFactor = 2.0;

        this.r = Math.pow( color.r, gammaFactor );
        this.g = Math.pow( color.g, gammaFactor );
        this.b = Math.pow( color.b, gammaFactor );

        return this;

    },

    copyLinearToGamma: function ( color, gammaFactor ) {

        if ( gammaFactor === undefined ) gammaFactor = 2.0;

        var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

        this.r = Math.pow( color.r, safeInverse );
        this.g = Math.pow( color.g, safeInverse );
        this.b = Math.pow( color.b, safeInverse );

        return this;

    },

    convertGammaToLinear: function () {

        var r = this.r, g = this.g, b = this.b;

        this.r = r * r;
        this.g = g * g;
        this.b = b * b;

        return this;

    },

    convertLinearToGamma: function () {

        this.r = Math.sqrt( this.r );
        this.g = Math.sqrt( this.g );
        this.b = Math.sqrt( this.b );

        return this;

    },

    getHex: function () {

        return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

    },

    getHexString: function () {

        return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

    },

    getHSL: function ( optionalTarget ) {

        // h,s,l ranges are in 0.0 - 1.0

        var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

        var r = this.r, g = this.g, b = this.b;

        var max = Math.max( r, g, b );
        var min = Math.min( r, g, b );

        var hue, saturation;
        var lightness = ( min + max ) / 2.0;

        if ( min === max ) {

            hue = 0;
            saturation = 0;

        } else {

            var delta = max - min;

            saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

            switch ( max ) {

                case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
                case g: hue = ( b - r ) / delta + 2; break;
                case b: hue = ( r - g ) / delta + 4; break;

            }

            hue /= 6;

        }

        hsl.h = hue;
        hsl.s = saturation;
        hsl.l = lightness;

        return hsl;

    },

    getStyle: function () {

        return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

    },

    offsetHSL: function ( h, s, l ) {

        var hsl = this.getHSL();

        hsl.h += h; hsl.s += s; hsl.l += l;

        this.setHSL( hsl.h, hsl.s, hsl.l );

        return this;

    },

    add: function ( color ) {

        this.r += color.r;
        this.g += color.g;
        this.b += color.b;

        return this;

    },

    addColors: function ( color1, color2 ) {

        this.r = color1.r + color2.r;
        this.g = color1.g + color2.g;
        this.b = color1.b + color2.b;

        return this;

    },

    addScalar: function ( s ) {

        this.r += s;
        this.g += s;
        this.b += s;

        return this;

    },

    multiply: function ( color ) {

        this.r *= color.r;
        this.g *= color.g;
        this.b *= color.b;

        return this;

    },

    multiplyScalar: function ( s ) {

        this.r *= s;
        this.g *= s;
        this.b *= s;

        return this;

    },

    lerp: function ( color, alpha ) {

        this.r += ( color.r - this.r ) * alpha;
        this.g += ( color.g - this.g ) * alpha;
        this.b += ( color.b - this.b ) * alpha;

        return this;

    },

    equals: function ( c ) {

        return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

    },

    fromArray: function ( array, offset ) {

        if ( offset === undefined ) offset = 0;

        this.r = array[ offset ];
        this.g = array[ offset + 1 ];
        this.b = array[ offset + 2 ];

        return this;

    },

    toArray: function ( array, offset ) {

        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this.r;
        array[ offset + 1 ] = this.g;
        array[ offset + 2 ] = this.b;

        return array;

    }

};

THREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
    'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
    'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
    'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
    'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
    'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
    'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
    'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
    'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
    'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
    'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
    'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
    'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
    'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
    'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
    'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
    'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
    'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
    'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
    'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
    'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
    'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
    'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
    'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

// File:src/math/Quaternion.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

THREE.Quaternion = function ( x, y, z, w ) {

    this._x = x || 0;
    this._y = y || 0;
    this._z = z || 0;
    this._w = ( w !== undefined ) ? w : 1;

};

THREE.Quaternion.prototype = {

    constructor: THREE.Quaternion,

    get x () {

        return this._x;

    },

    set x ( value ) {

        this._x = value;
        this.onChangeCallback();

    },

    get y () {

        return this._y;

    },

    set y ( value ) {

        this._y = value;
        this.onChangeCallback();

    },

    get z () {

        return this._z;

    },

    set z ( value ) {

        this._z = value;
        this.onChangeCallback();

    },

    get w () {

        return this._w;

    },

    set w ( value ) {

        this._w = value;
        this.onChangeCallback();

    },

    set: function ( x, y, z, w ) {

        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;

        this.onChangeCallback();

        return this;

    },

    clone: function () {

        return new this.constructor( this._x, this._y, this._z, this._w );

    },

    copy: function ( quaternion ) {

        this._x = quaternion.x;
        this._y = quaternion.y;
        this._z = quaternion.z;
        this._w = quaternion.w;

        this.onChangeCallback();

        return this;

    },

    setFromEuler: function ( euler, update ) {

        if ( euler instanceof THREE.Euler === false ) {

            throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

        }

        // http://www.mathworks.com/matlabcentral/fileexchange/
        // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
        //	content/SpinCalc.m

        var c1 = Math.cos( euler._x / 2 );
        var c2 = Math.cos( euler._y / 2 );
        var c3 = Math.cos( euler._z / 2 );
        var s1 = Math.sin( euler._x / 2 );
        var s2 = Math.sin( euler._y / 2 );
        var s3 = Math.sin( euler._z / 2 );

        var order = euler.order;

        if ( order === 'XYZ' ) {

            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;

        } else if ( order === 'YXZ' ) {

            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;

        } else if ( order === 'ZXY' ) {

            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;

        } else if ( order === 'ZYX' ) {

            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;

        } else if ( order === 'YZX' ) {

            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;

        } else if ( order === 'XZY' ) {

            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;

        }

        if ( update !== false ) this.onChangeCallback();

        return this;

    },

    setFromAxisAngle: function ( axis, angle ) {

        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

        // assumes axis is normalized

        var halfAngle = angle / 2, s = Math.sin( halfAngle );

        this._x = axis.x * s;
        this._y = axis.y * s;
        this._z = axis.z * s;
        this._w = Math.cos( halfAngle );

        this.onChangeCallback();

        return this;

    },

    setFromRotationMatrix: function ( m ) {

        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

        var te = m.elements,

            m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
            m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
            m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

            trace = m11 + m22 + m33,
            s;

        if ( trace > 0 ) {

            s = 0.5 / Math.sqrt( trace + 1.0 );

            this._w = 0.25 / s;
            this._x = ( m32 - m23 ) * s;
            this._y = ( m13 - m31 ) * s;
            this._z = ( m21 - m12 ) * s;

        } else if ( m11 > m22 && m11 > m33 ) {

            s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

            this._w = ( m32 - m23 ) / s;
            this._x = 0.25 * s;
            this._y = ( m12 + m21 ) / s;
            this._z = ( m13 + m31 ) / s;

        } else if ( m22 > m33 ) {

            s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

            this._w = ( m13 - m31 ) / s;
            this._x = ( m12 + m21 ) / s;
            this._y = 0.25 * s;
            this._z = ( m23 + m32 ) / s;

        } else {

            s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

            this._w = ( m21 - m12 ) / s;
            this._x = ( m13 + m31 ) / s;
            this._y = ( m23 + m32 ) / s;
            this._z = 0.25 * s;

        }

        this.onChangeCallback();

        return this;

    },

    setFromUnitVectors: function () {

        // http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

        // assumes direction vectors vFrom and vTo are normalized

        var v1, r;

        var EPS = 0.000001;

        return function ( vFrom, vTo ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();

            r = vFrom.dot( vTo ) + 1;

            if ( r < EPS ) {

                r = 0;

                if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

                    v1.set( - vFrom.y, vFrom.x, 0 );

                } else {

                    v1.set( 0, - vFrom.z, vFrom.y );

                }

            } else {

                v1.crossVectors( vFrom, vTo );

            }

            this._x = v1.x;
            this._y = v1.y;
            this._z = v1.z;
            this._w = r;

            this.normalize();

            return this;

        }

    }(),

    inverse: function () {

        this.conjugate().normalize();

        return this;

    },

    conjugate: function () {

        this._x *= - 1;
        this._y *= - 1;
        this._z *= - 1;

        this.onChangeCallback();

        return this;

    },

    dot: function ( v ) {

        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

    },

    lengthSq: function () {

        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

    },

    length: function () {

        return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

    },

    normalize: function () {

        var l = this.length();

        if ( l === 0 ) {

            this._x = 0;
            this._y = 0;
            this._z = 0;
            this._w = 1;

        } else {

            l = 1 / l;

            this._x = this._x * l;
            this._y = this._y * l;
            this._z = this._z * l;
            this._w = this._w * l;

        }

        this.onChangeCallback();

        return this;

    },

    multiply: function ( q, p ) {

        if ( p !== undefined ) {

            console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
            return this.multiplyQuaternions( q, p );

        }

        return this.multiplyQuaternions( this, q );

    },

    multiplyQuaternions: function ( a, b ) {

        // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

        var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
        var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

        this.onChangeCallback();

        return this;

    },

    multiplyVector3: function ( vector ) {

        console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
        return vector.applyQuaternion( this );

    },

    slerp: function ( qb, t ) {

        if ( t === 0 ) return this;
        if ( t === 1 ) return this.copy( qb );

        var x = this._x, y = this._y, z = this._z, w = this._w;

        // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

        var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

        if ( cosHalfTheta < 0 ) {

            this._w = - qb._w;
            this._x = - qb._x;
            this._y = - qb._y;
            this._z = - qb._z;

            cosHalfTheta = - cosHalfTheta;

        } else {

            this.copy( qb );

        }

        if ( cosHalfTheta >= 1.0 ) {

            this._w = w;
            this._x = x;
            this._y = y;
            this._z = z;

            return this;

        }

        var halfTheta = Math.acos( cosHalfTheta );
        var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

        if ( Math.abs( sinHalfTheta ) < 0.001 ) {

            this._w = 0.5 * ( w + this._w );
            this._x = 0.5 * ( x + this._x );
            this._y = 0.5 * ( y + this._y );
            this._z = 0.5 * ( z + this._z );

            return this;

        }

        var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
            ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

        this._w = ( w * ratioA + this._w * ratioB );
        this._x = ( x * ratioA + this._x * ratioB );
        this._y = ( y * ratioA + this._y * ratioB );
        this._z = ( z * ratioA + this._z * ratioB );

        this.onChangeCallback();

        return this;

    },

    equals: function ( quaternion ) {

        return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

    },

    fromArray: function ( array, offset ) {

        if ( offset === undefined ) offset = 0;

        this._x = array[ offset ];
        this._y = array[ offset + 1 ];
        this._z = array[ offset + 2 ];
        this._w = array[ offset + 3 ];

        this.onChangeCallback();

        return this;

    },

    toArray: function ( array, offset ) {

        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this._x;
        array[ offset + 1 ] = this._y;
        array[ offset + 2 ] = this._z;
        array[ offset + 3 ] = this._w;

        return array;

    },

    onChange: function ( callback ) {

        this.onChangeCallback = callback;

        return this;

    },

    onChangeCallback: function () {}

};

THREE.Quaternion.slerp = function ( qa, qb, qm, t ) {

    return qm.copy( qa ).slerp( qb, t );

};

// File:src/math/Vector2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.Vector2 = function ( x, y ) {

    this.x = x || 0;
    this.y = y || 0;

};

THREE.Vector2.prototype = {

    constructor: THREE.Vector2,

    get width() { return this.x },
    set width( value ) { this.x = value },

    get height() { return this.y },
    set height( value ) { this.y = value },

    //

    set: function ( x, y ) {

        this.x = x;
        this.y = y;

        return this;

    },

    setX: function ( x ) {

        this.x = x;

        return this;

    },

    setY: function ( y ) {

        this.y = y;

        return this;

    },

    setComponent: function ( index, value ) {

        switch ( index ) {

            case 0: this.x = value; break;
            case 1: this.y = value; break;
            default: throw new Error( 'index is out of range: ' + index );

        }

    },

    getComponent: function ( index ) {

        switch ( index ) {

            case 0: return this.x;
            case 1: return this.y;
            default: throw new Error( 'index is out of range: ' + index );

        }

    },

    clone: function () {

        return new this.constructor( this.x, this.y );

    },

    copy: function ( v ) {

        this.x = v.x;
        this.y = v.y;

        return this;

    },

    add: function ( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
            return this.addVectors( v, w );

        }

        this.x += v.x;
        this.y += v.y;

        return this;

    },

    addScalar: function ( s ) {

        this.x += s;
        this.y += s;

        return this;

    },

    addVectors: function ( a, b ) {

        this.x = a.x + b.x;
        this.y = a.y + b.y;

        return this;

    },

    addScaledVector: function ( v, s ) {

        this.x += v.x * s;
        this.y += v.y * s;

        return this;

    },

    sub: function ( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
            return this.subVectors( v, w );

        }

        this.x -= v.x;
        this.y -= v.y;

        return this;

    },

    subScalar: function ( s ) {

        this.x -= s;
        this.y -= s;

        return this;

    },

    subVectors: function ( a, b ) {

        this.x = a.x - b.x;
        this.y = a.y - b.y;

        return this;

    },

    multiply: function ( v ) {

        this.x *= v.x;
        this.y *= v.y;

        return this;

    },

    multiplyScalar: function ( scalar ) {

        if ( isFinite( scalar ) ) {
            this.x *= scalar;
            this.y *= scalar;
        } else {
            this.x = 0;
            this.y = 0;
        }

        return this;

    },

    divide: function ( v ) {

        this.x /= v.x;
        this.y /= v.y;

        return this;

    },

    divideScalar: function ( scalar ) {

        return this.multiplyScalar( 1 / scalar );

    },

    min: function ( v ) {

        this.x = Math.min( this.x, v.x );
        this.y = Math.min( this.y, v.y );

        return this;

    },

    max: function ( v ) {

        this.x = Math.max( this.x, v.x );
        this.y = Math.max( this.y, v.y );

        return this;

    },

    clamp: function ( min, max ) {

        // This function assumes min < max, if this assumption isn't true it will not operate correctly

        this.x = Math.max( min.x, Math.min( max.x, this.x ) );
        this.y = Math.max( min.y, Math.min( max.y, this.y ) );

        return this;

    },

    clampScalar: function () {

        var min, max;

        return function clampScalar( minVal, maxVal ) {

            if ( min === undefined ) {

                min = new THREE.Vector2();
                max = new THREE.Vector2();

            }

            min.set( minVal, minVal );
            max.set( maxVal, maxVal );

            return this.clamp( min, max );

        };

    }(),

    clampLength: function ( min, max ) {

        var length = this.length();

        this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

        return this;

    },

    floor: function () {

        this.x = Math.floor( this.x );
        this.y = Math.floor( this.y );

        return this;

    },

    ceil: function () {

        this.x = Math.ceil( this.x );
        this.y = Math.ceil( this.y );

        return this;

    },

    round: function () {

        this.x = Math.round( this.x );
        this.y = Math.round( this.y );

        return this;

    },

    roundToZero: function () {

        this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
        this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

        return this;

    },

    negate: function () {

        this.x = - this.x;
        this.y = - this.y;

        return this;

    },

    dot: function ( v ) {

        return this.x * v.x + this.y * v.y;

    },

    lengthSq: function () {

        return this.x * this.x + this.y * this.y;

    },

    length: function () {

        return Math.sqrt( this.x * this.x + this.y * this.y );

    },

    lengthManhattan: function() {

        return Math.abs( this.x ) + Math.abs( this.y );

    },

    normalize: function () {

        return this.divideScalar( this.length() );

    },

    distanceTo: function ( v ) {

        return Math.sqrt( this.distanceToSquared( v ) );

    },

    distanceToSquared: function ( v ) {

        var dx = this.x - v.x, dy = this.y - v.y;
        return dx * dx + dy * dy;

    },

    setLength: function ( length ) {

        return this.multiplyScalar( length / this.length() );

    },

    lerp: function ( v, alpha ) {

        this.x += ( v.x - this.x ) * alpha;
        this.y += ( v.y - this.y ) * alpha;

        return this;

    },

    lerpVectors: function ( v1, v2, alpha ) {

        this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

        return this;

    },

    equals: function ( v ) {

        return ( ( v.x === this.x ) && ( v.y === this.y ) );

    },

    fromArray: function ( array, offset ) {

        if ( offset === undefined ) offset = 0;

        this.x = array[ offset ];
        this.y = array[ offset + 1 ];

        return this;

    },

    toArray: function ( array, offset ) {

        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this.x;
        array[ offset + 1 ] = this.y;

        return array;

    },

    fromAttribute: function ( attribute, index, offset ) {

        if ( offset === undefined ) offset = 0;

        index = index * attribute.itemSize + offset;

        this.x = attribute.array[ index ];
        this.y = attribute.array[ index + 1 ];

        return this;

    },

    rotateAround: function ( center, angle ) {

        var c = Math.cos( angle ), s = Math.sin( angle );

        var x = this.x - center.x;
        var y = this.y - center.y;

        this.x = x * c - y * s + center.x;
        this.y = x * s + y * c + center.y;

        return this;

    }

};

// File:src/math/Vector3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author *kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector3 = function ( x, y, z ) {

    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;

};

THREE.Vector3.prototype = {

    constructor: THREE.Vector3,

    set: function ( x, y, z ) {

        this.x = x;
        this.y = y;
        this.z = z;

        return this;

    },

    setX: function ( x ) {

        this.x = x;

        return this;

    },

    setY: function ( y ) {

        this.y = y;

        return this;

    },

    setZ: function ( z ) {

        this.z = z;

        return this;

    },

    setComponent: function ( index, value ) {

        switch ( index ) {

            case 0: this.x = value; break;
            case 1: this.y = value; break;
            case 2: this.z = value; break;
            default: throw new Error( 'index is out of range: ' + index );

        }

    },

    getComponent: function ( index ) {

        switch ( index ) {

            case 0: return this.x;
            case 1: return this.y;
            case 2: return this.z;
            default: throw new Error( 'index is out of range: ' + index );

        }

    },

    clone: function () {

        return new this.constructor( this.x, this.y, this.z );

    },

    copy: function ( v ) {

        this.x = v.x;
        this.y = v.y;
        this.z = v.z;

        return this;

    },

    add: function ( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
            return this.addVectors( v, w );

        }

        this.x += v.x;
        this.y += v.y;
        this.z += v.z;

        return this;

    },

    addScalar: function ( s ) {

        this.x += s;
        this.y += s;
        this.z += s;

        return this;

    },

    addVectors: function ( a, b ) {

        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;

        return this;

    },

    addScaledVector: function ( v, s ) {

        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;

        return this;

    },

    sub: function ( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
            return this.subVectors( v, w );

        }

        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;

        return this;

    },

    subScalar: function ( s ) {

        this.x -= s;
        this.y -= s;
        this.z -= s;

        return this;

    },

    subVectors: function ( a, b ) {

        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;

        return this;

    },

    multiply: function ( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
            return this.multiplyVectors( v, w );

        }

        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;

        return this;

    },

    multiplyScalar: function ( scalar ) {

        if ( isFinite( scalar ) ) {
            this.x *= scalar;
            this.y *= scalar;
            this.z *= scalar;
        } else {
            this.x = 0;
            this.y = 0;
            this.z = 0;
        }

        return this;

    },

    multiplyVectors: function ( a, b ) {

        this.x = a.x * b.x;
        this.y = a.y * b.y;
        this.z = a.z * b.z;

        return this;

    },

    applyEuler: function () {

        var quaternion;

        return function applyEuler( euler ) {

            if ( euler instanceof THREE.Euler === false ) {

                console.error( 'THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.' );

            }

            if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

            this.applyQuaternion( quaternion.setFromEuler( euler ) );

            return this;

        };

    }(),

    applyAxisAngle: function () {

        var quaternion;

        return function applyAxisAngle( axis, angle ) {

            if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

            this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

            return this;

        };

    }(),

    applyMatrix3: function ( m ) {

        var x = this.x;
        var y = this.y;
        var z = this.z;

        var e = m.elements;

        this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
        this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
        this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

        return this;

    },

    applyMatrix4: function ( m ) {

        // input: THREE.Matrix4 affine matrix

        var x = this.x, y = this.y, z = this.z;

        var e = m.elements;

        this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
        this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
        this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

        return this;

    },

    applyProjection: function ( m ) {

        // input: THREE.Matrix4 projection matrix

        var x = this.x, y = this.y, z = this.z;

        var e = m.elements;
        var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

        this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
        this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
        this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

        return this;

    },

    applyQuaternion: function ( q ) {

        var x = this.x;
        var y = this.y;
        var z = this.z;

        var qx = q.x;
        var qy = q.y;
        var qz = q.z;
        var qw = q.w;

        // calculate quat * vector

        var ix =  qw * x + qy * z - qz * y;
        var iy =  qw * y + qz * x - qx * z;
        var iz =  qw * z + qx * y - qy * x;
        var iw = - qx * x - qy * y - qz * z;

        // calculate result * inverse quat

        this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
        this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
        this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

        return this;

    },

    project: function () {

        var matrix;

        return function project( camera ) {

            if ( matrix === undefined ) matrix = new THREE.Matrix4();

            matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
            return this.applyProjection( matrix );

        };

    }(),

    unproject: function () {

        var matrix;

        return function unproject( camera ) {

            if ( matrix === undefined ) matrix = new THREE.Matrix4();

            matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
            return this.applyProjection( matrix );

        };

    }(),

    transformDirection: function ( m ) {

        // input: THREE.Matrix4 affine matrix
        // vector interpreted as a direction

        var x = this.x, y = this.y, z = this.z;

        var e = m.elements;

        this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
        this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
        this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

        this.normalize();

        return this;

    },

    divide: function ( v ) {

        this.x /= v.x;
        this.y /= v.y;
        this.z /= v.z;

        return this;

    },

    divideScalar: function ( scalar ) {

        return this.multiplyScalar( 1 / scalar );

    },

    min: function ( v ) {

        this.x = Math.min( this.x, v.x );
        this.y = Math.min( this.y, v.y );
        this.z = Math.min( this.z, v.z );

        return this;

    },

    max: function ( v ) {

        this.x = Math.max( this.x, v.x );
        this.y = Math.max( this.y, v.y );
        this.z = Math.max( this.z, v.z );

        return this;

    },

    clamp: function ( min, max ) {

        // This function assumes min < max, if this assumption isn't true it will not operate correctly

        this.x = Math.max( min.x, Math.min( max.x, this.x ) );
        this.y = Math.max( min.y, Math.min( max.y, this.y ) );
        this.z = Math.max( min.z, Math.min( max.z, this.z ) );

        return this;

    },

    clampScalar: function () {

        var min, max;

        return function clampScalar( minVal, maxVal ) {

            if ( min === undefined ) {

                min = new THREE.Vector3();
                max = new THREE.Vector3();

            }

            min.set( minVal, minVal, minVal );
            max.set( maxVal, maxVal, maxVal );

            return this.clamp( min, max );

        };

    }(),

    clampLength: function ( min, max ) {

        var length = this.length();

        this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

        return this;

    },

    floor: function () {

        this.x = Math.floor( this.x );
        this.y = Math.floor( this.y );
        this.z = Math.floor( this.z );

        return this;

    },

    ceil: function () {

        this.x = Math.ceil( this.x );
        this.y = Math.ceil( this.y );
        this.z = Math.ceil( this.z );

        return this;

    },

    round: function () {

        this.x = Math.round( this.x );
        this.y = Math.round( this.y );
        this.z = Math.round( this.z );

        return this;

    },

    roundToZero: function () {

        this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
        this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
        this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

        return this;

    },

    negate: function () {

        this.x = - this.x;
        this.y = - this.y;
        this.z = - this.z;

        return this;

    },

    dot: function ( v ) {

        return this.x * v.x + this.y * v.y + this.z * v.z;

    },

    lengthSq: function () {

        return this.x * this.x + this.y * this.y + this.z * this.z;

    },

    length: function () {

        return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

    },

    lengthManhattan: function () {

        return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

    },

    normalize: function () {

        return this.divideScalar( this.length() );

    },

    setLength: function ( length ) {

        return this.multiplyScalar( length / this.length() );

    },

    lerp: function ( v, alpha ) {

        this.x += ( v.x - this.x ) * alpha;
        this.y += ( v.y - this.y ) * alpha;
        this.z += ( v.z - this.z ) * alpha;

        return this;

    },

    lerpVectors: function ( v1, v2, alpha ) {

        this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

        return this;

    },

    cross: function ( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
            return this.crossVectors( v, w );

        }

        var x = this.x, y = this.y, z = this.z;

        this.x = y * v.z - z * v.y;
        this.y = z * v.x - x * v.z;
        this.z = x * v.y - y * v.x;

        return this;

    },

    crossVectors: function ( a, b ) {

        var ax = a.x, ay = a.y, az = a.z;
        var bx = b.x, by = b.y, bz = b.z;

        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;

        return this;

    },

    projectOnVector: function () {

        var v1, dot;

        return function projectOnVector( vector ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();

            v1.copy( vector ).normalize();

            dot = this.dot( v1 );

            return this.copy( v1 ).multiplyScalar( dot );

        };

    }(),

    projectOnPlane: function () {

        var v1;

        return function projectOnPlane( planeNormal ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();

            v1.copy( this ).projectOnVector( planeNormal );

            return this.sub( v1 );

        }

    }(),

    reflect: function () {

        // reflect incident vector off plane orthogonal to normal
        // normal is assumed to have unit length

        var v1;

        return function reflect( normal ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();

            return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

        }

    }(),

    angleTo: function ( v ) {

        var theta = this.dot( v ) / ( this.length() * v.length() );

        // clamp, to handle numerical problems

        return Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );

    },

    distanceTo: function ( v ) {

        return Math.sqrt( this.distanceToSquared( v ) );

    },

    distanceToSquared: function ( v ) {

        var dx = this.x - v.x;
        var dy = this.y - v.y;
        var dz = this.z - v.z;

        return dx * dx + dy * dy + dz * dz;

    },

    setEulerFromRotationMatrix: function ( m, order ) {

        console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

    },

    setEulerFromQuaternion: function ( q, order ) {

        console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

    },

    getPositionFromMatrix: function ( m ) {

        console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );

        return this.setFromMatrixPosition( m );

    },

    getScaleFromMatrix: function ( m ) {

        console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );

        return this.setFromMatrixScale( m );

    },

    getColumnFromMatrix: function ( index, matrix ) {

        console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );

        return this.setFromMatrixColumn( index, matrix );

    },

    setFromMatrixPosition: function ( m ) {

        this.x = m.elements[ 12 ];
        this.y = m.elements[ 13 ];
        this.z = m.elements[ 14 ];

        return this;

    },

    setFromMatrixScale: function ( m ) {

        var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[ 2 ] ).length();
        var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[ 6 ] ).length();
        var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();

        this.x = sx;
        this.y = sy;
        this.z = sz;

        return this;

    },

    setFromMatrixColumn: function ( index, matrix ) {

        var offset = index * 4;

        var me = matrix.elements;

        this.x = me[ offset ];
        this.y = me[ offset + 1 ];
        this.z = me[ offset + 2 ];

        return this;

    },

    equals: function ( v ) {

        return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

    },

    fromArray: function ( array, offset ) {

        if ( offset === undefined ) offset = 0;

        this.x = array[ offset ];
        this.y = array[ offset + 1 ];
        this.z = array[ offset + 2 ];

        return this;

    },

    toArray: function ( array, offset ) {

        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this.x;
        array[ offset + 1 ] = this.y;
        array[ offset + 2 ] = this.z;

        return array;

    },

    fromAttribute: function ( attribute, index, offset ) {

        if ( offset === undefined ) offset = 0;

        index = index * attribute.itemSize + offset;

        this.x = attribute.array[ index ];
        this.y = attribute.array[ index + 1 ];
        this.z = attribute.array[ index + 2 ];

        return this;

    }

};

// File:src/math/Vector4.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector4 = function ( x, y, z, w ) {

    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
    this.w = ( w !== undefined ) ? w : 1;

};

THREE.Vector4.prototype = {

    constructor: THREE.Vector4,

    set: function ( x, y, z, w ) {

        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;

        return this;

    },

    setX: function ( x ) {

        this.x = x;

        return this;

    },

    setY: function ( y ) {

        this.y = y;

        return this;

    },

    setZ: function ( z ) {

        this.z = z;

        return this;

    },

    setW: function ( w ) {

        this.w = w;

        return this;

    },

    setComponent: function ( index, value ) {

        switch ( index ) {

            case 0: this.x = value; break;
            case 1: this.y = value; break;
            case 2: this.z = value; break;
            case 3: this.w = value; break;
            default: throw new Error( 'index is out of range: ' + index );

        }

    },

    getComponent: function ( index ) {

        switch ( index ) {

            case 0: return this.x;
            case 1: return this.y;
            case 2: return this.z;
            case 3: return this.w;
            default: throw new Error( 'index is out of range: ' + index );

        }

    },

    clone: function () {

        return new this.constructor( this.x, this.y, this.z, this.w );

    },

    copy: function ( v ) {

        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = ( v.w !== undefined ) ? v.w : 1;

        return this;

    },

    add: function ( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
            return this.addVectors( v, w );

        }

        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        this.w += v.w;

        return this;

    },

    addScalar: function ( s ) {

        this.x += s;
        this.y += s;
        this.z += s;
        this.w += s;

        return this;

    },

    addVectors: function ( a, b ) {

        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        this.w = a.w + b.w;

        return this;

    },

    addScaledVector: function ( v, s ) {

        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        this.w += v.w * s;

        return this;

    },

    sub: function ( v, w ) {

        if ( w !== undefined ) {

            console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
            return this.subVectors( v, w );

        }

        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        this.w -= v.w;

        return this;

    },

    subScalar: function ( s ) {

        this.x -= s;
        this.y -= s;
        this.z -= s;
        this.w -= s;

        return this;

    },

    subVectors: function ( a, b ) {

        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        this.w = a.w - b.w;

        return this;

    },

    multiplyScalar: function ( scalar ) {

        if ( isFinite( scalar ) ) {
            this.x *= scalar;
            this.y *= scalar;
            this.z *= scalar;
            this.w *= scalar;
        } else {
            this.x = 0;
            this.y = 0;
            this.z = 0;
            this.w = 0;
        }

        return this;

    },

    applyMatrix4: function ( m ) {

        var x = this.x;
        var y = this.y;
        var z = this.z;
        var w = this.w;

        var e = m.elements;

        this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
        this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
        this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
        this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

        return this;

    },

    divideScalar: function ( scalar ) {

        return this.multiplyScalar( 1 / scalar );

    },

    setAxisAngleFromQuaternion: function ( q ) {

        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

        // q is assumed to be normalized

        this.w = 2 * Math.acos( q.w );

        var s = Math.sqrt( 1 - q.w * q.w );

        if ( s < 0.0001 ) {

            this.x = 1;
            this.y = 0;
            this.z = 0;

        } else {

            this.x = q.x / s;
            this.y = q.y / s;
            this.z = q.z / s;

        }

        return this;

    },

    setAxisAngleFromRotationMatrix: function ( m ) {

        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

        var angle, x, y, z,		// variables for result
            epsilon = 0.01,		// margin to allow for rounding errors
            epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

            te = m.elements,

            m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
            m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
            m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

        if ( ( Math.abs( m12 - m21 ) < epsilon )
            && ( Math.abs( m13 - m31 ) < epsilon )
            && ( Math.abs( m23 - m32 ) < epsilon ) ) {

            // singularity found
            // first check for identity matrix which must have +1 for all terms
            // in leading diagonal and zero in other terms

            if ( ( Math.abs( m12 + m21 ) < epsilon2 )
                && ( Math.abs( m13 + m31 ) < epsilon2 )
                && ( Math.abs( m23 + m32 ) < epsilon2 )
                && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

                // this singularity is identity matrix so angle = 0

                this.set( 1, 0, 0, 0 );

                return this; // zero angle, arbitrary axis

            }

            // otherwise this singularity is angle = 180

            angle = Math.PI;

            var xx = ( m11 + 1 ) / 2;
            var yy = ( m22 + 1 ) / 2;
            var zz = ( m33 + 1 ) / 2;
            var xy = ( m12 + m21 ) / 4;
            var xz = ( m13 + m31 ) / 4;
            var yz = ( m23 + m32 ) / 4;

            if ( ( xx > yy ) && ( xx > zz ) ) {

                // m11 is the largest diagonal term

                if ( xx < epsilon ) {

                    x = 0;
                    y = 0.707106781;
                    z = 0.707106781;

                } else {

                    x = Math.sqrt( xx );
                    y = xy / x;
                    z = xz / x;

                }

            } else if ( yy > zz ) {

                // m22 is the largest diagonal term

                if ( yy < epsilon ) {

                    x = 0.707106781;
                    y = 0;
                    z = 0.707106781;

                } else {

                    y = Math.sqrt( yy );
                    x = xy / y;
                    z = yz / y;

                }

            } else {

                // m33 is the largest diagonal term so base result on this

                if ( zz < epsilon ) {

                    x = 0.707106781;
                    y = 0.707106781;
                    z = 0;

                } else {

                    z = Math.sqrt( zz );
                    x = xz / z;
                    y = yz / z;

                }

            }

            this.set( x, y, z, angle );

            return this; // return 180 deg rotation

        }

        // as we have reached here there are no singularities so we can handle normally

        var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )
            + ( m13 - m31 ) * ( m13 - m31 )
            + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

        if ( Math.abs( s ) < 0.001 ) s = 1;

        // prevent divide by zero, should not happen if matrix is orthogonal and should be
        // caught by singularity test above, but I've left it in just in case

        this.x = ( m32 - m23 ) / s;
        this.y = ( m13 - m31 ) / s;
        this.z = ( m21 - m12 ) / s;
        this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

        return this;

    },

    min: function ( v ) {

        this.x = Math.min( this.x, v.x );
        this.y = Math.min( this.y, v.y );
        this.z = Math.min( this.z, v.z );
        this.w = Math.min( this.w, v.w );

        return this;

    },

    max: function ( v ) {

        this.x = Math.max( this.x, v.x );
        this.y = Math.max( this.y, v.y );
        this.z = Math.max( this.z, v.z );
        this.w = Math.max( this.w, v.w );

        return this;

    },

    clamp: function ( min, max ) {

        // This function assumes min < max, if this assumption isn't true it will not operate correctly

        this.x = Math.max( min.x, Math.min( max.x, this.x ) );
        this.y = Math.max( min.y, Math.min( max.y, this.y ) );
        this.z = Math.max( min.z, Math.min( max.z, this.z ) );
        this.w = Math.max( min.w, Math.min( max.w, this.w ) );

        return this;

    },

    clampScalar: function () {

        var min, max;

        return function clampScalar( minVal, maxVal ) {

            if ( min === undefined ) {

                min = new THREE.Vector4();
                max = new THREE.Vector4();

            }

            min.set( minVal, minVal, minVal, minVal );
            max.set( maxVal, maxVal, maxVal, maxVal );

            return this.clamp( min, max );

        };

    }(),

    floor: function () {

        this.x = Math.floor( this.x );
        this.y = Math.floor( this.y );
        this.z = Math.floor( this.z );
        this.w = Math.floor( this.w );

        return this;

    },

    ceil: function () {

        this.x = Math.ceil( this.x );
        this.y = Math.ceil( this.y );
        this.z = Math.ceil( this.z );
        this.w = Math.ceil( this.w );

        return this;

    },

    round: function () {

        this.x = Math.round( this.x );
        this.y = Math.round( this.y );
        this.z = Math.round( this.z );
        this.w = Math.round( this.w );

        return this;

    },

    roundToZero: function () {

        this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
        this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
        this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
        this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

        return this;

    },

    negate: function () {

        this.x = - this.x;
        this.y = - this.y;
        this.z = - this.z;
        this.w = - this.w;

        return this;

    },

    dot: function ( v ) {

        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

    },

    lengthSq: function () {

        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

    },

    length: function () {

        return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

    },

    lengthManhattan: function () {

        return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

    },

    normalize: function () {

        return this.divideScalar( this.length() );

    },

    setLength: function ( length ) {

        return this.multiplyScalar( length / this.length() );

    },

    lerp: function ( v, alpha ) {

        this.x += ( v.x - this.x ) * alpha;
        this.y += ( v.y - this.y ) * alpha;
        this.z += ( v.z - this.z ) * alpha;
        this.w += ( v.w - this.w ) * alpha;

        return this;

    },

    lerpVectors: function ( v1, v2, alpha ) {

        this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

        return this;

    },

    equals: function ( v ) {

        return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

    },

    fromArray: function ( array, offset ) {

        if ( offset === undefined ) offset = 0;

        this.x = array[ offset ];
        this.y = array[ offset + 1 ];
        this.z = array[ offset + 2 ];
        this.w = array[ offset + 3 ];

        return this;

    },

    toArray: function ( array, offset ) {

        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this.x;
        array[ offset + 1 ] = this.y;
        array[ offset + 2 ] = this.z;
        array[ offset + 3 ] = this.w;

        return array;

    },

    fromAttribute: function ( attribute, index, offset ) {

        if ( offset === undefined ) offset = 0;

        index = index * attribute.itemSize + offset;

        this.x = attribute.array[ index ];
        this.y = attribute.array[ index + 1 ];
        this.z = attribute.array[ index + 2 ];
        this.w = attribute.array[ index + 3 ];

        return this;

    }

};

// File:src/math/Euler.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

THREE.Euler = function ( x, y, z, order ) {

    this._x = x || 0;
    this._y = y || 0;
    this._z = z || 0;
    this._order = order || THREE.Euler.DefaultOrder;

};

THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

THREE.Euler.DefaultOrder = 'XYZ';

THREE.Euler.prototype = {

    constructor: THREE.Euler,

    get x () {

        return this._x;

    },

    set x ( value ) {

        this._x = value;
        this.onChangeCallback();

    },

    get y () {

        return this._y;

    },

    set y ( value ) {

        this._y = value;
        this.onChangeCallback();

    },

    get z () {

        return this._z;

    },

    set z ( value ) {

        this._z = value;
        this.onChangeCallback();

    },

    get order () {

        return this._order;

    },

    set order ( value ) {

        this._order = value;
        this.onChangeCallback();

    },

    set: function ( x, y, z, order ) {

        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order || this._order;

        this.onChangeCallback();

        return this;

    },

    clone: function () {

        return new this.constructor( this._x, this._y, this._z, this._order);

    },

    copy: function ( euler ) {

        this._x = euler._x;
        this._y = euler._y;
        this._z = euler._z;
        this._order = euler._order;

        this.onChangeCallback();

        return this;

    },

    setFromRotationMatrix: function ( m, order, update ) {

        var clamp = THREE.Math.clamp;

        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

        var te = m.elements;
        var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
        var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
        var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

        order = order || this._order;

        if ( order === 'XYZ' ) {

            this._y = Math.asin( clamp( m13, - 1, 1 ) );

            if ( Math.abs( m13 ) < 0.99999 ) {

                this._x = Math.atan2( - m23, m33 );
                this._z = Math.atan2( - m12, m11 );

            } else {

                this._x = Math.atan2( m32, m22 );
                this._z = 0;

            }

        } else if ( order === 'YXZ' ) {

            this._x = Math.asin( - clamp( m23, - 1, 1 ) );

            if ( Math.abs( m23 ) < 0.99999 ) {

                this._y = Math.atan2( m13, m33 );
                this._z = Math.atan2( m21, m22 );

            } else {

                this._y = Math.atan2( - m31, m11 );
                this._z = 0;

            }

        } else if ( order === 'ZXY' ) {

            this._x = Math.asin( clamp( m32, - 1, 1 ) );

            if ( Math.abs( m32 ) < 0.99999 ) {

                this._y = Math.atan2( - m31, m33 );
                this._z = Math.atan2( - m12, m22 );

            } else {

                this._y = 0;
                this._z = Math.atan2( m21, m11 );

            }

        } else if ( order === 'ZYX' ) {

            this._y = Math.asin( - clamp( m31, - 1, 1 ) );

            if ( Math.abs( m31 ) < 0.99999 ) {

                this._x = Math.atan2( m32, m33 );
                this._z = Math.atan2( m21, m11 );

            } else {

                this._x = 0;
                this._z = Math.atan2( - m12, m22 );

            }

        } else if ( order === 'YZX' ) {

            this._z = Math.asin( clamp( m21, - 1, 1 ) );

            if ( Math.abs( m21 ) < 0.99999 ) {

                this._x = Math.atan2( - m23, m22 );
                this._y = Math.atan2( - m31, m11 );

            } else {

                this._x = 0;
                this._y = Math.atan2( m13, m33 );

            }

        } else if ( order === 'XZY' ) {

            this._z = Math.asin( - clamp( m12, - 1, 1 ) );

            if ( Math.abs( m12 ) < 0.99999 ) {

                this._x = Math.atan2( m32, m22 );
                this._y = Math.atan2( m13, m11 );

            } else {

                this._x = Math.atan2( - m23, m33 );
                this._y = 0;

            }

        } else {

            console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )

        }

        this._order = order;

        if ( update !== false ) this.onChangeCallback();

        return this;

    },

    setFromQuaternion: function () {

        var matrix;

        return function ( q, order, update ) {

            if ( matrix === undefined ) matrix = new THREE.Matrix4();
            matrix.makeRotationFromQuaternion( q );
            this.setFromRotationMatrix( matrix, order, update );

            return this;

        };

    }(),

    setFromVector3: function ( v, order ) {

        return this.set( v.x, v.y, v.z, order || this._order );

    },

    reorder: function () {

        // WARNING: this discards revolution information -bhouston

        var q = new THREE.Quaternion();

        return function ( newOrder ) {

            q.setFromEuler( this );
            this.setFromQuaternion( q, newOrder );

        };

    }(),

    equals: function ( euler ) {

        return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

    },

    fromArray: function ( array ) {

        this._x = array[ 0 ];
        this._y = array[ 1 ];
        this._z = array[ 2 ];
        if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

        this.onChangeCallback();

        return this;

    },

    toArray: function ( array, offset ) {

        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this._x;
        array[ offset + 1 ] = this._y;
        array[ offset + 2 ] = this._z;
        array[ offset + 3 ] = this._order;

        return array;

    },

    toVector3: function ( optionalResult ) {

        if ( optionalResult ) {

            return optionalResult.set( this._x, this._y, this._z );

        } else {

            return new THREE.Vector3( this._x, this._y, this._z );

        }

    },

    onChange: function ( callback ) {

        this.onChangeCallback = callback;

        return this;

    },

    onChangeCallback: function () {}

};

// File:src/math/Line3.js

/**
 * @author bhouston / http://clara.io
 */

THREE.Line3 = function ( start, end ) {

    this.start = ( start !== undefined ) ? start : new THREE.Vector3();
    this.end = ( end !== undefined ) ? end : new THREE.Vector3();

};

THREE.Line3.prototype = {

    constructor: THREE.Line3,

    set: function ( start, end ) {

        this.start.copy( start );
        this.end.copy( end );

        return this;

    },

    clone: function () {

        return new this.constructor().copy( this );

    },

    copy: function ( line ) {

        this.start.copy( line.start );
        this.end.copy( line.end );

        return this;

    },

    center: function ( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

    },

    delta: function ( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.subVectors( this.end, this.start );

    },

    distanceSq: function () {

        return this.start.distanceToSquared( this.end );

    },

    distance: function () {

        return this.start.distanceTo( this.end );

    },

    at: function ( t, optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();

        return this.delta( result ).multiplyScalar( t ).add( this.start );

    },

    closestPointToPointParameter: function () {

        var startP = new THREE.Vector3();
        var startEnd = new THREE.Vector3();

        return function ( point, clampToLine ) {

            startP.subVectors( point, this.start );
            startEnd.subVectors( this.end, this.start );

            var startEnd2 = startEnd.dot( startEnd );
            var startEnd_startP = startEnd.dot( startP );

            var t = startEnd_startP / startEnd2;

            if ( clampToLine ) {

                t = THREE.Math.clamp( t, 0, 1 );

            }

            return t;

        };

    }(),

    closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

        var t = this.closestPointToPointParameter( point, clampToLine );

        var result = optionalTarget || new THREE.Vector3();

        return this.delta( result ).multiplyScalar( t ).add( this.start );

    },

    applyMatrix4: function ( matrix ) {

        this.start.applyMatrix4( matrix );
        this.end.applyMatrix4( matrix );

        return this;

    },

    equals: function ( line ) {

        return line.start.equals( this.start ) && line.end.equals( this.end );

    }

};

// File:src/math/Box2.js

/**
 * @author bhouston / http://clara.io
 */

THREE.Box2 = function ( min, max ) {

    this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );
    this.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );

};

THREE.Box2.prototype = {

    constructor: THREE.Box2,

    set: function ( min, max ) {

        this.min.copy( min );
        this.max.copy( max );

        return this;

    },

    setFromPoints: function ( points ) {

        this.makeEmpty();

        for ( var i = 0, il = points.length; i < il; i ++ ) {

            this.expandByPoint( points[ i ] )

        }

        return this;

    },

    setFromCenterAndSize: function () {

        var v1 = new THREE.Vector2();

        return function ( center, size ) {

            var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
            this.min.copy( center ).sub( halfSize );
            this.max.copy( center ).add( halfSize );

            return this;

        };

    }(),

    clone: function () {

        return new this.constructor().copy( this );

    },

    copy: function ( box ) {

        this.min.copy( box.min );
        this.max.copy( box.max );

        return this;

    },

    makeEmpty: function () {

        this.min.x = this.min.y = Infinity;
        this.max.x = this.max.y = - Infinity;

        return this;

    },

    empty: function () {

        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

        return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

    },

    center: function ( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector2();
        return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

    },

    size: function ( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector2();
        return result.subVectors( this.max, this.min );

    },

    expandByPoint: function ( point ) {

        this.min.min( point );
        this.max.max( point );

        return this;

    },

    expandByVector: function ( vector ) {

        this.min.sub( vector );
        this.max.add( vector );

        return this;

    },

    expandByScalar: function ( scalar ) {

        this.min.addScalar( - scalar );
        this.max.addScalar( scalar );

        return this;

    },

    containsPoint: function ( point ) {

        if ( point.x < this.min.x || point.x > this.max.x ||
            point.y < this.min.y || point.y > this.max.y ) {

            return false;

        }

        return true;

    },

    containsBox: function ( box ) {

        if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
            ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

            return true;

        }

        return false;

    },

    getParameter: function ( point, optionalTarget ) {

        // This can potentially have a divide by zero if the box
        // has a size dimension of 0.

        var result = optionalTarget || new THREE.Vector2();

        return result.set(
            ( point.x - this.min.x ) / ( this.max.x - this.min.x ),
            ( point.y - this.min.y ) / ( this.max.y - this.min.y )
        );

    },

    isIntersectionBox: function ( box ) {

        // using 6 splitting planes to rule out intersections.

        if ( box.max.x < this.min.x || box.min.x > this.max.x ||
            box.max.y < this.min.y || box.min.y > this.max.y ) {

            return false;

        }

        return true;

    },

    clampPoint: function ( point, optionalTarget ) {

        var result = optionalTarget || new THREE.Vector2();
        return result.copy( point ).clamp( this.min, this.max );

    },

    distanceToPoint: function () {

        var v1 = new THREE.Vector2();

        return function ( point ) {

            var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
            return clampedPoint.sub( point ).length();

        };

    }(),

    intersect: function ( box ) {

        this.min.max( box.min );
        this.max.min( box.max );

        return this;

    },

    union: function ( box ) {

        this.min.min( box.min );
        this.max.max( box.max );

        return this;

    },

    translate: function ( offset ) {

        this.min.add( offset );
        this.max.add( offset );

        return this;

    },

    equals: function ( box ) {

        return box.min.equals( this.min ) && box.max.equals( this.max );

    }

};

// File:src/math/Box3.js

/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Box3 = function ( min, max ) {

    this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );
    this.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );

};

THREE.Box3.prototype = {

    constructor: THREE.Box3,

    set: function ( min, max ) {

        this.min.copy( min );
        this.max.copy( max );

        return this;

    },

    setFromPoints: function ( points ) {

        this.makeEmpty();

        for ( var i = 0, il = points.length; i < il; i ++ ) {

            this.expandByPoint( points[ i ] );

        }

        return this;

    },

    setFromCenterAndSize: function () {

        var v1 = new THREE.Vector3();

        return function ( center, size ) {

            var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

            this.min.copy( center ).sub( halfSize );
            this.max.copy( center ).add( halfSize );

            return this;

        };

    }(),

    setFromObject: function () {

        // Computes the world-axis-aligned bounding box of an object (including its children),
        // accounting for both the object's, and children's, world transforms

        var v1 = new THREE.Vector3();

        return function ( object ) {

            var scope = this;

            object.updateMatrixWorld( true );

            this.makeEmpty();

            object.traverse( function ( node ) {

                var geometry = node.geometry;

                if ( geometry !== undefined ) {

                    if ( geometry instanceof THREE.Geometry ) {

                        var vertices = geometry.vertices;

                        for ( var i = 0, il = vertices.length; i < il; i ++ ) {

                            v1.copy( vertices[ i ] );

                            v1.applyMatrix4( node.matrixWorld );

                            scope.expandByPoint( v1 );

                        }

                    } else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {

                        var positions = geometry.attributes[ 'position' ].array;

                        for ( var i = 0, il = positions.length; i < il; i += 3 ) {

                            v1.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );

                            v1.applyMatrix4( node.matrixWorld );

                            scope.expandByPoint( v1 );

                        }

                    }

                }

            } );

            return this;

        };

    }(),

    clone: function () {

        return new this.constructor().copy( this );

    },

    copy: function ( box ) {

        this.min.copy( box.min );
        this.max.copy( box.max );

        return this;

    },

    makeEmpty: function () {

        this.min.x = this.min.y = this.min.z = Infinity;
        this.max.x = this.max.y = this.max.z = - Infinity;

        return this;

    },

    empty: function () {

        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

        return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

    },

    center: function ( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

    },

    size: function ( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.subVectors( this.max, this.min );

    },

    expandByPoint: function ( point ) {

        this.min.min( point );
        this.max.max( point );

        return this;

    },

    expandByVector: function ( vector ) {

        this.min.sub( vector );
        this.max.add( vector );

        return this;

    },

    expandByScalar: function ( scalar ) {

        this.min.addScalar( - scalar );
        this.max.addScalar( scalar );

        return this;

    },

    containsPoint: function ( point ) {

        if ( point.x < this.min.x || point.x > this.max.x ||
            point.y < this.min.y || point.y > this.max.y ||
            point.z < this.min.z || point.z > this.max.z ) {

            return false;

        }

        return true;

    },

    containsBox: function ( box ) {

        if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
            ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
            ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

            return true;

        }

        return false;

    },

    getParameter: function ( point, optionalTarget ) {

        // This can potentially have a divide by zero if the box
        // has a size dimension of 0.

        var result = optionalTarget || new THREE.Vector3();

        return result.set(
            ( point.x - this.min.x ) / ( this.max.x - this.min.x ),
            ( point.y - this.min.y ) / ( this.max.y - this.min.y ),
            ( point.z - this.min.z ) / ( this.max.z - this.min.z )
        );

    },

    isIntersectionBox: function ( box ) {

        // using 6 splitting planes to rule out intersections.

        if ( box.max.x < this.min.x || box.min.x > this.max.x ||
            box.max.y < this.min.y || box.min.y > this.max.y ||
            box.max.z < this.min.z || box.min.z > this.max.z ) {

            return false;

        }

        return true;

    },

    clampPoint: function ( point, optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.copy( point ).clamp( this.min, this.max );

    },

    distanceToPoint: function () {

        var v1 = new THREE.Vector3();

        return function ( point ) {

            var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
            return clampedPoint.sub( point ).length();

        };

    }(),

    getBoundingSphere: function () {

        var v1 = new THREE.Vector3();

        return function ( optionalTarget ) {

            var result = optionalTarget || new THREE.Sphere();

            result.center = this.center();
            result.radius = this.size( v1 ).length() * 0.5;

            return result;

        };

    }(),

    intersect: function ( box ) {

        this.min.max( box.min );
        this.max.min( box.max );

        return this;

    },

    union: function ( box ) {

        this.min.min( box.min );
        this.max.max( box.max );

        return this;

    },

    applyMatrix4: function () {

        var points = [
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3()
        ];

        return function ( matrix ) {

            // NOTE: I am using a binary pattern to specify all 2^3 combinations below
            points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
            points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
            points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
            points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
            points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
            points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
            points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
            points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111

            this.makeEmpty();
            this.setFromPoints( points );

            return this;

        };

    }(),

    translate: function ( offset ) {

        this.min.add( offset );
        this.max.add( offset );

        return this;

    },

    equals: function ( box ) {

        return box.min.equals( this.min ) && box.max.equals( this.max );

    }

};

// File:src/math/Matrix3.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

THREE.Matrix3 = function () {

    this.elements = new Float32Array( [

        1, 0, 0,
        0, 1, 0,
        0, 0, 1

    ] );

    if ( arguments.length > 0 ) {

        console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

    }

};

THREE.Matrix3.prototype = {

    constructor: THREE.Matrix3,

    set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

        var te = this.elements;

        te[ 0 ] = n11; te[ 3 ] = n12; te[ 6 ] = n13;
        te[ 1 ] = n21; te[ 4 ] = n22; te[ 7 ] = n23;
        te[ 2 ] = n31; te[ 5 ] = n32; te[ 8 ] = n33;

        return this;

    },

    identity: function () {

        this.set(

            1, 0, 0,
            0, 1, 0,
            0, 0, 1

        );

        return this;

    },

    clone: function () {

        return new this.constructor().fromArray( this.elements );

    },

    copy: function ( m ) {

        var me = m.elements;

        this.set(

            me[ 0 ], me[ 3 ], me[ 6 ],
            me[ 1 ], me[ 4 ], me[ 7 ],
            me[ 2 ], me[ 5 ], me[ 8 ]

        );

        return this;

    },

    multiplyVector3: function ( vector ) {

        console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
        return vector.applyMatrix3( this );

    },

    multiplyVector3Array: function ( a ) {

        console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
        return this.applyToVector3Array( a );

    },

    applyToVector3Array: function () {

        var v1;

        return function ( array, offset, length ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();
            if ( offset === undefined ) offset = 0;
            if ( length === undefined ) length = array.length;

            for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

                v1.fromArray( array, j );
                v1.applyMatrix3( this );
                v1.toArray( array, j );

            }

            return array;

        };

    }(),

    applyToBuffer: function () {

        var v1;

        return function applyToBuffer( buffer, offset, length ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();
            if ( offset === undefined ) offset = 0;
            if ( length === undefined ) length = buffer.length / buffer.itemSize;

            for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

                v1.x = buffer.getX( j );
                v1.y = buffer.getY( j );
                v1.z = buffer.getZ( j );

                v1.applyMatrix3( this );

                buffer.setXYZ( v1.x, v1.y, v1.z );

            }

            return buffer;

        };

    }(),

    multiplyScalar: function ( s ) {

        var te = this.elements;

        te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
        te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
        te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

        return this;

    },

    determinant: function () {

        var te = this.elements;

        var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
            d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
            g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

        return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

    },

    getInverse: function ( matrix, throwOnInvertible ) {

        // input: THREE.Matrix4
        // ( based on http://code.google.com/p/webgl-mjs/ )

        var me = matrix.elements;
        var te = this.elements;

        te[ 0 ] =   me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];
        te[ 1 ] = - me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];
        te[ 2 ] =   me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];
        te[ 3 ] = - me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];
        te[ 4 ] =   me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];
        te[ 5 ] = - me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];
        te[ 6 ] =   me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];
        te[ 7 ] = - me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];
        te[ 8 ] =   me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];

        var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];

        // no inverse

        if ( det === 0 ) {

            var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";

            if ( throwOnInvertible || false ) {

                throw new Error( msg );

            } else {

                console.warn( msg );

            }

            this.identity();

            return this;

        }

        this.multiplyScalar( 1.0 / det );

        return this;

    },

    transpose: function () {

        var tmp, m = this.elements;

        tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
        tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
        tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

        return this;

    },

    flattenToArrayOffset: function ( array, offset ) {

        var te = this.elements;

        array[ offset ] = te[ 0 ];
        array[ offset + 1 ] = te[ 1 ];
        array[ offset + 2 ] = te[ 2 ];

        array[ offset + 3 ] = te[ 3 ];
        array[ offset + 4 ] = te[ 4 ];
        array[ offset + 5 ] = te[ 5 ];

        array[ offset + 6 ] = te[ 6 ];
        array[ offset + 7 ] = te[ 7 ];
        array[ offset + 8 ]  = te[ 8 ];

        return array;

    },

    getNormalMatrix: function ( m ) {

        // input: THREE.Matrix4

        this.getInverse( m ).transpose();

        return this;

    },

    transposeIntoArray: function ( r ) {

        var m = this.elements;

        r[ 0 ] = m[ 0 ];
        r[ 1 ] = m[ 3 ];
        r[ 2 ] = m[ 6 ];
        r[ 3 ] = m[ 1 ];
        r[ 4 ] = m[ 4 ];
        r[ 5 ] = m[ 7 ];
        r[ 6 ] = m[ 2 ];
        r[ 7 ] = m[ 5 ];
        r[ 8 ] = m[ 8 ];

        return this;

    },

    fromArray: function ( array ) {

        this.elements.set( array );

        return this;

    },

    toArray: function () {

        var te = this.elements;

        return [
            te[ 0 ], te[ 1 ], te[ 2 ],
            te[ 3 ], te[ 4 ], te[ 5 ],
            te[ 6 ], te[ 7 ], te[ 8 ]
        ];

    }

};

// File:src/math/Matrix4.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Matrix4 = function () {

    this.elements = new Float32Array( [

        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1

    ] );

    if ( arguments.length > 0 ) {

        console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

    }

};

THREE.Matrix4.prototype = {

    constructor: THREE.Matrix4,

    set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

        var te = this.elements;

        te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
        te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
        te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
        te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

        return this;

    },

    identity: function () {

        this.set(

            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1

        );

        return this;

    },

    clone: function () {

        return new THREE.Matrix4().fromArray( this.elements );

    },

    copy: function ( m ) {

        this.elements.set( m.elements );

        return this;

    },

    extractPosition: function ( m ) {

        console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
        return this.copyPosition( m );

    },

    copyPosition: function ( m ) {

        var te = this.elements;
        var me = m.elements;

        te[ 12 ] = me[ 12 ];
        te[ 13 ] = me[ 13 ];
        te[ 14 ] = me[ 14 ];

        return this;

    },

    extractBasis: function ( xAxis, yAxis, zAxis ) {

        var te = this.elements;

        xAxis.set( te[ 0 ], te[ 1 ], te[ 2 ] );
        yAxis.set( te[ 4 ], te[ 5 ], te[ 6 ] );
        zAxis.set( te[ 8 ], te[ 9 ], te[ 10 ] );

        return this;

    },

    makeBasis: function ( xAxis, yAxis, zAxis ) {

        this.set(
            xAxis.x, yAxis.x, zAxis.x, 0,
            xAxis.y, yAxis.y, zAxis.y, 0,
            xAxis.z, yAxis.z, zAxis.z, 0,
            0,       0,       0,       1
        );

        return this;

    },

    extractRotation: function () {

        var v1;

        return function ( m ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();

            var te = this.elements;
            var me = m.elements;

            var scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();
            var scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();
            var scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();

            te[ 0 ] = me[ 0 ] * scaleX;
            te[ 1 ] = me[ 1 ] * scaleX;
            te[ 2 ] = me[ 2 ] * scaleX;

            te[ 4 ] = me[ 4 ] * scaleY;
            te[ 5 ] = me[ 5 ] * scaleY;
            te[ 6 ] = me[ 6 ] * scaleY;

            te[ 8 ] = me[ 8 ] * scaleZ;
            te[ 9 ] = me[ 9 ] * scaleZ;
            te[ 10 ] = me[ 10 ] * scaleZ;

            return this;

        };

    }(),

    makeRotationFromEuler: function ( euler ) {

        if ( euler instanceof THREE.Euler === false ) {

            console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

        }

        var te = this.elements;

        var x = euler.x, y = euler.y, z = euler.z;
        var a = Math.cos( x ), b = Math.sin( x );
        var c = Math.cos( y ), d = Math.sin( y );
        var e = Math.cos( z ), f = Math.sin( z );

        if ( euler.order === 'XYZ' ) {

            var ae = a * e, af = a * f, be = b * e, bf = b * f;

            te[ 0 ] = c * e;
            te[ 4 ] = - c * f;
            te[ 8 ] = d;

            te[ 1 ] = af + be * d;
            te[ 5 ] = ae - bf * d;
            te[ 9 ] = - b * c;

            te[ 2 ] = bf - ae * d;
            te[ 6 ] = be + af * d;
            te[ 10 ] = a * c;

        } else if ( euler.order === 'YXZ' ) {

            var ce = c * e, cf = c * f, de = d * e, df = d * f;

            te[ 0 ] = ce + df * b;
            te[ 4 ] = de * b - cf;
            te[ 8 ] = a * d;

            te[ 1 ] = a * f;
            te[ 5 ] = a * e;
            te[ 9 ] = - b;

            te[ 2 ] = cf * b - de;
            te[ 6 ] = df + ce * b;
            te[ 10 ] = a * c;

        } else if ( euler.order === 'ZXY' ) {

            var ce = c * e, cf = c * f, de = d * e, df = d * f;

            te[ 0 ] = ce - df * b;
            te[ 4 ] = - a * f;
            te[ 8 ] = de + cf * b;

            te[ 1 ] = cf + de * b;
            te[ 5 ] = a * e;
            te[ 9 ] = df - ce * b;

            te[ 2 ] = - a * d;
            te[ 6 ] = b;
            te[ 10 ] = a * c;

        } else if ( euler.order === 'ZYX' ) {

            var ae = a * e, af = a * f, be = b * e, bf = b * f;

            te[ 0 ] = c * e;
            te[ 4 ] = be * d - af;
            te[ 8 ] = ae * d + bf;

            te[ 1 ] = c * f;
            te[ 5 ] = bf * d + ae;
            te[ 9 ] = af * d - be;

            te[ 2 ] = - d;
            te[ 6 ] = b * c;
            te[ 10 ] = a * c;

        } else if ( euler.order === 'YZX' ) {

            var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

            te[ 0 ] = c * e;
            te[ 4 ] = bd - ac * f;
            te[ 8 ] = bc * f + ad;

            te[ 1 ] = f;
            te[ 5 ] = a * e;
            te[ 9 ] = - b * e;

            te[ 2 ] = - d * e;
            te[ 6 ] = ad * f + bc;
            te[ 10 ] = ac - bd * f;

        } else if ( euler.order === 'XZY' ) {

            var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

            te[ 0 ] = c * e;
            te[ 4 ] = - f;
            te[ 8 ] = d * e;

            te[ 1 ] = ac * f + bd;
            te[ 5 ] = a * e;
            te[ 9 ] = ad * f - bc;

            te[ 2 ] = bc * f - ad;
            te[ 6 ] = b * e;
            te[ 10 ] = bd * f + ac;

        }

        // last column
        te[ 3 ] = 0;
        te[ 7 ] = 0;
        te[ 11 ] = 0;

        // bottom row
        te[ 12 ] = 0;
        te[ 13 ] = 0;
        te[ 14 ] = 0;
        te[ 15 ] = 1;

        return this;

    },

    setRotationFromQuaternion: function ( q ) {

        console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );

        return this.makeRotationFromQuaternion( q );

    },

    makeRotationFromQuaternion: function ( q ) {

        var te = this.elements;

        var x = q.x, y = q.y, z = q.z, w = q.w;
        var x2 = x + x, y2 = y + y, z2 = z + z;
        var xx = x * x2, xy = x * y2, xz = x * z2;
        var yy = y * y2, yz = y * z2, zz = z * z2;
        var wx = w * x2, wy = w * y2, wz = w * z2;

        te[ 0 ] = 1 - ( yy + zz );
        te[ 4 ] = xy - wz;
        te[ 8 ] = xz + wy;

        te[ 1 ] = xy + wz;
        te[ 5 ] = 1 - ( xx + zz );
        te[ 9 ] = yz - wx;

        te[ 2 ] = xz - wy;
        te[ 6 ] = yz + wx;
        te[ 10 ] = 1 - ( xx + yy );

        // last column
        te[ 3 ] = 0;
        te[ 7 ] = 0;
        te[ 11 ] = 0;

        // bottom row
        te[ 12 ] = 0;
        te[ 13 ] = 0;
        te[ 14 ] = 0;
        te[ 15 ] = 1;

        return this;

    },

    lookAt: function () {

        var x, y, z;

        return function ( eye, target, up ) {

            if ( x === undefined ) x = new THREE.Vector3();
            if ( y === undefined ) y = new THREE.Vector3();
            if ( z === undefined ) z = new THREE.Vector3();

            var te = this.elements;

            z.subVectors( eye, target ).normalize();

            if ( z.lengthSq() === 0 ) {

                z.z = 1;

            }

            x.crossVectors( up, z ).normalize();

            if ( x.lengthSq() === 0 ) {

                z.x += 0.0001;
                x.crossVectors( up, z ).normalize();

            }

            y.crossVectors( z, x );


            te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
            te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
            te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

            return this;

        };

    }(),

    multiply: function ( m, n ) {

        if ( n !== undefined ) {

            console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
            return this.multiplyMatrices( m, n );

        }

        return this.multiplyMatrices( this, m );

    },

    multiplyMatrices: function ( a, b ) {

        var ae = a.elements;
        var be = b.elements;
        var te = this.elements;

        var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
        var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
        var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
        var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

        var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
        var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
        var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
        var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

        te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

        te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

        te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

        te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

        return this;

    },

    multiplyToArray: function ( a, b, r ) {

        var te = this.elements;

        this.multiplyMatrices( a, b );

        r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
        r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
        r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
        r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];

        return this;

    },

    multiplyScalar: function ( s ) {

        var te = this.elements;

        te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
        te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
        te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
        te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

        return this;

    },

    multiplyVector3: function ( vector ) {

        console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
        return vector.applyProjection( this );

    },

    multiplyVector4: function ( vector ) {

        console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
        return vector.applyMatrix4( this );

    },

    multiplyVector3Array: function ( a ) {

        console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
        return this.applyToVector3Array( a );

    },

    applyToVector3Array: function () {

        var v1;

        return function ( array, offset, length ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();
            if ( offset === undefined ) offset = 0;
            if ( length === undefined ) length = array.length;

            for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

                v1.fromArray( array, j );
                v1.applyMatrix4( this );
                v1.toArray( array, j );

            }

            return array;

        };

    }(),

    applyToBuffer: function () {

        var v1;

        return function applyToBuffer( buffer, offset, length ) {

            if ( v1 === undefined ) v1 = new THREE.Vector3();
            if ( offset === undefined ) offset = 0;
            if ( length === undefined ) length = buffer.length / buffer.itemSize;

            for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

                v1.x = buffer.getX( j );
                v1.y = buffer.getY( j );
                v1.z = buffer.getZ( j );

                v1.applyMatrix4( this );

                buffer.setXYZ( v1.x, v1.y, v1.z );

            }

            return buffer;

        };

    }(),

    rotateAxis: function ( v ) {

        console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );

        v.transformDirection( this );

    },

    crossVector: function ( vector ) {

        console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
        return vector.applyMatrix4( this );

    },

    determinant: function () {

        var te = this.elements;

        var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
        var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
        var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
        var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

        //TODO: make this more efficient
        //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

        return (
            n41 * (
                + n14 * n23 * n32
                - n13 * n24 * n32
                - n14 * n22 * n33
                + n12 * n24 * n33
                + n13 * n22 * n34
                - n12 * n23 * n34
            ) +
            n42 * (
                + n11 * n23 * n34
                - n11 * n24 * n33
                + n14 * n21 * n33
                - n13 * n21 * n34
                + n13 * n24 * n31
                - n14 * n23 * n31
            ) +
            n43 * (
                + n11 * n24 * n32
                - n11 * n22 * n34
                - n14 * n21 * n32
                + n12 * n21 * n34
                + n14 * n22 * n31
                - n12 * n24 * n31
            ) +
            n44 * (
                - n13 * n22 * n31
                - n11 * n23 * n32
                + n11 * n22 * n33
                + n13 * n21 * n32
                - n12 * n21 * n33
                + n12 * n23 * n31
            )

        );

    },

    transpose: function () {

        var te = this.elements;
        var tmp;

        tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
        tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
        tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

        tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
        tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
        tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

        return this;

    },

    flattenToArrayOffset: function ( array, offset ) {

        var te = this.elements;

        array[ offset ] = te[ 0 ];
        array[ offset + 1 ] = te[ 1 ];
        array[ offset + 2 ] = te[ 2 ];
        array[ offset + 3 ] = te[ 3 ];

        array[ offset + 4 ] = te[ 4 ];
        array[ offset + 5 ] = te[ 5 ];
        array[ offset + 6 ] = te[ 6 ];
        array[ offset + 7 ] = te[ 7 ];

        array[ offset + 8 ]  = te[ 8 ];
        array[ offset + 9 ]  = te[ 9 ];
        array[ offset + 10 ] = te[ 10 ];
        array[ offset + 11 ] = te[ 11 ];

        array[ offset + 12 ] = te[ 12 ];
        array[ offset + 13 ] = te[ 13 ];
        array[ offset + 14 ] = te[ 14 ];
        array[ offset + 15 ] = te[ 15 ];

        return array;

    },

    getPosition: function () {

        var v1;

        return function () {

            if ( v1 === undefined ) v1 = new THREE.Vector3();
            console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

            var te = this.elements;
            return v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );

        };

    }(),

    setPosition: function ( v ) {

        var te = this.elements;

        te[ 12 ] = v.x;
        te[ 13 ] = v.y;
        te[ 14 ] = v.z;

        return this;

    },

    getInverse: function ( m, throwOnInvertible ) {

        // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
        var te = this.elements;
        var me = m.elements;

        var n11 = me[ 0 ], n12 = me[ 4 ], n13 = me[ 8 ], n14 = me[ 12 ];
        var n21 = me[ 1 ], n22 = me[ 5 ], n23 = me[ 9 ], n24 = me[ 13 ];
        var n31 = me[ 2 ], n32 = me[ 6 ], n33 = me[ 10 ], n34 = me[ 14 ];
        var n41 = me[ 3 ], n42 = me[ 7 ], n43 = me[ 11 ], n44 = me[ 15 ];

        te[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
        te[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
        te[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
        te[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
        te[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
        te[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
        te[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
        te[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
        te[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
        te[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
        te[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
        te[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
        te[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
        te[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
        te[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
        te[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;

        var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];

        if ( det === 0 ) {

            var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";

            if ( throwOnInvertible || false ) {

                throw new Error( msg );

            } else {

                console.warn( msg );

            }

            this.identity();

            return this;

        }

        this.multiplyScalar( 1 / det );

        return this;

    },

    translate: function ( v ) {

        console.error( 'THREE.Matrix4: .translate() has been removed.' );

    },

    rotateX: function ( angle ) {

        console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

    },

    rotateY: function ( angle ) {

        console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

    },

    rotateZ: function ( angle ) {

        console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

    },

    rotateByAxis: function ( axis, angle ) {

        console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

    },

    scale: function ( v ) {

        var te = this.elements;
        var x = v.x, y = v.y, z = v.z;

        te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
        te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
        te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
        te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

        return this;

    },

    getMaxScaleOnAxis: function () {

        var te = this.elements;

        var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
        var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
        var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

        return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

    },

    makeTranslation: function ( x, y, z ) {

        this.set(

            1, 0, 0, x,
            0, 1, 0, y,
            0, 0, 1, z,
            0, 0, 0, 1

        );

        return this;

    },

    makeRotationX: function ( theta ) {

        var c = Math.cos( theta ), s = Math.sin( theta );

        this.set(

            1, 0,  0, 0,
            0, c, - s, 0,
            0, s,  c, 0,
            0, 0,  0, 1

        );

        return this;

    },

    makeRotationY: function ( theta ) {

        var c = Math.cos( theta ), s = Math.sin( theta );

        this.set(

            c, 0, s, 0,
            0, 1, 0, 0,
            - s, 0, c, 0,
            0, 0, 0, 1

        );

        return this;

    },

    makeRotationZ: function ( theta ) {

        var c = Math.cos( theta ), s = Math.sin( theta );

        this.set(

            c, - s, 0, 0,
            s,  c, 0, 0,
            0,  0, 1, 0,
            0,  0, 0, 1

        );

        return this;

    },

    makeRotationAxis: function ( axis, angle ) {

        // Based on http://www.gamedev.net/reference/articles/article1199.asp

        var c = Math.cos( angle );
        var s = Math.sin( angle );
        var t = 1 - c;
        var x = axis.x, y = axis.y, z = axis.z;
        var tx = t * x, ty = t * y;

        this.set(

            tx * x + c, tx * y - s * z, tx * z + s * y, 0,
            tx * y + s * z, ty * y + c, ty * z - s * x, 0,
            tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
            0, 0, 0, 1

        );

        return this;

    },

    makeScale: function ( x, y, z ) {

        this.set(

            x, 0, 0, 0,
            0, y, 0, 0,
            0, 0, z, 0,
            0, 0, 0, 1

        );

        return this;

    },

    compose: function ( position, quaternion, scale ) {

        this.makeRotationFromQuaternion( quaternion );
        this.scale( scale );
        this.setPosition( position );

        return this;

    },

    decompose: function () {

        var vector, matrix;

        return function ( position, quaternion, scale ) {

            if ( vector === undefined ) vector = new THREE.Vector3();
            if ( matrix === undefined ) matrix = new THREE.Matrix4();

            var te = this.elements;

            var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
            var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
            var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

            // if determine is negative, we need to invert one scale
            var det = this.determinant();
            if ( det < 0 ) {

                sx = - sx;

            }

            position.x = te[ 12 ];
            position.y = te[ 13 ];
            position.z = te[ 14 ];

            // scale the rotation part

            matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

            var invSX = 1 / sx;
            var invSY = 1 / sy;
            var invSZ = 1 / sz;

            matrix.elements[ 0 ] *= invSX;
            matrix.elements[ 1 ] *= invSX;
            matrix.elements[ 2 ] *= invSX;

            matrix.elements[ 4 ] *= invSY;
            matrix.elements[ 5 ] *= invSY;
            matrix.elements[ 6 ] *= invSY;

            matrix.elements[ 8 ] *= invSZ;
            matrix.elements[ 9 ] *= invSZ;
            matrix.elements[ 10 ] *= invSZ;

            quaternion.setFromRotationMatrix( matrix );

            scale.x = sx;
            scale.y = sy;
            scale.z = sz;

            return this;

        };

    }(),

    makeFrustum: function ( left, right, bottom, top, near, far ) {

        var te = this.elements;
        var x = 2 * near / ( right - left );
        var y = 2 * near / ( top - bottom );

        var a = ( right + left ) / ( right - left );
        var b = ( top + bottom ) / ( top - bottom );
        var c = - ( far + near ) / ( far - near );
        var d = - 2 * far * near / ( far - near );

        te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
        te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
        te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
        te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

        return this;

    },

    makePerspective: function ( fov, aspect, near, far ) {

        var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
        var ymin = - ymax;
        var xmin = ymin * aspect;
        var xmax = ymax * aspect;

        return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

    },

    makeOrthographic: function ( left, right, top, bottom, near, far ) {

        var te = this.elements;
        var w = right - left;
        var h = top - bottom;
        var p = far - near;

        var x = ( right + left ) / w;
        var y = ( top + bottom ) / h;
        var z = ( far + near ) / p;

        te[ 0 ] = 2 / w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
        te[ 1 ] = 0;	te[ 5 ] = 2 / h;	te[ 9 ] = 0;	te[ 13 ] = - y;
        te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 / p;	te[ 14 ] = - z;
        te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

        return this;

    },

    equals: function ( matrix ) {

        var te = this.elements;
        var me = matrix.elements;

        for ( var i = 0; i < 16; i ++ ) {

            if ( te[ i ] !== me[ i ] ) return false;

        }

        return true;

    },

    fromArray: function ( array ) {

        this.elements.set( array );

        return this;

    },

    toArray: function () {

        var te = this.elements;

        return [
            te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
            te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
            te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
            te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
        ];

    }

};

// File:src/math/Ray.js

/**
 * @author bhouston / http://clara.io
 */

THREE.Ray = function ( origin, direction ) {

    this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
    this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();

};

THREE.Ray.prototype = {

    constructor: THREE.Ray,

    set: function ( origin, direction ) {

        this.origin.copy( origin );
        this.direction.copy( direction );

        return this;

    },

    clone: function () {

        return new this.constructor().copy( this );

    },

    copy: function ( ray ) {

        this.origin.copy( ray.origin );
        this.direction.copy( ray.direction );

        return this;

    },

    at: function ( t, optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();

        return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

    },

    recast: function () {

        var v1 = new THREE.Vector3();

        return function ( t ) {

            this.origin.copy( this.at( t, v1 ) );

            return this;

        };

    }(),

    closestPointToPoint: function ( point, optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        result.subVectors( point, this.origin );
        var directionDistance = result.dot( this.direction );

        if ( directionDistance < 0 ) {

            return result.copy( this.origin );

        }

        return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

    },

    distanceToPoint: function ( point ) {

        return Math.sqrt( this.distanceSqToPoint( point ) );

    },

    distanceSqToPoint: function () {

        var v1 = new THREE.Vector3();

        return function ( point ) {

            var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

            // point behind the ray

            if ( directionDistance < 0 ) {

                return this.origin.distanceToSquared( point );

            }

            v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

            return v1.distanceToSquared( point );

        };

    }(),

    distanceSqToSegment: function () {

        var segCenter = new THREE.Vector3();
        var segDir = new THREE.Vector3();
        var diff = new THREE.Vector3();

        return function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

            // from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
            // It returns the min distance between the ray and the segment
            // defined by v0 and v1
            // It can also set two optional targets :
            // - The closest point on the ray
            // - The closest point on the segment

            segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
            segDir.copy( v1 ).sub( v0 ).normalize();
            diff.copy( this.origin ).sub( segCenter );

            var segExtent = v0.distanceTo( v1 ) * 0.5;
            var a01 = - this.direction.dot( segDir );
            var b0 = diff.dot( this.direction );
            var b1 = - diff.dot( segDir );
            var c = diff.lengthSq();
            var det = Math.abs( 1 - a01 * a01 );
            var s0, s1, sqrDist, extDet;

            if ( det > 0 ) {

                // The ray and segment are not parallel.

                s0 = a01 * b1 - b0;
                s1 = a01 * b0 - b1;
                extDet = segExtent * det;

                if ( s0 >= 0 ) {

                    if ( s1 >= - extDet ) {

                        if ( s1 <= extDet ) {

                            // region 0
                            // Minimum at interior points of ray and segment.

                            var invDet = 1 / det;
                            s0 *= invDet;
                            s1 *= invDet;
                            sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

                        } else {

                            // region 1

                            s1 = segExtent;
                            s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
                            sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

                        }

                    } else {

                        // region 5

                        s1 = - segExtent;
                        s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
                        sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

                    }

                } else {

                    if ( s1 <= - extDet ) {

                        // region 4

                        s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
                        s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
                        sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

                    } else if ( s1 <= extDet ) {

                        // region 3

                        s0 = 0;
                        s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
                        sqrDist = s1 * ( s1 + 2 * b1 ) + c;

                    } else {

                        // region 2

                        s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
                        s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
                        sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

                    }

                }

            } else {

                // Ray and segment are parallel.

                s1 = ( a01 > 0 ) ? - segExtent : segExtent;
                s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
                sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

            }

            if ( optionalPointOnRay ) {

                optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

            }

            if ( optionalPointOnSegment ) {

                optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

            }

            return sqrDist;

        };

    }(),


    isIntersectionSphere: function ( sphere ) {

        return this.distanceToPoint( sphere.center ) <= sphere.radius;

    },

    intersectSphere: function () {

        // from http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/

        var v1 = new THREE.Vector3();

        return function ( sphere, optionalTarget ) {

            v1.subVectors( sphere.center, this.origin );

            var tca = v1.dot( this.direction );

            var d2 = v1.dot( v1 ) - tca * tca;

            var radius2 = sphere.radius * sphere.radius;

            if ( d2 > radius2 ) return null;

            var thc = Math.sqrt( radius2 - d2 );

            // t0 = first intersect point - entrance on front of sphere
            var t0 = tca - thc;

            // t1 = second intersect point - exit point on back of sphere
            var t1 = tca + thc;

            // test to see if both t0 and t1 are behind the ray - if so, return null
            if ( t0 < 0 && t1 < 0 ) return null;

            // test to see if t0 is behind the ray:
            // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
            // in order to always return an intersect point that is in front of the ray.
            if ( t0 < 0 ) return this.at( t1, optionalTarget );

            // else t0 is in front of the ray, so return the first collision point scaled by t0
            return this.at( t0, optionalTarget );

        }

    }(),

    isIntersectionPlane: function ( plane ) {

        // check if the ray lies on the plane first

        var distToPoint = plane.distanceToPoint( this.origin );

        if ( distToPoint === 0 ) {

            return true;

        }

        var denominator = plane.normal.dot( this.direction );

        if ( denominator * distToPoint < 0 ) {

            return true;

        }

        // ray origin is behind the plane (and is pointing behind it)

        return false;

    },

    distanceToPlane: function ( plane ) {

        var denominator = plane.normal.dot( this.direction );
        if ( denominator === 0 ) {

            // line is coplanar, return origin
            if ( plane.distanceToPoint( this.origin ) === 0 ) {

                return 0;

            }

            // Null is preferable to undefined since undefined means.... it is undefined

            return null;

        }

        var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

        // Return if the ray never intersects the plane

        return t >= 0 ? t :  null;

    },

    intersectPlane: function ( plane, optionalTarget ) {

        var t = this.distanceToPlane( plane );

        if ( t === null ) {

            return null;

        }

        return this.at( t, optionalTarget );

    },

    isIntersectionBox: function () {

        var v = new THREE.Vector3();

        return function ( box ) {

            return this.intersectBox( box, v ) !== null;

        };

    }(),

    intersectBox: function ( box, optionalTarget ) {

        // http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/

        var tmin, tmax, tymin, tymax, tzmin, tzmax;

        var invdirx = 1 / this.direction.x,
            invdiry = 1 / this.direction.y,
            invdirz = 1 / this.direction.z;

        var origin = this.origin;

        if ( invdirx >= 0 ) {

            tmin = ( box.min.x - origin.x ) * invdirx;
            tmax = ( box.max.x - origin.x ) * invdirx;

        } else {

            tmin = ( box.max.x - origin.x ) * invdirx;
            tmax = ( box.min.x - origin.x ) * invdirx;

        }

        if ( invdiry >= 0 ) {

            tymin = ( box.min.y - origin.y ) * invdiry;
            tymax = ( box.max.y - origin.y ) * invdiry;

        } else {

            tymin = ( box.max.y - origin.y ) * invdiry;
            tymax = ( box.min.y - origin.y ) * invdiry;

        }

        if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

        // These lines also handle the case where tmin or tmax is NaN
        // (result of 0 * Infinity). x !== x returns true if x is NaN

        if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

        if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

        if ( invdirz >= 0 ) {

            tzmin = ( box.min.z - origin.z ) * invdirz;
            tzmax = ( box.max.z - origin.z ) * invdirz;

        } else {

            tzmin = ( box.max.z - origin.z ) * invdirz;
            tzmax = ( box.min.z - origin.z ) * invdirz;

        }

        if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

        if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

        if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

        //return point closest to the ray (positive side)

        if ( tmax < 0 ) return null;

        return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

    },

    intersectTriangle: function () {

        // Compute the offset origin, edges, and normal.
        var diff = new THREE.Vector3();
        var edge1 = new THREE.Vector3();
        var edge2 = new THREE.Vector3();
        var normal = new THREE.Vector3();

        return function ( a, b, c, backfaceCulling, optionalTarget ) {

            // from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp

            edge1.subVectors( b, a );
            edge2.subVectors( c, a );
            normal.crossVectors( edge1, edge2 );

            // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
            // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
            //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
            //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
            //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
            var DdN = this.direction.dot( normal );
            var sign;

            if ( DdN > 0 ) {

                if ( backfaceCulling ) return null;
                sign = 1;

            } else if ( DdN < 0 ) {

                sign = - 1;
                DdN = - DdN;

            } else {

                return null;

            }

            diff.subVectors( this.origin, a );
            var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

            // b1 < 0, no intersection
            if ( DdQxE2 < 0 ) {

                return null;

            }

            var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

            // b2 < 0, no intersection
            if ( DdE1xQ < 0 ) {

                return null;

            }

            // b1+b2 > 1, no intersection
            if ( DdQxE2 + DdE1xQ > DdN ) {

                return null;

            }

            // Line intersects triangle, check if ray does.
            var QdN = - sign * diff.dot( normal );

            // t < 0, no intersection
            if ( QdN < 0 ) {

                return null;

            }

            // Ray intersects triangle.
            return this.at( QdN / DdN, optionalTarget );

        };

    }(),

    applyMatrix4: function ( matrix4 ) {

        this.direction.add( this.origin ).applyMatrix4( matrix4 );
        this.origin.applyMatrix4( matrix4 );
        this.direction.sub( this.origin );
        this.direction.normalize();

        return this;

    },

    equals: function ( ray ) {

        return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

    }

};

// File:src/math/Sphere.js

/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Sphere = function ( center, radius ) {

    this.center = ( center !== undefined ) ? center : new THREE.Vector3();
    this.radius = ( radius !== undefined ) ? radius : 0;

};

THREE.Sphere.prototype = {

    constructor: THREE.Sphere,

    set: function ( center, radius ) {

        this.center.copy( center );
        this.radius = radius;

        return this;

    },

    setFromPoints: function () {

        var box = new THREE.Box3();

        return function ( points, optionalCenter ) {

            var center = this.center;

            if ( optionalCenter !== undefined ) {

                center.copy( optionalCenter );

            } else {

                box.setFromPoints( points ).center( center );

            }

            var maxRadiusSq = 0;

            for ( var i = 0, il = points.length; i < il; i ++ ) {

                maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

            }

            this.radius = Math.sqrt( maxRadiusSq );

            return this;

        };

    }(),

    clone: function () {

        return new this.constructor().copy( this );

    },

    copy: function ( sphere ) {

        this.center.copy( sphere.center );
        this.radius = sphere.radius;

        return this;

    },

    empty: function () {

        return ( this.radius <= 0 );

    },

    containsPoint: function ( point ) {

        return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

    },

    distanceToPoint: function ( point ) {

        return ( point.distanceTo( this.center ) - this.radius );

    },

    intersectsSphere: function ( sphere ) {

        var radiusSum = this.radius + sphere.radius;

        return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

    },

    clampPoint: function ( point, optionalTarget ) {

        var deltaLengthSq = this.center.distanceToSquared( point );

        var result = optionalTarget || new THREE.Vector3();
        result.copy( point );

        if ( deltaLengthSq > ( this.radius * this.radius ) ) {

            result.sub( this.center ).normalize();
            result.multiplyScalar( this.radius ).add( this.center );

        }

        return result;

    },

    getBoundingBox: function ( optionalTarget ) {

        var box = optionalTarget || new THREE.Box3();

        box.set( this.center, this.center );
        box.expandByScalar( this.radius );

        return box;

    },

    applyMatrix4: function ( matrix ) {

        this.center.applyMatrix4( matrix );
        this.radius = this.radius * matrix.getMaxScaleOnAxis();

        return this;

    },

    translate: function ( offset ) {

        this.center.add( offset );

        return this;

    },

    equals: function ( sphere ) {

        return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

    }

};

// File:src/math/Frustum.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://clara.io
 */

THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {

    this.planes = [

        ( p0 !== undefined ) ? p0 : new THREE.Plane(),
        ( p1 !== undefined ) ? p1 : new THREE.Plane(),
        ( p2 !== undefined ) ? p2 : new THREE.Plane(),
        ( p3 !== undefined ) ? p3 : new THREE.Plane(),
        ( p4 !== undefined ) ? p4 : new THREE.Plane(),
        ( p5 !== undefined ) ? p5 : new THREE.Plane()

    ];

};

THREE.Frustum.prototype = {

    constructor: THREE.Frustum,

    set: function ( p0, p1, p2, p3, p4, p5 ) {

        var planes = this.planes;

        planes[ 0 ].copy( p0 );
        planes[ 1 ].copy( p1 );
        planes[ 2 ].copy( p2 );
        planes[ 3 ].copy( p3 );
        planes[ 4 ].copy( p4 );
        planes[ 5 ].copy( p5 );

        return this;

    },

    clone: function () {

        return new this.constructor().copy( this );

    },

    copy: function ( frustum ) {

        var planes = this.planes;

        for ( var i = 0; i < 6; i ++ ) {

            planes[ i ].copy( frustum.planes[ i ] );

        }

        return this;

    },

    setFromMatrix: function ( m ) {

        var planes = this.planes;
        var me = m.elements;
        var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
        var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
        var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
        var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

        planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
        planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
        planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
        planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
        planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
        planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

        return this;

    },

    intersectsObject: function () {

        var sphere = new THREE.Sphere();

        return function ( object ) {

            var geometry = object.geometry;

            if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

            sphere.copy( geometry.boundingSphere );
            sphere.applyMatrix4( object.matrixWorld );

            return this.intersectsSphere( sphere );

        };

    }(),

    intersectsSphere: function ( sphere ) {

        var planes = this.planes;
        var center = sphere.center;
        var negRadius = - sphere.radius;

        for ( var i = 0; i < 6; i ++ ) {

            var distance = planes[ i ].distanceToPoint( center );

            if ( distance < negRadius ) {

                return false;

            }

        }

        return true;

    },

    intersectsBox: function () {

        var p1 = new THREE.Vector3(),
            p2 = new THREE.Vector3();

        return function ( box ) {

            var planes = this.planes;

            for ( var i = 0; i < 6 ; i ++ ) {

                var plane = planes[ i ];

                p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
                p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
                p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
                p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
                p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
                p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

                var d1 = plane.distanceToPoint( p1 );
                var d2 = plane.distanceToPoint( p2 );

                // if both outside plane, no intersection

                if ( d1 < 0 && d2 < 0 ) {

                    return false;

                }

            }

            return true;

        };

    }(),


    containsPoint: function ( point ) {

        var planes = this.planes;

        for ( var i = 0; i < 6; i ++ ) {

            if ( planes[ i ].distanceToPoint( point ) < 0 ) {

                return false;

            }

        }

        return true;

    }

};

// File:src/math/Plane.js

/**
 * @author bhouston / http://clara.io
 */

THREE.Plane = function ( normal, constant ) {

    this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
    this.constant = ( constant !== undefined ) ? constant : 0;

};

THREE.Plane.prototype = {

    constructor: THREE.Plane,

    set: function ( normal, constant ) {

        this.normal.copy( normal );
        this.constant = constant;

        return this;

    },

    setComponents: function ( x, y, z, w ) {

        this.normal.set( x, y, z );
        this.constant = w;

        return this;

    },

    setFromNormalAndCoplanarPoint: function ( normal, point ) {

        this.normal.copy( normal );
        this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized

        return this;

    },

    setFromCoplanarPoints: function () {

        var v1 = new THREE.Vector3();
        var v2 = new THREE.Vector3();

        return function ( a, b, c ) {

            var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

            // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

            this.setFromNormalAndCoplanarPoint( normal, a );

            return this;

        };

    }(),

    clone: function () {

        return new this.constructor().copy( this );

    },

    copy: function ( plane ) {

        this.normal.copy( plane.normal );
        this.constant = plane.constant;

        return this;

    },

    normalize: function () {

        // Note: will lead to a divide by zero if the plane is invalid.

        var inverseNormalLength = 1.0 / this.normal.length();
        this.normal.multiplyScalar( inverseNormalLength );
        this.constant *= inverseNormalLength;

        return this;

    },

    negate: function () {

        this.constant *= - 1;
        this.normal.negate();

        return this;

    },

    distanceToPoint: function ( point ) {

        return this.normal.dot( point ) + this.constant;

    },

    distanceToSphere: function ( sphere ) {

        return this.distanceToPoint( sphere.center ) - sphere.radius;

    },

    projectPoint: function ( point, optionalTarget ) {

        return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

    },

    orthoPoint: function ( point, optionalTarget ) {

        var perpendicularMagnitude = this.distanceToPoint( point );

        var result = optionalTarget || new THREE.Vector3();
        return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

    },

    isIntersectionLine: function ( line ) {

        // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

        var startSign = this.distanceToPoint( line.start );
        var endSign = this.distanceToPoint( line.end );

        return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

    },

    intersectLine: function () {

        var v1 = new THREE.Vector3();

        return function ( line, optionalTarget ) {

            var result = optionalTarget || new THREE.Vector3();

            var direction = line.delta( v1 );

            var denominator = this.normal.dot( direction );

            if ( denominator === 0 ) {

                // line is coplanar, return origin
                if ( this.distanceToPoint( line.start ) === 0 ) {

                    return result.copy( line.start );

                }

                // Unsure if this is the correct method to handle this case.
                return undefined;

            }

            var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

            if ( t < 0 || t > 1 ) {

                return undefined;

            }

            return result.copy( direction ).multiplyScalar( t ).add( line.start );

        };

    }(),


    coplanarPoint: function ( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.copy( this.normal ).multiplyScalar( - this.constant );

    },

    applyMatrix4: function () {

        var v1 = new THREE.Vector3();
        var v2 = new THREE.Vector3();
        var m1 = new THREE.Matrix3();

        return function ( matrix, optionalNormalMatrix ) {

            // compute new normal based on theory here:
            // http://www.songho.ca/opengl/gl_normaltransform.html
            var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
            var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );

            var newCoplanarPoint = this.coplanarPoint( v2 );
            newCoplanarPoint.applyMatrix4( matrix );

            this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );

            return this;

        };

    }(),

    translate: function ( offset ) {

        this.constant = this.constant - offset.dot( this.normal );

        return this;

    },

    equals: function ( plane ) {

        return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

    }

};

// File:src/math/Math.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Math = {

    generateUUID: function () {

        // http://www.broofa.com/Tools/Math.uuid.htm

        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
        var uuid = new Array( 36 );
        var rnd = 0, r;

        return function () {

            for ( var i = 0; i < 36; i ++ ) {

                if ( i === 8 || i === 13 || i === 18 || i === 23 ) {

                    uuid[ i ] = '-';

                } else if ( i === 14 ) {

                    uuid[ i ] = '4';

                } else {

                    if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
                    r = rnd & 0xf;
                    rnd = rnd >> 4;
                    uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];

                }

            }

            return uuid.join( '' );

        };

    }(),

    clamp: function ( value, min, max ) {

        return Math.max( min, Math.min( max, value ) );

    },

    // compute euclidian modulo of m % n
    // https://en.wikipedia.org/wiki/Modulo_operation

    euclideanModulo: function ( n, m ) {

        return ( ( n % m ) + m ) % m;

    },

    // Linear mapping from range <a1, a2> to range <b1, b2>

    mapLinear: function ( x, a1, a2, b1, b2 ) {

        return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

    },

    // http://en.wikipedia.org/wiki/Smoothstep

    smoothstep: function ( x, min, max ) {

        if ( x <= min ) return 0;
        if ( x >= max ) return 1;

        x = ( x - min ) / ( max - min );

        return x * x * ( 3 - 2 * x );

    },

    smootherstep: function ( x, min, max ) {

        if ( x <= min ) return 0;
        if ( x >= max ) return 1;

        x = ( x - min ) / ( max - min );

        return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

    },

    // Random float from <0, 1> with 16 bits of randomness
    // (standard Math.random() creates repetitive patterns when applied over larger space)

    random16: function () {

        return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;

    },

    // Random integer from <low, high> interval

    randInt: function ( low, high ) {

        return low + Math.floor( Math.random() * ( high - low + 1 ) );

    },

    // Random float from <low, high> interval

    randFloat: function ( low, high ) {

        return low + Math.random() * ( high - low );

    },

    // Random float from <-range/2, range/2> interval

    randFloatSpread: function ( range ) {

        return range * ( 0.5 - Math.random() );

    },

    degToRad: function () {

        var degreeToRadiansFactor = Math.PI / 180;

        return function ( degrees ) {

            return degrees * degreeToRadiansFactor;

        };

    }(),

    radToDeg: function () {

        var radianToDegreesFactor = 180 / Math.PI;

        return function ( radians ) {

            return radians * radianToDegreesFactor;

        };

    }(),

    isPowerOfTwo: function ( value ) {

        return ( value & ( value - 1 ) ) === 0 && value !== 0;

    },

    nearestPowerOfTwo: function ( value ) {

        return Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );

    },

    nextPowerOfTwo: function ( value ) {

        value --;
        value |= value >> 1;
        value |= value >> 2;
        value |= value >> 4;
        value |= value >> 8;
        value |= value >> 16;
        value ++;

        return value;

    }

};

// File:src/math/Spline.js

/**
 * Spline from Tween.js, slightly optimized (and trashed)
 * http://sole.github.com/tween.js/examples/05_spline.html
 *
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Spline = function ( points ) {

    this.points = points;

    var c = [], v3 = { x: 0, y: 0, z: 0 },
        point, intPoint, weight, w2, w3,
        pa, pb, pc, pd;

    this.initFromArray = function ( a ) {

        this.points = [];

        for ( var i = 0; i < a.length; i ++ ) {

            this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

        }

    };

    this.getPoint = function ( k ) {

        point = ( this.points.length - 1 ) * k;
        intPoint = Math.floor( point );
        weight = point - intPoint;

        c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
        c[ 1 ] = intPoint;
        c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
        c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

        pa = this.points[ c[ 0 ] ];
        pb = this.points[ c[ 1 ] ];
        pc = this.points[ c[ 2 ] ];
        pd = this.points[ c[ 3 ] ];

        w2 = weight * weight;
        w3 = weight * w2;

        v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
        v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
        v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

        return v3;

    };

    this.getControlPointsArray = function () {

        var i, p, l = this.points.length,
            coords = [];

        for ( i = 0; i < l; i ++ ) {

            p = this.points[ i ];
            coords[ i ] = [ p.x, p.y, p.z ];

        }

        return coords;

    };

    // approximate length by summing linear segments

    this.getLength = function ( nSubDivisions ) {

        var i, index, nSamples, position,
            point = 0, intPoint = 0, oldIntPoint = 0,
            oldPosition = new THREE.Vector3(),
            tmpVec = new THREE.Vector3(),
            chunkLengths = [],
            totalLength = 0;

        // first point has 0 length

        chunkLengths[ 0 ] = 0;

        if ( ! nSubDivisions ) nSubDivisions = 100;

        nSamples = this.points.length * nSubDivisions;

        oldPosition.copy( this.points[ 0 ] );

        for ( i = 1; i < nSamples; i ++ ) {

            index = i / nSamples;

            position = this.getPoint( index );
            tmpVec.copy( position );

            totalLength += tmpVec.distanceTo( oldPosition );

            oldPosition.copy( position );

            point = ( this.points.length - 1 ) * index;
            intPoint = Math.floor( point );

            if ( intPoint !== oldIntPoint ) {

                chunkLengths[ intPoint ] = totalLength;
                oldIntPoint = intPoint;

            }

        }

        // last point ends with total length

        chunkLengths[ chunkLengths.length ] = totalLength;

        return { chunks: chunkLengths, total: totalLength };

    };

    this.reparametrizeByArcLength = function ( samplingCoef ) {

        var i, j,
            index, indexCurrent, indexNext,
            realDistance,
            sampling, position,
            newpoints = [],
            tmpVec = new THREE.Vector3(),
            sl = this.getLength();

        newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

        for ( i = 1; i < this.points.length; i ++ ) {

            //tmpVec.copy( this.points[ i - 1 ] );
            //linearDistance = tmpVec.distanceTo( this.points[ i ] );

            realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

            sampling = Math.ceil( samplingCoef * realDistance / sl.total );

            indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
            indexNext = i / ( this.points.length - 1 );

            for ( j = 1; j < sampling - 1; j ++ ) {

                index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

                position = this.getPoint( index );
                newpoints.push( tmpVec.copy( position ).clone() );

            }

            newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

        }

        this.points = newpoints;

    };

    // Catmull-Rom

    function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

        var v0 = ( p2 - p0 ) * 0.5,
            v1 = ( p3 - p1 ) * 0.5;

        return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

    }

};

// File:src/math/Triangle.js

/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Triangle = function ( a, b, c ) {

    this.a = ( a !== undefined ) ? a : new THREE.Vector3();
    this.b = ( b !== undefined ) ? b : new THREE.Vector3();
    this.c = ( c !== undefined ) ? c : new THREE.Vector3();

};

THREE.Triangle.normal = function () {

    var v0 = new THREE.Vector3();

    return function ( a, b, c, optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();

        result.subVectors( c, b );
        v0.subVectors( a, b );
        result.cross( v0 );

        var resultLengthSq = result.lengthSq();
        if ( resultLengthSq > 0 ) {

            return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

        }

        return result.set( 0, 0, 0 );

    };

}();

// static/instance method to calculate barycentric coordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
THREE.Triangle.barycoordFromPoint = function () {

    var v0 = new THREE.Vector3();
    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();

    return function ( point, a, b, c, optionalTarget ) {

        v0.subVectors( c, a );
        v1.subVectors( b, a );
        v2.subVectors( point, a );

        var dot00 = v0.dot( v0 );
        var dot01 = v0.dot( v1 );
        var dot02 = v0.dot( v2 );
        var dot11 = v1.dot( v1 );
        var dot12 = v1.dot( v2 );

        var denom = ( dot00 * dot11 - dot01 * dot01 );

        var result = optionalTarget || new THREE.Vector3();

        // collinear or singular triangle
        if ( denom === 0 ) {

            // arbitrary location outside of triangle?
            // not sure if this is the best idea, maybe should be returning undefined
            return result.set( - 2, - 1, - 1 );

        }

        var invDenom = 1 / denom;
        var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
        var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

        // barycentric coordinates must always sum to 1
        return result.set( 1 - u - v, v, u );

    };

}();

THREE.Triangle.containsPoint = function () {

    var v1 = new THREE.Vector3();

    return function ( point, a, b, c ) {

        var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );

        return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

    };

}();

THREE.Triangle.prototype = {

    constructor: THREE.Triangle,

    set: function ( a, b, c ) {

        this.a.copy( a );
        this.b.copy( b );
        this.c.copy( c );

        return this;

    },

    setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

        this.a.copy( points[ i0 ] );
        this.b.copy( points[ i1 ] );
        this.c.copy( points[ i2 ] );

        return this;

    },

    clone: function () {

        return new this.constructor().copy( this );

    },

    copy: function ( triangle ) {

        this.a.copy( triangle.a );
        this.b.copy( triangle.b );
        this.c.copy( triangle.c );

        return this;

    },

    area: function () {

        var v0 = new THREE.Vector3();
        var v1 = new THREE.Vector3();

        return function () {

            v0.subVectors( this.c, this.b );
            v1.subVectors( this.a, this.b );

            return v0.cross( v1 ).length() * 0.5;

        };

    }(),

    midpoint: function ( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();
        return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

    },

    normal: function ( optionalTarget ) {

        return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );

    },

    plane: function ( optionalTarget ) {

        var result = optionalTarget || new THREE.Plane();

        return result.setFromCoplanarPoints( this.a, this.b, this.c );

    },

    barycoordFromPoint: function ( point, optionalTarget ) {

        return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

    },

    containsPoint: function ( point ) {

        return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );

    },

    equals: function ( triangle ) {

        return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

    }

};

// File:src/core/Channels.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Channels = function () {

    this.mask = 1;

};

THREE.Channels.prototype = {

    constructor: THREE.Channels,

    set: function ( channel ) {

        this.mask = 1 << channel;

    },

    enable: function ( channel ) {

        this.mask |= 1 << channel;

    },

    toggle: function ( channel ) {

        this.mask ^= 1 << channel;

    },

    disable: function ( channel ) {

        this.mask &= ~ ( 1 << channel );

    }

};

// File:src/core/Clock.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Clock = function ( autoStart ) {

    this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;

    this.running = false;

};

THREE.Clock.prototype = {

    constructor: THREE.Clock,

    start: function () {

        this.startTime = self.performance.now();

        this.oldTime = this.startTime;
        this.running = true;

    },

    stop: function () {

        this.getElapsedTime();
        this.running = false;

    },

    getElapsedTime: function () {

        this.getDelta();
        return this.elapsedTime;

    },

    getDelta: function () {

        var diff = 0;

        if ( this.autoStart && ! this.running ) {

            this.start();

        }

        if ( this.running ) {

            var newTime = self.performance.now();

            diff = 0.001 * ( newTime - this.oldTime );
            this.oldTime = newTime;

            this.elapsedTime += diff;

        }

        return diff;

    }

};

// File:src/core/EventDispatcher.js

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

THREE.EventDispatcher = function () {};

THREE.EventDispatcher.prototype = {

    constructor: THREE.EventDispatcher,

    apply: function ( object ) {

        object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
        object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
        object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
        object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;

    },

    addEventListener: function ( type, listener ) {

        if ( this._listeners === undefined ) this._listeners = {};

        var listeners = this._listeners;

        if ( listeners[ type ] === undefined ) {

            listeners[ type ] = [];

        }

        if ( listeners[ type ].indexOf( listener ) === - 1 ) {

            listeners[ type ].push( listener );

        }

    },

    hasEventListener: function ( type, listener ) {

        if ( this._listeners === undefined ) return false;

        var listeners = this._listeners;

        if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

            return true;

        }

        return false;

    },

    removeEventListener: function ( type, listener ) {

        if ( this._listeners === undefined ) return;

        var listeners = this._listeners;
        var listenerArray = listeners[ type ];

        if ( listenerArray !== undefined ) {

            var index = listenerArray.indexOf( listener );

            if ( index !== - 1 ) {

                listenerArray.splice( index, 1 );

            }

        }

    },

    dispatchEvent: function ( event ) {

        if ( this._listeners === undefined ) return;

        var listeners = this._listeners;
        var listenerArray = listeners[ event.type ];

        if ( listenerArray !== undefined ) {

            event.target = this;

            var array = [];
            var length = listenerArray.length;

            for ( var i = 0; i < length; i ++ ) {

                array[ i ] = listenerArray[ i ];

            }

            for ( var i = 0; i < length; i ++ ) {

                array[ i ].call( this, event );

            }

        }

    }

};

// File:src/core/Raycaster.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://clara.io/
 * @author stephomi / http://stephaneginier.com/
 */

( function ( THREE ) {

    THREE.Raycaster = function ( origin, direction, near, far ) {

        this.ray = new THREE.Ray( origin, direction );
        // direction is assumed to be normalized (for accurate distance calculations)

        this.near = near || 0;
        this.far = far || Infinity;

        this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: { threshold: 1 },
            Sprite: {}
        };

        Object.defineProperties( this.params, {
            PointCloud: {
                get: function () {
                    console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
                    return this.Points;
                }
            }
        } );

    };

    function descSort( a, b ) {

        return a.distance - b.distance;

    }

    function intersectObject( object, raycaster, intersects, recursive ) {

        if ( object.visible === false ) return;

        object.raycast( raycaster, intersects );

        if ( recursive === true ) {

            var children = object.children;

            for ( var i = 0, l = children.length; i < l; i ++ ) {

                intersectObject( children[ i ], raycaster, intersects, true );

            }

        }

    }

    //

    THREE.Raycaster.prototype = {

        constructor: THREE.Raycaster,

        linePrecision: 1,

        set: function ( origin, direction ) {

            // direction is assumed to be normalized (for accurate distance calculations)

            this.ray.set( origin, direction );

        },

        setFromCamera: function ( coords, camera ) {

            if ( camera instanceof THREE.PerspectiveCamera ) {

                this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
                this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

            } else if ( camera instanceof THREE.OrthographicCamera ) {

                this.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );
                this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

            } else {

                console.error( 'THREE.Raycaster: Unsupported camera type.' );

            }

        },

        intersectObject: function ( object, recursive ) {

            var intersects = [];

            intersectObject( object, this, intersects, recursive );

            intersects.sort( descSort );

            return intersects;

        },

        intersectObjects: function ( objects, recursive ) {

            var intersects = [];

            if ( Array.isArray( objects ) === false ) {

                console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
                return intersects;

            }

            for ( var i = 0, l = objects.length; i < l; i ++ ) {

                intersectObject( objects[ i ], this, intersects, recursive );

            }

            intersects.sort( descSort );

            return intersects;

        }

    };

}( THREE ) );

// File:src/core/Object3D.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author elephantatwork / www.elephantatwork.ch
 */

THREE.Object3D = function () {

    Object.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );

    this.uuid = THREE.Math.generateUUID();

    this.name = '';
    this.type = 'Object3D';

    this.parent = null;
    this.channels = new THREE.Channels();
    this.children = [];

    this.up = THREE.Object3D.DefaultUp.clone();

    var position = new THREE.Vector3();
    var rotation = new THREE.Euler();
    var quaternion = new THREE.Quaternion();
    var scale = new THREE.Vector3( 1, 1, 1 );

    function onRotationChange() {

        quaternion.setFromEuler( rotation, false );

    }

    function onQuaternionChange() {

        rotation.setFromQuaternion( quaternion, undefined, false );

    }

    rotation.onChange( onRotationChange );
    quaternion.onChange( onQuaternionChange );

    Object.defineProperties( this, {
        position: {
            enumerable: true,
            value: position
        },
        rotation: {
            enumerable: true,
            value: rotation
        },
        quaternion: {
            enumerable: true,
            value: quaternion
        },
        scale: {
            enumerable: true,
            value: scale
        },
        modelViewMatrix: {
            value: new THREE.Matrix4()
        },
        normalMatrix: {
            value: new THREE.Matrix3()
        }
    } );

    this.rotationAutoUpdate = true;

    this.matrix = new THREE.Matrix4();
    this.matrixWorld = new THREE.Matrix4();

    this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = false;

    this.visible = true;

    this.castShadow = false;
    this.receiveShadow = false;

    this.frustumCulled = true;
    this.renderOrder = 0;

    this.userData = {};

};

THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );
THREE.Object3D.DefaultMatrixAutoUpdate = true;

THREE.Object3D.prototype = {

    constructor: THREE.Object3D,

    get eulerOrder () {

        console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );

        return this.rotation.order;

    },

    set eulerOrder ( value ) {

        console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );

        this.rotation.order = value;

    },

    get useQuaternion () {

        console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

    },

    set useQuaternion ( value ) {

        console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

    },

    set renderDepth ( value ) {

        console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

    },

    //

    applyMatrix: function ( matrix ) {

        this.matrix.multiplyMatrices( matrix, this.matrix );

        this.matrix.decompose( this.position, this.quaternion, this.scale );

    },

    setRotationFromAxisAngle: function ( axis, angle ) {

        // assumes axis is normalized

        this.quaternion.setFromAxisAngle( axis, angle );

    },

    setRotationFromEuler: function ( euler ) {

        this.quaternion.setFromEuler( euler, true );

    },

    setRotationFromMatrix: function ( m ) {

        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

        this.quaternion.setFromRotationMatrix( m );

    },

    setRotationFromQuaternion: function ( q ) {

        // assumes q is normalized

        this.quaternion.copy( q );

    },

    rotateOnAxis: function () {

        // rotate object on axis in object space
        // axis is assumed to be normalized

        var q1 = new THREE.Quaternion();

        return function ( axis, angle ) {

            q1.setFromAxisAngle( axis, angle );

            this.quaternion.multiply( q1 );

            return this;

        };

    }(),

    rotateX: function () {

        var v1 = new THREE.Vector3( 1, 0, 0 );

        return function ( angle ) {

            return this.rotateOnAxis( v1, angle );

        };

    }(),

    rotateY: function () {

        var v1 = new THREE.Vector3( 0, 1, 0 );

        return function ( angle ) {

            return this.rotateOnAxis( v1, angle );

        };

    }(),

    rotateZ: function () {

        var v1 = new THREE.Vector3( 0, 0, 1 );

        return function ( angle ) {

            return this.rotateOnAxis( v1, angle );

        };

    }(),

    translateOnAxis: function () {

        // translate object by distance along axis in object space
        // axis is assumed to be normalized

        var v1 = new THREE.Vector3();

        return function ( axis, distance ) {

            v1.copy( axis ).applyQuaternion( this.quaternion );

            this.position.add( v1.multiplyScalar( distance ) );

            return this;

        };

    }(),

    translate: function ( distance, axis ) {

        console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
        return this.translateOnAxis( axis, distance );

    },

    translateX: function () {

        var v1 = new THREE.Vector3( 1, 0, 0 );

        return function ( distance ) {

            return this.translateOnAxis( v1, distance );

        };

    }(),

    translateY: function () {

        var v1 = new THREE.Vector3( 0, 1, 0 );

        return function ( distance ) {

            return this.translateOnAxis( v1, distance );

        };

    }(),

    translateZ: function () {

        var v1 = new THREE.Vector3( 0, 0, 1 );

        return function ( distance ) {

            return this.translateOnAxis( v1, distance );

        };

    }(),

    localToWorld: function ( vector ) {

        return vector.applyMatrix4( this.matrixWorld );

    },

    worldToLocal: function () {

        var m1 = new THREE.Matrix4();

        return function ( vector ) {

            return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

        };

    }(),

    lookAt: function () {

        // This routine does not support objects with rotated and/or translated parent(s)

        var m1 = new THREE.Matrix4();

        return function ( vector ) {

            m1.lookAt( vector, this.position, this.up );

            this.quaternion.setFromRotationMatrix( m1 );

        };

    }(),

    add: function ( object ) {

        if ( arguments.length > 1 ) {

            for ( var i = 0; i < arguments.length; i ++ ) {

                this.add( arguments[ i ] );

            }

            return this;

        }

        if ( object === this ) {

            console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
            return this;

        }

        if ( object instanceof THREE.Object3D ) {

            if ( object.parent !== null ) {

                object.parent.remove( object );

            }

            object.parent = this;
            object.dispatchEvent( { type: 'added' } );

            this.children.push( object );

        } else {

            console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

        }

        return this;

    },

    remove: function ( object ) {

        if ( arguments.length > 1 ) {

            for ( var i = 0; i < arguments.length; i ++ ) {

                this.remove( arguments[ i ] );

            }

        }

        var index = this.children.indexOf( object );

        if ( index !== - 1 ) {

            object.parent = null;

            object.dispatchEvent( { type: 'removed' } );

            this.children.splice( index, 1 );

        }

    },

    getChildByName: function ( name ) {

        console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
        return this.getObjectByName( name );

    },

    getObjectById: function ( id ) {

        return this.getObjectByProperty( 'id', id );

    },

    getObjectByName: function ( name ) {

        return this.getObjectByProperty( 'name', name );

    },

    getObjectByProperty: function ( name, value ) {

        if ( this[ name ] === value ) return this;

        for ( var i = 0, l = this.children.length; i < l; i ++ ) {

            var child = this.children[ i ];
            var object = child.getObjectByProperty( name, value );

            if ( object !== undefined ) {

                return object;

            }

        }

        return undefined;

    },

    getWorldPosition: function ( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();

        this.updateMatrixWorld( true );

        return result.setFromMatrixPosition( this.matrixWorld );

    },

    getWorldQuaternion: function () {

        var position = new THREE.Vector3();
        var scale = new THREE.Vector3();

        return function ( optionalTarget ) {

            var result = optionalTarget || new THREE.Quaternion();

            this.updateMatrixWorld( true );

            this.matrixWorld.decompose( position, result, scale );

            return result;

        };

    }(),

    getWorldRotation: function () {

        var quaternion = new THREE.Quaternion();

        return function ( optionalTarget ) {

            var result = optionalTarget || new THREE.Euler();

            this.getWorldQuaternion( quaternion );

            return result.setFromQuaternion( quaternion, this.rotation.order, false );

        };

    }(),

    getWorldScale: function () {

        var position = new THREE.Vector3();
        var quaternion = new THREE.Quaternion();

        return function ( optionalTarget ) {

            var result = optionalTarget || new THREE.Vector3();

            this.updateMatrixWorld( true );

            this.matrixWorld.decompose( position, quaternion, result );

            return result;

        };

    }(),

    getWorldDirection: function () {

        var quaternion = new THREE.Quaternion();

        return function ( optionalTarget ) {

            var result = optionalTarget || new THREE.Vector3();

            this.getWorldQuaternion( quaternion );

            return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

        };

    }(),

    raycast: function () {},

    traverse: function ( callback ) {

        callback( this );

        var children = this.children;

        for ( var i = 0, l = children.length; i < l; i ++ ) {

            children[ i ].traverse( callback );

        }

    },

    traverseVisible: function ( callback ) {

        if ( this.visible === false ) return;

        callback( this );

        var children = this.children;

        for ( var i = 0, l = children.length; i < l; i ++ ) {

            children[ i ].traverseVisible( callback );

        }

    },

    traverseAncestors: function ( callback ) {

        var parent = this.parent;

        if ( parent !== null ) {

            callback( parent );

            parent.traverseAncestors( callback );

        }

    },

    updateMatrix: function () {

        this.matrix.compose( this.position, this.quaternion, this.scale );

        this.matrixWorldNeedsUpdate = true;

    },

    updateMatrixWorld: function ( force ) {

        if ( this.matrixAutoUpdate === true ) this.updateMatrix();

        if ( this.matrixWorldNeedsUpdate === true || force === true ) {

            if ( this.parent === null ) {

                this.matrixWorld.copy( this.matrix );

            } else {

                this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

            }

            this.matrixWorldNeedsUpdate = false;

            force = true;

        }

        // update children

        for ( var i = 0, l = this.children.length; i < l; i ++ ) {

            this.children[ i ].updateMatrixWorld( force );

        }

    },

    toJSON: function ( meta ) {

        var isRootObject = ( meta === undefined );

        var output = {};

        // meta is a hash used to collect geometries, materials.
        // not providing it implies that this is the root object
        // being serialized.
        if ( isRootObject ) {

            // initialize meta obj
            meta = {
                geometries: {},
                materials: {},
                textures: {},
                images: {}
            };

            output.metadata = {
                version: 4.4,
                type: 'Object',
                generator: 'Object3D.toJSON'
            };

        }

        // standard Object3D serialization

        var object = {};

        object.uuid = this.uuid;
        object.type = this.type;

        if ( this.name !== '' ) object.name = this.name;
        if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
        if ( this.castShadow === true ) object.castShadow = true;
        if ( this.receiveShadow === true ) object.receiveShadow = true;
        if ( this.visible === false ) object.visible = false;

        object.matrix = this.matrix.toArray();

        //

        if ( this.geometry !== undefined ) {

            if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

                meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );

            }

            object.geometry = this.geometry.uuid;

        }

        if ( this.material !== undefined ) {

            if ( meta.materials[ this.material.uuid ] === undefined ) {

                meta.materials[ this.material.uuid ] = this.material.toJSON( meta );

            }

            object.material = this.material.uuid;

        }

        //

        if ( this.children.length > 0 ) {

            object.children = [];

            for ( var i = 0; i < this.children.length; i ++ ) {

                object.children.push( this.children[ i ].toJSON( meta ).object );

            }

        }

        if ( isRootObject ) {

            var geometries = extractFromCache( meta.geometries );
            var materials = extractFromCache( meta.materials );
            var textures = extractFromCache( meta.textures );
            var images = extractFromCache( meta.images );

            if ( geometries.length > 0 ) output.geometries = geometries;
            if ( materials.length > 0 ) output.materials = materials;
            if ( textures.length > 0 ) output.textures = textures;
            if ( images.length > 0 ) output.images = images;

        }

        output.object = object;

        return output;

        // extract data from the cache hash
        // remove metadata on each item
        // and return as array
        function extractFromCache ( cache ) {

            var values = [];
            for ( var key in cache ) {

                var data = cache[ key ];
                delete data.metadata;
                values.push( data );

            }
            return values;

        }

    },

    clone: function ( recursive ) {

        return new this.constructor().copy( this, recursive );

    },

    copy: function ( source, recursive ) {

        if ( recursive === undefined ) recursive = true;

        this.name = source.name;

        this.up.copy( source.up );

        this.position.copy( source.position );
        this.quaternion.copy( source.quaternion );
        this.scale.copy( source.scale );

        this.rotationAutoUpdate = source.rotationAutoUpdate;

        this.matrix.copy( source.matrix );
        this.matrixWorld.copy( source.matrixWorld );

        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

        this.visible = source.visible;

        this.castShadow = source.castShadow;
        this.receiveShadow = source.receiveShadow;

        this.frustumCulled = source.frustumCulled;
        this.renderOrder = source.renderOrder;

        this.userData = JSON.parse( JSON.stringify( source.userData ) );

        if ( recursive === true ) {

            for ( var i = 0; i < source.children.length; i ++ ) {

                var child = source.children[ i ];
                this.add( child.clone() );

            }

        }

        return this;

    }

};

THREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );

THREE.Object3DIdCount = 0;

// File:src/core/Face3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {

    this.a = a;
    this.b = b;
    this.c = c;

    this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
    this.vertexNormals = Array.isArray( normal ) ? normal : [];

    this.color = color instanceof THREE.Color ? color : new THREE.Color();
    this.vertexColors = Array.isArray( color ) ? color : [];

    this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

};

THREE.Face3.prototype = {

    constructor: THREE.Face3,

    clone: function () {

        return new this.constructor().copy( this );

    },

    copy: function ( source ) {

        this.a = source.a;
        this.b = source.b;
        this.c = source.c;

        this.normal.copy( source.normal );
        this.color.copy( source.color );

        this.materialIndex = source.materialIndex;

        for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

            this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

        }

        for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

            this.vertexColors[ i ] = source.vertexColors[ i ].clone();

        }

        return this;

    }

};

// File:src/core/Face4.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {

    console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
    return new THREE.Face3( a, b, c, normal, color, materialIndex );

};

// File:src/core/BufferAttribute.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferAttribute = function ( array, itemSize ) {

    this.uuid = THREE.Math.generateUUID();

    this.array = array;
    this.itemSize = itemSize;

    this.dynamic = false;
    this.updateRange = { offset: 0, count: - 1 };

    this.version = 0;

};

THREE.BufferAttribute.prototype = {

    constructor: THREE.BufferAttribute,

    get length() {

        console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
        return this.array.length;

    },

    get count() {

        return this.array.length / this.itemSize;

    },

    set needsUpdate( value ) {

        if ( value === true ) this.version ++;

    },

    setDynamic: function ( value ) {

        this.dynamic = value;

        return this;

    },

    copy: function ( source ) {

        this.array = new source.array.constructor( source.array );
        this.itemSize = source.itemSize;

        this.dynamic = source.dynamic;

        return this;

    },

    copyAt: function ( index1, attribute, index2 ) {

        index1 *= this.itemSize;
        index2 *= attribute.itemSize;

        for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

            this.array[ index1 + i ] = attribute.array[ index2 + i ];

        }

        return this;

    },

    copyArray: function ( array ) {

        this.array.set( array );

        return this;

    },

    copyColorsArray: function ( colors ) {

        var array = this.array, offset = 0;

        for ( var i = 0, l = colors.length; i < l; i ++ ) {

            var color = colors[ i ];

            if ( color === undefined ) {

                console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
                color = new THREE.Color();

            }

            array[ offset ++ ] = color.r;
            array[ offset ++ ] = color.g;
            array[ offset ++ ] = color.b;

        }

        return this;

    },

    copyIndicesArray: function ( indices ) {

        var array = this.array, offset = 0;

        for ( var i = 0, l = indices.length; i < l; i ++ ) {

            var index = indices[ i ];

            array[ offset ++ ] = index.a;
            array[ offset ++ ] = index.b;
            array[ offset ++ ] = index.c;

        }

        return this;

    },

    copyVector2sArray: function ( vectors ) {

        var array = this.array, offset = 0;

        for ( var i = 0, l = vectors.length; i < l; i ++ ) {

            var vector = vectors[ i ];

            if ( vector === undefined ) {

                console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
                vector = new THREE.Vector2();

            }

            array[ offset ++ ] = vector.x;
            array[ offset ++ ] = vector.y;

        }

        return this;

    },

    copyVector3sArray: function ( vectors ) {

        var array = this.array, offset = 0;

        for ( var i = 0, l = vectors.length; i < l; i ++ ) {

            var vector = vectors[ i ];

            if ( vector === undefined ) {

                console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
                vector = new THREE.Vector3();

            }

            array[ offset ++ ] = vector.x;
            array[ offset ++ ] = vector.y;
            array[ offset ++ ] = vector.z;

        }

        return this;

    },

    copyVector4sArray: function ( vectors ) {

        var array = this.array, offset = 0;

        for ( var i = 0, l = vectors.length; i < l; i ++ ) {

            var vector = vectors[ i ];

            if ( vector === undefined ) {

                console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
                vector = new THREE.Vector4();

            }

            array[ offset ++ ] = vector.x;
            array[ offset ++ ] = vector.y;
            array[ offset ++ ] = vector.z;
            array[ offset ++ ] = vector.w;

        }

        return this;

    },

    set: function ( value, offset ) {

        if ( offset === undefined ) offset = 0;

        this.array.set( value, offset );

        return this;

    },

    getX: function ( index ) {

        return this.array[ index * this.itemSize ];

    },

    setX: function ( index, x ) {

        this.array[ index * this.itemSize ] = x;

        return this;

    },

    getY: function ( index ) {

        return this.array[ index * this.itemSize + 1 ];

    },

    setY: function ( index, y ) {

        this.array[ index * this.itemSize + 1 ] = y;

        return this;

    },

    getZ: function ( index ) {

        return this.array[ index * this.itemSize + 2 ];

    },

    setZ: function ( index, z ) {

        this.array[ index * this.itemSize + 2 ] = z;

        return this;

    },

    getW: function ( index ) {

        return this.array[ index * this.itemSize + 3 ];

    },

    setW: function ( index, w ) {

        this.array[ index * this.itemSize + 3 ] = w;

        return this;

    },

    setXY: function ( index, x, y ) {

        index *= this.itemSize;

        this.array[ index + 0 ] = x;
        this.array[ index + 1 ] = y;

        return this;

    },

    setXYZ: function ( index, x, y, z ) {

        index *= this.itemSize;

        this.array[ index + 0 ] = x;
        this.array[ index + 1 ] = y;
        this.array[ index + 2 ] = z;

        return this;

    },

    setXYZW: function ( index, x, y, z, w ) {

        index *= this.itemSize;

        this.array[ index + 0 ] = x;
        this.array[ index + 1 ] = y;
        this.array[ index + 2 ] = z;
        this.array[ index + 3 ] = w;

        return this;

    },

    clone: function () {

        return new this.constructor().copy( this );

    }

};

//

THREE.Int8Attribute = function ( array, itemSize ) {

    return new THREE.BufferAttribute( new Int8Array( array ), itemSize );

};

THREE.Uint8Attribute = function ( array, itemSize ) {

    return new THREE.BufferAttribute( new Uint8Array( array ), itemSize );

};

THREE.Uint8ClampedAttribute = function ( array, itemSize ) {

    return new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );

};

THREE.Int16Attribute = function ( array, itemSize ) {

    return new THREE.BufferAttribute( new Int16Array( array ), itemSize );

};

THREE.Uint16Attribute = function ( array, itemSize ) {

    return new THREE.BufferAttribute( new Uint16Array( array ), itemSize );

};

THREE.Int32Attribute = function ( array, itemSize ) {

    return new THREE.BufferAttribute( new Int32Array( array ), itemSize );

};

THREE.Uint32Attribute = function ( array, itemSize ) {

    return new THREE.BufferAttribute( new Uint32Array( array ), itemSize );

};

THREE.Float32Attribute = function ( array, itemSize ) {

    return new THREE.BufferAttribute( new Float32Array( array ), itemSize );

};

THREE.Float64Attribute = function ( array, itemSize ) {

    return new THREE.BufferAttribute( new Float64Array( array ), itemSize );

};


// Deprecated

THREE.DynamicBufferAttribute = function ( array, itemSize ) {

    console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
    return new THREE.BufferAttribute( array, itemSize ).setDynamic( true );

};

// File:src/core/InstancedBufferAttribute.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedBufferAttribute = function ( array, itemSize, meshPerAttribute ) {

    THREE.BufferAttribute.call( this, array, itemSize );

    this.meshPerAttribute = meshPerAttribute || 1;

};

THREE.InstancedBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );
THREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;

THREE.InstancedBufferAttribute.prototype.copy = function ( source ) {

    THREE.BufferAttribute.prototype.copy.call( this, source );

    this.meshPerAttribute = source.meshPerAttribute;

    return this;

};

// File:src/core/InterleavedBuffer.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InterleavedBuffer = function ( array, stride ) {

    this.uuid = THREE.Math.generateUUID();

    this.array = array;
    this.stride = stride;

    this.dynamic = false;
    this.updateRange = { offset: 0, count: - 1 };

    this.version = 0;

};

THREE.InterleavedBuffer.prototype = {

    constructor: THREE.InterleavedBuffer,

    get length () {

        return this.array.length;

    },

    get count () {

        return this.array.length / this.stride;

    },

    set needsUpdate( value ) {

        if ( value === true ) this.version ++;

    },

    setDynamic: function ( value ) {

        this.dynamic = value;

        return this;

    },

    copy: function ( source ) {

        this.array = new source.array.constructor( source.array );
        this.stride = source.stride;
        this.dynamic = source.dynamic;

    },

    copyAt: function ( index1, attribute, index2 ) {

        index1 *= this.stride;
        index2 *= attribute.stride;

        for ( var i = 0, l = this.stride; i < l; i ++ ) {

            this.array[ index1 + i ] = attribute.array[ index2 + i ];

        }

        return this;

    },

    set: function ( value, offset ) {

        if ( offset === undefined ) offset = 0;

        this.array.set( value, offset );

        return this;

    },

    clone: function () {

        return new this.constructor().copy( this );

    }

};

// File:src/core/InstancedInterleavedBuffer.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedInterleavedBuffer = function ( array, stride, meshPerAttribute ) {

    THREE.InterleavedBuffer.call( this, array, stride );

    this.meshPerAttribute = meshPerAttribute || 1;

};

THREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );
THREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;

THREE.InstancedInterleavedBuffer.prototype.copy = function ( source ) {

    THREE.InterleavedBuffer.prototype.copy.call( this, source );

    this.meshPerAttribute = source.meshPerAttribute;

    return this;

};

// File:src/core/InterleavedBufferAttribute.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset ) {

    this.uuid = THREE.Math.generateUUID();

    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;

};


THREE.InterleavedBufferAttribute.prototype = {

    constructor: THREE.InterleavedBufferAttribute,

    get length() {

        console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
        return this.array.length;

    },

    get count() {

        return this.data.array.length / this.data.stride;

    },

    setX: function ( index, x ) {

        this.data.array[ index * this.data.stride + this.offset ] = x;

        return this;

    },

    setY: function ( index, y ) {

        this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

        return this;

    },

    setZ: function ( index, z ) {

        this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

        return this;

    },

    setW: function ( index, w ) {

        this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

        return this;

    },

    getX: function ( index ) {

        return this.data.array[ index * this.data.stride + this.offset ];

    },

    getY: function ( index ) {

        return this.data.array[ index * this.data.stride + this.offset + 1 ];

    },

    getZ: function ( index ) {

        return this.data.array[ index * this.data.stride + this.offset + 2 ];

    },

    getW: function ( index ) {

        return this.data.array[ index * this.data.stride + this.offset + 3 ];

    },

    setXY: function ( index, x, y ) {

        index = index * this.data.stride + this.offset;

        this.data.array[ index + 0 ] = x;
        this.data.array[ index + 1 ] = y;

        return this;

    },

    setXYZ: function ( index, x, y, z ) {

        index = index * this.data.stride + this.offset;

        this.data.array[ index + 0 ] = x;
        this.data.array[ index + 1 ] = y;
        this.data.array[ index + 2 ] = z;

        return this;

    },

    setXYZW: function ( index, x, y, z, w ) {

        index = index * this.data.stride + this.offset;

        this.data.array[ index + 0 ] = x;
        this.data.array[ index + 1 ] = y;
        this.data.array[ index + 2 ] = z;
        this.data.array[ index + 3 ] = w;

        return this;

    }

};

// File:src/core/Geometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://clara.io
 */

THREE.Geometry = function () {

    Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

    this.uuid = THREE.Math.generateUUID();

    this.name = '';
    this.type = 'Geometry';

    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [ [] ];

    this.morphTargets = [];
    this.morphNormals = [];

    this.skinWeights = [];
    this.skinIndices = [];

    this.lineDistances = [];

    this.boundingBox = null;
    this.boundingSphere = null;

    // update flags

    this.verticesNeedUpdate = false;
    this.elementsNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.lineDistancesNeedUpdate = false;
    this.groupsNeedUpdate = false;

};

THREE.Geometry.prototype = {

    constructor: THREE.Geometry,

    applyMatrix: function ( matrix ) {

        var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

        for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

            var vertex = this.vertices[ i ];
            vertex.applyMatrix4( matrix );

        }

        for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

            var face = this.faces[ i ];
            face.normal.applyMatrix3( normalMatrix ).normalize();

            for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

                face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

            }

        }

        if ( this.boundingBox !== null ) {

            this.computeBoundingBox();

        }

        if ( this.boundingSphere !== null ) {

            this.computeBoundingSphere();

        }

        this.verticesNeedUpdate = true;
        this.normalsNeedUpdate = true;

    },

    rotateX: function () {

        // rotate geometry around world x-axis

        var m1;

        return function rotateX( angle ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeRotationX( angle );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    rotateY: function () {

        // rotate geometry around world y-axis

        var m1;

        return function rotateY( angle ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeRotationY( angle );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    rotateZ: function () {

        // rotate geometry around world z-axis

        var m1;

        return function rotateZ( angle ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeRotationZ( angle );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    translate: function () {

        // translate geometry

        var m1;

        return function translate( x, y, z ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeTranslation( x, y, z );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    scale: function () {

        // scale geometry

        var m1;

        return function scale( x, y, z ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeScale( x, y, z );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    lookAt: function () {

        var obj;

        return function lookAt( vector ) {

            if ( obj === undefined ) obj = new THREE.Object3D();

            obj.lookAt( vector );

            obj.updateMatrix();

            this.applyMatrix( obj.matrix );

        };

    }(),

    fromBufferGeometry: function ( geometry ) {

        var scope = this;

        var indices = geometry.index !== null ? geometry.index.array : undefined;
        var attributes = geometry.attributes;

        var vertices = attributes.position.array;
        var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
        var colors = attributes.color !== undefined ? attributes.color.array : undefined;
        var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
        var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

        if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

        var tempNormals = [];
        var tempUVs = [];
        var tempUVs2 = [];

        for ( var i = 0, j = 0, k = 0; i < vertices.length; i += 3, j += 2, k += 4 ) {

            scope.vertices.push( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

            if ( normals !== undefined ) {

                tempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

            }

            if ( colors !== undefined ) {

                scope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

            }

            if ( uvs !== undefined ) {

                tempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );

            }

            if ( uvs2 !== undefined ) {

                tempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );

            }

        }

        function addFace( a, b, c ) {

            var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
            var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

            var face = new THREE.Face3( a, b, c, vertexNormals, vertexColors );

            scope.faces.push( face );

            if ( uvs !== undefined ) {

                scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

            }

            if ( uvs2 !== undefined ) {

                scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );

            }

        };

        if ( indices !== undefined ) {

            var groups = geometry.groups;

            if ( groups.length > 0 ) {

                for ( var i = 0; i < groups.length; i ++ ) {

                    var group = groups[ i ];

                    var start = group.start;
                    var count = group.count;

                    for ( var j = start, jl = start + count; j < jl; j += 3 ) {

                        addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ] );

                    }

                }

            } else {

                for ( var i = 0; i < indices.length; i += 3 ) {

                    addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

                }

            }

        } else {

            for ( var i = 0; i < vertices.length / 3; i += 3 ) {

                addFace( i, i + 1, i + 2 );

            }

        }

        this.computeFaceNormals();

        if ( geometry.boundingBox !== null ) {

            this.boundingBox = geometry.boundingBox.clone();

        }

        if ( geometry.boundingSphere !== null ) {

            this.boundingSphere = geometry.boundingSphere.clone();

        }

        return this;

    },

    center: function () {

        this.computeBoundingBox();

        var offset = this.boundingBox.center().negate();

        this.translate( offset.x, offset.y, offset.z );

        return offset;

    },

    normalize: function () {

        this.computeBoundingSphere();

        var center = this.boundingSphere.center;
        var radius = this.boundingSphere.radius;

        var s = radius === 0 ? 1 : 1.0 / radius;

        var matrix = new THREE.Matrix4();
        matrix.set(
            s, 0, 0, - s * center.x,
            0, s, 0, - s * center.y,
            0, 0, s, - s * center.z,
            0, 0, 0, 1
        );

        this.applyMatrix( matrix );

        return this;

    },

    computeFaceNormals: function () {

        var cb = new THREE.Vector3(), ab = new THREE.Vector3();

        for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

            var face = this.faces[ f ];

            var vA = this.vertices[ face.a ];
            var vB = this.vertices[ face.b ];
            var vC = this.vertices[ face.c ];

            cb.subVectors( vC, vB );
            ab.subVectors( vA, vB );
            cb.cross( ab );

            cb.normalize();

            face.normal.copy( cb );

        }

    },

    computeVertexNormals: function ( areaWeighted ) {

        var v, vl, f, fl, face, vertices;

        vertices = new Array( this.vertices.length );

        for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

            vertices[ v ] = new THREE.Vector3();

        }

        if ( areaWeighted ) {

            // vertex normals weighted by triangle areas
            // http://www.iquilezles.org/www/articles/normals/normals.htm

            var vA, vB, vC;
            var cb = new THREE.Vector3(), ab = new THREE.Vector3();

            for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

                face = this.faces[ f ];

                vA = this.vertices[ face.a ];
                vB = this.vertices[ face.b ];
                vC = this.vertices[ face.c ];

                cb.subVectors( vC, vB );
                ab.subVectors( vA, vB );
                cb.cross( ab );

                vertices[ face.a ].add( cb );
                vertices[ face.b ].add( cb );
                vertices[ face.c ].add( cb );

            }

        } else {

            for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

                face = this.faces[ f ];

                vertices[ face.a ].add( face.normal );
                vertices[ face.b ].add( face.normal );
                vertices[ face.c ].add( face.normal );

            }

        }

        for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

            vertices[ v ].normalize();

        }

        for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

            face = this.faces[ f ];

            var vertexNormals = face.vertexNormals;

            if ( vertexNormals.length === 3 ) {

                vertexNormals[ 0 ].copy( vertices[ face.a ] );
                vertexNormals[ 1 ].copy( vertices[ face.b ] );
                vertexNormals[ 2 ].copy( vertices[ face.c ] );

            } else {

                vertexNormals[ 0 ] = vertices[ face.a ].clone();
                vertexNormals[ 1 ] = vertices[ face.b ].clone();
                vertexNormals[ 2 ] = vertices[ face.c ].clone();

            }

        }

    },

    computeMorphNormals: function () {

        var i, il, f, fl, face;

        // save original normals
        // - create temp variables on first access
        //   otherwise just copy (for faster repeated calls)

        for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

            face = this.faces[ f ];

            if ( ! face.__originalFaceNormal ) {

                face.__originalFaceNormal = face.normal.clone();

            } else {

                face.__originalFaceNormal.copy( face.normal );

            }

            if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

            for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

                if ( ! face.__originalVertexNormals[ i ] ) {

                    face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

                } else {

                    face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

                }

            }

        }

        // use temp geometry to compute face and vertex normals for each morph

        var tmpGeo = new THREE.Geometry();
        tmpGeo.faces = this.faces;

        for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

            // create on first access

            if ( ! this.morphNormals[ i ] ) {

                this.morphNormals[ i ] = {};
                this.morphNormals[ i ].faceNormals = [];
                this.morphNormals[ i ].vertexNormals = [];

                var dstNormalsFace = this.morphNormals[ i ].faceNormals;
                var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

                var faceNormal, vertexNormals;

                for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

                    faceNormal = new THREE.Vector3();
                    vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };

                    dstNormalsFace.push( faceNormal );
                    dstNormalsVertex.push( vertexNormals );

                }

            }

            var morphNormals = this.morphNormals[ i ];

            // set vertices to morph target

            tmpGeo.vertices = this.morphTargets[ i ].vertices;

            // compute morph normals

            tmpGeo.computeFaceNormals();
            tmpGeo.computeVertexNormals();

            // store morph normals

            var faceNormal, vertexNormals;

            for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

                face = this.faces[ f ];

                faceNormal = morphNormals.faceNormals[ f ];
                vertexNormals = morphNormals.vertexNormals[ f ];

                faceNormal.copy( face.normal );

                vertexNormals.a.copy( face.vertexNormals[ 0 ] );
                vertexNormals.b.copy( face.vertexNormals[ 1 ] );
                vertexNormals.c.copy( face.vertexNormals[ 2 ] );

            }

        }

        // restore original normals

        for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

            face = this.faces[ f ];

            face.normal = face.__originalFaceNormal;
            face.vertexNormals = face.__originalVertexNormals;

        }

    },

    computeTangents: function () {

        console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );

    },

    computeLineDistances: function () {

        var d = 0;
        var vertices = this.vertices;

        for ( var i = 0, il = vertices.length; i < il; i ++ ) {

            if ( i > 0 ) {

                d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

            }

            this.lineDistances[ i ] = d;

        }

    },

    computeBoundingBox: function () {

        if ( this.boundingBox === null ) {

            this.boundingBox = new THREE.Box3();

        }

        this.boundingBox.setFromPoints( this.vertices );

    },

    computeBoundingSphere: function () {

        if ( this.boundingSphere === null ) {

            this.boundingSphere = new THREE.Sphere();

        }

        this.boundingSphere.setFromPoints( this.vertices );

    },

    merge: function ( geometry, matrix, materialIndexOffset ) {

        if ( geometry instanceof THREE.Geometry === false ) {

            console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
            return;

        }

        var normalMatrix,
            vertexOffset = this.vertices.length,
            vertices1 = this.vertices,
            vertices2 = geometry.vertices,
            faces1 = this.faces,
            faces2 = geometry.faces,
            uvs1 = this.faceVertexUvs[ 0 ],
            uvs2 = geometry.faceVertexUvs[ 0 ];

        if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

        if ( matrix !== undefined ) {

            normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

        }

        // vertices

        for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

            var vertex = vertices2[ i ];

            var vertexCopy = vertex.clone();

            if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

            vertices1.push( vertexCopy );

        }

        // faces

        for ( i = 0, il = faces2.length; i < il; i ++ ) {

            var face = faces2[ i ], faceCopy, normal, color,
                faceVertexNormals = face.vertexNormals,
                faceVertexColors = face.vertexColors;

            faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
            faceCopy.normal.copy( face.normal );

            if ( normalMatrix !== undefined ) {

                faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

            }

            for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

                normal = faceVertexNormals[ j ].clone();

                if ( normalMatrix !== undefined ) {

                    normal.applyMatrix3( normalMatrix ).normalize();

                }

                faceCopy.vertexNormals.push( normal );

            }

            faceCopy.color.copy( face.color );

            for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

                color = faceVertexColors[ j ];
                faceCopy.vertexColors.push( color.clone() );

            }

            faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

            faces1.push( faceCopy );

        }

        // uvs

        for ( i = 0, il = uvs2.length; i < il; i ++ ) {

            var uv = uvs2[ i ], uvCopy = [];

            if ( uv === undefined ) {

                continue;

            }

            for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

                uvCopy.push( uv[ j ].clone() );

            }

            uvs1.push( uvCopy );

        }

    },

    mergeMesh: function ( mesh ) {

        if ( mesh instanceof THREE.Mesh === false ) {

            console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
            return;

        }

        mesh.matrixAutoUpdate && mesh.updateMatrix();

        this.merge( mesh.geometry, mesh.matrix );

    },

    /*
     * Checks for duplicate vertices with hashmap.
     * Duplicated vertices are removed
     * and faces' vertices are updated.
     */

    mergeVertices: function () {

        var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
        var unique = [], changes = [];

        var v, key;
        var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
        var precision = Math.pow( 10, precisionPoints );
        var i, il, face;
        var indices, j, jl;

        for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

            v = this.vertices[ i ];
            key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

            if ( verticesMap[ key ] === undefined ) {

                verticesMap[ key ] = i;
                unique.push( this.vertices[ i ] );
                changes[ i ] = unique.length - 1;

            } else {

                //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
                changes[ i ] = changes[ verticesMap[ key ] ];

            }

        }


        // if faces are completely degenerate after merging vertices, we
        // have to remove them from the geometry.
        var faceIndicesToRemove = [];

        for ( i = 0, il = this.faces.length; i < il; i ++ ) {

            face = this.faces[ i ];

            face.a = changes[ face.a ];
            face.b = changes[ face.b ];
            face.c = changes[ face.c ];

            indices = [ face.a, face.b, face.c ];

            var dupIndex = - 1;

            // if any duplicate vertices are found in a Face3
            // we have to remove the face as nothing can be saved
            for ( var n = 0; n < 3; n ++ ) {

                if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

                    dupIndex = n;
                    faceIndicesToRemove.push( i );
                    break;

                }

            }

        }

        for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

            var idx = faceIndicesToRemove[ i ];

            this.faces.splice( idx, 1 );

            for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

                this.faceVertexUvs[ j ].splice( idx, 1 );

            }

        }

        // Use unique set of vertices

        var diff = this.vertices.length - unique.length;
        this.vertices = unique;
        return diff;

    },

    sortFacesByMaterialIndex: function () {

        var faces = this.faces;
        var length = faces.length;

        // tag faces

        for ( var i = 0; i < length; i ++ ) {

            faces[ i ]._id = i;

        }

        // sort faces

        function materialIndexSort( a, b ) {

            return a.materialIndex - b.materialIndex;

        }

        faces.sort( materialIndexSort );

        // sort uvs

        var uvs1 = this.faceVertexUvs[ 0 ];
        var uvs2 = this.faceVertexUvs[ 1 ];

        var newUvs1, newUvs2;

        if ( uvs1 && uvs1.length === length ) newUvs1 = [];
        if ( uvs2 && uvs2.length === length ) newUvs2 = [];

        for ( var i = 0; i < length; i ++ ) {

            var id = faces[ i ]._id;

            if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
            if ( newUvs2 ) newUvs2.push( uvs2[ id ] );

        }

        if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
        if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;

    },

    toJSON: function () {

        var data = {
            metadata: {
                version: 4.4,
                type: 'Geometry',
                generator: 'Geometry.toJSON'
            }
        };

        // standard Geometry serialization

        data.uuid = this.uuid;
        data.type = this.type;
        if ( this.name !== '' ) data.name = this.name;

        if ( this.parameters !== undefined ) {

            var parameters = this.parameters;

            for ( var key in parameters ) {

                if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

            }

            return data;

        }

        var vertices = [];

        for ( var i = 0; i < this.vertices.length; i ++ ) {

            var vertex = this.vertices[ i ];
            vertices.push( vertex.x, vertex.y, vertex.z );

        }

        var faces = [];
        var normals = [];
        var normalsHash = {};
        var colors = [];
        var colorsHash = {};
        var uvs = [];
        var uvsHash = {};

        for ( var i = 0; i < this.faces.length; i ++ ) {

            var face = this.faces[ i ];

            var hasMaterial = false; // face.materialIndex !== undefined;
            var hasFaceUv = false; // deprecated
            var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
            var hasFaceNormal = face.normal.length() > 0;
            var hasFaceVertexNormal = face.vertexNormals.length > 0;
            var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
            var hasFaceVertexColor = face.vertexColors.length > 0;

            var faceType = 0;

            faceType = setBit( faceType, 0, 0 );
            faceType = setBit( faceType, 1, hasMaterial );
            faceType = setBit( faceType, 2, hasFaceUv );
            faceType = setBit( faceType, 3, hasFaceVertexUv );
            faceType = setBit( faceType, 4, hasFaceNormal );
            faceType = setBit( faceType, 5, hasFaceVertexNormal );
            faceType = setBit( faceType, 6, hasFaceColor );
            faceType = setBit( faceType, 7, hasFaceVertexColor );

            faces.push( faceType );
            faces.push( face.a, face.b, face.c );

            if ( hasFaceVertexUv ) {

                var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

                faces.push(
                    getUvIndex( faceVertexUvs[ 0 ] ),
                    getUvIndex( faceVertexUvs[ 1 ] ),
                    getUvIndex( faceVertexUvs[ 2 ] )
                );

            }

            if ( hasFaceNormal ) {

                faces.push( getNormalIndex( face.normal ) );

            }

            if ( hasFaceVertexNormal ) {

                var vertexNormals = face.vertexNormals;

                faces.push(
                    getNormalIndex( vertexNormals[ 0 ] ),
                    getNormalIndex( vertexNormals[ 1 ] ),
                    getNormalIndex( vertexNormals[ 2 ] )
                );

            }

            if ( hasFaceColor ) {

                faces.push( getColorIndex( face.color ) );

            }

            if ( hasFaceVertexColor ) {

                var vertexColors = face.vertexColors;

                faces.push(
                    getColorIndex( vertexColors[ 0 ] ),
                    getColorIndex( vertexColors[ 1 ] ),
                    getColorIndex( vertexColors[ 2 ] )
                );

            }

        }

        function setBit( value, position, enabled ) {

            return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

        }

        function getNormalIndex( normal ) {

            var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

            if ( normalsHash[ hash ] !== undefined ) {

                return normalsHash[ hash ];

            }

            normalsHash[ hash ] = normals.length / 3;
            normals.push( normal.x, normal.y, normal.z );

            return normalsHash[ hash ];

        }

        function getColorIndex( color ) {

            var hash = color.r.toString() + color.g.toString() + color.b.toString();

            if ( colorsHash[ hash ] !== undefined ) {

                return colorsHash[ hash ];

            }

            colorsHash[ hash ] = colors.length;
            colors.push( color.getHex() );

            return colorsHash[ hash ];

        }

        function getUvIndex( uv ) {

            var hash = uv.x.toString() + uv.y.toString();

            if ( uvsHash[ hash ] !== undefined ) {

                return uvsHash[ hash ];

            }

            uvsHash[ hash ] = uvs.length / 2;
            uvs.push( uv.x, uv.y );

            return uvsHash[ hash ];

        }

        data.data = {};

        data.data.vertices = vertices;
        data.data.normals = normals;
        if ( colors.length > 0 ) data.data.colors = colors;
        if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
        data.data.faces = faces;

        return data;

    },

    clone: function () {

        return new this.constructor().copy( this );

    },

    copy: function ( source ) {

        this.vertices = [];
        this.faces = [];
        this.faceVertexUvs = [ [] ];

        var vertices = source.vertices;

        for ( var i = 0, il = vertices.length; i < il; i ++ ) {

            this.vertices.push( vertices[ i ].clone() );

        }

        var faces = source.faces;

        for ( var i = 0, il = faces.length; i < il; i ++ ) {

            this.faces.push( faces[ i ].clone() );

        }

        for ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

            var faceVertexUvs = source.faceVertexUvs[ i ];

            if ( this.faceVertexUvs[ i ] === undefined ) {

                this.faceVertexUvs[ i ] = [];

            }

            for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

                var uvs = faceVertexUvs[ j ], uvsCopy = [];

                for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {

                    var uv = uvs[ k ];

                    uvsCopy.push( uv.clone() );

                }

                this.faceVertexUvs[ i ].push( uvsCopy );

            }

        }

        return this;

    },

    dispose: function () {

        this.dispatchEvent( { type: 'dispose' } );

    }

};

THREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );

THREE.GeometryIdCount = 0;

// File:src/core/DirectGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.DirectGeometry = function () {

    Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

    this.uuid = THREE.Math.generateUUID();

    this.name = '';
    this.type = 'DirectGeometry';

    this.indices = [];
    this.vertices = [];
    this.normals = [];
    this.colors = [];
    this.uvs = [];
    this.uvs2 = [];

    this.groups = [];

    this.morphTargets = {};

    this.skinWeights = [];
    this.skinIndices = [];

    // this.lineDistances = [];

    this.boundingBox = null;
    this.boundingSphere = null;

    // update flags

    this.verticesNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.groupsNeedUpdate = false;

};

THREE.DirectGeometry.prototype = {

    constructor: THREE.DirectGeometry,

    computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,
    computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,

    computeFaceNormals: function () {

        console.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );

    },

    computeVertexNormals: function () {

        console.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );

    },

    computeGroups: function ( geometry ) {

        var group;
        var groups = [];
        var materialIndex;

        var faces = geometry.faces;

        for ( var i = 0; i < faces.length; i ++ ) {

            var face = faces[ i ];

            // materials

            if ( face.materialIndex !== materialIndex ) {

                materialIndex = face.materialIndex;

                if ( group !== undefined ) {

                    group.count = ( i * 3 ) - group.start;
                    groups.push( group );

                }

                group = {
                    start: i * 3,
                    materialIndex: materialIndex
                };

            }

        }

        if ( group !== undefined ) {

            group.count = ( i * 3 ) - group.start;
            groups.push( group );

        }

        this.groups = groups;

    },

    fromGeometry: function ( geometry ) {

        var faces = geometry.faces;
        var vertices = geometry.vertices;
        var faceVertexUvs = geometry.faceVertexUvs;

        var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
        var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

        // morphs

        var morphTargets = geometry.morphTargets;
        var morphTargetsLength = morphTargets.length;

        if ( morphTargetsLength > 0 ) {

            var morphTargetsPosition = [];

            for ( var i = 0; i < morphTargetsLength; i ++ ) {

                morphTargetsPosition[ i ] = [];

            }

            this.morphTargets.position = morphTargetsPosition;

        }

        var morphNormals = geometry.morphNormals;
        var morphNormalsLength = morphNormals.length;

        if ( morphNormalsLength > 0 ) {

            var morphTargetsNormal = [];

            for ( var i = 0; i < morphNormalsLength; i ++ ) {

                morphTargetsNormal[ i ] = [];

            }

            this.morphTargets.normal = morphTargetsNormal;

        }

        // skins

        var skinIndices = geometry.skinIndices;
        var skinWeights = geometry.skinWeights;

        var hasSkinIndices = skinIndices.length === vertices.length;
        var hasSkinWeights = skinWeights.length === vertices.length;

        //

        for ( var i = 0; i < faces.length; i ++ ) {

            var face = faces[ i ];

            this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

            var vertexNormals = face.vertexNormals;

            if ( vertexNormals.length === 3 ) {

                this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

            } else {

                var normal = face.normal;

                this.normals.push( normal, normal, normal );

            }

            var vertexColors = face.vertexColors;

            if ( vertexColors.length === 3 ) {

                this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

            } else {

                var color = face.color;

                this.colors.push( color, color, color );

            }

            if ( hasFaceVertexUv === true ) {

                var vertexUvs = faceVertexUvs[ 0 ][ i ];

                if ( vertexUvs !== undefined ) {

                    this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

                } else {

                    console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

                    this.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );

                }

            }

            if ( hasFaceVertexUv2 === true ) {

                var vertexUvs = faceVertexUvs[ 1 ][ i ];

                if ( vertexUvs !== undefined ) {

                    this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

                } else {

                    console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

                    this.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );

                }

            }

            // morphs

            for ( var j = 0; j < morphTargetsLength; j ++ ) {

                var morphTarget = morphTargets[ j ].vertices;

                morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

            }

            for ( var j = 0; j < morphNormalsLength; j ++ ) {

                var morphNormal = morphNormals[ j ].vertexNormals[ i ];

                morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

            }

            // skins

            if ( hasSkinIndices ) {

                this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

            }

            if ( hasSkinWeights ) {

                this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

            }

        }

        this.computeGroups( geometry );

        this.verticesNeedUpdate = geometry.verticesNeedUpdate;
        this.normalsNeedUpdate = geometry.normalsNeedUpdate;
        this.colorsNeedUpdate = geometry.colorsNeedUpdate;
        this.uvsNeedUpdate = geometry.uvsNeedUpdate;
        this.groupsNeedUpdate = geometry.groupsNeedUpdate;

        return this;

    },

    dispose: function () {

        this.dispatchEvent( { type: 'dispose' } );

    }

};

THREE.EventDispatcher.prototype.apply( THREE.DirectGeometry.prototype );

// File:src/core/BufferGeometry.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometry = function () {

    Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

    this.uuid = THREE.Math.generateUUID();

    this.name = '';
    this.type = 'BufferGeometry';

    this.index = null;
    this.attributes = {};

    this.morphAttributes = {};

    this.groups = [];

    this.boundingBox = null;
    this.boundingSphere = null;

    this.drawRange = { start: 0, count: Infinity };

};

THREE.BufferGeometry.prototype = {

    constructor: THREE.BufferGeometry,

    addIndex: function ( index ) {

        console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
        this.setIndex( index );

    },

    getIndex: function () {

        return this.index;

    },

    setIndex: function ( index ) {

        this.index = index;

    },

    addAttribute: function ( name, attribute ) {

        if ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {

            console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

            this.addAttribute( name, new THREE.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

            return;

        }

        if ( name === 'index' ) {

            console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
            this.setIndex( attribute );

            return;

        }

        this.attributes[ name ] = attribute;

    },

    getAttribute: function ( name ) {

        return this.attributes[ name ];

    },

    removeAttribute: function ( name ) {

        delete this.attributes[ name ];

    },

    get drawcalls() {

        console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
        return this.groups;

    },

    get offsets() {

        console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
        return this.groups;

    },

    addDrawCall: function ( start, count, indexOffset ) {

        if ( indexOffset !== undefined ) {

            console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

        }

        console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
        this.addGroup( start, count );

    },

    clearDrawCalls: function () {

        console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
        this.clearGroups();

    },

    addGroup: function ( start, count, materialIndex ) {

        this.groups.push( {

            start: start,
            count: count,
            materialIndex: materialIndex !== undefined ? materialIndex : 0

        } );

    },

    clearGroups: function () {

        this.groups = [];

    },

    setDrawRange: function ( start, count ) {

        this.drawRange.start = start;
        this.drawRange.count = count;

    },

    applyMatrix: function ( matrix ) {

        var position = this.attributes.position;

        if ( position !== undefined ) {

            matrix.applyToVector3Array( position.array );
            position.needsUpdate = true;

        }

        var normal = this.attributes.normal;

        if ( normal !== undefined ) {

            var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

            normalMatrix.applyToVector3Array( normal.array );
            normal.needsUpdate = true;

        }

        if ( this.boundingBox !== null ) {

            this.computeBoundingBox();

        }

        if ( this.boundingSphere !== null ) {

            this.computeBoundingSphere();

        }

    },

    rotateX: function () {

        // rotate geometry around world x-axis

        var m1;

        return function rotateX( angle ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeRotationX( angle );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    rotateY: function () {

        // rotate geometry around world y-axis

        var m1;

        return function rotateY( angle ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeRotationY( angle );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    rotateZ: function () {

        // rotate geometry around world z-axis

        var m1;

        return function rotateZ( angle ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeRotationZ( angle );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    translate: function () {

        // translate geometry

        var m1;

        return function translate( x, y, z ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeTranslation( x, y, z );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    scale: function () {

        // scale geometry

        var m1;

        return function scale( x, y, z ) {

            if ( m1 === undefined ) m1 = new THREE.Matrix4();

            m1.makeScale( x, y, z );

            this.applyMatrix( m1 );

            return this;

        };

    }(),

    lookAt: function () {

        var obj;

        return function lookAt( vector ) {

            if ( obj === undefined ) obj = new THREE.Object3D();

            obj.lookAt( vector );

            obj.updateMatrix();

            this.applyMatrix( obj.matrix );

        };

    }(),

    center: function () {

        this.computeBoundingBox();

        var offset = this.boundingBox.center().negate();

        this.translate( offset.x, offset.y, offset.z );

        return offset;

    },

    setFromObject: function ( object ) {

        // console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

        var geometry = object.geometry;

        if ( object instanceof THREE.Points || object instanceof THREE.Line ) {

            var positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );
            var colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );

            this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
            this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

            if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

                var lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );

                this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

            }

            if ( geometry.boundingSphere !== null ) {

                this.boundingSphere = geometry.boundingSphere.clone();

            }

            if ( geometry.boundingBox !== null ) {

                this.boundingBox = geometry.boundingBox.clone();

            }

        } else if ( object instanceof THREE.Mesh ) {

            if ( geometry instanceof THREE.Geometry ) {

                this.fromGeometry( geometry );

            }

        }

        return this;

    },

    updateFromObject: function ( object ) {

        var geometry = object.geometry;

        if ( object instanceof THREE.Mesh ) {

            var direct = geometry.__directGeometry;

            if ( direct === undefined ) {

                return this.fromGeometry( geometry );

            }

            direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
            direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
            direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
            direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
            direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

            geometry.verticesNeedUpdate = false;
            geometry.normalsNeedUpdate = false;
            geometry.colorsNeedUpdate = false;
            geometry.uvsNeedUpdate = false;
            geometry.groupsNeedUpdate = false;

            geometry = direct;

        }

        if ( geometry.verticesNeedUpdate === true ) {

            var attribute = this.attributes.position;

            if ( attribute !== undefined ) {

                attribute.copyVector3sArray( geometry.vertices );
                attribute.needsUpdate = true;

            }

            geometry.verticesNeedUpdate = false;

        }

        if ( geometry.normalsNeedUpdate === true ) {

            var attribute = this.attributes.normal;

            if ( attribute !== undefined ) {

                attribute.copyVector3sArray( geometry.normals );
                attribute.needsUpdate = true;

            }

            geometry.normalsNeedUpdate = false;

        }

        if ( geometry.colorsNeedUpdate === true ) {

            var attribute = this.attributes.color;

            if ( attribute !== undefined ) {

                attribute.copyColorsArray( geometry.colors );
                attribute.needsUpdate = true;

            }

            geometry.colorsNeedUpdate = false;

        }

        if ( geometry.uvsNeedUpdate ) {

            var attribute = this.attributes.uv;

            if ( attribute !== undefined ) {

                attribute.copyVector2sArray( geometry.uvs );
                attribute.needsUpdate = true;

            }

            geometry.uvsNeedUpdate = false;

        }

        if ( geometry.lineDistancesNeedUpdate ) {

            var attribute = this.attributes.lineDistance;

            if ( attribute !== undefined ) {

                attribute.copyArray( geometry.lineDistances );
                attribute.needsUpdate = true;

            }

            geometry.lineDistancesNeedUpdate = false;

        }

        if ( geometry.groupsNeedUpdate ) {

            geometry.computeGroups( object.geometry );
            this.groups = geometry.groups;

            geometry.groupsNeedUpdate = false;

        }

        return this;

    },

    fromGeometry: function ( geometry ) {

        geometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );

        return this.fromDirectGeometry( geometry.__directGeometry );

    },

    fromDirectGeometry: function ( geometry ) {

        var positions = new Float32Array( geometry.vertices.length * 3 );
        this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

        if ( geometry.normals.length > 0 ) {

            var normals = new Float32Array( geometry.normals.length * 3 );
            this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

        }

        if ( geometry.colors.length > 0 ) {

            var colors = new Float32Array( geometry.colors.length * 3 );
            this.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

        }

        if ( geometry.uvs.length > 0 ) {

            var uvs = new Float32Array( geometry.uvs.length * 2 );
            this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

        }

        if ( geometry.uvs2.length > 0 ) {

            var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
            this.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

        }

        if ( geometry.indices.length > 0 ) {

            var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
            var indices = new TypeArray( geometry.indices.length * 3 );
            this.setIndex( new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );

        }

        // groups

        this.groups = geometry.groups;

        // morphs

        for ( var name in geometry.morphTargets ) {

            var array = [];
            var morphTargets = geometry.morphTargets[ name ];

            for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

                var morphTarget = morphTargets[ i ];

                var attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );

                array.push( attribute.copyVector3sArray( morphTarget ) );

            }

            this.morphAttributes[ name ] = array;

        }

        // skinning

        if ( geometry.skinIndices.length > 0 ) {

            var skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );
            this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

        }

        if ( geometry.skinWeights.length > 0 ) {

            var skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );
            this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

        }

        //

        if ( geometry.boundingSphere !== null ) {

            this.boundingSphere = geometry.boundingSphere.clone();

        }

        if ( geometry.boundingBox !== null ) {

            this.boundingBox = geometry.boundingBox.clone();

        }

        return this;

    },

    computeBoundingBox: function () {

        var vector = new THREE.Vector3();

        return function () {

            if ( this.boundingBox === null ) {

                this.boundingBox = new THREE.Box3();

            }

            var positions = this.attributes.position.array;

            if ( positions ) {

                var bb = this.boundingBox;
                bb.makeEmpty();

                for ( var i = 0, il = positions.length; i < il; i += 3 ) {

                    vector.fromArray( positions, i );
                    bb.expandByPoint( vector );

                }

            }

            if ( positions === undefined || positions.length === 0 ) {

                this.boundingBox.min.set( 0, 0, 0 );
                this.boundingBox.max.set( 0, 0, 0 );

            }

            if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

                console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

            }

        };

    }(),

    computeBoundingSphere: function () {

        var box = new THREE.Box3();
        var vector = new THREE.Vector3();

        return function () {

            if ( this.boundingSphere === null ) {

                this.boundingSphere = new THREE.Sphere();

            }

            var positions = this.attributes.position.array;

            if ( positions ) {

                box.makeEmpty();

                var center = this.boundingSphere.center;

                for ( var i = 0, il = positions.length; i < il; i += 3 ) {

                    vector.fromArray( positions, i );
                    box.expandByPoint( vector );

                }

                box.center( center );

                // hoping to find a boundingSphere with a radius smaller than the
                // boundingSphere of the boundingBox: sqrt(3) smaller in the best case

                var maxRadiusSq = 0;

                for ( var i = 0, il = positions.length; i < il; i += 3 ) {

                    vector.fromArray( positions, i );
                    maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

                }

                this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

                if ( isNaN( this.boundingSphere.radius ) ) {

                    console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

                }

            }

        };

    }(),

    computeFaceNormals: function () {

        // backwards compatibility

    },

    computeVertexNormals: function () {

        var index = this.index;
        var attributes = this.attributes;
        var groups = this.groups;

        if ( attributes.position ) {

            var positions = attributes.position.array;

            if ( attributes.normal === undefined ) {

                this.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );

            } else {

                // reset existing normals to zero

                var normals = attributes.normal.array;

                for ( var i = 0, il = normals.length; i < il; i ++ ) {

                    normals[ i ] = 0;

                }

            }

            var normals = attributes.normal.array;

            var vA, vB, vC,

                pA = new THREE.Vector3(),
                pB = new THREE.Vector3(),
                pC = new THREE.Vector3(),

                cb = new THREE.Vector3(),
                ab = new THREE.Vector3();

            // indexed elements

            if ( index ) {

                var indices = index.array;

                if ( groups.length === 0 ) {

                    this.addGroup( 0, indices.length );

                }

                for ( var j = 0, jl = groups.length; j < jl; ++ j ) {

                    var group = groups[ j ];

                    var start = group.start;
                    var count = group.count;

                    for ( var i = start, il = start + count; i < il; i += 3 ) {

                        vA = indices[ i + 0 ] * 3;
                        vB = indices[ i + 1 ] * 3;
                        vC = indices[ i + 2 ] * 3;

                        pA.fromArray( positions, vA );
                        pB.fromArray( positions, vB );
                        pC.fromArray( positions, vC );

                        cb.subVectors( pC, pB );
                        ab.subVectors( pA, pB );
                        cb.cross( ab );

                        normals[ vA ] += cb.x;
                        normals[ vA + 1 ] += cb.y;
                        normals[ vA + 2 ] += cb.z;

                        normals[ vB ] += cb.x;
                        normals[ vB + 1 ] += cb.y;
                        normals[ vB + 2 ] += cb.z;

                        normals[ vC ] += cb.x;
                        normals[ vC + 1 ] += cb.y;
                        normals[ vC + 2 ] += cb.z;

                    }

                }

            } else {

                // non-indexed elements (unconnected triangle soup)

                for ( var i = 0, il = positions.length; i < il; i += 9 ) {

                    pA.fromArray( positions, i );
                    pB.fromArray( positions, i + 3 );
                    pC.fromArray( positions, i + 6 );

                    cb.subVectors( pC, pB );
                    ab.subVectors( pA, pB );
                    cb.cross( ab );

                    normals[ i ] = cb.x;
                    normals[ i + 1 ] = cb.y;
                    normals[ i + 2 ] = cb.z;

                    normals[ i + 3 ] = cb.x;
                    normals[ i + 4 ] = cb.y;
                    normals[ i + 5 ] = cb.z;

                    normals[ i + 6 ] = cb.x;
                    normals[ i + 7 ] = cb.y;
                    normals[ i + 8 ] = cb.z;

                }

            }

            this.normalizeNormals();

            attributes.normal.needsUpdate = true;

        }

    },

    computeTangents: function () {

        console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );

    },

    computeOffsets: function ( size ) {

        console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.')

    },

    merge: function ( geometry, offset ) {

        if ( geometry instanceof THREE.BufferGeometry === false ) {

            console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
            return;

        }

        if ( offset === undefined ) offset = 0;

        var attributes = this.attributes;

        for ( var key in attributes ) {

            if ( geometry.attributes[ key ] === undefined ) continue;

            var attribute1 = attributes[ key ];
            var attributeArray1 = attribute1.array;

            var attribute2 = geometry.attributes[ key ];
            var attributeArray2 = attribute2.array;

            var attributeSize = attribute2.itemSize;

            for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

                attributeArray1[ j ] = attributeArray2[ i ];

            }

        }

        return this;

    },

    normalizeNormals: function () {

        var normals = this.attributes.normal.array;

        var x, y, z, n;

        for ( var i = 0, il = normals.length; i < il; i += 3 ) {

            x = normals[ i ];
            y = normals[ i + 1 ];
            z = normals[ i + 2 ];

            n = 1.0 / Math.sqrt( x * x + y * y + z * z );

            normals[ i ] *= n;
            normals[ i + 1 ] *= n;
            normals[ i + 2 ] *= n;

        }

    },

    toJSON: function () {

        var data = {
            metadata: {
                version: 4.4,
                type: 'BufferGeometry',
                generator: 'BufferGeometry.toJSON'
            }
        };

        // standard BufferGeometry serialization

        data.uuid = this.uuid;
        data.type = this.type;
        if ( this.name !== '' ) data.name = this.name;

        if ( this.parameters !== undefined ) {

            var parameters = this.parameters;

            for ( var key in parameters ) {

                if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

            }

            return data;

        }

        data.data = { attributes: {} };

        var index = this.index;

        if ( index !== null ) {

            var array = Array.prototype.slice.call( index.array );

            data.data.index = {
                type: index.array.constructor.name,
                array: array
            };

        }

        var attributes = this.attributes;

        for ( var key in attributes ) {

            var attribute = attributes[ key ];

            var array = Array.prototype.slice.call( attribute.array );

            data.data.attributes[ key ] = {
                itemSize: attribute.itemSize,
                type: attribute.array.constructor.name,
                array: array
            };

        }

        var groups = this.groups;

        if ( groups.length > 0 ) {

            data.data.groups = JSON.parse( JSON.stringify( groups ) );

        }

        var boundingSphere = this.boundingSphere;

        if ( boundingSphere !== null ) {

            data.data.boundingSphere = {
                center: boundingSphere.center.toArray(),
                radius: boundingSphere.radius
            };

        }

        return data;

    },

    clone: function () {

        return new this.constructor().copy( this );

    },

    copy: function ( source ) {

        var index = source.index;

        if ( index !== null ) {

            this.setIndex( index.clone() );

        }

        var attributes = source.attributes;

        for ( var name in attributes ) {

            var attribute = attributes[ name ];
            this.addAttribute( name, attribute.clone() );

        }

        var groups = source.groups;

        for ( var i = 0, l = groups.length; i < l; i ++ ) {

            var group = groups[ i ];
            this.addGroup( group.start, group.count );

        }

        return this;

    },

    dispose: function () {

        this.dispatchEvent( { type: 'dispose' } );

    }

};

THREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );

THREE.BufferGeometry.MaxIndex = 65535;

// File:src/core/InstancedBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedBufferGeometry = function () {

    THREE.BufferGeometry.call( this );

    this.type = 'InstancedBufferGeometry';
    this.maxInstancedCount = undefined;

};

THREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;

THREE.InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {

    this.groups.push( {

        start: start,
        count: count,
        instances: instances

    } );

};

THREE.InstancedBufferGeometry.prototype.copy = function ( source ) {

    var index = source.index;

    if ( index !== null ) {

        this.setIndex( index.clone() );

    }

    var attributes = source.attributes;

    for ( var name in attributes ) {

        var attribute = attributes[ name ];
        this.addAttribute( name, attribute.clone() );

    }

    var groups = source.groups;

    for ( var i = 0, l = groups.length; i < l; i ++ ) {

        var group = groups[ i ];
        this.addGroup( group.start, group.count, group.instances );

    }

    return this;

};

THREE.EventDispatcher.prototype.apply( THREE.InstancedBufferGeometry.prototype );

// File:src/animation/AnimationAction.js

/**
 *
 * A clip that has been explicitly scheduled.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.AnimationAction = function ( clip, startTime, timeScale, weight, loop ) {

    if ( clip === undefined ) throw new Error( 'clip is null' );
    this.clip = clip;
    this.localRoot = null;
    this.startTime = startTime || 0;
    this.timeScale = timeScale || 1;
    this.weight = weight || 1;
    this.loop = loop || THREE.LoopRepeat;
    this.loopCount = 0;
    this.enabled = true;	// allow for easy disabling of the action.

    this.actionTime = - this.startTime;
    this.clipTime = 0;

    this.propertyBindings = [];
};

/*
 THREE.LoopOnce = 2200;
 THREE.LoopRepeat = 2201;
 THREE.LoopPingPing = 2202;
 */

THREE.AnimationAction.prototype = {

    constructor: THREE.AnimationAction,

    setLocalRoot: function( localRoot ) {

        this.localRoot = localRoot;

        return this;

    },

    updateTime: function( clipDeltaTime ) {

        var previousClipTime = this.clipTime;
        var previousLoopCount = this.loopCount;
        var previousActionTime = this.actionTime;

        var duration = this.clip.duration;

        this.actionTime = this.actionTime + clipDeltaTime;

        if ( this.loop === THREE.LoopOnce ) {

            this.loopCount = 0;
            this.clipTime = Math.min( Math.max( this.actionTime, 0 ), duration );

            // if time is changed since last time, see if we have hit a start/end limit
            if ( this.clipTime !== previousClipTime ) {

                if ( this.clipTime === duration ) {

                    this.mixer.dispatchEvent( { type: 'finished', action: this, direction: 1 } );

                } else if ( this.clipTime === 0 ) {

                    this.mixer.dispatchEvent( { type: 'finished', action: this, direction: -1 } );

                }

            }


            return this.clipTime;

        }

        this.loopCount = Math.floor( this.actionTime / duration );

        var newClipTime = this.actionTime - this.loopCount * duration;
        newClipTime = newClipTime % duration;

        // if we are ping pong looping, ensure that we go backwards when appropriate
        if ( this.loop == THREE.LoopPingPong ) {

            if ( Math.abs( this.loopCount % 2 ) === 1 ) {

                newClipTime = duration - newClipTime;

            }

        }

        this.clipTime = newClipTime;

        if ( this.loopCount !== previousLoopCount ) {

            this.mixer.dispatchEvent( { type: 'loop', action: this, loopDelta: ( this.loopCount - this.loopCount ) } );

        }

        return this.clipTime;

    },

    syncWith: function( action ) {

        this.actionTime = action.actionTime;
        this.timeScale = action.timeScale;

        return this;
    },

    warpToDuration: function( duration ) {

        this.timeScale = this.clip.duration / duration;

        return this;
    },

    init: function( time ) {

        this.clipTime = time - this.startTime;

        return this;

    },

    update: function( clipDeltaTime ) {

        this.updateTime( clipDeltaTime );

        var clipResults = this.clip.getAt( this.clipTime );

        return clipResults;

    },

    getTimeScaleAt: function( time ) {

        if ( this.timeScale.getAt ) {
            // pass in time, not clip time, allows for fadein/fadeout across multiple loops of the clip
            return this.timeScale.getAt( time );

        }

        return this.timeScale;

    },

    getWeightAt: function( time ) {

        if ( this.weight.getAt ) {
            // pass in time, not clip time, allows for fadein/fadeout across multiple loops of the clip
            return this.weight.getAt( time );

        }

        return this.weight;

    }

};

// File:src/animation/AnimationClip.js

/**
 *
 * Reusable set of Tracks that represent an animation.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.AnimationClip = function ( name, duration, tracks ) {

    this.name = name;
    this.tracks = tracks;
    this.duration = ( duration !== undefined ) ? duration : -1;

    // this means it should figure out its duration by scanning the tracks
    if ( this.duration < 0 ) {
        for ( var i = 0; i < this.tracks.length; i ++ ) {
            var track = this.tracks[i];
            this.duration = Math.max( track.keys[ track.keys.length - 1 ].time );
        }
    }

    // maybe only do these on demand, as doing them here could potentially slow down loading
    // but leaving these here during development as this ensures a lot of testing of these functions
    this.trim();
    this.optimize();

    this.results = [];

};

THREE.AnimationClip.prototype = {

    constructor: THREE.AnimationClip,

    getAt: function( clipTime ) {

        clipTime = Math.max( 0, Math.min( clipTime, this.duration ) );

        for ( var i = 0; i < this.tracks.length; i ++ ) {

            var track = this.tracks[ i ];

            this.results[ i ] = track.getAt( clipTime );

        }

        return this.results;
    },

    trim: function() {

        for ( var i = 0; i < this.tracks.length; i ++ ) {

            this.tracks[ i ].trim( 0, this.duration );

        }

        return this;

    },

    optimize: function() {

        for ( var i = 0; i < this.tracks.length; i ++ ) {

            this.tracks[ i ].optimize();

        }

        return this;

    }

};


THREE.AnimationClip.CreateFromMorphTargetSequence = function( name, morphTargetSequence, fps ) {


    var numMorphTargets = morphTargetSequence.length;
    var tracks = [];

    for ( var i = 0; i < numMorphTargets; i ++ ) {

        var keys = [];

        keys.push( { time: ( i + numMorphTargets - 1 ) % numMorphTargets, value: 0 } );
        keys.push( { time: i, value: 1 } );
        keys.push( { time: ( i + 1 ) % numMorphTargets, value: 0 } );

        keys.sort( THREE.KeyframeTrack.keyComparer );

        // if there is a key at the first frame, duplicate it as the last frame as well for perfect loop.
        if ( keys[0].time === 0 ) {
            keys.push( {
                time: numMorphTargets,
                value: keys[0].value
            });
        }

        tracks.push( new THREE.NumberKeyframeTrack( '.morphTargetInfluences[' + morphTargetSequence[i].name + ']', keys ).scale( 1.0 / fps ) );
    }

    return new THREE.AnimationClip( name, -1, tracks );

};

THREE.AnimationClip.findByName = function( clipArray, name ) {

    for ( var i = 0; i < clipArray.length; i ++ ) {

        if ( clipArray[i].name === name ) {

            return clipArray[i];

        }
    }

    return null;

};

THREE.AnimationClip.CreateClipsFromMorphTargetSequences = function( morphTargets, fps ) {

    var animationToMorphTargets = {};

    // tested with https://regex101.com/ on trick sequences such flamingo_flyA_003, flamingo_run1_003, crdeath0059
    var pattern = /^([\w-]*?)([\d]+)$/;

    // sort morph target names into animation groups based patterns like Walk_001, Walk_002, Run_001, Run_002
    for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

        var morphTarget = morphTargets[ i ];
        var parts = morphTarget.name.match( pattern );

        if ( parts && parts.length > 1 ) {

            var name = parts[ 1 ];

            var animationMorphTargets = animationToMorphTargets[ name ];
            if ( ! animationMorphTargets ) {
                animationToMorphTargets[ name ] = animationMorphTargets = [];
            }

            animationMorphTargets.push( morphTarget );

        }

    }

    var clips = [];

    for ( var name in animationToMorphTargets ) {

        clips.push( THREE.AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps ) );
    }

    return clips;

};

// parse the standard JSON format for clips
THREE.AnimationClip.parse = function( json ) {

    var tracks = [];

    for ( var i = 0; i < json.tracks.length; i ++ ) {

        tracks.push( THREE.KeyframeTrack.parse( json.tracks[i] ).scale( 1.0 / json.fps ) );

    }

    return new THREE.AnimationClip( json.name, json.duration, tracks );

};


// parse the animation.hierarchy format
THREE.AnimationClip.parseAnimation = function( animation, bones, nodeName ) {

    if ( ! animation ) {
        console.error( "  no animation in JSONLoader data" );
        return null;
    }

    var convertTrack = function( trackName, animationKeys, propertyName, trackType, animationKeyToValueFunc ) {

        var keys = [];

        for ( var k = 0; k < animationKeys.length; k ++ ) {

            var animationKey = animationKeys[k];

            if ( animationKey[propertyName] !== undefined ) {

                keys.push( { time: animationKey.time, value: animationKeyToValueFunc( animationKey ) } );
            }

        }

        // only return track if there are actually keys.
        if ( keys.length > 0 ) {

            return new trackType( trackName, keys );

        }

        return null;

    };

    var tracks = [];

    var clipName = animation.name || 'default';
    var duration = animation.length || -1; // automatic length determination in AnimationClip.
    var fps = animation.fps || 30;

    var hierarchyTracks = animation.hierarchy || [];

    for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

        var animationKeys = hierarchyTracks[ h ].keys;

        // skip empty tracks
        if ( ! animationKeys || animationKeys.length == 0 ) {
            continue;
        }

        // process morph targets in a way exactly compatible with AnimationHandler.init( animation )
        if ( animationKeys[0].morphTargets ) {

            // figure out all morph targets used in this track
            var morphTargetNames = {};
            for ( var k = 0; k < animationKeys.length; k ++ ) {

                if ( animationKeys[k].morphTargets ) {
                    for ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {

                        morphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;
                    }
                }

            }

            // create a track for each morph target with all zero morphTargetInfluences except for the keys in which the morphTarget is named.
            for ( var morphTargetName in morphTargetNames ) {

                var keys = [];

                for ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {

                    var animationKey = animationKeys[k];

                    keys.push( {
                        time: animationKey.time,
                        value: (( animationKey.morphTarget === morphTargetName ) ? 1 : 0 )
                    });

                }

                tracks.push( new THREE.NumberKeyframeTrack( nodeName + '.morphTargetInfluence[' + morphTargetName + ']', keys ) );

            }

            duration = morphTargetNames.length * ( fps || 1.0 );

        } else {

            var boneName = nodeName + '.bones[' + bones[ h ].name + ']';

            // track contains positions...
            var positionTrack = convertTrack( boneName + '.position', animationKeys, 'pos', THREE.VectorKeyframeTrack, function( animationKey ) {
                return new THREE.Vector3().fromArray( animationKey.pos )
            } );

            if ( positionTrack ) tracks.push( positionTrack );

            // track contains quaternions...
            var quaternionTrack = convertTrack( boneName + '.quaternion', animationKeys, 'rot', THREE.QuaternionKeyframeTrack, function( animationKey ) {
                if ( animationKey.rot.slerp ) {
                    return animationKey.rot.clone();
                } else {
                    return new THREE.Quaternion().fromArray( animationKey.rot );
                }
            } );

            if ( quaternionTrack ) tracks.push( quaternionTrack );

            // track contains quaternions...
            var scaleTrack = convertTrack( boneName + '.scale', animationKeys, 'scl', THREE.VectorKeyframeTrack, function( animationKey ) {
                return new THREE.Vector3().fromArray( animationKey.scl )
            } );

            if ( scaleTrack ) tracks.push( scaleTrack );

        }
    }

    if ( tracks.length === 0 ) {

        return null;

    }

    var clip = new THREE.AnimationClip( clipName, duration, tracks );

    return clip;

};

// File:src/animation/AnimationMixer.js

/**
 *
 * Mixes together the AnimationClips scheduled by AnimationActions and applies them to the root and subtree
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.AnimationMixer = function( root ) {

    this.root = root;
    this.time = 0;
    this.timeScale = 1.0;
    this.actions = [];
    this.propertyBindingMap = {};

};

THREE.AnimationMixer.prototype = {

    constructor: THREE.AnimationMixer,

    addAction: function( action ) {

        // TODO: check for duplicate action names?  Or provide each action with a UUID?

        this.actions.push( action );
        action.init( this.time );
        action.mixer = this;

        var tracks = action.clip.tracks;

        var root = action.localRoot || this.root;

        for ( var i = 0; i < tracks.length; i ++ ) {

            var track = tracks[ i ];

            var propertyBindingKey = root.uuid + '-' + track.name;
            var propertyBinding = this.propertyBindingMap[ propertyBindingKey ];

            if ( propertyBinding === undefined ) {

                propertyBinding = new THREE.PropertyBinding( root, track.name );
                this.propertyBindingMap[ propertyBindingKey ] = propertyBinding;

            }

            // push in the same order as the tracks.
            action.propertyBindings.push( propertyBinding );

            // track usages of shared property bindings, because if we leave too many around, the mixer can get slow
            propertyBinding.referenceCount += 1;

        }

    },

    removeAllActions: function() {

        for ( var i = 0; i < this.actions.length; i ++ ) {

            this.actions[i].mixer = null;

        }

        // unbind all property bindings
        for ( var properyBindingKey in this.propertyBindingMap ) {

            this.propertyBindingMap[ properyBindingKey ].unbind();

        }

        this.actions = [];
        this.propertyBindingMap = {};

        return this;

    },

    removeAction: function( action ) {

        var index = this.actions.indexOf( action );

        if ( index !== - 1 ) {

            this.actions.splice( index, 1 );
            action.mixer = null;

        }


        // remove unused property bindings because if we leave them around the mixer can get slow
        var root = action.localRoot || this.root;
        var tracks = action.clip.tracks;

        for ( var i = 0; i < tracks.length; i ++ ) {

            var track = tracks[ i ];

            var propertyBindingKey = root.uuid + '-' + track.name;
            var propertyBinding = this.propertyBindingMap[ propertyBindingKey ];

            propertyBinding.referenceCount -= 1;

            if ( propertyBinding.referenceCount <= 0 ) {

                propertyBinding.unbind();

                delete this.propertyBindingMap[ propertyBindingKey ];

            }
        }

        return this;

    },

    // can be optimized if needed
    findActionByName: function( name ) {

        for ( var i = 0; i < this.actions.length; i ++ ) {

            if ( this.actions[i].name === name ) return this.actions[i];

        }

        return null;

    },

    play: function( action, optionalFadeInDuration ) {

        action.startTime = this.time;
        this.addAction( action );

        return this;

    },

    fadeOut: function( action, duration ) {

        var keys = [];

        keys.push( { time: this.time, value: 1 } );
        keys.push( { time: this.time + duration, value: 0 } );

        action.weight = new THREE.NumberKeyframeTrack( "weight", keys );

        return this;

    },

    fadeIn: function( action, duration ) {

        var keys = [];

        keys.push( { time: this.time, value: 0 } );
        keys.push( { time: this.time + duration, value: 1 } );

        action.weight = new THREE.NumberKeyframeTrack( "weight", keys );

        return this;

    },

    warp: function( action, startTimeScale, endTimeScale, duration ) {

        var keys = [];

        keys.push( { time: this.time, value: startTimeScale } );
        keys.push( { time: this.time + duration, value: endTimeScale } );

        action.timeScale = new THREE.NumberKeyframeTrack( "timeScale", keys );

        return this;

    },

    crossFade: function( fadeOutAction, fadeInAction, duration, warp ) {

        this.fadeOut( fadeOutAction, duration );
        this.fadeIn( fadeInAction, duration );

        if ( warp ) {

            var startEndRatio = fadeOutAction.clip.duration / fadeInAction.clip.duration;
            var endStartRatio = 1.0 / startEndRatio;

            this.warp( fadeOutAction, 1.0, startEndRatio, duration );
            this.warp( fadeInAction, endStartRatio, 1.0, duration );

        }

        return this;

    },

    update: function( deltaTime ) {

        var mixerDeltaTime = deltaTime * this.timeScale;
        this.time += mixerDeltaTime;

        for ( var i = 0; i < this.actions.length; i ++ ) {

            var action = this.actions[i];

            var weight = action.getWeightAt( this.time );

            var actionTimeScale = action.getTimeScaleAt( this.time );
            var actionDeltaTime = mixerDeltaTime * actionTimeScale;

            var actionResults = action.update( actionDeltaTime );

            if ( action.weight <= 0 || ! action.enabled ) continue;

            for ( var j = 0; j < actionResults.length; j ++ ) {

                var name = action.clip.tracks[j].name;

                action.propertyBindings[ j ].accumulate( actionResults[j], weight );

            }

        }

        // apply to nodes
        for ( var propertyBindingKey in this.propertyBindingMap ) {

            this.propertyBindingMap[ propertyBindingKey ].apply();

        }

        return this;

    }

};

THREE.EventDispatcher.prototype.apply( THREE.AnimationMixer.prototype );

// File:src/animation/AnimationUtils.js

/**
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.AnimationUtils = {

    getEqualsFunc: function( exemplarValue ) {

        if ( exemplarValue.equals ) {
            return function equals_object( a, b ) {
                return a.equals( b );
            }
        }

        return function equals_primitive( a, b ) {
            return ( a === b );
        };

    },

    clone: function( exemplarValue ) {

        var typeName = typeof exemplarValue;
        if ( typeName === "object" ) {
            if ( exemplarValue.clone ) {
                return exemplarValue.clone();
            }
            console.error( "can not figure out how to copy exemplarValue", exemplarValue );
        }

        return exemplarValue;

    },

    lerp: function( a, b, alpha, interTrack ) {

        var lerpFunc = THREE.AnimationUtils.getLerpFunc( a, interTrack );

        return lerpFunc( a, b, alpha );

    },

    lerp_object: function( a, b, alpha ) {
        return a.lerp( b, alpha );
    },

    slerp_object: function( a, b, alpha ) {
        return a.slerp( b, alpha );
    },

    lerp_number: function( a, b, alpha ) {
        return a * ( 1 - alpha ) + b * alpha;
    },

    lerp_boolean: function( a, b, alpha ) {
        return ( alpha < 0.5 ) ? a : b;
    },

    lerp_boolean_immediate: function( a, b, alpha ) {
        return a;
    },

    lerp_string: function( a, b, alpha ) {
        return ( alpha < 0.5 ) ? a : b;
    },

    lerp_string_immediate: function( a, b, alpha ) {
        return a;
    },

    // NOTE: this is an accumulator function that modifies the first argument (e.g. a).	This is to minimize memory alocations.
    getLerpFunc: function( exemplarValue, interTrack ) {

        if ( exemplarValue === undefined || exemplarValue === null ) throw new Error( "examplarValue is null" );

        var typeName = typeof exemplarValue;

        switch( typeName ) {

            case "object":
                if ( exemplarValue.lerp ) {
                    return THREE.AnimationUtils.lerp_object;
                }

                if ( exemplarValue.slerp ) {
                    return THREE.AnimationUtils.slerp_object;
                }
                break;

            case "number":
                return THREE.AnimationUtils.lerp_number;

            case "boolean":
                if ( interTrack ) {
                    return THREE.AnimationUtils.lerp_boolean;
                } else {
                    return THREE.AnimationUtils.lerp_boolean_immediate;
                }

            case "string":
                if ( interTrack ) {
                    return THREE.AnimationUtils.lerp_string;
                } else {
                    return THREE.AnimationUtils.lerp_string_immediate;
                }

        }

    }

};

// File:src/animation/KeyframeTrack.js

/**
 *
 * A Track that returns a keyframe interpolated value, currently linearly interpolated
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.KeyframeTrack = function ( name, keys ) {

    if ( name === undefined ) throw new Error( "track name is undefined" );
    if ( keys === undefined || keys.length === 0 ) throw new Error( "no keys in track named " + name );

    this.name = name;
    this.keys = keys;	// time in seconds, value as value

    // the index of the last result, used as a starting point for local search.
    this.lastIndex = 0;

    this.validate();
    this.optimize();

};

THREE.KeyframeTrack.prototype = {

    constructor: THREE.KeyframeTrack,

    getAt: function( time ) {


        // this can not go higher than this.keys.length.
        while( ( this.lastIndex < this.keys.length ) && ( time >= this.keys[this.lastIndex].time ) ) {
            this.lastIndex ++;
        };

        // this can not go lower than 0.
        while( ( this.lastIndex > 0 ) && ( time < this.keys[this.lastIndex - 1].time ) ) {
            this.lastIndex --;
        }

        if ( this.lastIndex >= this.keys.length ) {

            this.setResult( this.keys[ this.keys.length - 1 ].value );

            return this.result;

        }

        if ( this.lastIndex === 0 ) {

            this.setResult( this.keys[ 0 ].value );

            return this.result;

        }

        var prevKey = this.keys[ this.lastIndex - 1 ];
        this.setResult( prevKey.value );

        // if true, means that prev/current keys are identical, thus no interpolation required.
        if ( prevKey.constantToNext ) {

            return this.result;

        }

        // linear interpolation to start with
        var currentKey = this.keys[ this.lastIndex ];
        var alpha = ( time - prevKey.time ) / ( currentKey.time - prevKey.time );
        this.result = this.lerpValues( this.result, currentKey.value, alpha );

        return this.result;

    },

    // move all keyframes either forwards or backwards in time
    shift: function( timeOffset ) {

        if ( timeOffset !== 0.0 ) {

            for ( var i = 0; i < this.keys.length; i ++ ) {
                this.keys[i].time += timeOffset;
            }

        }

        return this;

    },

    // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
    scale: function( timeScale ) {

        if ( timeScale !== 1.0 ) {

            for ( var i = 0; i < this.keys.length; i ++ ) {
                this.keys[i].time *= timeScale;
            }

        }

        return this;

    },

    // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
    // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
    trim: function( startTime, endTime ) {

        var firstKeysToRemove = 0;
        for ( var i = 1; i < this.keys.length; i ++ ) {
            if ( this.keys[i] <= startTime ) {
                firstKeysToRemove ++;
            }
        }

        var lastKeysToRemove = 0;
        for ( var i = this.keys.length - 2; i > 0; i ++ ) {
            if ( this.keys[i] >= endTime ) {
                lastKeysToRemove ++;
            } else {
                break;
            }
        }

        // remove last keys first because it doesn't affect the position of the first keys (the otherway around doesn't work as easily)
        if ( ( firstKeysToRemove + lastKeysToRemove ) > 0 ) {
            this.keys = this.keys.splice( firstKeysToRemove, this.keys.length - lastKeysToRemove - firstKeysToRemove );;
        }

        return this;

    },

    /* NOTE: This is commented out because we really shouldn't have to handle unsorted key lists
     Tracks with out of order keys should be considered to be invalid.  - bhouston
     sort: function() {

     this.keys.sort( THREE.KeyframeTrack.keyComparer );

     return this;

     },*/

    // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
    // One could eventually ensure that all key.values in a track are all of the same type (otherwise interpolation makes no sense.)
    validate: function() {

        var prevKey = null;

        if ( this.keys.length === 0 ) {
            console.error( "  track is empty, no keys", this );
            return;
        }

        for ( var i = 0; i < this.keys.length; i ++ ) {

            var currKey = this.keys[i];

            if ( ! currKey ) {
                console.error( "  key is null in track", this, i );
                return;
            }

            if ( ( typeof currKey.time ) !== 'number' || isNaN( currKey.time ) ) {
                console.error( "  key.time is not a valid number", this, i, currKey );
                return;
            }

            if ( currKey.value === undefined || currKey.value === null) {
                console.error( "  key.value is null in track", this, i, currKey );
                return;
            }

            if ( prevKey && prevKey.time > currKey.time ) {
                console.error( "  key.time is less than previous key time, out of order keys", this, i, currKey, prevKey );
                return;
            }

            prevKey = currKey;

        }

        return this;

    },

    // currently only removes equivalent sequential keys (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0), which are common in morph target animations
    optimize: function() {

        var newKeys = [];
        var prevKey = this.keys[0];
        newKeys.push( prevKey );

        var equalsFunc = THREE.AnimationUtils.getEqualsFunc( prevKey.value );

        for ( var i = 1; i < this.keys.length - 1; i ++ ) {
            var currKey = this.keys[i];
            var nextKey = this.keys[i+1];

            // if prevKey & currKey are the same time, remove currKey.  If you want immediate adjacent keys, use an epsilon offset
            // it is not possible to have two keys at the same time as we sort them.  The sort is not stable on keys with the same time.
            if ( ( prevKey.time === currKey.time ) ) {

                continue;

            }

            // remove completely unnecessary keyframes that are the same as their prev and next keys
            if ( this.compareValues( prevKey.value, currKey.value ) && this.compareValues( currKey.value, nextKey.value ) ) {

                continue;

            }

            // determine if interpolation is required
            prevKey.constantToNext = this.compareValues( prevKey.value, currKey.value );

            newKeys.push( currKey );
            prevKey = currKey;
        }
        newKeys.push( this.keys[ this.keys.length - 1 ] );

        this.keys = newKeys;

        return this;

    }

};

THREE.KeyframeTrack.keyComparer = function keyComparator(key0, key1) {
    return key0.time - key1.time;
};

THREE.KeyframeTrack.parse = function( json ) {

    if ( json.type === undefined ) throw new Error( "track type undefined, can not parse" );

    var trackType = THREE.KeyframeTrack.GetTrackTypeForTypeName( json.type );

    return trackType.parse( json );

};

THREE.KeyframeTrack.GetTrackTypeForTypeName = function( typeName ) {
    switch( typeName.toLowerCase() ) {
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
            return THREE.VectorKeyframeTrack;

        case "quaternion":
            return THREE.QuaternionKeyframeTrack;

        case "integer":
        case "scalar":
        case "double":
        case "float":
        case "number":
            return THREE.NumberKeyframeTrack;

        case "bool":
        case "boolean":
            return THREE.BooleanKeyframeTrack;

        case "string":
            return THREE.StringKeyframeTrack;
    };

    throw new Error( "Unsupported typeName: " + typeName );
};

// File:src/animation/PropertyBinding.js

/**
 *
 * A track bound to a real value in the scene graph.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.PropertyBinding = function ( rootNode, trackName ) {

    this.rootNode = rootNode;
    this.trackName = trackName;
    this.referenceCount = 0;
    this.originalValue = null; // the value of the property before it was controlled by this binding

    var parseResults = THREE.PropertyBinding.parseTrackName( trackName );

    this.directoryName = parseResults.directoryName;
    this.nodeName = parseResults.nodeName;
    this.objectName = parseResults.objectName;
    this.objectIndex = parseResults.objectIndex;
    this.propertyName = parseResults.propertyName;
    this.propertyIndex = parseResults.propertyIndex;

    this.node = THREE.PropertyBinding.findNode( rootNode, this.nodeName ) || rootNode;

    this.cumulativeValue = null;
    this.cumulativeWeight = 0;
};

THREE.PropertyBinding.prototype = {

    constructor: THREE.PropertyBinding,

    reset: function() {

        this.cumulativeValue = null;
        this.cumulativeWeight = 0;

    },

    accumulate: function( value, weight ) {

        if ( ! this.isBound ) this.bind();

        if ( this.cumulativeWeight === 0 ) {

            if ( weight > 0 ) {

                if ( this.cumulativeValue === null ) {
                    this.cumulativeValue = THREE.AnimationUtils.clone( value );
                }
                this.cumulativeWeight = weight;

            }

        } else {

            var lerpAlpha = weight / ( this.cumulativeWeight + weight );
            this.cumulativeValue = this.lerpValue( this.cumulativeValue, value, lerpAlpha );
            this.cumulativeWeight += weight;

        }

    },

    unbind: function() {

        if ( ! this.isBound ) return;

        this.setValue( this.originalValue );

        this.setValue = null;
        this.getValue = null;
        this.lerpValue = null;
        this.equalsValue = null;
        this.triggerDirty = null;
        this.isBound = false;

    },

    // bind to the real property in the scene graph, remember original value, memorize various accessors for speed/inefficiency
    bind: function() {

        if ( this.isBound ) return;

        var targetObject = this.node;

        // ensure there is a value node
        if ( ! targetObject ) {
            console.error( "  trying to update node for track: " + this.trackName + " but it wasn't found." );
            return;
        }

        if ( this.objectName ) {
            // special case were we need to reach deeper into the hierarchy to get the face materials....
            if ( this.objectName === "materials" ) {
                if ( ! targetObject.material ) {
                    console.error( '  can not bind to material as node does not have a material', this );
                    return;
                }
                if ( ! targetObject.material.materials ) {
                    console.error( '  can not bind to material.materials as node.material does not have a materials array', this );
                    return;
                }
                targetObject = targetObject.material.materials;
            } else if ( this.objectName === "bones" ) {
                if ( ! targetObject.skeleton ) {
                    console.error( '  can not bind to bones as node does not have a skeleton', this );
                    return;
                }
                // potential future optimization: skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

                targetObject = targetObject.skeleton.bones;

                // support resolving morphTarget names into indices.
                for ( var i = 0; i < targetObject.length; i ++ ) {
                    if ( targetObject[i].name === this.objectIndex ) {
                        this.objectIndex = i;
                        break;
                    }
                }
            } else {

                if ( targetObject[ this.objectName ] === undefined ) {
                    console.error( '  can not bind to objectName of node, undefined', this );
                    return;
                }
                targetObject = targetObject[ this.objectName ];
            }

            if ( this.objectIndex !== undefined ) {
                if ( targetObject[ this.objectIndex ] === undefined ) {
                    console.error( "  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject );
                    return;
                }

                targetObject = targetObject[ this.objectIndex ];
            }

        }

        // special case mappings
        var nodeProperty = targetObject[ this.propertyName ];
        if ( ! nodeProperty ) {
            console.error( "  trying to update property for track: " + this.nodeName + '.' + this.propertyName + " but it wasn't found.", targetObject );
            return;
        }

        // access a sub element of the property array (only primitives are supported right now)
        if ( this.propertyIndex !== undefined ) {

            if ( this.propertyName === "morphTargetInfluences" ) {
                // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

                // support resolving morphTarget names into indices.
                if ( ! targetObject.geometry ) {
                    console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );
                }
                if ( ! targetObject.geometry.morphTargets ) {
                    console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );
                }

                for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {
                    if ( targetObject.geometry.morphTargets[i].name === this.propertyIndex ) {
                        this.propertyIndex = i;
                        break;
                    }
                }
            }

            this.setValue = function setValue_propertyIndexed( value ) {
                if ( ! this.equalsValue( nodeProperty[ this.propertyIndex ], value ) ) {
                    nodeProperty[ this.propertyIndex ] = value;
                    return true;
                }
                return false;
            };

            this.getValue = function getValue_propertyIndexed() {
                return nodeProperty[ this.propertyIndex ];
            };

        }
        // must use copy for Object3D.Euler/Quaternion
        else if ( nodeProperty.copy ) {

            this.setValue = function setValue_propertyObject( value ) {
                if ( ! this.equalsValue( nodeProperty, value ) ) {
                    nodeProperty.copy( value );
                    return true;
                }
                return false;
            }

            this.getValue = function getValue_propertyObject() {
                return nodeProperty;
            };

        }
        // otherwise just set the property directly on the node (do not use nodeProperty as it may not be a reference object)
        else {

            this.setValue = function setValue_property( value ) {
                if ( ! this.equalsValue( targetObject[ this.propertyName ], value ) ) {
                    targetObject[ this.propertyName ] = value;
                    return true;
                }
                return false;
            }

            this.getValue = function getValue_property() {
                return targetObject[ this.propertyName ];
            };

        }

        // trigger node dirty
        if ( targetObject.needsUpdate !== undefined ) { // material

            this.triggerDirty = function triggerDirty_needsUpdate() {
                this.node.needsUpdate = true;
            }

        } else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

            this.triggerDirty = function triggerDirty_matrixWorldNeedsUpdate() {
                targetObject.matrixWorldNeedsUpdate = true;
            }

        }

        this.originalValue = this.getValue();

        this.equalsValue = THREE.AnimationUtils.getEqualsFunc( this.originalValue );
        this.lerpValue = THREE.AnimationUtils.getLerpFunc( this.originalValue, true );

        this.isBound = true;

    },

    apply: function() {

        // for speed capture the setter pattern as a closure (sort of a memoization pattern: https://en.wikipedia.org/wiki/Memoization)
        if ( ! this.isBound ) this.bind();

        // early exit if there is nothing to apply.
        if ( this.cumulativeWeight > 0 ) {

            // blend with original value
            if ( this.cumulativeWeight < 1 ) {

                var remainingWeight = 1 - this.cumulativeWeight;
                var lerpAlpha = remainingWeight / ( this.cumulativeWeight + remainingWeight );
                this.cumulativeValue = this.lerpValue( this.cumulativeValue, this.originalValue, lerpAlpha );

            }

            var valueChanged = this.setValue( this.cumulativeValue );

            if ( valueChanged && this.triggerDirty ) {
                this.triggerDirty();
            }

            // reset accumulator
            this.cumulativeValue = null;
            this.cumulativeWeight = 0;

        }
    }

};


THREE.PropertyBinding.parseTrackName = function( trackName ) {

    // matches strings in the form of:
    //    nodeName.property
    //    nodeName.property[accessor]
    //    nodeName.material.property[accessor]
    //    uuid.property[accessor]
    //    uuid.objectName[objectIndex].propertyName[propertyIndex]
    //    parentName/nodeName.property
    //    parentName/parentName/nodeName.property[index]
    //	  .bone[Armature.DEF_cog].position
    // created and tested via https://regex101.com/#javascript

    var re = /^(([\w]+\/)*)([\w-\d]+)?(\.([\w]+)(\[([\w\d\[\]\_. ]+)\])?)?(\.([\w.]+)(\[([\w\d\[\]\_. ]+)\])?)$/;
    var matches = re.exec(trackName);

    if ( ! matches ) {
        throw new Error( "cannot parse trackName at all: " + trackName );
    }

    if (matches.index === re.lastIndex) {
        re.lastIndex++;
    }

    var results = {
        directoryName: matches[1],
        nodeName: matches[3], 	// allowed to be null, specified root node.
        objectName: matches[5],
        objectIndex: matches[7],
        propertyName: matches[9],
        propertyIndex: matches[11]	// allowed to be null, specifies that the whole property is set.
    };

    if ( results.propertyName === null || results.propertyName.length === 0 ) {
        throw new Error( "can not parse propertyName from trackName: " + trackName );
    }

    return results;

};

THREE.PropertyBinding.findNode = function( root, nodeName ) {

    function searchSkeleton( skeleton ) {

        for ( var i = 0; i < skeleton.bones.length; i ++ ) {

            var bone = skeleton.bones[i];

            if ( bone.name === nodeName ) {

                return bone;

            }
        }

        return null;

    }

    function searchNodeSubtree( children ) {

        for ( var i = 0; i < children.length; i ++ ) {

            var childNode = children[i];

            if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

                return childNode;

            }

            var result = searchNodeSubtree( childNode.children );

            if ( result ) return result;

        }

        return null;

    }

    //

    if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {

        return root;

    }

    // search into skeleton bones.
    if ( root.skeleton ) {

        var bone = searchSkeleton( root.skeleton );

        if ( bone ) {

            return bone;

        }
    }

    // search into node subtree.
    if ( root.children ) {

        var subTreeNode = searchNodeSubtree( root.children );

        if ( subTreeNode ) {

            return subTreeNode;

        }

    }

    return null;
}

// File:src/animation/tracks/VectorKeyframeTrack.js

/**
 *
 * A Track that interpolates Vectors
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.VectorKeyframeTrack = function ( name, keys ) {

    THREE.KeyframeTrack.call( this, name, keys );

    // local cache of value type to avoid allocations during runtime.
    this.result = this.keys[0].value.clone();

};

THREE.VectorKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );

THREE.VectorKeyframeTrack.prototype.constructor = THREE.VectorKeyframeTrack;

THREE.VectorKeyframeTrack.prototype.setResult = function( value ) {

    this.result.copy( value );

};

// memoization of the lerp function for speed.
// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
THREE.VectorKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {

    return value0.lerp( value1, alpha );

};

THREE.VectorKeyframeTrack.prototype.compareValues = function( value0, value1 ) {

    return value0.equals( value1 );

};

THREE.VectorKeyframeTrack.prototype.clone = function() {

    var clonedKeys = [];

    for ( var i = 0; i < this.keys.length; i ++ ) {

        var key = this.keys[i];
        clonedKeys.push( {
            time: key.time,
            value: key.value.clone()
        } );
    }

    return new THREE.VectorKeyframeTrack( this.name, clonedKeys );

};

THREE.VectorKeyframeTrack.parse = function( json ) {

    var elementCount = json.keys[0].value.length;
    var valueType = THREE[ 'Vector' + elementCount ];

    var keys = [];

    for ( var i = 0; i < json.keys.length; i ++ ) {
        var jsonKey = json.keys[i];
        keys.push( {
            value: new valueType().fromArray( jsonKey.value ),
            time: jsonKey.time
        } );
    }

    return new THREE.VectorKeyframeTrack( json.name, keys );

};

// File:src/animation/tracks/QuaternionKeyframeTrack.js

/**
 *
 * A Track that interpolates Quaternion
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.QuaternionKeyframeTrack = function ( name, keys ) {

    THREE.KeyframeTrack.call( this, name, keys );

    // local cache of value type to avoid allocations during runtime.
    this.result = this.keys[0].value.clone();

};

THREE.QuaternionKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );

THREE.QuaternionKeyframeTrack.prototype.constructor = THREE.QuaternionKeyframeTrack;

THREE.QuaternionKeyframeTrack.prototype.setResult = function( value ) {

    this.result.copy( value );

};

// memoization of the lerp function for speed.
// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
THREE.QuaternionKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {

    return value0.slerp( value1, alpha );

};

THREE.QuaternionKeyframeTrack.prototype.compareValues = function( value0, value1 ) {

    return value0.equals( value1 );

};

THREE.QuaternionKeyframeTrack.prototype.multiply = function( quat ) {

    for ( var i = 0; i < this.keys.length; i ++ ) {

        this.keys[i].value.multiply( quat );

    }

    return this;

};

THREE.QuaternionKeyframeTrack.prototype.clone = function() {

    var clonedKeys = [];

    for ( var i = 0; i < this.keys.length; i ++ ) {

        var key = this.keys[i];
        clonedKeys.push( {
            time: key.time,
            value: key.value.clone()
        } );
    }

    return new THREE.QuaternionKeyframeTrack( this.name, clonedKeys );

};

THREE.QuaternionKeyframeTrack.parse = function( json ) {

    var keys = [];

    for ( var i = 0; i < json.keys.length; i ++ ) {
        var jsonKey = json.keys[i];
        keys.push( {
            value: new THREE.Quaternion().fromArray( jsonKey.value ),
            time: jsonKey.time
        } );
    }

    return new THREE.QuaternionKeyframeTrack( json.name, keys );

};

// File:src/animation/tracks/StringKeyframeTrack.js

/**
 *
 * A Track that interpolates Strings
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.StringKeyframeTrack = function ( name, keys ) {

    THREE.KeyframeTrack.call( this, name, keys );

    // local cache of value type to avoid allocations during runtime.
    this.result = this.keys[0].value;

};

THREE.StringKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );

THREE.StringKeyframeTrack.prototype.constructor = THREE.StringKeyframeTrack;

THREE.StringKeyframeTrack.prototype.setResult = function( value ) {

    this.result = value;

};

// memoization of the lerp function for speed.
// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
THREE.StringKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {

    return ( alpha < 1.0 ) ? value0 : value1;

};

THREE.StringKeyframeTrack.prototype.compareValues = function( value0, value1 ) {

    return ( value0 === value1 );

};

THREE.StringKeyframeTrack.prototype.clone = function() {

    var clonedKeys = [];

    for ( var i = 0; i < this.keys.length; i ++ ) {

        var key = this.keys[i];
        clonedKeys.push( {
            time: key.time,
            value: key.value
        } );
    }

    return new THREE.StringKeyframeTrack( this.name, clonedKeys );

};

THREE.StringKeyframeTrack.parse = function( json ) {

    return new THREE.StringKeyframeTrack( json.name, json.keys );

};

// File:src/animation/tracks/BooleanKeyframeTrack.js

/**
 *
 * A Track that interpolates Boolean
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.BooleanKeyframeTrack = function ( name, keys ) {

    THREE.KeyframeTrack.call( this, name, keys );

    // local cache of value type to avoid allocations during runtime.
    this.result = this.keys[0].value;

};

THREE.BooleanKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );

THREE.BooleanKeyframeTrack.prototype.constructor = THREE.BooleanKeyframeTrack;

THREE.BooleanKeyframeTrack.prototype.setResult = function( value ) {

    this.result = value;

};

// memoization of the lerp function for speed.
// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
THREE.BooleanKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {

    return ( alpha < 1.0 ) ? value0 : value1;

};

THREE.BooleanKeyframeTrack.prototype.compareValues = function( value0, value1 ) {

    return ( value0 === value1 );

};

THREE.BooleanKeyframeTrack.prototype.clone = function() {

    var clonedKeys = [];

    for ( var i = 0; i < this.keys.length; i ++ ) {

        var key = this.keys[i];
        clonedKeys.push( {
            time: key.time,
            value: key.value
        } );
    }

    return new THREE.BooleanKeyframeTrack( this.name, clonedKeys );

};

THREE.BooleanKeyframeTrack.parse = function( json ) {

    return new THREE.BooleanKeyframeTrack( json.name, json.keys );

};

// File:src/animation/tracks/NumberKeyframeTrack.js

/**
 *
 * A Track that interpolates Numbers
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.NumberKeyframeTrack = function ( name, keys ) {

    THREE.KeyframeTrack.call( this, name, keys );

    // local cache of value type to avoid allocations during runtime.
    this.result = this.keys[0].value;

};

THREE.NumberKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );

THREE.NumberKeyframeTrack.prototype.constructor = THREE.NumberKeyframeTrack;

THREE.NumberKeyframeTrack.prototype.setResult = function( value ) {

    this.result = value;

};

// memoization of the lerp function for speed.
// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
THREE.NumberKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {

    return value0 * ( 1 - alpha ) + value1 * alpha;

};

THREE.NumberKeyframeTrack.prototype.compareValues = function( value0, value1 ) {

    return ( value0 === value1 );

};

THREE.NumberKeyframeTrack.prototype.clone = function() {

    var clonedKeys = [];

    for ( var i = 0; i < this.keys.length; i ++ ) {

        var key = this.keys[i];
        clonedKeys.push( {
            time: key.time,
            value: key.value
        } );
    }

    return new THREE.NumberKeyframeTrack( this.name, clonedKeys );

};

THREE.NumberKeyframeTrack.parse = function( json ) {

    return new THREE.NumberKeyframeTrack( json.name, json.keys );

};

// File:src/cameras/Camera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Camera = function () {

    THREE.Object3D.call( this );

    this.type = 'Camera';

    this.matrixWorldInverse = new THREE.Matrix4();
    this.projectionMatrix = new THREE.Matrix4();

};

THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );
THREE.Camera.prototype.constructor = THREE.Camera;

THREE.Camera.prototype.getWorldDirection = function () {

    var quaternion = new THREE.Quaternion();

    return function ( optionalTarget ) {

        var result = optionalTarget || new THREE.Vector3();

        this.getWorldQuaternion( quaternion );

        return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

    };

}();

THREE.Camera.prototype.lookAt = function () {

    // This routine does not support cameras with rotated and/or translated parent(s)

    var m1 = new THREE.Matrix4();

    return function ( vector ) {

        m1.lookAt( this.position, vector, this.up );

        this.quaternion.setFromRotationMatrix( m1 );

    };

}();

THREE.Camera.prototype.clone = function () {

    return new this.constructor().copy( this );

};

THREE.Camera.prototype.copy = function ( source ) {

    THREE.Object3D.prototype.copy.call( this, source );

    this.matrixWorldInverse.copy( source.matrixWorldInverse );
    this.projectionMatrix.copy( source.projectionMatrix );

    return this;

};

// File:src/cameras/CubeCamera.js

/**
 * Camera for rendering cube maps
 *	- renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CubeCamera = function ( near, far, cubeResolution ) {

    THREE.Object3D.call( this );

    this.type = 'CubeCamera';

    var fov = 90, aspect = 1;

    var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
    cameraPX.up.set( 0, - 1, 0 );
    cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
    this.add( cameraPX );

    var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
    cameraNX.up.set( 0, - 1, 0 );
    cameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );
    this.add( cameraNX );

    var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
    cameraPY.up.set( 0, 0, 1 );
    cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
    this.add( cameraPY );

    var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
    cameraNY.up.set( 0, 0, - 1 );
    cameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );
    this.add( cameraNY );

    var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
    cameraPZ.up.set( 0, - 1, 0 );
    cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
    this.add( cameraPZ );

    var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
    cameraNZ.up.set( 0, - 1, 0 );
    cameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );
    this.add( cameraNZ );

    this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );

    this.updateCubeMap = function ( renderer, scene ) {

        if ( this.parent === null ) this.updateMatrixWorld();

        var renderTarget = this.renderTarget;
        var generateMipmaps = renderTarget.texture.generateMipmaps;

        renderTarget.texture.generateMipmaps = false;

        renderTarget.activeCubeFace = 0;
        renderer.render( scene, cameraPX, renderTarget );

        renderTarget.activeCubeFace = 1;
        renderer.render( scene, cameraNX, renderTarget );

        renderTarget.activeCubeFace = 2;
        renderer.render( scene, cameraPY, renderTarget );

        renderTarget.activeCubeFace = 3;
        renderer.render( scene, cameraNY, renderTarget );

        renderTarget.activeCubeFace = 4;
        renderer.render( scene, cameraPZ, renderTarget );

        renderTarget.texture.generateMipmaps = generateMipmaps;

        renderTarget.activeCubeFace = 5;
        renderer.render( scene, cameraNZ, renderTarget );

        renderer.setRenderTarget( null );

    };

};

THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );
THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;

// File:src/cameras/OrthographicCamera.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {

    THREE.Camera.call( this );

    this.type = 'OrthographicCamera';

    this.zoom = 1;

    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;

    this.near = ( near !== undefined ) ? near : 0.1;
    this.far = ( far !== undefined ) ? far : 2000;

    this.updateProjectionMatrix();

};

THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );
THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;

THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {

    var dx = ( this.right - this.left ) / ( 2 * this.zoom );
    var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
    var cx = ( this.right + this.left ) / 2;
    var cy = ( this.top + this.bottom ) / 2;

    this.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );

};

THREE.OrthographicCamera.prototype.copy = function ( source ) {

    THREE.Camera.prototype.copy.call( this, source );

    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;

    this.zoom = source.zoom;

    return this;

};

THREE.OrthographicCamera.prototype.toJSON = function ( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;

    return data;

};

// File:src/cameras/PerspectiveCamera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {

    THREE.Camera.call( this );

    this.type = 'PerspectiveCamera';

    this.zoom = 1;

    this.fov = fov !== undefined ? fov : 50;
    this.aspect = aspect !== undefined ? aspect : 1;
    this.near = near !== undefined ? near : 0.1;
    this.far = far !== undefined ? far : 2000;

    this.updateProjectionMatrix();

};

THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );
THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;


/**
 * Uses Focal Length (in mm) to estimate and set FOV
 * 35mm (full-frame) camera is used if frame size is not specified;
 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
 */

THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {

    if ( frameHeight === undefined ) frameHeight = 24;

    this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
    this.updateProjectionMatrix();

};


/**
 * Sets an offset in a larger frustum. This is useful for multi-window or
 * multi-monitor/multi-machine setups.
 *
 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
 * the monitors are in grid like this
 *
 *   +---+---+---+
 *   | A | B | C |
 *   +---+---+---+
 *   | D | E | F |
 *   +---+---+---+
 *
 * then for each monitor you would call it like this
 *
 *   var w = 1920;
 *   var h = 1080;
 *   var fullWidth = w * 3;
 *   var fullHeight = h * 2;
 *
 *   --A--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
 *   --B--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
 *   --C--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
 *   --D--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
 *   --E--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
 *   --F--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
 *
 *   Note there is no reason monitors have to be the same size or in a grid.
 */

THREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {

    this.fullWidth = fullWidth;
    this.fullHeight = fullHeight;
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;

    this.updateProjectionMatrix();

};


THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {

    var fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );

    if ( this.fullWidth ) {

        var aspect = this.fullWidth / this.fullHeight;
        var top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;
        var bottom = - top;
        var left = aspect * bottom;
        var right = aspect * top;
        var width = Math.abs( right - left );
        var height = Math.abs( top - bottom );

        this.projectionMatrix.makeFrustum(
            left + this.x * width / this.fullWidth,
            left + ( this.x + this.width ) * width / this.fullWidth,
            top - ( this.y + this.height ) * height / this.fullHeight,
            top - this.y * height / this.fullHeight,
            this.near,
            this.far
        );

    } else {

        this.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );

    }

};

THREE.PerspectiveCamera.prototype.copy = function ( source ) {

    THREE.Camera.prototype.copy.call( this, source );

    this.fov = source.fov;
    this.aspect = source.aspect;
    this.near = source.near;
    this.far = source.far;

    this.zoom = source.zoom;

    return this;

};

THREE.PerspectiveCamera.prototype.toJSON = function ( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    data.object.zoom = this.zoom;
    data.object.fov = this.fov;
    data.object.aspect = this.aspect;
    data.object.near = this.near;
    data.object.far = this.far;

    return data;

};

// File:src/lights/Light.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Light = function ( color ) {

    THREE.Object3D.call( this );

    this.type = 'Light';

    this.color = new THREE.Color( color );

    this.receiveShadow = undefined;

};

THREE.Light.prototype = Object.create( THREE.Object3D.prototype );
THREE.Light.prototype.constructor = THREE.Light;

Object.defineProperties( THREE.Light.prototype, {
    onlyShadow: {
        set: function ( value ) {
            console.warn( 'THREE.Light: .onlyShadow has been removed.' );
        }
    },
    shadowCameraFov: {
        set: function ( value ) {
            this.shadow.camera.fov = value;
        }
    },
    shadowCameraLeft: {
        set: function ( value ) {
            this.shadow.camera.left = value;
        }
    },
    shadowCameraRight: {
        set: function ( value ) {
            this.shadow.camera.right = value;
        }
    },
    shadowCameraTop: {
        set: function ( value ) {
            this.shadow.camera.top = value;
        }
    },
    shadowCameraBottom: {
        set: function ( value ) {
            this.shadow.camera.bottom = value;
        }
    },
    shadowCameraNear: {
        set: function ( value ) {
            this.shadow.camera.near = value;
        }
    },
    shadowCameraFar: {
        set: function ( value ) {
            this.shadow.camera.far = value;
        }
    },
    shadowCameraVisible: {
        set: function ( value ) {
            console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow ) instead.' );
        }
    },
    shadowBias: {
        set: function ( value ) {
            this.shadow.bias = value;
        }
    },
    shadowDarkness: {
        set: function ( value ) {
            this.shadow.darkness = value;
        }
    },
    shadowMapWidth: {
        set: function ( value ) {
            this.shadow.mapSize.width = value;
        }
    },
    shadowMapHeight: {
        set: function ( value ) {
            this.shadow.mapSize.height = value;
        }
    }
} );

THREE.Light.prototype.copy = function ( source ) {

    THREE.Object3D.prototype.copy.call( this, source );

    this.color.copy( source.color );

    return this;

};

THREE.Light.prototype.toJSON = function ( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    data.object.color = this.color.getHex();
    if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

    if ( this.intensity !== undefined ) data.object.intensity = this.intensity;
    if ( this.distance !== undefined ) data.object.distance = this.distance;
    if ( this.angle !== undefined ) data.object.angle = this.angle;
    if ( this.decay !== undefined ) data.object.decay = this.decay;
    if ( this.exponent !== undefined ) data.object.exponent = this.exponent;

    return data;

};

// File:src/lights/LightShadow.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LightShadow = function ( camera ) {

    this.camera = camera;

    this.bias = 0;
    this.darkness = 1;

    this.mapSize = new THREE.Vector2( 512, 512 );

    this.map = null;
    this.matrix = null;

};

THREE.LightShadow.prototype = {

    constructor: THREE.LightShadow,

    copy: function ( source ) {

        this.camera = source.camera.clone();

        this.bias = source.bias;
        this.darkness = source.darkness;

        this.mapSize.copy( source.mapSize );

    },

    clone: function () {

        return new this.constructor().copy( this );

    }

};

// File:src/lights/AmbientLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AmbientLight = function ( color ) {

    THREE.Light.call( this, color );

    this.type = 'AmbientLight';

    this.castShadow = undefined;

};

THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );
THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;

// File:src/lights/DirectionalLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DirectionalLight = function ( color, intensity ) {

    THREE.Light.call( this, color );

    this.type = 'DirectionalLight';

    this.position.set( 0, 1, 0 );
    this.updateMatrix();

    this.target = new THREE.Object3D();

    this.intensity = ( intensity !== undefined ) ? intensity : 1;

    this.shadow = new THREE.LightShadow( new THREE.OrthographicCamera( - 500, 500, 500, - 500, 50, 5000 ) );

};

THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );
THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;

THREE.DirectionalLight.prototype.copy = function ( source ) {

    THREE.Light.prototype.copy.call( this, source );

    this.intensity = source.intensity;
    this.target = source.target.clone();

    this.shadow = source.shadow.clone();

    return this;

};

// File:src/lights/HemisphereLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {

    THREE.Light.call( this, skyColor );

    this.type = 'HemisphereLight';

    this.castShadow = undefined;

    this.position.set( 0, 1, 0 );
    this.updateMatrix();

    this.groundColor = new THREE.Color( groundColor );
    this.intensity = ( intensity !== undefined ) ? intensity : 1;

};

THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );
THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;

THREE.HemisphereLight.prototype.copy = function ( source ) {

    THREE.Light.prototype.copy.call( this, source );

    this.groundColor.copy( source.groundColor );
    this.intensity = source.intensity;

    return this;

};

// File:src/lights/PointLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */


THREE.PointLight = function ( color, intensity, distance, decay ) {

    THREE.Light.call( this, color );

    this.type = 'PointLight';

    this.intensity = ( intensity !== undefined ) ? intensity : 1;
    this.distance = ( distance !== undefined ) ? distance : 0;
    this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

    this.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 90, 1, 1, 500 ) );

};

THREE.PointLight.prototype = Object.create( THREE.Light.prototype );
THREE.PointLight.prototype.constructor = THREE.PointLight;

THREE.PointLight.prototype.copy = function ( source ) {

    THREE.Light.prototype.copy.call( this, source );

    this.intensity = source.intensity;
    this.distance = source.distance;
    this.decay = source.decay;

    this.shadow = source.shadow.clone();

    return this;

};

// File:src/lights/SpotLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpotLight = function ( color, intensity, distance, angle, exponent, decay ) {

    THREE.Light.call( this, color );

    this.type = 'SpotLight';

    this.position.set( 0, 1, 0 );
    this.updateMatrix();

    this.target = new THREE.Object3D();

    this.intensity = ( intensity !== undefined ) ? intensity : 1;
    this.distance = ( distance !== undefined ) ? distance : 0;
    this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
    this.exponent = ( exponent !== undefined ) ? exponent : 10;
    this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

    this.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 50, 1, 50, 5000 ) );

};

THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );
THREE.SpotLight.prototype.constructor = THREE.SpotLight;

THREE.SpotLight.prototype.copy = function ( source ) {

    THREE.Light.prototype.copy.call( this, source );

    this.intensity = source.intensity;
    this.distance = source.distance;
    this.angle = source.angle;
    this.exponent = source.exponent;
    this.decay = source.decay;

    this.target = source.target.clone();

    this.shadow = source.shadow.clone();

    return this;

};

// File:src/loaders/Cache.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Cache = {

    enabled: false,

    files: {},

    add: function ( key, file ) {

        if ( this.enabled === false ) return;

        // console.log( 'THREE.Cache', 'Adding key:', key );

        this.files[ key ] = file;

    },

    get: function ( key ) {

        if ( this.enabled === false ) return;

        // console.log( 'THREE.Cache', 'Checking key:', key );

        return this.files[ key ];

    },

    remove: function ( key ) {

        delete this.files[ key ];

    },

    clear: function () {

        this.files = {};

    }

};

// File:src/loaders/Loader.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Loader = function () {

    this.onLoadStart = function () {};
    this.onLoadProgress = function () {};
    this.onLoadComplete = function () {};

};

THREE.Loader.prototype = {

    constructor: THREE.Loader,

    crossOrigin: undefined,

    extractUrlBase: function ( url ) {

        var parts = url.split( '/' );

        if ( parts.length === 1 ) return './';

        parts.pop();

        return parts.join( '/' ) + '/';

    },

    initMaterials: function ( materials, texturePath, crossOrigin ) {

        var array = [];

        for ( var i = 0; i < materials.length; ++ i ) {

            array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

        }

        return array;

    },

    createMaterial: ( function () {

        var color, textureLoader, materialLoader;

        return function ( m, texturePath, crossOrigin ) {

            if ( color === undefined ) color = new THREE.Color();
            if ( textureLoader === undefined ) textureLoader = new THREE.TextureLoader();
            if ( materialLoader === undefined ) materialLoader = new THREE.MaterialLoader();

            // convert from old material format

            var textures = {};

            function loadTexture( path, repeat, offset, wrap, anisotropy ) {

                var fullPath = texturePath + path;
                var loader = THREE.Loader.Handlers.get( fullPath );

                var texture;

                if ( loader !== null ) {

                    texture = loader.load( fullPath );

                } else {

                    textureLoader.setCrossOrigin( crossOrigin );
                    texture = textureLoader.load( fullPath );

                }

                if ( repeat !== undefined ) {

                    texture.repeat.fromArray( repeat );

                    if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
                    if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;

                }

                if ( offset !== undefined ) {

                    texture.offset.fromArray( offset );

                }

                if ( wrap !== undefined ) {

                    if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = THREE.RepeatWrapping;
                    if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = THREE.MirroredRepeatWrapping;

                    if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = THREE.RepeatWrapping;
                    if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = THREE.MirroredRepeatWrapping;

                }

                if ( anisotropy !== undefined ) {

                    texture.anisotropy = anisotropy;

                }

                var uuid = THREE.Math.generateUUID();

                textures[ uuid ] = texture;

                return uuid;

            }

            //

            var json = {
                uuid: THREE.Math.generateUUID(),
                type: 'MeshLambertMaterial'
            };

            for ( var name in m ) {

                var value = m[ name ];

                switch ( name ) {
                    case 'DbgColor':
                        json.color = value;
                        break;
                    case 'DbgIndex':
                    case 'opticalDensity':
                    case 'illumination':
                        // These were never supported
                        break;
                    case 'DbgName':
                        json.name = value;
                        break;
                    case 'blending':
                        json.blending = THREE[ value ];
                        break;
                    case 'colorDiffuse':
                        json.color = color.fromArray( value ).getHex();
                        break;
                    case 'colorSpecular':
                        json.specular = color.fromArray( value ).getHex();
                        break;
                    case 'colorEmissive':
                        json.emissive = color.fromArray( value ).getHex();
                        break;
                    case 'specularCoef':
                        json.shininess = value;
                        break;
                    case 'shading':
                        if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
                        if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
                        break;
                    case 'mapDiffuse':
                        json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
                        break;
                    case 'mapDiffuseRepeat':
                    case 'mapDiffuseOffset':
                    case 'mapDiffuseWrap':
                    case 'mapDiffuseAnisotropy':
                        break;
                    case 'mapLight':
                        json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
                        break;
                    case 'mapLightRepeat':
                    case 'mapLightOffset':
                    case 'mapLightWrap':
                    case 'mapLightAnisotropy':
                        break;
                    case 'mapAO':
                        json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
                        break;
                    case 'mapAORepeat':
                    case 'mapAOOffset':
                    case 'mapAOWrap':
                    case 'mapAOAnisotropy':
                        break;
                    case 'mapBump':
                        json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
                        break;
                    case 'mapBumpScale':
                        json.bumpScale = value;
                        break;
                    case 'mapBumpRepeat':
                    case 'mapBumpOffset':
                    case 'mapBumpWrap':
                    case 'mapBumpAnisotropy':
                        break;
                    case 'mapNormal':
                        json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
                        break;
                    case 'mapNormalFactor':
                        json.normalScale = [ value, value ];
                        break;
                    case 'mapNormalRepeat':
                    case 'mapNormalOffset':
                    case 'mapNormalWrap':
                    case 'mapNormalAnisotropy':
                        break;
                    case 'mapSpecular':
                        json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
                        break;
                    case 'mapSpecularRepeat':
                    case 'mapSpecularOffset':
                    case 'mapSpecularWrap':
                    case 'mapSpecularAnisotropy':
                        break;
                    case 'mapAlpha':
                        json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
                        break;
                    case 'mapAlphaRepeat':
                    case 'mapAlphaOffset':
                    case 'mapAlphaWrap':
                    case 'mapAlphaAnisotropy':
                        break;
                    case 'flipSided':
                        json.side = THREE.BackSide;
                        break;
                    case 'doubleSided':
                        json.side = THREE.DoubleSide;
                        break;
                    case 'transparency':
                        console.warn( 'THREE.Loader: transparency has been renamed to opacity' );
                        json.opacity = value;
                        break;
                    case 'opacity':
                    case 'transparent':
                    case 'depthTest':
                    case 'depthWrite':
                    case 'transparent':
                    case 'visible':
                    case 'wireframe':
                        json[ name ] = value;
                        break;
                    case 'vertexColors':
                        if ( value === true ) json.vertexColors = THREE.VertexColors;
                        if ( value === 'face' ) json.vertexColors = THREE.FaceColors;
                        break;
                    default:
                        console.error( 'Loader.createMaterial: Unsupported', name, value );
                        break;
                }

            }

            if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;
            if ( json.opacity < 1 ) json.transparent = true;

            materialLoader.setTextures( textures );

            return materialLoader.parse( json );

        };

    } )()

};

THREE.Loader.Handlers = {

    handlers: [],

    add: function ( regex, loader ) {

        this.handlers.push( regex, loader );

    },

    get: function ( file ) {

        var handlers = this.handlers;

        for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

            var regex = handlers[ i ];
            var loader  = handlers[ i + 1 ];

            if ( regex.test( file ) ) {

                return loader;

            }

        }

        return null;

    }

};

// File:src/loaders/XHRLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.XHRLoader = function ( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.XHRLoader.prototype = {

    constructor: THREE.XHRLoader,

    load: function ( url, onLoad, onProgress, onError ) {

        var scope = this;

        var cached = THREE.Cache.get( url );

        if ( cached !== undefined ) {

            if ( onLoad ) {

                setTimeout( function () {

                    onLoad( cached );

                }, 0 );

            }

            return cached;

        }

        var request = new XMLHttpRequest();
        request.open( 'GET', url, true );

        request.addEventListener( 'load', function ( event ) {

            var response = event.target.response;

            THREE.Cache.add( url, response );

            if ( onLoad ) onLoad( response );

            scope.manager.itemEnd( url );

        }, false );

        if ( onProgress !== undefined ) {

            request.addEventListener( 'progress', function ( event ) {

                onProgress( event );

            }, false );

        }

        request.addEventListener( 'error', function ( event ) {

            if ( onError ) onError( event );

            scope.manager.itemError( url );

        }, false );

        if ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;
        if ( this.responseType !== undefined ) request.responseType = this.responseType;
        if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

        request.send( null );

        scope.manager.itemStart( url );

        return request;

    },

    setResponseType: function ( value ) {

        this.responseType = value;

    },

    setCrossOrigin: function ( value ) {

        this.crossOrigin = value;

    },

    setWithCredentials: function ( value ) {

        this.withCredentials = value;

    }

};

// File:src/loaders/ImageLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ImageLoader = function ( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.ImageLoader.prototype = {

    constructor: THREE.ImageLoader,

    load: function ( url, onLoad, onProgress, onError ) {

        var scope = this;

        var cached = THREE.Cache.get( url );

        if ( cached !== undefined ) {

            scope.manager.itemStart( url );

            if ( onLoad ) {

                setTimeout( function () {

                    onLoad( cached );

                    scope.manager.itemEnd( url );

                }, 0 );

            } else {

                scope.manager.itemEnd( url );

            }

            return cached;

        }

        var image = document.createElement( 'img' );

        image.addEventListener( 'load', function ( event ) {

            THREE.Cache.add( url, this );

            if ( onLoad ) onLoad( this );

            scope.manager.itemEnd( url );

        }, false );

        if ( onProgress !== undefined ) {

            image.addEventListener( 'progress', function ( event ) {

                onProgress( event );

            }, false );

        }

        image.addEventListener( 'error', function ( event ) {

            if ( onError ) onError( event );

            scope.manager.itemError( url );

        }, false );

        if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

        scope.manager.itemStart( url );

        image.src = url;

        return image;

    },

    setCrossOrigin: function ( value ) {

        this.crossOrigin = value;

    }

};

// File:src/loaders/JSONLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.JSONLoader = function ( manager ) {

    if ( typeof manager === 'boolean' ) {

        console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
        manager = undefined;

    }

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

    this.withCredentials = false;

};

THREE.JSONLoader.prototype = {

    constructor: THREE.JSONLoader,

    // Deprecated

    get statusDomElement () {

        if ( this._statusDomElement === undefined ) {

            this._statusDomElement = document.createElement( 'div' );

        }

        console.warn( 'THREE.JSONLoader: .statusDomElement has been removed.' );
        return this._statusDomElement;

    },

    load: function( url, onLoad, onProgress, onError ) {

        var scope = this;

        var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );

        var loader = new THREE.XHRLoader( this.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.setWithCredentials( this.withCredentials );
        loader.load( url, function ( text ) {

            var json = JSON.parse( text );
            var metadata = json.metadata;

            if ( metadata !== undefined ) {

                if ( metadata.type === 'object' ) {

                    console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
                    return;

                }

                if ( metadata.type === 'scene' ) {

                    console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
                    return;

                }

            }

            var object = scope.parse( json, texturePath );
            onLoad( object.geometry, object.materials );

        } );

    },

    setCrossOrigin: function ( value ) {

        this.crossOrigin = value;

    },

    setTexturePath: function ( value ) {

        this.texturePath = value;

    },

    parse: function ( json, texturePath ) {

        var geometry = new THREE.Geometry(),
            scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

        parseModel( scale );

        parseSkin();
        parseMorphing( scale );
        parseAnimations();

        geometry.computeFaceNormals();
        geometry.computeBoundingSphere();

        function parseModel( scale ) {

            function isBitSet( value, position ) {

                return value & ( 1 << position );

            }

            var i, j, fi,

                offset, zLength,

                colorIndex, normalIndex, uvIndex, materialIndex,

                type,
                isQuad,
                hasMaterial,
                hasFaceVertexUv,
                hasFaceNormal, hasFaceVertexNormal,
                hasFaceColor, hasFaceVertexColor,

                vertex, face, faceA, faceB, hex, normal,

                uvLayer, uv, u, v,

                faces = json.faces,
                vertices = json.vertices,
                normals = json.normals,
                colors = json.colors,

                nUvLayers = 0;

            if ( json.uvs !== undefined ) {

                // disregard empty arrays

                for ( i = 0; i < json.uvs.length; i ++ ) {

                    if ( json.uvs[ i ].length ) nUvLayers ++;

                }

                for ( i = 0; i < nUvLayers; i ++ ) {

                    geometry.faceVertexUvs[ i ] = [];

                }

            }

            offset = 0;
            zLength = vertices.length;

            while ( offset < zLength ) {

                vertex = new THREE.Vector3();

                vertex.x = vertices[ offset ++ ] * scale;
                vertex.y = vertices[ offset ++ ] * scale;
                vertex.z = vertices[ offset ++ ] * scale;

                geometry.vertices.push( vertex );

            }

            offset = 0;
            zLength = faces.length;

            while ( offset < zLength ) {

                type = faces[ offset ++ ];


                isQuad              = isBitSet( type, 0 );
                hasMaterial         = isBitSet( type, 1 );
                hasFaceVertexUv     = isBitSet( type, 3 );
                hasFaceNormal       = isBitSet( type, 4 );
                hasFaceVertexNormal = isBitSet( type, 5 );
                hasFaceColor	     = isBitSet( type, 6 );
                hasFaceVertexColor  = isBitSet( type, 7 );

                // console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

                if ( isQuad ) {

                    faceA = new THREE.Face3();
                    faceA.a = faces[ offset ];
                    faceA.b = faces[ offset + 1 ];
                    faceA.c = faces[ offset + 3 ];

                    faceB = new THREE.Face3();
                    faceB.a = faces[ offset + 1 ];
                    faceB.b = faces[ offset + 2 ];
                    faceB.c = faces[ offset + 3 ];

                    offset += 4;

                    if ( hasMaterial ) {

                        materialIndex = faces[ offset ++ ];
                        faceA.materialIndex = materialIndex;
                        faceB.materialIndex = materialIndex;

                    }

                    // to get face <=> uv index correspondence

                    fi = geometry.faces.length;

                    if ( hasFaceVertexUv ) {

                        for ( i = 0; i < nUvLayers; i ++ ) {

                            uvLayer = json.uvs[ i ];

                            geometry.faceVertexUvs[ i ][ fi ] = [];
                            geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

                            for ( j = 0; j < 4; j ++ ) {

                                uvIndex = faces[ offset ++ ];

                                u = uvLayer[ uvIndex * 2 ];
                                v = uvLayer[ uvIndex * 2 + 1 ];

                                uv = new THREE.Vector2( u, v );

                                if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
                                if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

                            }

                        }

                    }

                    if ( hasFaceNormal ) {

                        normalIndex = faces[ offset ++ ] * 3;

                        faceA.normal.set(
                            normals[ normalIndex ++ ],
                            normals[ normalIndex ++ ],
                            normals[ normalIndex ]
                        );

                        faceB.normal.copy( faceA.normal );

                    }

                    if ( hasFaceVertexNormal ) {

                        for ( i = 0; i < 4; i ++ ) {

                            normalIndex = faces[ offset ++ ] * 3;

                            normal = new THREE.Vector3(
                                normals[ normalIndex ++ ],
                                normals[ normalIndex ++ ],
                                normals[ normalIndex ]
                            );


                            if ( i !== 2 ) faceA.vertexNormals.push( normal );
                            if ( i !== 0 ) faceB.vertexNormals.push( normal );

                        }

                    }


                    if ( hasFaceColor ) {

                        colorIndex = faces[ offset ++ ];
                        hex = colors[ colorIndex ];

                        faceA.color.setHex( hex );
                        faceB.color.setHex( hex );

                    }


                    if ( hasFaceVertexColor ) {

                        for ( i = 0; i < 4; i ++ ) {

                            colorIndex = faces[ offset ++ ];
                            hex = colors[ colorIndex ];

                            if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
                            if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );

                        }

                    }

                    geometry.faces.push( faceA );
                    geometry.faces.push( faceB );

                } else {

                    face = new THREE.Face3();
                    face.a = faces[ offset ++ ];
                    face.b = faces[ offset ++ ];
                    face.c = faces[ offset ++ ];

                    if ( hasMaterial ) {

                        materialIndex = faces[ offset ++ ];
                        face.materialIndex = materialIndex;

                    }

                    // to get face <=> uv index correspondence

                    fi = geometry.faces.length;

                    if ( hasFaceVertexUv ) {

                        for ( i = 0; i < nUvLayers; i ++ ) {

                            uvLayer = json.uvs[ i ];

                            geometry.faceVertexUvs[ i ][ fi ] = [];

                            for ( j = 0; j < 3; j ++ ) {

                                uvIndex = faces[ offset ++ ];

                                u = uvLayer[ uvIndex * 2 ];
                                v = uvLayer[ uvIndex * 2 + 1 ];

                                uv = new THREE.Vector2( u, v );

                                geometry.faceVertexUvs[ i ][ fi ].push( uv );

                            }

                        }

                    }

                    if ( hasFaceNormal ) {

                        normalIndex = faces[ offset ++ ] * 3;

                        face.normal.set(
                            normals[ normalIndex ++ ],
                            normals[ normalIndex ++ ],
                            normals[ normalIndex ]
                        );

                    }

                    if ( hasFaceVertexNormal ) {

                        for ( i = 0; i < 3; i ++ ) {

                            normalIndex = faces[ offset ++ ] * 3;

                            normal = new THREE.Vector3(
                                normals[ normalIndex ++ ],
                                normals[ normalIndex ++ ],
                                normals[ normalIndex ]
                            );

                            face.vertexNormals.push( normal );

                        }

                    }


                    if ( hasFaceColor ) {

                        colorIndex = faces[ offset ++ ];
                        face.color.setHex( colors[ colorIndex ] );

                    }


                    if ( hasFaceVertexColor ) {

                        for ( i = 0; i < 3; i ++ ) {

                            colorIndex = faces[ offset ++ ];
                            face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );

                        }

                    }

                    geometry.faces.push( face );

                }

            }

        };

        function parseSkin() {

            var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

            if ( json.skinWeights ) {

                for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

                    var x =                               json.skinWeights[ i ];
                    var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
                    var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
                    var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

                    geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );

                }

            }

            if ( json.skinIndices ) {

                for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

                    var a =                               json.skinIndices[ i ];
                    var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
                    var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
                    var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

                    geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );

                }

            }

            geometry.bones = json.bones;

            if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

                console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
                    geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

            }

        };

        function parseMorphing( scale ) {

            if ( json.morphTargets !== undefined ) {

                for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {

                    geometry.morphTargets[ i ] = {};
                    geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
                    geometry.morphTargets[ i ].vertices = [];

                    var dstVertices = geometry.morphTargets[ i ].vertices;
                    var srcVertices = json.morphTargets[ i ].vertices;

                    for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

                        var vertex = new THREE.Vector3();
                        vertex.x = srcVertices[ v ] * scale;
                        vertex.y = srcVertices[ v + 1 ] * scale;
                        vertex.z = srcVertices[ v + 2 ] * scale;

                        dstVertices.push( vertex );

                    }

                }

            }

            if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {

                console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );

                var faces = geometry.faces;
                var morphColors = json.morphColors[ 0 ].colors;

                for ( var i = 0, l = faces.length; i < l; i ++ ) {

                    faces[ i ].color.fromArray( morphColors, i * 3 );

                }

            }

        }

        function parseAnimations() {

            var outputAnimations = [];

            // parse old style Bone/Hierarchy animations
            var animations = [];
            if ( json.animation !== undefined ) {
                animations.push( json.animation );
            }
            if ( json.animations !== undefined ) {
                if ( json.animations.length ) {
                    animations = animations.concat( json.animations );
                } else {
                    animations.push( json.animations );
                }
            }

            for ( var i = 0; i < animations.length; i ++ ) {

                var clip = THREE.AnimationClip.parseAnimation( animations[i], geometry.bones );
                if ( clip ) outputAnimations.push( clip );

            }

            // parse implicit morph animations
            if ( geometry.morphTargets ) {

                // TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
                var morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
                outputAnimations = outputAnimations.concat( morphAnimationClips );

            }

            if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;

        };

        if ( json.materials === undefined || json.materials.length === 0 ) {

            return { geometry: geometry };

        } else {

            var materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );

            return { geometry: geometry, materials: materials };

        }

    }

};

// File:src/loaders/LoadingManager.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LoadingManager = function ( onLoad, onProgress, onError ) {

    var scope = this;

    var isLoading = false, itemsLoaded = 0, itemsTotal = 0;

    this.onStart = undefined;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;

    this.itemStart = function ( url ) {

        itemsTotal ++;

        if ( isLoading === false ) {

            if ( scope.onStart !== undefined ) {

                scope.onStart( url, itemsLoaded, itemsTotal );

            }

        }

        isLoading = true;

    };

    this.itemEnd = function ( url ) {

        itemsLoaded ++;

        if ( scope.onProgress !== undefined ) {

            scope.onProgress( url, itemsLoaded, itemsTotal );

        }

        if ( itemsLoaded === itemsTotal ) {

            isLoading = false;

            if ( scope.onLoad !== undefined ) {

                scope.onLoad();

            }

        }

    };

    this.itemError = function ( url ) {

        if ( scope.onError !== undefined ) {

            scope.onError( url );

        }

    };

};

THREE.DefaultLoadingManager = new THREE.LoadingManager();

// File:src/loaders/BufferGeometryLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometryLoader = function ( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.BufferGeometryLoader.prototype = {

    constructor: THREE.BufferGeometryLoader,

    load: function ( url, onLoad, onProgress, onError ) {

        var scope = this;

        var loader = new THREE.XHRLoader( scope.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.load( url, function ( text ) {

            onLoad( scope.parse( JSON.parse( text ) ) );

        }, onProgress, onError );

    },

    setCrossOrigin: function ( value ) {

        this.crossOrigin = value;

    },

    parse: function ( json ) {

        var geometry = new THREE.BufferGeometry();

        var index = json.data.index;

        if ( index !== undefined ) {

            var typedArray = new self[ index.type ]( index.array );
            geometry.setIndex( new THREE.BufferAttribute( typedArray, 1 ) );

        }

        var attributes = json.data.attributes;

        for ( var key in attributes ) {

            var attribute = attributes[ key ];
            var typedArray = new self[ attribute.type ]( attribute.array );

            geometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );

        }

        var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

        if ( groups !== undefined ) {

            for ( var i = 0, n = groups.length; i !== n; ++ i ) {

                var group = groups[ i ];

                geometry.addGroup( group.start, group.count );

            }

        }

        var boundingSphere = json.data.boundingSphere;

        if ( boundingSphere !== undefined ) {

            var center = new THREE.Vector3();

            if ( boundingSphere.center !== undefined ) {

                center.fromArray( boundingSphere.center );

            }

            geometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );

        }

        return geometry;

    }

};

// File:src/loaders/MaterialLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MaterialLoader = function ( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
    this.textures = {};

};

THREE.MaterialLoader.prototype = {

    constructor: THREE.MaterialLoader,

    load: function ( url, onLoad, onProgress, onError ) {

        var scope = this;

        var loader = new THREE.XHRLoader( scope.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.load( url, function ( text ) {

            onLoad( scope.parse( JSON.parse( text ) ) );

        }, onProgress, onError );

    },

    setCrossOrigin: function ( value ) {

        this.crossOrigin = value;

    },

    setTextures: function ( value ) {

        this.textures = value;

    },

    getTexture: function ( name ) {

        var textures = this.textures;

        if ( textures[ name ] === undefined ) {

            console.warn( 'THREE.MaterialLoader: Undefined texture', name );

        }

        return textures[ name ];

    },

    parse: function ( json ) {

        var material = new THREE[ json.type ];
        material.uuid = json.uuid;

        if ( json.name !== undefined ) material.name = json.name;
        if ( json.color !== undefined ) material.color.setHex( json.color );
        if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
        if ( json.specular !== undefined ) material.specular.setHex( json.specular );
        if ( json.shininess !== undefined ) material.shininess = json.shininess;
        if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
        if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
        if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
        if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
        if ( json.shading !== undefined ) material.shading = json.shading;
        if ( json.blending !== undefined ) material.blending = json.blending;
        if ( json.side !== undefined ) material.side = json.side;
        if ( json.opacity !== undefined ) material.opacity = json.opacity;
        if ( json.transparent !== undefined ) material.transparent = json.transparent;
        if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
        if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
        if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
        if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
        if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;

        // for PointsMaterial
        if ( json.size !== undefined ) material.size = json.size;
        if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

        // maps

        if ( json.map !== undefined ) material.map = this.getTexture( json.map );

        if ( json.alphaMap !== undefined ) {

            material.alphaMap = this.getTexture( json.alphaMap );
            material.transparent = true;

        }

        if ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );
        if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

        if ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );
        if ( json.normalScale )	material.normalScale = new THREE.Vector2( json.normalScale, json.normalScale );

        if ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );
        if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
        if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

        if ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );

        if ( json.envMap !== undefined ) {

            material.envMap = this.getTexture( json.envMap );
            material.combine = THREE.MultiplyOperation;

        }

        if ( json.reflectivity ) material.reflectivity = json.reflectivity;

        if ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );
        if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

        if ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );
        if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

        // MeshFaceMaterial

        if ( json.materials !== undefined ) {

            for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

                material.materials.push( this.parse( json.materials[ i ] ) );

            }

        }

        return material;

    }

};

// File:src/loaders/ObjectLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ObjectLoader = function ( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
    this.texturePath = '';

};

THREE.ObjectLoader.prototype = {

    constructor: THREE.ObjectLoader,

    load: function ( url, onLoad, onProgress, onError ) {

        if ( this.texturePath === '' ) {

            this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

        }

        var scope = this;

        var loader = new THREE.XHRLoader( scope.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.load( url, function ( text ) {

            scope.parse( JSON.parse( text ), onLoad );

        }, onProgress, onError );

    },

    setTexturePath: function ( value ) {

        this.texturePath = value;

    },

    setCrossOrigin: function ( value ) {

        this.crossOrigin = value;

    },

    parse: function ( json, onLoad ) {

        var geometries = this.parseGeometries( json.geometries );

        var images = this.parseImages( json.images, function () {

            if ( onLoad !== undefined ) onLoad( object );

        } );

        var textures  = this.parseTextures( json.textures, images );
        var materials = this.parseMaterials( json.materials, textures );

        var object = this.parseObject( json.object, geometries, materials );

        if ( json.animations ) {

            object.animations = this.parseAnimations( json.animations );

        }

        if ( json.images === undefined || json.images.length === 0 ) {

            if ( onLoad !== undefined ) onLoad( object );

        }

        return object;

    },

    parseGeometries: function ( json ) {

        var geometries = {};

        if ( json !== undefined ) {

            var geometryLoader = new THREE.JSONLoader();
            var bufferGeometryLoader = new THREE.BufferGeometryLoader();

            for ( var i = 0, l = json.length; i < l; i ++ ) {

                var geometry;
                var data = json[ i ];

                switch ( data.type ) {

                    case 'PlaneGeometry':
                    case 'PlaneBufferGeometry':

                        geometry = new THREE[ data.type ](
                            data.width,
                            data.height,
                            data.widthSegments,
                            data.heightSegments
                        );

                        break;

                    case 'BoxGeometry':
                    case 'CubeGeometry': // backwards compatible

                        geometry = new THREE.BoxGeometry(
                            data.width,
                            data.height,
                            data.depth,
                            data.widthSegments,
                            data.heightSegments,
                            data.depthSegments
                        );

                        break;

                    case 'CircleBufferGeometry':

                        geometry = new THREE.CircleBufferGeometry(
                            data.radius,
                            data.segments,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'CircleGeometry':

                        geometry = new THREE.CircleGeometry(
                            data.radius,
                            data.segments,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'CylinderGeometry':

                        geometry = new THREE.CylinderGeometry(
                            data.radiusTop,
                            data.radiusBottom,
                            data.height,
                            data.radialSegments,
                            data.heightSegments,
                            data.openEnded,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'SphereGeometry':

                        geometry = new THREE.SphereGeometry(
                            data.radius,
                            data.widthSegments,
                            data.heightSegments,
                            data.phiStart,
                            data.phiLength,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'SphereBufferGeometry':

                        geometry = new THREE.SphereBufferGeometry(
                            data.radius,
                            data.widthSegments,
                            data.heightSegments,
                            data.phiStart,
                            data.phiLength,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'DodecahedronGeometry':

                        geometry = new THREE.DodecahedronGeometry(
                            data.radius,
                            data.detail
                        );

                        break;

                    case 'IcosahedronGeometry':

                        geometry = new THREE.IcosahedronGeometry(
                            data.radius,
                            data.detail
                        );

                        break;

                    case 'OctahedronGeometry':

                        geometry = new THREE.OctahedronGeometry(
                            data.radius,
                            data.detail
                        );

                        break;

                    case 'TetrahedronGeometry':

                        geometry = new THREE.TetrahedronGeometry(
                            data.radius,
                            data.detail
                        );

                        break;

                    case 'RingGeometry':

                        geometry = new THREE.RingGeometry(
                            data.innerRadius,
                            data.outerRadius,
                            data.thetaSegments,
                            data.phiSegments,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'TorusGeometry':

                        geometry = new THREE.TorusGeometry(
                            data.radius,
                            data.tube,
                            data.radialSegments,
                            data.tubularSegments,
                            data.arc
                        );

                        break;

                    case 'TorusKnotGeometry':

                        geometry = new THREE.TorusKnotGeometry(
                            data.radius,
                            data.tube,
                            data.radialSegments,
                            data.tubularSegments,
                            data.p,
                            data.q,
                            data.heightScale
                        );

                        break;

                    case 'BufferGeometry':

                        geometry = bufferGeometryLoader.parse( data );

                        break;

                    case 'Geometry':

                        geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;

                        break;

                    default:

                        console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

                        continue;

                }

                geometry.uuid = data.uuid;

                if ( data.name !== undefined ) geometry.name = data.name;

                geometries[ data.uuid ] = geometry;

            }

        }

        return geometries;

    },

    parseMaterials: function ( json, textures ) {

        var materials = {};

        if ( json !== undefined ) {

            var loader = new THREE.MaterialLoader();
            loader.setTextures( textures );

            for ( var i = 0, l = json.length; i < l; i ++ ) {

                var material = loader.parse( json[ i ] );
                materials[ material.uuid ] = material;

            }

        }

        return materials;

    },

    parseAnimations: function ( json ) {

        var animations = [];

        for ( var i = 0; i < json.length; i ++ ) {

            var clip = THREE.AnimationClip.parse( json[i] );

            animations.push( clip );

        }

        return animations;

    },

    parseImages: function ( json, onLoad ) {

        var scope = this;
        var images = {};

        function loadImage( url ) {

            scope.manager.itemStart( url );

            return loader.load( url, function () {

                scope.manager.itemEnd( url );

            } );

        }

        if ( json !== undefined && json.length > 0 ) {

            var manager = new THREE.LoadingManager( onLoad );

            var loader = new THREE.ImageLoader( manager );
            loader.setCrossOrigin( this.crossOrigin );

            for ( var i = 0, l = json.length; i < l; i ++ ) {

                var image = json[ i ];
                var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

                images[ image.uuid ] = loadImage( path );

            }

        }

        return images;

    },

    parseTextures: function ( json, images ) {

        function parseConstant( value ) {

            if ( typeof( value ) === 'number' ) return value;

            console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

            return THREE[ value ];

        }

        var textures = {};

        if ( json !== undefined ) {

            for ( var i = 0, l = json.length; i < l; i ++ ) {

                var data = json[ i ];

                if ( data.image === undefined ) {

                    console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

                }

                if ( images[ data.image ] === undefined ) {

                    console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

                }

                var texture = new THREE.Texture( images[ data.image ] );
                texture.needsUpdate = true;

                texture.uuid = data.uuid;

                if ( data.name !== undefined ) texture.name = data.name;
                if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );
                if ( data.offset !== undefined ) texture.offset = new THREE.Vector2( data.offset[ 0 ], data.offset[ 1 ] );
                if ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );
                if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );
                if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );
                if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;
                if ( Array.isArray( data.wrap ) ) {

                    texture.wrapS = parseConstant( data.wrap[ 0 ] );
                    texture.wrapT = parseConstant( data.wrap[ 1 ] );

                }

                textures[ data.uuid ] = texture;

            }

        }

        return textures;

    },

    parseObject: function () {

        var matrix = new THREE.Matrix4();

        return function ( data, geometries, materials ) {

            var object;

            function getGeometry( name ) {

                if ( geometries[ name ] === undefined ) {

                    console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

                }

                return geometries[ name ];

            }

            function getMaterial( name ) {

                if ( name === undefined ) return undefined;

                if ( materials[ name ] === undefined ) {

                    console.warn( 'THREE.ObjectLoader: Undefined material', name );

                }

                return materials[ name ];

            }

            switch ( data.type ) {

                case 'Scene':

                    object = new THREE.Scene();

                    break;

                case 'PerspectiveCamera':

                    object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

                    break;

                case 'OrthographicCamera':

                    object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

                    break;

                case 'AmbientLight':

                    object = new THREE.AmbientLight( data.color );

                    break;

                case 'DirectionalLight':

                    object = new THREE.DirectionalLight( data.color, data.intensity );

                    break;

                case 'PointLight':

                    object = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );

                    break;

                case 'SpotLight':

                    object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay );

                    break;

                case 'HemisphereLight':

                    object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );

                    break;

                case 'Mesh':

                    object = new THREE.Mesh( getGeometry( data.geometry ), getMaterial( data.material ) );

                    break;

                case 'LOD':

                    object = new THREE.LOD();

                    break;

                case 'Line':

                    object = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

                    break;

                case 'PointCloud':
                case 'Points':

                    object = new THREE.Points( getGeometry( data.geometry ), getMaterial( data.material ) );

                    break;

                case 'Sprite':

                    object = new THREE.Sprite( getMaterial( data.material ) );

                    break;

                case 'Group':

                    object = new THREE.Group();

                    break;

                default:

                    object = new THREE.Object3D();

            }

            object.uuid = data.uuid;

            if ( data.name !== undefined ) object.name = data.name;
            if ( data.matrix !== undefined ) {

                matrix.fromArray( data.matrix );
                matrix.decompose( object.position, object.quaternion, object.scale );

            } else {

                if ( data.position !== undefined ) object.position.fromArray( data.position );
                if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
                if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

            }

            if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
            if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

            if ( data.visible !== undefined ) object.visible = data.visible;
            if ( data.userData !== undefined ) object.userData = data.userData;

            if ( data.children !== undefined ) {

                for ( var child in data.children ) {

                    object.add( this.parseObject( data.children[ child ], geometries, materials ) );

                }

            }

            if ( data.type === 'LOD' ) {

                var levels = data.levels;

                for ( var l = 0; l < levels.length; l ++ ) {

                    var level = levels[ l ];
                    var child = object.getObjectByProperty( 'uuid', level.object );

                    if ( child !== undefined ) {

                        object.addLevel( child, level.distance );

                    }

                }

            }

            return object;

        }

    }()

};

// File:src/loaders/TextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.TextureLoader = function ( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.TextureLoader.prototype = {

    constructor: THREE.TextureLoader,

    load: function ( url, onLoad, onProgress, onError ) {

        var texture = new THREE.Texture();

        var loader = new THREE.ImageLoader( this.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.load( url, function ( image ) {

            texture.image = image;
            texture.needsUpdate = true;

            if ( onLoad !== undefined ) {

                onLoad( texture );

            }

        }, onProgress, onError );

        return texture;

    },

    setCrossOrigin: function ( value ) {

        this.crossOrigin = value;

    }

};

// File:src/loaders/CubeTextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CubeTextureLoader = function ( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.CubeTextureLoader.prototype = {

    constructor: THREE.CubeTextureLoader,

    load: function ( urls, onLoad, onProgress, onError ) {

        var texture = new THREE.CubeTexture( [] );

        var loader = new THREE.ImageLoader();
        loader.setCrossOrigin( this.crossOrigin );

        var loaded = 0;

        function loadTexture( i ) {

            loader.load( urls[ i ], function ( image ) {

                texture.images[ i ] = image;

                loaded ++;

                if ( loaded === 6 ) {

                    texture.needsUpdate = true;

                    if ( onLoad ) onLoad( texture );

                }

            }, undefined, onError );

        }

        for ( var i = 0; i < urls.length; ++ i ) {

            loadTexture( i );

        }

        return texture;

    },

    setCrossOrigin: function ( value ) {

        this.crossOrigin = value;

    }

};

// File:src/loaders/BinaryTextureLoader.js

/**
 * @author Nikos M. / https://github.com/foo123/
 *
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 */

THREE.DataTextureLoader = THREE.BinaryTextureLoader = function ( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

    // override in sub classes
    this._parser = null;

};

THREE.BinaryTextureLoader.prototype = {

    constructor: THREE.BinaryTextureLoader,

    load: function ( url, onLoad, onProgress, onError ) {

        var scope = this;

        var texture = new THREE.DataTexture();

        var loader = new THREE.XHRLoader( this.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.setResponseType( 'arraybuffer' );

        loader.load( url, function ( buffer ) {

            var texData = scope._parser( buffer );

            if ( ! texData ) return;

            if ( undefined !== texData.image ) {

                texture.image = texData.image;

            } else if ( undefined !== texData.data ) {

                texture.image.width = texData.width;
                texture.image.height = texData.height;
                texture.image.data = texData.data;

            }

            texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;
            texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;

            texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;
            texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;

            texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

            if ( undefined !== texData.format ) {

                texture.format = texData.format;

            }
            if ( undefined !== texData.type ) {

                texture.type = texData.type;

            }

            if ( undefined !== texData.mipmaps ) {

                texture.mipmaps = texData.mipmaps;

            }

            if ( 1 === texData.mipmapCount ) {

                texture.minFilter = THREE.LinearFilter;

            }

            texture.needsUpdate = true;

            if ( onLoad ) onLoad( texture, texData );

        }, onProgress, onError );


        return texture;

    },

    setCrossOrigin: function ( value ) {

        this.crossOrigin = value;

    }

};

// File:src/loaders/CompressedTextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 */

THREE.CompressedTextureLoader = function ( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

    // override in sub classes
    this._parser = null;

};


THREE.CompressedTextureLoader.prototype = {

    constructor: THREE.CompressedTextureLoader,

    load: function ( url, onLoad, onProgress, onError ) {

        var scope = this;

        var images = [];

        var texture = new THREE.CompressedTexture();
        texture.image = images;

        var loader = new THREE.XHRLoader( this.manager );
        loader.setCrossOrigin( this.crossOrigin );
        loader.setResponseType( 'arraybuffer' );

        if ( Array.isArray( url ) ) {

            var loaded = 0;

            var loadTexture = function ( i ) {

                loader.load( url[ i ], function ( buffer ) {

                    var texDatas = scope._parser( buffer, true );

                    images[ i ] = {
                        width: texDatas.width,
                        height: texDatas.height,
                        format: texDatas.format,
                        mipmaps: texDatas.mipmaps
                    };

                    loaded += 1;

                    if ( loaded === 6 ) {

                        if ( texDatas.mipmapCount === 1 )
                            texture.minFilter = THREE.LinearFilter;

                        texture.format = texDatas.format;
                        texture.needsUpdate = true;

                        if ( onLoad ) onLoad( texture );

                    }

                }, onProgress, onError );

            };

            for ( var i = 0, il = url.length; i < il; ++ i ) {

                loadTexture( i );

            }

        } else {

            // compressed cubemap texture stored in a single DDS file

            loader.load( url, function ( buffer ) {

                var texDatas = scope._parser( buffer, true );

                if ( texDatas.isCubemap ) {

                    var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

                    for ( var f = 0; f < faces; f ++ ) {

                        images[ f ] = { mipmaps : [] };

                        for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

                            images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
                            images[ f ].format = texDatas.format;
                            images[ f ].width = texDatas.width;
                            images[ f ].height = texDatas.height;

                        }

                    }

                } else {

                    texture.image.width = texDatas.width;
                    texture.image.height = texDatas.height;
                    texture.mipmaps = texDatas.mipmaps;

                }

                if ( texDatas.mipmapCount === 1 ) {

                    texture.minFilter = THREE.LinearFilter;

                }

                texture.format = texDatas.format;
                texture.needsUpdate = true;

                if ( onLoad ) onLoad( texture );

            }, onProgress, onError );

        }

        return texture;

    },

    setCrossOrigin: function ( value ) {

        this.crossOrigin = value;

    }

};

// File:src/materials/Material.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Material = function () {

    Object.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );

    this.uuid = THREE.Math.generateUUID();

    this.name = '';
    this.type = 'Material';

    this.side = THREE.FrontSide;

    this.opacity = 1;
    this.transparent = false;

    this.blending = THREE.NormalBlending;

    this.blendSrc = THREE.SrcAlphaFactor;
    this.blendDst = THREE.OneMinusSrcAlphaFactor;
    this.blendEquation = THREE.AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;

    this.depthFunc = THREE.LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;

    this.colorWrite = true;

    this.precision = null; // override the renderer's default precision for this material

    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;

    this.alphaTest = 0;

    this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

    this.visible = true;

    this._needsUpdate = true;

};

THREE.Material.prototype = {

    constructor: THREE.Material,

    get needsUpdate () {

        return this._needsUpdate;

    },

    set needsUpdate ( value ) {

        if ( value === true ) this.update();

        this._needsUpdate = value;

    },

    setValues: function ( values ) {

        if ( values === undefined ) return;

        for ( var key in values ) {

            var newValue = values[ key ];

            if ( newValue === undefined ) {

                console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
                continue;

            }

            var currentValue = this[ key ];

            if ( currentValue === undefined ) {

                console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
                continue;

            }

            if ( currentValue instanceof THREE.Color ) {

                currentValue.set( newValue );

            } else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {

                currentValue.copy( newValue );

            } else if ( key === 'overdraw' ) {

                // ensure overdraw is backwards-compatible with legacy boolean type
                this[ key ] = Number( newValue );

            } else {

                this[ key ] = newValue;

            }

        }

    },

    toJSON: function ( meta ) {

        var data = {
            metadata: {
                version: 4.4,
                type: 'Material',
                generator: 'Material.toJSON'
            }
        };

        // standard Material serialization
        data.uuid = this.uuid;
        data.type = this.type;
        if ( this.name !== '' ) data.name = this.name;

        if ( this.color instanceof THREE.Color ) data.color = this.color.getHex();
        if ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();
        if ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();
        if ( this.shininess !== undefined ) data.shininess = this.shininess;

        if ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;
        if ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
        if ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
        if ( this.bumpMap instanceof THREE.Texture ) {

            data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
            data.bumpScale = this.bumpScale;

        }
        if ( this.normalMap instanceof THREE.Texture ) {

            data.normalMap = this.normalMap.toJSON( meta ).uuid;
            data.normalScale = this.normalScale; // Removed for now, causes issue in editor ui.js

        }
        if ( this.displacementMap instanceof THREE.Texture ) {

            data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
            data.displacementScale = this.displacementScale;
            data.displacementBias = this.displacementBias;

        }
        if ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
        if ( this.envMap instanceof THREE.Texture ) {

            data.envMap = this.envMap.toJSON( meta ).uuid;
            data.reflectivity = this.reflectivity; // Scale behind envMap

        }

        if ( this.size !== undefined ) data.size = this.size;
        if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

        if ( this.vertexColors !== undefined && this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;
        if ( this.shading !== undefined && this.shading !== THREE.SmoothShading ) data.shading = this.shading;
        if ( this.blending !== undefined && this.blending !== THREE.NormalBlending ) data.blending = this.blending;
        if ( this.side !== undefined && this.side !== THREE.FrontSide ) data.side = this.side;

        if ( this.opacity < 1 ) data.opacity = this.opacity;
        if ( this.transparent === true ) data.transparent = this.transparent;
        if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
        if ( this.wireframe === true ) data.wireframe = this.wireframe;
        if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;

        return data;

    },

    clone: function () {

        return new this.constructor().copy( this );

    },

    copy: function ( source ) {

        this.name = source.name;

        this.side = source.side;

        this.opacity = source.opacity;
        this.transparent = source.transparent;

        this.blending = source.blending;

        this.blendSrc = source.blendSrc;
        this.blendDst = source.blendDst;
        this.blendEquation = source.blendEquation;
        this.blendSrcAlpha = source.blendSrcAlpha;
        this.blendDstAlpha = source.blendDstAlpha;
        this.blendEquationAlpha = source.blendEquationAlpha;

        this.depthFunc = source.depthFunc;
        this.depthTest = source.depthTest;
        this.depthWrite = source.depthWrite;

        this.precision = source.precision;

        this.polygonOffset = source.polygonOffset;
        this.polygonOffsetFactor = source.polygonOffsetFactor;
        this.polygonOffsetUnits = source.polygonOffsetUnits;

        this.alphaTest = source.alphaTest;

        this.overdraw = source.overdraw;

        this.visible = source.visible;

        return this;

    },

    update: function () {

        this.dispatchEvent( { type: 'update' } );

    },

    dispose: function () {

        this.dispatchEvent( { type: 'dispose' } );

    },

    // Deprecated

    get wrapAround () {

        console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );

    },

    set wrapAround ( boolean ) {

        console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );

    },

    get wrapRGB () {

        console.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );
        return new THREE.Color();

    }

};

THREE.EventDispatcher.prototype.apply( THREE.Material.prototype );

THREE.MaterialIdCount = 0;

// File:src/materials/LineBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round",
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineBasicMaterial = function ( parameters ) {

    THREE.Material.call( this );

    this.type = 'LineBasicMaterial';

    this.color = new THREE.Color( 0xffffff );

    this.linewidth = 1;
    this.linecap = 'round';
    this.linejoin = 'round';

    this.vertexColors = THREE.NoColors;

    this.fog = true;

    this.setValues( parameters );

};

THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;

THREE.LineBasicMaterial.prototype.copy = function ( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );

    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;

    this.vertexColors = source.vertexColors;

    this.fog = source.fog;

    return this;

};

// File:src/materials/LineDashedMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>,
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineDashedMaterial = function ( parameters ) {

    THREE.Material.call( this );

    this.type = 'LineDashedMaterial';

    this.color = new THREE.Color( 0xffffff );

    this.linewidth = 1;

    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;

    this.vertexColors = false;

    this.fog = true;

    this.setValues( parameters );

};

THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;

THREE.LineDashedMaterial.prototype.copy = function ( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );

    this.linewidth = source.linewidth;

    this.scale = source.scale;
    this.dashSize = source.dashSize;
    this.gapSize = source.gapSize;

    this.vertexColors = source.vertexColors;

    this.fog = source.fog;

    return this;

};

// File:src/materials/MeshBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.MeshBasicMaterial = function ( parameters ) {

    THREE.Material.call( this );

    this.type = 'MeshBasicMaterial';

    this.color = new THREE.Color( 0xffffff ); // emissive

    this.map = null;

    this.aoMap = null;
    this.aoMapIntensity = 1.0;

    this.specularMap = null;

    this.alphaMap = null;

    this.envMap = null;
    this.combine = THREE.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;

    this.fog = true;

    this.shading = THREE.SmoothShading;

    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';

    this.vertexColors = THREE.NoColors;

    this.skinning = false;
    this.morphTargets = false;

    this.setValues( parameters );

};

THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;

THREE.MeshBasicMaterial.prototype.copy = function ( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );

    this.map = source.map;

    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;

    this.specularMap = source.specularMap;

    this.alphaMap = source.alphaMap;

    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;

    this.fog = source.fog;

    this.shading = source.shading;

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;

    this.vertexColors = source.vertexColors;

    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;

    return this;

};

// File:src/materials/MeshLambertMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  emissive: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshLambertMaterial = function ( parameters ) {

    THREE.Material.call( this );

    this.type = 'MeshLambertMaterial';

    this.color = new THREE.Color( 0xffffff ); // diffuse
    this.emissive = new THREE.Color( 0x000000 );

    this.map = null;

    this.specularMap = null;

    this.alphaMap = null;

    this.envMap = null;
    this.combine = THREE.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;

    this.fog = true;

    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';

    this.vertexColors = THREE.NoColors;

    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;

    this.setValues( parameters );

};

THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;

THREE.MeshLambertMaterial.prototype.copy = function ( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );
    this.emissive.copy( source.emissive );

    this.map = source.map;

    this.specularMap = source.specularMap;

    this.alphaMap = source.alphaMap;

    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;

    this.fog = source.fog;

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;

    this.vertexColors = source.vertexColors;

    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;

    return this;

};

// File:src/materials/MeshPhongMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  emissive: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshPhongMaterial = function ( parameters ) {

    THREE.Material.call( this );

    this.type = 'MeshPhongMaterial';

    this.color = new THREE.Color( 0xffffff ); // diffuse
    this.emissive = new THREE.Color( 0x000000 );
    this.specular = new THREE.Color( 0x111111 );
    this.shininess = 30;

    this.metal = false;

    this.map = null;

    this.lightMap = null;
    this.lightMapIntensity = 1.0;

    this.aoMap = null;
    this.aoMapIntensity = 1.0;

    this.emissiveMap = null;

    this.bumpMap = null;
    this.bumpScale = 1;

    this.normalMap = null;
    this.normalScale = new THREE.Vector2( 1, 1 );

    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;

    this.specularMap = null;

    this.alphaMap = null;

    this.envMap = null;
    this.combine = THREE.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;

    this.fog = true;

    this.shading = THREE.SmoothShading;

    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';

    this.vertexColors = THREE.NoColors;

    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;

    this.setValues( parameters );

};

THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;

THREE.MeshPhongMaterial.prototype.copy = function ( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );
    this.emissive.copy( source.emissive );
    this.specular.copy( source.specular );
    this.shininess = source.shininess;

    this.metal = source.metal;

    this.map = source.map;

    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;

    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;

    this.emissiveMap = source.emissiveMap;

    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;

    this.normalMap = source.normalMap;
    this.normalScale.copy( source.normalScale );

    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;

    this.specularMap = source.specularMap;

    this.alphaMap = source.alphaMap;

    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;

    this.fog = source.fog;

    this.shading = source.shading;

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;

    this.vertexColors = source.vertexColors;

    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;

    return this;

};

// File:src/materials/MeshDepthMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshDepthMaterial = function ( parameters ) {

    THREE.Material.call( this );

    this.type = 'MeshDepthMaterial';

    this.morphTargets = false;
    this.wireframe = false;
    this.wireframeLinewidth = 1;

    this.setValues( parameters );

};

THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;

THREE.MeshDepthMaterial.prototype.copy = function ( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;

    return this;

};

// File:src/materials/MeshNormalMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  shading: THREE.FlatShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshNormalMaterial = function ( parameters ) {

    THREE.Material.call( this, parameters );

    this.type = 'MeshNormalMaterial';

    this.wireframe = false;
    this.wireframeLinewidth = 1;

    this.morphTargets = false;

    this.setValues( parameters );

};

THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;

THREE.MeshNormalMaterial.prototype.copy = function ( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;

    return this;

};

// File:src/materials/MultiMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MultiMaterial = function ( materials ) {

    this.uuid = THREE.Math.generateUUID();

    this.type = 'MultiMaterial';

    this.materials = materials instanceof Array ? materials : [];

    this.visible = true;

};

THREE.MultiMaterial.prototype = {

    constructor: THREE.MultiMaterial,

    toJSON: function () {

        var output = {
            metadata: {
                version: 4.2,
                type: 'material',
                generator: 'MaterialExporter'
            },
            uuid: this.uuid,
            type: this.type,
            materials: []
        };

        for ( var i = 0, l = this.materials.length; i < l; i ++ ) {

            output.materials.push( this.materials[ i ].toJSON() );

        }

        output.visible = this.visible;

        return output;

    },

    clone: function () {

        var material = new this.constructor();

        for ( var i = 0; i < this.materials.length; i ++ ) {

            material.materials.push( this.materials[ i ].clone() );

        }

        material.visible = this.visible;

        return material;

    }

};

// backwards compatibility

THREE.MeshFaceMaterial = THREE.MultiMaterial;

// File:src/materials/PointsMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  vertexColors: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.PointsMaterial = function ( parameters ) {

    THREE.Material.call( this );

    this.type = 'PointsMaterial';

    this.color = new THREE.Color( 0xffffff );

    this.map = null;

    this.size = 1;
    this.sizeAttenuation = true;

    this.vertexColors = THREE.NoColors;

    this.fog = true;

    this.setValues( parameters );

};

THREE.PointsMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;

THREE.PointsMaterial.prototype.copy = function ( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );

    this.map = source.map;

    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;

    this.vertexColors = source.vertexColors;

    this.fog = source.fog;

    return this;

};

// backwards compatibility

THREE.PointCloudMaterial = function ( parameters ) {

    console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
    return new THREE.PointsMaterial( parameters );

};

THREE.ParticleBasicMaterial = function ( parameters ) {

    console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
    return new THREE.PointsMaterial( parameters );

};

THREE.ParticleSystemMaterial = function ( parameters ) {

    console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
    return new THREE.PointsMaterial( parameters );

};

// File:src/materials/ShaderMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.ShaderMaterial = function ( parameters ) {

    THREE.Material.call( this );

    this.type = 'ShaderMaterial';

    this.defines = {};
    this.uniforms = {};

    this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
    this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

    this.shading = THREE.SmoothShading;

    this.linewidth = 1;

    this.wireframe = false;
    this.wireframeLinewidth = 1;

    this.fog = false; // set to use scene fog

    this.lights = false; // set to use scene lights

    this.vertexColors = THREE.NoColors; // set to use "color" attribute stream

    this.skinning = false; // set to use skinning attribute streams

    this.morphTargets = false; // set to use morph targets
    this.morphNormals = false; // set to use morph normals

    this.derivatives = false; // set to use derivatives

    // When rendered geometry doesn't include these attributes but the material does,
    // use these default values in WebGL. This avoids errors when buffer data is missing.
    this.defaultAttributeValues = {
        'color': [ 1, 1, 1 ],
        'uv': [ 0, 0 ],
        'uv2': [ 0, 0 ]
    };

    this.index0AttributeName = undefined;

    if ( parameters !== undefined ) {

        if ( parameters.attributes !== undefined ) {

            console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

        }

        this.setValues( parameters );

    }

};

THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;

THREE.ShaderMaterial.prototype.copy = function ( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;

    this.uniforms = THREE.UniformsUtils.clone( source.uniforms );

    this.attributes = source.attributes;
    this.defines = source.defines;

    this.shading = source.shading;

    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;

    this.fog = source.fog;

    this.lights = source.lights;

    this.vertexColors = source.vertexColors;

    this.skinning = source.skinning;

    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;

    this.derivatives = source.derivatives;

    return this;

};

THREE.ShaderMaterial.prototype.toJSON = function ( meta ) {

    var data = THREE.Material.prototype.toJSON.call( this, meta );

    data.uniforms = this.uniforms;
    data.attributes = this.attributes;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;

    return data;

};

// File:src/materials/RawShaderMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RawShaderMaterial = function ( parameters ) {

    THREE.ShaderMaterial.call( this, parameters );

    this.type = 'RawShaderMaterial';

};

THREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );
THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;
// File:src/materials/SpriteMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *	uvOffset: new THREE.Vector2(),
 *	uvScale: new THREE.Vector2(),
 *
 *  fog: <bool>
 * }
 */

THREE.SpriteMaterial = function ( parameters ) {

    THREE.Material.call( this );

    this.type = 'SpriteMaterial';

    this.color = new THREE.Color( 0xffffff );
    this.map = null;

    this.rotation = 0;

    this.fog = false;

    // set parameters

    this.setValues( parameters );

};

THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;

THREE.SpriteMaterial.prototype.copy = function ( source ) {

    THREE.Material.prototype.copy.call( this, source );

    this.color.copy( source.color );
    this.map = source.map;

    this.rotation = source.rotation;

    this.fog = source.fog;

    return this;

};

// File:src/textures/Texture.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

    Object.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );

    this.uuid = THREE.Math.generateUUID();

    this.name = '';
    this.sourceFile = '';

    this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
    this.mipmaps = [];

    this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;

    this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
    this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;

    this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
    this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;

    this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

    this.format = format !== undefined ? format : THREE.RGBAFormat;
    this.type = type !== undefined ? type : THREE.UnsignedByteType;

    this.offset = new THREE.Vector2( 0, 0 );
    this.repeat = new THREE.Vector2( 1, 1 );

    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

    this.version = 0;
    this.onUpdate = null;

};

THREE.Texture.DEFAULT_IMAGE = undefined;
THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;

THREE.Texture.prototype = {

    constructor: THREE.Texture,

    set needsUpdate ( value ) {

        if ( value === true ) this.version ++;

    },

    clone: function () {

        return new this.constructor().copy( this );

    },

    copy: function ( source ) {

        this.image = source.image;
        this.mipmaps = source.mipmaps.slice( 0 );

        this.mapping = source.mapping;

        this.wrapS = source.wrapS;
        this.wrapT = source.wrapT;

        this.magFilter = source.magFilter;
        this.minFilter = source.minFilter;

        this.anisotropy = source.anisotropy;

        this.format = source.format;
        this.type = source.type;

        this.offset.copy( source.offset );
        this.repeat.copy( source.repeat );

        this.generateMipmaps = source.generateMipmaps;
        this.premultiplyAlpha = source.premultiplyAlpha;
        this.flipY = source.flipY;
        this.unpackAlignment = source.unpackAlignment;

        return this;

    },

    toJSON: function ( meta ) {

        if ( meta.textures[ this.uuid ] !== undefined ) {

            return meta.textures[ this.uuid ];

        }

        function getDataURL( image ) {

            var canvas;

            if ( image.toDataURL !== undefined ) {

                canvas = image;

            } else {

                canvas = document.createElement( 'canvas' );
                canvas.width = image.width;
                canvas.height = image.height;

                canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );

            }

            if ( canvas.width > 2048 || canvas.height > 2048 ) {

                return canvas.toDataURL( 'image/jpeg', 0.6 );

            } else {

                return canvas.toDataURL( 'image/png' );

            }

        }

        var output = {
            metadata: {
                version: 4.4,
                type: 'Texture',
                generator: 'Texture.toJSON'
            },

            uuid: this.uuid,
            name: this.name,

            mapping: this.mapping,

            repeat: [ this.repeat.x, this.repeat.y ],
            offset: [ this.offset.x, this.offset.y ],
            wrap: [ this.wrapS, this.wrapT ],

            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy
        };

        if ( this.image !== undefined ) {

            // TODO: Move to THREE.Image

            var image = this.image;

            if ( image.uuid === undefined ) {

                image.uuid = THREE.Math.generateUUID(); // UGH

            }

            if ( meta.images[ image.uuid ] === undefined ) {

                meta.images[ image.uuid ] = {
                    uuid: image.uuid,
                    url: getDataURL( image )
                };

            }

            output.image = image.uuid;

        }

        meta.textures[ this.uuid ] = output;

        return output;

    },

    dispose: function () {

        this.dispatchEvent( { type: 'dispose' } );

    },

    transformUv: function ( uv ) {

        if ( this.mapping !== THREE.UVMapping )  return;

        uv.multiply( this.repeat );
        uv.add( this.offset );

        if ( uv.x < 0 || uv.x > 1 ) {

            switch ( this.wrapS ) {

                case THREE.RepeatWrapping:

                    uv.x = uv.x - Math.floor( uv.x );
                    break;

                case THREE.ClampToEdgeWrapping:

                    uv.x = uv.x < 0 ? 0 : 1;
                    break;

                case THREE.MirroredRepeatWrapping:

                    if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

                        uv.x = Math.ceil( uv.x ) - uv.x;

                    } else {

                        uv.x = uv.x - Math.floor( uv.x );

                    }
                    break;

            }

        }

        if ( uv.y < 0 || uv.y > 1 ) {

            switch ( this.wrapT ) {

                case THREE.RepeatWrapping:

                    uv.y = uv.y - Math.floor( uv.y );
                    break;

                case THREE.ClampToEdgeWrapping:

                    uv.y = uv.y < 0 ? 0 : 1;
                    break;

                case THREE.MirroredRepeatWrapping:

                    if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

                        uv.y = Math.ceil( uv.y ) - uv.y;

                    } else {

                        uv.y = uv.y - Math.floor( uv.y );

                    }
                    break;

            }

        }

        if ( this.flipY ) {

            uv.y = 1 - uv.y;

        }

    }

};

THREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );

THREE.TextureIdCount = 0;

// File:src/textures/CanvasTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CanvasTexture = function ( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

    THREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    this.needsUpdate = true;

};

THREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;

// File:src/textures/CubeTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

    mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;

    THREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    this.images = images;
    this.flipY = false;

};

THREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;

THREE.CubeTexture.prototype.copy = function ( source ) {

    THREE.Texture.prototype.copy.call( this, source );

    this.images = source.images;

    return this;

};
// File:src/textures/CompressedTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

    THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    this.image = { width: width, height: height };
    this.mipmaps = mipmaps;

    // no flipping for cube textures
    // (also flipping doesn't work for compressed textures )

    this.flipY = false;

    // can't generate mipmaps for compressed textures
    // mips must be embedded in DDS files

    this.generateMipmaps = false;

};

THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;

// File:src/textures/DataTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

    THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    this.image = { data: data, width: width, height: height };

    this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;
    this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;

    this.flipY = false;
    this.generateMipmaps  = false;

};

THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.DataTexture.prototype.constructor = THREE.DataTexture;

// File:src/textures/VideoTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

    THREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    this.generateMipmaps = false;

    var scope = this;

    function update() {

        requestAnimationFrame( update );

        if ( video.readyState === video.HAVE_ENOUGH_DATA ) {

            scope.needsUpdate = true;

        }

    }

    update();

};

THREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;

// File:src/objects/Group.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Group = function () {

    THREE.Object3D.call( this );

    this.type = 'Group';

};

THREE.Group.prototype = Object.create( THREE.Object3D.prototype );
THREE.Group.prototype.constructor = THREE.Group;
// File:src/objects/Points.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Points = function ( geometry, material ) {

    THREE.Object3D.call( this );

    this.type = 'Points';

    this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
    this.material = material !== undefined ? material : new THREE.PointsMaterial( { color: Math.random() * 0xffffff } );

};

THREE.Points.prototype = Object.create( THREE.Object3D.prototype );
THREE.Points.prototype.constructor = THREE.Points;

THREE.Points.prototype.raycast = ( function () {

    var inverseMatrix = new THREE.Matrix4();
    var ray = new THREE.Ray();

    return function raycast( raycaster, intersects ) {

        var object = this;
        var geometry = object.geometry;
        var threshold = raycaster.params.Points.threshold;

        inverseMatrix.getInverse( this.matrixWorld );
        ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

        if ( geometry.boundingBox !== null ) {

            if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {

                return;

            }

        }

        var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
        var localThresholdSq = localThreshold * localThreshold;
        var position = new THREE.Vector3();

        function testPoint( point, index ) {

            var rayPointDistanceSq = ray.distanceSqToPoint( point );

            if ( rayPointDistanceSq < localThresholdSq ) {

                var intersectPoint = ray.closestPointToPoint( point );
                intersectPoint.applyMatrix4( object.matrixWorld );

                var distance = raycaster.ray.origin.distanceTo( intersectPoint );

                if ( distance < raycaster.near || distance > raycaster.far ) return;

                intersects.push( {

                    distance: distance,
                    distanceToRay: Math.sqrt( rayPointDistanceSq ),
                    point: intersectPoint.clone(),
                    index: index,
                    face: null,
                    object: object

                } );

            }

        }

        if ( geometry instanceof THREE.BufferGeometry ) {

            var index = geometry.index;
            var attributes = geometry.attributes;
            var positions = attributes.position.array;

            if ( index !== null ) {

                var indices = index.array;

                for ( var i = 0, il = indices.length; i < il; i ++ ) {

                    var a = indices[ i ];

                    position.fromArray( positions, a * 3 );

                    testPoint( position, a );

                }

            } else {

                for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

                    position.fromArray( positions, i * 3 );

                    testPoint( position, i );

                }

            }

        } else {

            var vertices = geometry.vertices;

            for ( var i = 0, l = vertices.length; i < l; i ++ ) {

                testPoint( vertices[ i ], i );

            }

        }

    };

}() );

THREE.Points.prototype.clone = function () {

    return new this.constructor( this.geometry, this.material ).copy( this );

};

// Backwards compatibility

THREE.PointCloud = function ( geometry, material ) {

    console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
    return new THREE.Points( geometry, material );

};

THREE.ParticleSystem = function ( geometry, material ) {

    console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
    return new THREE.Points( geometry, material );

};

// File:src/objects/Line.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Line = function ( geometry, material, mode ) {

    if ( mode === 1 ) {

        console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
        return new THREE.LineSegments( geometry, material );

    }

    THREE.Object3D.call( this );

    this.type = 'Line';

    this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
    this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );

};

THREE.Line.prototype = Object.create( THREE.Object3D.prototype );
THREE.Line.prototype.constructor = THREE.Line;

THREE.Line.prototype.raycast = ( function () {

    var inverseMatrix = new THREE.Matrix4();
    var ray = new THREE.Ray();
    var sphere = new THREE.Sphere();

    return function raycast( raycaster, intersects ) {

        var precision = raycaster.linePrecision;
        var precisionSq = precision * precision;

        var geometry = this.geometry;

        if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

        // Checking boundingSphere distance to ray

        sphere.copy( geometry.boundingSphere );
        sphere.applyMatrix4( this.matrixWorld );

        if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

            return;

        }

        inverseMatrix.getInverse( this.matrixWorld );
        ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

        var vStart = new THREE.Vector3();
        var vEnd = new THREE.Vector3();
        var interSegment = new THREE.Vector3();
        var interRay = new THREE.Vector3();
        var step = this instanceof THREE.LineSegments ? 2 : 1;

        if ( geometry instanceof THREE.BufferGeometry ) {

            var index = geometry.index;
            var attributes = geometry.attributes;

            if ( index !== null ) {

                var indices = index.array;
                var positions = attributes.position.array;

                for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

                    var a = indices[ i ];
                    var b = indices[ i + 1 ];

                    vStart.fromArray( positions, a * 3 );
                    vEnd.fromArray( positions, b * 3 );

                    var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

                    if ( distSq > precisionSq ) continue;

                    interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

                    var distance = raycaster.ray.origin.distanceTo( interRay );

                    if ( distance < raycaster.near || distance > raycaster.far ) continue;

                    intersects.push( {

                        distance: distance,
                        // What do we want? intersection point on the ray or on the segment??
                        // point: raycaster.ray.at( distance ),
                        point: interSegment.clone().applyMatrix4( this.matrixWorld ),
                        index: i,
                        face: null,
                        faceIndex: null,
                        object: this

                    } );

                }

            } else {

                var positions = attributes.position.array;

                for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

                    vStart.fromArray( positions, 3 * i );
                    vEnd.fromArray( positions, 3 * i + 3 );

                    var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

                    if ( distSq > precisionSq ) continue;

                    interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

                    var distance = raycaster.ray.origin.distanceTo( interRay );

                    if ( distance < raycaster.near || distance > raycaster.far ) continue;

                    intersects.push( {

                        distance: distance,
                        // What do we want? intersection point on the ray or on the segment??
                        // point: raycaster.ray.at( distance ),
                        point: interSegment.clone().applyMatrix4( this.matrixWorld ),
                        index: i,
                        face: null,
                        faceIndex: null,
                        object: this

                    } );

                }

            }

        } else if ( geometry instanceof THREE.Geometry ) {

            var vertices = geometry.vertices;
            var nbVertices = vertices.length;

            for ( var i = 0; i < nbVertices - 1; i += step ) {

                var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

                if ( distSq > precisionSq ) continue;

                interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

                var distance = raycaster.ray.origin.distanceTo( interRay );

                if ( distance < raycaster.near || distance > raycaster.far ) continue;

                intersects.push( {

                    distance: distance,
                    // What do we want? intersection point on the ray or on the segment??
                    // point: raycaster.ray.at( distance ),
                    point: interSegment.clone().applyMatrix4( this.matrixWorld ),
                    index: i,
                    face: null,
                    faceIndex: null,
                    object: this

                } );

            }

        }

    };

}() );

THREE.Line.prototype.clone = function () {

    return new this.constructor( this.geometry, this.material ).copy( this );

};

// DEPRECATED

THREE.LineStrip = 0;
THREE.LinePieces = 1;

// File:src/objects/LineSegments.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LineSegments = function ( geometry, material ) {

    THREE.Line.call( this, geometry, material );

    this.type = 'LineSegments';

};

THREE.LineSegments.prototype = Object.create( THREE.Line.prototype );
THREE.LineSegments.prototype.constructor = THREE.LineSegments;

// File:src/objects/Mesh.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

THREE.Mesh = function ( geometry, material ) {

    THREE.Object3D.call( this );

    this.type = 'Mesh';

    this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
    this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );

    this.updateMorphTargets();

};

THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );
THREE.Mesh.prototype.constructor = THREE.Mesh;

THREE.Mesh.prototype.updateMorphTargets = function () {

    if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {

        this.morphTargetBase = - 1;
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};

        for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {

            this.morphTargetInfluences.push( 0 );
            this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;

        }

    }

};

THREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {

    if ( this.morphTargetDictionary[ name ] !== undefined ) {

        return this.morphTargetDictionary[ name ];

    }

    console.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );

    return 0;

};


THREE.Mesh.prototype.raycast = ( function () {

    var inverseMatrix = new THREE.Matrix4();
    var ray = new THREE.Ray();
    var sphere = new THREE.Sphere();

    var vA = new THREE.Vector3();
    var vB = new THREE.Vector3();
    var vC = new THREE.Vector3();

    var tempA = new THREE.Vector3();
    var tempB = new THREE.Vector3();
    var tempC = new THREE.Vector3();

    var uvA = new THREE.Vector2();
    var uvB = new THREE.Vector2();
    var uvC = new THREE.Vector2();

    var barycoord = new THREE.Vector3();

    var intersectionPoint = new THREE.Vector3();
    var intersectionPointWorld = new THREE.Vector3();

    function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

        THREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );

        uv1.multiplyScalar( barycoord.x );
        uv2.multiplyScalar( barycoord.y );
        uv3.multiplyScalar( barycoord.z );

        uv1.add( uv2 ).add( uv3 );

        return uv1.clone();

    }

    function checkIntersection( object, raycaster, ray, pA, pB, pC, point ){

        var intersect;
        var material = object.material;

        if ( material.side === THREE.BackSide ) {

            intersect = ray.intersectTriangle( pC, pB, pA, true, point );

        } else {

            intersect = ray.intersectTriangle( pA, pB, pC, material.side !== THREE.DoubleSide, point );

        }

        if ( intersect === null ) return null;

        intersectionPointWorld.copy( point );
        intersectionPointWorld.applyMatrix4( object.matrixWorld );

        var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

        if ( distance < raycaster.near || distance > raycaster.far ) return null;

        return {
            distance: distance,
            point: intersectionPointWorld.clone(),
            object: object
        };

    }

    function checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {

        vA.fromArray( positions, a * 3 );
        vB.fromArray( positions, b * 3 );
        vC.fromArray( positions, c * 3 );

        var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );

        if ( intersection ) {

            if ( uvs ) {

                uvA.fromArray( uvs, a * 2 );
                uvB.fromArray( uvs, b * 2 );
                uvC.fromArray( uvs, c * 2 );

                intersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );

            }

            intersection.face = new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) );
            intersection.faceIndex = a;

        }

        return intersection;

    }

    return function raycast( raycaster, intersects ) {

        var geometry = this.geometry;
        var material = this.material;

        if ( material === undefined ) return;

        // Checking boundingSphere distance to ray

        if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

        var matrixWorld = this.matrixWorld;

        sphere.copy( geometry.boundingSphere );
        sphere.applyMatrix4( matrixWorld );

        if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) return;

        // Check boundingBox before continuing

        inverseMatrix.getInverse( matrixWorld );
        ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

        if ( geometry.boundingBox !== null ) {

            if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) return;

        }

        var uvs, intersection;

        if ( geometry instanceof THREE.BufferGeometry ) {

            var a, b, c;
            var index = geometry.index;
            var attributes = geometry.attributes;
            var positions = attributes.position.array;

            if ( attributes.uv !== undefined ){

                uvs = attributes.uv.array;

            }

            if ( index !== null ) {

                var indices = index.array;

                for ( var i = 0, l = indices.length; i < l; i += 3 ) {

                    a = indices[ i ];
                    b = indices[ i + 1 ];
                    c = indices[ i + 2 ];

                    intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );

                    if ( intersection ) {

                        intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
                        intersects.push( intersection );

                    }

                }

            } else {


                for ( var i = 0, l = positions.length; i < l; i += 9 ) {

                    a = i / 3;
                    b = a + 1;
                    c = a + 2;

                    intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );

                    if ( intersection ) {

                        intersection.index = a; // triangle number in positions buffer semantics
                        intersects.push( intersection );

                    }

                }

            }

        } else if ( geometry instanceof THREE.Geometry ) {

            var fvA, fvB, fvC;
            var isFaceMaterial = material instanceof THREE.MeshFaceMaterial;
            var materials = isFaceMaterial === true ? material.materials : null;

            var vertices = geometry.vertices;
            var faces = geometry.faces;
            var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
            if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;

            for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

                var face = faces[ f ];
                var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;

                if ( faceMaterial === undefined ) continue;

                fvA = vertices[ face.a ];
                fvB = vertices[ face.b ];
                fvC = vertices[ face.c ];

                if ( faceMaterial.morphTargets === true ) {

                    var morphTargets = geometry.morphTargets;
                    var morphInfluences = this.morphTargetInfluences;

                    vA.set( 0, 0, 0 );
                    vB.set( 0, 0, 0 );
                    vC.set( 0, 0, 0 );

                    for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

                        var influence = morphInfluences[ t ];

                        if ( influence === 0 ) continue;

                        var targets = morphTargets[ t ].vertices;

                        vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
                        vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
                        vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );

                    }

                    vA.add( fvA );
                    vB.add( fvB );
                    vC.add( fvC );

                    fvA = vA;
                    fvB = vB;
                    fvC = vC;

                }

                intersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );

                if ( intersection ) {

                    if ( uvs ) {

                        var uvs_f = uvs[ f ];
                        uvA.copy( uvs_f[ 0 ] );
                        uvB.copy( uvs_f[ 1 ] );
                        uvC.copy( uvs_f[ 2 ] );

                        intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );

                    }

                    intersection.face = face;
                    intersection.faceIndex = f;
                    intersects.push( intersection );

                }

            }

        }

    };

}() );

THREE.Mesh.prototype.clone = function () {

    return new this.constructor( this.geometry, this.material ).copy( this );

};

// File:src/objects/Bone.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.Bone = function ( skin ) {

    THREE.Object3D.call( this );

    this.type = 'Bone';

    this.skin = skin;

};

THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );
THREE.Bone.prototype.constructor = THREE.Bone;

THREE.Bone.prototype.copy = function ( source ) {

    THREE.Object3D.prototype.copy.call( this, source );

    this.skin = source.skin;

    return this;

};

// File:src/objects/Skeleton.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */

THREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {

    this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

    this.identityMatrix = new THREE.Matrix4();

    // copy the bone array

    bones = bones || [];

    this.bones = bones.slice( 0 );

    // create a bone texture or an array of floats

    if ( this.useVertexTexture ) {

        // layout (1 matrix = 4 pixels)
        //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
        //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
        //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
        //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
        //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


        var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
        size = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );
        size = Math.max( size, 4 );

        this.boneTextureWidth = size;
        this.boneTextureHeight = size;

        this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
        this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );

    } else {

        this.boneMatrices = new Float32Array( 16 * this.bones.length );

    }

    // use the supplied bone inverses or calculate the inverses

    if ( boneInverses === undefined ) {

        this.calculateInverses();

    } else {

        if ( this.bones.length === boneInverses.length ) {

            this.boneInverses = boneInverses.slice( 0 );

        } else {

            console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

            this.boneInverses = [];

            for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

                this.boneInverses.push( new THREE.Matrix4() );

            }

        }

    }

};

THREE.Skeleton.prototype.calculateInverses = function () {

    this.boneInverses = [];

    for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

        var inverse = new THREE.Matrix4();

        if ( this.bones[ b ] ) {

            inverse.getInverse( this.bones[ b ].matrixWorld );

        }

        this.boneInverses.push( inverse );

    }

};

THREE.Skeleton.prototype.pose = function () {

    var bone;

    // recover the bind-time world matrices

    for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

        bone = this.bones[ b ];

        if ( bone ) {

            bone.matrixWorld.getInverse( this.boneInverses[ b ] );

        }

    }

    // compute the local matrices, positions, rotations and scales

    for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

        bone = this.bones[ b ];

        if ( bone ) {

            if ( bone.parent ) {

                bone.matrix.getInverse( bone.parent.matrixWorld );
                bone.matrix.multiply( bone.matrixWorld );

            } else {

                bone.matrix.copy( bone.matrixWorld );

            }

            bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

        }

    }

};

THREE.Skeleton.prototype.update = ( function () {

    var offsetMatrix = new THREE.Matrix4();

    return function update() {

        // flatten bone matrices to array

        for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

            // compute the offset between the current and the original transform

            var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

            offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
            offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );

        }

        if ( this.useVertexTexture ) {

            this.boneTexture.needsUpdate = true;

        }

    };

} )();

THREE.Skeleton.prototype.clone = function () {

    return new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );

};

// File:src/objects/SkinnedMesh.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {

    THREE.Mesh.call( this, geometry, material );

    this.type = 'SkinnedMesh';

    this.bindMode = "attached";
    this.bindMatrix = new THREE.Matrix4();
    this.bindMatrixInverse = new THREE.Matrix4();

    // init bones

    // TODO: remove bone creation as there is no reason (other than
    // convenience) for THREE.SkinnedMesh to do this.

    var bones = [];

    if ( this.geometry && this.geometry.bones !== undefined ) {

        var bone, gbone;

        for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

            gbone = this.geometry.bones[ b ];

            bone = new THREE.Bone( this );
            bones.push( bone );

            bone.name = gbone.name;
            bone.position.fromArray( gbone.pos );
            bone.quaternion.fromArray( gbone.rotq );
            if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );

        }

        for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

            gbone = this.geometry.bones[ b ];

            if ( gbone.parent !== - 1 && gbone.parent !== null) {

                bones[ gbone.parent ].add( bones[ b ] );

            } else {

                this.add( bones[ b ] );

            }

        }

    }

    this.normalizeSkinWeights();

    this.updateMatrixWorld( true );
    this.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );

};


THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;

THREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {

    this.skeleton = skeleton;

    if ( bindMatrix === undefined ) {

        this.updateMatrixWorld( true );

        this.skeleton.calculateInverses();

        bindMatrix = this.matrixWorld;

    }

    this.bindMatrix.copy( bindMatrix );
    this.bindMatrixInverse.getInverse( bindMatrix );

};

THREE.SkinnedMesh.prototype.pose = function () {

    this.skeleton.pose();

};

THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {

    if ( this.geometry instanceof THREE.Geometry ) {

        for ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {

            var sw = this.geometry.skinWeights[ i ];

            var scale = 1.0 / sw.lengthManhattan();

            if ( scale !== Infinity ) {

                sw.multiplyScalar( scale );

            } else {

                sw.set( 1 ); // this will be normalized by the shader anyway

            }

        }

    } else {

        // skinning weights assumed to be normalized for THREE.BufferGeometry

    }

};

THREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {

    THREE.Mesh.prototype.updateMatrixWorld.call( this, true );

    if ( this.bindMode === "attached" ) {

        this.bindMatrixInverse.getInverse( this.matrixWorld );

    } else if ( this.bindMode === "detached" ) {

        this.bindMatrixInverse.getInverse( this.bindMatrix );

    } else {

        console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );

    }

};

THREE.SkinnedMesh.prototype.clone = function() {

    return new this.constructor( this.geometry, this.material, this.useVertexTexture ).copy( this );

};

// File:src/objects/LOD.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LOD = function () {

    THREE.Object3D.call( this );

    this.type = 'LOD';

    Object.defineProperties( this, {
        levels: {
            enumerable: true,
            value: []
        },
        objects: {
            get: function () {

                console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
                return this.levels;

            }
        }
    } );

};


THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );
THREE.LOD.prototype.constructor = THREE.LOD;

THREE.LOD.prototype.addLevel = function ( object, distance ) {

    if ( distance === undefined ) distance = 0;

    distance = Math.abs( distance );

    var levels = this.levels;

    for ( var l = 0; l < levels.length; l ++ ) {

        if ( distance < levels[ l ].distance ) {

            break;

        }

    }

    levels.splice( l, 0, { distance: distance, object: object } );

    this.add( object );

};

THREE.LOD.prototype.getObjectForDistance = function ( distance ) {

    var levels = this.levels;

    for ( var i = 1, l = levels.length; i < l; i ++ ) {

        if ( distance < levels[ i ].distance ) {

            break;

        }

    }

    return levels[ i - 1 ].object;

};

THREE.LOD.prototype.raycast = ( function () {

    var matrixPosition = new THREE.Vector3();

    return function raycast( raycaster, intersects ) {

        matrixPosition.setFromMatrixPosition( this.matrixWorld );

        var distance = raycaster.ray.origin.distanceTo( matrixPosition );

        this.getObjectForDistance( distance ).raycast( raycaster, intersects );

    };

}() );

THREE.LOD.prototype.update = function () {

    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();

    return function update( camera ) {

        var levels = this.levels;

        if ( levels.length > 1 ) {

            v1.setFromMatrixPosition( camera.matrixWorld );
            v2.setFromMatrixPosition( this.matrixWorld );

            var distance = v1.distanceTo( v2 );

            levels[ 0 ].object.visible = true;

            for ( var i = 1, l = levels.length; i < l; i ++ ) {

                if ( distance >= levels[ i ].distance ) {

                    levels[ i - 1 ].object.visible = false;
                    levels[ i ].object.visible = true;

                } else {

                    break;

                }

            }

            for ( ; i < l; i ++ ) {

                levels[ i ].object.visible = false;

            }

        }

    };

}();

THREE.LOD.prototype.copy = function ( source ) {

    THREE.Object3D.prototype.copy.call( this, source, false );

    var levels = source.levels;

    for ( var i = 0, l = levels.length; i < l; i ++ ) {

        var level = levels[ i ];

        this.addLevel( level.object.clone(), level.distance );

    }

    return this;

};

THREE.LOD.prototype.toJSON = function ( meta ) {

    var data = THREE.Object3D.prototype.toJSON.call( this, meta );

    data.object.levels = [];

    var levels = this.levels;

    for ( var i = 0, l = levels.length; i < l; i ++ ) {

        var level = levels[ i ];

        data.object.levels.push( {
            object: level.object.uuid,
            distance: level.distance
        } );

    }

    return data;

};

// File:src/objects/Sprite.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Sprite = ( function () {

    var indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );
    var vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );
    var uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );

    var geometry = new THREE.BufferGeometry();
    geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
    geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
    geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

    return function Sprite( material ) {

        THREE.Object3D.call( this );

        this.type = 'Sprite';

        this.geometry = geometry;
        this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();

    };

} )();

THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );
THREE.Sprite.prototype.constructor = THREE.Sprite;

THREE.Sprite.prototype.raycast = ( function () {

    var matrixPosition = new THREE.Vector3();

    return function raycast( raycaster, intersects ) {

        matrixPosition.setFromMatrixPosition( this.matrixWorld );

        var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );
        var guessSizeSq = this.scale.x * this.scale.y;

        if ( distanceSq > guessSizeSq ) {

            return;

        }

        intersects.push( {

            distance: Math.sqrt( distanceSq ),
            point: this.position,
            face: null,
            object: this

        } );

    };

}() );

THREE.Sprite.prototype.clone = function () {

    return new this.constructor( this.material ).copy( this );

};

// Backwards compatibility

THREE.Particle = THREE.Sprite;

// File:src/objects/LensFlare.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlare = function ( texture, size, distance, blending, color ) {

    THREE.Object3D.call( this );

    this.lensFlares = [];

    this.positionScreen = new THREE.Vector3();
    this.customUpdateCallback = undefined;

    if ( texture !== undefined ) {

        this.add( texture, size, distance, blending, color );

    }

};

THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );
THREE.LensFlare.prototype.constructor = THREE.LensFlare;


/*
 * Add: adds another flare
 */

THREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {

    if ( size === undefined ) size = - 1;
    if ( distance === undefined ) distance = 0;
    if ( opacity === undefined ) opacity = 1;
    if ( color === undefined ) color = new THREE.Color( 0xffffff );
    if ( blending === undefined ) blending = THREE.NormalBlending;

    distance = Math.min( distance, Math.max( 0, distance ) );

    this.lensFlares.push( {
        texture: texture,	// THREE.Texture
        size: size, 		// size in pixels (-1 = use texture.width)
        distance: distance, 	// distance (0-1) from light source (0=at light source)
        x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back
        scale: 1, 		// scale
        rotation: 0, 		// rotation
        opacity: opacity,	// opacity
        color: color,		// color
        blending: blending	// blending
    } );

};

/*
 * Update lens flares update positions on all flares based on the screen position
 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
 */

THREE.LensFlare.prototype.updateLensFlares = function () {

    var f, fl = this.lensFlares.length;
    var flare;
    var vecX = - this.positionScreen.x * 2;
    var vecY = - this.positionScreen.y * 2;

    for ( f = 0; f < fl; f ++ ) {

        flare = this.lensFlares[ f ];

        flare.x = this.positionScreen.x + vecX * flare.distance;
        flare.y = this.positionScreen.y + vecY * flare.distance;

        flare.wantedRotation = flare.x * Math.PI * 0.25;
        flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

    }

};

THREE.LensFlare.prototype.copy = function ( source ) {

    THREE.Object3D.prototype.copy.call( this, source );

    this.positionScreen.copy( source.positionScreen );
    this.customUpdateCallback = source.customUpdateCallback;

    for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {

        this.lensFlares.push( source.lensFlares[ i ] );

    }

    return this;

};

// File:src/scenes/Scene.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Scene = function () {

    THREE.Object3D.call( this );

    this.type = 'Scene';

    this.fog = null;
    this.overrideMaterial = null;

    this.autoUpdate = true; // checked by the renderer

};

THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );
THREE.Scene.prototype.constructor = THREE.Scene;

THREE.Scene.prototype.copy = function ( source ) {

    THREE.Object3D.prototype.copy.call( this, source );

    if ( source.fog !== null ) this.fog = source.fog.clone();
    if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

    this.autoUpdate = source.autoUpdate;
    this.matrixAutoUpdate = source.matrixAutoUpdate;

    return this;

};

// File:src/scenes/Fog.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Fog = function ( color, near, far ) {

    this.name = '';

    this.color = new THREE.Color( color );

    this.near = ( near !== undefined ) ? near : 1;
    this.far = ( far !== undefined ) ? far : 1000;

};

THREE.Fog.prototype.clone = function () {

    return new THREE.Fog( this.color.getHex(), this.near, this.far );

};

// File:src/scenes/FogExp2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.FogExp2 = function ( color, density ) {

    this.name = '';

    this.color = new THREE.Color( color );
    this.density = ( density !== undefined ) ? density : 0.00025;

};

THREE.FogExp2.prototype.clone = function () {

    return new THREE.FogExp2( this.color.getHex(), this.density );

};

// File:src/renderers/shaders/ShaderChunk.js

THREE.ShaderChunk = {};

// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl

THREE.ShaderChunk[ 'alphamap_fragment'] = "#ifdef USE_ALPHAMAP\n\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl

THREE.ShaderChunk[ 'alphamap_pars_fragment'] = "#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl

THREE.ShaderChunk[ 'alphatest_fragment'] = "#ifdef ALPHATEST\n\n	if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl

THREE.ShaderChunk[ 'aomap_fragment'] = "#ifdef USE_AOMAP\n\n	totalAmbientLight *= ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl

THREE.ShaderChunk[ 'aomap_pars_fragment'] = "#ifdef USE_AOMAP\n\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl

THREE.ShaderChunk[ 'begin_vertex'] = "\nvec3 transformed = vec3( position );\n";

// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl

THREE.ShaderChunk[ 'beginnormal_vertex'] = "\nvec3 objectNormal = vec3( normal );\n";

// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl

THREE.ShaderChunk[ 'bumpmap_pars_fragment'] = "#ifdef USE_BUMPMAP\n\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n\n\n\n	vec2 dHdxy_fwd() {\n\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n		return vec2( dBx, dBy );\n\n	}\n\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n\n		float fDet = dot( vSigmaX, R1 );\n\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl

THREE.ShaderChunk[ 'color_fragment'] = "#ifdef USE_COLOR\n\n	diffuseColor.rgb *= vColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl

THREE.ShaderChunk[ 'color_pars_fragment'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl

THREE.ShaderChunk[ 'color_pars_vertex'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl

THREE.ShaderChunk[ 'color_vertex'] = "#ifdef USE_COLOR\n\n	vColor.xyz = color.xyz;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/common.glsl

THREE.ShaderChunk[ 'common'] = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n\n	return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n\n}\n\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\n	return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	float distance = dot( planeNormal, point - pointOnPlane );\n\n	return - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n\n	if ( decayExponent > 0.0 ) {\n\n	  return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n	}\n\n	return 1.0;\n\n}\n\nvec3 F_Schlick( in vec3 specularColor, in float dotLH ) {\n\n\n	float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );\n\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n\n}\n\nfloat G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {\n\n\n	return 0.25;\n\n}\n\nfloat D_BlinnPhong( in float shininess, in float dotNH ) {\n\n\n	return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {\n\n	vec3 halfDir = normalize( lightDir + viewDir );\n\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( lightDir, halfDir ) );\n\n	vec3 F = F_Schlick( specularColor, dotLH );\n\n	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n	float D = D_BlinnPhong( shininess, dotNH );\n\n	return F * G * D;\n\n}\n\nvec3 inputToLinear( in vec3 a ) {\n\n	#ifdef GAMMA_INPUT\n\n		return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n\n	#else\n\n		return a;\n\n	#endif\n\n}\n\nvec3 linearToOutput( in vec3 a ) {\n\n	#ifdef GAMMA_OUTPUT\n\n		return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\n	#else\n\n		return a;\n\n	#endif\n\n}\n";

// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl

THREE.ShaderChunk[ 'defaultnormal_vertex'] = "#ifdef FLIP_SIDED\n\n	objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n";

// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl

THREE.ShaderChunk[ 'displacementmap_vertex'] = "#ifdef USE_DISPLACEMENTMAP\n\n	transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl

THREE.ShaderChunk[ 'displacementmap_pars_vertex'] = "#ifdef USE_DISPLACEMENTMAP\n\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl

THREE.ShaderChunk[ 'emissivemap_fragment'] = "#ifdef USE_EMISSIVEMAP\n\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n	emissiveColor.rgb = inputToLinear( emissiveColor.rgb );\n\n	totalEmissiveLight *= emissiveColor.rgb;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl

THREE.ShaderChunk[ 'emissivemap_pars_fragment'] = "#ifdef USE_EMISSIVEMAP\n\n	uniform sampler2D emissiveMap;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl

THREE.ShaderChunk[ 'envmap_fragment'] = "#ifdef USE_ENVMAP\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n		#ifdef ENVMAP_MODE_REFLECTION\n\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n		#else\n\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n		#endif\n\n	#else\n\n		vec3 reflectVec = vReflect;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n		float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#else\n		float flipNormal = 1.0;\n	#endif\n\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n\n	envColor.xyz = inputToLinear( envColor.xyz );\n\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_MIX )\n\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_ADD )\n\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl

THREE.ShaderChunk[ 'envmap_pars_fragment'] = "#ifdef USE_ENVMAP\n\n	uniform float reflectivity;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		uniform float refractionRatio;\n\n	#else\n\n		varying vec3 vReflect;\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl

THREE.ShaderChunk[ 'envmap_pars_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	varying vec3 vReflect;\n\n	uniform float refractionRatio;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl

THREE.ShaderChunk[ 'envmap_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n	vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\n	#ifdef ENVMAP_MODE_REFLECTION\n\n		vReflect = reflect( cameraToVertex, worldNormal );\n\n	#else\n\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl

THREE.ShaderChunk[ 'fog_fragment'] = "#ifdef USE_FOG\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n	#else\n\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n	#endif\n\n	#ifdef FOG_EXP2\n\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\n	#else\n\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n	#endif\n	\n	outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl

THREE.ShaderChunk[ 'fog_pars_fragment'] = "#ifdef USE_FOG\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/hemilight_fragment.glsl

THREE.ShaderChunk[ 'hemilight_fragment'] = "#if MAX_HEMI_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lightDir = hemisphereLightDirection[ i ];\n\n		float dotProduct = dot( normal, lightDir );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vec3 lightColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		totalAmbientLight += lightColor;\n\n	}\n\n#endif\n\n";

// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl

THREE.ShaderChunk[ 'lightmap_fragment'] = "#ifdef USE_LIGHTMAP\n\n	totalAmbientLight += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl

THREE.ShaderChunk[ 'lightmap_pars_fragment'] = "#ifdef USE_LIGHTMAP\n\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_pars_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_pars_vertex'] = "#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_vertex'] = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vec3( 0.0 );\n\n#endif\n\nvec3 normal = normalize( transformedNormal );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = pointLightColor[ i ];\n\n		vec3 lVector = pointLightPosition[ i ] - mvPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n\n		float dotProduct = dot( normal, lightDir );\n\n		vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = spotLightColor[ i ];\n\n		vec3 lightPosition = spotLightPosition[ i ];\n		vec3 lVector = lightPosition - mvPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], lightDir );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			attenuation *= spotEffect;\n\n\n			float dotProduct = dot( normal, lightDir );\n\n			vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n			#ifdef DOUBLE_SIDED\n\n				vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n			#endif\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 lightColor = directionalLightColor[ i ];\n\n		vec3 lightDir = directionalLightDirection[ i ];\n\n\n		float dotProduct = dot( normal, lightDir );\n\n		vLightFront += lightColor * saturate( dotProduct );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += lightColor * saturate( - dotProduct );\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lightDir = hemisphereLightDirection[ i ];\n\n\n		float dotProduct = dot( normal, lightDir );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		#ifdef DOUBLE_SIDED\n\n			float hemiDiffuseWeightBack = - 0.5 * dotProduct + 0.5;\n\n			vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n		#endif\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_fragment'] = "vec3 viewDir = normalize( vViewPosition );\n\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = pointLightColor[ i ];\n\n		vec3 lightPosition = pointLightPosition[ i ];\n		vec3 lVector = lightPosition + vViewPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n\n		float cosineTerm = saturate( dot( normal, lightDir ) );\n\n		totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = spotLightColor[ i ];\n\n		vec3 lightPosition = spotLightPosition[ i ];\n		vec3 lVector = lightPosition + vViewPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], lightDir );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			attenuation *= spotEffect;\n\n\n			float cosineTerm = saturate( dot( normal, lightDir ) );\n\n			totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n\n			vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n			totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 lightColor = directionalLightColor[ i ];\n\n		vec3 lightDir = directionalLightDirection[ i ];\n\n\n		float cosineTerm = saturate( dot( normal, lightDir ) );\n\n		totalDiffuseLight += lightColor * cosineTerm;\n\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * cosineTerm;\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_pars_fragment'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_pars_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	vWorldPosition = worldPosition.xyz;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl

THREE.ShaderChunk[ 'linear_to_gamma_fragment'] = "\n	outgoingLight = linearToOutput( outgoingLight );\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_fragment'] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_fragment'] = "#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n	uniform float logDepthBufFC;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl

THREE.ShaderChunk[ 'map_fragment'] = "#ifdef USE_MAP\n\n	vec4 texelColor = texture2D( map, vUv );\n\n	texelColor.xyz = inputToLinear( texelColor.xyz );\n\n	diffuseColor *= texelColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl

THREE.ShaderChunk[ 'map_pars_fragment'] = "#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl

THREE.ShaderChunk[ 'map_particle_fragment'] = "#ifdef USE_MAP\n\n	diffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl

THREE.ShaderChunk[ 'map_particle_pars_fragment'] = "#ifdef USE_MAP\n\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl

THREE.ShaderChunk[ 'morphnormal_vertex'] = "#ifdef USE_MORPHNORMALS\n\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_pars_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	#ifndef USE_MORPHNORMALS\n\n	uniform float morphTargetInfluences[ 8 ];\n\n	#else\n\n	uniform float morphTargetInfluences[ 4 ];\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n	#ifndef USE_MORPHNORMALS\n\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/normal_phong_fragment.glsl

THREE.ShaderChunk[ 'normal_phong_fragment'] = "#ifndef FLAT_SHADED\n\n	vec3 normal = normalize( vNormal );\n\n	#ifdef DOUBLE_SIDED\n\n		normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n	#endif\n\n#else\n\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\n";

// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl

THREE.ShaderChunk[ 'normalmap_pars_fragment'] = "#ifdef USE_NORMALMAP\n\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n\n\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl

THREE.ShaderChunk[ 'project_vertex'] = "#ifdef USE_SKINNING\n\n	vec4 mvPosition = modelViewMatrix * skinned;\n\n#else\n\n	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_fragment'] = "#ifdef USE_SHADOWMAP\n\n	for ( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		float texelSizeY =  1.0 / shadowMapSize[ i ].y;\n\n		float shadow = 0.0;\n\n#if defined( POINT_LIGHT_SHADOWS )\n\n		bool isPointLight = shadowDarkness[ i ] < 0.0;\n\n		if ( isPointLight ) {\n\n			float realShadowDarkness = abs( shadowDarkness[ i ] );\n\n			vec3 lightToPosition = vShadowCoord[ i ].xyz;\n\n	#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n			vec3 bd3D = normalize( lightToPosition );\n			float dp = length( lightToPosition );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D, texelSizeY ) ), shadowBias[ i ], shadow );\n\n\n	#if defined( SHADOWMAP_TYPE_PCF )\n			const float Dr = 1.25;\n	#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			const float Dr = 2.25;\n	#endif\n\n			float os = Dr *  2.0 * texelSizeY;\n\n			const vec3 Gsd = vec3( - 1, 0, 1 );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zyz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xyz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zyx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xyx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\n			shadow *= realShadowDarkness * ( 1.0 / 21.0 );\n\n	#else \n			vec3 bd3D = normalize( lightToPosition );\n			float dp = length( lightToPosition );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D, texelSizeY ) ), shadowBias[ i ], shadow );\n\n			shadow *= realShadowDarkness;\n\n	#endif\n\n		} else {\n\n#endif \n			float texelSizeX =  1.0 / shadowMapSize[ i ].x;\n\n			vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n\n			bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n			bool inFrustum = all( inFrustumVec );\n\n			bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n			bool frustumTest = all( frustumTestVec );\n\n			if ( frustumTest ) {\n\n	#if defined( SHADOWMAP_TYPE_PCF )\n\n\n				/*\n					for ( float y = -1.25; y <= 1.25; y += 1.25 )\n						for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n							vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n							float fDepth = unpackDepth( rgbaDepth );\n							if ( fDepth < shadowCoord.z )\n								shadow += 1.0;\n					}\n					shadow /= 9.0;\n				*/\n\n				shadowCoord.z += shadowBias[ i ];\n\n				const float ShadowDelta = 1.0 / 9.0;\n\n				float xPixelOffset = texelSizeX;\n				float yPixelOffset = texelSizeY;\n\n				float dx0 = - 1.25 * xPixelOffset;\n				float dy0 = - 1.25 * yPixelOffset;\n				float dx1 = 1.25 * xPixelOffset;\n				float dy1 = 1.25 * yPixelOffset;\n\n				float fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				shadow *= shadowDarkness[ i ];\n\n	#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\n				shadowCoord.z += shadowBias[ i ];\n\n				float xPixelOffset = texelSizeX;\n				float yPixelOffset = texelSizeY;\n\n				float dx0 = - 1.0 * xPixelOffset;\n				float dy0 = - 1.0 * yPixelOffset;\n				float dx1 = 1.0 * xPixelOffset;\n				float dy1 = 1.0 * yPixelOffset;\n\n				mat3 shadowKernel;\n				mat3 depthKernel;\n\n				depthKernel[ 0 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				depthKernel[ 0 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				depthKernel[ 0 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				depthKernel[ 1 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				depthKernel[ 1 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				depthKernel[ 1 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				depthKernel[ 2 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				depthKernel[ 2 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				depthKernel[ 2 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n				vec3 shadowZ = vec3( shadowCoord.z );\n				shadowKernel[ 0 ] = vec3( lessThan( depthKernel[ 0 ], shadowZ ) );\n				shadowKernel[ 0 ] *= vec3( 0.25 );\n\n				shadowKernel[ 1 ] = vec3( lessThan( depthKernel[ 1 ], shadowZ ) );\n				shadowKernel[ 1 ] *= vec3( 0.25 );\n\n				shadowKernel[ 2 ] = vec3( lessThan( depthKernel[ 2 ], shadowZ ) );\n				shadowKernel[ 2 ] *= vec3( 0.25 );\n\n				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[ i ].xy );\n\n				shadowKernel[ 0 ] = mix( shadowKernel[ 1 ], shadowKernel[ 0 ], fractionalCoord.x );\n				shadowKernel[ 1 ] = mix( shadowKernel[ 2 ], shadowKernel[ 1 ], fractionalCoord.x );\n\n				vec4 shadowValues;\n				shadowValues.x = mix( shadowKernel[ 0 ][ 1 ], shadowKernel[ 0 ][ 0 ], fractionalCoord.y );\n				shadowValues.y = mix( shadowKernel[ 0 ][ 2 ], shadowKernel[ 0 ][ 1 ], fractionalCoord.y );\n				shadowValues.z = mix( shadowKernel[ 1 ][ 1 ], shadowKernel[ 1 ][ 0 ], fractionalCoord.y );\n				shadowValues.w = mix( shadowKernel[ 1 ][ 2 ], shadowKernel[ 1 ][ 1 ], fractionalCoord.y );\n\n				shadow = dot( shadowValues, vec4( 1.0 ) ) * shadowDarkness[ i ];\n\n	#else \n				shadowCoord.z += shadowBias[ i ];\n\n				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n				float fDepth = unpackDepth( rgbaDepth );\n\n				if ( fDepth < shadowCoord.z )\n					shadow = shadowDarkness[ i ];\n\n	#endif\n\n			}\n\n#ifdef SHADOWMAP_DEBUG\n\n			if ( inFrustum ) {\n\n				if ( i == 0 ) {\n\n					outgoingLight *= vec3( 1.0, 0.5, 0.0 );\n\n				} else if ( i == 1 ) {\n\n					outgoingLight *= vec3( 0.0, 1.0, 0.8 );\n\n				} else {\n\n					outgoingLight *= vec3( 0.0, 0.5, 1.0 );\n\n				}\n\n			}\n\n#endif\n\n#if defined( POINT_LIGHT_SHADOWS )\n\n		}\n\n#endif\n\n		shadowMask = shadowMask * vec3( 1.0 - shadow );\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_pars_fragment'] = "#ifdef USE_SHADOWMAP\n\n	uniform sampler2D shadowMap[ MAX_SHADOWS ];\n	uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform float shadowBias[ MAX_SHADOWS ];\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n	float unpackDepth( const in vec4 rgba_depth ) {\n\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		float depth = dot( rgba_depth, bit_shift );\n		return depth;\n\n	}\n\n	#if defined(POINT_LIGHT_SHADOWS)\n\n\n		void adjustShadowValue1K( const float testDepth, const vec4 textureData, const float bias, inout float shadowValue ) {\n\n			const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n			if ( testDepth >= dot( textureData, bitSh ) * 1000.0 + bias )\n				shadowValue += 1.0;\n\n		}\n\n\n		vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n\n			vec3 absV = abs( v );\n\n\n			float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n			absV *= scaleToCube;\n\n\n			v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n\n\n			vec2 planar = v.xy;\n\n			float almostATexel = 1.5 * texelSizeY;\n			float almostOne = 1.0 - almostATexel;\n\n			if ( absV.z >= almostOne ) {\n\n				if ( v.z > 0.0 )\n					planar.x = 4.0 - v.x;\n\n			} else if ( absV.x >= almostOne ) {\n\n				float signX = sign( v.x );\n				planar.x = v.z * signX + 2.0 * signX;\n\n			} else if ( absV.y >= almostOne ) {\n\n				float signY = sign( v.y );\n				planar.x = v.x + 2.0 * signY + 2.0;\n				planar.y = v.z * signY - 2.0;\n\n			}\n\n\n			return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n		}\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_pars_vertex'] = "#ifdef USE_SHADOWMAP\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_vertex'] = "#ifdef USE_SHADOWMAP\n\n	for ( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n			vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n	}\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl

THREE.ShaderChunk[ 'skinbase_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl

THREE.ShaderChunk[ 'skinning_pars_vertex'] = "#ifdef USE_SKINNING\n\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n\n	#ifdef BONE_TEXTURE\n\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n\n			y = dy * ( y + 0.5 );\n\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n			mat4 bone = mat4( v1, v2, v3, v4 );\n\n			return bone;\n\n		}\n\n	#else\n\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n\n		}\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl

THREE.ShaderChunk[ 'skinning_vertex'] = "#ifdef USE_SKINNING\n\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl

THREE.ShaderChunk[ 'skinnormal_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl

THREE.ShaderChunk[ 'specularmap_fragment'] = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n\n#else\n\n	specularStrength = 1.0;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl

THREE.ShaderChunk[ 'specularmap_pars_fragment'] = "#ifdef USE_SPECULARMAP\n\n	uniform sampler2D specularMap;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl

THREE.ShaderChunk[ 'uv2_pars_fragment'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	varying vec2 vUv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl

THREE.ShaderChunk[ 'uv2_pars_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl

THREE.ShaderChunk[ 'uv2_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	vUv2 = uv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl

THREE.ShaderChunk[ 'uv_pars_fragment'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	varying vec2 vUv;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl

THREE.ShaderChunk[ 'uv_pars_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl

THREE.ShaderChunk[ 'uv_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl

THREE.ShaderChunk[ 'worldpos_vertex'] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n	#ifdef USE_SKINNING\n\n		vec4 worldPosition = modelMatrix * skinned;\n\n	#else\n\n		vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/UniformsUtils.js

/**
 * Uniform Utilities
 */

THREE.UniformsUtils = {

    merge: function ( uniforms ) {

        var merged = {};

        for ( var u = 0; u < uniforms.length; u ++ ) {

            var tmp = this.clone( uniforms[ u ] );

            for ( var p in tmp ) {

                merged[ p ] = tmp[ p ];

            }

        }

        return merged;

    },

    clone: function ( uniforms_src ) {

        var uniforms_dst = {};

        for ( var u in uniforms_src ) {

            uniforms_dst[ u ] = {};

            for ( var p in uniforms_src[ u ] ) {

                var parameter_src = uniforms_src[ u ][ p ];

                if ( parameter_src instanceof THREE.Color ||
                    parameter_src instanceof THREE.Vector2 ||
                    parameter_src instanceof THREE.Vector3 ||
                    parameter_src instanceof THREE.Vector4 ||
                    parameter_src instanceof THREE.Matrix3 ||
                    parameter_src instanceof THREE.Matrix4 ||
                    parameter_src instanceof THREE.Texture ) {

                    uniforms_dst[ u ][ p ] = parameter_src.clone();

                } else if ( Array.isArray( parameter_src ) ) {

                    uniforms_dst[ u ][ p ] = parameter_src.slice();

                } else {

                    uniforms_dst[ u ][ p ] = parameter_src;

                }

            }

        }

        return uniforms_dst;

    }

};

// File:src/renderers/shaders/UniformsLib.js

/**
 * Uniforms library for shared webgl shaders
 */

THREE.UniformsLib = {

    common: {

        "diffuse" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
        "opacity" : { type: "f", value: 1.0 },

        "map" : { type: "t", value: null },
        "offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

        "specularMap" : { type: "t", value: null },
        "alphaMap" : { type: "t", value: null },

        "envMap" : { type: "t", value: null },
        "flipEnvMap" : { type: "f", value: - 1 },
        "reflectivity" : { type: "f", value: 1.0 },
        "refractionRatio" : { type: "f", value: 0.98 }

    },

    aomap: {

        "aoMap" : { type: "t", value: null },
        "aoMapIntensity" : { type: "f", value: 1 },

    },

    lightmap: {

        "lightMap" : { type: "t", value: null },
        "lightMapIntensity" : { type: "f", value: 1 },

    },

    emissivemap: {

        "emissiveMap" : { type: "t", value: null },

    },

    bumpmap: {

        "bumpMap" : { type: "t", value: null },
        "bumpScale" : { type: "f", value: 1 }

    },

    normalmap: {

        "normalMap" : { type: "t", value: null },
        "normalScale" : { type: "v2", value: new THREE.Vector2( 1, 1 ) }

    },

    displacementmap: {

        "displacementMap" : { type: "t", value: null },
        "displacementScale" : { type: "f", value: 1 },
        "displacementBias" : { type: "f", value: 0 }

    },

    fog : {

        "fogDensity" : { type: "f", value: 0.00025 },
        "fogNear" : { type: "f", value: 1 },
        "fogFar" : { type: "f", value: 2000 },
        "fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

    },

    lights: {

        "ambientLightColor" : { type: "fv", value: [] },

        "directionalLightDirection" : { type: "fv", value: [] },
        "directionalLightColor" : { type: "fv", value: [] },

        "hemisphereLightDirection" : { type: "fv", value: [] },
        "hemisphereLightSkyColor" : { type: "fv", value: [] },
        "hemisphereLightGroundColor" : { type: "fv", value: [] },

        "pointLightColor" : { type: "fv", value: [] },
        "pointLightPosition" : { type: "fv", value: [] },
        "pointLightDistance" : { type: "fv1", value: [] },
        "pointLightDecay" : { type: "fv1", value: [] },

        "spotLightColor" : { type: "fv", value: [] },
        "spotLightPosition" : { type: "fv", value: [] },
        "spotLightDirection" : { type: "fv", value: [] },
        "spotLightDistance" : { type: "fv1", value: [] },
        "spotLightAngleCos" : { type: "fv1", value: [] },
        "spotLightExponent" : { type: "fv1", value: [] },
        "spotLightDecay" : { type: "fv1", value: [] }

    },

    points: {

        "psColor" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
        "opacity" : { type: "f", value: 1.0 },
        "size" : { type: "f", value: 1.0 },
        "scale" : { type: "f", value: 1.0 },
        "map" : { type: "t", value: null },
        "offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

        "fogDensity" : { type: "f", value: 0.00025 },
        "fogNear" : { type: "f", value: 1 },
        "fogFar" : { type: "f", value: 2000 },
        "fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

    },

    shadowmap: {

        "shadowMap": { type: "tv", value: [] },
        "shadowMapSize": { type: "v2v", value: [] },

        "shadowBias" : { type: "fv1", value: [] },
        "shadowDarkness": { type: "fv1", value: [] },

        "shadowMatrix" : { type: "m4v", value: [] }

    }

};

// File:src/renderers/shaders/ShaderLib.js

/**
 * Webgl Shader Library for three.js
 *
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */


THREE.ShaderLib = {

    'basic': {

        uniforms: THREE.UniformsUtils.merge( [

            THREE.UniformsLib[ "common" ],
            THREE.UniformsLib[ "aomap" ],
            THREE.UniformsLib[ "fog" ],
            THREE.UniformsLib[ "shadowmap" ]

        ] ),

        vertexShader: [

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "uv_pars_vertex" ],
            THREE.ShaderChunk[ "uv2_pars_vertex" ],
            THREE.ShaderChunk[ "envmap_pars_vertex" ],
            THREE.ShaderChunk[ "color_pars_vertex" ],
            THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
            THREE.ShaderChunk[ "skinning_pars_vertex" ],
            THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "uv_vertex" ],
            THREE.ShaderChunk[ "uv2_vertex" ],
            THREE.ShaderChunk[ "color_vertex" ],
            THREE.ShaderChunk[ "skinbase_vertex" ],

            "	#ifdef USE_ENVMAP",

            THREE.ShaderChunk[ "beginnormal_vertex" ],
            THREE.ShaderChunk[ "morphnormal_vertex" ],
            THREE.ShaderChunk[ "skinnormal_vertex" ],
            THREE.ShaderChunk[ "defaultnormal_vertex" ],

            "	#endif",

            THREE.ShaderChunk[ "begin_vertex" ],
            THREE.ShaderChunk[ "morphtarget_vertex" ],
            THREE.ShaderChunk[ "skinning_vertex" ],
            THREE.ShaderChunk[ "project_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            THREE.ShaderChunk[ "worldpos_vertex" ],
            THREE.ShaderChunk[ "envmap_vertex" ],
            THREE.ShaderChunk[ "shadowmap_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform vec3 diffuse;",
            "uniform float opacity;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_fragment" ],
            THREE.ShaderChunk[ "uv_pars_fragment" ],
            THREE.ShaderChunk[ "uv2_pars_fragment" ],
            THREE.ShaderChunk[ "map_pars_fragment" ],
            THREE.ShaderChunk[ "alphamap_pars_fragment" ],
            THREE.ShaderChunk[ "aomap_pars_fragment" ],
            THREE.ShaderChunk[ "envmap_pars_fragment" ],
            THREE.ShaderChunk[ "fog_pars_fragment" ],
            THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
            THREE.ShaderChunk[ "specularmap_pars_fragment" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	vec3 outgoingLight = vec3( 0.0 );",
            "	vec4 diffuseColor = vec4( diffuse, opacity );",
            "	vec3 totalAmbientLight = vec3( 1.0 );", // hardwired
            "	vec3 shadowMask = vec3( 1.0 );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],
            THREE.ShaderChunk[ "map_fragment" ],
            THREE.ShaderChunk[ "color_fragment" ],
            THREE.ShaderChunk[ "alphamap_fragment" ],
            THREE.ShaderChunk[ "alphatest_fragment" ],
            THREE.ShaderChunk[ "specularmap_fragment" ],
            THREE.ShaderChunk[ "aomap_fragment" ],
            THREE.ShaderChunk[ "shadowmap_fragment" ],

            "	outgoingLight = diffuseColor.rgb * totalAmbientLight * shadowMask;",

            THREE.ShaderChunk[ "envmap_fragment" ],

            THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

            THREE.ShaderChunk[ "fog_fragment" ],

            "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

            "}"

        ].join( "\n" )

    },

    'lambert': {

        uniforms: THREE.UniformsUtils.merge( [

            THREE.UniformsLib[ "common" ],
            THREE.UniformsLib[ "fog" ],
            THREE.UniformsLib[ "lights" ],
            THREE.UniformsLib[ "shadowmap" ],

            {
                "emissive" : { type: "c", value: new THREE.Color( 0x000000 ) }
            }

        ] ),

        vertexShader: [

            "#define LAMBERT",

            "varying vec3 vLightFront;",

            "#ifdef DOUBLE_SIDED",

            "	varying vec3 vLightBack;",

            "#endif",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "uv_pars_vertex" ],
            THREE.ShaderChunk[ "uv2_pars_vertex" ],
            THREE.ShaderChunk[ "envmap_pars_vertex" ],
            THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
            THREE.ShaderChunk[ "color_pars_vertex" ],
            THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
            THREE.ShaderChunk[ "skinning_pars_vertex" ],
            THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "uv_vertex" ],
            THREE.ShaderChunk[ "uv2_vertex" ],
            THREE.ShaderChunk[ "color_vertex" ],

            THREE.ShaderChunk[ "beginnormal_vertex" ],
            THREE.ShaderChunk[ "morphnormal_vertex" ],
            THREE.ShaderChunk[ "skinbase_vertex" ],
            THREE.ShaderChunk[ "skinnormal_vertex" ],
            THREE.ShaderChunk[ "defaultnormal_vertex" ],

            THREE.ShaderChunk[ "begin_vertex" ],
            THREE.ShaderChunk[ "morphtarget_vertex" ],
            THREE.ShaderChunk[ "skinning_vertex" ],
            THREE.ShaderChunk[ "project_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            THREE.ShaderChunk[ "worldpos_vertex" ],
            THREE.ShaderChunk[ "envmap_vertex" ],
            THREE.ShaderChunk[ "lights_lambert_vertex" ],
            THREE.ShaderChunk[ "shadowmap_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform vec3 diffuse;",
            "uniform vec3 emissive;",
            "uniform float opacity;",

            "uniform vec3 ambientLightColor;",

            "varying vec3 vLightFront;",

            "#ifdef DOUBLE_SIDED",

            "	varying vec3 vLightBack;",

            "#endif",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_fragment" ],
            THREE.ShaderChunk[ "uv_pars_fragment" ],
            THREE.ShaderChunk[ "uv2_pars_fragment" ],
            THREE.ShaderChunk[ "map_pars_fragment" ],
            THREE.ShaderChunk[ "alphamap_pars_fragment" ],
            THREE.ShaderChunk[ "envmap_pars_fragment" ],
            THREE.ShaderChunk[ "fog_pars_fragment" ],
            THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
            THREE.ShaderChunk[ "specularmap_pars_fragment" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	vec3 outgoingLight = vec3( 0.0 );",	// outgoing light does not have an alpha, the surface does
            "	vec4 diffuseColor = vec4( diffuse, opacity );",
            "	vec3 totalAmbientLight = ambientLightColor;",
            "	vec3 shadowMask = vec3( 1.0 );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],
            THREE.ShaderChunk[ "map_fragment" ],
            THREE.ShaderChunk[ "color_fragment" ],
            THREE.ShaderChunk[ "alphamap_fragment" ],
            THREE.ShaderChunk[ "alphatest_fragment" ],
            THREE.ShaderChunk[ "specularmap_fragment" ],
            THREE.ShaderChunk[ "shadowmap_fragment" ],

            "	#ifdef DOUBLE_SIDED",

            "		if ( gl_FrontFacing )",
            "			outgoingLight += diffuseColor.rgb * ( vLightFront * shadowMask + totalAmbientLight ) + emissive;",
            "		else",
            "			outgoingLight += diffuseColor.rgb * ( vLightBack * shadowMask + totalAmbientLight ) + emissive;",

            "	#else",

            "		outgoingLight += diffuseColor.rgb * ( vLightFront * shadowMask + totalAmbientLight ) + emissive;",

            "	#endif",

            THREE.ShaderChunk[ "envmap_fragment" ],

            THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

            THREE.ShaderChunk[ "fog_fragment" ],

            "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

            "}"

        ].join( "\n" )

    },

    'phong': {

        uniforms: THREE.UniformsUtils.merge( [

            THREE.UniformsLib[ "common" ],
            THREE.UniformsLib[ "aomap" ],
            THREE.UniformsLib[ "lightmap" ],
            THREE.UniformsLib[ "emissivemap" ],
            THREE.UniformsLib[ "bumpmap" ],
            THREE.UniformsLib[ "normalmap" ],
            THREE.UniformsLib[ "displacementmap" ],
            THREE.UniformsLib[ "fog" ],
            THREE.UniformsLib[ "lights" ],
            THREE.UniformsLib[ "shadowmap" ],

            {
                "emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
                "specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
                "shininess": { type: "f", value: 30 }
            }

        ] ),

        vertexShader: [

            "#define PHONG",

            "varying vec3 vViewPosition;",

            "#ifndef FLAT_SHADED",

            "	varying vec3 vNormal;",

            "#endif",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "uv_pars_vertex" ],
            THREE.ShaderChunk[ "uv2_pars_vertex" ],
            THREE.ShaderChunk[ "displacementmap_pars_vertex" ],
            THREE.ShaderChunk[ "envmap_pars_vertex" ],
            THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
            THREE.ShaderChunk[ "color_pars_vertex" ],
            THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
            THREE.ShaderChunk[ "skinning_pars_vertex" ],
            THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "uv_vertex" ],
            THREE.ShaderChunk[ "uv2_vertex" ],
            THREE.ShaderChunk[ "color_vertex" ],

            THREE.ShaderChunk[ "beginnormal_vertex" ],
            THREE.ShaderChunk[ "morphnormal_vertex" ],
            THREE.ShaderChunk[ "skinbase_vertex" ],
            THREE.ShaderChunk[ "skinnormal_vertex" ],
            THREE.ShaderChunk[ "defaultnormal_vertex" ],

            "#ifndef FLAT_SHADED", // Normal computed with derivatives when FLAT_SHADED

            "	vNormal = normalize( transformedNormal );",

            "#endif",

            THREE.ShaderChunk[ "begin_vertex" ],
            THREE.ShaderChunk[ "displacementmap_vertex" ],
            THREE.ShaderChunk[ "morphtarget_vertex" ],
            THREE.ShaderChunk[ "skinning_vertex" ],
            THREE.ShaderChunk[ "project_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "	vViewPosition = - mvPosition.xyz;",

            THREE.ShaderChunk[ "worldpos_vertex" ],
            THREE.ShaderChunk[ "envmap_vertex" ],
            THREE.ShaderChunk[ "lights_phong_vertex" ],
            THREE.ShaderChunk[ "shadowmap_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "#define PHONG",

            "uniform vec3 diffuse;",
            "uniform vec3 emissive;",
            "uniform vec3 specular;",
            "uniform float shininess;",
            "uniform float opacity;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_fragment" ],
            THREE.ShaderChunk[ "uv_pars_fragment" ],
            THREE.ShaderChunk[ "uv2_pars_fragment" ],
            THREE.ShaderChunk[ "map_pars_fragment" ],
            THREE.ShaderChunk[ "alphamap_pars_fragment" ],
            THREE.ShaderChunk[ "aomap_pars_fragment" ],
            THREE.ShaderChunk[ "lightmap_pars_fragment" ],
            THREE.ShaderChunk[ "emissivemap_pars_fragment" ],
            THREE.ShaderChunk[ "envmap_pars_fragment" ],
            THREE.ShaderChunk[ "fog_pars_fragment" ],
            THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
            THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
            THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
            THREE.ShaderChunk[ "normalmap_pars_fragment" ],
            THREE.ShaderChunk[ "specularmap_pars_fragment" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	vec3 outgoingLight = vec3( 0.0 );",
            "	vec4 diffuseColor = vec4( diffuse, opacity );",
            "	vec3 totalAmbientLight = ambientLightColor;",
            "	vec3 totalEmissiveLight = emissive;",
            "	vec3 shadowMask = vec3( 1.0 );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],
            THREE.ShaderChunk[ "map_fragment" ],
            THREE.ShaderChunk[ "color_fragment" ],
            THREE.ShaderChunk[ "alphamap_fragment" ],
            THREE.ShaderChunk[ "alphatest_fragment" ],
            THREE.ShaderChunk[ "specularmap_fragment" ],
            THREE.ShaderChunk[ "normal_phong_fragment" ],
            THREE.ShaderChunk[ "lightmap_fragment" ],
            THREE.ShaderChunk[ "hemilight_fragment" ],
            THREE.ShaderChunk[ "aomap_fragment" ],
            THREE.ShaderChunk[ "emissivemap_fragment" ],

            THREE.ShaderChunk[ "lights_phong_fragment" ],
            THREE.ShaderChunk[ "shadowmap_fragment" ],

            "totalDiffuseLight *= shadowMask;",
            "totalSpecularLight *= shadowMask;",

            "#ifdef METAL",

            "	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) * specular + totalSpecularLight + totalEmissiveLight;",

            "#else",

            "	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) + totalSpecularLight + totalEmissiveLight;",

            "#endif",

            THREE.ShaderChunk[ "envmap_fragment" ],

            THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

            THREE.ShaderChunk[ "fog_fragment" ],

            "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

            "}"

        ].join( "\n" )

    },

    'points': {

        uniforms: THREE.UniformsUtils.merge( [

            THREE.UniformsLib[ "points" ],
            THREE.UniformsLib[ "shadowmap" ]

        ] ),

        vertexShader: [

            "uniform float size;",
            "uniform float scale;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_vertex" ],
            THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "color_vertex" ],

            "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

            "	#ifdef USE_SIZEATTENUATION",
            "		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
            "	#else",
            "		gl_PointSize = size;",
            "	#endif",

            "	gl_Position = projectionMatrix * mvPosition;",

            THREE.ShaderChunk[ "logdepthbuf_vertex" ],
            THREE.ShaderChunk[ "worldpos_vertex" ],
            THREE.ShaderChunk[ "shadowmap_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform vec3 psColor;",
            "uniform float opacity;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_fragment" ],
            THREE.ShaderChunk[ "map_particle_pars_fragment" ],
            THREE.ShaderChunk[ "fog_pars_fragment" ],
            THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	vec3 outgoingLight = vec3( 0.0 );",
            "	vec4 diffuseColor = vec4( psColor, opacity );",
            "	vec3 shadowMask = vec3( 1.0 );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],
            THREE.ShaderChunk[ "map_particle_fragment" ],
            THREE.ShaderChunk[ "color_fragment" ],
            THREE.ShaderChunk[ "alphatest_fragment" ],
            THREE.ShaderChunk[ "shadowmap_fragment" ],

            "	outgoingLight = diffuseColor.rgb * shadowMask;",

            THREE.ShaderChunk[ "fog_fragment" ],

            "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

            "}"

        ].join( "\n" )

    },

    'dashed': {

        uniforms: THREE.UniformsUtils.merge( [

            THREE.UniformsLib[ "common" ],
            THREE.UniformsLib[ "fog" ],

            {
                "scale"    : { type: "f", value: 1 },
                "dashSize" : { type: "f", value: 1 },
                "totalSize": { type: "f", value: 2 }
            }

        ] ),

        vertexShader: [

            "uniform float scale;",
            "attribute float lineDistance;",

            "varying float vLineDistance;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "color_vertex" ],

            "	vLineDistance = scale * lineDistance;",

            "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
            "	gl_Position = projectionMatrix * mvPosition;",

            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform vec3 diffuse;",
            "uniform float opacity;",

            "uniform float dashSize;",
            "uniform float totalSize;",

            "varying float vLineDistance;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "color_pars_fragment" ],
            THREE.ShaderChunk[ "fog_pars_fragment" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	if ( mod( vLineDistance, totalSize ) > dashSize ) {",

            "		discard;",

            "	}",

            "	vec3 outgoingLight = vec3( 0.0 );",
            "	vec4 diffuseColor = vec4( diffuse, opacity );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],
            THREE.ShaderChunk[ "color_fragment" ],

            "	outgoingLight = diffuseColor.rgb;", // simple shader

            THREE.ShaderChunk[ "fog_fragment" ],

            "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

            "}"

        ].join( "\n" )

    },

    'depth': {

        uniforms: {

            "mNear": { type: "f", value: 1.0 },
            "mFar" : { type: "f", value: 2000.0 },
            "opacity" : { type: "f", value: 1.0 }

        },

        vertexShader: [

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "begin_vertex" ],
            THREE.ShaderChunk[ "morphtarget_vertex" ],
            THREE.ShaderChunk[ "project_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform float mNear;",
            "uniform float mFar;",
            "uniform float opacity;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],

            "	#ifdef USE_LOGDEPTHBUF_EXT",

            "		float depth = gl_FragDepthEXT / gl_FragCoord.w;",

            "	#else",

            "		float depth = gl_FragCoord.z / gl_FragCoord.w;",

            "	#endif",

            "	float color = 1.0 - smoothstep( mNear, mFar, depth );",
            "	gl_FragColor = vec4( vec3( color ), opacity );",

            "}"

        ].join( "\n" )

    },

    'normal': {

        uniforms: {

            "opacity" : { type: "f", value: 1.0 }

        },

        vertexShader: [

            "varying vec3 vNormal;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            "	vNormal = normalize( normalMatrix * normal );",

            THREE.ShaderChunk[ "begin_vertex" ],
            THREE.ShaderChunk[ "morphtarget_vertex" ],
            THREE.ShaderChunk[ "project_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform float opacity;",
            "varying vec3 vNormal;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],

            "}"

        ].join( "\n" )

    },

    /* -------------------------------------------------------------------------
     //	Cube map shader
     ------------------------------------------------------------------------- */

    'cube': {

        uniforms: { "tCube": { type: "t", value: null },
            "tFlip": { type: "f", value: - 1 } },

        vertexShader: [

            "varying vec3 vWorldPosition;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            "	vWorldPosition = transformDirection( position, modelMatrix );",

            "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform samplerCube tCube;",
            "uniform float tFlip;",

            "varying vec3 vWorldPosition;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],

            "}"

        ].join( "\n" )

    },

    /* -------------------------------------------------------------------------
     //	Cube map shader
     ------------------------------------------------------------------------- */

    'equirect': {

        uniforms: { "tEquirect": { type: "t", value: null },
            "tFlip": { type: "f", value: - 1 } },

        vertexShader: [

            "varying vec3 vWorldPosition;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            "	vWorldPosition = transformDirection( position, modelMatrix );",

            "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform sampler2D tEquirect;",
            "uniform float tFlip;",

            "varying vec3 vWorldPosition;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "void main() {",

            // "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
            "vec3 direction = normalize( vWorldPosition );",
            "vec2 sampleUV;",
            "sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );",
            "sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;",
            "gl_FragColor = texture2D( tEquirect, sampleUV );",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],

            "}"

        ].join( "\n" )

    },

    /* Depth encoding into RGBA texture
     *
     * based on SpiderGL shadow map example
     * http://spidergl.org/example.php?id=6
     *
     * originally from
     * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
     *
     * see also
     * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
     */

    'depthRGBA': {

        uniforms: {},

        vertexShader: [

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
            THREE.ShaderChunk[ "skinning_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "skinbase_vertex" ],

            THREE.ShaderChunk[ "begin_vertex" ],
            THREE.ShaderChunk[ "morphtarget_vertex" ],
            THREE.ShaderChunk[ "skinning_vertex" ],
            THREE.ShaderChunk[ "project_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

            "}"

        ].join( "\n" ),

        fragmentShader: [

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "vec4 pack_depth( const in float depth ) {",

            "	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
            "	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
            "	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", // "	vec4 res = fract( depth * bit_shift );",
            "	res -= res.xxyz * bit_mask;",
            "	return res;",

            "}",

            "void main() {",

            THREE.ShaderChunk[ "logdepthbuf_fragment" ],

            "	#ifdef USE_LOGDEPTHBUF_EXT",

            "		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );",

            "	#else",

            "		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",

            "	#endif",

            //"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
            //"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
            //"gl_FragData[ 0 ] = pack_depth( z );",
            //"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",

            "}"

        ].join( "\n" )

    },


    'distanceRGBA': {

        uniforms: {

            "lightPos": { type: "v3", value: new THREE.Vector3( 0, 0, 0 ) }

        },

        vertexShader: [

            "varying vec4 vWorldPosition;",

            THREE.ShaderChunk[ "common" ],
            THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
            THREE.ShaderChunk[ "skinning_pars_vertex" ],

            "void main() {",

            THREE.ShaderChunk[ "skinbase_vertex" ],
            THREE.ShaderChunk[ "begin_vertex" ],
            THREE.ShaderChunk[ "morphtarget_vertex" ],
            THREE.ShaderChunk[ "skinning_vertex" ],
            THREE.ShaderChunk[ "project_vertex" ],
            THREE.ShaderChunk[ "worldpos_vertex" ],

            "vWorldPosition = worldPosition;",

            "}"

        ].join( "\n" ),

        fragmentShader: [

            "uniform vec3 lightPos;",
            "varying vec4 vWorldPosition;",

            THREE.ShaderChunk[ "common" ],

            "vec4 pack1K ( float depth ) {",

            "   depth /= 1000.0;",
            "   const vec4 bitSh = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
            "	const vec4 bitMsk = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
            "	vec4 res = fract( depth * bitSh );",
            "	res -= res.xxyz * bitMsk;",
            "	return res; ",

            "}",

            "float unpack1K ( vec4 color ) {",

            "	const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
            "	return dot( color, bitSh ) * 1000.0;",

            "}",

            "void main () {",

            "	gl_FragColor = pack1K( length( vWorldPosition.xyz - lightPos.xyz ) );",

            "}"

        ].join( "\n" )

    }

};

// File:src/renderers/WebGLRenderer.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.WebGLRenderer = function ( parameters ) {

    console.log( 'THREE.WebGLRenderer', THREE.REVISION );

    parameters = parameters || {};

    var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),
        _context = parameters.context !== undefined ? parameters.context : null,

        _width = _canvas.width,
        _height = _canvas.height,

        pixelRatio = 1,

        _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
        _depth = parameters.depth !== undefined ? parameters.depth : true,
        _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
        _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
        _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
        _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,

        _clearColor = new THREE.Color( 0x000000 ),
        _clearAlpha = 0;

    var lights = [];

    var opaqueObjects = [];
    var opaqueObjectsLastIndex = - 1;
    var transparentObjects = [];
    var transparentObjectsLastIndex = - 1;

    var morphInfluences = new Float32Array( 8 );


    var sprites = [];
    var lensFlares = [];

    // public properties

    this.domElement = _canvas;
    this.context = null;

    // clearing

    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;

    // scene graph

    this.sortObjects = true;

    // physically based shading

    this.gammaFactor = 2.0;	// for backwards compatibility
    this.gammaInput = false;
    this.gammaOutput = false;

    // morphs

    this.maxMorphTargets = 8;
    this.maxMorphNormals = 4;

    // flags

    this.autoScaleCubemaps = true;

    // internal properties

    var _this = this,

    // internal state cache

        _currentProgram = null,
        _currentFramebuffer = null,
        _currentMaterialId = - 1,
        _currentGeometryProgram = '',
        _currentCamera = null,

        _usedTextureUnits = 0,

        _viewportX = 0,
        _viewportY = 0,
        _viewportWidth = _canvas.width,
        _viewportHeight = _canvas.height,
        _currentWidth = 0,
        _currentHeight = 0,

    // frustum

        _frustum = new THREE.Frustum(),

    // camera matrices cache

        _projScreenMatrix = new THREE.Matrix4(),

        _vector3 = new THREE.Vector3(),

    // light arrays cache

        _direction = new THREE.Vector3(),

        _lightsNeedUpdate = true,

        _lights = {

            ambient: [ 0, 0, 0 ],
            directional: { length: 0, colors: [], positions: [] },
            point: { length: 0, colors: [], positions: [], distances: [], decays: [] },
            spot: { length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: [], decays: [] },
            hemi: { length: 0, skyColors: [], groundColors: [], positions: [] }

        },

    // info

        _infoMemory = {

            geometries: 0,
            textures: 0

        },

        _infoRender = {

            calls: 0,
            vertices: 0,
            faces: 0,
            points: 0

        };

    this.info = {

        render: _infoRender,
        memory: _infoMemory,
        programs: null

    };


    // initialize

    var _gl;

    try {

        var attributes = {
            alpha: _alpha,
            depth: _depth,
            stencil: _stencil,
            antialias: _antialias,
            premultipliedAlpha: _premultipliedAlpha,
            preserveDrawingBuffer: _preserveDrawingBuffer
        };

        _gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

        if ( _gl === null ) {

            if ( _canvas.getContext( 'webgl' ) !== null ) {

                throw 'Error creating WebGL context with your selected attributes.';

            } else {

                throw 'Error creating WebGL context.';

            }

        }

        _canvas.addEventListener( 'webglcontextlost', onContextLost, false );

    } catch ( error ) {

        console.error( 'THREE.WebGLRenderer: ' + error );

    }

    var extensions = new THREE.WebGLExtensions( _gl );

    extensions.get( 'OES_texture_float' );
    extensions.get( 'OES_texture_float_linear' );
    extensions.get( 'OES_texture_half_float' );
    extensions.get( 'OES_texture_half_float_linear' );
    extensions.get( 'OES_standard_derivatives' );
    extensions.get( 'ANGLE_instanced_arrays' );

    if ( extensions.get( 'OES_element_index_uint' ) ) {

        THREE.BufferGeometry.MaxIndex = 4294967296;

    }

    var capabilities = new THREE.WebGLCapabilities( _gl, extensions, parameters );

    var state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );
    var properties = new THREE.WebGLProperties();
    var objects = new THREE.WebGLObjects( _gl, properties, this.info );
    var programCache = new THREE.WebGLPrograms( this, capabilities );

    this.info.programs = programCache.programs;

    var bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );
    var indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );

    //

    function glClearColor( r, g, b, a ) {

        if ( _premultipliedAlpha === true ) {

            r *= a; g *= a; b *= a;

        }

        _gl.clearColor( r, g, b, a );

    }

    function setDefaultGLState() {

        state.init();

        _gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

        glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

    }

    function resetGLState() {

        _currentProgram = null;
        _currentCamera = null;

        _currentGeometryProgram = '';
        _currentMaterialId = - 1;

        _lightsNeedUpdate = true;

        state.reset();

    }

    setDefaultGLState();

    this.context = _gl;
    this.capabilities = capabilities;
    this.extensions = extensions;
    this.state = state;

    // shadow map

    var shadowMap = new THREE.WebGLShadowMap( this, lights, objects );

    this.shadowMap = shadowMap;


    // Plugins

    var spritePlugin = new THREE.SpritePlugin( this, sprites );
    var lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );

    // API

    this.getContext = function () {

        return _gl;

    };

    this.getContextAttributes = function () {

        return _gl.getContextAttributes();

    };

    this.forceContextLoss = function () {

        extensions.get( 'WEBGL_lose_context' ).loseContext();

    };

    this.getMaxAnisotropy = ( function () {

        var value;

        return function getMaxAnisotropy() {

            if ( value !== undefined ) return value;

            var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

            if ( extension !== null ) {

                value = _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

            } else {

                value = 0;

            }

            return value;

        }

    } )();

    this.getPrecision = function () {

        return capabilities.precision;

    };

    this.getPixelRatio = function () {

        return pixelRatio;

    };

    this.setPixelRatio = function ( value ) {

        if ( value !== undefined ) pixelRatio = value;

    };

    this.getSize = function () {

        return {
            width: _width,
            height: _height
        };

    };

    this.setSize = function ( width, height, updateStyle ) {

        _width = width;
        _height = height;

        _canvas.width = width * pixelRatio;
        _canvas.height = height * pixelRatio;

        if ( updateStyle !== false ) {

            _canvas.style.width = width + 'px';
            _canvas.style.height = height + 'px';

        }

        this.setViewport( 0, 0, width, height );

    };

    this.setViewport = function ( x, y, width, height ) {

        _viewportX = x * pixelRatio;
        _viewportY = y * pixelRatio;

        _viewportWidth = width * pixelRatio;
        _viewportHeight = height * pixelRatio;

        _gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

    };

    this.getViewport = function ( dimensions ) {

        dimensions.x = _viewportX / pixelRatio;
        dimensions.y = _viewportY / pixelRatio;

        dimensions.z = _viewportWidth / pixelRatio;
        dimensions.w = _viewportHeight / pixelRatio;

    };

    this.setScissor = function ( x, y, width, height ) {

        _gl.scissor(
            x * pixelRatio,
            y * pixelRatio,
            width * pixelRatio,
            height * pixelRatio
        );

    };

    this.enableScissorTest = function ( boolean ) {

        state.setScissorTest( boolean );

    };

    // Clearing

    this.getClearColor = function () {

        return _clearColor;

    };

    this.setClearColor = function ( color, alpha ) {

        _clearColor.set( color );

        _clearAlpha = alpha !== undefined ? alpha : 1;

        glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

    };

    this.getClearAlpha = function () {

        return _clearAlpha;

    };

    this.setClearAlpha = function ( alpha ) {

        _clearAlpha = alpha;

        glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

    };

    this.clear = function ( color, depth, stencil ) {

        var bits = 0;

        if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
        if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
        if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

        _gl.clear( bits );

    };

    this.clearColor = function () {

        _gl.clear( _gl.COLOR_BUFFER_BIT );

    };

    this.clearDepth = function () {

        _gl.clear( _gl.DEPTH_BUFFER_BIT );

    };

    this.clearStencil = function () {

        _gl.clear( _gl.STENCIL_BUFFER_BIT );

    };

    this.clearTarget = function ( renderTarget, color, depth, stencil ) {

        this.setRenderTarget( renderTarget );
        this.clear( color, depth, stencil );

    };

    // Reset

    this.resetGLState = resetGLState;

    this.dispose = function() {

        _canvas.removeEventListener( 'webglcontextlost', onContextLost, false );

    };

    // Events

    function onContextLost( event ) {

        event.preventDefault();

        resetGLState();
        setDefaultGLState();

        properties.clear();

    };

    function onTextureDispose( event ) {

        var texture = event.target;

        texture.removeEventListener( 'dispose', onTextureDispose );

        deallocateTexture( texture );

        _infoMemory.textures --;


    }

    function onRenderTargetDispose( event ) {

        var renderTarget = event.target;

        renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

        deallocateRenderTarget( renderTarget );

        _infoMemory.textures --;

    }

    function onMaterialDispose( event ) {

        var material = event.target;

        material.removeEventListener( 'dispose', onMaterialDispose );

        deallocateMaterial( material );

    }

    // Buffer deallocation

    function deallocateTexture( texture ) {

        var textureProperties = properties.get( texture );

        if ( texture.image && textureProperties.__image__webglTextureCube ) {

            // cube texture

            _gl.deleteTexture( textureProperties.__image__webglTextureCube );

        } else {

            // 2D texture

            if ( textureProperties.__webglInit === undefined ) return;

            _gl.deleteTexture( textureProperties.__webglTexture );

        }

        // remove all webgl properties
        properties.delete( texture );

    }

    function deallocateRenderTarget( renderTarget ) {

        var renderTargetProperties = properties.get( renderTarget );
        var textureProperties = properties.get( renderTarget.texture );

        if ( ! renderTarget || textureProperties.__webglTexture === undefined ) return;

        _gl.deleteTexture( textureProperties.__webglTexture );

        if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

            for ( var i = 0; i < 6; i ++ ) {

                _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
                _gl.deleteRenderbuffer( renderTargetProperties.__webglRenderbuffer[ i ] );

            }

        } else {

            _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
            _gl.deleteRenderbuffer( renderTargetProperties.__webglRenderbuffer );

        }

        properties.delete( renderTarget.texture );
        properties.delete( renderTarget );

    }

    function deallocateMaterial( material ) {

        releaseMaterialProgramReference( material );

        properties.delete( material );

    }


    function releaseMaterialProgramReference( material ) {

        var programInfo = properties.get( material ).program;

        material.program = undefined;

        if ( programInfo !== undefined ) {

            programCache.releaseProgram( programInfo );

        }

    }

    // Buffer rendering

    this.renderBufferImmediate = function ( object, program, material ) {

        state.initAttributes();

        var buffers = properties.get( object );

        if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
        if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
        if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
        if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

        var attributes = program.getAttributes();

        if ( object.hasPositions ) {

            _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
            _gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

            state.enableAttribute( attributes.position );
            _gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

        }

        if ( object.hasNormals ) {

            _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );

            if ( material.type !== 'MeshPhongMaterial' && material.shading === THREE.FlatShading ) {

                for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {

                    var array = object.normalArray;

                    var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
                    var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
                    var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;

                    array[ i + 0 ] = nx;
                    array[ i + 1 ] = ny;
                    array[ i + 2 ] = nz;

                    array[ i + 3 ] = nx;
                    array[ i + 4 ] = ny;
                    array[ i + 5 ] = nz;

                    array[ i + 6 ] = nx;
                    array[ i + 7 ] = ny;
                    array[ i + 8 ] = nz;

                }

            }

            _gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

            state.enableAttribute( attributes.normal );

            _gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

        }

        if ( object.hasUvs && material.map ) {

            _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
            _gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

            state.enableAttribute( attributes.uv );

            _gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

        }

        if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {

            _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
            _gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

            state.enableAttribute( attributes.color );

            _gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

        }

        state.disableUnusedAttributes();

        _gl.drawArrays( _gl.TRIANGLES, 0, object.count );

        object.count = 0;

    };

    this.renderBufferDirect = function ( camera, lights, fog, geometry, material, object, group ) {

        setMaterial( material );

        var program = setProgram( camera, lights, fog, material, object );

        var updateBuffers = false;
        var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;

        if ( geometryProgram !== _currentGeometryProgram ) {

            _currentGeometryProgram = geometryProgram;
            updateBuffers = true;

        }

        // morph targets

        var morphTargetInfluences = object.morphTargetInfluences;

        if ( morphTargetInfluences !== undefined ) {

            var activeInfluences = [];

            for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {

                var influence = morphTargetInfluences[ i ];
                activeInfluences.push( [ influence, i ] );

            }

            activeInfluences.sort( numericalSort );

            if ( activeInfluences.length > 8 ) {

                activeInfluences.length = 8;

            }

            var morphAttributes = geometry.morphAttributes;

            for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {

                var influence = activeInfluences[ i ];
                morphInfluences[ i ] = influence[ 0 ];

                if ( influence[ 0 ] !== 0 ) {

                    var index = influence[ 1 ];

                    if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
                    if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );

                } else {

                    if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
                    if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );

                }

            }

            var uniforms = program.getUniforms();

            if ( uniforms.morphTargetInfluences !== null ) {

                _gl.uniform1fv( uniforms.morphTargetInfluences, morphInfluences );

            }

            updateBuffers = true;

        }

        //

        var index = geometry.index;
        var position = geometry.attributes.position;

        if ( material.wireframe === true ) {

            index = objects.getWireframeAttribute( geometry );

        }

        var renderer;

        if ( index !== null ) {

            renderer = indexedBufferRenderer;
            renderer.setIndex( index );

        } else {

            renderer = bufferRenderer;

        }

        if ( updateBuffers ) {

            setupVertexAttributes( material, program, geometry );

            if ( index !== null ) {

                _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );

            }

        }

        //

        var dataStart = 0;
        var dataCount = Infinity;

        if ( index !== null ) {

            dataCount = index.count

        } else if ( position !== undefined ) {

            dataCount = position.count;

        }

        var rangeStart = geometry.drawRange.start;
        var rangeCount = geometry.drawRange.count;

        var groupStart = group !== null ? group.start : 0;
        var groupCount = group !== null ? group.count : Infinity;

        var drawStart = Math.max( dataStart, rangeStart, groupStart );
        var drawEnd = Math.min( dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

        var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

        //

        if ( object instanceof THREE.Mesh ) {

            if ( material.wireframe === true ) {

                state.setLineWidth( material.wireframeLinewidth * pixelRatio );
                renderer.setMode( _gl.LINES );

            } else {

                renderer.setMode( _gl.TRIANGLES );

            }

            if ( geometry instanceof THREE.InstancedBufferGeometry && geometry.maxInstancedCount > 0 ) {

                renderer.renderInstances( geometry );

            } else {

                renderer.render( drawStart, drawCount );

            }

        } else if ( object instanceof THREE.Line ) {

            var lineWidth = material.linewidth;

            if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

            state.setLineWidth( lineWidth * pixelRatio );

            if ( object instanceof THREE.LineSegments ) {

                renderer.setMode( _gl.LINES );

            } else {

                renderer.setMode( _gl.LINE_STRIP );

            }

            renderer.render( drawStart, drawCount );

        } else if ( object instanceof THREE.Points ) {

            renderer.setMode( _gl.POINTS );
            renderer.render( drawStart, drawCount );

        }

    };

    function setupVertexAttributes( material, program, geometry, startIndex ) {

        var extension;

        if ( geometry instanceof THREE.InstancedBufferGeometry ) {

            extension = extensions.get( 'ANGLE_instanced_arrays' );

            if ( extension === null ) {

                console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
                return;

            }

        }

        if ( startIndex === undefined ) startIndex = 0;

        state.initAttributes();

        var geometryAttributes = geometry.attributes;

        var programAttributes = program.getAttributes();

        var materialDefaultAttributeValues = material.defaultAttributeValues;

        for ( var name in programAttributes ) {

            var programAttribute = programAttributes[ name ];

            if ( programAttribute >= 0 ) {

                var geometryAttribute = geometryAttributes[ name ];

                if ( geometryAttribute !== undefined ) {

                    var size = geometryAttribute.itemSize;
                    var buffer = objects.getAttributeBuffer( geometryAttribute );

                    if ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {

                        var data = geometryAttribute.data;
                        var stride = data.stride;
                        var offset = geometryAttribute.offset;

                        if ( data instanceof THREE.InstancedInterleavedBuffer ) {

                            state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );

                            if ( geometry.maxInstancedCount === undefined ) {

                                geometry.maxInstancedCount = data.meshPerAttribute * data.count;

                            }

                        } else {

                            state.enableAttribute( programAttribute );

                        }

                        _gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
                        _gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );

                    } else {

                        if ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {

                            state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );

                            if ( geometry.maxInstancedCount === undefined ) {

                                geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

                            }

                        } else {

                            state.enableAttribute( programAttribute );

                        }

                        _gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
                        _gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32

                    }

                } else if ( materialDefaultAttributeValues !== undefined ) {

                    var value = materialDefaultAttributeValues[ name ];

                    if ( value !== undefined ) {

                        switch ( value.length ) {

                            case 2:
                                _gl.vertexAttrib2fv( programAttribute, value );
                                break;

                            case 3:
                                _gl.vertexAttrib3fv( programAttribute, value );
                                break;

                            case 4:
                                _gl.vertexAttrib4fv( programAttribute, value );
                                break;

                            default:
                                _gl.vertexAttrib1fv( programAttribute, value );

                        }

                    }

                }

            }

        }

        state.disableUnusedAttributes();

    }

    // Sorting

    function numericalSort ( a, b ) {

        return b[ 0 ] - a[ 0 ];

    }

    function painterSortStable ( a, b ) {

        if ( a.object.renderOrder !== b.object.renderOrder ) {

            return a.object.renderOrder - b.object.renderOrder;

        } else if ( a.material.id !== b.material.id ) {

            return a.material.id - b.material.id;

        } else if ( a.z !== b.z ) {

            return a.z - b.z;

        } else {

            return a.id - b.id;

        }

    }

    function reversePainterSortStable ( a, b ) {

        if ( a.object.renderOrder !== b.object.renderOrder ) {

            return a.object.renderOrder - b.object.renderOrder;

        } if ( a.z !== b.z ) {

            return b.z - a.z;

        } else {

            return a.id - b.id;

        }

    }

    // Rendering

    this.render = function ( scene, camera, renderTarget, forceClear ) {

        if ( camera instanceof THREE.Camera === false ) {

            console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
            return;

        }

        var fog = scene.fog;

        // reset caching for this frame

        _currentGeometryProgram = '';
        _currentMaterialId = - 1;
        _currentCamera = null;
        _lightsNeedUpdate = true;

        // update scene graph

        if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

        // update camera matrices and frustum

        if ( camera.parent === null ) camera.updateMatrixWorld();

        camera.matrixWorldInverse.getInverse( camera.matrixWorld );

        _projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
        _frustum.setFromMatrix( _projScreenMatrix );

        lights.length = 0;

        opaqueObjectsLastIndex = - 1;
        transparentObjectsLastIndex = - 1;

        sprites.length = 0;
        lensFlares.length = 0;

        projectObject( scene, camera );

        opaqueObjects.length = opaqueObjectsLastIndex + 1;
        transparentObjects.length = transparentObjectsLastIndex + 1;

        if ( _this.sortObjects === true ) {

            opaqueObjects.sort( painterSortStable );
            transparentObjects.sort( reversePainterSortStable );

        }

        //

        shadowMap.render( scene );

        //

        _infoRender.calls = 0;
        _infoRender.vertices = 0;
        _infoRender.faces = 0;
        _infoRender.points = 0;

        this.setRenderTarget( renderTarget );

        if ( this.autoClear || forceClear ) {

            this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

        }

        //

        if ( scene.overrideMaterial ) {

            var overrideMaterial = scene.overrideMaterial;

            renderObjects( opaqueObjects, camera, lights, fog, overrideMaterial );
            renderObjects( transparentObjects, camera, lights, fog, overrideMaterial );

        } else {

            // opaque pass (front-to-back order)

            state.setBlending( THREE.NoBlending );
            renderObjects( opaqueObjects, camera, lights, fog );

            // transparent pass (back-to-front order)

            renderObjects( transparentObjects, camera, lights, fog );

        }

        // custom render plugins (post pass)

        spritePlugin.render( scene, camera );
        lensFlarePlugin.render( scene, camera, _currentWidth, _currentHeight );

        // Generate mipmap if we're using any kind of mipmap filtering

        if ( renderTarget ) {

            var texture = renderTarget.texture;
            var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );
            if ( texture.generateMipmaps && isTargetPowerOfTwo && texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {

                updateRenderTargetMipmap( renderTarget );

            }

        }

        // Ensure depth buffer writing is enabled so it can be cleared on next render

        state.setDepthTest( true );
        state.setDepthWrite( true );
        state.setColorWrite( true );

        // _gl.finish();

    };

    function pushRenderItem( object, geometry, material, z, group ) {

        var array, index;

        // allocate the next position in the appropriate array

        if ( material.transparent ) {

            array = transparentObjects;
            index = ++ transparentObjectsLastIndex;

        } else {

            array = opaqueObjects;
            index = ++ opaqueObjectsLastIndex;

        }

        // recycle existing render item or grow the array

        var renderItem = array[ index ];

        if ( renderItem !== undefined ) {

            renderItem.id = object.id;
            renderItem.object = object;
            renderItem.geometry = geometry;
            renderItem.material = material;
            renderItem.z = _vector3.z;
            renderItem.group = group;

        } else {

            renderItem = {
                id: object.id,
                object: object,
                geometry: geometry,
                material: material,
                z: _vector3.z,
                group: group
            };

            // assert( index === array.length );
            array.push( renderItem );

        }

    }

    function projectObject( object, camera ) {

        if ( object.visible === false ) return;

        if ( ( object.channels.mask & camera.channels.mask ) !== 0 ) {

            if ( object instanceof THREE.Light ) {

                lights.push( object );

            } else if ( object instanceof THREE.Sprite ) {

                sprites.push( object );

            } else if ( object instanceof THREE.LensFlare ) {

                lensFlares.push( object );

            } else if ( object instanceof THREE.ImmediateRenderObject ) {

                if ( _this.sortObjects === true ) {

                    _vector3.setFromMatrixPosition( object.matrixWorld );
                    _vector3.applyProjection( _projScreenMatrix );

                }

                pushRenderItem( object, null, object.material, _vector3.z, null );

            } else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {

                if ( object instanceof THREE.SkinnedMesh ) {

                    object.skeleton.update();

                }

                if ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {

                    var material = object.material;

                    if ( material.visible === true ) {

                        if ( _this.sortObjects === true ) {

                            _vector3.setFromMatrixPosition( object.matrixWorld );
                            _vector3.applyProjection( _projScreenMatrix );

                        }

                        var geometry = objects.update( object );

                        if ( material instanceof THREE.MeshFaceMaterial ) {

                            var groups = geometry.groups;
                            var materials = material.materials;

                            for ( var i = 0, l = groups.length; i < l; i ++ ) {

                                var group = groups[ i ];
                                var groupMaterial = materials[ group.materialIndex ];

                                if ( groupMaterial.visible === true ) {

                                    pushRenderItem( object, geometry, groupMaterial, _vector3.z, group );

                                }

                            }

                        } else {

                            pushRenderItem( object, geometry, material, _vector3.z, null );

                        }

                    }

                }

            }

        }

        var children = object.children;

        for ( var i = 0, l = children.length; i < l; i ++ ) {

            projectObject( children[ i ], camera );

        }

    }

    function renderObjects( renderList, camera, lights, fog, overrideMaterial ) {

        for ( var i = 0, l = renderList.length; i < l; i ++ ) {

            var renderItem = renderList[ i ];

            var object = renderItem.object;
            var geometry = renderItem.geometry;
            var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
            var group = renderItem.group;

            object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
            object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

            if ( object instanceof THREE.ImmediateRenderObject ) {

                setMaterial( material );

                var program = setProgram( camera, lights, fog, material, object );

                _currentGeometryProgram = '';

                object.render( function ( object ) {

                    _this.renderBufferImmediate( object, program, material );

                } );

            } else {

                _this.renderBufferDirect( camera, lights, fog, geometry, material, object, group );

            }

        }

    }

    function initMaterial( material, lights, fog, object ) {

        var materialProperties = properties.get( material );

        var parameters = programCache.getParameters( material, lights, fog, object );
        var code = programCache.getProgramCode( material, parameters );

        var program = materialProperties.program;
        var programChange = true;

        if ( program === undefined ) {

            // new material
            material.addEventListener( 'dispose', onMaterialDispose );

        } else if ( program.code !== code ) {

            // changed glsl or parameters
            releaseMaterialProgramReference( material );

        } else if ( parameters.shaderID !== undefined ) {

            // same glsl and uniform list
            return;

        } else {

            // only rebuild uniform list
            programChange = false;

        }

        if ( programChange ) {

            if ( parameters.shaderID ) {

                var shader = THREE.ShaderLib[ parameters.shaderID ];

                materialProperties.__webglShader = {
                    name: material.type,
                    uniforms: THREE.UniformsUtils.clone( shader.uniforms ),
                    vertexShader: shader.vertexShader,
                    fragmentShader: shader.fragmentShader
                };

            } else {

                materialProperties.__webglShader = {
                    name: material.type,
                    uniforms: material.uniforms,
                    vertexShader: material.vertexShader,
                    fragmentShader: material.fragmentShader
                };

            }

            material.__webglShader = materialProperties.__webglShader;

            program = programCache.acquireProgram( material, parameters, code );

            materialProperties.program = program;
            material.program = program;

        }

        var attributes = program.getAttributes();

        if ( material.morphTargets ) {

            material.numSupportedMorphTargets = 0;

            for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

                if ( attributes[ 'morphTarget' + i ] >= 0 ) {

                    material.numSupportedMorphTargets ++;

                }

            }

        }

        if ( material.morphNormals ) {

            material.numSupportedMorphNormals = 0;

            for ( i = 0; i < _this.maxMorphNormals; i ++ ) {

                if ( attributes[ 'morphNormal' + i ] >= 0 ) {

                    material.numSupportedMorphNormals ++;

                }

            }

        }

        materialProperties.uniformsList = [];

        var uniformLocations = materialProperties.program.getUniforms();

        for ( var u in materialProperties.__webglShader.uniforms ) {

            var location = uniformLocations[ u ];

            if ( location ) {

                materialProperties.uniformsList.push( [ materialProperties.__webglShader.uniforms[ u ], location ] );

            }

        }

    }

    function setMaterial( material ) {

        setMaterialFaces( material );

        if ( material.transparent === true ) {

            state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha );

        } else {

            state.setBlending( THREE.NoBlending );

        }

        state.setDepthFunc( material.depthFunc );
        state.setDepthTest( material.depthTest );
        state.setDepthWrite( material.depthWrite );
        state.setColorWrite( material.colorWrite );
        state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

    }

    function setMaterialFaces( material ) {

        material.side !== THREE.DoubleSide ? state.enable( _gl.CULL_FACE ) : state.disable( _gl.CULL_FACE );
        state.setFlipSided( material.side === THREE.BackSide );

    }

    function setProgram( camera, lights, fog, material, object ) {

        _usedTextureUnits = 0;

        var materialProperties = properties.get( material );

        if ( material.needsUpdate || ! materialProperties.program ) {

            initMaterial( material, lights, fog, object );
            material.needsUpdate = false;

        }

        var refreshProgram = false;
        var refreshMaterial = false;
        var refreshLights = false;

        var program = materialProperties.program,
            p_uniforms = program.getUniforms(),
            m_uniforms = materialProperties.__webglShader.uniforms;

        if ( program.id !== _currentProgram ) {

            _gl.useProgram( program.program );
            _currentProgram = program.id;

            refreshProgram = true;
            refreshMaterial = true;
            refreshLights = true;

        }

        if ( material.id !== _currentMaterialId ) {

            if ( _currentMaterialId === - 1 ) refreshLights = true;
            _currentMaterialId = material.id;

            refreshMaterial = true;

        }

        if ( refreshProgram || camera !== _currentCamera ) {

            _gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

            if ( capabilities.logarithmicDepthBuffer ) {

                _gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

            }


            if ( camera !== _currentCamera ) _currentCamera = camera;

            // load material specific uniforms
            // (shader material also gets them for the sake of genericity)

            if ( material instanceof THREE.ShaderMaterial ||
                material instanceof THREE.MeshPhongMaterial ||
                material.envMap ) {

                if ( p_uniforms.cameraPosition !== undefined ) {

                    _vector3.setFromMatrixPosition( camera.matrixWorld );
                    _gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );

                }

            }

            if ( material instanceof THREE.MeshPhongMaterial ||
                material instanceof THREE.MeshLambertMaterial ||
                material instanceof THREE.MeshBasicMaterial ||
                material instanceof THREE.ShaderMaterial ||
                material.skinning ) {

                if ( p_uniforms.viewMatrix !== undefined ) {

                    _gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );

                }

            }

        }

        // skinning uniforms must be set even if material didn't change
        // auto-setting of texture unit for bone texture must go before other textures
        // not sure why, but otherwise weird things happen

        if ( material.skinning ) {

            if ( object.bindMatrix && p_uniforms.bindMatrix !== undefined ) {

                _gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );

            }

            if ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== undefined ) {

                _gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );

            }

            if ( capabilities.floatVertexTextures && object.skeleton && object.skeleton.useVertexTexture ) {

                if ( p_uniforms.boneTexture !== undefined ) {

                    var textureUnit = getTextureUnit();

                    _gl.uniform1i( p_uniforms.boneTexture, textureUnit );
                    _this.setTexture( object.skeleton.boneTexture, textureUnit );

                }

                if ( p_uniforms.boneTextureWidth !== undefined ) {

                    _gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );

                }

                if ( p_uniforms.boneTextureHeight !== undefined ) {

                    _gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );

                }

            } else if ( object.skeleton && object.skeleton.boneMatrices ) {

                if ( p_uniforms.boneGlobalMatrices !== undefined ) {

                    _gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );

                }

            }

        }

        if ( refreshMaterial ) {

            // refresh uniforms common to several materials

            if ( fog && material.fog ) {

                refreshUniformsFog( m_uniforms, fog );

            }

            if ( material instanceof THREE.MeshPhongMaterial ||
                material instanceof THREE.MeshLambertMaterial ||
                material.lights ) {

                if ( _lightsNeedUpdate ) {

                    refreshLights = true;
                    setupLights( lights, camera );
                    _lightsNeedUpdate = false;

                }

                if ( refreshLights ) {

                    refreshUniformsLights( m_uniforms, _lights );
                    markUniformsLightsNeedsUpdate( m_uniforms, true );

                } else {

                    markUniformsLightsNeedsUpdate( m_uniforms, false );

                }

            }

            if ( material instanceof THREE.MeshBasicMaterial ||
                material instanceof THREE.MeshLambertMaterial ||
                material instanceof THREE.MeshPhongMaterial ) {

                refreshUniformsCommon( m_uniforms, material );

            }

            // refresh single material specific uniforms

            if ( material instanceof THREE.LineBasicMaterial ) {

                refreshUniformsLine( m_uniforms, material );

            } else if ( material instanceof THREE.LineDashedMaterial ) {

                refreshUniformsLine( m_uniforms, material );
                refreshUniformsDash( m_uniforms, material );

            } else if ( material instanceof THREE.PointsMaterial ) {

                refreshUniformsParticle( m_uniforms, material );

            } else if ( material instanceof THREE.MeshPhongMaterial ) {

                refreshUniformsPhong( m_uniforms, material );

            } else if ( material instanceof THREE.MeshDepthMaterial ) {

                m_uniforms.mNear.value = camera.near;
                m_uniforms.mFar.value = camera.far;
                m_uniforms.opacity.value = material.opacity;

            } else if ( material instanceof THREE.MeshNormalMaterial ) {

                m_uniforms.opacity.value = material.opacity;

            }

            if ( object.receiveShadow && ! material._shadowPass ) {

                refreshUniformsShadow( m_uniforms, lights, camera );

            }

            // load common uniforms

            loadUniformsGeneric( materialProperties.uniformsList );

        }

        loadUniformsMatrices( p_uniforms, object );

        if ( p_uniforms.modelMatrix !== undefined ) {

            _gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );

        }

        return program;

    }

    // Uniforms (refresh uniforms objects)

    function refreshUniformsCommon ( uniforms, material ) {

        uniforms.opacity.value = material.opacity;

        uniforms.diffuse.value = material.color;

        if ( material.emissive ) {

            uniforms.emissive.value = material.emissive;

        }

        uniforms.map.value = material.map;
        uniforms.specularMap.value = material.specularMap;
        uniforms.alphaMap.value = material.alphaMap;

        if ( material.aoMap ) {

            uniforms.aoMap.value = material.aoMap;
            uniforms.aoMapIntensity.value = material.aoMapIntensity;

        }

        // uv repeat and offset setting priorities
        // 1. color map
        // 2. specular map
        // 3. normal map
        // 4. bump map
        // 5. alpha map
        // 6. emissive map

        var uvScaleMap;

        if ( material.map ) {

            uvScaleMap = material.map;

        } else if ( material.specularMap ) {

            uvScaleMap = material.specularMap;

        } else if ( material.displacementMap ) {

            uvScaleMap = material.displacementMap;

        } else if ( material.normalMap ) {

            uvScaleMap = material.normalMap;

        } else if ( material.bumpMap ) {

            uvScaleMap = material.bumpMap;

        } else if ( material.alphaMap ) {

            uvScaleMap = material.alphaMap;

        } else if ( material.emissiveMap ) {

            uvScaleMap = material.emissiveMap;

        }

        if ( uvScaleMap !== undefined ) {

            if ( uvScaleMap instanceof THREE.WebGLRenderTarget ) uvScaleMap = uvScaleMap.texture;
            var offset = uvScaleMap.offset;
            var repeat = uvScaleMap.repeat;

            uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

        }

        uniforms.envMap.value = material.envMap;
        uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;

        uniforms.reflectivity.value = material.reflectivity;
        uniforms.refractionRatio.value = material.refractionRatio;

    }

    function refreshUniformsLine ( uniforms, material ) {

        uniforms.diffuse.value = material.color;
        uniforms.opacity.value = material.opacity;

    }

    function refreshUniformsDash ( uniforms, material ) {

        uniforms.dashSize.value = material.dashSize;
        uniforms.totalSize.value = material.dashSize + material.gapSize;
        uniforms.scale.value = material.scale;

    }

    function refreshUniformsParticle ( uniforms, material ) {

        uniforms.psColor.value = material.color;
        uniforms.opacity.value = material.opacity;
        uniforms.size.value = material.size;
        uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.

        uniforms.map.value = material.map;

        if ( material.map !== null ) {

            var offset = material.map.offset;
            var repeat = material.map.repeat;

            uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

        }

    }

    function refreshUniformsFog ( uniforms, fog ) {

        uniforms.fogColor.value = fog.color;

        if ( fog instanceof THREE.Fog ) {

            uniforms.fogNear.value = fog.near;
            uniforms.fogFar.value = fog.far;

        } else if ( fog instanceof THREE.FogExp2 ) {

            uniforms.fogDensity.value = fog.density;

        }

    }

    function refreshUniformsPhong ( uniforms, material ) {

        uniforms.specular.value = material.specular;
        uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

        if ( material.lightMap ) {

            uniforms.lightMap.value = material.lightMap;
            uniforms.lightMapIntensity.value = material.lightMapIntensity;

        }

        if ( material.emissiveMap ) {

            uniforms.emissiveMap.value = material.emissiveMap;

        }

        if ( material.bumpMap ) {

            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;

        }

        if ( material.normalMap ) {

            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy( material.normalScale );

        }

        if ( material.displacementMap ) {

            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;

        }

    }

    function refreshUniformsLights ( uniforms, lights ) {

        uniforms.ambientLightColor.value = lights.ambient;

        uniforms.directionalLightColor.value = lights.directional.colors;
        uniforms.directionalLightDirection.value = lights.directional.positions;

        uniforms.pointLightColor.value = lights.point.colors;
        uniforms.pointLightPosition.value = lights.point.positions;
        uniforms.pointLightDistance.value = lights.point.distances;
        uniforms.pointLightDecay.value = lights.point.decays;

        uniforms.spotLightColor.value = lights.spot.colors;
        uniforms.spotLightPosition.value = lights.spot.positions;
        uniforms.spotLightDistance.value = lights.spot.distances;
        uniforms.spotLightDirection.value = lights.spot.directions;
        uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
        uniforms.spotLightExponent.value = lights.spot.exponents;
        uniforms.spotLightDecay.value = lights.spot.decays;

        uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
        uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
        uniforms.hemisphereLightDirection.value = lights.hemi.positions;

    }

    // If uniforms are marked as clean, they don't need to be loaded to the GPU.

    function markUniformsLightsNeedsUpdate ( uniforms, value ) {

        uniforms.ambientLightColor.needsUpdate = value;

        uniforms.directionalLightColor.needsUpdate = value;
        uniforms.directionalLightDirection.needsUpdate = value;

        uniforms.pointLightColor.needsUpdate = value;
        uniforms.pointLightPosition.needsUpdate = value;
        uniforms.pointLightDistance.needsUpdate = value;
        uniforms.pointLightDecay.needsUpdate = value;

        uniforms.spotLightColor.needsUpdate = value;
        uniforms.spotLightPosition.needsUpdate = value;
        uniforms.spotLightDistance.needsUpdate = value;
        uniforms.spotLightDirection.needsUpdate = value;
        uniforms.spotLightAngleCos.needsUpdate = value;
        uniforms.spotLightExponent.needsUpdate = value;
        uniforms.spotLightDecay.needsUpdate = value;

        uniforms.hemisphereLightSkyColor.needsUpdate = value;
        uniforms.hemisphereLightGroundColor.needsUpdate = value;
        uniforms.hemisphereLightDirection.needsUpdate = value;

    }

    function refreshUniformsShadow ( uniforms, lights, camera ) {

        if ( uniforms.shadowMatrix ) {

            var j = 0;

            for ( var i = 0, il = lights.length; i < il; i ++ ) {

                var light = lights[ i ];

                if ( light.castShadow === true ) {

                    if ( light instanceof THREE.PointLight || light instanceof THREE.SpotLight || light instanceof THREE.DirectionalLight ) {

                        var shadow = light.shadow;

                        if ( light instanceof THREE.PointLight ) {

                            // for point lights we set the shadow matrix to be a translation-only matrix
                            // equal to inverse of the light's position
                            _vector3.setFromMatrixPosition( light.matrixWorld ).negate();
                            shadow.matrix.identity().setPosition( _vector3 );

                            // for point lights we set the sign of the shadowDarkness uniform to be negative
                            uniforms.shadowDarkness.value[ j ] = - shadow.darkness;

                        } else {

                            uniforms.shadowDarkness.value[ j ] = shadow.darkness;

                        }

                        uniforms.shadowMatrix.value[ j ] = shadow.matrix;
                        uniforms.shadowMap.value[ j ] = shadow.map;
                        uniforms.shadowMapSize.value[ j ] = shadow.mapSize;
                        uniforms.shadowBias.value[ j ] = shadow.bias;

                        j ++;

                    }

                }

            }

        }

    }

    // Uniforms (load to GPU)

    function loadUniformsMatrices ( uniforms, object ) {

        _gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object.modelViewMatrix.elements );

        if ( uniforms.normalMatrix ) {

            _gl.uniformMatrix3fv( uniforms.normalMatrix, false, object.normalMatrix.elements );

        }

    }

    function getTextureUnit() {

        var textureUnit = _usedTextureUnits;

        if ( textureUnit >= capabilities.maxTextures ) {

            console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

        }

        _usedTextureUnits += 1;

        return textureUnit;

    }

    function loadUniformsGeneric ( uniforms ) {

        var texture, textureUnit;

        for ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {

            var uniform = uniforms[ j ][ 0 ];

            // needsUpdate property is not added to all uniforms.
            if ( uniform.needsUpdate === false ) continue;

            var type = uniform.type;
            var value = uniform.value;
            var location = uniforms[ j ][ 1 ];

            switch ( type ) {

                case '1i':
                    _gl.uniform1i( location, value );
                    break;

                case '1f':
                    _gl.uniform1f( location, value );
                    break;

                case '2f':
                    _gl.uniform2f( location, value[ 0 ], value[ 1 ] );
                    break;

                case '3f':
                    _gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );
                    break;

                case '4f':
                    _gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );
                    break;

                case '1iv':
                    _gl.uniform1iv( location, value );
                    break;

                case '3iv':
                    _gl.uniform3iv( location, value );
                    break;

                case '1fv':
                    _gl.uniform1fv( location, value );
                    break;

                case '2fv':
                    _gl.uniform2fv( location, value );
                    break;

                case '3fv':
                    _gl.uniform3fv( location, value );
                    break;

                case '4fv':
                    _gl.uniform4fv( location, value );
                    break;

                case 'Matrix3fv':
                    _gl.uniformMatrix3fv( location, false, value );
                    break;

                case 'Matrix4fv':
                    _gl.uniformMatrix4fv( location, false, value );
                    break;

                //

                case 'i':

                    // single integer
                    _gl.uniform1i( location, value );

                    break;

                case 'f':

                    // single float
                    _gl.uniform1f( location, value );

                    break;

                case 'v2':

                    // single THREE.Vector2
                    _gl.uniform2f( location, value.x, value.y );

                    break;

                case 'v3':

                    // single THREE.Vector3
                    _gl.uniform3f( location, value.x, value.y, value.z );

                    break;

                case 'v4':

                    // single THREE.Vector4
                    _gl.uniform4f( location, value.x, value.y, value.z, value.w );

                    break;

                case 'c':

                    // single THREE.Color
                    _gl.uniform3f( location, value.r, value.g, value.b );

                    break;

                case 'iv1':

                    // flat array of integers (JS or typed array)
                    _gl.uniform1iv( location, value );

                    break;

                case 'iv':

                    // flat array of integers with 3 x N size (JS or typed array)
                    _gl.uniform3iv( location, value );

                    break;

                case 'fv1':

                    // flat array of floats (JS or typed array)
                    _gl.uniform1fv( location, value );

                    break;

                case 'fv':

                    // flat array of floats with 3 x N size (JS or typed array)
                    _gl.uniform3fv( location, value );

                    break;

                case 'v2v':

                    // array of THREE.Vector2

                    if ( uniform._array === undefined ) {

                        uniform._array = new Float32Array( 2 * value.length );

                    }

                    for ( var i = 0, i2 = 0, il = value.length; i < il; i ++, i2 += 2 ) {

                        uniform._array[ i2 + 0 ] = value[ i ].x;
                        uniform._array[ i2 + 1 ] = value[ i ].y;

                    }

                    _gl.uniform2fv( location, uniform._array );

                    break;

                case 'v3v':

                    // array of THREE.Vector3

                    if ( uniform._array === undefined ) {

                        uniform._array = new Float32Array( 3 * value.length );

                    }

                    for ( var i = 0, i3 = 0, il = value.length; i < il; i ++, i3 += 3 ) {

                        uniform._array[ i3 + 0 ] = value[ i ].x;
                        uniform._array[ i3 + 1 ] = value[ i ].y;
                        uniform._array[ i3 + 2 ] = value[ i ].z;

                    }

                    _gl.uniform3fv( location, uniform._array );

                    break;

                case 'v4v':

                    // array of THREE.Vector4

                    if ( uniform._array === undefined ) {

                        uniform._array = new Float32Array( 4 * value.length );

                    }

                    for ( var i = 0, i4 = 0, il = value.length; i < il; i ++, i4 += 4 ) {

                        uniform._array[ i4 + 0 ] = value[ i ].x;
                        uniform._array[ i4 + 1 ] = value[ i ].y;
                        uniform._array[ i4 + 2 ] = value[ i ].z;
                        uniform._array[ i4 + 3 ] = value[ i ].w;

                    }

                    _gl.uniform4fv( location, uniform._array );

                    break;

                case 'm3':

                    // single THREE.Matrix3
                    _gl.uniformMatrix3fv( location, false, value.elements );

                    break;

                case 'm3v':

                    // array of THREE.Matrix3

                    if ( uniform._array === undefined ) {

                        uniform._array = new Float32Array( 9 * value.length );

                    }

                    for ( var i = 0, il = value.length; i < il; i ++ ) {

                        value[ i ].flattenToArrayOffset( uniform._array, i * 9 );

                    }

                    _gl.uniformMatrix3fv( location, false, uniform._array );

                    break;

                case 'm4':

                    // single THREE.Matrix4
                    _gl.uniformMatrix4fv( location, false, value.elements );

                    break;

                case 'm4v':

                    // array of THREE.Matrix4

                    if ( uniform._array === undefined ) {

                        uniform._array = new Float32Array( 16 * value.length );

                    }

                    for ( var i = 0, il = value.length; i < il; i ++ ) {

                        value[ i ].flattenToArrayOffset( uniform._array, i * 16 );

                    }

                    _gl.uniformMatrix4fv( location, false, uniform._array );

                    break;

                case 't':

                    // single THREE.Texture (2d or cube)

                    texture = value;
                    textureUnit = getTextureUnit();

                    _gl.uniform1i( location, textureUnit );

                    if ( ! texture ) continue;

                    if ( texture instanceof THREE.CubeTexture ||
                        ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

                        // CompressedTexture can have Array in image :/

                        setCubeTexture( texture, textureUnit );

                    } else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

                        setCubeTextureDynamic( texture.texture, textureUnit );

                    } else if ( texture instanceof THREE.WebGLRenderTarget ) {

                        _this.setTexture( texture.texture, textureUnit );

                    } else {

                        _this.setTexture( texture, textureUnit );

                    }

                    break;

                case 'tv':

                    // array of THREE.Texture (2d or cube)

                    if ( uniform._array === undefined ) {

                        uniform._array = [];

                    }

                    for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

                        uniform._array[ i ] = getTextureUnit();

                    }

                    _gl.uniform1iv( location, uniform._array );

                    for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

                        texture = uniform.value[ i ];
                        textureUnit = uniform._array[ i ];

                        if ( ! texture ) continue;

                        if ( texture instanceof THREE.CubeTexture ||
                            ( texture.image instanceof Array && texture.image.length === 6 ) ) {

                            // CompressedTexture can have Array in image :/

                            setCubeTexture( texture, textureUnit );

                        } else if ( texture instanceof THREE.WebGLRenderTarget ) {

                            _this.setTexture( texture.texture, textureUnit );

                        } else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

                            setCubeTextureDynamic( texture.texture, textureUnit );

                        } else {

                            _this.setTexture( texture, textureUnit );

                        }

                    }

                    break;

                default:

                    console.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );

            }

        }

    }

    function setColorLinear( array, offset, color, intensity ) {

        array[ offset + 0 ] = color.r * intensity;
        array[ offset + 1 ] = color.g * intensity;
        array[ offset + 2 ] = color.b * intensity;

    }

    function setupLights ( lights, camera ) {

        var l, ll, light,
            r = 0, g = 0, b = 0,
            color, skyColor, groundColor,
            intensity,
            distance,

            zlights = _lights,

            viewMatrix = camera.matrixWorldInverse,

            dirColors = zlights.directional.colors,
            dirPositions = zlights.directional.positions,

            pointColors = zlights.point.colors,
            pointPositions = zlights.point.positions,
            pointDistances = zlights.point.distances,
            pointDecays = zlights.point.decays,

            spotColors = zlights.spot.colors,
            spotPositions = zlights.spot.positions,
            spotDistances = zlights.spot.distances,
            spotDirections = zlights.spot.directions,
            spotAnglesCos = zlights.spot.anglesCos,
            spotExponents = zlights.spot.exponents,
            spotDecays = zlights.spot.decays,

            hemiSkyColors = zlights.hemi.skyColors,
            hemiGroundColors = zlights.hemi.groundColors,
            hemiPositions = zlights.hemi.positions,

            dirLength = 0,
            pointLength = 0,
            spotLength = 0,
            hemiLength = 0,

            dirCount = 0,
            pointCount = 0,
            spotCount = 0,
            hemiCount = 0,

            dirOffset = 0,
            pointOffset = 0,
            spotOffset = 0,
            hemiOffset = 0;

        for ( l = 0, ll = lights.length; l < ll; l ++ ) {

            light = lights[ l ];

            color = light.color;
            intensity = light.intensity;
            distance = light.distance;

            if ( light instanceof THREE.AmbientLight ) {

                if ( ! light.visible ) continue;

                r += color.r;
                g += color.g;
                b += color.b;

            } else if ( light instanceof THREE.DirectionalLight ) {

                dirCount += 1;

                if ( ! light.visible ) continue;

                _direction.setFromMatrixPosition( light.matrixWorld );
                _vector3.setFromMatrixPosition( light.target.matrixWorld );
                _direction.sub( _vector3 );
                _direction.transformDirection( viewMatrix );

                dirOffset = dirLength * 3;

                dirPositions[ dirOffset + 0 ] = _direction.x;
                dirPositions[ dirOffset + 1 ] = _direction.y;
                dirPositions[ dirOffset + 2 ] = _direction.z;

                setColorLinear( dirColors, dirOffset, color, intensity );

                dirLength += 1;

            } else if ( light instanceof THREE.PointLight ) {

                pointCount += 1;

                if ( ! light.visible ) continue;

                pointOffset = pointLength * 3;

                setColorLinear( pointColors, pointOffset, color, intensity );

                _vector3.setFromMatrixPosition( light.matrixWorld );
                _vector3.applyMatrix4( viewMatrix );

                pointPositions[ pointOffset + 0 ] = _vector3.x;
                pointPositions[ pointOffset + 1 ] = _vector3.y;
                pointPositions[ pointOffset + 2 ] = _vector3.z;

                // distance is 0 if decay is 0, because there is no attenuation at all.
                pointDistances[ pointLength ] = distance;
                pointDecays[ pointLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;

                pointLength += 1;

            } else if ( light instanceof THREE.SpotLight ) {

                spotCount += 1;

                if ( ! light.visible ) continue;

                spotOffset = spotLength * 3;

                setColorLinear( spotColors, spotOffset, color, intensity );

                _direction.setFromMatrixPosition( light.matrixWorld );
                _vector3.copy( _direction ).applyMatrix4( viewMatrix );

                spotPositions[ spotOffset + 0 ] = _vector3.x;
                spotPositions[ spotOffset + 1 ] = _vector3.y;
                spotPositions[ spotOffset + 2 ] = _vector3.z;

                spotDistances[ spotLength ] = distance;

                _vector3.setFromMatrixPosition( light.target.matrixWorld );
                _direction.sub( _vector3 );
                _direction.transformDirection( viewMatrix );

                spotDirections[ spotOffset + 0 ] = _direction.x;
                spotDirections[ spotOffset + 1 ] = _direction.y;
                spotDirections[ spotOffset + 2 ] = _direction.z;

                spotAnglesCos[ spotLength ] = Math.cos( light.angle );
                spotExponents[ spotLength ] = light.exponent;
                spotDecays[ spotLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;

                spotLength += 1;

            } else if ( light instanceof THREE.HemisphereLight ) {

                hemiCount += 1;

                if ( ! light.visible ) continue;

                _direction.setFromMatrixPosition( light.matrixWorld );
                _direction.transformDirection( viewMatrix );

                hemiOffset = hemiLength * 3;

                hemiPositions[ hemiOffset + 0 ] = _direction.x;
                hemiPositions[ hemiOffset + 1 ] = _direction.y;
                hemiPositions[ hemiOffset + 2 ] = _direction.z;

                skyColor = light.color;
                groundColor = light.groundColor;

                setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
                setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );

                hemiLength += 1;

            }

        }

        // null eventual remains from removed lights
        // (this is to avoid if in shader)

        for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;
        for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;
        for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;
        for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;
        for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;

        zlights.directional.length = dirLength;
        zlights.point.length = pointLength;
        zlights.spot.length = spotLength;
        zlights.hemi.length = hemiLength;

        zlights.ambient[ 0 ] = r;
        zlights.ambient[ 1 ] = g;
        zlights.ambient[ 2 ] = b;

    }

    // GL state setting

    this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

        if ( cullFace === THREE.CullFaceNone ) {

            state.disable( _gl.CULL_FACE );

        } else {

            if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {

                _gl.frontFace( _gl.CW );

            } else {

                _gl.frontFace( _gl.CCW );

            }

            if ( cullFace === THREE.CullFaceBack ) {

                _gl.cullFace( _gl.BACK );

            } else if ( cullFace === THREE.CullFaceFront ) {

                _gl.cullFace( _gl.FRONT );

            } else {

                _gl.cullFace( _gl.FRONT_AND_BACK );

            }

            state.enable( _gl.CULL_FACE );

        }

    };

    // Textures

    function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {

        var extension;

        if ( isImagePowerOfTwo ) {

            _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
            _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

            _gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
            _gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

        } else {

            _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
            _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

            if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {

                console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );

            }

            _gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
            _gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

            if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {

                console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );

            }

        }

        extension = extensions.get( 'EXT_texture_filter_anisotropic' );

        if ( extension ) {

            if ( texture.type === THREE.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
            if ( texture.type === THREE.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;

            if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

                _gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );
                properties.get( texture ).__currentAnisotropy = texture.anisotropy;

            }

        }

    }

    function uploadTexture( textureProperties, texture, slot ) {

        if ( textureProperties.__webglInit === undefined ) {

            textureProperties.__webglInit = true;

            texture.addEventListener( 'dispose', onTextureDispose );

            textureProperties.__webglTexture = _gl.createTexture();

            _infoMemory.textures ++;

        }

        state.activeTexture( _gl.TEXTURE0 + slot );
        state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

        _gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
        _gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
        _gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

        texture.image = clampToMaxSize( texture.image, capabilities.maxTextureSize );

        if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false ) {

            texture.image = makePowerOfTwo( texture.image );

        }

        var image = texture.image,
            isImagePowerOfTwo = isPowerOfTwo( image ),
            glFormat = paramThreeToGL( texture.format ),
            glType = paramThreeToGL( texture.type );

        setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );

        var mipmap, mipmaps = texture.mipmaps;

        if ( texture instanceof THREE.DataTexture ) {

            // use manually created mipmaps if available
            // if there are no manual mipmaps
            // set 0 level mipmap and then use GL to generate other mipmap levels

            if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

                for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

                    mipmap = mipmaps[ i ];
                    state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

                }

                texture.generateMipmaps = false;

            } else {

                state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

            }

        } else if ( texture instanceof THREE.CompressedTexture ) {

            for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

                mipmap = mipmaps[ i ];

                if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

                    if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

                        state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

                    } else {

                        console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );

                    }

                } else {

                    state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

                }

            }

        } else {

            // regular Texture (image, video, canvas)

            // use manually created mipmaps if available
            // if there are no manual mipmaps
            // set 0 level mipmap and then use GL to generate other mipmap levels

            if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

                for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

                    mipmap = mipmaps[ i ];
                    state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

                }

                texture.generateMipmaps = false;

            } else {

                state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

            }

        }

        if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

        textureProperties.__version = texture.version;

        if ( texture.onUpdate ) texture.onUpdate( texture );

    }

    this.setTexture = function ( texture, slot ) {

        var textureProperties = properties.get( texture );

        if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

            var image = texture.image;

            if ( image === undefined ) {

                console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );
                return;

            }

            if ( image.complete === false ) {

                console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );
                return;

            }

            uploadTexture( textureProperties, texture, slot );

            return;

        }

        state.activeTexture( _gl.TEXTURE0 + slot );
        state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

    };

    function clampToMaxSize ( image, maxSize ) {

        if ( image.width > maxSize || image.height > maxSize ) {

            // Warning: Scaling through the canvas will only work with images that use
            // premultiplied alpha.

            var scale = maxSize / Math.max( image.width, image.height );

            var canvas = document.createElement( 'canvas' );
            canvas.width = Math.floor( image.width * scale );
            canvas.height = Math.floor( image.height * scale );

            var context = canvas.getContext( '2d' );
            context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

            console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

            return canvas;

        }

        return image;

    }

    function isPowerOfTwo( image ) {

        return THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height );

    }

    function textureNeedsPowerOfTwo( texture ) {

        if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) return true;
        if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) return true;

        return false;

    }

    function makePowerOfTwo( image ) {

        if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {

            var canvas = document.createElement( 'canvas' );
            canvas.width = THREE.Math.nearestPowerOfTwo( image.width );
            canvas.height = THREE.Math.nearestPowerOfTwo( image.height );

            var context = canvas.getContext( '2d' );
            context.drawImage( image, 0, 0, canvas.width, canvas.height );

            console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

            return canvas;

        }

        return image;

    }

    function setCubeTexture ( texture, slot ) {

        var textureProperties = properties.get( texture );

        if ( texture.image.length === 6 ) {

            if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

                if ( ! textureProperties.__image__webglTextureCube ) {

                    texture.addEventListener( 'dispose', onTextureDispose );

                    textureProperties.__image__webglTextureCube = _gl.createTexture();

                    _infoMemory.textures ++;

                }

                state.activeTexture( _gl.TEXTURE0 + slot );
                state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

                _gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

                var isCompressed = texture instanceof THREE.CompressedTexture;
                var isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;

                var cubeImage = [];

                for ( var i = 0; i < 6; i ++ ) {

                    if ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {

                        cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );

                    } else {

                        cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

                    }

                }

                var image = cubeImage[ 0 ],
                    isImagePowerOfTwo = isPowerOfTwo( image ),
                    glFormat = paramThreeToGL( texture.format ),
                    glType = paramThreeToGL( texture.type );

                setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );

                for ( var i = 0; i < 6; i ++ ) {

                    if ( ! isCompressed ) {

                        if ( isDataTexture ) {

                            state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

                        } else {

                            state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

                        }

                    } else {

                        var mipmap, mipmaps = cubeImage[ i ].mipmaps;

                        for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

                            mipmap = mipmaps[ j ];

                            if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

                                if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

                                    state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

                                } else {

                                    console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()" );

                                }

                            } else {

                                state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

                            }

                        }

                    }

                }

                if ( texture.generateMipmaps && isImagePowerOfTwo ) {

                    _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

                }

                textureProperties.__version = texture.version;

                if ( texture.onUpdate ) texture.onUpdate( texture );

            } else {

                state.activeTexture( _gl.TEXTURE0 + slot );
                state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

            }

        }

    }

    function setCubeTextureDynamic ( texture, slot ) {

        state.activeTexture( _gl.TEXTURE0 + slot );
        state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

    }

    // Render targets

    function setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {

        _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
        _gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );

    }

    function setupRenderBuffer ( renderbuffer, renderTarget ) {

        _gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

        if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

            _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
            _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

            /* For some reason this is not working. Defaulting to RGBA4.
             } else if ( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

             _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
             _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
             */

        } else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

            _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
            _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

        } else {

            _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

        }

    }

    this.setRenderTarget = function ( renderTarget ) {

        var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );

        if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

            var renderTargetProperties = properties.get( renderTarget );
            var textureProperties = properties.get( renderTarget.texture );

            if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;
            if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;

            renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

            textureProperties.__webglTexture = _gl.createTexture();

            _infoMemory.textures ++;

            // Setup texture, create render and frame buffers

            var isTargetPowerOfTwo = isPowerOfTwo( renderTarget ),
                glFormat = paramThreeToGL( renderTarget.texture.format ),
                glType = paramThreeToGL( renderTarget.texture.type );

            if ( isCube ) {

                renderTargetProperties.__webglFramebuffer = [];
                renderTargetProperties.__webglRenderbuffer = [];

                state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );

                setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );

                for ( var i = 0; i < 6; i ++ ) {

                    renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();
                    renderTargetProperties.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();
                    state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

                    setupFrameBuffer( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
                    setupRenderBuffer( renderTargetProperties.__webglRenderbuffer[ i ], renderTarget );

                }

                if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

            } else {

                renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

                if ( renderTarget.shareDepthFrom ) {

                    renderTargetProperties.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;

                } else {

                    renderTargetProperties.__webglRenderbuffer = _gl.createRenderbuffer();

                }

                state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
                setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );

                state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

                setupFrameBuffer( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );

                if ( renderTarget.shareDepthFrom ) {

                    if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

                        _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer );

                    } else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

                        _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer );

                    }

                } else {

                    setupRenderBuffer( renderTargetProperties.__webglRenderbuffer, renderTarget );

                }

                if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

            }

            // Release everything

            if ( isCube ) {

                state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

            } else {

                state.bindTexture( _gl.TEXTURE_2D, null );

            }

            _gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
            _gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

        }

        var framebuffer, width, height, vx, vy;

        if ( renderTarget ) {

            var renderTargetProperties = properties.get( renderTarget );

            if ( isCube ) {

                framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];

            } else {

                framebuffer = renderTargetProperties.__webglFramebuffer;

            }

            width = renderTarget.width;
            height = renderTarget.height;

            vx = 0;
            vy = 0;

        } else {

            framebuffer = null;

            width = _viewportWidth;
            height = _viewportHeight;

            vx = _viewportX;
            vy = _viewportY;

        }

        if ( framebuffer !== _currentFramebuffer ) {

            _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
            _gl.viewport( vx, vy, width, height );

            _currentFramebuffer = framebuffer;

        }

        if ( isCube ) {

            var textureProperties = properties.get( renderTarget.texture );
            _gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, 0 );

        }

        _currentWidth = width;
        _currentHeight = height;

    };

    this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {

        if ( renderTarget instanceof THREE.WebGLRenderTarget === false ) {

            console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
            return;

        }

        var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

        if ( framebuffer ) {

            var restore = false;

            if ( framebuffer !== _currentFramebuffer ) {

                _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

                restore = true;

            }

            try {

                var texture = renderTarget.texture;

                if ( texture.format !== THREE.RGBAFormat
                    && paramThreeToGL( texture.format ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

                    console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
                    return;

                }

                if ( texture.type !== THREE.UnsignedByteType
                    && paramThreeToGL( texture.type ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE )
                    && ! ( texture.type === THREE.FloatType && extensions.get( 'WEBGL_color_buffer_float' ) )
                    && ! ( texture.type === THREE.HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {

                    console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
                    return;

                }

                if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

                    _gl.readPixels( x, y, width, height, paramThreeToGL( texture.format ), paramThreeToGL( texture.type ), buffer );

                } else {

                    console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

                }

            } finally {

                if ( restore ) {

                    _gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

                }

            }

        }

    };

    function updateRenderTargetMipmap( renderTarget ) {

        var target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
        var texture = properties.get( renderTarget.texture ).__webglTexture;

        state.bindTexture( target, texture );
        _gl.generateMipmap( target );
        state.bindTexture( target, null );

    }

    // Fallback filters for non-power-of-2 textures

    function filterFallback ( f ) {

        if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {

            return _gl.NEAREST;

        }

        return _gl.LINEAR;

    }

    // Map three.js constants to WebGL constants

    function paramThreeToGL ( p ) {

        var extension;

        if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
        if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
        if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

        if ( p === THREE.NearestFilter ) return _gl.NEAREST;
        if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
        if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

        if ( p === THREE.LinearFilter ) return _gl.LINEAR;
        if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
        if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

        if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
        if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
        if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
        if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

        if ( p === THREE.ByteType ) return _gl.BYTE;
        if ( p === THREE.ShortType ) return _gl.SHORT;
        if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
        if ( p === THREE.IntType ) return _gl.INT;
        if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
        if ( p === THREE.FloatType ) return _gl.FLOAT;

        extension = extensions.get( 'OES_texture_half_float' );

        if ( extension !== null ) {

            if ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;

        }

        if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
        if ( p === THREE.RGBFormat ) return _gl.RGB;
        if ( p === THREE.RGBAFormat ) return _gl.RGBA;
        if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
        if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;

        if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
        if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
        if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

        if ( p === THREE.ZeroFactor ) return _gl.ZERO;
        if ( p === THREE.OneFactor ) return _gl.ONE;
        if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
        if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
        if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
        if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
        if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
        if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

        if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
        if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
        if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

        extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

        if ( extension !== null ) {

            if ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

        }

        extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

        if ( extension !== null ) {

            if ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

        }

        extension = extensions.get( 'EXT_blend_minmax' );

        if ( extension !== null ) {

            if ( p === THREE.MinEquation ) return extension.MIN_EXT;
            if ( p === THREE.MaxEquation ) return extension.MAX_EXT;

        }

        return 0;

    }

    // DEPRECATED

    this.supportsFloatTextures = function () {

        console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
        return extensions.get( 'OES_texture_float' );

    };

    this.supportsHalfFloatTextures = function () {

        console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
        return extensions.get( 'OES_texture_half_float' );

    };

    this.supportsStandardDerivatives = function () {

        console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
        return extensions.get( 'OES_standard_derivatives' );

    };

    this.supportsCompressedTextureS3TC = function () {

        console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
        return extensions.get( 'WEBGL_compressed_texture_s3tc' );

    };

    this.supportsCompressedTexturePVRTC = function () {

        console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
        return extensions.get( 'WEBGL_compressed_texture_pvrtc' );

    };

    this.supportsBlendMinMax = function () {

        console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
        return extensions.get( 'EXT_blend_minmax' );

    };

    this.supportsVertexTextures = function () {

        return capabilities.vertexTextures;

    };

    this.supportsInstancedArrays = function () {

        console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
        return extensions.get( 'ANGLE_instanced_arrays' );

    };

    //

    this.initMaterial = function () {

        console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

    };

    this.addPrePlugin = function () {

        console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

    };

    this.addPostPlugin = function () {

        console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

    };

    this.updateShadowMap = function () {

        console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

    };

    Object.defineProperties( this, {
        shadowMapEnabled: {
            get: function () {

                return shadowMap.enabled;

            },
            set: function ( value ) {

                console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
                shadowMap.enabled = value;

            }
        },
        shadowMapType: {
            get: function () {

                return shadowMap.type;

            },
            set: function ( value ) {

                console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
                shadowMap.type = value;

            }
        },
        shadowMapCullFace: {
            get: function () {

                return shadowMap.cullFace;

            },
            set: function ( value ) {

                console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
                shadowMap.cullFace = value;

            }
        },
        shadowMapDebug: {
            get: function () {

                return shadowMap.debug;

            },
            set: function ( value ) {

                console.warn( 'THREE.WebGLRenderer: .shadowMapDebug is now .shadowMap.debug.' );
                shadowMap.debug = value;

            }
        }
    } );

};

// File:src/renderers/WebGLRenderTarget.js

/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.WebGLRenderTarget = function ( width, height, options ) {

    this.uuid = THREE.Math.generateUUID();

    this.width = width;
    this.height = height;

    options = options || {};

    if ( options.minFilter === undefined ) options.minFilter = THREE.LinearFilter;

    this.texture = new THREE.Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy );

    this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
    this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;

    this.shareDepthFrom = options.shareDepthFrom !== undefined ? options.shareDepthFrom : null;

};

THREE.WebGLRenderTarget.prototype = {

    constructor: THREE.WebGLRenderTarget,

    get wrapS() {

        console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );

        return this.texture.wrapS;

    },

    set wrapS( value ) {

        console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );

        this.texture.wrapS = value;

    },

    get wrapT() {

        console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );

        return this.texture.wrapT;

    },

    set wrapT( value ) {

        console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );

        this.texture.wrapT = value;

    },

    get magFilter() {

        console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );

        return this.texture.magFilter;

    },

    set magFilter( value ) {

        console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );

        this.texture.magFilter = value;

    },

    get minFilter() {

        console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );

        return this.texture.minFilter;

    },

    set minFilter( value ) {

        console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );

        this.texture.minFilter = value;

    },

    get anisotropy() {

        console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );

        return this.texture.anisotropy;

    },

    set anisotropy( value ) {

        console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );

        this.texture.anisotropy = value;

    },

    get offset() {

        console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );

        return this.texture.offset;

    },

    set offset( value ) {

        console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );

        this.texture.offset = value;

    },

    get repeat() {

        console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );

        return this.texture.repeat;

    },

    set repeat( value ) {

        console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );

        this.texture.repeat = value;

    },

    get format() {

        console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );

        return this.texture.format;

    },

    set format( value ) {

        console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );

        this.texture.format = value;

    },

    get type() {

        console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );

        return this.texture.type;

    },

    set type( value ) {

        console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );

        this.texture.type = value;

    },

    get generateMipmaps() {

        console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );

        return this.texture.generateMipmaps;

    },

    set generateMipmaps( value ) {

        console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );

        this.texture.generateMipmaps = value;

    },

    //

    setSize: function ( width, height ) {

        if ( this.width !== width || this.height !== height ) {

            this.width = width;
            this.height = height;

            this.dispose();

        }

    },

    clone: function () {

        return new this.constructor().copy( this );

    },

    copy: function ( source ) {

        this.width = source.width;
        this.height = source.height;

        this.texture = source.texture.clone();

        this.depthBuffer = source.depthBuffer;
        this.stencilBuffer = source.stencilBuffer;

        this.shareDepthFrom = source.shareDepthFrom;

        return this;

    },

    dispose: function () {

        this.dispatchEvent( { type: 'dispose' } );

    }

};

THREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );

// File:src/renderers/WebGLRenderTargetCube.js

/**
 * @author alteredq / http://alteredqualia.com
 */

THREE.WebGLRenderTargetCube = function ( width, height, options ) {

    THREE.WebGLRenderTarget.call( this, width, height, options );

    this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5

};

THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );
THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;

// File:src/renderers/webgl/WebGLBufferRenderer.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLBufferRenderer = function ( _gl, extensions, _infoRender ) {

    var mode;

    function setMode( value ) {

        mode = value;

    }

    function render( start, count ) {

        _gl.drawArrays( mode, start, count );

        _infoRender.calls ++;
        _infoRender.vertices += count;
        if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;

    }

    function renderInstances( geometry ) {

        var extension = extensions.get( 'ANGLE_instanced_arrays' );

        if ( extension === null ) {

            console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
            return;

        }

        var position = geometry.attributes.position;

        if ( position instanceof THREE.InterleavedBufferAttribute ) {

            extension.drawArraysInstancedANGLE( mode, 0, position.data.count, geometry.maxInstancedCount );

        } else {

            extension.drawArraysInstancedANGLE( mode, 0, position.count, geometry.maxInstancedCount );

        }

    }

    this.setMode = setMode;
    this.render = render;
    this.renderInstances = renderInstances;

};

// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLIndexedBufferRenderer = function ( _gl, extensions, _infoRender ) {

    var mode;

    function setMode( value ) {

        mode = value;

    }

    var type, size;

    function setIndex( index ) {

        if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

            type = _gl.UNSIGNED_INT;
            size = 4;

        } else {

            type = _gl.UNSIGNED_SHORT;
            size = 2;

        }

    }

    function render( start, count ) {

        _gl.drawElements( mode, count, type, start * size );

        _infoRender.calls ++;
        _infoRender.vertices += count;
        if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;

    }

    function renderInstances( geometry ) {

        var extension = extensions.get( 'ANGLE_instanced_arrays' );

        if ( extension === null ) {

            console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
            return;

        }

        var index = geometry.index;

        extension.drawElementsInstancedANGLE( mode, index.array.length, type, 0, geometry.maxInstancedCount );

    }

    this.setMode = setMode;
    this.setIndex = setIndex;
    this.render = render;
    this.renderInstances = renderInstances;

};

// File:src/renderers/webgl/WebGLExtensions.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLExtensions = function ( gl ) {

    var extensions = {};

    this.get = function ( name ) {

        if ( extensions[ name ] !== undefined ) {

            return extensions[ name ];

        }

        var extension;

        switch ( name ) {

            case 'EXT_texture_filter_anisotropic':
                extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
                break;

            case 'WEBGL_compressed_texture_s3tc':
                extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
                break;

            case 'WEBGL_compressed_texture_pvrtc':
                extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
                break;

            default:
                extension = gl.getExtension( name );

        }

        if ( extension === null ) {

            console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

        }

        extensions[ name ] = extension;

        return extension;

    };

};

// File:src/renderers/webgl/WebGLCapabilities.js

THREE.WebGLCapabilities = function ( gl, extensions, parameters ) {

    function getMaxPrecision( precision ) {

        if ( precision === 'highp' ) {

            if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
                gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

                return 'highp';

            }

            precision = 'mediump';

        }

        if ( precision === 'mediump' ) {

            if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
                gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

                return 'mediump';

            }

        }

        return 'lowp';

    }

    this.getMaxPrecision = getMaxPrecision;

    this.precision = parameters.precision !== undefined ? parameters.precision : 'highp',
        this.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;

    this.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
    this.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
    this.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
    this.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

    this.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
    this.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
    this.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
    this.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

    this.vertexTextures = this.maxVertexTextures > 0;
    this.floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
    this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;

    var _maxPrecision = getMaxPrecision( this.precision );

    if ( _maxPrecision !== this.precision ) {

        console.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );
        this.precision = _maxPrecision;

    }

    if ( this.logarithmicDepthBuffer ) {

        this.logarithmicDepthBuffer = !! extensions.get( 'EXT_frag_depth' );

    }

};

// File:src/renderers/webgl/WebGLGeometries.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLGeometries = function ( gl, properties, info ) {

    var geometries = {};

    function get( object ) {

        var geometry = object.geometry;

        if ( geometries[ geometry.id ] !== undefined ) {

            return geometries[ geometry.id ];

        }

        geometry.addEventListener( 'dispose', onGeometryDispose );

        var buffergeometry;

        if ( geometry instanceof THREE.BufferGeometry ) {

            buffergeometry = geometry;

        } else if ( geometry instanceof THREE.Geometry ) {

            if ( geometry._bufferGeometry === undefined ) {

                geometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );

            }

            buffergeometry = geometry._bufferGeometry;

        }

        geometries[ geometry.id ] = buffergeometry;

        info.memory.geometries ++;

        return buffergeometry;

    }

    function onGeometryDispose( event ) {

        var geometry = event.target;
        var buffergeometry = geometries[ geometry.id ];

        deleteAttributes( buffergeometry.attributes );

        geometry.removeEventListener( 'dispose', onGeometryDispose );

        delete geometries[ geometry.id ];

        var property = properties.get( geometry );
        if ( property.wireframe ) deleteAttribute( property.wireframe );

        info.memory.geometries --;

    }

    function getAttributeBuffer( attribute ) {

        if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

            return properties.get( attribute.data ).__webglBuffer;

        }

        return properties.get( attribute ).__webglBuffer;

    }

    function deleteAttribute( attribute ) {

        var buffer = getAttributeBuffer( attribute );

        if ( buffer !== undefined ) {

            gl.deleteBuffer( buffer );
            removeAttributeBuffer( attribute );

        }

    }

    function deleteAttributes( attributes ) {

        for ( var name in attributes ) {

            deleteAttribute( attributes[ name ] );

        }

    }

    function removeAttributeBuffer( attribute ) {

        if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

            properties.delete( attribute.data );

        } else {

            properties.delete( attribute );

        }

    }

    this.get = get;

};

// File:src/renderers/webgl/WebGLObjects.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLObjects = function ( gl, properties, info ) {

    var geometries = new THREE.WebGLGeometries( gl, properties, info );

    //

    function update( object ) {

        // TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.

        var geometry = geometries.get( object );

        if ( object.geometry instanceof THREE.Geometry ) {

            geometry.updateFromObject( object );

        }

        var index = geometry.index;
        var attributes = geometry.attributes;

        if ( index !== null ) {

            updateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );

        }

        for ( var name in attributes ) {

            updateAttribute( attributes[ name ], gl.ARRAY_BUFFER );

        }

        // morph targets

        var morphAttributes = geometry.morphAttributes;

        for ( var name in morphAttributes ) {

            var array = morphAttributes[ name ];

            for ( var i = 0, l = array.length; i < l; i ++ ) {

                updateAttribute( array[ i ], gl.ARRAY_BUFFER );

            }

        }

        return geometry;

    }

    function updateAttribute( attribute, bufferType ) {

        var data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;

        var attributeProperties = properties.get( data );

        if ( attributeProperties.__webglBuffer === undefined ) {

            createBuffer( attributeProperties, data, bufferType );

        } else if ( attributeProperties.version !== data.version ) {

            updateBuffer( attributeProperties, data, bufferType );

        }

    }

    function createBuffer( attributeProperties, data, bufferType ) {

        attributeProperties.__webglBuffer = gl.createBuffer();
        gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

        var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

        gl.bufferData( bufferType, data.array, usage );

        attributeProperties.version = data.version;

    }

    function updateBuffer( attributeProperties, data, bufferType ) {

        gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

        if ( data.dynamic === false || data.updateRange.count === - 1 ) {

            // Not using update ranges

            gl.bufferSubData( bufferType, 0, data.array );

        } else if ( data.updateRange.count === 0 ) {

            console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

        } else {

            gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
                data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );

            data.updateRange.count = 0; // reset range

        }

        attributeProperties.version = data.version;

    }

    function getAttributeBuffer( attribute ) {

        if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

            return properties.get( attribute.data ).__webglBuffer;

        }

        return properties.get( attribute ).__webglBuffer;

    }

    function getWireframeAttribute( geometry ) {

        var property = properties.get( geometry );

        if ( property.wireframe !== undefined ) {

            return property.wireframe;

        }

        var indices = [];

        var index = geometry.index;
        var attributes = geometry.attributes;
        var position = attributes.position;

        // console.time( 'wireframe' );

        if ( index !== null ) {

            var edges = {};
            var array = index.array;

            for ( var i = 0, l = array.length; i < l; i += 3 ) {

                var a = array[ i + 0 ];
                var b = array[ i + 1 ];
                var c = array[ i + 2 ];

                if ( checkEdge( edges, a, b ) ) indices.push( a, b );
                if ( checkEdge( edges, b, c ) ) indices.push( b, c );
                if ( checkEdge( edges, c, a ) ) indices.push( c, a );

            }

        } else {

            var array = attributes.position.array;

            for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

                var a = i + 0;
                var b = i + 1;
                var c = i + 2;

                indices.push( a, b, b, c, c, a );

            }

        }

        // console.timeEnd( 'wireframe' );

        var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
        var attribute = new THREE.BufferAttribute( new TypeArray( indices ), 1 );

        updateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );

        property.wireframe = attribute;

        return attribute;

    }

    function checkEdge( edges, a, b ) {

        if ( a > b ) {

            var tmp = a;
            a = b;
            b = tmp;

        }

        var list = edges[ a ];

        if ( list === undefined ) {

            edges[ a ] = [ b ];
            return true;

        } else if ( list.indexOf( b ) === -1 ) {

            list.push( b );
            return true;

        }

        return false;

    }

    this.getAttributeBuffer = getAttributeBuffer;
    this.getWireframeAttribute = getWireframeAttribute;

    this.update = update;

};

// File:src/renderers/webgl/WebGLProgram.js

THREE.WebGLProgram = ( function () {

    var programIdCount = 0;

    function generateDefines( defines ) {

        var chunks = [];

        for ( var name in defines ) {

            var value = defines[ name ];

            if ( value === false ) continue;

            chunks.push( '#define ' + name + ' ' + value );

        }

        return chunks.join( '\n' );

    }

    function fetchUniformLocations( gl, program, identifiers ) {

        var uniforms = {};

        var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

        for ( var i = 0; i < n; i ++ ) {

            var info = gl.getActiveUniform( program, i );
            var name = info.name;
            var location = gl.getUniformLocation( program, name );

            // console.log("THREE.WebGLProgram: ACTIVE UNIFORM:", name);

            var suffixPos = name.lastIndexOf( '[0]' );
            if ( suffixPos !== - 1 && suffixPos === name.length - 3 ) {

                uniforms[ name.substr( 0, suffixPos ) ] = location;

            }

            uniforms[ name ] = location;

        }

        return uniforms;

    }

    function fetchAttributeLocations( gl, program, identifiers ) {

        var attributes = {};

        var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

        for ( var i = 0; i < n; i ++ ) {

            var info = gl.getActiveAttrib( program, i );
            var name = info.name;

            // console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );

            attributes[ name ] = gl.getAttribLocation( program, name );

        }

        return attributes;

    }

    function filterEmptyLine( string ) {

        return string !== '';

    }

    return function WebGLProgram( renderer, code, material, parameters ) {

        var gl = renderer.context;

        var defines = material.defines;

        var vertexShader = material.__webglShader.vertexShader;
        var fragmentShader = material.__webglShader.fragmentShader;

        var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

        if ( parameters.shadowMapType === THREE.PCFShadowMap ) {

            shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

        } else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {

            shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

        }

        var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
        var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
        var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

        if ( parameters.envMap ) {

            switch ( material.envMap.mapping ) {

                case THREE.CubeReflectionMapping:
                case THREE.CubeRefractionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
                    break;

                case THREE.EquirectangularReflectionMapping:
                case THREE.EquirectangularRefractionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
                    break;

                case THREE.SphericalReflectionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
                    break;

            }

            switch ( material.envMap.mapping ) {

                case THREE.CubeRefractionMapping:
                case THREE.EquirectangularRefractionMapping:
                    envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
                    break;

            }

            switch ( material.combine ) {

                case THREE.MultiplyOperation:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
                    break;

                case THREE.MixOperation:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
                    break;

                case THREE.AddOperation:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
                    break;

            }

        }

        var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

        // console.log( 'building new program ' );

        //

        var customDefines = generateDefines( defines );

        //

        var program = gl.createProgram();

        var prefixVertex, prefixFragment;

        if ( material instanceof THREE.RawShaderMaterial ) {

            prefixVertex = '';
            prefixFragment = '';

        } else {

            prefixVertex = [

                'precision ' + parameters.precision + ' float;',
                'precision ' + parameters.precision + ' int;',

                '#define SHADER_NAME ' + material.__webglShader.name,

                customDefines,

                parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

                renderer.gammaInput ? '#define GAMMA_INPUT' : '',
                renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
                '#define GAMMA_FACTOR ' + gammaFactorDefine,

                '#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
                '#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
                '#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
                '#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

                '#define MAX_SHADOWS ' + parameters.maxShadows,

                '#define MAX_BONES ' + parameters.maxBones,

                parameters.map ? '#define USE_MAP' : '',
                parameters.envMap ? '#define USE_ENVMAP' : '',
                parameters.envMap ? '#define ' + envMapModeDefine : '',
                parameters.lightMap ? '#define USE_LIGHTMAP' : '',
                parameters.aoMap ? '#define USE_AOMAP' : '',
                parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                parameters.bumpMap ? '#define USE_BUMPMAP' : '',
                parameters.normalMap ? '#define USE_NORMALMAP' : '',
                parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
                parameters.specularMap ? '#define USE_SPECULARMAP' : '',
                parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
                parameters.vertexColors ? '#define USE_COLOR' : '',

                parameters.flatShading ? '#define FLAT_SHADED' : '',

                parameters.skinning ? '#define USE_SKINNING' : '',
                parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

                parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
                parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
                parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
                parameters.flipSided ? '#define FLIP_SIDED' : '',

                parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
                parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
                parameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '',

                parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

                parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',


                'uniform mat4 modelMatrix;',
                'uniform mat4 modelViewMatrix;',
                'uniform mat4 projectionMatrix;',
                'uniform mat4 viewMatrix;',
                'uniform mat3 normalMatrix;',
                'uniform vec3 cameraPosition;',

                'attribute vec3 position;',
                'attribute vec3 normal;',
                'attribute vec2 uv;',

                '#ifdef USE_COLOR',

                '	attribute vec3 color;',

                '#endif',

                '#ifdef USE_MORPHTARGETS',

                '	attribute vec3 morphTarget0;',
                '	attribute vec3 morphTarget1;',
                '	attribute vec3 morphTarget2;',
                '	attribute vec3 morphTarget3;',

                '	#ifdef USE_MORPHNORMALS',

                '		attribute vec3 morphNormal0;',
                '		attribute vec3 morphNormal1;',
                '		attribute vec3 morphNormal2;',
                '		attribute vec3 morphNormal3;',

                '	#else',

                '		attribute vec3 morphTarget4;',
                '		attribute vec3 morphTarget5;',
                '		attribute vec3 morphTarget6;',
                '		attribute vec3 morphTarget7;',

                '	#endif',

                '#endif',

                '#ifdef USE_SKINNING',

                '	attribute vec4 skinIndex;',
                '	attribute vec4 skinWeight;',

                '#endif',

                '\n'

            ].filter( filterEmptyLine ).join( '\n' );

            prefixFragment = [

                parameters.bumpMap || parameters.normalMap || parameters.flatShading || material.derivatives ? '#extension GL_OES_standard_derivatives : enable' : '',
                parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',

                'precision ' + parameters.precision + ' float;',
                'precision ' + parameters.precision + ' int;',

                '#define SHADER_NAME ' + material.__webglShader.name,

                customDefines,

                '#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
                '#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
                '#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
                '#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

                '#define MAX_SHADOWS ' + parameters.maxShadows,

                parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

                renderer.gammaInput ? '#define GAMMA_INPUT' : '',
                renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
                '#define GAMMA_FACTOR ' + gammaFactorDefine,

                ( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
                ( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

                parameters.map ? '#define USE_MAP' : '',
                parameters.envMap ? '#define USE_ENVMAP' : '',
                parameters.envMap ? '#define ' + envMapTypeDefine : '',
                parameters.envMap ? '#define ' + envMapModeDefine : '',
                parameters.envMap ? '#define ' + envMapBlendingDefine : '',
                parameters.lightMap ? '#define USE_LIGHTMAP' : '',
                parameters.aoMap ? '#define USE_AOMAP' : '',
                parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                parameters.bumpMap ? '#define USE_BUMPMAP' : '',
                parameters.normalMap ? '#define USE_NORMALMAP' : '',
                parameters.specularMap ? '#define USE_SPECULARMAP' : '',
                parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
                parameters.vertexColors ? '#define USE_COLOR' : '',

                parameters.flatShading ? '#define FLAT_SHADED' : '',

                parameters.metal ? '#define METAL' : '',
                parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
                parameters.flipSided ? '#define FLIP_SIDED' : '',

                parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
                parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
                parameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '',

                parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

                'uniform mat4 viewMatrix;',
                'uniform vec3 cameraPosition;',

                '\n'

            ].filter( filterEmptyLine ).join( '\n' );

        }

        var vertexGlsl = prefixVertex + vertexShader;
        var fragmentGlsl = prefixFragment + fragmentShader;

        var glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
        var glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

        gl.attachShader( program, glVertexShader );
        gl.attachShader( program, glFragmentShader );

        // Force a particular attribute to index 0.

        if ( material.index0AttributeName !== undefined ) {

            gl.bindAttribLocation( program, 0, material.index0AttributeName );

        } else if ( parameters.morphTargets === true ) {

            // programs with morphTargets displace position out of attribute 0
            gl.bindAttribLocation( program, 0, 'position' );

        }

        gl.linkProgram( program );

        var programLog = gl.getProgramInfoLog( program );
        var vertexLog = gl.getShaderInfoLog( glVertexShader );
        var fragmentLog = gl.getShaderInfoLog( glFragmentShader );

        var runnable = true;
        var haveDiagnostics = true;

        if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

            runnable = false;

            console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

        } else if ( programLog !== '' ) {

            console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

        } else if ( vertexLog === '' || fragmentLog === '' ) {

            haveDiagnostics = false;

        }

        if ( haveDiagnostics ) {

            this.diagnostics = {

                runnable: runnable,
                material: material,

                programLog: programLog,

                vertexShader: {

                    log: vertexLog,
                    prefix: prefixVertex

                },

                fragmentShader: {

                    log: fragmentLog,
                    prefix: prefixFragment

                }

            };

        }

        // clean up

        gl.deleteShader( glVertexShader );
        gl.deleteShader( glFragmentShader );

        // set up caching for uniform locations

        var cachedUniforms;

        this.getUniforms = function() {

            if ( cachedUniforms === undefined ) {

                cachedUniforms = fetchUniformLocations( gl, program );

            }

            return cachedUniforms;

        };

        // set up caching for attribute locations

        var cachedAttributes;

        this.getAttributes = function() {

            if ( cachedAttributes === undefined ) {

                cachedAttributes = fetchAttributeLocations( gl, program );

            }

            return cachedAttributes;

        };

        // free resource

        this.destroy = function() {

            gl.deleteProgram( program );
            this.program = undefined;

        };

        // DEPRECATED

        Object.defineProperties( this, {

            uniforms: {
                get: function() {

                    console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
                    return this.getUniforms();

                }
            },

            attributes: {
                get: function() {

                    console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
                    return this.getAttributes();

                }
            }

        } );


        //

        this.id = programIdCount ++;
        this.code = code;
        this.usedTimes = 1;
        this.program = program;
        this.vertexShader = glVertexShader;
        this.fragmentShader = glFragmentShader;

        return this;

    };

} )();

// File:src/renderers/webgl/WebGLPrograms.js

THREE.WebGLPrograms = function ( renderer, capabilities ) {

    var programs = [];

    var shaderIDs = {
        MeshDepthMaterial: 'depth',
        MeshNormalMaterial: 'normal',
        MeshBasicMaterial: 'basic',
        MeshLambertMaterial: 'lambert',
        MeshPhongMaterial: 'phong',
        LineBasicMaterial: 'basic',
        LineDashedMaterial: 'dashed',
        PointsMaterial: 'points'
    };

    var parameterNames = [
        "precision", "supportsVertexTextures", "map", "envMap", "envMapMode",
        "lightMap", "aoMap", "emissiveMap", "bumpMap", "normalMap", "displacementMap", "specularMap",
        "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
        "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
        "maxBones", "useVertexTexture", "morphTargets", "morphNormals",
        "maxMorphTargets", "maxMorphNormals", "maxDirLights", "maxPointLights",
        "maxSpotLights", "maxHemiLights", "maxShadows", "shadowMapEnabled", "pointLightShadows",
        "shadowMapType", "shadowMapDebug", "alphaTest", "metal", "doubleSided",
        "flipSided"
    ];


    function allocateBones ( object ) {

        if ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

            return 1024;

        } else {

            // default for when object is not specified
            // ( for example when prebuilding shader to be used with multiple objects )
            //
            //  - leave some extra space for other uniforms
            //  - limit here is ANGLE's 254 max uniform vectors
            //    (up to 54 should be safe)

            var nVertexUniforms = capabilities.maxVertexUniforms;
            var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

            var maxBones = nVertexMatrices;

            if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {

                maxBones = Math.min( object.skeleton.bones.length, maxBones );

                if ( maxBones < object.skeleton.bones.length ) {

                    console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

                }

            }

            return maxBones;

        }

    }

    function allocateLights( lights ) {

        var dirLights = 0;
        var pointLights = 0;
        var spotLights = 0;
        var hemiLights = 0;

        for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

            var light = lights[ l ];

            if ( light.visible === false ) continue;

            if ( light instanceof THREE.DirectionalLight ) dirLights ++;
            if ( light instanceof THREE.PointLight ) pointLights ++;
            if ( light instanceof THREE.SpotLight ) spotLights ++;
            if ( light instanceof THREE.HemisphereLight ) hemiLights ++;

        }

        return { 'directional': dirLights, 'point': pointLights, 'spot': spotLights, 'hemi': hemiLights };

    }

    function allocateShadows( lights ) {

        var maxShadows = 0;
        var pointLightShadows = 0;

        for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

            var light = lights[ l ];

            if ( ! light.castShadow ) continue;

            if ( light instanceof THREE.SpotLight || light instanceof THREE.DirectionalLight ) maxShadows ++;
            if ( light instanceof THREE.PointLight ) {

                maxShadows ++;
                pointLightShadows ++;

            }

        }

        return { 'maxShadows': maxShadows, 'pointLightShadows': pointLightShadows };

    }

    this.getParameters = function ( material, lights, fog, object ) {

        var shaderID = shaderIDs[ material.type ];
        // heuristics to create shader parameters according to lights in the scene
        // (not to blow over maxLights budget)

        var maxLightCount = allocateLights( lights );
        var allocatedShadows = allocateShadows( lights );
        var maxBones = allocateBones( object );
        var precision = renderer.getPrecision();

        if ( material.precision !== null ) {

            precision = capabilities.getMaxPrecision( material.precision );

            if ( precision !== material.precision ) {

                console.warn( 'THREE.WebGLRenderer.initMaterial:', material.precision, 'not supported, using', precision, 'instead.' );

            }

        }

        var parameters = {

            shaderID: shaderID,

            precision: precision,
            supportsVertexTextures: capabilities.vertexTextures,

            map: !! material.map,
            envMap: !! material.envMap,
            envMapMode: material.envMap && material.envMap.mapping,
            lightMap: !! material.lightMap,
            aoMap: !! material.aoMap,
            emissiveMap: !! material.emissiveMap,
            bumpMap: !! material.bumpMap,
            normalMap: !! material.normalMap,
            displacementMap: !! material.displacementMap,
            specularMap: !! material.specularMap,
            alphaMap: !! material.alphaMap,

            combine: material.combine,

            vertexColors: material.vertexColors,

            fog: fog,
            useFog: material.fog,
            fogExp: fog instanceof THREE.FogExp2,

            flatShading: material.shading === THREE.FlatShading,

            sizeAttenuation: material.sizeAttenuation,
            logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

            skinning: material.skinning,
            maxBones: maxBones,
            useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,

            morphTargets: material.morphTargets,
            morphNormals: material.morphNormals,
            maxMorphTargets: renderer.maxMorphTargets,
            maxMorphNormals: renderer.maxMorphNormals,

            maxDirLights: maxLightCount.directional,
            maxPointLights: maxLightCount.point,
            maxSpotLights: maxLightCount.spot,
            maxHemiLights: maxLightCount.hemi,

            maxShadows: allocatedShadows.maxShadows,
            pointLightShadows: allocatedShadows.pointLightShadows,
            shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && allocatedShadows.maxShadows > 0,
            shadowMapType: renderer.shadowMap.type,
            shadowMapDebug: renderer.shadowMap.debug,

            alphaTest: material.alphaTest,
            metal: material.metal,
            doubleSided: material.side === THREE.DoubleSide,
            flipSided: material.side === THREE.BackSide

        };

        return parameters;

    };

    this.getProgramCode = function ( material, parameters ) {

        var chunks = [];

        if ( parameters.shaderID ) {

            chunks.push( parameters.shaderID );

        } else {

            chunks.push( material.fragmentShader );
            chunks.push( material.vertexShader );

        }

        if ( material.defines !== undefined ) {

            for ( var name in material.defines ) {

                chunks.push( name );
                chunks.push( material.defines[ name ] );

            }

        }

        for ( var i = 0; i < parameterNames.length; i ++ ) {

            var parameterName = parameterNames[ i ];
            chunks.push( parameterName );
            chunks.push( parameters[ parameterName ] );

        }

        return chunks.join();

    };

    this.acquireProgram = function ( material, parameters, code ) {

        var program;

        // Check if code has been already compiled
        for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

            var programInfo = programs[ p ];

            if ( programInfo.code === code ) {

                program = programInfo;
                ++ program.usedTimes;

                break;

            }

        }

        if ( program === undefined ) {

            program = new THREE.WebGLProgram( renderer, code, material, parameters );
            programs.push( program );

        }

        return program;

    };

    this.releaseProgram = function( program ) {

        if ( -- program.usedTimes === 0 ) {

            // Remove from unordered set
            var i = programs.indexOf( program );
            programs[ i ] = programs[ programs.length - 1 ];
            programs.pop();

            // Free WebGL resources
            program.destroy();

        }

    };

    // Exposed for resource monitoring & error feedback via renderer.info:
    this.programs = programs;

};

// File:src/renderers/webgl/WebGLProperties.js

/**
 * @author fordacious / fordacious.github.io
 */

THREE.WebGLProperties = function () {

    var properties = {};

    this.get = function ( object ) {

        var uuid = object.uuid;
        var map = properties[ uuid ];

        if ( map === undefined ) {

            map = {};
            properties[ uuid ] = map;

        }

        return map;

    };

    this.delete = function ( object ) {

        delete properties[ object.uuid ];

    };

    this.clear = function () {

        properties = {};

    };

};

// File:src/renderers/webgl/WebGLShader.js

THREE.WebGLShader = ( function () {

    function addLineNumbers( string ) {

        var lines = string.split( '\n' );

        for ( var i = 0; i < lines.length; i ++ ) {

            lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

        }

        return lines.join( '\n' );

    }

    return function WebGLShader( gl, type, string ) {

        var shader = gl.createShader( type );

        gl.shaderSource( shader, string );
        gl.compileShader( shader );

        if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

            console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

        }

        if ( gl.getShaderInfoLog( shader ) !== '' ) {

            console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

        }

        // --enable-privileged-webgl-extension
        // console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

        return shader;

    };

} )();

// File:src/renderers/webgl/WebGLShadowMap.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLShadowMap = function ( _renderer, _lights, _objects ) {

    var _gl = _renderer.context,
        _state = _renderer.state,
        _frustum = new THREE.Frustum(),
        _projScreenMatrix = new THREE.Matrix4(),

        _min = new THREE.Vector3(),
        _max = new THREE.Vector3(),

        _lookTarget = new THREE.Vector3(),
        _lightPositionWorld = new THREE.Vector3(),

        _renderList = [],

        _MorphingFlag = 1,
        _SkinningFlag = 2,

        _NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,

        _depthMaterials = new Array( _NumberOfMaterialVariants ),
        _distanceMaterials = new Array( _NumberOfMaterialVariants );

    var cubeDirections = [
        new THREE.Vector3( 1, 0, 0 ), new THREE.Vector3( - 1, 0, 0 ), new THREE.Vector3( 0, 0, 1 ),
        new THREE.Vector3( 0, 0, - 1 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, - 1, 0 )
    ];

    var cubeUps = [
        new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ),
        new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, 1 ),	new THREE.Vector3( 0, 0, - 1 )
    ];

    var cube2DViewPorts = [
        new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(),
        new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()
    ];

    var _vector4 = new THREE.Vector4();

    // init

    var depthShader = THREE.ShaderLib[ "depthRGBA" ];
    var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

    var distanceShader = THREE.ShaderLib[ "distanceRGBA" ];
    var distanceUniforms = THREE.UniformsUtils.clone( distanceShader.uniforms );

    for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {

        var useMorphing = ( i & _MorphingFlag ) !== 0;
        var useSkinning = ( i & _SkinningFlag ) !== 0;

        var depthMaterial = new THREE.ShaderMaterial( {
            uniforms: depthUniforms,
            vertexShader: depthShader.vertexShader,
            fragmentShader: depthShader.fragmentShader,
            morphTargets: useMorphing,
            skinning: useSkinning
        } );

        depthMaterial._shadowPass = true;

        _depthMaterials[ i ] = depthMaterial;

        var distanceMaterial = new THREE.ShaderMaterial( {
            uniforms: distanceUniforms,
            vertexShader: distanceShader.vertexShader,
            fragmentShader: distanceShader.fragmentShader,
            morphTargets: useMorphing,
            skinning: useSkinning
        } );

        distanceMaterial._shadowPass = true;

        _distanceMaterials[ i ] = distanceMaterial;

    }

    //

    var scope = this;

    this.enabled = false;

    this.autoUpdate = true;
    this.needsUpdate = false;

    this.type = THREE.PCFShadowMap;
    this.cullFace = THREE.CullFaceFront;

    this.render = function ( scene ) {

        var faceCount, isPointLight;

        if ( scope.enabled === false ) return;
        if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

        // Set GL state for depth map.
        _gl.clearColor( 1, 1, 1, 1 );
        _state.disable( _gl.BLEND );
        _state.enable( _gl.CULL_FACE );
        _gl.frontFace( _gl.CCW );
        _gl.cullFace( scope.cullFace === THREE.CullFaceFront ? _gl.FRONT : _gl.BACK );
        _state.setDepthTest( true );

        // save the existing viewport so it can be restored later
        _renderer.getViewport( _vector4 );

        // render depth map

        for ( var i = 0, il = _lights.length; i < il; i ++ ) {

            var light = _lights[ i ];

            if ( light.castShadow === true ) {

                var shadow = light.shadow;
                var shadowCamera = shadow.camera;
                var shadowMapSize = shadow.mapSize;

                if ( light instanceof THREE.PointLight ) {

                    faceCount = 6;
                    isPointLight = true;

                    var vpWidth = shadowMapSize.x / 4.0;
                    var vpHeight = shadowMapSize.y / 2.0;

                    // These viewports map a cube-map onto a 2D texture with the
                    // following orientation:
                    //
                    //  xzXZ
                    //   y Y
                    //
                    // X - Positive x direction
                    // x - Negative x direction
                    // Y - Positive y direction
                    // y - Negative y direction
                    // Z - Positive z direction
                    // z - Negative z direction

                    // positive X
                    cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
                    // negative X
                    cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
                    // positive Z
                    cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
                    // negative Z
                    cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
                    // positive Y
                    cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
                    // negative Y
                    cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );

                } else {

                    faceCount = 1;
                    isPointLight = false;

                }

                if ( shadow.map === null ) {

                    var shadowFilter = THREE.LinearFilter;

                    if ( scope.type === THREE.PCFSoftShadowMap ) {

                        shadowFilter = THREE.NearestFilter;

                    }

                    var pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };

                    shadow.map = new THREE.WebGLRenderTarget( shadowMapSize.x, shadowMapSize.y, pars );
                    shadow.matrix = new THREE.Matrix4();

                    //

                    if ( light instanceof THREE.SpotLight ) {

                        shadowCamera.aspect = shadowMapSize.x / shadowMapSize.y;

                    }

                    shadowCamera.updateProjectionMatrix();

                }

                var shadowMap = shadow.map;
                var shadowMatrix = shadow.matrix;

                _lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
                shadowCamera.position.copy( _lightPositionWorld );

                _renderer.setRenderTarget( shadowMap );
                _renderer.clear();

                // render shadow map for each cube face (if omni-directional) or
                // run a single pass if not

                for ( var face = 0; face < faceCount; face ++ ) {

                    if ( isPointLight ) {

                        _lookTarget.copy( shadowCamera.position );
                        _lookTarget.add( cubeDirections[ face ] );
                        shadowCamera.up.copy( cubeUps[ face ] );
                        shadowCamera.lookAt( _lookTarget );
                        var vpDimensions = cube2DViewPorts[ face ];
                        _renderer.setViewport( vpDimensions.x, vpDimensions.y, vpDimensions.z, vpDimensions.w );

                    } else {

                        _lookTarget.setFromMatrixPosition( light.target.matrixWorld );
                        shadowCamera.lookAt( _lookTarget );

                    }

                    shadowCamera.updateMatrixWorld();
                    shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

                    // compute shadow matrix

                    shadowMatrix.set(
                        0.5, 0.0, 0.0, 0.5,
                        0.0, 0.5, 0.0, 0.5,
                        0.0, 0.0, 0.5, 0.5,
                        0.0, 0.0, 0.0, 1.0
                    );

                    shadowMatrix.multiply( shadowCamera.projectionMatrix );
                    shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

                    // update camera matrices and frustum

                    _projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
                    _frustum.setFromMatrix( _projScreenMatrix );

                    // set object matrices & frustum culling

                    _renderList.length = 0;

                    projectObject( scene, shadowCamera );

                    // render shadow map
                    // render regular objects

                    for ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {

                        var object = _renderList[ j ];
                        var geometry = _objects.update( object );
                        var material = object.material;

                        if ( material instanceof THREE.MeshFaceMaterial ) {

                            var groups = geometry.groups;
                            var materials = material.materials;

                            for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

                                var group = groups[ k ];
                                var groupMaterial = materials[ group.materialIndex ];

                                if ( groupMaterial.visible === true ) {

                                    var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );
                                    _renderer.renderBufferDirect( shadowCamera, _lights, null, geometry, depthMaterial, object, group );

                                }

                            }

                        } else {

                            var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );
                            _renderer.renderBufferDirect( shadowCamera, _lights, null, geometry, depthMaterial, object, null );

                        }

                    }

                }

                // We must call _renderer.resetGLState() at the end of each iteration of
                // the light loop in order to force material updates for each light.
                _renderer.resetGLState();

            }

        }

        _renderer.setViewport( _vector4.x, _vector4.y, _vector4.z, _vector4.w );

        // Restore GL state.
        var clearColor = _renderer.getClearColor(),
            clearAlpha = _renderer.getClearAlpha();
        _renderer.setClearColor( clearColor, clearAlpha );
        _state.enable( _gl.BLEND );

        if ( scope.cullFace === THREE.CullFaceFront ) {

            _gl.cullFace( _gl.BACK );

        }

        _renderer.resetGLState();

        scope.needsUpdate = false;

    };

    function getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {

        var geometry = object.geometry;

        var newMaterial = null;

        var materialVariants = _depthMaterials;
        var customMaterial = object.customDepthMaterial;

        if ( isPointLight ) {

            materialVariants = _distanceMaterials;
            customMaterial = object.customDistanceMaterial;

        }

        if ( ! customMaterial ) {

            var useMorphing = geometry.morphTargets !== undefined &&
                geometry.morphTargets.length > 0 && material.morphTargets;

            var useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;

            var variantIndex = 0;

            if ( useMorphing ) variantIndex |= _MorphingFlag;
            if ( useSkinning ) variantIndex |= _SkinningFlag;

            newMaterial = materialVariants[ variantIndex ];

        } else {

            newMaterial = customMaterial;

        }

        newMaterial.visible = material.visible;
        newMaterial.wireframe = material.wireframe;
        newMaterial.wireframeLinewidth = material.wireframeLinewidth;

        if ( isPointLight && newMaterial.uniforms.lightPos !== undefined ) {

            newMaterial.uniforms.lightPos.value.copy( lightPositionWorld );

        }

        return newMaterial;

    }

    function projectObject( object, camera ) {

        if ( object.visible === false ) return;

        if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {

            if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

                var material = object.material;

                if ( material.visible === true ) {

                    object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
                    _renderList.push( object );

                }

            }

        }

        var children = object.children;

        for ( var i = 0, l = children.length; i < l; i ++ ) {

            projectObject( children[ i ], camera );

        }

    }

};

// File:src/renderers/webgl/WebGLState.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLState = function ( gl, extensions, paramThreeToGL ) {

    var _this = this;

    var newAttributes = new Uint8Array( 16 );
    var enabledAttributes = new Uint8Array( 16 );
    var attributeDivisors = new Uint8Array( 16 );

    var capabilities = {};

    var compressedTextureFormats = null;

    var currentBlending = null;
    var currentBlendEquation = null;
    var currentBlendSrc = null;
    var currentBlendDst = null;
    var currentBlendEquationAlpha = null;
    var currentBlendSrcAlpha = null;
    var currentBlendDstAlpha = null;

    var currentDepthFunc = null;
    var currentDepthWrite = null;

    var currentColorWrite = null;

    var currentFlipSided = null;

    var currentLineWidth = null;

    var currentPolygonOffsetFactor = null;
    var currentPolygonOffsetUnits = null;

    var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );

    var currentTextureSlot = undefined;
    var currentBoundTextures = {};

    this.init = function () {

        gl.clearColor( 0, 0, 0, 1 );
        gl.clearDepth( 1 );
        gl.clearStencil( 0 );

        this.enable( gl.DEPTH_TEST );
        gl.depthFunc( gl.LEQUAL );

        gl.frontFace( gl.CCW );
        gl.cullFace( gl.BACK );
        this.enable( gl.CULL_FACE );

        this.enable( gl.BLEND );
        gl.blendEquation( gl.FUNC_ADD );
        gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );

    };

    this.initAttributes = function () {

        for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

            newAttributes[ i ] = 0;

        }

    };

    this.enableAttribute = function ( attribute ) {

        newAttributes[ attribute ] = 1;

        if ( enabledAttributes[ attribute ] === 0 ) {

            gl.enableVertexAttribArray( attribute );
            enabledAttributes[ attribute ] = 1;

        }

        if ( attributeDivisors[ attribute ] !== 0 ) {

            var extension = extensions.get( 'ANGLE_instanced_arrays' );

            extension.vertexAttribDivisorANGLE( attribute, 0 );
            attributeDivisors[ attribute ] = 0;

        }

    };

    this.enableAttributeAndDivisor = function ( attribute, meshPerAttribute, extension ) {

        newAttributes[ attribute ] = 1;

        if ( enabledAttributes[ attribute ] === 0 ) {

            gl.enableVertexAttribArray( attribute );
            enabledAttributes[ attribute ] = 1;

        }

        if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

            extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
            attributeDivisors[ attribute ] = meshPerAttribute;

        }

    };

    this.disableUnusedAttributes = function () {

        for ( var i = 0, l = enabledAttributes.length; i < l; i ++ ) {

            if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

                gl.disableVertexAttribArray( i );
                enabledAttributes[ i ] = 0;

            }

        }

    };

    this.enable = function ( id ) {

        if ( capabilities[ id ] !== true ) {

            gl.enable( id );
            capabilities[ id ] = true;

        }

    };

    this.disable = function ( id ) {

        if ( capabilities[ id ] !== false ) {

            gl.disable( id );
            capabilities[ id ] = false;

        }

    };

    this.getCompressedTextureFormats = function () {

        if ( compressedTextureFormats === null ) {

            compressedTextureFormats = [];

            if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
                extensions.get( 'WEBGL_compressed_texture_s3tc' ) ) {

                var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

                for ( var i = 0; i < formats.length; i ++ ) {

                    compressedTextureFormats.push( formats[ i ] );

                }

            }

        }

        return compressedTextureFormats;

    };

    this.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha ) {

        if ( blending !== currentBlending ) {

            if ( blending === THREE.NoBlending ) {

                this.disable( gl.BLEND );

            } else if ( blending === THREE.AdditiveBlending ) {

                this.enable( gl.BLEND );
                gl.blendEquation( gl.FUNC_ADD );
                gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

            } else if ( blending === THREE.SubtractiveBlending ) {

                // TODO: Find blendFuncSeparate() combination

                this.enable( gl.BLEND );
                gl.blendEquation( gl.FUNC_ADD );
                gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

            } else if ( blending === THREE.MultiplyBlending ) {

                // TODO: Find blendFuncSeparate() combination

                this.enable( gl.BLEND );
                gl.blendEquation( gl.FUNC_ADD );
                gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

            } else if ( blending === THREE.CustomBlending ) {

                this.enable( gl.BLEND );

            } else {

                this.enable( gl.BLEND );
                gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
                gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

            }

            currentBlending = blending;

        }

        if ( blending === THREE.CustomBlending ) {

            blendEquationAlpha = blendEquationAlpha || blendEquation;
            blendSrcAlpha = blendSrcAlpha || blendSrc;
            blendDstAlpha = blendDstAlpha || blendDst;

            if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

                gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );

                currentBlendEquation = blendEquation;
                currentBlendEquationAlpha = blendEquationAlpha;

            }

            if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

                gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );

                currentBlendSrc = blendSrc;
                currentBlendDst = blendDst;
                currentBlendSrcAlpha = blendSrcAlpha;
                currentBlendDstAlpha = blendDstAlpha;

            }

        } else {

            currentBlendEquation = null;
            currentBlendSrc = null;
            currentBlendDst = null;
            currentBlendEquationAlpha = null;
            currentBlendSrcAlpha = null;
            currentBlendDstAlpha = null;

        }

    };

    this.setDepthFunc = function ( depthFunc ) {

        if ( currentDepthFunc !== depthFunc ) {

            if ( depthFunc ) {

                switch ( depthFunc ) {

                    case THREE.NeverDepth:

                        gl.depthFunc( gl.NEVER );
                        break;

                    case THREE.AlwaysDepth:

                        gl.depthFunc( gl.ALWAYS );
                        break;

                    case THREE.LessDepth:

                        gl.depthFunc( gl.LESS );
                        break;

                    case THREE.LessEqualDepth:

                        gl.depthFunc( gl.LEQUAL );
                        break;

                    case THREE.EqualDepth:

                        gl.depthFunc( gl.EQUAL );
                        break;

                    case THREE.GreaterEqualDepth:

                        gl.depthFunc( gl.GEQUAL );
                        break;

                    case THREE.GreaterDepth:

                        gl.depthFunc( gl.GREATER );
                        break;

                    case THREE.NotEqualDepth:

                        gl.depthFunc( gl.NOTEQUAL );
                        break;

                    default:

                        gl.depthFunc( gl.LEQUAL );

                }

            } else {

                gl.depthFunc( gl.LEQUAL );

            }

            currentDepthFunc = depthFunc;

        }

    };

    this.setDepthTest = function ( depthTest ) {

        if ( depthTest ) {

            this.enable( gl.DEPTH_TEST );

        } else {

            this.disable( gl.DEPTH_TEST );

        }

    };

    this.setDepthWrite = function ( depthWrite ) {

        if ( currentDepthWrite !== depthWrite ) {

            gl.depthMask( depthWrite );
            currentDepthWrite = depthWrite;

        }

    };

    this.setColorWrite = function ( colorWrite ) {

        if ( currentColorWrite !== colorWrite ) {

            gl.colorMask( colorWrite, colorWrite, colorWrite, colorWrite );
            currentColorWrite = colorWrite;

        }

    };

    this.setFlipSided = function ( flipSided ) {

        if ( currentFlipSided !== flipSided ) {

            if ( flipSided ) {

                gl.frontFace( gl.CW );

            } else {

                gl.frontFace( gl.CCW );

            }

            currentFlipSided = flipSided;

        }

    };

    this.setLineWidth = function ( width ) {

        if ( width !== currentLineWidth ) {

            gl.lineWidth( width );

            currentLineWidth = width;

        }

    };

    this.setPolygonOffset = function ( polygonOffset, factor, units ) {

        if ( polygonOffset ) {

            this.enable( gl.POLYGON_OFFSET_FILL );

        } else {

            this.disable( gl.POLYGON_OFFSET_FILL );

        }

        if ( polygonOffset && ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) ) {

            gl.polygonOffset( factor, units );

            currentPolygonOffsetFactor = factor;
            currentPolygonOffsetUnits = units;

        }

    };

    this.setScissorTest = function ( scissorTest ) {

        if ( scissorTest ) {

            this.enable( gl.SCISSOR_TEST );

        } else {

            this.disable( gl.SCISSOR_TEST );

        }

    };

    // texture

    this.activeTexture = function ( webglSlot ) {

        if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

        if ( currentTextureSlot !== webglSlot ) {

            gl.activeTexture( webglSlot );
            currentTextureSlot = webglSlot;

        }

    }

    this.bindTexture = function ( webglType, webglTexture ) {

        if ( currentTextureSlot === undefined ) {

            _this.activeTexture();

        }

        var boundTexture = currentBoundTextures[ currentTextureSlot ];

        if ( boundTexture === undefined ) {

            boundTexture = { type: undefined, texture: undefined };
            currentBoundTextures[ currentTextureSlot ] = boundTexture;

        }

        if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

            gl.bindTexture( webglType, webglTexture );

            boundTexture.type = webglType;
            boundTexture.texture = webglTexture;

        }

    };

    this.compressedTexImage2D = function () {

        try {

            gl.compressedTexImage2D.apply( gl, arguments );

        } catch ( error ) {

            console.error( error );

        }

    };

    this.texImage2D = function () {

        try {

            gl.texImage2D.apply( gl, arguments );

        } catch ( error ) {

            console.error( error );

        }

    };

    //

    this.reset = function () {

        for ( var i = 0; i < enabledAttributes.length; i ++ ) {

            if ( enabledAttributes[ i ] === 1 ) {

                gl.disableVertexAttribArray( i );
                enabledAttributes[ i ] = 0;

            }

        }

        capabilities = {};

        compressedTextureFormats = null;

        currentBlending = null;

        currentDepthWrite = null;
        currentColorWrite = null;

        currentFlipSided = null;

    };

};

// File:src/renderers/webgl/plugins/LensFlarePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlarePlugin = function ( renderer, flares ) {

    var gl = renderer.context;
    var state = renderer.state;

    var vertexBuffer, elementBuffer;
    var program, attributes, uniforms;
    var hasVertexTexture;

    var tempTexture, occlusionTexture;

    function init() {

        var vertices = new Float32Array( [
            - 1, - 1,  0, 0,
            1, - 1,  1, 0,
            1,  1,  1, 1,
            - 1,  1,  0, 1
        ] );

        var faces = new Uint16Array( [
            0, 1, 2,
            0, 2, 3
        ] );

        // buffers

        vertexBuffer     = gl.createBuffer();
        elementBuffer    = gl.createBuffer();

        gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
        gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

        gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
        gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

        // textures

        tempTexture      = gl.createTexture();
        occlusionTexture = gl.createTexture();

        state.bindTexture( gl.TEXTURE_2D, tempTexture );
        gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

        state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
        gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

        hasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;

        var shader;

        if ( hasVertexTexture ) {

            shader = {

                vertexShader: [

                    "uniform lowp int renderType;",

                    "uniform vec3 screenPosition;",
                    "uniform vec2 scale;",
                    "uniform float rotation;",

                    "uniform sampler2D occlusionMap;",

                    "attribute vec2 position;",
                    "attribute vec2 uv;",

                    "varying vec2 vUV;",
                    "varying float vVisibility;",

                    "void main() {",

                    "vUV = uv;",

                    "vec2 pos = position;",

                    "if ( renderType == 2 ) {",

                    "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

                    "vVisibility =        visibility.r / 9.0;",
                    "vVisibility *= 1.0 - visibility.g / 9.0;",
                    "vVisibility *=       visibility.b / 9.0;",
                    "vVisibility *= 1.0 - visibility.a / 9.0;",

                    "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
                    "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

                    "}",

                    "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

                    "}"

                ].join( "\n" ),

                fragmentShader: [

                    "uniform lowp int renderType;",

                    "uniform sampler2D map;",
                    "uniform float opacity;",
                    "uniform vec3 color;",

                    "varying vec2 vUV;",
                    "varying float vVisibility;",

                    "void main() {",

                    // pink square

                    "if ( renderType == 0 ) {",

                    "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

                    // restore

                    "} else if ( renderType == 1 ) {",

                    "gl_FragColor = texture2D( map, vUV );",

                    // flare

                    "} else {",

                    "vec4 texture = texture2D( map, vUV );",
                    "texture.a *= opacity * vVisibility;",
                    "gl_FragColor = texture;",
                    "gl_FragColor.rgb *= color;",

                    "}",

                    "}"

                ].join( "\n" )

            };

        } else {

            shader = {

                vertexShader: [

                    "uniform lowp int renderType;",

                    "uniform vec3 screenPosition;",
                    "uniform vec2 scale;",
                    "uniform float rotation;",

                    "attribute vec2 position;",
                    "attribute vec2 uv;",

                    "varying vec2 vUV;",

                    "void main() {",

                    "vUV = uv;",

                    "vec2 pos = position;",

                    "if ( renderType == 2 ) {",

                    "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
                    "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

                    "}",

                    "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

                    "}"

                ].join( "\n" ),

                fragmentShader: [

                    "precision mediump float;",

                    "uniform lowp int renderType;",

                    "uniform sampler2D map;",
                    "uniform sampler2D occlusionMap;",
                    "uniform float opacity;",
                    "uniform vec3 color;",

                    "varying vec2 vUV;",

                    "void main() {",

                    // pink square

                    "if ( renderType == 0 ) {",

                    "gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",

                    // restore

                    "} else if ( renderType == 1 ) {",

                    "gl_FragColor = texture2D( map, vUV );",

                    // flare

                    "} else {",

                    "float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
                    "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
                    "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
                    "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
                    "visibility = ( 1.0 - visibility / 4.0 );",

                    "vec4 texture = texture2D( map, vUV );",
                    "texture.a *= opacity * visibility;",
                    "gl_FragColor = texture;",
                    "gl_FragColor.rgb *= color;",

                    "}",

                    "}"

                ].join( "\n" )

            };

        }

        program = createProgram( shader );

        attributes = {
            vertex: gl.getAttribLocation ( program, "position" ),
            uv:     gl.getAttribLocation ( program, "uv" )
        };

        uniforms = {
            renderType:     gl.getUniformLocation( program, "renderType" ),
            map:            gl.getUniformLocation( program, "map" ),
            occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
            opacity:        gl.getUniformLocation( program, "opacity" ),
            color:          gl.getUniformLocation( program, "color" ),
            scale:          gl.getUniformLocation( program, "scale" ),
            rotation:       gl.getUniformLocation( program, "rotation" ),
            screenPosition: gl.getUniformLocation( program, "screenPosition" )
        };

    }

    /*
     * Render lens flares
     * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
     *         reads these back and calculates occlusion.
     */

    this.render = function ( scene, camera, viewportWidth, viewportHeight ) {

        if ( flares.length === 0 ) return;

        var tempPosition = new THREE.Vector3();

        var invAspect = viewportHeight / viewportWidth,
            halfViewportWidth = viewportWidth * 0.5,
            halfViewportHeight = viewportHeight * 0.5;

        var size = 16 / viewportHeight,
            scale = new THREE.Vector2( size * invAspect, size );

        var screenPosition = new THREE.Vector3( 1, 1, 0 ),
            screenPositionPixels = new THREE.Vector2( 1, 1 );

        if ( program === undefined ) {

            init();

        }

        gl.useProgram( program );

        state.initAttributes();
        state.enableAttribute( attributes.vertex );
        state.enableAttribute( attributes.uv );
        state.disableUnusedAttributes();

        // loop through all lens flares to update their occlusion and positions
        // setup gl and common used attribs/uniforms

        gl.uniform1i( uniforms.occlusionMap, 0 );
        gl.uniform1i( uniforms.map, 1 );

        gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
        gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
        gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

        gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

        state.disable( gl.CULL_FACE );
        gl.depthMask( false );

        for ( var i = 0, l = flares.length; i < l; i ++ ) {

            size = 16 / viewportHeight;
            scale.set( size * invAspect, size );

            // calc object screen position

            var flare = flares[ i ];

            tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );

            tempPosition.applyMatrix4( camera.matrixWorldInverse );
            tempPosition.applyProjection( camera.projectionMatrix );

            // setup arrays for gl programs

            screenPosition.copy( tempPosition );

            screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
            screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;

            // screen cull

            if ( hasVertexTexture || (
                screenPositionPixels.x > 0 &&
                screenPositionPixels.x < viewportWidth &&
                screenPositionPixels.y > 0 &&
                screenPositionPixels.y < viewportHeight ) ) {

                // save current RGB to temp texture

                state.activeTexture( gl.TEXTURE0 );
                state.bindTexture( gl.TEXTURE_2D, null );
                state.activeTexture( gl.TEXTURE1 );
                state.bindTexture( gl.TEXTURE_2D, tempTexture );
                gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


                // render pink quad

                gl.uniform1i( uniforms.renderType, 0 );
                gl.uniform2f( uniforms.scale, scale.x, scale.y );
                gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

                state.disable( gl.BLEND );
                state.enable( gl.DEPTH_TEST );

                gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


                // copy result to occlusionMap

                state.activeTexture( gl.TEXTURE0 );
                state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
                gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


                // restore graphics

                gl.uniform1i( uniforms.renderType, 1 );
                state.disable( gl.DEPTH_TEST );

                state.activeTexture( gl.TEXTURE1 );
                state.bindTexture( gl.TEXTURE_2D, tempTexture );
                gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


                // update object positions

                flare.positionScreen.copy( screenPosition );

                if ( flare.customUpdateCallback ) {

                    flare.customUpdateCallback( flare );

                } else {

                    flare.updateLensFlares();

                }

                // render flares

                gl.uniform1i( uniforms.renderType, 2 );
                state.enable( gl.BLEND );

                for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

                    var sprite = flare.lensFlares[ j ];

                    if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

                        screenPosition.x = sprite.x;
                        screenPosition.y = sprite.y;
                        screenPosition.z = sprite.z;

                        size = sprite.size * sprite.scale / viewportHeight;

                        scale.x = size * invAspect;
                        scale.y = size;

                        gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
                        gl.uniform2f( uniforms.scale, scale.x, scale.y );
                        gl.uniform1f( uniforms.rotation, sprite.rotation );

                        gl.uniform1f( uniforms.opacity, sprite.opacity );
                        gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

                        state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
                        renderer.setTexture( sprite.texture, 1 );

                        gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

                    }

                }

            }

        }

        // restore gl

        state.enable( gl.CULL_FACE );
        state.enable( gl.DEPTH_TEST );
        gl.depthMask( true );

        renderer.resetGLState();

    };

    function createProgram ( shader ) {

        var program = gl.createProgram();

        var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
        var vertexShader = gl.createShader( gl.VERTEX_SHADER );

        var prefix = "precision " + renderer.getPrecision() + " float;\n";

        gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
        gl.shaderSource( vertexShader, prefix + shader.vertexShader );

        gl.compileShader( fragmentShader );
        gl.compileShader( vertexShader );

        gl.attachShader( program, fragmentShader );
        gl.attachShader( program, vertexShader );

        gl.linkProgram( program );

        return program;

    }

};

// File:src/renderers/webgl/plugins/SpritePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpritePlugin = function ( renderer, sprites ) {

    var gl = renderer.context;
    var state = renderer.state;

    var vertexBuffer, elementBuffer;
    var program, attributes, uniforms;

    var texture;

    // decompose matrixWorld

    var spritePosition = new THREE.Vector3();
    var spriteRotation = new THREE.Quaternion();
    var spriteScale = new THREE.Vector3();

    function init() {

        var vertices = new Float32Array( [
            - 0.5, - 0.5,  0, 0,
            0.5, - 0.5,  1, 0,
            0.5,   0.5,  1, 1,
            - 0.5,   0.5,  0, 1
        ] );

        var faces = new Uint16Array( [
            0, 1, 2,
            0, 2, 3
        ] );

        vertexBuffer  = gl.createBuffer();
        elementBuffer = gl.createBuffer();

        gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
        gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

        gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
        gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

        program = createProgram();

        attributes = {
            position:			gl.getAttribLocation ( program, 'position' ),
            uv:					gl.getAttribLocation ( program, 'uv' )
        };

        uniforms = {
            uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
            uvScale:			gl.getUniformLocation( program, 'uvScale' ),

            rotation:			gl.getUniformLocation( program, 'rotation' ),
            scale:				gl.getUniformLocation( program, 'scale' ),

            color:				gl.getUniformLocation( program, 'color' ),
            map:				gl.getUniformLocation( program, 'map' ),
            opacity:			gl.getUniformLocation( program, 'opacity' ),

            modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
            projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),

            fogType:			gl.getUniformLocation( program, 'fogType' ),
            fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
            fogNear:			gl.getUniformLocation( program, 'fogNear' ),
            fogFar:				gl.getUniformLocation( program, 'fogFar' ),
            fogColor:			gl.getUniformLocation( program, 'fogColor' ),

            alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
        };

        var canvas = document.createElement( 'canvas' );
        canvas.width = 8;
        canvas.height = 8;

        var context = canvas.getContext( '2d' );
        context.fillStyle = 'white';
        context.fillRect( 0, 0, 8, 8 );

        texture = new THREE.Texture( canvas );
        texture.needsUpdate = true;

    }

    this.render = function ( scene, camera ) {

        if ( sprites.length === 0 ) return;

        // setup gl

        if ( program === undefined ) {

            init();

        }

        gl.useProgram( program );

        state.initAttributes();
        state.enableAttribute( attributes.position );
        state.enableAttribute( attributes.uv );
        state.disableUnusedAttributes();

        state.disable( gl.CULL_FACE );
        state.enable( gl.BLEND );

        gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
        gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
        gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

        gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

        gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

        state.activeTexture( gl.TEXTURE0 );
        gl.uniform1i( uniforms.map, 0 );

        var oldFogType = 0;
        var sceneFogType = 0;
        var fog = scene.fog;

        if ( fog ) {

            gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

            if ( fog instanceof THREE.Fog ) {

                gl.uniform1f( uniforms.fogNear, fog.near );
                gl.uniform1f( uniforms.fogFar, fog.far );

                gl.uniform1i( uniforms.fogType, 1 );
                oldFogType = 1;
                sceneFogType = 1;

            } else if ( fog instanceof THREE.FogExp2 ) {

                gl.uniform1f( uniforms.fogDensity, fog.density );

                gl.uniform1i( uniforms.fogType, 2 );
                oldFogType = 2;
                sceneFogType = 2;

            }

        } else {

            gl.uniform1i( uniforms.fogType, 0 );
            oldFogType = 0;
            sceneFogType = 0;

        }


        // update positions and sort

        for ( var i = 0, l = sprites.length; i < l; i ++ ) {

            var sprite = sprites[ i ];

            sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
            sprite.z = - sprite.modelViewMatrix.elements[ 14 ];

        }

        sprites.sort( painterSortStable );

        // render all sprites

        var scale = [];

        for ( var i = 0, l = sprites.length; i < l; i ++ ) {

            var sprite = sprites[ i ];
            var material = sprite.material;

            gl.uniform1f( uniforms.alphaTest, material.alphaTest );
            gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );

            sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

            scale[ 0 ] = spriteScale.x;
            scale[ 1 ] = spriteScale.y;

            var fogType = 0;

            if ( scene.fog && material.fog ) {

                fogType = sceneFogType;

            }

            if ( oldFogType !== fogType ) {

                gl.uniform1i( uniforms.fogType, fogType );
                oldFogType = fogType;

            }

            if ( material.map !== null ) {

                gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
                gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

            } else {

                gl.uniform2f( uniforms.uvOffset, 0, 0 );
                gl.uniform2f( uniforms.uvScale, 1, 1 );

            }

            gl.uniform1f( uniforms.opacity, material.opacity );
            gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

            gl.uniform1f( uniforms.rotation, material.rotation );
            gl.uniform2fv( uniforms.scale, scale );

            state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
            state.setDepthTest( material.depthTest );
            state.setDepthWrite( material.depthWrite );

            if ( material.map && material.map.image && material.map.image.width ) {

                renderer.setTexture( material.map, 0 );

            } else {

                renderer.setTexture( texture, 0 );

            }

            gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

        }

        // restore gl

        state.enable( gl.CULL_FACE );

        renderer.resetGLState();

    };

    function createProgram () {

        var program = gl.createProgram();

        var vertexShader = gl.createShader( gl.VERTEX_SHADER );
        var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

        gl.shaderSource( vertexShader, [

            'precision ' + renderer.getPrecision() + ' float;',

            'uniform mat4 modelViewMatrix;',
            'uniform mat4 projectionMatrix;',
            'uniform float rotation;',
            'uniform vec2 scale;',
            'uniform vec2 uvOffset;',
            'uniform vec2 uvScale;',

            'attribute vec2 position;',
            'attribute vec2 uv;',

            'varying vec2 vUV;',

            'void main() {',

            'vUV = uvOffset + uv * uvScale;',

            'vec2 alignedPosition = position * scale;',

            'vec2 rotatedPosition;',
            'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
            'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

            'vec4 finalPosition;',

            'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
            'finalPosition.xy += rotatedPosition;',
            'finalPosition = projectionMatrix * finalPosition;',

            'gl_Position = finalPosition;',

            '}'

        ].join( '\n' ) );

        gl.shaderSource( fragmentShader, [

            'precision ' + renderer.getPrecision() + ' float;',

            'uniform vec3 color;',
            'uniform sampler2D map;',
            'uniform float opacity;',

            'uniform int fogType;',
            'uniform vec3 fogColor;',
            'uniform float fogDensity;',
            'uniform float fogNear;',
            'uniform float fogFar;',
            'uniform float alphaTest;',

            'varying vec2 vUV;',

            'void main() {',

            'vec4 texture = texture2D( map, vUV );',

            'if ( texture.a < alphaTest ) discard;',

            'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

            'if ( fogType > 0 ) {',

            'float depth = gl_FragCoord.z / gl_FragCoord.w;',
            'float fogFactor = 0.0;',

            'if ( fogType == 1 ) {',

            'fogFactor = smoothstep( fogNear, fogFar, depth );',

            '} else {',

            'const float LOG2 = 1.442695;',
            'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
            'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

            '}',

            'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

            '}',

            '}'

        ].join( '\n' ) );

        gl.compileShader( vertexShader );
        gl.compileShader( fragmentShader );

        gl.attachShader( program, vertexShader );
        gl.attachShader( program, fragmentShader );

        gl.linkProgram( program );

        return program;

    }

    function painterSortStable ( a, b ) {

        if ( a.z !== b.z ) {

            return b.z - a.z;

        } else {

            return b.id - a.id;

        }

    }

};

// File:src/extras/CurveUtils.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.CurveUtils = {

    tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

        return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

    },

    // Puay Bing, thanks for helping with this derivative!

    tangentCubicBezier: function ( t, p0, p1, p2, p3 ) {

        return - 3 * p0 * ( 1 - t ) * ( 1 - t )  +
            3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +
            6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +
            3 * t * t * p3;

    },

    tangentSpline: function ( t, p0, p1, p2, p3 ) {

        // To check if my formulas are correct

        var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3 ? 3t^2 + 1
        var h10 = 3 * t * t - 4 * t + 1; // t^3 ? 2t^2 + t
        var h01 = - 6 * t * t + 6 * t; 	// ? 2t3 + 3t2
        var h11 = 3 * t * t - 2 * t;	// t3 ? t2

        return h00 + h10 + h01 + h11;

    },

    // Catmull-Rom

    interpolate: function( p0, p1, p2, p3, t ) {

        var v0 = ( p2 - p0 ) * 0.5;
        var v1 = ( p3 - p1 ) * 0.5;
        var t2 = t * t;
        var t3 = t * t2;
        return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

    }

};

// File:src/extras/GeometryUtils.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GeometryUtils = {

    merge: function ( geometry1, geometry2, materialIndexOffset ) {

        console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );

        var matrix;

        if ( geometry2 instanceof THREE.Mesh ) {

            geometry2.matrixAutoUpdate && geometry2.updateMatrix();

            matrix = geometry2.matrix;
            geometry2 = geometry2.geometry;

        }

        geometry1.merge( geometry2, matrix, materialIndexOffset );

    },

    center: function ( geometry ) {

        console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
        return geometry.center();

    }

};

// File:src/extras/ImageUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author Daosheng Mu / https://github.com/DaoshengMu/
 */

THREE.ImageUtils = {

    crossOrigin: undefined,

    loadTexture: function ( url, mapping, onLoad, onError ) {

        console.warn( 'THREE.ImageUtils.loadTexture is being deprecated. Use THREE.TextureLoader() instead.' );

        var loader = new THREE.TextureLoader();
        loader.setCrossOrigin( this.crossOrigin );

        var texture = loader.load( url, onLoad, undefined, onError );

        if ( mapping ) texture.mapping = mapping;

        return texture;

    },

    loadTextureCube: function ( urls, mapping, onLoad, onError ) {

        console.warn( 'THREE.ImageUtils.loadTextureCube is being deprecated. Use THREE.CubeTextureLoader() instead.' );

        var loader = new THREE.CubeTextureLoader();
        loader.setCrossOrigin( this.crossOrigin );

        var texture = loader.load( urls, onLoad, undefined, onError );

        if ( mapping ) texture.mapping = mapping;

        return texture;

    },

    loadCompressedTexture: function () {

        console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' )

    },

    loadCompressedTextureCube: function () {

        console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' )

    }

};

// File:src/extras/SceneUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SceneUtils = {

    createMultiMaterialObject: function ( geometry, materials ) {

        var group = new THREE.Group();

        for ( var i = 0, l = materials.length; i < l; i ++ ) {

            group.add( new THREE.Mesh( geometry, materials[ i ] ) );

        }

        return group;

    },

    detach: function ( child, parent, scene ) {

        child.applyMatrix( parent.matrixWorld );
        parent.remove( child );
        scene.add( child );

    },

    attach: function ( child, scene, parent ) {

        var matrixWorldInverse = new THREE.Matrix4();
        matrixWorldInverse.getInverse( parent.matrixWorld );
        child.applyMatrix( matrixWorldInverse );

        scene.remove( child );
        parent.add( child );

    }

};

// File:src/extras/ShapeUtils.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.ShapeUtils = {

    // calculate area of the contour polygon

    area: function ( contour ) {

        var n = contour.length;
        var a = 0.0;

        for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

            a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

        }

        return a * 0.5;

    },

    triangulate: ( function () {

        /**
         * This code is a quick port of code written in C++ which was submitted to
         * flipcode.com by John W. Ratcliff  // July 22, 2000
         * See original code and more information here:
         * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
         *
         * ported to actionscript by Zevan Rosser
         * www.actionsnippet.com
         *
         * ported to javascript by Joshua Koo
         * http://www.lab4games.net/zz85/blog
         *
         */

        function snip( contour, u, v, w, n, verts ) {

            var p;
            var ax, ay, bx, by;
            var cx, cy, px, py;

            ax = contour[ verts[ u ] ].x;
            ay = contour[ verts[ u ] ].y;

            bx = contour[ verts[ v ] ].x;
            by = contour[ verts[ v ] ].y;

            cx = contour[ verts[ w ] ].x;
            cy = contour[ verts[ w ] ].y;

            if ( Number.EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;

            var aX, aY, bX, bY, cX, cY;
            var apx, apy, bpx, bpy, cpx, cpy;
            var cCROSSap, bCROSScp, aCROSSbp;

            aX = cx - bx;  aY = cy - by;
            bX = ax - cx;  bY = ay - cy;
            cX = bx - ax;  cY = by - ay;

            for ( p = 0; p < n; p ++ ) {

                px = contour[ verts[ p ] ].x;
                py = contour[ verts[ p ] ].y;

                if ( ( ( px === ax ) && ( py === ay ) ) ||
                    ( ( px === bx ) && ( py === by ) ) ||
                    ( ( px === cx ) && ( py === cy ) ) )	continue;

                apx = px - ax;  apy = py - ay;
                bpx = px - bx;  bpy = py - by;
                cpx = px - cx;  cpy = py - cy;

                // see if p is inside triangle abc

                aCROSSbp = aX * bpy - aY * bpx;
                cCROSSap = cX * apy - cY * apx;
                bCROSScp = bX * cpy - bY * cpx;

                if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;

            }

            return true;

        }

        // takes in an contour array and returns

        return function ( contour, indices ) {

            var n = contour.length;

            if ( n < 3 ) return null;

            var result = [],
                verts = [],
                vertIndices = [];

            /* we want a counter-clockwise polygon in verts */

            var u, v, w;

            if ( THREE.ShapeUtils.area( contour ) > 0.0 ) {

                for ( v = 0; v < n; v ++ ) verts[ v ] = v;

            } else {

                for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

            }

            var nv = n;

            /*  remove nv - 2 vertices, creating 1 triangle every time */

            var count = 2 * nv;   /* error detection */

            for ( v = nv - 1; nv > 2; ) {

                /* if we loop, it is probably a non-simple polygon */

                if ( ( count -- ) <= 0 ) {

                    //** Triangulate: ERROR - probable bad polygon!

                    //throw ( "Warning, unable to triangulate polygon!" );
                    //return null;
                    // Sometimes warning is fine, especially polygons are triangulated in reverse.
                    console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );

                    if ( indices ) return vertIndices;
                    return result;

                }

                /* three consecutive vertices in current polygon, <u,v,w> */

                u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
                v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
                w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

                if ( snip( contour, u, v, w, nv, verts ) ) {

                    var a, b, c, s, t;

                    /* true names of the vertices */

                    a = verts[ u ];
                    b = verts[ v ];
                    c = verts[ w ];

                    /* output Triangle */

                    result.push( [ contour[ a ],
                        contour[ b ],
                        contour[ c ] ] );


                    vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

                    /* remove v from the remaining polygon */

                    for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {

                        verts[ s ] = verts[ t ];

                    }

                    nv --;

                    /* reset error detection counter */

                    count = 2 * nv;

                }

            }

            if ( indices ) return vertIndices;
            return result;

        }

    } )(),

    triangulateShape: function ( contour, holes ) {

        function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {

            // inOtherPt needs to be collinear to the inSegment
            if ( inSegPt1.x !== inSegPt2.x ) {

                if ( inSegPt1.x < inSegPt2.x ) {

                    return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );

                } else {

                    return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );

                }

            } else {

                if ( inSegPt1.y < inSegPt2.y ) {

                    return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );

                } else {

                    return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );

                }

            }

        }

        function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {

            var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
            var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

            var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
            var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

            var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
            var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

            if ( Math.abs( limit ) > Number.EPSILON ) {

                // not parallel

                var perpSeg2;
                if ( limit > 0 ) {

                    if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
                    perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
                    if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];

                } else {

                    if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
                    perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
                    if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];

                }

                // i.e. to reduce rounding errors
                // intersection at endpoint of segment#1?
                if ( perpSeg2 === 0 ) {

                    if ( ( inExcludeAdjacentSegs ) &&
                        ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
                    return [ inSeg1Pt1 ];

                }
                if ( perpSeg2 === limit ) {

                    if ( ( inExcludeAdjacentSegs ) &&
                        ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
                    return [ inSeg1Pt2 ];

                }
                // intersection at endpoint of segment#2?
                if ( perpSeg1 === 0 )		return [ inSeg2Pt1 ];
                if ( perpSeg1 === limit )	return [ inSeg2Pt2 ];

                // return real intersection point
                var factorSeg1 = perpSeg2 / limit;
                return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
                    y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

            } else {

                // parallel or collinear
                if ( ( perpSeg1 !== 0 ) ||
                    ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			return [];

                // they are collinear or degenerate
                var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );	// segment1 is just a point?
                var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );	// segment2 is just a point?
                // both segments are points
                if ( seg1Pt && seg2Pt ) {

                    if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
                        ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		return [];	// they are distinct  points
                    return [ inSeg1Pt1 ];                 						// they are the same point

                }
                // segment#1  is a single point
                if ( seg1Pt ) {

                    if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
                    return [ inSeg1Pt1 ];

                }
                // segment#2  is a single point
                if ( seg2Pt ) {

                    if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
                    return [ inSeg2Pt1 ];

                }

                // they are collinear segments, which might overlap
                var seg1min, seg1max, seg1minVal, seg1maxVal;
                var seg2min, seg2max, seg2minVal, seg2maxVal;
                if ( seg1dx !== 0 ) {

                    // the segments are NOT on a vertical line
                    if ( inSeg1Pt1.x < inSeg1Pt2.x ) {

                        seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
                        seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;

                    } else {

                        seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
                        seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;

                    }
                    if ( inSeg2Pt1.x < inSeg2Pt2.x ) {

                        seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
                        seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;

                    } else {

                        seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
                        seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;

                    }

                } else {

                    // the segments are on a vertical line
                    if ( inSeg1Pt1.y < inSeg1Pt2.y ) {

                        seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
                        seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;

                    } else {

                        seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
                        seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;

                    }
                    if ( inSeg2Pt1.y < inSeg2Pt2.y ) {

                        seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
                        seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;

                    } else {

                        seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
                        seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;

                    }

                }
                if ( seg1minVal <= seg2minVal ) {

                    if ( seg1maxVal <  seg2minVal )	return [];
                    if ( seg1maxVal === seg2minVal )	{

                        if ( inExcludeAdjacentSegs )		return [];
                        return [ seg2min ];

                    }
                    if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
                    return	[ seg2min, seg2max ];

                } else {

                    if ( seg1minVal >  seg2maxVal )	return [];
                    if ( seg1minVal === seg2maxVal )	{

                        if ( inExcludeAdjacentSegs )		return [];
                        return [ seg1min ];

                    }
                    if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
                    return	[ seg1min, seg2max ];

                }

            }

        }

        function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {

            // The order of legs is important

            // translation of all points, so that Vertex is at (0,0)
            var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
            var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
            var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;

            // main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
            var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
            var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;

            if ( Math.abs( from2toAngle ) > Number.EPSILON ) {

                // angle != 180 deg.

                var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
                // console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

                if ( from2toAngle > 0 ) {

                    // main angle < 180 deg.
                    return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );

                } else {

                    // main angle > 180 deg.
                    return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );

                }

            } else {

                // angle == 180 deg.
                // console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
                return	( from2otherAngle > 0 );

            }

        }


        function removeHoles( contour, holes ) {

            var shape = contour.concat(); // work on this shape
            var hole;

            function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {

                // Check if hole point lies within angle around shape point
                var lastShapeIdx = shape.length - 1;

                var prevShapeIdx = inShapeIdx - 1;
                if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;

                var nextShapeIdx = inShapeIdx + 1;
                if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;

                var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
                if ( ! insideAngle ) {

                    // console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
                    return	false;

                }

                // Check if shape point lies within angle around hole point
                var lastHoleIdx = hole.length - 1;

                var prevHoleIdx = inHoleIdx - 1;
                if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;

                var nextHoleIdx = inHoleIdx + 1;
                if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;

                insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
                if ( ! insideAngle ) {

                    // console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
                    return	false;

                }

                return	true;

            }

            function intersectsShapeEdge( inShapePt, inHolePt ) {

                // checks for intersections with shape edges
                var sIdx, nextIdx, intersection;
                for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {

                    nextIdx = sIdx + 1; nextIdx %= shape.length;
                    intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
                    if ( intersection.length > 0 )		return	true;

                }

                return	false;

            }

            var indepHoles = [];

            function intersectsHoleEdge( inShapePt, inHolePt ) {

                // checks for intersections with hole edges
                var ihIdx, chkHole,
                    hIdx, nextIdx, intersection;
                for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {

                    chkHole = holes[ indepHoles[ ihIdx ]];
                    for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {

                        nextIdx = hIdx + 1; nextIdx %= chkHole.length;
                        intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
                        if ( intersection.length > 0 )		return	true;

                    }

                }
                return	false;

            }

            var holeIndex, shapeIndex,
                shapePt, holePt,
                holeIdx, cutKey, failedCuts = [],
                tmpShape1, tmpShape2,
                tmpHole1, tmpHole2;

            for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

                indepHoles.push( h );

            }

            var minShapeIndex = 0;
            var counter = indepHoles.length * 2;
            while ( indepHoles.length > 0 ) {

                counter --;
                if ( counter < 0 ) {

                    console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
                    break;

                }

                // search for shape-vertex and hole-vertex,
                // which can be connected without intersections
                for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

                    shapePt = shape[ shapeIndex ];
                    holeIndex	= - 1;

                    // search for hole which can be reached without intersections
                    for ( var h = 0; h < indepHoles.length; h ++ ) {

                        holeIdx = indepHoles[ h ];

                        // prevent multiple checks
                        cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
                        if ( failedCuts[ cutKey ] !== undefined )			continue;

                        hole = holes[ holeIdx ];
                        for ( var h2 = 0; h2 < hole.length; h2 ++ ) {

                            holePt = hole[ h2 ];
                            if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
                            if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
                            if ( intersectsHoleEdge( shapePt, holePt ) )		continue;

                            holeIndex = h2;
                            indepHoles.splice( h, 1 );

                            tmpShape1 = shape.slice( 0, shapeIndex + 1 );
                            tmpShape2 = shape.slice( shapeIndex );
                            tmpHole1 = hole.slice( holeIndex );
                            tmpHole2 = hole.slice( 0, holeIndex + 1 );

                            shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

                            minShapeIndex = shapeIndex;

                            // Debug only, to show the selected cuts
                            // glob_CutLines.push( [ shapePt, holePt ] );

                            break;

                        }
                        if ( holeIndex >= 0 )	break;		// hole-vertex found

                        failedCuts[ cutKey ] = true;			// remember failure

                    }
                    if ( holeIndex >= 0 )	break;		// hole-vertex found

                }

            }

            return shape; 			/* shape with no holes */

        }


        var i, il, f, face,
            key, index,
            allPointsMap = {};

        // To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

        var allpoints = contour.concat();

        for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

            Array.prototype.push.apply( allpoints, holes[ h ] );

        }

        //console.log( "allpoints",allpoints, allpoints.length );

        // prepare all points map

        for ( i = 0, il = allpoints.length; i < il; i ++ ) {

            key = allpoints[ i ].x + ":" + allpoints[ i ].y;

            if ( allPointsMap[ key ] !== undefined ) {

                console.warn( "THREE.Shape: Duplicate point", key );

            }

            allPointsMap[ key ] = i;

        }

        // remove holes by cutting paths to holes and adding them to the shape
        var shapeWithoutHoles = removeHoles( contour, holes );

        var triangles = THREE.ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
        //console.log( "triangles",triangles, triangles.length );

        // check all face vertices against all points map

        for ( i = 0, il = triangles.length; i < il; i ++ ) {

            face = triangles[ i ];

            for ( f = 0; f < 3; f ++ ) {

                key = face[ f ].x + ":" + face[ f ].y;

                index = allPointsMap[ key ];

                if ( index !== undefined ) {

                    face[ f ] = index;

                }

            }

        }

        return triangles.concat();

    },

    isClockWise: function ( pts ) {

        return THREE.ShapeUtils.area( pts ) < 0;

    },

    // Bezier Curves formulas obtained from
    // http://en.wikipedia.org/wiki/B%C3%A9zier_curve

    // Quad Bezier Functions

    b2: ( function () {

        function b2p0( t, p ) {

            var k = 1 - t;
            return k * k * p;

        }

        function b2p1( t, p ) {

            return 2 * ( 1 - t ) * t * p;

        }

        function b2p2( t, p ) {

            return t * t * p;

        }

        return function ( t, p0, p1, p2 ) {

            return b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );

        };

    } )(),

    // Cubic Bezier Functions

    b3: ( function () {

        function b3p0( t, p ) {

            var k = 1 - t;
            return k * k * k * p;

        }

        function b3p1( t, p ) {

            var k = 1 - t;
            return 3 * k * k * t * p;

        }

        function b3p2( t, p ) {

            var k = 1 - t;
            return 3 * k * t * t * p;

        }

        function b3p3( t, p ) {

            return t * t * t * p;

        }

        return function ( t, p0, p1, p2, p3 ) {

            return b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );

        };

    } )()

};

// File:src/extras/audio/Audio.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Audio = function ( listener ) {

    THREE.Object3D.call( this );

    this.type = 'Audio';

    this.context = listener.context;
    this.source = this.context.createBufferSource();
    this.source.onended = this.onEnded.bind( this );

    this.gain = this.context.createGain();
    this.gain.connect( this.context.destination );

    this.panner = this.context.createPanner();
    this.panner.connect( this.gain );

    this.autoplay = false;

    this.startTime = 0;
    this.playbackRate = 1;
    this.isPlaying = false;

};

THREE.Audio.prototype = Object.create( THREE.Object3D.prototype );
THREE.Audio.prototype.constructor = THREE.Audio;

THREE.Audio.prototype.load = function ( file ) {

    var scope = this;

    var request = new XMLHttpRequest();
    request.open( 'GET', file, true );
    request.responseType = 'arraybuffer';
    request.onload = function ( e ) {

        scope.context.decodeAudioData( this.response, function ( buffer ) {

            scope.source.buffer = buffer;

            if ( scope.autoplay ) scope.play();

        } );

    };
    request.send();

    return this;

};

THREE.Audio.prototype.play = function () {

    if ( this.isPlaying === true ) {

        console.warn( 'THREE.Audio: Audio is already playing.' );
        return;

    }

    var source = this.context.createBufferSource();

    source.buffer = this.source.buffer;
    source.loop = this.source.loop;
    source.onended = this.source.onended;
    source.start( 0, this.startTime );
    source.playbackRate.value = this.playbackRate;

    this.isPlaying = true;

    this.source = source;

    this.connect();

};

THREE.Audio.prototype.pause = function () {

    this.source.stop();
    this.startTime = this.context.currentTime;

};

THREE.Audio.prototype.stop = function () {

    this.source.stop();
    this.startTime = 0;

};

THREE.Audio.prototype.connect = function () {

    if ( this.filter !== undefined ) {

        this.source.connect( this.filter );
        this.filter.connect( this.panner );

    } else {

        this.source.connect( this.panner );

    }

};

THREE.Audio.prototype.disconnect = function () {

    if ( this.filter !== undefined ) {

        this.source.disconnect( this.filter );
        this.filter.disconnect( this.panner );

    } else {

        this.source.disconnect( this.panner );

    }

};

THREE.Audio.prototype.setFilter = function ( value ) {

    if ( this.isPlaying === true ) {

        this.disconnect();
        this.filter = value;
        this.connect();

    } else {

        this.filter = value;

    }

};

THREE.Audio.prototype.getFilter = function () {

    return this.filter;

};

THREE.Audio.prototype.setPlaybackRate = function ( value ) {

    this.playbackRate = value;

    if ( this.isPlaying === true ) {

        this.source.playbackRate.value = this.playbackRate;

    }

};

THREE.Audio.prototype.getPlaybackRate = function () {

    return this.playbackRate;

};

THREE.Audio.prototype.onEnded = function() {

    this.isPlaying = false;

};

THREE.Audio.prototype.setLoop = function ( value ) {

    this.source.loop = value;

};

THREE.Audio.prototype.getLoop = function () {

    return this.source.loop;

};

THREE.Audio.prototype.setRefDistance = function ( value ) {

    this.panner.refDistance = value;

};

THREE.Audio.prototype.getRefDistance = function () {

    return this.panner.refDistance;

};

THREE.Audio.prototype.setRolloffFactor = function ( value ) {

    this.panner.rolloffFactor = value;

};

THREE.Audio.prototype.getRolloffFactor = function () {

    return this.panner.rolloffFactor;

};

THREE.Audio.prototype.setVolume = function ( value ) {

    this.gain.gain.value = value;

};

THREE.Audio.prototype.getVolume = function () {

    return this.gain.gain.value;

};

THREE.Audio.prototype.updateMatrixWorld = ( function () {

    var position = new THREE.Vector3();

    return function updateMatrixWorld( force ) {

        THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

        position.setFromMatrixPosition( this.matrixWorld );

        this.panner.setPosition( position.x, position.y, position.z );

    };

} )();

// File:src/extras/audio/AudioListener.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AudioListener = function () {

    THREE.Object3D.call( this );

    this.type = 'AudioListener';

    this.context = new ( window.AudioContext || window.webkitAudioContext )();

};

THREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );
THREE.AudioListener.prototype.constructor = THREE.AudioListener;

THREE.AudioListener.prototype.updateMatrixWorld = ( function () {

    var position = new THREE.Vector3();
    var quaternion = new THREE.Quaternion();
    var scale = new THREE.Vector3();

    var orientation = new THREE.Vector3();

    return function updateMatrixWorld( force ) {

        THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

        var listener = this.context.listener;
        var up = this.up;

        this.matrixWorld.decompose( position, quaternion, scale );

        orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );

        listener.setPosition( position.x, position.y, position.z );
        listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

    };

} )();

// File:src/extras/core/Curve.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of Curve methods
 * .getPoint(t), getTangent(t)
 * .getPointAt(u), getTagentAt(u)
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following classes subclasses THREE.Curve:
 *
 * -- 2d classes --
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.CubicBezierCurve
 * THREE.SplineCurve
 * THREE.ArcCurve
 * THREE.EllipseCurve
 *
 * -- 3d classes --
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 * THREE.CubicBezierCurve3
 * THREE.SplineCurve3
 * THREE.ClosedSplineCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath
 *
 **/

/**************************************************************
 *	Abstract Curve base class
 **************************************************************/

THREE.Curve = function () {

};

THREE.Curve.prototype = {

    constructor: THREE.Curve,

    // Virtual base class method to overwrite and implement in subclasses
    //	- t [0 .. 1]

    getPoint: function ( t ) {

        console.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
        return null;

    },

    // Get point at relative position in curve according to arc length
    // - u [0 .. 1]

    getPointAt: function ( u ) {

        var t = this.getUtoTmapping( u );
        return this.getPoint( t );

    },

    // Get sequence of points using getPoint( t )

    getPoints: function ( divisions ) {

        if ( ! divisions ) divisions = 5;

        var d, pts = [];

        for ( d = 0; d <= divisions; d ++ ) {

            pts.push( this.getPoint( d / divisions ) );

        }

        return pts;

    },

    // Get sequence of points using getPointAt( u )

    getSpacedPoints: function ( divisions ) {

        if ( ! divisions ) divisions = 5;

        var d, pts = [];

        for ( d = 0; d <= divisions; d ++ ) {

            pts.push( this.getPointAt( d / divisions ) );

        }

        return pts;

    },

    // Get total curve arc length

    getLength: function () {

        var lengths = this.getLengths();
        return lengths[ lengths.length - 1 ];

    },

    // Get list of cumulative segment lengths

    getLengths: function ( divisions ) {

        if ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;

        if ( this.cacheArcLengths
            && ( this.cacheArcLengths.length === divisions + 1 )
            && ! this.needsUpdate ) {

            //console.log( "cached", this.cacheArcLengths );
            return this.cacheArcLengths;

        }

        this.needsUpdate = false;

        var cache = [];
        var current, last = this.getPoint( 0 );
        var p, sum = 0;

        cache.push( 0 );

        for ( p = 1; p <= divisions; p ++ ) {

            current = this.getPoint ( p / divisions );
            sum += current.distanceTo( last );
            cache.push( sum );
            last = current;

        }

        this.cacheArcLengths = cache;

        return cache; // { sums: cache, sum:sum }; Sum is in the last element.

    },

    updateArcLengths: function() {

        this.needsUpdate = true;
        this.getLengths();

    },

    // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

    getUtoTmapping: function ( u, distance ) {

        var arcLengths = this.getLengths();

        var i = 0, il = arcLengths.length;

        var targetArcLength; // The targeted u distance value to get

        if ( distance ) {

            targetArcLength = distance;

        } else {

            targetArcLength = u * arcLengths[ il - 1 ];

        }

        //var time = Date.now();

        // binary search for the index with largest value smaller than target u distance

        var low = 0, high = il - 1, comparison;

        while ( low <= high ) {

            i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

            comparison = arcLengths[ i ] - targetArcLength;

            if ( comparison < 0 ) {

                low = i + 1;

            } else if ( comparison > 0 ) {

                high = i - 1;

            } else {

                high = i;
                break;

                // DONE

            }

        }

        i = high;

        //console.log('b' , i, low, high, Date.now()- time);

        if ( arcLengths[ i ] === targetArcLength ) {

            var t = i / ( il - 1 );
            return t;

        }

        // we could get finer grain at lengths, or use simple interpolation between two points

        var lengthBefore = arcLengths[ i ];
        var lengthAfter = arcLengths[ i + 1 ];

        var segmentLength = lengthAfter - lengthBefore;

        // determine where we are between the 'before' and 'after' points

        var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

        // add that fractional amount to t

        var t = ( i + segmentFraction ) / ( il - 1 );

        return t;

    },

    // Returns a unit vector tangent at t
    // In case any sub curve does not implement its tangent derivation,
    // 2 points a small delta apart will be used to find its gradient
    // which seems to give a reasonable approximation

    getTangent: function( t ) {

        var delta = 0.0001;
        var t1 = t - delta;
        var t2 = t + delta;

        // Capping in case of danger

        if ( t1 < 0 ) t1 = 0;
        if ( t2 > 1 ) t2 = 1;

        var pt1 = this.getPoint( t1 );
        var pt2 = this.getPoint( t2 );

        var vec = pt2.clone().sub( pt1 );
        return vec.normalize();

    },

    getTangentAt: function ( u ) {

        var t = this.getUtoTmapping( u );
        return this.getTangent( t );

    }

}

THREE.Curve.Utils = THREE.CurveUtils; // backwards compatibility

// TODO: Transformation for Curves?

/**************************************************************
 *	3D Curves
 **************************************************************/

// A Factory method for creating new curve subclasses

THREE.Curve.create = function ( constructor, getPointFunc ) {

    constructor.prototype = Object.create( THREE.Curve.prototype );
    constructor.prototype.constructor = constructor;
    constructor.prototype.getPoint = getPointFunc;

    return constructor;

};

// File:src/extras/core/CurvePath.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

THREE.CurvePath = function () {

    this.curves = [];

    this.autoClose = false; // Automatically closes the path

};

THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );
THREE.CurvePath.prototype.constructor = THREE.CurvePath;

THREE.CurvePath.prototype.add = function ( curve ) {

    this.curves.push( curve );

};

/*
 THREE.CurvePath.prototype.checkConnection = function() {
 // TODO
 // If the ending of curve is not connected to the starting
 // or the next curve, then, this is not a real path
 };
 */

THREE.CurvePath.prototype.closePath = function() {

    // TODO Test
    // and verify for vector3 (needs to implement equals)
    // Add a line curve if start and end of lines are not connected
    var startPoint = this.curves[ 0 ].getPoint( 0 );
    var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

    if ( ! startPoint.equals( endPoint ) ) {

        this.curves.push( new THREE.LineCurve( endPoint, startPoint ) );

    }

};

// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:

// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')

THREE.CurvePath.prototype.getPoint = function( t ) {

    var d = t * this.getLength();
    var curveLengths = this.getCurveLengths();
    var i = 0;

    // To think about boundaries points.

    while ( i < curveLengths.length ) {

        if ( curveLengths[ i ] >= d ) {

            var diff = curveLengths[ i ] - d;
            var curve = this.curves[ i ];

            var u = 1 - diff / curve.getLength();

            return curve.getPointAt( u );

        }

        i ++;

    }

    return null;

    // loop where sum != 0, sum > d , sum+1 <d

};

/*
 THREE.CurvePath.prototype.getTangent = function( t ) {
 };
 */

// We cannot use the default THREE.Curve getPoint() with getLength() because in
// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
// getPoint() depends on getLength

THREE.CurvePath.prototype.getLength = function() {

    var lens = this.getCurveLengths();
    return lens[ lens.length - 1 ];

};

// Compute lengths and cache them
// We cannot overwrite getLengths() because UtoT mapping uses it.

THREE.CurvePath.prototype.getCurveLengths = function() {

    // We use cache values if curves and cache array are same length

    if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

        return this.cacheLengths;

    }

    // Get length of sub-curve
    // Push sums into cached array

    var lengths = [], sums = 0;

    for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

        sums += this.curves[ i ].getLength();
        lengths.push( sums );

    }

    this.cacheLengths = lengths;

    return lengths;

};



/**************************************************************
 *	Create Geometries Helpers
 **************************************************************/

/// Generate geometry from path points (for Line or Points objects)

THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {

    var pts = this.getPoints( divisions, true );
    return this.createGeometry( pts );

};

// Generate geometry from equidistant sampling along the path

THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {

    var pts = this.getSpacedPoints( divisions, true );
    return this.createGeometry( pts );

};

THREE.CurvePath.prototype.createGeometry = function( points ) {

    var geometry = new THREE.Geometry();

    for ( var i = 0, l = points.length; i < l; i ++ ) {

        var point = points[ i ];
        geometry.vertices.push( new THREE.Vector3( point.x, point.y, point.z || 0 ) );

    }

    return geometry;

};

// File:src/extras/core/Path.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 *
 **/

THREE.Path = function ( points ) {

    THREE.CurvePath.call( this );

    this.actions = [];

    if ( points ) {

        this.fromPoints( points );

    }

};

THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );
THREE.Path.prototype.constructor = THREE.Path;

// TODO Clean up PATH API

// Create path using straight lines to connect all points
// - vectors: array of Vector2

THREE.Path.prototype.fromPoints = function ( vectors ) {

    this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

    for ( var i = 1, l = vectors.length; i < l; i ++ ) {

        this.lineTo( vectors[ i ].x, vectors[ i ].y );

    }

};

// startPath() endPath()?

THREE.Path.prototype.moveTo = function ( x, y ) {

    this.actions.push( { action: 'moveTo', args: [ x, y ] } );

};

THREE.Path.prototype.lineTo = function ( x, y ) {

    var lastargs = this.actions[ this.actions.length - 1 ].args;

    var x0 = lastargs[ lastargs.length - 2 ];
    var y0 = lastargs[ lastargs.length - 1 ];

    var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
    this.curves.push( curve );

    this.actions.push( { action: 'lineTo', args: [ x, y ] } );

};

THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {

    var lastargs = this.actions[ this.actions.length - 1 ].args;

    var x0 = lastargs[ lastargs.length - 2 ];
    var y0 = lastargs[ lastargs.length - 1 ];

    var curve = new THREE.QuadraticBezierCurve(
        new THREE.Vector2( x0, y0 ),
        new THREE.Vector2( aCPx, aCPy ),
        new THREE.Vector2( aX, aY )
    );

    this.curves.push( curve );

    this.actions.push( { action: 'quadraticCurveTo', args: [ aCPx, aCPy, aX, aY ] } );

};

THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

    var lastargs = this.actions[ this.actions.length - 1 ].args;

    var x0 = lastargs[ lastargs.length - 2 ];
    var y0 = lastargs[ lastargs.length - 1 ];

    var curve = new THREE.CubicBezierCurve(
        new THREE.Vector2( x0, y0 ),
        new THREE.Vector2( aCP1x, aCP1y ),
        new THREE.Vector2( aCP2x, aCP2y ),
        new THREE.Vector2( aX, aY )
    );

    this.curves.push( curve );

    this.actions.push( { action: 'bezierCurveTo', args: [ aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ] } );

};

THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {

    var args = Array.prototype.slice.call( arguments );

    var lastargs = this.actions[ this.actions.length - 1 ].args;

    var x0 = lastargs[ lastargs.length - 2 ];
    var y0 = lastargs[ lastargs.length - 1 ];

    var npts = [ new THREE.Vector2( x0, y0 ) ];
    Array.prototype.push.apply( npts, pts );

    var curve = new THREE.SplineCurve( npts );
    this.curves.push( curve );

    this.actions.push( { action: 'splineThru', args: args } );

};

// FUTURE: Change the API or follow canvas API?

THREE.Path.prototype.arc = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

    var lastargs = this.actions[ this.actions.length - 1 ].args;
    var x0 = lastargs[ lastargs.length - 2 ];
    var y0 = lastargs[ lastargs.length - 1 ];

    this.absarc( aX + x0, aY + y0, aRadius,
        aStartAngle, aEndAngle, aClockwise );

};

THREE.Path.prototype.absarc = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

    this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

};

THREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

    var lastargs = this.actions[ this.actions.length - 1 ].args;
    var x0 = lastargs[ lastargs.length - 2 ];
    var y0 = lastargs[ lastargs.length - 1 ];

    this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

};


THREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

    var args = [
        aX, aY,
        xRadius, yRadius,
        aStartAngle, aEndAngle,
        aClockwise,
        aRotation || 0 // aRotation is optional.
    ];

    var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
    this.curves.push( curve );

    var lastPoint = curve.getPoint( 1 );
    args.push( lastPoint.x );
    args.push( lastPoint.y );

    this.actions.push( { action: 'ellipse', args: args } );

};

THREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {

    if ( ! divisions ) divisions = 40;

    var points = [];

    for ( var i = 0; i < divisions; i ++ ) {

        points.push( this.getPoint( i / divisions ) );

        //if ( !this.getPoint( i / divisions ) ) throw "DIE";

    }

    // if ( closedPath ) {
    //
    // 	points.push( points[ 0 ] );
    //
    // }

    return points;

};

/* Return an array of vectors based on contour of the path */

THREE.Path.prototype.getPoints = function( divisions, closedPath ) {

    divisions = divisions || 12;

    var b2 = THREE.ShapeUtils.b2;
    var b3 = THREE.ShapeUtils.b3;

    var points = [];

    var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
        laste, tx, ty;

    for ( var i = 0, l = this.actions.length; i < l; i ++ ) {

        var item = this.actions[ i ];

        var action = item.action;
        var args = item.args;

        switch ( action ) {

            case 'moveTo':

                points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

                break;

            case 'lineTo':

                points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

                break;

            case 'quadraticCurveTo':

                cpx  = args[ 2 ];
                cpy  = args[ 3 ];

                cpx1 = args[ 0 ];
                cpy1 = args[ 1 ];

                if ( points.length > 0 ) {

                    laste = points[ points.length - 1 ];

                    cpx0 = laste.x;
                    cpy0 = laste.y;

                } else {

                    laste = this.actions[ i - 1 ].args;

                    cpx0 = laste[ laste.length - 2 ];
                    cpy0 = laste[ laste.length - 1 ];

                }

                for ( var j = 1; j <= divisions; j ++ ) {

                    var t = j / divisions;

                    tx = b2( t, cpx0, cpx1, cpx );
                    ty = b2( t, cpy0, cpy1, cpy );

                    points.push( new THREE.Vector2( tx, ty ) );

                }

                break;

            case 'bezierCurveTo':

                cpx  = args[ 4 ];
                cpy  = args[ 5 ];

                cpx1 = args[ 0 ];
                cpy1 = args[ 1 ];

                cpx2 = args[ 2 ];
                cpy2 = args[ 3 ];

                if ( points.length > 0 ) {

                    laste = points[ points.length - 1 ];

                    cpx0 = laste.x;
                    cpy0 = laste.y;

                } else {

                    laste = this.actions[ i - 1 ].args;

                    cpx0 = laste[ laste.length - 2 ];
                    cpy0 = laste[ laste.length - 1 ];

                }


                for ( var j = 1; j <= divisions; j ++ ) {

                    var t = j / divisions;

                    tx = b3( t, cpx0, cpx1, cpx2, cpx );
                    ty = b3( t, cpy0, cpy1, cpy2, cpy );

                    points.push( new THREE.Vector2( tx, ty ) );

                }

                break;

            case 'splineThru':

                laste = this.actions[ i - 1 ].args;

                var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
                var spts = [ last ];

                var n = divisions * args[ 0 ].length;

                spts = spts.concat( args[ 0 ] );

                var spline = new THREE.SplineCurve( spts );

                for ( var j = 1; j <= n; j ++ ) {

                    points.push( spline.getPointAt( j / n ) );

                }

                break;

            case 'arc':

                var aX = args[ 0 ], aY = args[ 1 ],
                    aRadius = args[ 2 ],
                    aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
                    aClockwise = !! args[ 5 ];

                var deltaAngle = aEndAngle - aStartAngle;
                var angle;
                var tdivisions = divisions * 2;

                for ( var j = 1; j <= tdivisions; j ++ ) {

                    var t = j / tdivisions;

                    if ( ! aClockwise ) {

                        t = 1 - t;

                    }

                    angle = aStartAngle + t * deltaAngle;

                    tx = aX + aRadius * Math.cos( angle );
                    ty = aY + aRadius * Math.sin( angle );

                    //console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

                    points.push( new THREE.Vector2( tx, ty ) );

                }

                //console.log(points);

                break;

            case 'ellipse':

                var aX = args[ 0 ], aY = args[ 1 ],
                    xRadius = args[ 2 ],
                    yRadius = args[ 3 ],
                    aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],
                    aClockwise = !! args[ 6 ],
                    aRotation = args[ 7 ];


                var deltaAngle = aEndAngle - aStartAngle;
                var angle;
                var tdivisions = divisions * 2;

                var cos, sin;
                if ( aRotation !== 0 ) {

                    cos = Math.cos( aRotation );
                    sin = Math.sin( aRotation );

                }

                for ( var j = 1; j <= tdivisions; j ++ ) {

                    var t = j / tdivisions;

                    if ( ! aClockwise ) {

                        t = 1 - t;

                    }

                    angle = aStartAngle + t * deltaAngle;

                    tx = aX + xRadius * Math.cos( angle );
                    ty = aY + yRadius * Math.sin( angle );

                    if ( aRotation !== 0 ) {

                        var x = tx, y = ty;

                        // Rotate the point about the center of the ellipse.
                        tx = ( x - aX ) * cos - ( y - aY ) * sin + aX;
                        ty = ( x - aX ) * sin + ( y - aY ) * cos + aY;

                    }

                    //console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

                    points.push( new THREE.Vector2( tx, ty ) );

                }

                //console.log(points);

                break;

        } // end switch

    }



    // Normalize to remove the closing point by default.
    var lastPoint = points[ points.length - 1 ];
    if ( Math.abs( lastPoint.x - points[ 0 ].x ) < Number.EPSILON &&
        Math.abs( lastPoint.y - points[ 0 ].y ) < Number.EPSILON )
        points.splice( points.length - 1, 1 );
    if ( closedPath ) {

        points.push( points[ 0 ] );

    }

    return points;

};

//
// Breaks path into shapes
//
//	Assumptions (if parameter isCCW==true the opposite holds):
//	- solid shapes are defined clockwise (CW)
//	- holes are defined counterclockwise (CCW)
//
//	If parameter noHoles==true:
//  - all subPaths are regarded as solid shapes
//  - definition order CW/CCW has no relevance
//

THREE.Path.prototype.toShapes = function( isCCW, noHoles ) {

    function extractSubpaths( inActions ) {

        var subPaths = [], lastPath = new THREE.Path();

        for ( var i = 0, l = inActions.length; i < l; i ++ ) {

            var item = inActions[ i ];

            var args = item.args;
            var action = item.action;

            if ( action === 'moveTo' ) {

                if ( lastPath.actions.length !== 0 ) {

                    subPaths.push( lastPath );
                    lastPath = new THREE.Path();

                }

            }

            lastPath[ action ].apply( lastPath, args );

        }

        if ( lastPath.actions.length !== 0 ) {

            subPaths.push( lastPath );

        }

        // console.log(subPaths);

        return	subPaths;

    }

    function toShapesNoHoles( inSubpaths ) {

        var shapes = [];

        for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

            var tmpPath = inSubpaths[ i ];

            var tmpShape = new THREE.Shape();
            tmpShape.actions = tmpPath.actions;
            tmpShape.curves = tmpPath.curves;

            shapes.push( tmpShape );

        }

        //console.log("shape", shapes);

        return shapes;

    }

    function isPointInsidePolygon( inPt, inPolygon ) {

        var polyLen = inPolygon.length;

        // inPt on polygon contour => immediate success    or
        // toggling of inside/outside at every single! intersection point of an edge
        //  with the horizontal line through inPt, left of inPt
        //  not counting lowerY endpoints of edges and whole edges on that line
        var inside = false;
        for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

            var edgeLowPt  = inPolygon[ p ];
            var edgeHighPt = inPolygon[ q ];

            var edgeDx = edgeHighPt.x - edgeLowPt.x;
            var edgeDy = edgeHighPt.y - edgeLowPt.y;

            if ( Math.abs( edgeDy ) > Number.EPSILON ) {

                // not parallel
                if ( edgeDy < 0 ) {

                    edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
                    edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

                }
                if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

                if ( inPt.y === edgeLowPt.y ) {

                    if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
                    // continue;				// no intersection or edgeLowPt => doesn't count !!!

                } else {

                    var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
                    if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
                    if ( perpEdge < 0 ) 				continue;
                    inside = ! inside;		// true intersection left of inPt

                }

            } else {

                // parallel or collinear
                if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
                // edge lies on the same horizontal line as inPt
                if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
                    ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
                // continue;

            }

        }

        return	inside;

    }

    var isClockWise = THREE.ShapeUtils.isClockWise;

    var subPaths = extractSubpaths( this.actions );
    if ( subPaths.length === 0 ) return [];

    if ( noHoles === true )	return	toShapesNoHoles( subPaths );


    var solid, tmpPath, tmpShape, shapes = [];

    if ( subPaths.length === 1 ) {

        tmpPath = subPaths[ 0 ];
        tmpShape = new THREE.Shape();
        tmpShape.actions = tmpPath.actions;
        tmpShape.curves = tmpPath.curves;
        shapes.push( tmpShape );
        return shapes;

    }

    var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
    holesFirst = isCCW ? ! holesFirst : holesFirst;

    // console.log("Holes first", holesFirst);

    var betterShapeHoles = [];
    var newShapes = [];
    var newShapeHoles = [];
    var mainIdx = 0;
    var tmpPoints;

    newShapes[ mainIdx ] = undefined;
    newShapeHoles[ mainIdx ] = [];

    for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

        tmpPath = subPaths[ i ];
        tmpPoints = tmpPath.getPoints();
        solid = isClockWise( tmpPoints );
        solid = isCCW ? ! solid : solid;

        if ( solid ) {

            if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

            newShapes[ mainIdx ] = { s: new THREE.Shape(), p: tmpPoints };
            newShapes[ mainIdx ].s.actions = tmpPath.actions;
            newShapes[ mainIdx ].s.curves = tmpPath.curves;

            if ( holesFirst )	mainIdx ++;
            newShapeHoles[ mainIdx ] = [];

            //console.log('cw', i);

        } else {

            newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

            //console.log('ccw', i);

        }

    }

    // only Holes? -> probably all Shapes with wrong orientation
    if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


    if ( newShapes.length > 1 ) {

        var ambiguous = false;
        var toChange = [];

        for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

            betterShapeHoles[ sIdx ] = [];

        }

        for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

            var sho = newShapeHoles[ sIdx ];

            for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

                var ho = sho[ hIdx ];
                var hole_unassigned = true;

                for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

                    if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

                        if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
                        if ( hole_unassigned ) {

                            hole_unassigned = false;
                            betterShapeHoles[ s2Idx ].push( ho );

                        } else {

                            ambiguous = true;

                        }

                    }

                }
                if ( hole_unassigned ) {

                    betterShapeHoles[ sIdx ].push( ho );

                }

            }

        }
        // console.log("ambiguous: ", ambiguous);
        if ( toChange.length > 0 ) {

            // console.log("to change: ", toChange);
            if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

        }

    }

    var tmpHoles;

    for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

        tmpShape = newShapes[ i ].s;
        shapes.push( tmpShape );
        tmpHoles = newShapeHoles[ i ];

        for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

            tmpShape.holes.push( tmpHoles[ j ].h );

        }

    }

    //console.log("shape", shapes);

    return shapes;

};

// File:src/extras/core/Shape.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/

// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

THREE.Shape = function () {

    THREE.Path.apply( this, arguments );

    this.holes = [];

};

THREE.Shape.prototype = Object.create( THREE.Path.prototype );
THREE.Shape.prototype.constructor = THREE.Shape;

// Convenience method to return ExtrudeGeometry

THREE.Shape.prototype.extrude = function ( options ) {

    return new THREE.ExtrudeGeometry( this, options );

};

// Convenience method to return ShapeGeometry

THREE.Shape.prototype.makeGeometry = function ( options ) {

    return new THREE.ShapeGeometry( this, options );

};

// Get points of holes

THREE.Shape.prototype.getPointsHoles = function ( divisions ) {

    var holesPts = [];

    for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

        holesPts[ i ] = this.holes[ i ].getPoints( divisions );

    }

    return holesPts;

};


// Get points of shape and holes (keypoints based on segments parameter)

THREE.Shape.prototype.extractAllPoints = function ( divisions ) {

    return {

        shape: this.getPoints( divisions ),
        holes: this.getPointsHoles( divisions )

    };

};

THREE.Shape.prototype.extractPoints = function ( divisions ) {

    return this.extractAllPoints( divisions );

};

THREE.Shape.Utils = THREE.ShapeUtils; // backwards compatibility

// File:src/extras/curves/LineCurve.js

/**************************************************************
 *	Line
 **************************************************************/

THREE.LineCurve = function ( v1, v2 ) {

    this.v1 = v1;
    this.v2 = v2;

};

THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.LineCurve.prototype.constructor = THREE.LineCurve;

THREE.LineCurve.prototype.getPoint = function ( t ) {

    var point = this.v2.clone().sub( this.v1 );
    point.multiplyScalar( t ).add( this.v1 );

    return point;

};

// Line curve is linear, so we can overwrite default getPointAt

THREE.LineCurve.prototype.getPointAt = function ( u ) {

    return this.getPoint( u );

};

THREE.LineCurve.prototype.getTangent = function( t ) {

    var tangent = this.v2.clone().sub( this.v1 );

    return tangent.normalize();

};

// File:src/extras/curves/QuadraticBezierCurve.js

/**************************************************************
 *	Quadratic Bezier curve
 **************************************************************/


THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {

    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;

};

THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;


THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {

    var b2 = THREE.ShapeUtils.b2;

    return new THREE.Vector2(
        b2( t, this.v0.x, this.v1.x, this.v2.x ),
        b2( t, this.v0.y, this.v1.y, this.v2.y )
    );

};


THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {

    var tangentQuadraticBezier = THREE.CurveUtils.tangentQuadraticBezier;

    return new THREE.Vector2(
        tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),
        tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )
    ).normalize();

};

// File:src/extras/curves/CubicBezierCurve.js

/**************************************************************
 *	Cubic Bezier curve
 **************************************************************/

THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {

    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;

};

THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;

THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {

    var b3 = THREE.ShapeUtils.b3;

    return new THREE.Vector2(
        b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
        b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
    );

};

THREE.CubicBezierCurve.prototype.getTangent = function( t ) {

    var tangentCubicBezier = THREE.CurveUtils.tangentCubicBezier;

    return new THREE.Vector2(
        tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
        tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
    ).normalize();

};

// File:src/extras/curves/SplineCurve.js

/**************************************************************
 *	Spline curve
 **************************************************************/

THREE.SplineCurve = function ( points /* array of Vector2 */ ) {

    this.points = ( points == undefined ) ? [] : points;

};

THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;

THREE.SplineCurve.prototype.getPoint = function ( t ) {

    var points = this.points;
    var point = ( points.length - 1 ) * t;

    var intPoint = Math.floor( point );
    var weight = point - intPoint;

    var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
    var point1 = points[ intPoint ];
    var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
    var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

    var interpolate = THREE.CurveUtils.interpolate;

    return new THREE.Vector2(
        interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
        interpolate( point0.y, point1.y, point2.y, point3.y, weight )
    );

};

// File:src/extras/curves/EllipseCurve.js

/**************************************************************
 *	Ellipse curve
 **************************************************************/

THREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

    this.aX = aX;
    this.aY = aY;

    this.xRadius = xRadius;
    this.yRadius = yRadius;

    this.aStartAngle = aStartAngle;
    this.aEndAngle = aEndAngle;

    this.aClockwise = aClockwise;

    this.aRotation = aRotation || 0;

};

THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;

THREE.EllipseCurve.prototype.getPoint = function ( t ) {

    var deltaAngle = this.aEndAngle - this.aStartAngle;

    if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
    if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;

    var angle;

    if ( this.aClockwise === true ) {

        angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );

    } else {

        angle = this.aStartAngle + t * deltaAngle;

    }

    var x = this.aX + this.xRadius * Math.cos( angle );
    var y = this.aY + this.yRadius * Math.sin( angle );

    if ( this.aRotation !== 0 ) {

        var cos = Math.cos( this.aRotation );
        var sin = Math.sin( this.aRotation );

        var tx = x, ty = y;

        // Rotate the point about the center of the ellipse.
        x = ( tx - this.aX ) * cos - ( ty - this.aY ) * sin + this.aX;
        y = ( tx - this.aX ) * sin + ( ty - this.aY ) * cos + this.aY;

    }

    return new THREE.Vector2( x, y );

};

// File:src/extras/curves/ArcCurve.js

/**************************************************************
 *	Arc curve
 **************************************************************/

THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

    THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

};

THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );
THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;

// File:src/extras/curves/LineCurve3.js

/**************************************************************
 *	Line3D
 **************************************************************/

THREE.LineCurve3 = THREE.Curve.create(

    function ( v1, v2 ) {

        this.v1 = v1;
        this.v2 = v2;

    },

    function ( t ) {

        var vector = new THREE.Vector3();

        vector.subVectors( this.v2, this.v1 ); // diff
        vector.multiplyScalar( t );
        vector.add( this.v1 );

        return vector;

    }

);

// File:src/extras/curves/QuadraticBezierCurve3.js

/**************************************************************
 *	Quadratic Bezier 3D curve
 **************************************************************/

THREE.QuadraticBezierCurve3 = THREE.Curve.create(

    function ( v0, v1, v2 ) {

        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;

    },

    function ( t ) {

        var b2 = THREE.ShapeUtils.b2;

        return new THREE.Vector3(
            b2( t, this.v0.x, this.v1.x, this.v2.x ),
            b2( t, this.v0.y, this.v1.y, this.v2.y ),
            b2( t, this.v0.z, this.v1.z, this.v2.z )
        );

    }

);

// File:src/extras/curves/CubicBezierCurve3.js

/**************************************************************
 *	Cubic Bezier 3D curve
 **************************************************************/

THREE.CubicBezierCurve3 = THREE.Curve.create(

    function ( v0, v1, v2, v3 ) {

        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;

    },

    function ( t ) {

        var b3 = THREE.ShapeUtils.b3;

        return new THREE.Vector3(
            b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
            b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),
            b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )
        );

    }

);

// File:src/extras/curves/SplineCurve3.js

/**************************************************************
 *	Spline 3D curve
 **************************************************************/


THREE.SplineCurve3 = THREE.Curve.create(

    function ( points /* array of Vector3 */ ) {

        console.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );
        this.points = ( points == undefined ) ? [] : points;

    },

    function ( t ) {

        var points = this.points;
        var point = ( points.length - 1 ) * t;

        var intPoint = Math.floor( point );
        var weight = point - intPoint;

        var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
        var point1 = points[ intPoint ];
        var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
        var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

        var interpolate = THREE.CurveUtils.interpolate;

        return new THREE.Vector3(
            interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
            interpolate( point0.y, point1.y, point2.y, point3.y, weight ),
            interpolate( point0.z, point1.z, point2.z, point3.z, weight )
        );

    }

);

// File:src/extras/curves/CatmullRomCurve3.js

/**
 * @author zz85 https://github.com/zz85
 *
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */

THREE.CatmullRomCurve3 = ( function() {

    var
        tmp = new THREE.Vector3(),
        px = new CubicPoly(),
        py = new CubicPoly(),
        pz = new CubicPoly();

    /*
     Based on an optimized c++ solution in
     - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
     - http://ideone.com/NoEbVM

     This CubicPoly class could be used for reusing some variables and calculations,
     but for three.js curve use, it could be possible inlined and flatten into a single function call
     which can be placed in CurveUtils.
     */

    function CubicPoly() {

    }

    /*
     * Compute coefficients for a cubic polynomial
     *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
     * such that
     *   p(0) = x0, p(1) = x1
     *  and
     *   p'(0) = t0, p'(1) = t1.
     */
    CubicPoly.prototype.init = function( x0, x1, t0, t1 ) {

        this.c0 = x0;
        this.c1 = t0;
        this.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
        this.c3 = 2 * x0 - 2 * x1 + t0 + t1;

    };

    CubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {

        // compute tangents when parameterized in [t1,t2]
        var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
        var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

        // rescale tangents for parametrization in [0,1]
        t1 *= dt1;
        t2 *= dt1;

        // initCubicPoly
        this.init( x1, x2, t1, t2 );

    };

    // standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4
    CubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {

        this.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

    };

    CubicPoly.prototype.calc = function( t ) {

        var t2 = t * t;
        var t3 = t2 * t;
        return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;

    };

    // Subclass Three.js curve
    return THREE.Curve.create(

        function ( p /* array of Vector3 */ ) {

            this.points = p || [];

        },

        function ( t ) {

            var points = this.points,
                point, intPoint, weight, l;

            l = points.length;

            if ( l < 2 ) console.log( 'duh, you need at least 2 points' );

            point = ( l - 1 ) * t;
            intPoint = Math.floor( point );
            weight = point - intPoint;

            if ( weight === 0 && intPoint === l - 1 ) {

                intPoint = l - 2;
                weight = 1;

            }

            var p0, p1, p2, p3;

            if ( intPoint === 0 ) {

                // extrapolate first point
                tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
                p0 = tmp;

            } else {

                p0 = points[ intPoint - 1 ];

            }

            p1 = points[ intPoint ];
            p2 = points[ intPoint + 1 ];

            if ( intPoint + 2 < l ) {

                p3 = points[ intPoint + 2 ]

            } else {

                // extrapolate last point
                tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 2 ] );
                p3 = tmp;

            }

            if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {

                // init Centripetal / Chordal Catmull-Rom
                var pow = this.type === 'chordal' ? 0.5 : 0.25;
                var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
                var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
                var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

                // safety check for repeated points
                if ( dt1 < 1e-4 ) dt1 = 1.0;
                if ( dt0 < 1e-4 ) dt0 = dt1;
                if ( dt2 < 1e-4 ) dt2 = dt1;

                px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
                py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
                pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

            } else if ( this.type === 'catmullrom' ) {

                var tension = this.tension !== undefined ? this.tension : 0.5;
                px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
                py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
                pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );

            }

            var v = new THREE.Vector3(
                px.calc( weight ),
                py.calc( weight ),
                pz.calc( weight )
            );

            return v;

        }

    );

} )();

// File:src/extras/curves/ClosedSplineCurve3.js

/**************************************************************
 *	Closed Spline 3D curve
 **************************************************************/


THREE.ClosedSplineCurve3 = THREE.Curve.create(

    function ( points /* array of Vector3 */ ) {

        this.points = ( points == undefined ) ? [] : points;

    },

    function ( t ) {

        var points = this.points;
        var point = ( points.length - 0 ) * t; // This needs to be from 0-length +1

        var intPoint = Math.floor( point );
        var weight = point - intPoint;

        intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

        var point0 = points[ ( intPoint - 1 ) % points.length ];
        var point1 = points[ ( intPoint     ) % points.length ];
        var point2 = points[ ( intPoint + 1 ) % points.length ];
        var point3 = points[ ( intPoint + 2 ) % points.length ];

        var interpolate = THREE.CurveUtils.interpolate;

        return new THREE.Vector3(
            interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
            interpolate( point0.y, point1.y, point2.y, point3.y, weight ),
            interpolate( point0.z, point1.z, point2.z, point3.z, weight )
        );

    }

);

// File:src/extras/geometries/BoxGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
 */

THREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

    THREE.Geometry.call( this );

    this.type = 'BoxGeometry';

    this.parameters = {
        width: width,
        height: height,
        depth: depth,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        depthSegments: depthSegments
    };

    this.widthSegments = widthSegments || 1;
    this.heightSegments = heightSegments || 1;
    this.depthSegments = depthSegments || 1;

    var scope = this;

    var width_half = width / 2;
    var height_half = height / 2;
    var depth_half = depth / 2;

    buildPlane( 'z', 'y', - 1, - 1, depth, height, width_half, 0 ); // px
    buildPlane( 'z', 'y',   1, - 1, depth, height, - width_half, 1 ); // nx
    buildPlane( 'x', 'z',   1,   1, width, depth, height_half, 2 ); // py
    buildPlane( 'x', 'z',   1, - 1, width, depth, - height_half, 3 ); // ny
    buildPlane( 'x', 'y',   1, - 1, width, height, depth_half, 4 ); // pz
    buildPlane( 'x', 'y', - 1, - 1, width, height, - depth_half, 5 ); // nz

    function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {

        var w, ix, iy,
            gridX = scope.widthSegments,
            gridY = scope.heightSegments,
            width_half = width / 2,
            height_half = height / 2,
            offset = scope.vertices.length;

        if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {

            w = 'z';

        } else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {

            w = 'y';
            gridY = scope.depthSegments;

        } else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {

            w = 'x';
            gridX = scope.depthSegments;

        }

        var gridX1 = gridX + 1,
            gridY1 = gridY + 1,
            segment_width = width / gridX,
            segment_height = height / gridY,
            normal = new THREE.Vector3();

        normal[ w ] = depth > 0 ? 1 : - 1;

        for ( iy = 0; iy < gridY1; iy ++ ) {

            for ( ix = 0; ix < gridX1; ix ++ ) {

                var vector = new THREE.Vector3();
                vector[ u ] = ( ix * segment_width - width_half ) * udir;
                vector[ v ] = ( iy * segment_height - height_half ) * vdir;
                vector[ w ] = depth;

                scope.vertices.push( vector );

            }

        }

        for ( iy = 0; iy < gridY; iy ++ ) {

            for ( ix = 0; ix < gridX; ix ++ ) {

                var a = ix + gridX1 * iy;
                var b = ix + gridX1 * ( iy + 1 );
                var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
                var d = ( ix + 1 ) + gridX1 * iy;

                var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );
                var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );
                var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );
                var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );

                var face = new THREE.Face3( a + offset, b + offset, d + offset );
                face.normal.copy( normal );
                face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
                face.materialIndex = materialIndex;

                scope.faces.push( face );
                scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

                face = new THREE.Face3( b + offset, c + offset, d + offset );
                face.normal.copy( normal );
                face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
                face.materialIndex = materialIndex;

                scope.faces.push( face );
                scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

            }

        }

    }

    this.mergeVertices();

};

THREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;

THREE.BoxGeometry.prototype.clone = function () {

    var parameters = this.parameters;

    return new THREE.BoxGeometry(
        parameters.width,
        parameters.height,
        parameters.depth,
        parameters.widthSegments,
        parameters.heightSegments,
        parameters.depthSegments
    );

};

THREE.CubeGeometry = THREE.BoxGeometry; // backwards compatibility

// File:src/extras/geometries/CircleGeometry.js

/**
 * @author hughes
 */

THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {

    THREE.Geometry.call( this );

    this.type = 'CircleGeometry';

    this.parameters = {
        radius: radius,
        segments: segments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };

    this.fromBufferGeometry( new THREE.CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );

};

THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;

THREE.CircleGeometry.prototype.clone = function () {

    var parameters = this.parameters;

    return new THREE.CircleGeometry(
        parameters.radius,
        parameters.segments,
        parameters.thetaStart,
        parameters.thetaLength
    );

};

// File:src/extras/geometries/CircleBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {

    THREE.BufferGeometry.call( this );

    this.type = 'CircleBufferGeometry';

    this.parameters = {
        radius: radius,
        segments: segments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };

    radius = radius || 50;
    segments = segments !== undefined ? Math.max( 3, segments ) : 8;

    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

    var vertices = segments + 2;

    var positions = new Float32Array( vertices * 3 );
    var normals = new Float32Array( vertices * 3 );
    var uvs = new Float32Array( vertices * 2 );

    // center data is already zero, but need to set a few extras
    normals[ 2 ] = 1.0;
    uvs[ 0 ] = 0.5;
    uvs[ 1 ] = 0.5;

    for ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {

        var segment = thetaStart + s / segments * thetaLength;

        positions[ i ] = radius * Math.cos( segment );
        positions[ i + 1 ] = radius * Math.sin( segment );

        normals[ i + 2 ] = 1; // normal z

        uvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;
        uvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;

    }

    var indices = [];

    for ( var i = 1; i <= segments; i ++ ) {

        indices.push( i, i + 1, 0 );

    }

    this.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );
    this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
    this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
    this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;

THREE.CircleBufferGeometry.prototype.clone = function () {

    var parameters = this.parameters;

    return new THREE.CircleBufferGeometry(
        parameters.radius,
        parameters.segments,
        parameters.thetaStart,
        parameters.thetaLength
    );

};

// File:src/extras/geometries/CylinderGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

    THREE.Geometry.call( this );

    this.type = 'CylinderGeometry';

    this.parameters = {
        radiusTop: radiusTop,
        radiusBottom: radiusBottom,
        height: height,
        radialSegments: radialSegments,
        heightSegments: heightSegments,
        openEnded: openEnded,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };

    radiusTop = radiusTop !== undefined ? radiusTop : 20;
    radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
    height = height !== undefined ? height : 100;

    radialSegments = radialSegments || 8;
    heightSegments = heightSegments || 1;

    openEnded = openEnded !== undefined ? openEnded : false;
    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;

    var heightHalf = height / 2;

    var x, y, vertices = [], uvs = [];

    for ( y = 0; y <= heightSegments; y ++ ) {

        var verticesRow = [];
        var uvsRow = [];

        var v = y / heightSegments;
        var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

        for ( x = 0; x <= radialSegments; x ++ ) {

            var u = x / radialSegments;

            var vertex = new THREE.Vector3();
            vertex.x = radius * Math.sin( u * thetaLength + thetaStart );
            vertex.y = - v * height + heightHalf;
            vertex.z = radius * Math.cos( u * thetaLength + thetaStart );

            this.vertices.push( vertex );

            verticesRow.push( this.vertices.length - 1 );
            uvsRow.push( new THREE.Vector2( u, 1 - v ) );

        }

        vertices.push( verticesRow );
        uvs.push( uvsRow );

    }

    var tanTheta = ( radiusBottom - radiusTop ) / height;
    var na, nb;

    for ( x = 0; x < radialSegments; x ++ ) {

        if ( radiusTop !== 0 ) {

            na = this.vertices[ vertices[ 0 ][ x ] ].clone();
            nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();

        } else {

            na = this.vertices[ vertices[ 1 ][ x ] ].clone();
            nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();

        }

        na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
        nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();

        for ( y = 0; y < heightSegments; y ++ ) {

            var v1 = vertices[ y ][ x ];
            var v2 = vertices[ y + 1 ][ x ];
            var v3 = vertices[ y + 1 ][ x + 1 ];
            var v4 = vertices[ y ][ x + 1 ];

            var n1 = na.clone();
            var n2 = na.clone();
            var n3 = nb.clone();
            var n4 = nb.clone();

            var uv1 = uvs[ y ][ x ].clone();
            var uv2 = uvs[ y + 1 ][ x ].clone();
            var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
            var uv4 = uvs[ y ][ x + 1 ].clone();

            this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
            this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

            this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
            this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

        }

    }

    // top cap

    if ( openEnded === false && radiusTop > 0 ) {

        this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );

        for ( x = 0; x < radialSegments; x ++ ) {

            var v1 = vertices[ 0 ][ x ];
            var v2 = vertices[ 0 ][ x + 1 ];
            var v3 = this.vertices.length - 1;

            var n1 = new THREE.Vector3( 0, 1, 0 );
            var n2 = new THREE.Vector3( 0, 1, 0 );
            var n3 = new THREE.Vector3( 0, 1, 0 );

            var uv1 = uvs[ 0 ][ x ].clone();
            var uv2 = uvs[ 0 ][ x + 1 ].clone();
            var uv3 = new THREE.Vector2( uv2.x, 0 );

            this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 1 ) );
            this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

        }

    }

    // bottom cap

    if ( openEnded === false && radiusBottom > 0 ) {

        this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );

        for ( x = 0; x < radialSegments; x ++ ) {

            var v1 = vertices[ heightSegments ][ x + 1 ];
            var v2 = vertices[ heightSegments ][ x ];
            var v3 = this.vertices.length - 1;

            var n1 = new THREE.Vector3( 0, - 1, 0 );
            var n2 = new THREE.Vector3( 0, - 1, 0 );
            var n3 = new THREE.Vector3( 0, - 1, 0 );

            var uv1 = uvs[ heightSegments ][ x + 1 ].clone();
            var uv2 = uvs[ heightSegments ][ x ].clone();
            var uv3 = new THREE.Vector2( uv2.x, 1 );

            this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 2 ) );
            this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

        }

    }

    this.computeFaceNormals();

};

THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;

THREE.CylinderGeometry.prototype.clone = function () {

    var parameters = this.parameters;

    return new THREE.CylinderGeometry(
        parameters.radiusTop,
        parameters.radiusBottom,
        parameters.height,
        parameters.radialSegments,
        parameters.heightSegments,
        parameters.openEnded,
        parameters.thetaStart,
        parameters.thetaLength
    );

};

// File:src/extras/geometries/EdgesGeometry.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.EdgesGeometry = function ( geometry, thresholdAngle ) {

    THREE.BufferGeometry.call( this );

    thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

    var thresholdDot = Math.cos( THREE.Math.degToRad( thresholdAngle ) );

    var edge = [ 0, 0 ], hash = {};

    function sortFunction( a, b ) {

        return a - b;

    }

    var keys = [ 'a', 'b', 'c' ];

    var geometry2;

    if ( geometry instanceof THREE.BufferGeometry ) {

        geometry2 = new THREE.Geometry();
        geometry2.fromBufferGeometry( geometry );

    } else {

        geometry2 = geometry.clone();

    }

    geometry2.mergeVertices();
    geometry2.computeFaceNormals();

    var vertices = geometry2.vertices;
    var faces = geometry2.faces;

    for ( var i = 0, l = faces.length; i < l; i ++ ) {

        var face = faces[ i ];

        for ( var j = 0; j < 3; j ++ ) {

            edge[ 0 ] = face[ keys[ j ] ];
            edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
            edge.sort( sortFunction );

            var key = edge.toString();

            if ( hash[ key ] === undefined ) {

                hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };

            } else {

                hash[ key ].face2 = i;

            }

        }

    }

    var coords = [];

    for ( var key in hash ) {

        var h = hash[ key ];

        if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {

            var vertex = vertices[ h.vert1 ];
            coords.push( vertex.x );
            coords.push( vertex.y );
            coords.push( vertex.z );

            vertex = vertices[ h.vert2 ];
            coords.push( vertex.x );
            coords.push( vertex.y );
            coords.push( vertex.z );

        }

    }

    this.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );

};

THREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;

// File:src/extras/geometries/ExtrudeGeometry.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  amount: <int>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline is bevel
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
 *
 *  uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ExtrudeGeometry = function ( shapes, options ) {

    if ( typeof( shapes ) === "undefined" ) {

        shapes = [];
        return;

    }

    THREE.Geometry.call( this );

    this.type = 'ExtrudeGeometry';

    shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

    this.addShapeList( shapes, options );

    this.computeFaceNormals();

    // can't really use automatic vertex normals
    // as then front and back sides get smoothed too
    // should do separate smoothing just for sides

    //this.computeVertexNormals();

    //console.log( "took", ( Date.now() - startTime ) );

};

THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;

THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {

    var sl = shapes.length;

    for ( var s = 0; s < sl; s ++ ) {

        var shape = shapes[ s ];
        this.addShape( shape, options );

    }

};

THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

    var amount = options.amount !== undefined ? options.amount : 100;

    var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
    var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
    var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

    var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

    var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

    var steps = options.steps !== undefined ? options.steps : 1;

    var extrudePath = options.extrudePath;
    var extrudePts, extrudeByPath = false;

    // Use default WorldUVGenerator if no UV generators are specified.
    var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;

    var splineTube, binormal, normal, position2;
    if ( extrudePath ) {

        extrudePts = extrudePath.getSpacedPoints( steps );

        extrudeByPath = true;
        bevelEnabled = false; // bevels not supported for path extrusion

        // SETUP TNB variables

        // Reuse TNB from TubeGeomtry for now.
        // TODO1 - have a .isClosed in spline?

        splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );

        // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

        binormal = new THREE.Vector3();
        normal = new THREE.Vector3();
        position2 = new THREE.Vector3();

    }

    // Safeguards if bevels are not enabled

    if ( ! bevelEnabled ) {

        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;

    }

    // Variables initialization

    var ahole, h, hl; // looping of holes
    var scope = this;

    var shapesOffset = this.vertices.length;

    var shapePoints = shape.extractPoints( curveSegments );

    var vertices = shapePoints.shape;
    var holes = shapePoints.holes;

    var reverse = ! THREE.ShapeUtils.isClockWise( vertices );

    if ( reverse ) {

        vertices = vertices.reverse();

        // Maybe we should also check if holes are in the opposite direction, just to be safe ...

        for ( h = 0, hl = holes.length; h < hl; h ++ ) {

            ahole = holes[ h ];

            if ( THREE.ShapeUtils.isClockWise( ahole ) ) {

                holes[ h ] = ahole.reverse();

            }

        }

        reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

    }


    var faces = THREE.ShapeUtils.triangulateShape( vertices, holes );

    /* Vertices */

    var contour = vertices; // vertices has all points but contour has only points of circumference

    for ( h = 0, hl = holes.length; h < hl; h ++ ) {

        ahole = holes[ h ];

        vertices = vertices.concat( ahole );

    }


    function scalePt2 ( pt, vec, size ) {

        if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

        return vec.clone().multiplyScalar( size ).add( pt );

    }

    var b, bs, t, z,
        vert, vlen = vertices.length,
        face, flen = faces.length;


    // Find directions for point movement


    function getBevelVec( inPt, inPrev, inNext ) {

        // computes for inPt the corresponding point inPt' on a new contour
        //   shifted by 1 unit (length of normalized vector) to the left
        // if we walk along contour clockwise, this new contour is outside the old one
        //
        // inPt' is the intersection of the two lines parallel to the two
        //  adjacent edges of inPt at a distance of 1 unit on the left side.

        var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt

        // good reading for geometry algorithms (here: line-line intersection)
        // http://geomalgorithms.com/a05-_intersect-1.html

        var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
        var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;

        var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

        // check for collinear edges
        var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

        if ( Math.abs( collinear0 ) > Number.EPSILON ) {

            // not collinear

            // length of vectors for normalizing

            var v_prev_len = Math.sqrt( v_prev_lensq );
            var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

            // shift adjacent points by unit vectors to the left

            var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
            var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

            var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
            var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

            // scaling factor for v_prev to intersection point

            var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
                ( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
                ( v_prev_x * v_next_y - v_prev_y * v_next_x );

            // vector from inPt to intersection point

            v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
            v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

            // Don't normalize!, otherwise sharp corners become ugly
            //  but prevent crazy spikes
            var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
            if ( v_trans_lensq <= 2 ) {

                return	new THREE.Vector2( v_trans_x, v_trans_y );

            } else {

                shrink_by = Math.sqrt( v_trans_lensq / 2 );

            }

        } else {

            // handle special case of collinear edges

            var direction_eq = false;		// assumes: opposite
            if ( v_prev_x > Number.EPSILON ) {

                if ( v_next_x > Number.EPSILON ) {

                    direction_eq = true;

                }

            } else {

                if ( v_prev_x < - Number.EPSILON ) {

                    if ( v_next_x < - Number.EPSILON ) {

                        direction_eq = true;

                    }

                } else {

                    if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

                        direction_eq = true;

                    }

                }

            }

            if ( direction_eq ) {

                // console.log("Warning: lines are a straight sequence");
                v_trans_x = - v_prev_y;
                v_trans_y =  v_prev_x;
                shrink_by = Math.sqrt( v_prev_lensq );

            } else {

                // console.log("Warning: lines are a straight spike");
                v_trans_x = v_prev_x;
                v_trans_y = v_prev_y;
                shrink_by = Math.sqrt( v_prev_lensq / 2 );

            }

        }

        return	new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

    }


    var contourMovements = [];

    for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

        if ( j === il ) j = 0;
        if ( k === il ) k = 0;

        //  (j)---(i)---(k)
        // console.log('i,j,k', i, j , k)

        contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

    }

    var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

    for ( h = 0, hl = holes.length; h < hl; h ++ ) {

        ahole = holes[ h ];

        oneHoleMovements = [];

        for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

            if ( j === il ) j = 0;
            if ( k === il ) k = 0;

            //  (j)---(i)---(k)
            oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

        }

        holesMovements.push( oneHoleMovements );
        verticesMovements = verticesMovements.concat( oneHoleMovements );

    }


    // Loop bevelSegments, 1 for the front, 1 for the back

    for ( b = 0; b < bevelSegments; b ++ ) {

        //for ( b = bevelSegments; b > 0; b -- ) {

        t = b / bevelSegments;
        z = bevelThickness * ( 1 - t );

        //z = bevelThickness * t;
        bs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ); // curved
        //bs = bevelSize * t; // linear

        // contract shape

        for ( i = 0, il = contour.length; i < il; i ++ ) {

            vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

            v( vert.x, vert.y,  - z );

        }

        // expand holes

        for ( h = 0, hl = holes.length; h < hl; h ++ ) {

            ahole = holes[ h ];
            oneHoleMovements = holesMovements[ h ];

            for ( i = 0, il = ahole.length; i < il; i ++ ) {

                vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

                v( vert.x, vert.y,  - z );

            }

        }

    }

    bs = bevelSize;

    // Back facing vertices

    for ( i = 0; i < vlen; i ++ ) {

        vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

        if ( ! extrudeByPath ) {

            v( vert.x, vert.y, 0 );

        } else {

            // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

            normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
            binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

            position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

            v( position2.x, position2.y, position2.z );

        }

    }

    // Add stepped vertices...
    // Including front facing vertices

    var s;

    for ( s = 1; s <= steps; s ++ ) {

        for ( i = 0; i < vlen; i ++ ) {

            vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

            if ( ! extrudeByPath ) {

                v( vert.x, vert.y, amount / steps * s );

            } else {

                // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

                normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
                binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

                position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

                v( position2.x, position2.y, position2.z );

            }

        }

    }


    // Add bevel segments planes

    //for ( b = 1; b <= bevelSegments; b ++ ) {
    for ( b = bevelSegments - 1; b >= 0; b -- ) {

        t = b / bevelSegments;
        z = bevelThickness * ( 1 - t );
        //bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
        bs = bevelSize * Math.sin ( t * Math.PI / 2 );

        // contract shape

        for ( i = 0, il = contour.length; i < il; i ++ ) {

            vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
            v( vert.x, vert.y,  amount + z );

        }

        // expand holes

        for ( h = 0, hl = holes.length; h < hl; h ++ ) {

            ahole = holes[ h ];
            oneHoleMovements = holesMovements[ h ];

            for ( i = 0, il = ahole.length; i < il; i ++ ) {

                vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

                if ( ! extrudeByPath ) {

                    v( vert.x, vert.y,  amount + z );

                } else {

                    v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

                }

            }

        }

    }

    /* Faces */

    // Top and bottom faces

    buildLidFaces();

    // Sides faces

    buildSideFaces();


    /////  Internal functions

    function buildLidFaces() {

        if ( bevelEnabled ) {

            var layer = 0; // steps + 1
            var offset = vlen * layer;

            // Bottom faces

            for ( i = 0; i < flen; i ++ ) {

                face = faces[ i ];
                f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

            }

            layer = steps + bevelSegments * 2;
            offset = vlen * layer;

            // Top faces

            for ( i = 0; i < flen; i ++ ) {

                face = faces[ i ];
                f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

            }

        } else {

            // Bottom faces

            for ( i = 0; i < flen; i ++ ) {

                face = faces[ i ];
                f3( face[ 2 ], face[ 1 ], face[ 0 ] );

            }

            // Top faces

            for ( i = 0; i < flen; i ++ ) {

                face = faces[ i ];
                f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

            }

        }

    }

    // Create faces for the z-sides of the shape

    function buildSideFaces() {

        var layeroffset = 0;
        sidewalls( contour, layeroffset );
        layeroffset += contour.length;

        for ( h = 0, hl = holes.length; h < hl; h ++ ) {

            ahole = holes[ h ];
            sidewalls( ahole, layeroffset );

            //, true
            layeroffset += ahole.length;

        }

    }

    function sidewalls( contour, layeroffset ) {

        var j, k;
        i = contour.length;

        while ( -- i >= 0 ) {

            j = i;
            k = i - 1;
            if ( k < 0 ) k = contour.length - 1;

            //console.log('b', i,j, i-1, k,vertices.length);

            var s = 0, sl = steps  + bevelSegments * 2;

            for ( s = 0; s < sl; s ++ ) {

                var slen1 = vlen * s;
                var slen2 = vlen * ( s + 1 );

                var a = layeroffset + j + slen1,
                    b = layeroffset + k + slen1,
                    c = layeroffset + k + slen2,
                    d = layeroffset + j + slen2;

                f4( a, b, c, d, contour, s, sl, j, k );

            }

        }

    }


    function v( x, y, z ) {

        scope.vertices.push( new THREE.Vector3( x, y, z ) );

    }

    function f3( a, b, c ) {

        a += shapesOffset;
        b += shapesOffset;
        c += shapesOffset;

        scope.faces.push( new THREE.Face3( a, b, c, null, null, 0 ) );

        var uvs = uvgen.generateTopUV( scope, a, b, c );

        scope.faceVertexUvs[ 0 ].push( uvs );

    }

    function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

        a += shapesOffset;
        b += shapesOffset;
        c += shapesOffset;
        d += shapesOffset;

        scope.faces.push( new THREE.Face3( a, b, d, null, null, 1 ) );
        scope.faces.push( new THREE.Face3( b, c, d, null, null, 1 ) );

        var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

        scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
        scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

    }

};

THREE.ExtrudeGeometry.WorldUVGenerator = {

    generateTopUV: function ( geometry, indexA, indexB, indexC ) {

        var vertices = geometry.vertices;

        var a = vertices[ indexA ];
        var b = vertices[ indexB ];
        var c = vertices[ indexC ];

        return [
            new THREE.Vector2( a.x, a.y ),
            new THREE.Vector2( b.x, b.y ),
            new THREE.Vector2( c.x, c.y )
        ];

    },

    generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {

        var vertices = geometry.vertices;

        var a = vertices[ indexA ];
        var b = vertices[ indexB ];
        var c = vertices[ indexC ];
        var d = vertices[ indexD ];

        if ( Math.abs( a.y - b.y ) < 0.01 ) {

            return [
                new THREE.Vector2( a.x, 1 - a.z ),
                new THREE.Vector2( b.x, 1 - b.z ),
                new THREE.Vector2( c.x, 1 - c.z ),
                new THREE.Vector2( d.x, 1 - d.z )
            ];

        } else {

            return [
                new THREE.Vector2( a.y, 1 - a.z ),
                new THREE.Vector2( b.y, 1 - b.z ),
                new THREE.Vector2( c.y, 1 - c.z ),
                new THREE.Vector2( d.y, 1 - d.z )
            ];

        }

    }
};

// File:src/extras/geometries/ShapeGeometry.js

/**
 * @author jonobr1 / http://jonobr1.com
 *
 * Creates a one-sided polygonal geometry from a path shape. Similar to
 * ExtrudeGeometry.
 *
 * parameters = {
 *
 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
 *
 *	material: <int> // material index for front and back faces
 *	uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ShapeGeometry = function ( shapes, options ) {

    THREE.Geometry.call( this );

    this.type = 'ShapeGeometry';

    if ( Array.isArray( shapes ) === false ) shapes = [ shapes ];

    this.addShapeList( shapes, options );

    this.computeFaceNormals();

};

THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;

/**
 * Add an array of shapes to THREE.ShapeGeometry.
 */
THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {

    for ( var i = 0, l = shapes.length; i < l; i ++ ) {

        this.addShape( shapes[ i ], options );

    }

    return this;

};

/**
 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
 */
THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {

    if ( options === undefined ) options = {};
    var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

    var material = options.material;
    var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

    //

    var i, l, hole;

    var shapesOffset = this.vertices.length;
    var shapePoints = shape.extractPoints( curveSegments );

    var vertices = shapePoints.shape;
    var holes = shapePoints.holes;

    var reverse = ! THREE.ShapeUtils.isClockWise( vertices );

    if ( reverse ) {

        vertices = vertices.reverse();

        // Maybe we should also check if holes are in the opposite direction, just to be safe...

        for ( i = 0, l = holes.length; i < l; i ++ ) {

            hole = holes[ i ];

            if ( THREE.ShapeUtils.isClockWise( hole ) ) {

                holes[ i ] = hole.reverse();

            }

        }

        reverse = false;

    }

    var faces = THREE.ShapeUtils.triangulateShape( vertices, holes );

    // Vertices

    for ( i = 0, l = holes.length; i < l; i ++ ) {

        hole = holes[ i ];
        vertices = vertices.concat( hole );

    }

    //

    var vert, vlen = vertices.length;
    var face, flen = faces.length;

    for ( i = 0; i < vlen; i ++ ) {

        vert = vertices[ i ];

        this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );

    }

    for ( i = 0; i < flen; i ++ ) {

        face = faces[ i ];

        var a = face[ 0 ] + shapesOffset;
        var b = face[ 1 ] + shapesOffset;
        var c = face[ 2 ] + shapesOffset;

        this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
        this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );

    }

};

// File:src/extras/geometries/LatheGeometry.js

/**
 * @author astrodud / http://astrodud.isgreat.org/
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://clara.io
 */

// points - to create a closed torus, one must use a set of points 
//    like so: [ a, b, c, d, a ], see first is the same as last.
// segments - the number of circumference segments to create
// phiStart - the starting radian
// phiLength - the radian (0 to 2*PI) range of the lathed section
//    2*pi is a closed lathe, less than 2PI is a portion.

THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {

    THREE.Geometry.call( this );

    this.type = 'LatheGeometry';

    this.parameters = {
        points: points,
        segments: segments,
        phiStart: phiStart,
        phiLength: phiLength
    };

    segments = segments || 12;
    phiStart = phiStart || 0;
    phiLength = phiLength || 2 * Math.PI;

    var inversePointLength = 1.0 / ( points.length - 1 );
    var inverseSegments = 1.0 / segments;

    for ( var i = 0, il = segments; i <= il; i ++ ) {

        var phi = phiStart + i * inverseSegments * phiLength;

        var c = Math.cos( phi ),
            s = Math.sin( phi );

        for ( var j = 0, jl = points.length; j < jl; j ++ ) {

            var pt = points[ j ];

            var vertex = new THREE.Vector3();

            vertex.x = c * pt.x - s * pt.y;
            vertex.y = s * pt.x + c * pt.y;
            vertex.z = pt.z;

            this.vertices.push( vertex );

        }

    }

    var np = points.length;

    for ( var i = 0, il = segments; i < il; i ++ ) {

        for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {

            var base = j + np * i;
            var a = base;
            var b = base + np;
            var c = base + 1 + np;
            var d = base + 1;

            var u0 = i * inverseSegments;
            var v0 = j * inversePointLength;
            var u1 = u0 + inverseSegments;
            var v1 = v0 + inversePointLength;

            this.faces.push( new THREE.Face3( a, b, d ) );

            this.faceVertexUvs[ 0 ].push( [

                new THREE.Vector2( u0, v0 ),
                new THREE.Vector2( u1, v0 ),
                new THREE.Vector2( u0, v1 )

            ] );

            this.faces.push( new THREE.Face3( b, c, d ) );

            this.faceVertexUvs[ 0 ].push( [

                new THREE.Vector2( u1, v0 ),
                new THREE.Vector2( u1, v1 ),
                new THREE.Vector2( u0, v1 )

            ] );


        }

    }

    this.mergeVertices();
    this.computeFaceNormals();
    this.computeVertexNormals();

};

THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;

// File:src/extras/geometries/PlaneGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {

    THREE.Geometry.call( this );

    this.type = 'PlaneGeometry';

    this.parameters = {
        width: width,
        height: height,
        widthSegments: widthSegments,
        heightSegments: heightSegments
    };

    this.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

};

THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;

THREE.PlaneGeometry.prototype.clone = function () {

    var parameters = this.parameters;

    return new THREE.PlaneGeometry(
        parameters.width,
        parameters.height,
        parameters.widthSegments,
        parameters.heightSegments
    );

};

// File:src/extras/geometries/PlaneBufferGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {

    THREE.BufferGeometry.call( this );

    this.type = 'PlaneBufferGeometry';

    this.parameters = {
        width: width,
        height: height,
        widthSegments: widthSegments,
        heightSegments: heightSegments
    };

    var width_half = width / 2;
    var height_half = height / 2;

    var gridX = Math.floor( widthSegments ) || 1;
    var gridY = Math.floor( heightSegments ) || 1;

    var gridX1 = gridX + 1;
    var gridY1 = gridY + 1;

    var segment_width = width / gridX;
    var segment_height = height / gridY;

    var vertices = new Float32Array( gridX1 * gridY1 * 3 );
    var normals = new Float32Array( gridX1 * gridY1 * 3 );
    var uvs = new Float32Array( gridX1 * gridY1 * 2 );

    var offset = 0;
    var offset2 = 0;

    for ( var iy = 0; iy < gridY1; iy ++ ) {

        var y = iy * segment_height - height_half;

        for ( var ix = 0; ix < gridX1; ix ++ ) {

            var x = ix * segment_width - width_half;

            vertices[ offset ] = x;
            vertices[ offset + 1 ] = - y;

            normals[ offset + 2 ] = 1;

            uvs[ offset2 ] = ix / gridX;
            uvs[ offset2 + 1 ] = 1 - ( iy / gridY );

            offset += 3;
            offset2 += 2;

        }

    }

    offset = 0;

    var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

    for ( var iy = 0; iy < gridY; iy ++ ) {

        for ( var ix = 0; ix < gridX; ix ++ ) {

            var a = ix + gridX1 * iy;
            var b = ix + gridX1 * ( iy + 1 );
            var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
            var d = ( ix + 1 ) + gridX1 * iy;

            indices[ offset ] = a;
            indices[ offset + 1 ] = b;
            indices[ offset + 2 ] = d;

            indices[ offset + 3 ] = b;
            indices[ offset + 4 ] = c;
            indices[ offset + 5 ] = d;

            offset += 6;

        }

    }

    this.setIndex( new THREE.BufferAttribute( indices, 1 ) );
    this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
    this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
    this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

};

THREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;

THREE.PlaneBufferGeometry.prototype.clone = function () {

    var parameters = this.parameters;

    return new THREE.PlaneBufferGeometry(
        parameters.width,
        parameters.height,
        parameters.widthSegments,
        parameters.heightSegments
    );

};

// File:src/extras/geometries/RingGeometry.js

/**
 * @author Kaleb Murphy
 */

THREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

    THREE.Geometry.call( this );

    this.type = 'RingGeometry';

    this.parameters = {
        innerRadius: innerRadius,
        outerRadius: outerRadius,
        thetaSegments: thetaSegments,
        phiSegments: phiSegments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };

    innerRadius = innerRadius || 0;
    outerRadius = outerRadius || 50;

    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

    thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
    phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;

    var i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );

    for ( i = 0; i < phiSegments + 1; i ++ ) {

        // concentric circles inside ring

        for ( o = 0; o < thetaSegments + 1; o ++ ) {

            // number of segments per circle

            var vertex = new THREE.Vector3();
            var segment = thetaStart + o / thetaSegments * thetaLength;
            vertex.x = radius * Math.cos( segment );
            vertex.y = radius * Math.sin( segment );

            this.vertices.push( vertex );
            uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );

        }

        radius += radiusStep;

    }

    var n = new THREE.Vector3( 0, 0, 1 );

    for ( i = 0; i < phiSegments; i ++ ) {

        // concentric circles inside ring

        var thetaSegment = i * ( thetaSegments + 1 );

        for ( o = 0; o < thetaSegments ; o ++ ) {

            // number of segments per circle

            var segment = o + thetaSegment;

            var v1 = segment;
            var v2 = segment + thetaSegments + 1;
            var v3 = segment + thetaSegments + 2;

            this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
            this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );

            v1 = segment;
            v2 = segment + thetaSegments + 2;
            v3 = segment + 1;

            this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
            this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );

        }

    }

    this.computeFaceNormals();

    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;

THREE.RingGeometry.prototype.clone = function () {

    var parameters = this.parameters;

    return new THREE.RingGeometry(
        parameters.innerRadius,
        parameters.outerRadius,
        parameters.thetaSegments,
        parameters.phiSegments,
        parameters.thetaStart,
        parameters.thetaLength
    );

};

// File:src/extras/geometries/SphereGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

    THREE.Geometry.call( this );

    this.type = 'SphereGeometry';

    this.parameters = {
        radius: radius,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        phiStart: phiStart,
        phiLength: phiLength,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };

    this.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );

};

THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;

THREE.SphereGeometry.prototype.clone = function () {

    var parameters = this.parameters;

    return new THREE.SphereGeometry(
        parameters.radius,
        parameters.widthSegments,
        parameters.heightSegments,
        parameters.phiStart,
        parameters.phiLength,
        parameters.thetaStart,
        parameters.thetaLength
    );

};

// File:src/extras/geometries/SphereBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * based on THREE.SphereGeometry
 */

THREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

    THREE.BufferGeometry.call( this );

    this.type = 'SphereBufferGeometry';

    this.parameters = {
        radius: radius,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        phiStart: phiStart,
        phiLength: phiLength,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };

    radius = radius || 50;

    widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
    heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

    phiStart = phiStart !== undefined ? phiStart : 0;
    phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

    var thetaEnd = thetaStart + thetaLength;

    var vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );

    var positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    var normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    var uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

    var index = 0, vertices = [], normal = new THREE.Vector3();

    for ( var y = 0; y <= heightSegments; y ++ ) {

        var verticesRow = [];

        var v = y / heightSegments;

        for ( var x = 0; x <= widthSegments; x ++ ) {

            var u = x / widthSegments;

            var px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
            var py = radius * Math.cos( thetaStart + v * thetaLength );
            var pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

            normal.set( px, py, pz ).normalize();

            positions.setXYZ( index, px, py, pz );
            normals.setXYZ( index, normal.x, normal.y, normal.z );
            uvs.setXY( index, u, 1 - v );

            verticesRow.push( index );

            index ++;

        }

        vertices.push( verticesRow );

    }

    var indices = [];

    for ( var y = 0; y < heightSegments; y ++ ) {

        for ( var x = 0; x < widthSegments; x ++ ) {

            var v1 = vertices[ y ][ x + 1 ];
            var v2 = vertices[ y ][ x ];
            var v3 = vertices[ y + 1 ][ x ];
            var v4 = vertices[ y + 1 ][ x + 1 ];

            if ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );
            if ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );

        }

    }

    this.setIndex( new ( positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute )( indices, 1 ) );
    this.addAttribute( 'position', positions );
    this.addAttribute( 'normal', normals );
    this.addAttribute( 'uv', uvs );

    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;

THREE.SphereBufferGeometry.prototype.clone = function () {

    var parameters = this.parameters;

    return new THREE.SphereBufferGeometry(
        parameters.radius,
        parameters.widthSegments,
        parameters.heightSegments,
        parameters.phiStart,
        parameters.phiLength,
        parameters.thetaStart,
        parameters.thetaLength
    );

};

// File:src/extras/geometries/TorusGeometry.js

/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
 */

THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {

    THREE.Geometry.call( this );

    this.type = 'TorusGeometry';

    this.parameters = {
        radius: radius,
        tube: tube,
        radialSegments: radialSegments,
        tubularSegments: tubularSegments,
        arc: arc
    };

    radius = radius || 100;
    tube = tube || 40;
    radialSegments = radialSegments || 8;
    tubularSegments = tubularSegments || 6;
    arc = arc || Math.PI * 2;

    var center = new THREE.Vector3(), uvs = [], normals = [];

    for ( var j = 0; j <= radialSegments; j ++ ) {

        for ( var i = 0; i <= tubularSegments; i ++ ) {

            var u = i / tubularSegments * arc;
            var v = j / radialSegments * Math.PI * 2;

            center.x = radius * Math.cos( u );
            center.y = radius * Math.sin( u );

            var vertex = new THREE.Vector3();
            vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
            vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
            vertex.z = tube * Math.sin( v );

            this.vertices.push( vertex );

            uvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );
            normals.push( vertex.clone().sub( center ).normalize() );

        }

    }

    for ( var j = 1; j <= radialSegments; j ++ ) {

        for ( var i = 1; i <= tubularSegments; i ++ ) {

            var a = ( tubularSegments + 1 ) * j + i - 1;
            var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
            var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
            var d = ( tubularSegments + 1 ) * j + i;

            var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );
            this.faces.push( face );
            this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );

            face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );
            this.faces.push( face );
            this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );

        }

    }

    this.computeFaceNormals();

};

THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;

THREE.TorusGeometry.prototype.clone = function () {

    var parameters = this.parameters;

    return new THREE.TorusGeometry(
        parameters.radius,
        parameters.tube,
        parameters.radialSegments,
        parameters.tubularSegments,
        parameters.arc
    );

};

// File:src/extras/geometries/TorusKnotGeometry.js

/**
 * @author oosmoxiecode
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
 */

THREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {

    THREE.Geometry.call( this );

    this.type = 'TorusKnotGeometry';

    this.parameters = {
        radius: radius,
        tube: tube,
        radialSegments: radialSegments,
        tubularSegments: tubularSegments,
        p: p,
        q: q,
        heightScale: heightScale
    };

    radius = radius || 100;
    tube = tube || 40;
    radialSegments = radialSegments || 64;
    tubularSegments = tubularSegments || 8;
    p = p || 2;
    q = q || 3;
    heightScale = heightScale || 1;

    var grid = new Array( radialSegments );
    var tang = new THREE.Vector3();
    var n = new THREE.Vector3();
    var bitan = new THREE.Vector3();

    for ( var i = 0; i < radialSegments; ++ i ) {

        grid[ i ] = new Array( tubularSegments );
        var u = i / radialSegments * 2 * p * Math.PI;
        var p1 = getPos( u, q, p, radius, heightScale );
        var p2 = getPos( u + 0.01, q, p, radius, heightScale );
        tang.subVectors( p2, p1 );
        n.addVectors( p2, p1 );

        bitan.crossVectors( tang, n );
        n.crossVectors( bitan, tang );
        bitan.normalize();
        n.normalize();

        for ( var j = 0; j < tubularSegments; ++ j ) {

            var v = j / tubularSegments * 2 * Math.PI;
            var cx = - tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
            var cy = tube * Math.sin( v );

            var pos = new THREE.Vector3();
            pos.x = p1.x + cx * n.x + cy * bitan.x;
            pos.y = p1.y + cx * n.y + cy * bitan.y;
            pos.z = p1.z + cx * n.z + cy * bitan.z;

            grid[ i ][ j ] = this.vertices.push( pos ) - 1;

        }

    }

    for ( var i = 0; i < radialSegments; ++ i ) {

        for ( var j = 0; j < tubularSegments; ++ j ) {

            var ip = ( i + 1 ) % radialSegments;
            var jp = ( j + 1 ) % tubularSegments;

            var a = grid[ i ][ j ];
            var b = grid[ ip ][ j ];
            var c = grid[ ip ][ jp ];
            var d = grid[ i ][ jp ];

            var uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );
            var uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );
            var uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );
            var uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );

            this.faces.push( new THREE.Face3( a, b, d ) );
            this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

            this.faces.push( new THREE.Face3( b, c, d ) );
            this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

        }

    }

    this.computeFaceNormals();
    this.computeVertexNormals();

    function getPos( u, in_q, in_p, radius, heightScale ) {

        var cu = Math.cos( u );
        var su = Math.sin( u );
        var quOverP = in_q / in_p * u;
        var cs = Math.cos( quOverP );

        var tx = radius * ( 2 + cs ) * 0.5 * cu;
        var ty = radius * ( 2 + cs ) * su * 0.5;
        var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;

        return new THREE.Vector3( tx, ty, tz );

    }

};

THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;

THREE.TorusKnotGeometry.prototype.clone = function () {

    var parameters = this.parameters;

    return new THREE.TorusKnotGeometry(
        parameters.radius,
        parameters.tube,
        parameters.radialSegments,
        parameters.tubularSegments,
        parameters.p,
        parameters.q,
        parameters.heightScale
    );

};

// File:src/extras/geometries/TubeGeometry.js

/**
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 * @author jonobr1 / https://github.com/jonobr1
 *
 * Modified from the TorusKnotGeometry by @oosmoxiecode
 *
 * Creates a tube which extrudes along a 3d spline
 *
 * Uses parallel transport frames as described in
 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
 */

THREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {

    THREE.Geometry.call( this );

    this.type = 'TubeGeometry';

    this.parameters = {
        path: path,
        segments: segments,
        radius: radius,
        radialSegments: radialSegments,
        closed: closed,
        taper: taper
    };

    segments = segments || 64;
    radius = radius || 1;
    radialSegments = radialSegments || 8;
    closed = closed || false;
    taper = taper || THREE.TubeGeometry.NoTaper;

    var grid = [];

    var scope = this,

        tangent,
        normal,
        binormal,

        numpoints = segments + 1,

        u, v, r,

        cx, cy,
        pos, pos2 = new THREE.Vector3(),
        i, j,
        ip, jp,
        a, b, c, d,
        uva, uvb, uvc, uvd;

    var frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),
        tangents = frames.tangents,
        normals = frames.normals,
        binormals = frames.binormals;

    // proxy internals
    this.tangents = tangents;
    this.normals = normals;
    this.binormals = binormals;

    function vert( x, y, z ) {

        return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;

    }

    // construct the grid

    for ( i = 0; i < numpoints; i ++ ) {

        grid[ i ] = [];

        u = i / ( numpoints - 1 );

        pos = path.getPointAt( u );

        tangent = tangents[ i ];
        normal = normals[ i ];
        binormal = binormals[ i ];

        r = radius * taper( u );

        for ( j = 0; j < radialSegments; j ++ ) {

            v = j / radialSegments * 2 * Math.PI;

            cx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
            cy = r * Math.sin( v );

            pos2.copy( pos );
            pos2.x += cx * normal.x + cy * binormal.x;
            pos2.y += cx * normal.y + cy * binormal.y;
            pos2.z += cx * normal.z + cy * binormal.z;

            grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

        }

    }


    // construct the mesh

    for ( i = 0; i < segments; i ++ ) {

        for ( j = 0; j < radialSegments; j ++ ) {

            ip = ( closed ) ? ( i + 1 ) % segments : i + 1;
            jp = ( j + 1 ) % radialSegments;

            a = grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
            b = grid[ ip ][ j ];
            c = grid[ ip ][ jp ];
            d = grid[ i ][ jp ];

            uva = new THREE.Vector2( i / segments, j / radialSegments );
            uvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );
            uvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
            uvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );

            this.faces.push( new THREE.Face3( a, b, d ) );
            this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

            this.faces.push( new THREE.Face3( b, c, d ) );
            this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

        }

    }

    this.computeFaceNormals();
    this.computeVertexNormals();

};

THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;
THREE.TubeGeometry.prototype.clone = function() {

    return new this.constructor( this.parameters.path,
        this.parameters.segments, this.parameters.radius, this.parameters.radialSegments,
        this.parameters.closed, this.parameters.taper
    );

};

THREE.TubeGeometry.NoTaper = function ( u ) {

    return 1;

};

THREE.TubeGeometry.SinusoidalTaper = function ( u ) {

    return Math.sin( Math.PI * u );

};

// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
THREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {

    var	normal = new THREE.Vector3(),

        tangents = [],
        normals = [],
        binormals = [],

        vec = new THREE.Vector3(),
        mat = new THREE.Matrix4(),

        numpoints = segments + 1,
        theta,
        smallest,

        tx, ty, tz,
        i, u;


    // expose internals
    this.tangents = tangents;
    this.normals = normals;
    this.binormals = binormals;

    // compute the tangent vectors for each segment on the path

    for ( i = 0; i < numpoints; i ++ ) {

        u = i / ( numpoints - 1 );

        tangents[ i ] = path.getTangentAt( u );
        tangents[ i ].normalize();

    }

    initialNormal3();

    /*
     function initialNormal1(lastBinormal) {
     // fixed start binormal. Has dangers of 0 vectors
     normals[ 0 ] = new THREE.Vector3();
     binormals[ 0 ] = new THREE.Vector3();
     if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
     normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
     binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
     }

     function initialNormal2() {

     // This uses the Frenet-Serret formula for deriving binormal
     var t2 = path.getTangentAt( epsilon );

     normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
     binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

     normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
     binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

     }
     */

    function initialNormal3() {

        // select an initial normal vector perpendicular to the first tangent vector,
        // and in the direction of the smallest tangent xyz component

        normals[ 0 ] = new THREE.Vector3();
        binormals[ 0 ] = new THREE.Vector3();
        smallest = Number.MAX_VALUE;
        tx = Math.abs( tangents[ 0 ].x );
        ty = Math.abs( tangents[ 0 ].y );
        tz = Math.abs( tangents[ 0 ].z );

        if ( tx <= smallest ) {

            smallest = tx;
            normal.set( 1, 0, 0 );

        }

        if ( ty <= smallest ) {

            smallest = ty;
            normal.set( 0, 1, 0 );

        }

        if ( tz <= smallest ) {

            normal.set( 0, 0, 1 );

        }

        vec.crossVectors( tangents[ 0 ], normal ).normalize();

        normals[ 0 ].crossVectors( tangents[ 0 ], vec );
        binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );

    }


    // compute the slowly-varying normal and binormal vectors for each segment on the path

    for ( i = 1; i < numpoints; i ++ ) {

        normals[ i ] = normals[ i - 1 ].clone();

        binormals[ i ] = binormals[ i - 1 ].clone();

        vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

        if ( vec.length() > Number.EPSILON ) {

            vec.normalize();

            theta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

            normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

        }

        binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

    }


    // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

    if ( closed ) {

        theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );
        theta /= ( numpoints - 1 );

        if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {

            theta = - theta;

        }

        for ( i = 1; i < numpoints; i ++ ) {

            // twist a little...
            normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
            binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

        }

    }

};

// File:src/extras/geometries/PolyhedronGeometry.js

/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {

    THREE.Geometry.call( this );

    this.type = 'PolyhedronGeometry';

    this.parameters = {
        vertices: vertices,
        indices: indices,
        radius: radius,
        detail: detail
    };

    radius = radius || 1;
    detail = detail || 0;

    var that = this;

    for ( var i = 0, l = vertices.length; i < l; i += 3 ) {

        prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

    }

    var p = this.vertices;

    var faces = [];

    for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {

        var v1 = p[ indices[ i ] ];
        var v2 = p[ indices[ i + 1 ] ];
        var v3 = p[ indices[ i + 2 ] ];

        faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, j );

    }

    var centroid = new THREE.Vector3();

    for ( var i = 0, l = faces.length; i < l; i ++ ) {

        subdivide( faces[ i ], detail );

    }


    // Handle case when face straddles the seam

    for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {

        var uvs = this.faceVertexUvs[ 0 ][ i ];

        var x0 = uvs[ 0 ].x;
        var x1 = uvs[ 1 ].x;
        var x2 = uvs[ 2 ].x;

        var max = Math.max( x0, x1, x2 );
        var min = Math.min( x0, x1, x2 );

        if ( max > 0.9 && min < 0.1 ) {

            // 0.9 is somewhat arbitrary

            if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
            if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
            if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

        }

    }


    // Apply radius

    for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {

        this.vertices[ i ].multiplyScalar( radius );

    }


    // Merge vertices

    this.mergeVertices();

    this.computeFaceNormals();

    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );


    // Project vector onto sphere's surface

    function prepare( vector ) {

        var vertex = vector.normalize().clone();
        vertex.index = that.vertices.push( vertex ) - 1;

        // Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

        var u = azimuth( vector ) / 2 / Math.PI + 0.5;
        var v = inclination( vector ) / Math.PI + 0.5;
        vertex.uv = new THREE.Vector2( u, 1 - v );

        return vertex;

    }


    // Approximate a curved face with recursively sub-divided triangles.

    function make( v1, v2, v3, materialIndex ) {

        var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, materialIndex );
        that.faces.push( face );

        centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );

        var azi = azimuth( centroid );

        that.faceVertexUvs[ 0 ].push( [
            correctUV( v1.uv, v1, azi ),
            correctUV( v2.uv, v2, azi ),
            correctUV( v3.uv, v3, azi )
        ] );

    }


    // Analytically subdivide a face to the required detail level.

    function subdivide( face, detail ) {

        var cols = Math.pow( 2, detail );
        var a = prepare( that.vertices[ face.a ] );
        var b = prepare( that.vertices[ face.b ] );
        var c = prepare( that.vertices[ face.c ] );
        var v = [];

        var materialIndex = face.materialIndex;

        // Construct all of the vertices for this subdivision.

        for ( var i = 0 ; i <= cols; i ++ ) {

            v[ i ] = [];

            var aj = prepare( a.clone().lerp( c, i / cols ) );
            var bj = prepare( b.clone().lerp( c, i / cols ) );
            var rows = cols - i;

            for ( var j = 0; j <= rows; j ++ ) {

                if ( j === 0 && i === cols ) {

                    v[ i ][ j ] = aj;

                } else {

                    v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

                }

            }

        }

        // Construct all of the faces.

        for ( var i = 0; i < cols ; i ++ ) {

            for ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

                var k = Math.floor( j / 2 );

                if ( j % 2 === 0 ) {

                    make(
                        v[ i ][ k + 1 ],
                        v[ i + 1 ][ k ],
                        v[ i ][ k ],
                        materialIndex
                    );

                } else {

                    make(
                        v[ i ][ k + 1 ],
                        v[ i + 1 ][ k + 1 ],
                        v[ i + 1 ][ k ],
                        materialIndex
                    );

                }

            }

        }

    }


    // Angle around the Y axis, counter-clockwise when looking from above.

    function azimuth( vector ) {

        return Math.atan2( vector.z, - vector.x );

    }


    // Angle above the XZ plane.

    function inclination( vector ) {

        return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

    }


    // Texture fixing helper. Spheres have some odd behaviours.

    function correctUV( uv, vector, azimuth ) {

        if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
        if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
        return uv.clone();

    }


};

THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;

THREE.PolyhedronGeometry.prototype.clone = function () {

    var parameters = this.parameters;

    return new THREE.PolyhedronGeometry(
        parameters.vertices,
        parameters.indices,
        parameters.radius,
        parameters.detail
    );

};

// File:src/extras/geometries/DodecahedronGeometry.js

/**
 * @author Abe Pazos / https://hamoid.com
 */

THREE.DodecahedronGeometry = function ( radius, detail ) {

    var t = ( 1 + Math.sqrt( 5 ) ) / 2;
    var r = 1 / t;

    var vertices = [

        // (�1, �1, �1)
        - 1, - 1, - 1,    - 1, - 1,  1,
        - 1,  1, - 1,    - 1,  1,  1,
        1, - 1, - 1,     1, - 1,  1,
        1,  1, - 1,     1,  1,  1,

        // (0, �1/?, �?)
        0, - r, - t,     0, - r,  t,
        0,  r, - t,     0,  r,  t,

        // (�1/?, �?, 0)
        - r, - t,  0,    - r,  t,  0,
        r, - t,  0,     r,  t,  0,

        // (�?, 0, �1/?)
        - t,  0, - r,     t,  0, - r,
        - t,  0,  r,     t,  0,  r
    ];

    var indices = [
        3, 11,  7,      3,  7, 15,      3, 15, 13,
        7, 19, 17,      7, 17,  6,      7,  6, 15,
        17,  4,  8,     17,  8, 10,     17, 10,  6,
        8,  0, 16,      8, 16,  2,      8,  2, 10,
        0, 12,  1,      0,  1, 18,      0, 18, 16,
        6, 10,  2,      6,  2, 13,      6, 13, 15,
        2, 16, 18,      2, 18,  3,      2,  3, 13,
        18,  1,  9,     18,  9, 11,     18, 11,  3,
        4, 14, 12,      4, 12,  0,      4,  0,  8,
        11,  9,  5,     11,  5, 19,     11, 19,  7,
        19,  5, 14,     19, 14,  4,     19,  4, 17,
        1, 12, 14,      1, 14,  5,      1,  5,  9
    ];

    THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    this.type = 'DodecahedronGeometry';

    this.parameters = {
        radius: radius,
        detail: detail
    };

};

THREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;

THREE.DodecahedronGeometry.prototype.clone = function () {

    var parameters = this.parameters;

    return new THREE.DodecahedronGeometry(
        parameters.radius,
        parameters.detail
    );

};

// File:src/extras/geometries/IcosahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.IcosahedronGeometry = function ( radius, detail ) {

    var t = ( 1 + Math.sqrt( 5 ) ) / 2;

    var vertices = [
        - 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
        0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
        t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
    ];

    var indices = [
        0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
        1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
        3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
        4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
    ];

    THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    this.type = 'IcosahedronGeometry';

    this.parameters = {
        radius: radius,
        detail: detail
    };

};

THREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;

THREE.IcosahedronGeometry.prototype.clone = function () {

    var parameters = this.parameters;

    return new THREE.IcosahedronGeometry(
        parameters.radius,
        parameters.detail
    );

};

// File:src/extras/geometries/OctahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.OctahedronGeometry = function ( radius, detail ) {

    var vertices = [
        1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1
    ];

    var indices = [
        0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
    ];

    THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    this.type = 'OctahedronGeometry';

    this.parameters = {
        radius: radius,
        detail: detail
    };

};

THREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;

THREE.OctahedronGeometry.prototype.clone = function () {

    var parameters = this.parameters;

    return new THREE.OctahedronGeometry(
        parameters.radius,
        parameters.detail
    );

};

// File:src/extras/geometries/TetrahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.TetrahedronGeometry = function ( radius, detail ) {

    var vertices = [
        1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
    ];

    var indices = [
        2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
    ];

    THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    this.type = 'TetrahedronGeometry';

    this.parameters = {
        radius: radius,
        detail: detail
    };

};

THREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;

THREE.TetrahedronGeometry.prototype.clone = function () {

    var parameters = this.parameters;

    return new THREE.TetrahedronGeometry(
        parameters.radius,
        parameters.detail
    );

};

// File:src/extras/geometries/ParametricGeometry.js

/**
 * @author zz85 / https://github.com/zz85
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 *
 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
 *
 */

THREE.ParametricGeometry = function ( func, slices, stacks ) {

    THREE.Geometry.call( this );

    this.type = 'ParametricGeometry';

    this.parameters = {
        func: func,
        slices: slices,
        stacks: stacks
    };

    var verts = this.vertices;
    var faces = this.faces;
    var uvs = this.faceVertexUvs[ 0 ];

    var i, j, p;
    var u, v;

    var sliceCount = slices + 1;

    for ( i = 0; i <= stacks; i ++ ) {

        v = i / stacks;

        for ( j = 0; j <= slices; j ++ ) {

            u = j / slices;

            p = func( u, v );
            verts.push( p );

        }

    }

    var a, b, c, d;
    var uva, uvb, uvc, uvd;

    for ( i = 0; i < stacks; i ++ ) {

        for ( j = 0; j < slices; j ++ ) {

            a = i * sliceCount + j;
            b = i * sliceCount + j + 1;
            c = ( i + 1 ) * sliceCount + j + 1;
            d = ( i + 1 ) * sliceCount + j;

            uva = new THREE.Vector2( j / slices, i / stacks );
            uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
            uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
            uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );

            faces.push( new THREE.Face3( a, b, d ) );
            uvs.push( [ uva, uvb, uvd ] );

            faces.push( new THREE.Face3( b, c, d ) );
            uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );

        }

    }

    // console.log(this);

    // magic bullet
    // var diff = this.mergeVertices();
    // console.log('removed ', diff, ' vertices by merging');

    this.computeFaceNormals();
    this.computeVertexNormals();

};

THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;

// File:src/extras/geometries/WireframeGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeGeometry = function ( geometry ) {

    THREE.BufferGeometry.call( this );

    var edge = [ 0, 0 ], hash = {};

    function sortFunction( a, b ) {

        return a - b;

    }

    var keys = [ 'a', 'b', 'c' ];

    if ( geometry instanceof THREE.Geometry ) {

        var vertices = geometry.vertices;
        var faces = geometry.faces;
        var numEdges = 0;

        // allocate maximal size
        var edges = new Uint32Array( 6 * faces.length );

        for ( var i = 0, l = faces.length; i < l; i ++ ) {

            var face = faces[ i ];

            for ( var j = 0; j < 3; j ++ ) {

                edge[ 0 ] = face[ keys[ j ] ];
                edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
                edge.sort( sortFunction );

                var key = edge.toString();

                if ( hash[ key ] === undefined ) {

                    edges[ 2 * numEdges ] = edge[ 0 ];
                    edges[ 2 * numEdges + 1 ] = edge[ 1 ];
                    hash[ key ] = true;
                    numEdges ++;

                }

            }

        }

        var coords = new Float32Array( numEdges * 2 * 3 );

        for ( var i = 0, l = numEdges; i < l; i ++ ) {

            for ( var j = 0; j < 2; j ++ ) {

                var vertex = vertices[ edges [ 2 * i + j ] ];

                var index = 6 * i + 3 * j;
                coords[ index + 0 ] = vertex.x;
                coords[ index + 1 ] = vertex.y;
                coords[ index + 2 ] = vertex.z;

            }

        }

        this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

    } else if ( geometry instanceof THREE.BufferGeometry ) {

        if ( geometry.index !== null ) {

            // Indexed BufferGeometry

            var indices = geometry.index.array;
            var vertices = geometry.attributes.position;
            var drawcalls = geometry.drawcalls;
            var numEdges = 0;

            if ( drawcalls.length === 0 ) {

                geometry.addGroup( 0, indices.length );

            }

            // allocate maximal size
            var edges = new Uint32Array( 2 * indices.length );

            for ( var o = 0, ol = drawcalls.length; o < ol; ++ o ) {

                var drawcall = drawcalls[ o ];

                var start = drawcall.start;
                var count = drawcall.count;

                for ( var i = start, il = start + count; i < il; i += 3 ) {

                    for ( var j = 0; j < 3; j ++ ) {

                        edge[ 0 ] = indices[ i + j ];
                        edge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];
                        edge.sort( sortFunction );

                        var key = edge.toString();

                        if ( hash[ key ] === undefined ) {

                            edges[ 2 * numEdges ] = edge[ 0 ];
                            edges[ 2 * numEdges + 1 ] = edge[ 1 ];
                            hash[ key ] = true;
                            numEdges ++;

                        }

                    }

                }

            }

            var coords = new Float32Array( numEdges * 2 * 3 );

            for ( var i = 0, l = numEdges; i < l; i ++ ) {

                for ( var j = 0; j < 2; j ++ ) {

                    var index = 6 * i + 3 * j;
                    var index2 = edges[ 2 * i + j ];

                    coords[ index + 0 ] = vertices.getX( index2 );
                    coords[ index + 1 ] = vertices.getY( index2 );
                    coords[ index + 2 ] = vertices.getZ( index2 );

                }

            }

            this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

        } else {

            // non-indexed BufferGeometry

            var vertices = geometry.attributes.position.array;
            var numEdges = vertices.length / 3;
            var numTris = numEdges / 3;

            var coords = new Float32Array( numEdges * 2 * 3 );

            for ( var i = 0, l = numTris; i < l; i ++ ) {

                for ( var j = 0; j < 3; j ++ ) {

                    var index = 18 * i + 6 * j;

                    var index1 = 9 * i + 3 * j;
                    coords[ index + 0 ] = vertices[ index1 ];
                    coords[ index + 1 ] = vertices[ index1 + 1 ];
                    coords[ index + 2 ] = vertices[ index1 + 2 ];

                    var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
                    coords[ index + 3 ] = vertices[ index2 ];
                    coords[ index + 4 ] = vertices[ index2 + 1 ];
                    coords[ index + 5 ] = vertices[ index2 + 2 ];

                }

            }

            this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

        }

    }

};

THREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;

// File:src/extras/helpers/AxisHelper.js

/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AxisHelper = function ( size ) {

    size = size || 1;

    var vertices = new Float32Array( [
        0, 0, 0,  size, 0, 0,
        0, 0, 0,  0, size, 0,
        0, 0, 0,  0, 0, size
    ] );

    var colors = new Float32Array( [
        1, 0, 0,  1, 0.6, 0,
        0, 1, 0,  0.6, 1, 0,
        0, 0, 1,  0, 0.6, 1
    ] );

    var geometry = new THREE.BufferGeometry();
    geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
    geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

    var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

    THREE.LineSegments.call( this, geometry, material );

};

THREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;

// File:src/extras/helpers/ArrowHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://clara.io
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */

THREE.ArrowHelper = ( function () {

    var lineGeometry = new THREE.Geometry();
    lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );

    var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );
    coneGeometry.translate( 0, - 0.5, 0 );

    return function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

        // dir is assumed to be normalized

        THREE.Object3D.call( this );

        if ( color === undefined ) color = 0xffff00;
        if ( length === undefined ) length = 1;
        if ( headLength === undefined ) headLength = 0.2 * length;
        if ( headWidth === undefined ) headWidth = 0.2 * headLength;

        this.position.copy( origin );

        if ( headLength < length ) {
            this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );
            this.line.matrixAutoUpdate = false;
            this.add( this.line );
        }

        this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );
        this.cone.matrixAutoUpdate = false;
        this.add( this.cone );

        this.setDirection( dir );
        this.setLength( length, headLength, headWidth );

    }

}() );

THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;

THREE.ArrowHelper.prototype.setDirection = ( function () {

    var axis = new THREE.Vector3();
    var radians;

    return function setDirection( dir ) {

        // dir is assumed to be normalized

        if ( dir.y > 0.99999 ) {

            this.quaternion.set( 0, 0, 0, 1 );

        } else if ( dir.y < - 0.99999 ) {

            this.quaternion.set( 1, 0, 0, 0 );

        } else {

            axis.set( dir.z, 0, - dir.x ).normalize();

            radians = Math.acos( dir.y );

            this.quaternion.setFromAxisAngle( axis, radians );

        }

    };

}() );

THREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

    if ( headLength === undefined ) headLength = 0.2 * length;
    if ( headWidth === undefined ) headWidth = 0.2 * headLength;

    if ( headLength < length ){
        this.line.scale.set( 1, length - headLength, 1 );
        this.line.updateMatrix();
    }

    this.cone.scale.set( headWidth, headLength, headWidth );
    this.cone.position.y = length;
    this.cone.updateMatrix();

};

THREE.ArrowHelper.prototype.setColor = function ( color ) {

    if ( this.line !== undefined ) this.line.material.color.set( color );
    this.cone.material.color.set( color );

};

// File:src/extras/helpers/BoxHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BoxHelper = function ( object ) {

    var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
    var positions = new Float32Array( 8 * 3 );

    var geometry = new THREE.BufferGeometry();
    geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
    geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

    THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ) );

    if ( object !== undefined ) {

        this.update( object );

    }

};

THREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;

THREE.BoxHelper.prototype.update = ( function () {

    var box = new THREE.Box3();

    return function ( object ) {

        box.setFromObject( object );

        if ( box.empty() ) return;

        var min = box.min;
        var max = box.max;

        /*
         5____4
         1/___0/|
         | 6__|_7
         2/___3/

         0: max.x, max.y, max.z
         1: min.x, max.y, max.z
         2: min.x, min.y, max.z
         3: max.x, min.y, max.z
         4: max.x, max.y, min.z
         5: min.x, max.y, min.z
         6: min.x, min.y, min.z
         7: max.x, min.y, min.z
         */

        var position = this.geometry.attributes.position;
        var array = position.array;

        array[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;
        array[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;
        array[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;
        array[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
        array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
        array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
        array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
        array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

        position.needsUpdate = true;

        this.geometry.computeBoundingSphere();

    }

} )();

// File:src/extras/helpers/BoundingBoxHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

// a helper to show the world-axis-aligned bounding box for an object

THREE.BoundingBoxHelper = function ( object, hex ) {

    var color = ( hex !== undefined ) ? hex : 0x888888;

    this.object = object;

    this.box = new THREE.Box3();

    THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );

};

THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );
THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;

THREE.BoundingBoxHelper.prototype.update = function () {

    this.box.setFromObject( this.object );

    this.box.size( this.scale );

    this.box.center( this.position );

};

// File:src/extras/helpers/CameraHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

THREE.CameraHelper = function ( camera ) {

    var geometry = new THREE.Geometry();
    var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );

    var pointMap = {};

    // colors

    var hexFrustum = 0xffaa00;
    var hexCone = 0xff0000;
    var hexUp = 0x00aaff;
    var hexTarget = 0xffffff;
    var hexCross = 0x333333;

    // near

    addLine( "n1", "n2", hexFrustum );
    addLine( "n2", "n4", hexFrustum );
    addLine( "n4", "n3", hexFrustum );
    addLine( "n3", "n1", hexFrustum );

    // far

    addLine( "f1", "f2", hexFrustum );
    addLine( "f2", "f4", hexFrustum );
    addLine( "f4", "f3", hexFrustum );
    addLine( "f3", "f1", hexFrustum );

    // sides

    addLine( "n1", "f1", hexFrustum );
    addLine( "n2", "f2", hexFrustum );
    addLine( "n3", "f3", hexFrustum );
    addLine( "n4", "f4", hexFrustum );

    // cone

    addLine( "p", "n1", hexCone );
    addLine( "p", "n2", hexCone );
    addLine( "p", "n3", hexCone );
    addLine( "p", "n4", hexCone );

    // up

    addLine( "u1", "u2", hexUp );
    addLine( "u2", "u3", hexUp );
    addLine( "u3", "u1", hexUp );

    // target

    addLine( "c", "t", hexTarget );
    addLine( "p", "c", hexCross );

    // cross

    addLine( "cn1", "cn2", hexCross );
    addLine( "cn3", "cn4", hexCross );

    addLine( "cf1", "cf2", hexCross );
    addLine( "cf3", "cf4", hexCross );

    function addLine( a, b, hex ) {

        addPoint( a, hex );
        addPoint( b, hex );

    }

    function addPoint( id, hex ) {

        geometry.vertices.push( new THREE.Vector3() );
        geometry.colors.push( new THREE.Color( hex ) );

        if ( pointMap[ id ] === undefined ) {

            pointMap[ id ] = [];

        }

        pointMap[ id ].push( geometry.vertices.length - 1 );

    }

    THREE.LineSegments.call( this, geometry, material );

    this.camera = camera;
    this.camera.updateProjectionMatrix();

    this.matrix = camera.matrixWorld;
    this.matrixAutoUpdate = false;

    this.pointMap = pointMap;

    this.update();

};

THREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;

THREE.CameraHelper.prototype.update = function () {

    var geometry, pointMap;

    var vector = new THREE.Vector3();
    var camera = new THREE.Camera();

    function setPoint( point, x, y, z ) {

        vector.set( x, y, z ).unproject( camera );

        var points = pointMap[ point ];

        if ( points !== undefined ) {

            for ( var i = 0, il = points.length; i < il; i ++ ) {

                geometry.vertices[ points[ i ] ].copy( vector );

            }

        }

    }

    return function () {

        geometry = this.geometry;
        pointMap = this.pointMap;

        var w = 1, h = 1;

        // we need just camera projection matrix
        // world matrix must be identity

        camera.projectionMatrix.copy( this.camera.projectionMatrix );

        // center / target

        setPoint( "c", 0, 0, - 1 );
        setPoint( "t", 0, 0,  1 );

        // near

        setPoint( "n1", - w, - h, - 1 );
        setPoint( "n2",   w, - h, - 1 );
        setPoint( "n3", - w,   h, - 1 );
        setPoint( "n4",   w,   h, - 1 );

        // far

        setPoint( "f1", - w, - h, 1 );
        setPoint( "f2",   w, - h, 1 );
        setPoint( "f3", - w,   h, 1 );
        setPoint( "f4",   w,   h, 1 );

        // up

        setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
        setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
        setPoint( "u3",         0, h * 2,   - 1 );

        // cross

        setPoint( "cf1", - w,   0, 1 );
        setPoint( "cf2",   w,   0, 1 );
        setPoint( "cf3",   0, - h, 1 );
        setPoint( "cf4",   0,   h, 1 );

        setPoint( "cn1", - w,   0, - 1 );
        setPoint( "cn2",   w,   0, - 1 );
        setPoint( "cn3",   0, - h, - 1 );
        setPoint( "cn4",   0,   h, - 1 );

        geometry.verticesNeedUpdate = true;

    };

}();

// File:src/extras/helpers/DirectionalLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.DirectionalLightHelper = function ( light, size ) {

    THREE.Object3D.call( this );

    this.light = light;
    this.light.updateMatrixWorld();

    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;

    size = size || 1;

    var geometry = new THREE.Geometry();
    geometry.vertices.push(
        new THREE.Vector3( - size,   size, 0 ),
        new THREE.Vector3(   size,   size, 0 ),
        new THREE.Vector3(   size, - size, 0 ),
        new THREE.Vector3( - size, - size, 0 ),
        new THREE.Vector3( - size,   size, 0 )
    );

    var material = new THREE.LineBasicMaterial( { fog: false } );
    material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    this.lightPlane = new THREE.Line( geometry, material );
    this.add( this.lightPlane );

    geometry = new THREE.Geometry();
    geometry.vertices.push(
        new THREE.Vector3(),
        new THREE.Vector3()
    );

    material = new THREE.LineBasicMaterial( { fog: false } );
    material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    this.targetLine = new THREE.Line( geometry, material );
    this.add( this.targetLine );

    this.update();

};

THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;

THREE.DirectionalLightHelper.prototype.dispose = function () {

    this.lightPlane.geometry.dispose();
    this.lightPlane.material.dispose();
    this.targetLine.geometry.dispose();
    this.targetLine.material.dispose();

};

THREE.DirectionalLightHelper.prototype.update = function () {

    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    var v3 = new THREE.Vector3();

    return function () {

        v1.setFromMatrixPosition( this.light.matrixWorld );
        v2.setFromMatrixPosition( this.light.target.matrixWorld );
        v3.subVectors( v2, v1 );

        this.lightPlane.lookAt( v3 );
        this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

        this.targetLine.geometry.vertices[ 1 ].copy( v3 );
        this.targetLine.geometry.verticesNeedUpdate = true;
        this.targetLine.material.color.copy( this.lightPlane.material.color );

    };

}();

// File:src/extras/helpers/EdgesHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 * @param object THREE.Mesh whose geometry will be used
 * @param hex line color
 * @param thresholdAngle the minimum angle (in degrees),
 * between the face normals of adjacent faces,
 * that is required to render an edge. A value of 10 means
 * an edge is only rendered if the angle is at least 10 degrees.
 */

THREE.EdgesHelper = function ( object, hex, thresholdAngle ) {

    var color = ( hex !== undefined ) ? hex : 0xffffff;

    THREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( { color: color } ) );

    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;

};

THREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;

// File:src/extras/helpers/FaceNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {

    // FaceNormalsHelper only supports THREE.Geometry

    this.object = object;

    this.size = ( size !== undefined ) ? size : 1;

    var color = ( hex !== undefined ) ? hex : 0xffff00;

    var width = ( linewidth !== undefined ) ? linewidth : 1;

    //

    var nNormals = 0;

    var objGeometry = this.object.geometry;

    if ( objGeometry instanceof THREE.Geometry ) {

        nNormals = objGeometry.faces.length;

    } else {

        console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

    }

    //

    var geometry = new THREE.BufferGeometry();

    var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );

    geometry.addAttribute( 'position', positions );

    THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );

    //

    this.matrixAutoUpdate = false;
    this.update();

};

THREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;

THREE.FaceNormalsHelper.prototype.update = ( function () {

    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    var normalMatrix = new THREE.Matrix3();

    return function update() {

        this.object.updateMatrixWorld( true );

        normalMatrix.getNormalMatrix( this.object.matrixWorld );

        var matrixWorld = this.object.matrixWorld;

        var position = this.geometry.attributes.position;

        //

        var objGeometry = this.object.geometry;

        var vertices = objGeometry.vertices;

        var faces = objGeometry.faces;

        var idx = 0;

        for ( var i = 0, l = faces.length; i < l; i ++ ) {

            var face = faces[ i ];

            var normal = face.normal;

            v1.copy( vertices[ face.a ] )
                .add( vertices[ face.b ] )
                .add( vertices[ face.c ] )
                .divideScalar( 3 )
                .applyMatrix4( matrixWorld );

            v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

            position.setXYZ( idx, v1.x, v1.y, v1.z );

            idx = idx + 1;

            position.setXYZ( idx, v2.x, v2.y, v2.z );

            idx = idx + 1;

        }

        position.needsUpdate = true;

        return this;

    }

}() );

// File:src/extras/helpers/GridHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GridHelper = function ( size, step ) {

    var geometry = new THREE.Geometry();
    var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

    this.color1 = new THREE.Color( 0x444444 );
    this.color2 = new THREE.Color( 0x888888 );

    for ( var i = - size; i <= size; i += step ) {

        geometry.vertices.push(
            new THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),
            new THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )
        );

        var color = i === 0 ? this.color1 : this.color2;

        geometry.colors.push( color, color, color, color );

    }

    THREE.LineSegments.call( this, geometry, material );

};

THREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.GridHelper.prototype.constructor = THREE.GridHelper;

THREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {

    this.color1.set( colorCenterLine );
    this.color2.set( colorGrid );

    this.geometry.colorsNeedUpdate = true;

};

// File:src/extras/helpers/HemisphereLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.HemisphereLightHelper = function ( light, sphereSize ) {

    THREE.Object3D.call( this );

    this.light = light;
    this.light.updateMatrixWorld();

    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;

    this.colors = [ new THREE.Color(), new THREE.Color() ];

    var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
    geometry.rotateX( - Math.PI / 2 );

    for ( var i = 0, il = 8; i < il; i ++ ) {

        geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

    }

    var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );

    this.lightSphere = new THREE.Mesh( geometry, material );
    this.add( this.lightSphere );

    this.update();

};

THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;

THREE.HemisphereLightHelper.prototype.dispose = function () {

    this.lightSphere.geometry.dispose();
    this.lightSphere.material.dispose();

};

THREE.HemisphereLightHelper.prototype.update = function () {

    var vector = new THREE.Vector3();

    return function () {

        this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
        this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

        this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
        this.lightSphere.geometry.colorsNeedUpdate = true;

    }

}();

// File:src/extras/helpers/PointLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLightHelper = function ( light, sphereSize ) {

    this.light = light;
    this.light.updateMatrixWorld();

    var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
    var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
    material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    THREE.Mesh.call( this, geometry, material );

    this.matrix = this.light.matrixWorld;
    this.matrixAutoUpdate = false;

    /*
     var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
     var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

     this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
     this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

     var d = light.distance;

     if ( d === 0.0 ) {

     this.lightDistance.visible = false;

     } else {

     this.lightDistance.scale.set( d, d, d );

     }

     this.add( this.lightDistance );
     */

};

THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );
THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;

THREE.PointLightHelper.prototype.dispose = function () {

    this.geometry.dispose();
    this.material.dispose();

};

THREE.PointLightHelper.prototype.update = function () {

    this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    /*
     var d = this.light.distance;

     if ( d === 0.0 ) {

     this.lightDistance.visible = false;

     } else {

     this.lightDistance.visible = true;
     this.lightDistance.scale.set( d, d, d );

     }
     */

};

// File:src/extras/helpers/SkeletonHelper.js

/**
 * @author Sean Griffin / http://twitter.com/sgrif
 * @author Michael Guerrero / http://realitymeltdown.com
 * @author mrdoob / http://mrdoob.com/
 * @author ikerr / http://verold.com
 */

THREE.SkeletonHelper = function ( object ) {

    this.bones = this.getBoneList( object );

    var geometry = new THREE.Geometry();

    for ( var i = 0; i < this.bones.length; i ++ ) {

        var bone = this.bones[ i ];

        if ( bone.parent instanceof THREE.Bone ) {

            geometry.vertices.push( new THREE.Vector3() );
            geometry.vertices.push( new THREE.Vector3() );
            geometry.colors.push( new THREE.Color( 0, 0, 1 ) );
            geometry.colors.push( new THREE.Color( 0, 1, 0 ) );

        }

    }

    geometry.dynamic = true;

    var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );

    THREE.LineSegments.call( this, geometry, material );

    this.root = object;

    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;

    this.update();

};


THREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;

THREE.SkeletonHelper.prototype.getBoneList = function( object ) {

    var boneList = [];

    if ( object instanceof THREE.Bone ) {

        boneList.push( object );

    }

    for ( var i = 0; i < object.children.length; i ++ ) {

        boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

    }

    return boneList;

};

THREE.SkeletonHelper.prototype.update = function () {

    var geometry = this.geometry;

    var matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );

    var boneMatrix = new THREE.Matrix4();

    var j = 0;

    for ( var i = 0; i < this.bones.length; i ++ ) {

        var bone = this.bones[ i ];

        if ( bone.parent instanceof THREE.Bone ) {

            boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
            geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );

            boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
            geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );

            j += 2;

        }

    }

    geometry.verticesNeedUpdate = true;

    geometry.computeBoundingSphere();

};

// File:src/extras/helpers/SpotLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.SpotLightHelper = function ( light ) {

    THREE.Object3D.call( this );

    this.light = light;
    this.light.updateMatrixWorld();

    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;

    var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );

    geometry.translate( 0, - 0.5, 0 );
    geometry.rotateX( - Math.PI / 2 );

    var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );

    this.cone = new THREE.Mesh( geometry, material );
    this.add( this.cone );

    this.update();

};

THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;

THREE.SpotLightHelper.prototype.dispose = function () {

    this.cone.geometry.dispose();
    this.cone.material.dispose();

};

THREE.SpotLightHelper.prototype.update = function () {

    var vector = new THREE.Vector3();
    var vector2 = new THREE.Vector3();

    return function () {

        var coneLength = this.light.distance ? this.light.distance : 10000;
        var coneWidth = coneLength * Math.tan( this.light.angle );

        this.cone.scale.set( coneWidth, coneWidth, coneLength );

        vector.setFromMatrixPosition( this.light.matrixWorld );
        vector2.setFromMatrixPosition( this.light.target.matrixWorld );

        this.cone.lookAt( vector2.sub( vector ) );

        this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    };

}();

// File:src/extras/helpers/VertexNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {

    this.object = object;

    this.size = ( size !== undefined ) ? size : 1;

    var color = ( hex !== undefined ) ? hex : 0xff0000;

    var width = ( linewidth !== undefined ) ? linewidth : 1;

    //

    var nNormals = 0;

    var objGeometry = this.object.geometry;

    if ( objGeometry instanceof THREE.Geometry ) {

        nNormals = objGeometry.faces.length * 3;

    } else if ( objGeometry instanceof THREE.BufferGeometry ) {

        nNormals = objGeometry.attributes.normal.count

    }

    //

    var geometry = new THREE.BufferGeometry();

    var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );

    geometry.addAttribute( 'position', positions );

    THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );

    //

    this.matrixAutoUpdate = false;

    this.update();

};

THREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;

THREE.VertexNormalsHelper.prototype.update = ( function () {

    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    var normalMatrix = new THREE.Matrix3();

    return function update() {

        var keys = [ 'a', 'b', 'c' ];

        this.object.updateMatrixWorld( true );

        normalMatrix.getNormalMatrix( this.object.matrixWorld );

        var matrixWorld = this.object.matrixWorld;

        var position = this.geometry.attributes.position;

        //

        var objGeometry = this.object.geometry;

        if ( objGeometry instanceof THREE.Geometry ) {

            var vertices = objGeometry.vertices;

            var faces = objGeometry.faces;

            var idx = 0;

            for ( var i = 0, l = faces.length; i < l; i ++ ) {

                var face = faces[ i ];

                for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

                    var vertex = vertices[ face[ keys[ j ] ] ];

                    var normal = face.vertexNormals[ j ];

                    v1.copy( vertex ).applyMatrix4( matrixWorld );

                    v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

                    position.setXYZ( idx, v1.x, v1.y, v1.z );

                    idx = idx + 1;

                    position.setXYZ( idx, v2.x, v2.y, v2.z );

                    idx = idx + 1;

                }

            }

        } else if ( objGeometry instanceof THREE.BufferGeometry ) {

            var objPos = objGeometry.attributes.position;

            var objNorm = objGeometry.attributes.normal;

            var idx = 0;

            // for simplicity, ignore index and drawcalls, and render every normal

            for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

                v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

                v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

                v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

                position.setXYZ( idx, v1.x, v1.y, v1.z );

                idx = idx + 1;

                position.setXYZ( idx, v2.x, v2.y, v2.z );

                idx = idx + 1;

            }

        }

        position.needsUpdate = true;

        return this;

    }

}() );

// File:src/extras/helpers/WireframeHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeHelper = function ( object, hex ) {

    var color = ( hex !== undefined ) ? hex : 0xffffff;

    THREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( { color: color } ) );

    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;

};

THREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;

// File:src/extras/objects/ImmediateRenderObject.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ImmediateRenderObject = function ( material ) {

    THREE.Object3D.call( this );

    this.material = material;
    this.render = function ( renderCallback ) {};

};

THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );
THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;

// File:src/extras/objects/MorphBlendMesh.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphBlendMesh = function( geometry, material ) {

    THREE.Mesh.call( this, geometry, material );

    this.animationsMap = {};
    this.animationsList = [];

    // prepare default animation
    // (all frames played together in 1 second)

    var numFrames = this.geometry.morphTargets.length;

    var name = "__default";

    var startFrame = 0;
    var endFrame = numFrames - 1;

    var fps = numFrames / 1;

    this.createAnimation( name, startFrame, endFrame, fps );
    this.setAnimationWeight( name, 1 );

};

THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;

THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

    var animation = {

        start: start,
        end: end,

        length: end - start + 1,

        fps: fps,
        duration: ( end - start ) / fps,

        lastFrame: 0,
        currentFrame: 0,

        active: false,

        time: 0,
        direction: 1,
        weight: 1,

        directionBackwards: false,
        mirroredLoop: false

    };

    this.animationsMap[ name ] = animation;
    this.animationsList.push( animation );

};

THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

    var pattern = /([a-z]+)_?(\d+)/;

    var firstAnimation, frameRanges = {};

    var geometry = this.geometry;

    for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

        var morph = geometry.morphTargets[ i ];
        var chunks = morph.name.match( pattern );

        if ( chunks && chunks.length > 1 ) {

            var name = chunks[ 1 ];

            if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };

            var range = frameRanges[ name ];

            if ( i < range.start ) range.start = i;
            if ( i > range.end ) range.end = i;

            if ( ! firstAnimation ) firstAnimation = name;

        }

    }

    for ( var name in frameRanges ) {

        var range = frameRanges[ name ];
        this.createAnimation( name, range.start, range.end, fps );

    }

    this.firstAnimation = firstAnimation;

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.direction = 1;
        animation.directionBackwards = false;

    }

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.direction = - 1;
        animation.directionBackwards = true;

    }

};

THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.fps = fps;
        animation.duration = ( animation.end - animation.start ) / animation.fps;

    }

};

THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.duration = duration;
        animation.fps = ( animation.end - animation.start ) / animation.duration;

    }

};

THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.weight = weight;

    }

};

THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.time = time;

    }

};

THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

    var time = 0;

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        time = animation.time;

    }

    return time;

};

THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

    var duration = - 1;

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        duration = animation.duration;

    }

    return duration;

};

THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.time = 0;
        animation.active = true;

    } else {

        console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );

    }

};

THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {

    var animation = this.animationsMap[ name ];

    if ( animation ) {

        animation.active = false;

    }

};

THREE.MorphBlendMesh.prototype.update = function ( delta ) {

    for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

        var animation = this.animationsList[ i ];

        if ( ! animation.active ) continue;

        var frameTime = animation.duration / animation.length;

        animation.time += animation.direction * delta;

        if ( animation.mirroredLoop ) {

            if ( animation.time > animation.duration || animation.time < 0 ) {

                animation.direction *= - 1;

                if ( animation.time > animation.duration ) {

                    animation.time = animation.duration;
                    animation.directionBackwards = true;

                }

                if ( animation.time < 0 ) {

                    animation.time = 0;
                    animation.directionBackwards = false;

                }

            }

        } else {

            animation.time = animation.time % animation.duration;

            if ( animation.time < 0 ) animation.time += animation.duration;

        }

        var keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
        var weight = animation.weight;

        if ( keyframe !== animation.currentFrame ) {

            this.morphTargetInfluences[ animation.lastFrame ] = 0;
            this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

            this.morphTargetInfluences[ keyframe ] = 0;

            animation.lastFrame = animation.currentFrame;
            animation.currentFrame = keyframe;

        }

        var mix = ( animation.time % frameTime ) / frameTime;

        if ( animation.directionBackwards ) mix = 1 - mix;

        if ( animation.currentFrame !== animation.lastFrame ) {

            this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
            this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

        } else {

            this.morphTargetInfluences[ animation.currentFrame ] = weight;

        }

    }

};
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For creating 3D text geometry in three.js
 *
 * Text = 3D Text
 *
 * parameters = {
 *  size: 			<float>, 	// size of the text
 *  height: 		<float>, 	// thickness to extrude text
 *  curveSegments: 	<int>,		// number of points on the curves
 *
 *  font: 			<string>,		// font name
 *  weight: 		<string>,		// font weight (normal, bold)
 *  style: 			<string>,		// font style  (normal, italics)
 *
 *  bevelEnabled:	<bool>,			// turn on bevel
 *  bevelThickness: <float>, 		// how deep into text bevel goes
 *  bevelSize:		<float>, 		// how far from text outline is bevel
 *  }
 *
 */

/*	Usage Examples

 // TextGeometry wrapper

 var text3d = new TextGeometry( text, options );

 // Complete manner

 var textShapes = THREE.FontUtils.generateShapes( text, options );
 var text3d = new ExtrudeGeometry( textShapes, options );

 */

THREE.TextGeometry = function ( text, parameters ) {

    parameters = parameters || {};

    var textShapes = THREE.FontUtils.generateShapes( text, parameters );

    // translate parameters to ExtrudeGeometry API

    parameters.amount = parameters.height !== undefined ? parameters.height : 50;

    // defaults

    if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
    if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
    if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

    THREE.ExtrudeGeometry.call( this, textShapes, parameters );

    this.type = 'TextGeometry';

};

THREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );
THREE.TextGeometry.prototype.constructor = THREE.TextGeometry;




/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For Text operations in three.js (See TextGeometry)
 *
 * It uses techniques used in:
 *
 *	Triangulation ported from AS3
 *		Simple Polygon Triangulation
 *		http://actionsnippet.com/?p=1462
 *
 * 	A Method to triangulate shapes with holes
 *		http://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/
 *
 */

THREE.FontUtils = {

    faces: {},

    // Just for now. face[weight][style]

    face: 'helvetiker',
    weight: 'normal',
    style: 'normal',
    size: 150,
    divisions: 10,

    getFace: function () {

        try {

            return this.faces[ this.face.toLowerCase() ][ this.weight ][ this.style ];

        } catch ( e ) {

            throw "The font " + this.face + " with " + this.weight + " weight and " + this.style + " style is missing."

        }

    },

    loadFace: function ( data ) {

        var family = data.familyName.toLowerCase();

        var ThreeFont = this;

        ThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};

        ThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};
        ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

        ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

        return data;

    },

    drawText: function ( text ) {

        // RenderText

        var i,
            face = this.getFace(),
            scale = this.size / face.resolution,
            offset = 0,
            chars = String( text ).split( '' ),
            length = chars.length;

        var fontPaths = [];

        for ( i = 0; i < length; i ++ ) {

            var path = new THREE.Path();

            var ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );
            offset += ret.offset;

            fontPaths.push( ret.path );

        }

        // get the width

        var width = offset / 2;
        //
        // for ( p = 0; p < allPts.length; p++ ) {
        //
        // 	allPts[ p ].x -= width;
        //
        // }

        //var extract = this.extractPoints( allPts, characterPts );
        //extract.contour = allPts;

        //extract.paths = fontPaths;
        //extract.offset = width;

        return { paths: fontPaths, offset: width };

    },




    extractGlyphPoints: function ( c, face, scale, offset, path ) {

        var pts = [];

        var b2 = THREE.ShapeUtils.b2;
        var b3 = THREE.ShapeUtils.b3;

        var i, i2, divisions,
            outline, action, length,
            scaleX, scaleY,
            x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,
            laste,
            glyph = face.glyphs[ c ] || face.glyphs[ '?' ];

        if ( ! glyph ) return;

        if ( glyph.o ) {

            outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
            length = outline.length;

            scaleX = scale;
            scaleY = scale;

            for ( i = 0; i < length; ) {

                action = outline[ i ++ ];

                //console.log( action );

                switch ( action ) {

                    case 'm':

                        // Move To

                        x = outline[ i ++ ] * scaleX + offset;
                        y = outline[ i ++ ] * scaleY;

                        path.moveTo( x, y );
                        break;

                    case 'l':

                        // Line To

                        x = outline[ i ++ ] * scaleX + offset;
                        y = outline[ i ++ ] * scaleY;
                        path.lineTo( x, y );
                        break;

                    case 'q':

                        // QuadraticCurveTo

                        cpx  = outline[ i ++ ] * scaleX + offset;
                        cpy  = outline[ i ++ ] * scaleY;
                        cpx1 = outline[ i ++ ] * scaleX + offset;
                        cpy1 = outline[ i ++ ] * scaleY;

                        path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

                        laste = pts[ pts.length - 1 ];

                        if ( laste ) {

                            cpx0 = laste.x;
                            cpy0 = laste.y;

                            for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

                                var t = i2 / divisions;
                                b2( t, cpx0, cpx1, cpx );
                                b2( t, cpy0, cpy1, cpy );

                            }

                        }

                        break;

                    case 'b':

                        // Cubic Bezier Curve

                        cpx  = outline[ i ++ ] * scaleX + offset;
                        cpy  = outline[ i ++ ] * scaleY;
                        cpx1 = outline[ i ++ ] * scaleX + offset;
                        cpy1 = outline[ i ++ ] * scaleY;
                        cpx2 = outline[ i ++ ] * scaleX + offset;
                        cpy2 = outline[ i ++ ] * scaleY;

                        path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

                        laste = pts[ pts.length - 1 ];

                        if ( laste ) {

                            cpx0 = laste.x;
                            cpy0 = laste.y;

                            for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

                                var t = i2 / divisions;
                                b3( t, cpx0, cpx1, cpx2, cpx );
                                b3( t, cpy0, cpy1, cpy2, cpy );

                            }

                        }

                        break;

                }

            }

        }



        return { offset: glyph.ha * scale, path: path };

    }

};


THREE.FontUtils.generateShapes = function ( text, parameters ) {

    // Parameters

    parameters = parameters || {};

    var size = parameters.size !== undefined ? parameters.size : 100;
    var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments : 4;

    var font = parameters.font !== undefined ? parameters.font : 'helvetiker';
    var weight = parameters.weight !== undefined ? parameters.weight : 'normal';
    var style = parameters.style !== undefined ? parameters.style : 'normal';

    THREE.FontUtils.size = size;
    THREE.FontUtils.divisions = curveSegments;

    THREE.FontUtils.face = font;
    THREE.FontUtils.weight = weight;
    THREE.FontUtils.style = style;

    // Get a Font data json object

    var data = THREE.FontUtils.drawText( text );

    var paths = data.paths;
    var shapes = [];

    for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

        Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

    }

    return shapes;

};

// To use the typeface.js face files, hook up the API

THREE.typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };
if ( typeof self !== 'undefined' ) self._typeface_js = THREE.typeface_js;




// From github repository at three.js\examples\fontshelvetiker_regular.typeface.js
if (_typeface_js && _typeface_js.loadFace) _typeface_js.loadFace({"glyphs":{"?":{"x_min":0,"x_max":712,"ha":815,"o":"m 356 -25 q 96 88 192 -25 q 0 368 0 201 q 92 642 0 533 q 356 761 192 761 q 617 644 517 761 q 712 368 712 533 q 619 91 712 201 q 356 -25 520 -25 m 356 85 q 527 175 465 85 q 583 369 583 255 q 528 562 583 484 q 356 651 466 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 356 85 250 85 "},"S":{"x_min":0,"x_max":788,"ha":890,"o":"m 788 291 q 662 54 788 144 q 397 -26 550 -26 q 116 68 226 -26 q 0 337 0 168 l 131 337 q 200 152 131 220 q 384 85 269 85 q 557 129 479 85 q 650 270 650 183 q 490 429 650 379 q 194 513 341 470 q 33 739 33 584 q 142 964 33 881 q 388 1041 242 1041 q 644 957 543 1041 q 756 716 756 867 l 625 716 q 561 874 625 816 q 395 933 497 933 q 243 891 309 933 q 164 759 164 841 q 325 609 164 656 q 625 526 475 568 q 788 291 788 454 "},"�":{"x_min":343,"x_max":449,"ha":792,"o":"m 449 462 l 343 462 l 343 986 l 449 986 l 449 462 m 449 -242 l 343 -242 l 343 280 l 449 280 l 449 -242 "},"/":{"x_min":183.25,"x_max":608.328125,"ha":792,"o":"m 608 1041 l 266 -129 l 183 -129 l 520 1041 l 608 1041 "},"?":{"x_min":-0.4375,"x_max":777.453125,"ha":839,"o":"m 777 893 l 458 893 l 458 0 l 319 0 l 319 892 l 0 892 l 0 1013 l 777 1013 l 777 893 "},"y":{"x_min":0,"x_max":684.78125,"ha":771,"o":"m 684 738 l 388 -83 q 311 -216 356 -167 q 173 -279 252 -279 q 97 -266 133 -279 l 97 -149 q 132 -155 109 -151 q 168 -160 155 -160 q 240 -114 213 -160 q 274 -26 248 -98 l 0 738 l 137 737 l 341 139 l 548 737 l 684 738 "},"?":{"x_min":0,"x_max":803,"ha":917,"o":"m 803 0 l 667 0 l 667 886 l 140 886 l 140 0 l 0 0 l 0 1012 l 803 1012 l 803 0 "},"?":{"x_min":-111,"x_max":339,"ha":361,"o":"m 339 800 l 229 800 l 229 925 l 339 925 l 339 800 m -1 800 l -111 800 l -111 925 l -1 925 l -1 800 m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 737 l 167 737 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 103 239 101 q 284 112 257 104 l 284 3 m 302 1040 l 113 819 l 30 819 l 165 1040 l 302 1040 "},"g":{"x_min":0,"x_max":686,"ha":838,"o":"m 686 34 q 586 -213 686 -121 q 331 -306 487 -306 q 131 -252 216 -306 q 31 -84 31 -190 l 155 -84 q 228 -174 166 -138 q 345 -207 284 -207 q 514 -109 454 -207 q 564 89 564 -27 q 461 6 521 36 q 335 -23 401 -23 q 88 100 184 -23 q 0 370 0 215 q 87 634 0 522 q 330 758 183 758 q 457 728 398 758 q 564 644 515 699 l 564 737 l 686 737 l 686 34 m 582 367 q 529 560 582 481 q 358 652 468 652 q 189 561 250 652 q 135 369 135 482 q 189 176 135 255 q 361 85 251 85 q 529 176 468 85 q 582 367 582 255 "},"�":{"x_min":0,"x_max":442,"ha":539,"o":"m 442 383 l 0 383 q 91 566 0 492 q 260 668 176 617 q 354 798 354 727 q 315 875 354 845 q 227 905 277 905 q 136 869 173 905 q 99 761 99 833 l 14 761 q 82 922 14 864 q 232 974 141 974 q 379 926 316 974 q 442 797 442 878 q 351 635 442 704 q 183 539 321 611 q 92 455 92 491 l 442 455 l 442 383 "},"�":{"x_min":0,"x_max":705.5625,"ha":803,"o":"m 705 334 l 0 334 l 0 410 l 705 410 l 705 334 "},"?":{"x_min":0,"x_max":819.5625,"ha":893,"o":"m 819 0 l 650 0 l 294 509 l 139 356 l 139 0 l 0 0 l 0 1013 l 139 1013 l 139 526 l 626 1013 l 809 1013 l 395 600 l 819 0 "},"�":{"x_min":-46.265625,"x_max":392,"ha":513,"o":"m 392 651 l 259 651 l 79 -279 l -46 -278 l 134 651 l 14 651 l 14 751 l 135 751 q 151 948 135 900 q 304 1041 185 1041 q 334 1040 319 1041 q 392 1034 348 1039 l 392 922 q 337 931 360 931 q 271 883 287 931 q 260 793 260 853 l 260 751 l 392 751 l 392 651 "},"e":{"x_min":0,"x_max":714,"ha":813,"o":"m 714 326 l 140 326 q 200 157 140 227 q 359 87 260 87 q 488 130 431 87 q 561 245 545 174 l 697 245 q 577 48 670 123 q 358 -26 484 -26 q 97 85 195 -26 q 0 363 0 197 q 94 642 0 529 q 358 765 195 765 q 626 627 529 765 q 714 326 714 503 m 576 429 q 507 583 564 522 q 355 650 445 650 q 206 583 266 650 q 140 429 152 522 l 576 429 "},"?":{"x_min":0,"x_max":712,"ha":815,"o":"m 356 -25 q 94 91 194 -25 q 0 368 0 202 q 92 642 0 533 q 356 761 192 761 q 617 644 517 761 q 712 368 712 533 q 619 91 712 201 q 356 -25 520 -25 m 356 85 q 527 175 465 85 q 583 369 583 255 q 528 562 583 484 q 356 651 466 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 356 85 250 85 m 576 1040 l 387 819 l 303 819 l 438 1040 l 576 1040 "},"J":{"x_min":0,"x_max":588,"ha":699,"o":"m 588 279 q 287 -26 588 -26 q 58 73 126 -26 q 0 327 0 158 l 133 327 q 160 172 133 227 q 288 96 198 96 q 426 171 391 96 q 449 336 449 219 l 449 1013 l 588 1013 l 588 279 "},"�":{"x_min":-1,"x_max":503,"ha":601,"o":"m 503 302 l 280 136 l 281 256 l 429 373 l 281 486 l 280 608 l 503 440 l 503 302 m 221 302 l 0 136 l 0 255 l 145 372 l 0 486 l -1 608 l 221 440 l 221 302 "},"�":{"x_min":-3,"x_max":1008,"ha":1106,"o":"m 502 -7 q 123 151 263 -7 q -3 501 -3 294 q 123 851 -3 706 q 502 1011 263 1011 q 881 851 739 1011 q 1008 501 1008 708 q 883 151 1008 292 q 502 -7 744 -7 m 502 60 q 830 197 709 60 q 940 501 940 322 q 831 805 940 681 q 502 944 709 944 q 174 805 296 944 q 65 501 65 680 q 173 197 65 320 q 502 60 294 60 m 741 394 q 661 246 731 302 q 496 190 591 190 q 294 285 369 190 q 228 497 228 370 q 295 714 228 625 q 499 813 370 813 q 656 762 588 813 q 733 625 724 711 l 634 625 q 589 704 629 673 q 498 735 550 735 q 377 666 421 735 q 334 504 334 597 q 374 340 334 408 q 490 272 415 272 q 589 304 549 272 q 638 394 628 337 l 741 394 "},"?":{"x_min":0,"x_max":922,"ha":1030,"o":"m 687 1040 l 498 819 l 415 819 l 549 1040 l 687 1040 m 922 339 q 856 97 922 203 q 650 -26 780 -26 q 538 9 587 -26 q 461 103 489 44 q 387 12 436 46 q 277 -22 339 -22 q 69 97 147 -22 q 0 338 0 202 q 45 551 0 444 q 161 737 84 643 l 302 737 q 175 552 219 647 q 124 336 124 446 q 155 179 124 248 q 275 88 197 88 q 375 163 341 88 q 400 294 400 219 l 400 572 l 524 572 l 524 294 q 561 135 524 192 q 643 88 591 88 q 762 182 719 88 q 797 341 797 257 q 745 555 797 450 q 619 737 705 637 l 760 737 q 874 551 835 640 q 922 339 922 444 "},"^":{"x_min":193.0625,"x_max":598.609375,"ha":792,"o":"m 598 772 l 515 772 l 395 931 l 277 772 l 193 772 l 326 1013 l 462 1013 l 598 772 "},"�":{"x_min":0,"x_max":507.203125,"ha":604,"o":"m 506 136 l 284 302 l 284 440 l 506 608 l 507 485 l 360 371 l 506 255 l 506 136 m 222 136 l 0 302 l 0 440 l 222 608 l 221 486 l 73 373 l 222 256 l 222 136 "},"D":{"x_min":0,"x_max":828,"ha":935,"o":"m 389 1013 q 714 867 593 1013 q 828 521 828 729 q 712 161 828 309 q 382 0 587 0 l 0 0 l 0 1013 l 389 1013 m 376 124 q 607 247 523 124 q 681 510 681 355 q 607 771 681 662 q 376 896 522 896 l 139 896 l 139 124 l 376 124 "},"?":{"x_min":0,"x_max":142,"ha":239,"o":"m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 "},"�":{"x_min":0,"x_max":47,"ha":125,"o":"m 47 3 q 37 -7 47 -7 q 28 0 30 -7 q 39 -4 32 -4 q 45 3 45 -1 l 37 0 q 28 9 28 0 q 39 19 28 19 l 47 16 l 47 19 l 47 3 m 37 1 q 44 8 44 1 q 37 16 44 16 q 30 8 30 16 q 37 1 30 1 m 26 1 l 23 22 l 14 0 l 3 22 l 3 3 l 0 25 l 13 1 l 22 25 l 26 1 "},"w":{"x_min":0,"x_max":1009.71875,"ha":1100,"o":"m 1009 738 l 783 0 l 658 0 l 501 567 l 345 0 l 222 0 l 0 738 l 130 738 l 284 174 l 432 737 l 576 738 l 721 173 l 881 737 l 1009 738 "},"$":{"x_min":0,"x_max":700,"ha":793,"o":"m 664 717 l 542 717 q 490 825 531 785 q 381 872 450 865 l 381 551 q 620 446 540 522 q 700 241 700 370 q 618 45 700 116 q 381 -25 536 -25 l 381 -152 l 307 -152 l 307 -25 q 81 62 162 -25 q 0 297 0 149 l 124 297 q 169 146 124 204 q 307 81 215 89 l 307 441 q 80 536 148 469 q 13 725 13 603 q 96 910 13 839 q 307 982 180 982 l 307 1077 l 381 1077 l 381 982 q 574 917 494 982 q 664 717 664 845 m 307 565 l 307 872 q 187 831 233 872 q 142 724 142 791 q 180 618 142 656 q 307 565 218 580 m 381 76 q 562 237 562 96 q 517 361 562 313 q 381 423 472 409 l 381 76 "},"\\":{"x_min":-0.015625,"x_max":425.0625,"ha":522,"o":"m 425 -129 l 337 -129 l 0 1041 l 83 1041 l 425 -129 "},"�":{"x_min":0,"x_max":697.21875,"ha":747,"o":"m 697 -4 q 629 -14 658 -14 q 498 97 513 -14 q 422 9 470 41 q 313 -23 374 -23 q 207 4 258 -23 q 119 81 156 32 l 119 -278 l 0 -278 l 0 738 l 124 738 l 124 343 q 165 173 124 246 q 308 83 216 83 q 452 178 402 83 q 493 359 493 255 l 493 738 l 617 738 l 617 214 q 623 136 617 160 q 673 92 637 92 q 697 96 684 92 l 697 -4 "},"?":{"x_min":42,"x_max":181,"ha":297,"o":"m 181 0 l 42 0 l 42 1013 l 181 1013 l 181 0 "},"?":{"x_min":0,"x_max":1144.5,"ha":1214,"o":"m 1144 1012 l 807 416 l 807 0 l 667 0 l 667 416 l 325 1012 l 465 1012 l 736 533 l 1004 1012 l 1144 1012 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 "},"�":{"x_min":0,"x_max":139,"ha":236,"o":"m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 "},"?":{"x_min":0,"x_max":801,"ha":915,"o":"m 801 0 l 651 0 l 131 822 l 131 0 l 0 0 l 0 1013 l 151 1013 l 670 191 l 670 1013 l 801 1013 l 801 0 "},"-":{"x_min":8.71875,"x_max":350.390625,"ha":478,"o":"m 350 317 l 8 317 l 8 428 l 350 428 l 350 317 "},"Q":{"x_min":0,"x_max":968,"ha":1072,"o":"m 954 5 l 887 -79 l 744 35 q 622 -11 687 2 q 483 -26 556 -26 q 127 130 262 -26 q 0 504 0 279 q 127 880 0 728 q 484 1041 262 1041 q 841 884 708 1041 q 968 507 968 735 q 933 293 968 398 q 832 104 899 188 l 954 5 m 723 191 q 802 330 777 248 q 828 499 828 412 q 744 790 828 673 q 483 922 650 922 q 228 791 322 922 q 142 505 142 673 q 227 221 142 337 q 487 91 323 91 q 632 123 566 91 l 520 215 l 587 301 l 723 191 "},"?":{"x_min":1,"x_max":676.28125,"ha":740,"o":"m 676 460 l 551 460 q 498 595 542 546 q 365 651 448 651 q 199 578 263 651 q 136 401 136 505 q 266 178 136 241 q 508 106 387 142 q 640 -50 640 62 q 625 -158 640 -105 q 583 -278 611 -211 l 465 -278 q 498 -182 490 -211 q 515 -80 515 -126 q 381 12 515 -15 q 134 91 197 51 q 1 388 1 179 q 100 651 1 542 q 354 761 199 761 q 587 680 498 761 q 676 460 676 599 "},"M":{"x_min":0,"x_max":954,"ha":1067,"o":"m 954 0 l 819 0 l 819 869 l 537 0 l 405 0 l 128 866 l 128 0 l 0 0 l 0 1013 l 200 1013 l 472 160 l 757 1013 l 954 1013 l 954 0 "},"?":{"x_min":0,"x_max":1006,"ha":1094,"o":"m 1006 678 q 914 319 1006 429 q 571 200 814 200 l 571 0 l 433 0 l 433 200 q 92 319 194 200 q 0 678 0 429 l 0 1013 l 139 1013 l 139 679 q 191 417 139 492 q 433 326 255 326 l 433 1013 l 571 1013 l 571 326 l 580 326 q 813 423 747 326 q 868 679 868 502 l 868 1013 l 1006 1013 l 1006 678 "},"C":{"x_min":0,"x_max":886,"ha":944,"o":"m 886 379 q 760 87 886 201 q 455 -26 634 -26 q 112 136 236 -26 q 0 509 0 283 q 118 882 0 737 q 469 1041 245 1041 q 748 955 630 1041 q 879 708 879 859 l 745 708 q 649 862 724 805 q 473 920 573 920 q 219 791 312 920 q 136 509 136 675 q 217 229 136 344 q 470 99 311 99 q 672 179 591 99 q 753 379 753 259 l 886 379 "},"!":{"x_min":0,"x_max":138,"ha":236,"o":"m 138 684 q 116 409 138 629 q 105 244 105 299 l 33 244 q 16 465 33 313 q 0 684 0 616 l 0 1013 l 138 1013 l 138 684 m 138 0 l 0 0 l 0 151 l 138 151 l 138 0 "},"{":{"x_min":0,"x_max":480.5625,"ha":578,"o":"m 480 -286 q 237 -213 303 -286 q 187 -45 187 -159 q 194 48 187 -15 q 201 141 201 112 q 164 264 201 225 q 0 314 118 314 l 0 417 q 164 471 119 417 q 201 605 201 514 q 199 665 201 644 q 193 772 193 769 q 241 941 193 887 q 480 1015 308 1015 l 480 915 q 336 866 375 915 q 306 742 306 828 q 310 662 306 717 q 314 577 314 606 q 288 452 314 500 q 176 365 256 391 q 289 275 257 337 q 314 143 314 226 q 313 84 314 107 q 310 -11 310 -5 q 339 -131 310 -94 q 480 -182 377 -182 l 480 -286 "},"X":{"x_min":-0.015625,"x_max":854.15625,"ha":940,"o":"m 854 0 l 683 0 l 423 409 l 166 0 l 0 0 l 347 519 l 18 1013 l 186 1013 l 428 637 l 675 1013 l 836 1013 l 504 520 l 854 0 "},"#":{"x_min":0,"x_max":963.890625,"ha":1061,"o":"m 963 690 l 927 590 l 719 590 l 655 410 l 876 410 l 840 310 l 618 310 l 508 -3 l 393 -2 l 506 309 l 329 310 l 215 -2 l 102 -3 l 212 310 l 0 310 l 36 410 l 248 409 l 312 590 l 86 590 l 120 690 l 347 690 l 459 1006 l 573 1006 l 462 690 l 640 690 l 751 1006 l 865 1006 l 754 690 l 963 690 m 606 590 l 425 590 l 362 410 l 543 410 l 606 590 "},"?":{"x_min":42,"x_max":284,"ha":361,"o":"m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 738 l 167 738 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 103 239 101 q 284 112 257 104 l 284 3 "},"?":{"x_min":0,"x_max":906.953125,"ha":982,"o":"m 283 1040 l 88 799 l 5 799 l 145 1040 l 283 1040 m 906 0 l 756 0 l 650 303 l 251 303 l 143 0 l 0 0 l 376 1012 l 529 1012 l 906 0 m 609 421 l 452 866 l 293 421 l 609 421 "},")":{"x_min":0,"x_max":318,"ha":415,"o":"m 318 365 q 257 25 318 191 q 87 -290 197 -141 l 0 -290 q 140 21 93 -128 q 193 360 193 189 q 141 704 193 537 q 0 1024 97 850 l 87 1024 q 257 706 197 871 q 318 365 318 542 "},"?":{"x_min":0,"x_max":634.71875,"ha":714,"o":"m 634 234 q 527 38 634 110 q 300 -25 433 -25 q 98 29 183 -25 q 0 204 0 93 q 37 314 0 265 q 128 390 67 353 q 56 460 82 419 q 26 555 26 505 q 114 712 26 654 q 295 763 191 763 q 499 700 416 763 q 589 515 589 631 l 478 515 q 419 618 464 580 q 307 657 374 657 q 207 630 253 657 q 151 547 151 598 q 238 445 151 469 q 389 434 280 434 l 389 331 l 349 331 q 206 315 255 331 q 125 210 125 287 q 183 107 125 145 q 302 76 233 76 q 436 117 379 76 q 509 234 493 159 l 634 234 "},"?":{"x_min":0,"x_max":952.78125,"ha":1028,"o":"m 952 0 l 0 0 l 400 1013 l 551 1013 l 952 0 m 762 124 l 476 867 l 187 124 l 762 124 "},"}":{"x_min":0,"x_max":481,"ha":578,"o":"m 481 314 q 318 262 364 314 q 282 136 282 222 q 284 65 282 97 q 293 -58 293 -48 q 241 -217 293 -166 q 0 -286 174 -286 l 0 -182 q 143 -130 105 -182 q 171 -2 171 -93 q 168 81 171 22 q 165 144 165 140 q 188 275 165 229 q 306 365 220 339 q 191 455 224 391 q 165 588 165 505 q 168 681 165 624 q 171 742 171 737 q 141 865 171 827 q 0 915 102 915 l 0 1015 q 243 942 176 1015 q 293 773 293 888 q 287 675 293 741 q 282 590 282 608 q 318 466 282 505 q 481 417 364 417 l 481 314 "},"�":{"x_min":-3,"x_max":1672,"ha":1821,"o":"m 846 0 q 664 76 732 0 q 603 244 603 145 q 662 412 603 344 q 846 489 729 489 q 1027 412 959 489 q 1089 244 1089 343 q 1029 76 1089 144 q 846 0 962 0 m 845 103 q 945 143 910 103 q 981 243 981 184 q 947 340 981 301 q 845 385 910 385 q 745 342 782 385 q 709 243 709 300 q 742 147 709 186 q 845 103 781 103 m 888 986 l 284 -25 l 199 -25 l 803 986 l 888 986 m 241 468 q 58 545 126 468 q -3 715 -3 615 q 56 881 -3 813 q 238 958 124 958 q 421 881 353 958 q 483 712 483 813 q 423 544 483 612 q 241 468 356 468 m 241 855 q 137 811 175 855 q 100 710 100 768 q 136 612 100 653 q 240 572 172 572 q 344 614 306 572 q 382 713 382 656 q 347 810 382 771 q 241 855 308 855 m 1428 0 q 1246 76 1314 0 q 1185 244 1185 145 q 1244 412 1185 344 q 1428 489 1311 489 q 1610 412 1542 489 q 1672 244 1672 343 q 1612 76 1672 144 q 1428 0 1545 0 m 1427 103 q 1528 143 1492 103 q 1564 243 1564 184 q 1530 340 1564 301 q 1427 385 1492 385 q 1327 342 1364 385 q 1291 243 1291 300 q 1324 147 1291 186 q 1427 103 1363 103 "},"a":{"x_min":0,"x_max":698.609375,"ha":794,"o":"m 698 0 q 661 -12 679 -7 q 615 -17 643 -17 q 536 12 564 -17 q 500 96 508 41 q 384 6 456 37 q 236 -25 312 -25 q 65 31 130 -25 q 0 194 0 88 q 118 390 0 334 q 328 435 180 420 q 488 483 476 451 q 495 523 495 504 q 442 619 495 584 q 325 654 389 654 q 209 617 257 654 q 152 513 161 580 l 33 513 q 123 705 33 633 q 332 772 207 772 q 528 712 448 772 q 617 531 617 645 l 617 163 q 624 108 617 126 q 664 90 632 90 l 698 94 l 698 0 m 491 262 l 491 372 q 272 329 350 347 q 128 201 128 294 q 166 113 128 144 q 264 83 205 83 q 414 130 346 83 q 491 262 491 183 "},"�":{"x_min":0,"x_max":941.671875,"ha":1039,"o":"m 941 334 l 0 334 l 0 410 l 941 410 l 941 334 "},"=":{"x_min":8.71875,"x_max":780.953125,"ha":792,"o":"m 780 510 l 8 510 l 8 606 l 780 606 l 780 510 m 780 235 l 8 235 l 8 332 l 780 332 l 780 235 "},"N":{"x_min":0,"x_max":801,"ha":914,"o":"m 801 0 l 651 0 l 131 823 l 131 0 l 0 0 l 0 1013 l 151 1013 l 670 193 l 670 1013 l 801 1013 l 801 0 "},"?":{"x_min":0,"x_max":712,"ha":797,"o":"m 712 369 q 620 94 712 207 q 362 -26 521 -26 q 230 2 292 -26 q 119 83 167 30 l 119 -278 l 0 -278 l 0 362 q 91 643 0 531 q 355 764 190 764 q 617 647 517 764 q 712 369 712 536 m 583 366 q 530 559 583 480 q 359 651 469 651 q 190 562 252 651 q 135 370 135 483 q 189 176 135 257 q 359 85 250 85 q 528 175 466 85 q 583 366 583 254 "},"2":{"x_min":59,"x_max":731,"ha":792,"o":"m 731 0 l 59 0 q 197 314 59 188 q 457 487 199 315 q 598 691 598 580 q 543 819 598 772 q 411 867 488 867 q 272 811 328 867 q 209 630 209 747 l 81 630 q 182 901 81 805 q 408 986 271 986 q 629 909 536 986 q 731 694 731 826 q 613 449 731 541 q 378 316 495 383 q 201 122 235 234 l 731 122 l 731 0 "},"�":{"x_min":0,"x_max":941.671875,"ha":938,"o":"m 941 1033 l 0 1033 l 0 1109 l 941 1109 l 941 1033 "},"Z":{"x_min":0,"x_max":779,"ha":849,"o":"m 779 0 l 0 0 l 0 113 l 621 896 l 40 896 l 40 1013 l 779 1013 l 778 887 l 171 124 l 779 124 l 779 0 "},"u":{"x_min":0,"x_max":617,"ha":729,"o":"m 617 0 l 499 0 l 499 110 q 391 10 460 45 q 246 -25 322 -25 q 61 58 127 -25 q 0 258 0 136 l 0 738 l 125 738 l 125 284 q 156 148 125 202 q 273 82 197 82 q 433 165 369 82 q 493 340 493 243 l 493 738 l 617 738 l 617 0 "},"k":{"x_min":0,"x_max":612.484375,"ha":697,"o":"m 612 738 l 338 465 l 608 0 l 469 0 l 251 382 l 121 251 l 121 0 l 0 0 l 0 1013 l 121 1013 l 121 402 l 456 738 l 612 738 "},"?":{"x_min":0,"x_max":803,"ha":917,"o":"m 803 0 l 667 0 l 667 475 l 140 475 l 140 0 l 0 0 l 0 1013 l 140 1013 l 140 599 l 667 599 l 667 1013 l 803 1013 l 803 0 "},"?":{"x_min":0,"x_max":906.953125,"ha":985,"o":"m 906 0 l 756 0 l 650 303 l 251 303 l 143 0 l 0 0 l 376 1013 l 529 1013 l 906 0 m 609 421 l 452 866 l 293 421 l 609 421 "},"s":{"x_min":0,"x_max":604,"ha":697,"o":"m 604 217 q 501 36 604 104 q 292 -23 411 -23 q 86 43 166 -23 q 0 238 0 114 l 121 237 q 175 122 121 164 q 300 85 223 85 q 415 112 363 85 q 479 207 479 147 q 361 309 479 276 q 140 372 141 370 q 21 544 21 426 q 111 708 21 647 q 298 761 190 761 q 492 705 413 761 q 583 531 583 643 l 462 531 q 412 625 462 594 q 298 657 363 657 q 199 636 242 657 q 143 558 143 608 q 262 454 143 486 q 484 394 479 397 q 604 217 604 341 "},"B":{"x_min":0,"x_max":778,"ha":876,"o":"m 580 546 q 724 469 670 535 q 778 311 778 403 q 673 83 778 171 q 432 0 575 0 l 0 0 l 0 1013 l 411 1013 q 629 957 541 1013 q 732 768 732 892 q 691 633 732 693 q 580 546 650 572 m 393 899 l 139 899 l 139 588 l 379 588 q 521 624 462 588 q 592 744 592 667 q 531 859 592 819 q 393 899 471 899 m 419 124 q 566 169 504 124 q 635 303 635 219 q 559 436 635 389 q 402 477 494 477 l 139 477 l 139 124 l 419 124 "},"�":{"x_min":0,"x_max":614,"ha":708,"o":"m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 m 378 0 l 236 0 l 236 151 l 378 151 l 378 0 m 614 0 l 472 0 l 472 151 l 614 151 l 614 0 "},"?":{"x_min":0,"x_max":607,"ha":704,"o":"m 607 777 q 543 599 607 674 q 422 474 482 537 q 357 272 357 391 l 236 272 q 297 487 236 395 q 411 619 298 490 q 474 762 474 691 q 422 885 474 838 q 301 933 371 933 q 179 880 228 933 q 124 706 124 819 l 0 706 q 94 963 0 872 q 302 1044 177 1044 q 511 973 423 1044 q 607 777 607 895 m 370 0 l 230 0 l 230 151 l 370 151 l 370 0 "},"H":{"x_min":0,"x_max":803,"ha":915,"o":"m 803 0 l 667 0 l 667 475 l 140 475 l 140 0 l 0 0 l 0 1013 l 140 1013 l 140 599 l 667 599 l 667 1013 l 803 1013 l 803 0 "},"?":{"x_min":0,"x_max":675,"ha":761,"o":"m 675 738 l 404 0 l 272 0 l 0 738 l 133 738 l 340 147 l 541 738 l 675 738 "},"c":{"x_min":1,"x_max":701.390625,"ha":775,"o":"m 701 264 q 584 53 681 133 q 353 -26 487 -26 q 91 91 188 -26 q 1 370 1 201 q 92 645 1 537 q 353 761 190 761 q 572 688 479 761 q 690 493 666 615 l 556 493 q 487 606 545 562 q 356 650 428 650 q 186 563 246 650 q 134 372 134 487 q 188 179 134 258 q 359 88 250 88 q 492 136 437 88 q 566 264 548 185 l 701 264 "},"�":{"x_min":0,"x_max":566.671875,"ha":678,"o":"m 21 892 l 52 892 l 98 761 l 145 892 l 176 892 l 178 741 l 157 741 l 157 867 l 108 741 l 88 741 l 40 871 l 40 741 l 21 741 l 21 892 m 308 854 l 308 731 q 252 691 308 691 q 227 691 240 691 q 207 696 213 695 l 207 712 l 253 706 q 288 733 288 706 l 288 763 q 244 741 279 741 q 193 797 193 741 q 261 860 193 860 q 287 860 273 860 q 308 854 302 855 m 288 842 l 263 843 q 213 796 213 843 q 248 756 213 756 q 288 796 288 756 l 288 842 m 566 988 l 502 988 l 502 -1 l 439 -1 l 439 988 l 317 988 l 317 -1 l 252 -1 l 252 602 q 81 653 155 602 q 0 805 0 711 q 101 989 0 918 q 309 1053 194 1053 l 566 1053 l 566 988 "},"?":{"x_min":0,"x_max":660,"ha":745,"o":"m 471 550 q 610 450 561 522 q 660 280 660 378 q 578 64 660 151 q 367 -22 497 -22 q 239 5 299 -22 q 126 82 178 32 l 126 -278 l 0 -278 l 0 593 q 54 903 0 801 q 318 1042 127 1042 q 519 964 436 1042 q 603 771 603 887 q 567 644 603 701 q 471 550 532 586 m 337 79 q 476 138 418 79 q 535 279 535 198 q 427 437 535 386 q 226 477 344 477 l 226 583 q 398 620 329 583 q 486 762 486 668 q 435 884 486 833 q 312 935 384 935 q 169 861 219 935 q 126 698 126 797 l 126 362 q 170 169 126 242 q 337 79 224 79 "},"?":{"x_min":0,"x_max":954,"ha":1068,"o":"m 954 0 l 819 0 l 819 868 l 537 0 l 405 0 l 128 865 l 128 0 l 0 0 l 0 1013 l 199 1013 l 472 158 l 758 1013 l 954 1013 l 954 0 "},"?":{"x_min":0.109375,"x_max":1120,"ha":1217,"o":"m 1120 505 q 994 132 1120 282 q 642 -29 861 -29 q 290 130 422 -29 q 167 505 167 280 q 294 883 167 730 q 650 1046 430 1046 q 999 882 868 1046 q 1120 505 1120 730 m 977 504 q 896 784 977 669 q 644 915 804 915 q 391 785 484 915 q 307 504 307 669 q 391 224 307 339 q 644 95 486 95 q 894 224 803 95 q 977 504 977 339 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 "},"?":{"x_min":0,"x_max":1158,"ha":1275,"o":"m 1158 0 l 1022 0 l 1022 475 l 496 475 l 496 0 l 356 0 l 356 1012 l 496 1012 l 496 599 l 1022 599 l 1022 1012 l 1158 1012 l 1158 0 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 "},"�":{"x_min":0,"x_max":663.890625,"ha":775,"o":"m 663 529 q 566 293 663 391 q 331 196 469 196 q 97 294 194 196 q 0 529 0 393 q 96 763 0 665 q 331 861 193 861 q 566 763 469 861 q 663 529 663 665 "},"�":{"x_min":0.1875,"x_max":819.546875,"ha":886,"o":"m 563 561 l 697 561 l 696 487 l 520 487 l 482 416 l 482 380 l 697 380 l 695 308 l 482 308 l 482 0 l 342 0 l 342 308 l 125 308 l 125 380 l 342 380 l 342 417 l 303 487 l 125 487 l 125 561 l 258 561 l 0 1013 l 140 1013 l 411 533 l 679 1013 l 819 1013 l 563 561 "},"(":{"x_min":0,"x_max":318.0625,"ha":415,"o":"m 318 -290 l 230 -290 q 61 23 122 -142 q 0 365 0 190 q 62 712 0 540 q 230 1024 119 869 l 318 1024 q 175 705 219 853 q 125 360 125 542 q 176 22 125 187 q 318 -290 223 -127 "},"U":{"x_min":0,"x_max":796,"ha":904,"o":"m 796 393 q 681 93 796 212 q 386 -25 566 -25 q 101 95 208 -25 q 0 393 0 211 l 0 1013 l 138 1013 l 138 391 q 204 191 138 270 q 394 107 276 107 q 586 191 512 107 q 656 391 656 270 l 656 1013 l 796 1013 l 796 393 "},"?":{"x_min":0.5,"x_max":744.953125,"ha":822,"o":"m 744 737 l 463 54 l 463 -278 l 338 -278 l 338 54 l 154 495 q 104 597 124 569 q 13 651 67 651 l 0 651 l 0 751 l 39 753 q 168 711 121 753 q 242 594 207 676 l 403 208 l 617 737 l 744 737 "},"?":{"x_min":0,"x_max":765.5625,"ha":809,"o":"m 765 -4 q 698 -14 726 -14 q 564 97 586 -14 q 466 7 525 40 q 337 -26 407 -26 q 88 98 186 -26 q 0 369 0 212 q 88 637 0 525 q 337 760 184 760 q 465 728 407 760 q 563 637 524 696 l 563 739 l 685 739 l 685 222 q 693 141 685 168 q 748 94 708 94 q 765 96 760 94 l 765 -4 m 584 371 q 531 562 584 485 q 360 653 470 653 q 192 566 254 653 q 135 379 135 489 q 186 181 135 261 q 358 84 247 84 q 528 176 465 84 q 584 371 584 260 "},"F":{"x_min":0,"x_max":683.328125,"ha":717,"o":"m 683 888 l 140 888 l 140 583 l 613 583 l 613 458 l 140 458 l 140 0 l 0 0 l 0 1013 l 683 1013 l 683 888 "},"�":{"x_min":0,"x_max":705.5625,"ha":803,"o":"m 705 334 l 0 334 l 0 410 l 705 410 l 705 334 "},":":{"x_min":0,"x_max":142,"ha":239,"o":"m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 "},"?":{"x_min":0,"x_max":854.171875,"ha":935,"o":"m 854 0 l 683 0 l 423 409 l 166 0 l 0 0 l 347 519 l 18 1013 l 186 1013 l 427 637 l 675 1013 l 836 1013 l 504 521 l 854 0 "},"*":{"x_min":116,"x_max":674,"ha":792,"o":"m 674 768 l 475 713 l 610 544 l 517 477 l 394 652 l 272 478 l 178 544 l 314 713 l 116 766 l 153 876 l 341 812 l 342 1013 l 446 1013 l 446 811 l 635 874 l 674 768 "},"�":{"x_min":0,"x_max":777,"ha":835,"o":"m 458 804 l 777 804 l 777 683 l 458 683 l 458 0 l 319 0 l 319 681 l 0 683 l 0 804 l 319 804 l 319 1015 l 458 1013 l 458 804 "},"�":{"x_min":0,"x_max":347,"ha":444,"o":"m 173 802 q 43 856 91 802 q 0 977 0 905 q 45 1101 0 1049 q 173 1153 90 1153 q 303 1098 255 1153 q 347 977 347 1049 q 303 856 347 905 q 173 802 256 802 m 173 884 q 238 910 214 884 q 262 973 262 937 q 239 1038 262 1012 q 173 1064 217 1064 q 108 1037 132 1064 q 85 973 85 1010 q 108 910 85 937 q 173 884 132 884 "},"V":{"x_min":0,"x_max":862.71875,"ha":940,"o":"m 862 1013 l 505 0 l 361 0 l 0 1013 l 143 1013 l 434 165 l 718 1012 l 862 1013 "},"?":{"x_min":0,"x_max":734.71875,"ha":763,"o":"m 723 889 l 9 889 l 9 1013 l 723 1013 l 723 889 m 673 463 l 61 463 l 61 589 l 673 589 l 673 463 m 734 0 l 0 0 l 0 124 l 734 124 l 734 0 "},"�":{"x_min":0,"x_max":0,"ha":853},"?":{"x_min":0.328125,"x_max":819.515625,"ha":889,"o":"m 588 1046 l 460 1046 l 460 1189 l 588 1189 l 588 1046 m 360 1046 l 232 1046 l 232 1189 l 360 1189 l 360 1046 m 819 1012 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1012 l 140 1012 l 411 533 l 679 1012 l 819 1012 "},"0":{"x_min":73,"x_max":715,"ha":792,"o":"m 394 -29 q 153 129 242 -29 q 73 479 73 272 q 152 829 73 687 q 394 989 241 989 q 634 829 545 989 q 715 479 715 684 q 635 129 715 270 q 394 -29 546 -29 m 394 89 q 546 211 489 89 q 598 479 598 322 q 548 748 598 640 q 394 871 491 871 q 241 748 298 871 q 190 479 190 637 q 239 211 190 319 q 394 89 296 89 "},"�":{"x_min":0,"x_max":347,"ha":454,"o":"m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 m 347 851 q 310 737 347 784 q 208 669 273 690 l 208 734 q 267 787 250 741 q 280 873 280 821 l 208 873 l 208 1013 l 347 1013 l 347 851 "},"@":{"x_min":0,"x_max":1260,"ha":1357,"o":"m 1098 -45 q 877 -160 1001 -117 q 633 -203 752 -203 q 155 -29 327 -203 q 0 360 0 127 q 176 802 0 616 q 687 1008 372 1008 q 1123 854 969 1008 q 1260 517 1260 718 q 1155 216 1260 341 q 868 82 1044 82 q 772 106 801 82 q 737 202 737 135 q 647 113 700 144 q 527 82 594 82 q 367 147 420 82 q 314 312 314 212 q 401 565 314 452 q 639 690 498 690 q 810 588 760 690 l 849 668 l 938 668 q 877 441 900 532 q 833 226 833 268 q 853 182 833 198 q 902 167 873 167 q 1088 272 1012 167 q 1159 512 1159 372 q 1051 793 1159 681 q 687 925 925 925 q 248 747 415 925 q 97 361 97 586 q 226 26 97 159 q 627 -122 370 -122 q 856 -87 737 -122 q 1061 8 976 -53 l 1098 -45 m 786 488 q 738 580 777 545 q 643 615 700 615 q 483 517 548 615 q 425 322 425 430 q 457 203 425 250 q 552 156 490 156 q 722 273 665 156 q 786 488 738 309 "},"?":{"x_min":0,"x_max":499,"ha":613,"o":"m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 m 499 0 l 360 0 l 360 1012 l 499 1012 l 499 0 "},"i":{"x_min":14,"x_max":136,"ha":275,"o":"m 136 873 l 14 873 l 14 1013 l 136 1013 l 136 873 m 136 0 l 14 0 l 14 737 l 136 737 l 136 0 "},"?":{"x_min":0,"x_max":778,"ha":877,"o":"m 580 545 q 724 468 671 534 q 778 310 778 402 q 673 83 778 170 q 432 0 575 0 l 0 0 l 0 1013 l 411 1013 q 629 957 541 1013 q 732 768 732 891 q 691 632 732 692 q 580 545 650 571 m 393 899 l 139 899 l 139 587 l 379 587 q 521 623 462 587 q 592 744 592 666 q 531 859 592 819 q 393 899 471 899 m 419 124 q 566 169 504 124 q 635 302 635 219 q 559 435 635 388 q 402 476 494 476 l 139 476 l 139 124 l 419 124 "},"?":{"x_min":0,"x_max":617,"ha":725,"o":"m 617 352 q 540 94 617 199 q 308 -24 455 -24 q 76 94 161 -24 q 0 352 0 199 l 0 739 l 126 739 l 126 355 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 355 492 257 l 492 739 l 617 739 l 617 352 "},"]":{"x_min":0,"x_max":275,"ha":372,"o":"m 275 -281 l 0 -281 l 0 -187 l 151 -187 l 151 920 l 0 920 l 0 1013 l 275 1013 l 275 -281 "},"m":{"x_min":0,"x_max":1019,"ha":1128,"o":"m 1019 0 l 897 0 l 897 454 q 860 591 897 536 q 739 660 816 660 q 613 586 659 660 q 573 436 573 522 l 573 0 l 447 0 l 447 455 q 412 591 447 535 q 294 657 372 657 q 165 586 213 657 q 122 437 122 521 l 122 0 l 0 0 l 0 738 l 117 738 l 117 640 q 202 730 150 697 q 316 763 254 763 q 437 730 381 763 q 525 642 494 697 q 621 731 559 700 q 753 763 682 763 q 943 694 867 763 q 1019 512 1019 625 l 1019 0 "},"?":{"x_min":8.328125,"x_max":780.5625,"ha":815,"o":"m 780 -278 q 715 -294 747 -294 q 616 -257 663 -294 q 548 -175 576 -227 l 379 133 l 143 -277 l 9 -277 l 313 254 l 163 522 q 127 586 131 580 q 36 640 91 640 q 8 637 27 640 l 8 752 l 52 757 q 162 719 113 757 q 236 627 200 690 l 383 372 l 594 737 l 726 737 l 448 250 l 625 -69 q 670 -153 647 -110 q 743 -188 695 -188 q 780 -184 759 -188 l 780 -278 "},"8":{"x_min":55,"x_max":736,"ha":792,"o":"m 571 527 q 694 424 652 491 q 736 280 736 358 q 648 71 736 158 q 395 -26 551 -26 q 142 69 238 -26 q 55 279 55 157 q 96 425 55 359 q 220 527 138 491 q 120 615 153 562 q 88 726 88 668 q 171 904 88 827 q 395 986 261 986 q 618 905 529 986 q 702 727 702 830 q 670 616 702 667 q 571 527 638 565 m 394 565 q 519 610 475 565 q 563 717 563 655 q 521 823 563 781 q 392 872 474 872 q 265 824 312 872 q 224 720 224 783 q 265 613 224 656 q 394 565 312 565 m 395 91 q 545 150 488 91 q 597 280 597 204 q 546 408 597 355 q 395 465 492 465 q 244 408 299 465 q 194 280 194 356 q 244 150 194 203 q 395 91 299 91 "},"?":{"x_min":42,"x_max":326.71875,"ha":361,"o":"m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 737 l 167 737 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 102 239 101 q 284 112 257 104 l 284 3 m 326 1040 l 137 819 l 54 819 l 189 1040 l 326 1040 "},"?":{"x_min":0,"x_max":779.171875,"ha":850,"o":"m 779 0 l 0 0 l 0 113 l 620 896 l 40 896 l 40 1013 l 779 1013 l 779 887 l 170 124 l 779 124 l 779 0 "},"R":{"x_min":0,"x_max":781.953125,"ha":907,"o":"m 781 0 l 623 0 q 587 242 590 52 q 407 433 585 433 l 138 433 l 138 0 l 0 0 l 0 1013 l 396 1013 q 636 946 539 1013 q 749 731 749 868 q 711 597 749 659 q 608 502 674 534 q 718 370 696 474 q 729 207 722 352 q 781 26 736 62 l 781 0 m 373 551 q 533 594 465 551 q 614 731 614 645 q 532 859 614 815 q 373 896 465 896 l 138 896 l 138 551 l 373 551 "},"o":{"x_min":0,"x_max":713,"ha":821,"o":"m 357 -25 q 94 91 194 -25 q 0 368 0 202 q 93 642 0 533 q 357 761 193 761 q 618 644 518 761 q 713 368 713 533 q 619 91 713 201 q 357 -25 521 -25 m 357 85 q 528 175 465 85 q 584 369 584 255 q 529 562 584 484 q 357 651 467 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 357 85 250 85 "},"5":{"x_min":54.171875,"x_max":738,"ha":792,"o":"m 738 314 q 626 60 738 153 q 382 -23 526 -23 q 155 47 248 -23 q 54 256 54 125 l 183 256 q 259 132 204 174 q 382 91 314 91 q 533 149 471 91 q 602 314 602 213 q 538 469 602 411 q 386 528 475 528 q 284 506 332 528 q 197 439 237 484 l 81 439 l 159 958 l 684 958 l 684 840 l 254 840 l 214 579 q 306 627 258 612 q 407 643 354 643 q 636 552 540 643 q 738 314 738 457 "},"7":{"x_min":58.71875,"x_max":730.953125,"ha":792,"o":"m 730 839 q 469 448 560 641 q 335 0 378 255 l 192 0 q 328 441 235 252 q 593 830 421 630 l 58 830 l 58 958 l 730 958 l 730 839 "},"K":{"x_min":0,"x_max":819.46875,"ha":906,"o":"m 819 0 l 649 0 l 294 509 l 139 355 l 139 0 l 0 0 l 0 1013 l 139 1013 l 139 526 l 626 1013 l 809 1013 l 395 600 l 819 0 "},",":{"x_min":0,"x_max":142,"ha":239,"o":"m 142 -12 q 105 -132 142 -82 q 0 -205 68 -182 l 0 -138 q 57 -82 40 -124 q 70 0 70 -51 l 0 0 l 0 151 l 142 151 l 142 -12 "},"d":{"x_min":0,"x_max":683,"ha":796,"o":"m 683 0 l 564 0 l 564 93 q 456 6 516 38 q 327 -25 395 -25 q 87 100 181 -25 q 0 365 0 215 q 90 639 0 525 q 343 763 187 763 q 564 647 486 763 l 564 1013 l 683 1013 l 683 0 m 582 373 q 529 562 582 484 q 361 653 468 653 q 190 561 253 653 q 135 365 135 479 q 189 175 135 254 q 358 85 251 85 q 529 178 468 85 q 582 373 582 258 "},"�":{"x_min":-109,"x_max":247,"ha":232,"o":"m 247 1046 l 119 1046 l 119 1189 l 247 1189 l 247 1046 m 19 1046 l -109 1046 l -109 1189 l 19 1189 l 19 1046 "},"E":{"x_min":0,"x_max":736.109375,"ha":789,"o":"m 736 0 l 0 0 l 0 1013 l 725 1013 l 725 889 l 139 889 l 139 585 l 677 585 l 677 467 l 139 467 l 139 125 l 736 125 l 736 0 "},"Y":{"x_min":0,"x_max":820,"ha":886,"o":"m 820 1013 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1013 l 140 1013 l 411 534 l 679 1012 l 820 1013 "},"\"":{"x_min":0,"x_max":299,"ha":396,"o":"m 299 606 l 203 606 l 203 988 l 299 988 l 299 606 m 96 606 l 0 606 l 0 988 l 96 988 l 96 606 "},"�":{"x_min":17.984375,"x_max":773.609375,"ha":792,"o":"m 773 40 l 18 376 l 17 465 l 773 799 l 773 692 l 159 420 l 773 149 l 773 40 "},"�":{"x_min":0,"x_max":364,"ha":467,"o":"m 141 -12 q 104 -132 141 -82 q 0 -205 67 -182 l 0 -138 q 56 -82 40 -124 q 69 0 69 -51 l 0 0 l 0 151 l 141 151 l 141 -12 m 364 -12 q 327 -132 364 -82 q 222 -205 290 -182 l 222 -138 q 279 -82 262 -124 q 292 0 292 -51 l 222 0 l 222 151 l 364 151 l 364 -12 "},"?":{"x_min":1,"x_max":710,"ha":810,"o":"m 710 360 q 616 87 710 196 q 356 -28 518 -28 q 99 82 197 -28 q 1 356 1 192 q 100 606 1 509 q 355 703 199 703 q 180 829 288 754 q 70 903 124 866 l 70 1012 l 643 1012 l 643 901 l 258 901 q 462 763 422 794 q 636 592 577 677 q 710 360 710 485 m 584 365 q 552 501 584 447 q 451 602 521 555 q 372 611 411 611 q 197 541 258 611 q 136 355 136 472 q 190 171 136 245 q 358 85 252 85 q 528 173 465 85 q 584 365 584 252 "},"?":{"x_min":0,"x_max":634.71875,"ha":714,"o":"m 634 234 q 527 38 634 110 q 300 -25 433 -25 q 98 29 183 -25 q 0 204 0 93 q 37 313 0 265 q 128 390 67 352 q 56 459 82 419 q 26 555 26 505 q 114 712 26 654 q 295 763 191 763 q 499 700 416 763 q 589 515 589 631 l 478 515 q 419 618 464 580 q 307 657 374 657 q 207 630 253 657 q 151 547 151 598 q 238 445 151 469 q 389 434 280 434 l 389 331 l 349 331 q 206 315 255 331 q 125 210 125 287 q 183 107 125 145 q 302 76 233 76 q 436 117 379 76 q 509 234 493 159 l 634 234 m 520 1040 l 331 819 l 248 819 l 383 1040 l 520 1040 "},"?":{"x_min":0,"x_max":922,"ha":1031,"o":"m 922 339 q 856 97 922 203 q 650 -26 780 -26 q 538 9 587 -26 q 461 103 489 44 q 387 12 436 46 q 277 -22 339 -22 q 69 97 147 -22 q 0 339 0 203 q 45 551 0 444 q 161 738 84 643 l 302 738 q 175 553 219 647 q 124 336 124 446 q 155 179 124 249 q 275 88 197 88 q 375 163 341 88 q 400 294 400 219 l 400 572 l 524 572 l 524 294 q 561 135 524 192 q 643 88 591 88 q 762 182 719 88 q 797 342 797 257 q 745 556 797 450 q 619 738 705 638 l 760 738 q 874 551 835 640 q 922 339 922 444 "},"�":{"x_min":0,"x_max":96,"ha":251,"o":"m 96 606 l 0 606 l 0 988 l 96 988 l 96 606 "},"�":{"x_min":11,"x_max":781,"ha":792,"o":"m 781 490 l 446 490 l 446 255 l 349 255 l 349 490 l 11 490 l 11 586 l 349 586 l 349 819 l 446 819 l 446 586 l 781 586 l 781 490 m 781 21 l 11 21 l 11 115 l 781 115 l 781 21 "},"|":{"x_min":343,"x_max":449,"ha":792,"o":"m 449 462 l 343 462 l 343 986 l 449 986 l 449 462 m 449 -242 l 343 -242 l 343 280 l 449 280 l 449 -242 "},"?":{"x_min":0,"x_max":617,"ha":725,"o":"m 482 800 l 372 800 l 372 925 l 482 925 l 482 800 m 239 800 l 129 800 l 129 925 l 239 925 l 239 800 m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 "},"�":{"x_min":0,"x_max":593,"ha":690,"o":"m 593 425 q 554 312 593 369 q 467 233 516 254 q 537 83 537 172 q 459 -74 537 -12 q 288 -133 387 -133 q 115 -69 184 -133 q 47 96 47 -6 l 166 96 q 199 7 166 40 q 288 -26 232 -26 q 371 -5 332 -26 q 420 60 420 21 q 311 201 420 139 q 108 309 210 255 q 0 490 0 383 q 33 602 0 551 q 124 687 66 654 q 75 743 93 712 q 58 812 58 773 q 133 984 58 920 q 300 1043 201 1043 q 458 987 394 1043 q 529 814 529 925 l 411 814 q 370 908 404 877 q 289 939 336 939 q 213 911 246 939 q 180 841 180 883 q 286 720 180 779 q 484 612 480 615 q 593 425 593 534 m 467 409 q 355 544 467 473 q 196 630 228 612 q 146 587 162 609 q 124 525 124 558 q 239 387 124 462 q 398 298 369 315 q 448 345 429 316 q 467 409 467 375 "},"b":{"x_min":0,"x_max":685,"ha":783,"o":"m 685 372 q 597 99 685 213 q 347 -25 501 -25 q 219 5 277 -25 q 121 93 161 36 l 121 0 l 0 0 l 0 1013 l 121 1013 l 121 634 q 214 723 157 692 q 341 754 272 754 q 591 637 493 754 q 685 372 685 526 m 554 356 q 499 550 554 470 q 328 644 437 644 q 162 556 223 644 q 108 369 108 478 q 160 176 108 256 q 330 83 221 83 q 498 169 435 83 q 554 356 554 245 "},"q":{"x_min":0,"x_max":683,"ha":876,"o":"m 683 -278 l 564 -278 l 564 97 q 474 8 533 39 q 345 -23 415 -23 q 91 93 188 -23 q 0 364 0 203 q 87 635 0 522 q 337 760 184 760 q 466 727 408 760 q 564 637 523 695 l 564 737 l 683 737 l 683 -278 m 582 375 q 527 564 582 488 q 358 652 466 652 q 190 565 253 652 q 135 377 135 488 q 189 179 135 261 q 361 84 251 84 q 530 179 469 84 q 582 375 582 260 "},"?":{"x_min":-0.171875,"x_max":969.5625,"ha":1068,"o":"m 969 0 l 555 0 l 555 123 q 744 308 675 194 q 814 558 814 423 q 726 812 814 709 q 484 922 633 922 q 244 820 334 922 q 154 567 154 719 q 223 316 154 433 q 412 123 292 199 l 412 0 l 0 0 l 0 124 l 217 124 q 68 327 122 210 q 15 572 15 444 q 144 911 15 781 q 484 1041 274 1041 q 822 909 691 1041 q 953 569 953 777 q 899 326 953 443 q 750 124 846 210 l 969 124 l 969 0 "},"?":{"x_min":0,"x_max":617,"ha":725,"o":"m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 m 535 1040 l 346 819 l 262 819 l 397 1040 l 535 1040 "},"z":{"x_min":-0.015625,"x_max":613.890625,"ha":697,"o":"m 613 0 l 0 0 l 0 100 l 433 630 l 20 630 l 20 738 l 594 738 l 593 636 l 163 110 l 613 110 l 613 0 "},"�":{"x_min":0,"x_max":894,"ha":1000,"o":"m 389 951 l 229 951 l 229 503 l 160 503 l 160 951 l 0 951 l 0 1011 l 389 1011 l 389 951 m 894 503 l 827 503 l 827 939 l 685 503 l 620 503 l 481 937 l 481 503 l 417 503 l 417 1011 l 517 1011 l 653 580 l 796 1010 l 894 1011 l 894 503 "},"?":{"x_min":0.78125,"x_max":697,"ha":810,"o":"m 697 -278 l 572 -278 l 572 454 q 540 587 572 536 q 425 650 501 650 q 271 579 337 650 q 206 420 206 509 l 206 0 l 81 0 l 81 489 q 73 588 81 562 q 0 644 56 644 l 0 741 q 68 755 38 755 q 158 721 124 755 q 200 630 193 687 q 297 726 234 692 q 434 761 359 761 q 620 692 544 761 q 697 516 697 624 l 697 -278 m 479 1040 l 290 819 l 207 819 l 341 1040 l 479 1040 "},"?":{"x_min":0,"x_max":960,"ha":1056,"o":"m 960 507 q 833 129 960 280 q 476 -32 698 -32 q 123 129 255 -32 q 0 507 0 280 q 123 883 0 732 q 476 1045 255 1045 q 832 883 696 1045 q 960 507 960 732 m 817 500 q 733 789 817 669 q 476 924 639 924 q 223 792 317 924 q 142 507 142 675 q 222 222 142 339 q 476 89 315 89 q 730 218 636 89 q 817 500 817 334 m 716 449 l 243 449 l 243 571 l 716 571 l 716 449 "},"�":{"x_min":-3,"x_max":1008,"ha":1106,"o":"m 503 532 q 614 562 566 532 q 672 658 672 598 q 614 747 672 716 q 503 772 569 772 l 338 772 l 338 532 l 503 532 m 502 -7 q 123 151 263 -7 q -3 501 -3 294 q 123 851 -3 706 q 502 1011 263 1011 q 881 851 739 1011 q 1008 501 1008 708 q 883 151 1008 292 q 502 -7 744 -7 m 502 60 q 830 197 709 60 q 940 501 940 322 q 831 805 940 681 q 502 944 709 944 q 174 805 296 944 q 65 501 65 680 q 173 197 65 320 q 502 60 294 60 m 788 146 l 678 146 q 653 316 655 183 q 527 449 652 449 l 338 449 l 338 146 l 241 146 l 241 854 l 518 854 q 688 808 621 854 q 766 658 766 755 q 739 563 766 607 q 668 497 713 519 q 751 331 747 472 q 788 164 756 190 l 788 146 "},"~":{"x_min":0,"x_max":833,"ha":931,"o":"m 833 958 q 778 753 833 831 q 594 665 716 665 q 402 761 502 665 q 240 857 302 857 q 131 795 166 857 q 104 665 104 745 l 0 665 q 54 867 0 789 q 237 958 116 958 q 429 861 331 958 q 594 765 527 765 q 704 827 670 765 q 729 958 729 874 l 833 958 "},"?":{"x_min":0,"x_max":736.21875,"ha":778,"o":"m 736 0 l 0 0 l 0 1013 l 725 1013 l 725 889 l 139 889 l 139 585 l 677 585 l 677 467 l 139 467 l 139 125 l 736 125 l 736 0 "},"�":{"x_min":0,"x_max":450,"ha":547,"o":"m 450 552 q 379 413 450 464 q 220 366 313 366 q 69 414 130 366 q 0 567 0 470 l 85 567 q 126 470 85 504 q 225 437 168 437 q 320 467 280 437 q 360 552 360 498 q 318 632 360 608 q 213 657 276 657 q 195 657 203 657 q 176 657 181 657 l 176 722 q 279 733 249 722 q 334 815 334 752 q 300 881 334 856 q 220 907 267 907 q 133 875 169 907 q 97 781 97 844 l 15 781 q 78 926 15 875 q 220 972 135 972 q 364 930 303 972 q 426 817 426 888 q 344 697 426 733 q 421 642 392 681 q 450 552 450 603 "},"[":{"x_min":0,"x_max":273.609375,"ha":371,"o":"m 273 -281 l 0 -281 l 0 1013 l 273 1013 l 273 920 l 124 920 l 124 -187 l 273 -187 l 273 -281 "},"L":{"x_min":0,"x_max":645.828125,"ha":696,"o":"m 645 0 l 0 0 l 0 1013 l 140 1013 l 140 126 l 645 126 l 645 0 "},"?":{"x_min":0,"x_max":803.390625,"ha":894,"o":"m 803 628 l 633 628 q 713 368 713 512 q 618 93 713 204 q 357 -25 518 -25 q 94 91 194 -25 q 0 368 0 201 q 94 644 0 533 q 356 761 194 761 q 481 750 398 761 q 608 739 564 739 l 803 739 l 803 628 m 360 85 q 529 180 467 85 q 584 374 584 262 q 527 566 584 490 q 352 651 463 651 q 187 559 247 651 q 135 368 135 478 q 189 175 135 254 q 360 85 251 85 "},"?":{"x_min":0,"x_max":573,"ha":642,"o":"m 573 -40 q 553 -162 573 -97 q 510 -278 543 -193 l 400 -278 q 441 -187 428 -219 q 462 -90 462 -132 q 378 -14 462 -14 q 108 45 197 -14 q 0 290 0 117 q 108 631 0 462 q 353 901 194 767 l 55 901 l 55 1012 l 561 1012 l 561 924 q 261 669 382 831 q 128 301 128 489 q 243 117 128 149 q 458 98 350 108 q 573 -40 573 80 "},"?":{"x_min":0,"x_max":674,"ha":778,"o":"m 674 496 q 601 160 674 304 q 336 -26 508 -26 q 73 153 165 -26 q 0 485 0 296 q 72 840 0 683 q 343 1045 166 1045 q 605 844 516 1045 q 674 496 674 692 m 546 579 q 498 798 546 691 q 336 935 437 935 q 178 798 237 935 q 126 579 137 701 l 546 579 m 546 475 l 126 475 q 170 233 126 348 q 338 80 230 80 q 504 233 447 80 q 546 475 546 346 "},"?":{"x_min":0,"x_max":958,"ha":1054,"o":"m 485 1042 q 834 883 703 1042 q 958 511 958 735 q 834 136 958 287 q 481 -26 701 -26 q 126 130 261 -26 q 0 504 0 279 q 127 880 0 729 q 485 1042 263 1042 m 480 98 q 731 225 638 98 q 815 504 815 340 q 733 783 815 670 q 480 913 640 913 q 226 785 321 913 q 142 504 142 671 q 226 224 142 339 q 480 98 319 98 "},"?":{"x_min":0,"x_max":705.28125,"ha":749,"o":"m 705 886 l 140 886 l 140 0 l 0 0 l 0 1012 l 705 1012 l 705 886 "}," ":{"x_min":0,"x_max":0,"ha":375},"%":{"x_min":-3,"x_max":1089,"ha":1186,"o":"m 845 0 q 663 76 731 0 q 602 244 602 145 q 661 412 602 344 q 845 489 728 489 q 1027 412 959 489 q 1089 244 1089 343 q 1029 76 1089 144 q 845 0 962 0 m 844 103 q 945 143 909 103 q 981 243 981 184 q 947 340 981 301 q 844 385 909 385 q 744 342 781 385 q 708 243 708 300 q 741 147 708 186 q 844 103 780 103 m 888 986 l 284 -25 l 199 -25 l 803 986 l 888 986 m 241 468 q 58 545 126 468 q -3 715 -3 615 q 56 881 -3 813 q 238 958 124 958 q 421 881 353 958 q 483 712 483 813 q 423 544 483 612 q 241 468 356 468 m 241 855 q 137 811 175 855 q 100 710 100 768 q 136 612 100 653 q 240 572 172 572 q 344 614 306 572 q 382 713 382 656 q 347 810 382 771 q 241 855 308 855 "},"P":{"x_min":0,"x_max":726,"ha":806,"o":"m 424 1013 q 640 931 555 1013 q 726 719 726 850 q 637 506 726 587 q 413 426 548 426 l 140 426 l 140 0 l 0 0 l 0 1013 l 424 1013 m 379 889 l 140 889 l 140 548 l 372 548 q 522 589 459 548 q 593 720 593 637 q 528 845 593 801 q 379 889 463 889 "},"?":{"x_min":0,"x_max":1078.21875,"ha":1118,"o":"m 1078 0 l 342 0 l 342 1013 l 1067 1013 l 1067 889 l 481 889 l 481 585 l 1019 585 l 1019 467 l 481 467 l 481 125 l 1078 125 l 1078 0 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 "},"?":{"x_min":0.125,"x_max":1136.546875,"ha":1235,"o":"m 1136 0 l 722 0 l 722 123 q 911 309 842 194 q 981 558 981 423 q 893 813 981 710 q 651 923 800 923 q 411 821 501 923 q 321 568 321 720 q 390 316 321 433 q 579 123 459 200 l 579 0 l 166 0 l 166 124 l 384 124 q 235 327 289 210 q 182 572 182 444 q 311 912 182 782 q 651 1042 441 1042 q 989 910 858 1042 q 1120 569 1120 778 q 1066 326 1120 443 q 917 124 1013 210 l 1136 124 l 1136 0 m 277 1040 l 83 800 l 0 800 l 140 1041 l 277 1040 "},"_":{"x_min":0,"x_max":705.5625,"ha":803,"o":"m 705 -334 l 0 -334 l 0 -234 l 705 -234 l 705 -334 "},"?":{"x_min":-110,"x_max":246,"ha":275,"o":"m 246 1046 l 118 1046 l 118 1189 l 246 1189 l 246 1046 m 18 1046 l -110 1046 l -110 1189 l 18 1189 l 18 1046 m 136 0 l 0 0 l 0 1012 l 136 1012 l 136 0 "},"+":{"x_min":23,"x_max":768,"ha":792,"o":"m 768 372 l 444 372 l 444 0 l 347 0 l 347 372 l 23 372 l 23 468 l 347 468 l 347 840 l 444 840 l 444 468 l 768 468 l 768 372 "},"�":{"x_min":0,"x_max":1050,"ha":1149,"o":"m 1050 0 l 625 0 q 712 178 625 108 q 878 277 722 187 q 967 385 967 328 q 932 456 967 429 q 850 484 897 484 q 759 450 798 484 q 721 352 721 416 l 640 352 q 706 502 640 448 q 851 551 766 551 q 987 509 931 551 q 1050 385 1050 462 q 976 251 1050 301 q 829 179 902 215 q 717 68 740 133 l 1050 68 l 1050 0 m 834 985 l 215 -28 l 130 -28 l 750 984 l 834 985 m 224 422 l 142 422 l 142 811 l 0 811 l 0 867 q 104 889 62 867 q 164 973 157 916 l 224 973 l 224 422 "},"?":{"x_min":0,"x_max":720,"ha":783,"o":"m 424 1013 q 637 933 554 1013 q 720 723 720 853 q 633 508 720 591 q 413 426 546 426 l 140 426 l 140 0 l 0 0 l 0 1013 l 424 1013 m 378 889 l 140 889 l 140 548 l 371 548 q 521 589 458 548 q 592 720 592 637 q 527 845 592 801 q 378 889 463 889 "},"'":{"x_min":0,"x_max":139,"ha":236,"o":"m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 "},"�":{"x_min":0,"x_max":350,"ha":397,"o":"m 350 625 q 307 616 328 616 q 266 631 281 616 q 247 673 251 645 q 190 628 225 644 q 116 613 156 613 q 32 641 64 613 q 0 722 0 669 q 72 826 0 800 q 247 866 159 846 l 247 887 q 220 934 247 916 q 162 953 194 953 q 104 934 129 953 q 76 882 80 915 l 16 882 q 60 976 16 941 q 166 1011 104 1011 q 266 979 224 1011 q 308 891 308 948 l 308 706 q 311 679 308 688 q 331 670 315 670 l 350 672 l 350 625 m 247 757 l 247 811 q 136 790 175 798 q 64 726 64 773 q 83 682 64 697 q 132 667 103 667 q 207 690 174 667 q 247 757 247 718 "},"?":{"x_min":0,"x_max":450,"ha":553,"o":"m 450 800 l 340 800 l 340 925 l 450 925 l 450 800 m 406 1040 l 212 800 l 129 800 l 269 1040 l 406 1040 m 110 800 l 0 800 l 0 925 l 110 925 l 110 800 "},"T":{"x_min":0,"x_max":777,"ha":835,"o":"m 777 894 l 458 894 l 458 0 l 319 0 l 319 894 l 0 894 l 0 1013 l 777 1013 l 777 894 "},"?":{"x_min":0,"x_max":915,"ha":997,"o":"m 527 0 l 389 0 l 389 122 q 110 231 220 122 q 0 509 0 340 q 110 785 0 677 q 389 893 220 893 l 389 1013 l 527 1013 l 527 893 q 804 786 693 893 q 915 509 915 679 q 805 231 915 341 q 527 122 696 122 l 527 0 m 527 226 q 712 310 641 226 q 779 507 779 389 q 712 705 779 627 q 527 787 641 787 l 527 226 m 389 226 l 389 787 q 205 698 275 775 q 136 505 136 620 q 206 308 136 391 q 389 226 276 226 "},"?":{"x_min":0,"x_max":0,"ha":694},"j":{"x_min":-77.78125,"x_max":167,"ha":349,"o":"m 167 871 l 42 871 l 42 1013 l 167 1013 l 167 871 m 167 -80 q 121 -231 167 -184 q -26 -278 76 -278 l -77 -278 l -77 -164 l -41 -164 q 26 -143 11 -164 q 42 -65 42 -122 l 42 737 l 167 737 l 167 -80 "},"?":{"x_min":0,"x_max":756.953125,"ha":819,"o":"m 756 0 l 0 0 l 0 107 l 395 523 l 22 904 l 22 1013 l 745 1013 l 745 889 l 209 889 l 566 523 l 187 125 l 756 125 l 756 0 "},"1":{"x_min":215.671875,"x_max":574,"ha":792,"o":"m 574 0 l 442 0 l 442 697 l 215 697 l 215 796 q 386 833 330 796 q 475 986 447 875 l 574 986 l 574 0 "},"�":{"x_min":18.0625,"x_max":774,"ha":792,"o":"m 774 376 l 18 40 l 18 149 l 631 421 l 18 692 l 18 799 l 774 465 l 774 376 "},"<":{"x_min":17.984375,"x_max":773.609375,"ha":792,"o":"m 773 40 l 18 376 l 17 465 l 773 799 l 773 692 l 159 420 l 773 149 l 773 40 "},"�":{"x_min":0,"x_max":704.484375,"ha":801,"o":"m 704 41 q 623 -10 664 5 q 543 -26 583 -26 q 359 15 501 -26 q 243 36 288 36 q 158 23 197 36 q 73 -21 119 10 l 6 76 q 125 195 90 150 q 175 331 175 262 q 147 443 175 383 l 0 443 l 0 512 l 108 512 q 43 734 43 623 q 120 929 43 854 q 358 1010 204 1010 q 579 936 487 1010 q 678 729 678 857 l 678 684 l 552 684 q 504 838 552 780 q 362 896 457 896 q 216 852 263 896 q 176 747 176 815 q 199 627 176 697 q 248 512 217 574 l 468 512 l 468 443 l 279 443 q 297 356 297 398 q 230 194 297 279 q 153 107 211 170 q 227 133 190 125 q 293 142 264 142 q 410 119 339 142 q 516 96 482 96 q 579 105 550 96 q 648 142 608 115 l 704 41 "},"t":{"x_min":0,"x_max":367,"ha":458,"o":"m 367 0 q 312 -5 339 -2 q 262 -8 284 -8 q 145 28 183 -8 q 108 143 108 64 l 108 638 l 0 638 l 0 738 l 108 738 l 108 944 l 232 944 l 232 738 l 367 738 l 367 638 l 232 638 l 232 185 q 248 121 232 140 q 307 102 264 102 q 345 104 330 102 q 367 107 360 107 l 367 0 "},"�":{"x_min":0,"x_max":706,"ha":803,"o":"m 706 411 l 706 158 l 630 158 l 630 335 l 0 335 l 0 411 l 706 411 "},"?":{"x_min":0,"x_max":750,"ha":803,"o":"m 750 -7 q 679 -15 716 -15 q 538 59 591 -15 q 466 214 512 97 l 336 551 l 126 0 l 0 0 l 270 705 q 223 837 247 770 q 116 899 190 899 q 90 898 100 899 l 90 1004 q 152 1011 125 1011 q 298 938 244 1011 q 373 783 326 901 l 605 192 q 649 115 629 136 q 716 95 669 95 l 736 95 q 750 97 745 97 l 750 -7 "},"W":{"x_min":0,"x_max":1263.890625,"ha":1351,"o":"m 1263 1013 l 995 0 l 859 0 l 627 837 l 405 0 l 265 0 l 0 1013 l 136 1013 l 342 202 l 556 1013 l 701 1013 l 921 207 l 1133 1012 l 1263 1013 "},">":{"x_min":18.0625,"x_max":774,"ha":792,"o":"m 774 376 l 18 40 l 18 149 l 631 421 l 18 692 l 18 799 l 774 465 l 774 376 "},"v":{"x_min":0,"x_max":675.15625,"ha":761,"o":"m 675 738 l 404 0 l 272 0 l 0 738 l 133 737 l 340 147 l 541 737 l 675 738 "},"?":{"x_min":0.28125,"x_max":644.5,"ha":703,"o":"m 644 628 l 382 628 l 382 179 q 388 120 382 137 q 436 91 401 91 q 474 94 447 91 q 504 97 501 97 l 504 0 q 454 -9 482 -5 q 401 -14 426 -14 q 278 67 308 -14 q 260 233 260 118 l 260 628 l 0 628 l 0 739 l 644 739 l 644 628 "},"?":{"x_min":0,"x_max":624.9375,"ha":699,"o":"m 624 -37 q 608 -153 624 -96 q 563 -278 593 -211 l 454 -278 q 491 -183 486 -200 q 511 -83 511 -126 q 484 -23 511 -44 q 370 1 452 1 q 323 0 354 1 q 283 -1 293 -1 q 84 76 169 -1 q 0 266 0 154 q 56 431 0 358 q 197 538 108 498 q 94 613 134 562 q 54 730 54 665 q 77 823 54 780 q 143 901 101 867 l 27 901 l 27 1012 l 576 1012 l 576 901 l 380 901 q 244 863 303 901 q 178 745 178 820 q 312 600 178 636 q 532 582 380 582 l 532 479 q 276 455 361 479 q 118 281 118 410 q 165 173 118 217 q 274 120 208 133 q 494 101 384 110 q 624 -37 624 76 "},"&":{"x_min":-3,"x_max":894.25,"ha":992,"o":"m 894 0 l 725 0 l 624 123 q 471 0 553 40 q 306 -41 390 -41 q 168 -7 231 -41 q 62 92 105 26 q 14 187 31 139 q -3 276 -3 235 q 55 433 -3 358 q 248 581 114 508 q 170 689 196 640 q 137 817 137 751 q 214 985 137 922 q 384 1041 284 1041 q 548 988 483 1041 q 622 824 622 928 q 563 666 622 739 q 431 556 516 608 l 621 326 q 649 407 639 361 q 663 493 653 426 l 781 493 q 703 229 781 352 l 894 0 m 504 818 q 468 908 504 877 q 384 940 433 940 q 293 907 331 940 q 255 818 255 875 q 289 714 255 767 q 363 628 313 678 q 477 729 446 682 q 504 818 504 771 m 556 209 l 314 499 q 179 395 223 449 q 135 283 135 341 q 146 222 135 253 q 183 158 158 192 q 333 80 241 80 q 556 209 448 80 "},"?":{"x_min":0,"x_max":862.5,"ha":942,"o":"m 862 0 l 719 0 l 426 847 l 143 0 l 0 0 l 356 1013 l 501 1013 l 862 0 "},"I":{"x_min":41,"x_max":180,"ha":293,"o":"m 180 0 l 41 0 l 41 1013 l 180 1013 l 180 0 "},"G":{"x_min":0,"x_max":921,"ha":1011,"o":"m 921 0 l 832 0 l 801 136 q 655 15 741 58 q 470 -28 568 -28 q 126 133 259 -28 q 0 499 0 284 q 125 881 0 731 q 486 1043 259 1043 q 763 957 647 1043 q 905 709 890 864 l 772 709 q 668 866 747 807 q 486 926 589 926 q 228 795 322 926 q 142 507 142 677 q 228 224 142 342 q 483 94 323 94 q 712 195 625 94 q 796 435 796 291 l 477 435 l 477 549 l 921 549 l 921 0 "},"?":{"x_min":0,"x_max":617,"ha":725,"o":"m 524 800 l 414 800 l 414 925 l 524 925 l 524 800 m 183 800 l 73 800 l 73 925 l 183 925 l 183 800 m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 m 489 1040 l 300 819 l 216 819 l 351 1040 l 489 1040 "},"`":{"x_min":0,"x_max":138.890625,"ha":236,"o":"m 138 699 l 0 699 l 0 861 q 36 974 0 929 q 138 1041 72 1020 l 138 977 q 82 931 95 969 q 69 839 69 893 l 138 839 l 138 699 "},"�":{"x_min":0,"x_max":142,"ha":239,"o":"m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 "},"?":{"x_min":0.328125,"x_max":819.515625,"ha":889,"o":"m 819 1013 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1013 l 140 1013 l 411 533 l 679 1013 l 819 1013 "},"r":{"x_min":0,"x_max":355.5625,"ha":432,"o":"m 355 621 l 343 621 q 179 569 236 621 q 122 411 122 518 l 122 0 l 0 0 l 0 737 l 117 737 l 117 604 q 204 719 146 686 q 355 753 262 753 l 355 621 "},"x":{"x_min":0,"x_max":675,"ha":764,"o":"m 675 0 l 525 0 l 331 286 l 144 0 l 0 0 l 256 379 l 12 738 l 157 737 l 336 473 l 516 738 l 661 738 l 412 380 l 675 0 "},"?":{"x_min":0,"x_max":696.609375,"ha":747,"o":"m 696 -4 q 628 -14 657 -14 q 498 97 513 -14 q 422 8 470 41 q 313 -24 374 -24 q 207 3 258 -24 q 120 80 157 31 l 120 -278 l 0 -278 l 0 738 l 124 738 l 124 343 q 165 172 124 246 q 308 82 216 82 q 451 177 402 82 q 492 358 492 254 l 492 738 l 616 738 l 616 214 q 623 136 616 160 q 673 92 636 92 q 696 95 684 92 l 696 -4 "},"h":{"x_min":0,"x_max":615,"ha":724,"o":"m 615 472 l 615 0 l 490 0 l 490 454 q 456 590 490 535 q 338 654 416 654 q 186 588 251 654 q 122 436 122 522 l 122 0 l 0 0 l 0 1013 l 122 1013 l 122 633 q 218 727 149 694 q 362 760 287 760 q 552 676 484 760 q 615 472 615 600 "},".":{"x_min":0,"x_max":142,"ha":239,"o":"m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 "},"?":{"x_min":-2,"x_max":878,"ha":974,"o":"m 496 -279 l 378 -279 l 378 -17 q 101 88 204 -17 q -2 367 -2 194 q 68 626 -2 510 q 283 758 151 758 l 283 646 q 167 537 209 626 q 133 373 133 462 q 192 177 133 254 q 378 93 259 93 l 378 758 q 445 764 426 763 q 476 765 464 765 q 765 659 653 765 q 878 377 878 553 q 771 96 878 209 q 496 -17 665 -17 l 496 -279 m 496 93 l 514 93 q 687 183 623 93 q 746 380 746 265 q 691 569 746 491 q 522 658 629 658 l 496 656 l 496 93 "},";":{"x_min":0,"x_max":142,"ha":239,"o":"m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 m 142 -12 q 105 -132 142 -82 q 0 -206 68 -182 l 0 -138 q 58 -82 43 -123 q 68 0 68 -56 l 0 0 l 0 151 l 142 151 l 142 -12 "},"f":{"x_min":0,"x_max":378,"ha":472,"o":"m 378 638 l 246 638 l 246 0 l 121 0 l 121 638 l 0 638 l 0 738 l 121 738 q 137 935 121 887 q 290 1028 171 1028 q 320 1027 305 1028 q 378 1021 334 1026 l 378 908 q 323 918 346 918 q 257 870 273 918 q 246 780 246 840 l 246 738 l 378 738 l 378 638 "},"�":{"x_min":1,"x_max":348.21875,"ha":454,"o":"m 140 670 l 1 670 l 1 830 q 37 943 1 897 q 140 1011 74 990 l 140 947 q 82 900 97 940 q 68 810 68 861 l 140 810 l 140 670 m 348 670 l 209 670 l 209 830 q 245 943 209 897 q 348 1011 282 990 l 348 947 q 290 900 305 940 q 276 810 276 861 l 348 810 l 348 670 "},"A":{"x_min":0.03125,"x_max":906.953125,"ha":1008,"o":"m 906 0 l 756 0 l 648 303 l 251 303 l 142 0 l 0 0 l 376 1013 l 529 1013 l 906 0 m 610 421 l 452 867 l 293 421 l 610 421 "},"6":{"x_min":53,"x_max":739,"ha":792,"o":"m 739 312 q 633 62 739 162 q 400 -31 534 -31 q 162 78 257 -31 q 53 439 53 206 q 178 859 53 712 q 441 986 284 986 q 643 912 559 986 q 732 713 732 833 l 601 713 q 544 830 594 786 q 426 875 494 875 q 268 793 331 875 q 193 517 193 697 q 301 597 240 570 q 427 624 362 624 q 643 540 552 624 q 739 312 739 451 m 603 298 q 540 461 603 400 q 404 516 484 516 q 268 461 323 516 q 207 300 207 401 q 269 137 207 198 q 405 83 325 83 q 541 137 486 83 q 603 298 603 197 "},"�":{"x_min":1,"x_max":139.890625,"ha":236,"o":"m 139 670 l 1 670 l 1 830 q 37 943 1 897 q 139 1011 74 990 l 139 947 q 82 900 97 940 q 68 810 68 861 l 139 810 l 139 670 "},"?":{"x_min":-70,"x_max":283,"ha":361,"o":"m 283 800 l 173 800 l 173 925 l 283 925 l 283 800 m 40 800 l -70 800 l -70 925 l 40 925 l 40 800 m 283 3 q 232 -10 257 -5 q 181 -15 206 -15 q 84 26 118 -15 q 41 200 41 79 l 41 737 l 166 737 l 167 215 q 171 141 167 157 q 225 101 182 101 q 247 103 238 101 q 283 112 256 104 l 283 3 "},"?":{"x_min":-0.21875,"x_max":773.21875,"ha":857,"o":"m 773 -7 l 707 -11 q 575 40 607 -11 q 552 174 552 77 l 552 226 l 552 626 l 222 626 l 222 0 l 97 0 l 97 626 l 0 626 l 0 737 l 773 737 l 773 626 l 676 626 l 676 171 q 695 103 676 117 q 773 90 714 90 l 773 -7 "},"?":{"x_min":0,"x_max":765.5625,"ha":809,"o":"m 765 -4 q 698 -14 726 -14 q 564 97 586 -14 q 466 7 525 40 q 337 -26 407 -26 q 88 98 186 -26 q 0 369 0 212 q 88 637 0 525 q 337 760 184 760 q 465 727 407 760 q 563 637 524 695 l 563 738 l 685 738 l 685 222 q 693 141 685 168 q 748 94 708 94 q 765 95 760 94 l 765 -4 m 584 371 q 531 562 584 485 q 360 653 470 653 q 192 566 254 653 q 135 379 135 489 q 186 181 135 261 q 358 84 247 84 q 528 176 465 84 q 584 371 584 260 m 604 1040 l 415 819 l 332 819 l 466 1040 l 604 1040 "},"O":{"x_min":0,"x_max":958,"ha":1057,"o":"m 485 1041 q 834 882 702 1041 q 958 512 958 734 q 834 136 958 287 q 481 -26 702 -26 q 126 130 261 -26 q 0 504 0 279 q 127 880 0 728 q 485 1041 263 1041 m 480 98 q 731 225 638 98 q 815 504 815 340 q 733 783 815 669 q 480 912 640 912 q 226 784 321 912 q 142 504 142 670 q 226 224 142 339 q 480 98 319 98 "},"n":{"x_min":0,"x_max":615,"ha":724,"o":"m 615 463 l 615 0 l 490 0 l 490 454 q 453 592 490 537 q 331 656 410 656 q 178 585 240 656 q 117 421 117 514 l 117 0 l 0 0 l 0 738 l 117 738 l 117 630 q 218 728 150 693 q 359 764 286 764 q 552 675 484 764 q 615 463 615 593 "},"3":{"x_min":54,"x_max":737,"ha":792,"o":"m 737 284 q 635 55 737 141 q 399 -25 541 -25 q 156 52 248 -25 q 54 308 54 140 l 185 308 q 245 147 185 202 q 395 96 302 96 q 539 140 484 96 q 602 280 602 190 q 510 429 602 390 q 324 454 451 454 l 324 565 q 487 584 441 565 q 565 719 565 617 q 515 835 565 791 q 395 879 466 879 q 255 824 307 879 q 203 661 203 769 l 78 661 q 166 909 78 822 q 387 992 250 992 q 603 921 513 992 q 701 723 701 844 q 669 607 701 656 q 578 524 637 558 q 696 434 655 499 q 737 284 737 369 "},"9":{"x_min":53,"x_max":739,"ha":792,"o":"m 739 524 q 619 94 739 241 q 362 -32 516 -32 q 150 47 242 -32 q 59 244 59 126 l 191 244 q 246 129 191 176 q 373 82 301 82 q 526 161 466 82 q 597 440 597 255 q 363 334 501 334 q 130 432 216 334 q 53 650 53 521 q 134 880 53 786 q 383 986 226 986 q 659 841 566 986 q 739 524 739 719 m 388 449 q 535 514 480 449 q 585 658 585 573 q 535 805 585 744 q 388 873 480 873 q 242 809 294 873 q 191 658 191 745 q 239 514 191 572 q 388 449 292 449 "},"l":{"x_min":41,"x_max":166,"ha":279,"o":"m 166 0 l 41 0 l 41 1013 l 166 1013 l 166 0 "},"�":{"x_min":40.09375,"x_max":728.796875,"ha":825,"o":"m 728 304 l 649 224 l 512 363 q 383 331 458 331 q 256 363 310 331 l 119 224 l 40 304 l 177 441 q 150 553 150 493 q 184 673 150 621 l 40 818 l 119 898 l 267 749 q 321 766 291 759 q 384 773 351 773 q 447 766 417 773 q 501 749 477 759 l 649 898 l 728 818 l 585 675 q 612 618 604 648 q 621 553 621 587 q 591 441 621 491 l 728 304 m 384 682 q 280 643 318 682 q 243 551 243 604 q 279 461 243 499 q 383 423 316 423 q 487 461 449 423 q 525 553 525 500 q 490 641 525 605 q 384 682 451 682 "},"?":{"x_min":0,"x_max":632.328125,"ha":679,"o":"m 632 0 l 482 0 l 225 384 l 124 288 l 124 0 l 0 0 l 0 738 l 124 738 l 124 446 l 433 738 l 596 738 l 312 466 l 632 0 "},"4":{"x_min":48,"x_max":742.453125,"ha":792,"o":"m 742 243 l 602 243 l 602 0 l 476 0 l 476 243 l 48 243 l 48 368 l 476 958 l 602 958 l 602 354 l 742 354 l 742 243 m 476 354 l 476 792 l 162 354 l 476 354 "},"p":{"x_min":0,"x_max":685,"ha":786,"o":"m 685 364 q 598 96 685 205 q 350 -23 504 -23 q 121 89 205 -23 l 121 -278 l 0 -278 l 0 738 l 121 738 l 121 633 q 220 726 159 691 q 351 761 280 761 q 598 636 504 761 q 685 364 685 522 m 557 371 q 501 560 557 481 q 330 651 437 651 q 162 559 223 651 q 108 366 108 479 q 162 177 108 254 q 333 87 224 87 q 502 178 441 87 q 557 371 557 258 "},"�":{"x_min":0,"x_max":777,"ha":835,"o":"m 458 238 l 458 0 l 319 0 l 319 238 l 0 238 l 0 360 l 319 360 l 319 681 l 0 683 l 0 804 l 319 804 l 319 1015 l 458 1013 l 458 804 l 777 804 l 777 683 l 458 683 l 458 360 l 777 360 l 777 238 l 458 238 "},"?":{"x_min":0,"x_max":808,"ha":907,"o":"m 465 -278 l 341 -278 l 341 -15 q 87 102 180 -15 q 0 378 0 210 l 0 739 l 133 739 l 133 379 q 182 195 133 275 q 341 98 242 98 l 341 922 l 465 922 l 465 98 q 623 195 563 98 q 675 382 675 278 l 675 742 l 808 742 l 808 381 q 720 104 808 213 q 466 -13 627 -13 l 465 -278 "},"?":{"x_min":0.78125,"x_max":697,"ha":810,"o":"m 697 -278 l 572 -278 l 572 454 q 540 587 572 536 q 425 650 501 650 q 271 579 337 650 q 206 420 206 509 l 206 0 l 81 0 l 81 489 q 73 588 81 562 q 0 644 56 644 l 0 741 q 68 755 38 755 q 158 720 124 755 q 200 630 193 686 q 297 726 234 692 q 434 761 359 761 q 620 692 544 761 q 697 516 697 624 l 697 -278 "}},"cssFontWeight":"normal","ascender":1189,"underlinePosition":-100,"cssFontStyle":"normal","boundingBox":{"yMin":-334,"xMin":-111,"yMax":1189,"xMax":1672},"resolution":1000,"original_font_information":{"postscript_name":"Helvetiker-Regular","version_string":"Version 1.00 2004 initial release","vendor_url":"http://www.magenta.gr/","full_font_name":"Helvetiker","font_family_name":"Helvetiker","copyright":"Copyright (c) ?agenta ltd, 2004","description":"","trademark":"","designer":"","designer_url":"","unique_font_identifier":"?agenta ltd:Helvetiker:22-10-104","license_url":"http://www.ellak.gr/fonts/MgOpen/license.html","license_description":"Copyright (c) 2004 by MAGENTA Ltd. All Rights Reserved.\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of the fonts accompanying this license (\"Fonts\") and associated documentation files (the \"Font Software\"), to reproduce and distribute the Font Software, including without limitation the rights to use, copy, merge, publish, distribute, and/or sell copies of the Font Software, and to permit persons to whom the Font Software is furnished to do so, subject to the following conditions: \r\n\r\nThe above copyright and this permission notice shall be included in all copies of one or more of the Font Software typefaces.\r\n\r\nThe Font Software may be modified, altered, or added to, and in particular the designs of glyphs or characters in the Fonts may be modified and additional glyphs or characters may be added to the Fonts, only if the fonts are renamed to names not containing the word \"MgOpen\", or if the modifications are accepted for inclusion in the Font Software itself by the each appointed Administrator.\r\n\r\nThis License becomes null and void to the extent applicable to Fonts or Font Software that has been modified and is distributed under the \"MgOpen\" name.\r\n\r\nThe Font Software may be sold as part of a larger software package but no copy of one or more of the Font Software typefaces may be sold by itself. \r\n\r\nTHE FONT SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL MAGENTA OR PERSONS OR BODIES IN CHARGE OF ADMINISTRATION AND MAINTENANCE OF THE FONT SOFTWARE BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.","manufacturer_name":"?agenta ltd","font_sub_family_name":"Regular"},"descender":-334,"familyName":"Helvetiker","lineHeight":1522,"underlineThickness":50});
},{}]},{},[16])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImM6L1VzZXJzL01yVHJ1c3R3b3J0aHkvQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsImM6L1VzZXJzL01yVHJ1c3R3b3J0aHkvQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsInNyYy9qcy9hY3Rvci9hY3Rvci5qcyIsInNyYy9qcy9hY3Rvci9pbnZlbnRvcnkuanMiLCJzcmMvanMvYWN0b3IvdGFza21hc3Rlci5qcyIsInNyYy9qcy9hY3Rvci90YXNrcy5qcyIsInNyYy9qcy9hbmltYXRpb24uanMiLCJzcmMvanMvY29tbW9uL2Vycm9ycy5qcyIsInNyYy9qcy9jb21tb24vZ2FtZW9iamVjdC5qcyIsInNyYy9qcy9jb21tb24vbGlzdDJkLmpzIiwic3JjL2pzL2NvbW1vbi9wb2ludC5qcyIsInNyYy9qcy9jb21tb24vdGFza2xpc3QuanMiLCJzcmMvanMvY29tbW9uL3R3ZWVuLmpzIiwic3JjL2pzL2NvbnRyb2xsZXJzL2lucHV0aGFuZGxlci5qcyIsInNyYy9qcy9jb250cm9sbGVycy9tYWluY29udHJvbGxlci5qcyIsInNyYy9qcy9jb250cm9sbGVycy9tb3VzZWhhbmRsZXIuanMiLCJzcmMvanMvbWFpbi5qcyIsInNyYy9qcy9tYXAvbWFwLmpzIiwic3JjL2pzL21hcC9tYXBub2RlLmpzIiwic3JjL2pzL21hcC9tb2RlbC5qcyIsInNyYy9qcy9tYXAvcGF0aC5qcyIsInNyYy9qcy9tYXAvc3RydWN0dXJlYnVpbGRlci5qcyIsInNyYy9qcy9yZXNvdXJjZS9yZXNvdXJjZS5qcyIsInNyYy9saWIvbXQtZXZlbnQuanMiLCJzcmMvbGliL210LXByb21pc2UuanMiLCJzcmMvbGliL3RocmVlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5sZXQgR2FtZU9iamVjdCA9IHJlcXVpcmUoXCIuLi9jb21tb24vZ2FtZW9iamVjdFwiKTtcclxubGV0IFRIUkVFID0gcmVxdWlyZShcIi4uLy4uL2xpYi90aHJlZVwiKTtcclxubGV0IFBvaW50ID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wb2ludFwiKTtcclxubGV0IFR3ZWVuID0gcmVxdWlyZShcIi4uL2NvbW1vbi90d2VlblwiKTtcclxubGV0IERlZmVycmVkID0gcmVxdWlyZShcIi4uLy4uL2xpYi9tdC1wcm9taXNlXCIpO1xyXG5sZXQgVGFza0xpc3QgPSByZXF1aXJlKFwiLi4vY29tbW9uL3Rhc2tsaXN0XCIpLlRhc2tMaXN0O1xyXG5sZXQgSW52ZW50b3J5ID0gcmVxdWlyZShcIi4vaW52ZW50b3J5XCIpO1xyXG5cclxuY2xhc3MgQWN0b3IgZXh0ZW5kcyBHYW1lT2JqZWN0IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbm9kZSBNYXBOb2RlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG5vZGUpIHtcclxuXHJcbiAgICAgICAgc3VwZXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTsgLy8gbWFwbm9kZVxyXG5cclxuICAgICAgICB0aGlzLm5vZGUubG9jayh0aGlzKTtcclxuXHJcbiAgICAgICAgdGhpcy5tZXNoID0gdGhpcy5nZW5lcmF0ZV9tb2RlbCgpO1xyXG5cclxuICAgICAgICB0aGlzLm1lc2gudXNlckRhdGEgPSB0aGlzO1xyXG5cclxuICAgICAgICB0aGlzLnRhc2tfbGlzdCA9IG5ldyBUYXNrTGlzdCgpO1xyXG5cclxuICAgICAgICAvLyBkZXNjcmliZXMgaXRlbXNcclxuXHJcbiAgICAgICAgdGhpcy5pbnZlbnRvcnkgPSBuZXcgSW52ZW50b3J5KCk7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge1RIUkVFLk1lc2h9XHJcbiAgICAgKi9cclxuICAgIGdlbmVyYXRlX21vZGVsKCkge1xyXG4gICAgICAgIGxldCBnZW9tZXRyeSA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSgxLCAxLCAxKTtcclxuICAgICAgICBsZXQgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCh7Y29sb3I6IDB4ZmYwMDAwfSk7XHJcbiAgICAgICAgbGV0IG1lc2ggPSBuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xyXG4gICAgICAgIG1lc2gucG9zaXRpb24ueCA9IHRoaXMubm9kZS5wb2ludC54O1xyXG4gICAgICAgIG1lc2gucG9zaXRpb24ueSA9IHRoaXMubm9kZS5wb2ludC55O1xyXG4gICAgICAgIG1lc2gucG9zaXRpb24ueiA9IHRoaXMubm9kZS5wb2ludC56O1xyXG4gICAgICAgIHJldHVybiBtZXNoO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQWN0b3I7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuY2xhc3MgSW52ZW50b3J5IHtcclxuXHJcblxyXG4gICAgY29uc3RydWN0b3IoY2FwYWNpdHkpIHtcclxuICAgICAgICB0aGlzLmNhcGFjaXR5ID0gY2FwYWNpdHkgfHwgMTA7XHJcbiAgICAgICAgdGhpcy5fX2l0ZW1zID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSBpdGVtc1xyXG4gICAgICogQHBhcmFtIGl0ZW1zXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBpdCdzIHN0aWxsIHBvc3NpYmxlIHRvIGNhcnJ5IG1vcmVcclxuICAgICAqL1xyXG4gICAgYWRkKGl0ZW1zKSB7XHJcblxyXG4gICAgICAgIGl0ZW1zID0gQXJyYXkuaXNBcnJheShpdGVtcykgPyBpdGVtcyA6IFtpdGVtc107XHJcblxyXG4gICAgICAgIGlmKHRoaXMuX19pdGVtcy5sZW5ndGggPj0gdGhpcy5jYXBhY2l0eSl7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIH0gaWYgKGl0ZW1zLmxlbmd0aCArIHRoaXMuX19pdGVtcy5sZW5ndGggPj0gdGhpcy5jYXBhY2l0eSkge1xyXG5cclxuICAgICAgICAgICAgbGV0IHRvX2FkZCA9IGl0ZW1zLnNsaWNlKDAsIHRoaXMuY2FwYWNpdHkgLSB0aGlzLl9faXRlbXMubGVuZ3RoICsgMSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9faXRlbXMucHVzaCguLi50b19hZGQpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fX2l0ZW1zLnB1c2goLi4uaXRlbXMpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcblxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEludmVudG9yeTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5sZXQgVGFza0xpc3QgPSByZXF1aXJlKFwiLi4vY29tbW9uL3Rhc2tsaXN0XCIpLlRhc2tMaXN0O1xyXG5sZXQgVGFzayA9IHJlcXVpcmUoXCIuLi9jb21tb24vdGFza2xpc3RcIikuVGFzaztcclxubGV0IERlZmVycmVkID0gcmVxdWlyZShcIi4uLy4uL2xpYi9tdC1wcm9taXNlXCIpO1xyXG5sZXQgTWFwRXJyb3IgPSByZXF1aXJlKFwiLi4vY29tbW9uL2Vycm9yc1wiKS5NYXBFcnJvcjtcclxubGV0IFBhdGhFcnJvciA9IHJlcXVpcmUoXCIuLi9jb21tb24vZXJyb3JzXCIpLlBhdGhFcnJvcjtcclxubGV0IFJlc291cmNlID0gcmVxdWlyZShcIi4uL3Jlc291cmNlL3Jlc291cmNlXCIpO1xyXG5sZXQgQWN0b3JUYXNrcyA9IHJlcXVpcmUoXCIuL3Rhc2tzXCIpO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgY2xhc3MgZm9yIGFjdG9yIG1vdmVtZW50XHJcbiAqL1xyXG5jbGFzcyBUYXNrbWFzdGVyIHtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFjdG9yXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IHtNYXBOb2RlfVxyXG4gICAgICogQHBhcmFtIG1hcFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgc2VuZChhY3RvciwgdGFyZ2V0LCBtYXApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXCIjT2JqOlwiLCB0YXJnZXQuX19sb2NrX29iamVjdCk7XHJcblxyXG4gICAgICAgIGlmICghdGFyZ2V0LnBhc3NhYmxlKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBjYW4ndCBkbyBhbnl0aGluZyB0aGVyZSwgYWJvcnRcclxuXHJcbiAgICAgICAgICAgIC8vbm9pbnNwZWN0aW9uIFVubmVjZXNzYXJ5UmV0dXJuU3RhdGVtZW50SlNcclxuICAgICAgICAgICAgcmV0dXJuXHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIXRhcmdldC5vYmplY3QpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGlmIG5vIG9iamVjdCBpcyB0aGVyZSwganVzdCBtb3ZlIHRoZSBhY3RvclxyXG5cclxuICAgICAgICAgICAgVGFza21hc3Rlci5tb3ZlKGFjdG9yLCB0YXJnZXQsIG1hcCk7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0Lm9iamVjdCBpbnN0YW5jZW9mIFJlc291cmNlKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBpZiBhbiBvYmplY3QgaXMgb24gdGhpcyBmaWVsZFxyXG5cclxuICAgICAgICAgICAgVGFza21hc3Rlci5vY2N1cHkoYWN0b3IsIHRhcmdldCwgbWFwKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFjdG9yXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0XHJcbiAgICAgKiBAcGFyYW0gbWFwXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBvY2N1cHkoYWN0b3IsIHRhcmdldCwgbWFwKSB7XHJcblxyXG4gICAgICAgIC8vIHN0ZXAgMTogZmluZCBiZXN0IGZpZWxkIHRvIGdvIHRvXHJcblxyXG4gICAgICAgIGxldCBzdXJyb3VuZGluZyA9IG1hcC5zdHJ1Y3R1cmUuZ2V0X3N1cnJvdW5kaW5nKHRhcmdldC5wb2ludC54LCB0YXJnZXQucG9pbnQueSk7XHJcblxyXG4gICAgICAgIGxldCBwb3NzaWJsZV9ub2RlcyA9IHN1cnJvdW5kaW5nLmZpbHRlcihub2RlID0+IG5vZGUucGFzc2FibGUgJiYgIW5vZGUubG9ja2VkKTtcclxuXHJcbiAgICAgICAgLy8gYWJvcnQgaWYgdGFyZ2V0IGNhbid0IGJlIHJlYWNoZWRcclxuXHJcbiAgICAgICAgaWYocG9zc2libGVfbm9kZXMubGVuZ3RoID09PSAwKXtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIiNUYXNrbWFzdGVyOiBDYW4ndCBmaW5kIGEgd2F5IHRvIHJlYWNoIHRoaXMgcmVzb3VyY2UsIGRvaW5nIG5vdGhpbmdcIik7XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gc29ydCB0byBmaW5kIGNsb3Nlc3RcclxuXHJcbiAgICAgICAgcG9zc2libGVfbm9kZXMuc29ydCgoYSwgYikgPT4gYS5wb2ludC5kaXN0YW5jZV90byhhY3Rvci5ub2RlLnBvaW50KSAtIGIucG9pbnQuZGlzdGFuY2VfdG8oYWN0b3Iubm9kZS5wb2ludCkpO1xyXG5cclxuICAgICAgICBsZXQgbW92ZV90YXJnZXQgPSBwb3NzaWJsZV9ub2Rlc1swXTtcclxuXHJcblxyXG4gICAgICAgIC8vIGNyZWF0ZSB0YXNrcyB0byBtb3ZlIGFjdG9yIHRoZXJlXHJcblxyXG4gICAgICAgIGFjdG9yLnRhc2tfbGlzdC5jbGVhcigpLnRoZW4oKCk9PiB7XHJcblxyXG4gICAgICAgICAgICBsZXQgbm9kZXMgPSBUYXNrbWFzdGVyLl9nZXRfY2xlYW5fcGF0aChhY3RvciwgbW92ZV90YXJnZXQsIG1hcCk7XHJcblxyXG4gICAgICAgICAgICAvLyBjcmVhdGUgYSB0YXNrIGZvciBlYWNoIG5vZGUtdG8tbm9kZSBtb3ZlIGFjdGlvbiByZXF1aXJlZFxyXG5cclxuICAgICAgICAgICAgbGV0IG1vdmVfdGFza3MgPSBub2Rlcy5tYXAobm9kZSA9PiB7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUYXNrKEFjdG9yVGFza3MubW92ZV90YXNrLCBbbm9kZV0sIGFjdG9yKTtcclxuXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgYWN0b3IudGFza19saXN0LmFkZF90YXNrcyhtb3ZlX3Rhc2tzKTtcclxuXHJcblxyXG4gICAgICAgICAgICAvLyBjcmVhdGUgdGFzayBmb3IgcmVzb3VyY2UgZ2F0aGVyaW5nXHJcblxyXG4gICAgICAgICAgICBsZXQgZ2F0aGVyX3Rhc2sgPSAgbmV3IFRhc2soQWN0b3JUYXNrcy5nYXRoZXJfdGFzaywgdGFyZ2V0Lm9iamVjdCwgYWN0b3IpO1xyXG5cclxuICAgICAgICAgICAgYWN0b3IudGFza19saXN0LmFkZF90YXNrcyhnYXRoZXJfdGFzayk7XHJcblxyXG4gICAgICAgICAgICAvLyBzdGFydCBydW5uaW5nIHRoZSB0YXNrbGlzdC4gaWYgaXQgZmFpbHMsIHRyeSBhZ2FpblxyXG4gICAgICAgICAgICAvLyBUT0RPIEZJWE1FIG5lZWQgc29tZSB3YXkgdG8gbGltaXQgdGhlIHJlLXRyeXNcclxuICAgICAgICAgICAgLy8gY3VycmVudGx5LCBpdCdzIG9ubHkgd29ya2luZyBiZWNhdXNlIGEgbmV3IHBhdGggY2FuJ3QgYmUgY2FsY3VsYXRlZCBzbyBpdCdzIGFib3J0ZWQgdGhlIDJuZCB0aW1lXHJcblxyXG4gICAgICAgICAgICBhY3Rvci50YXNrX2xpc3Quc3RhcnQoKS50aGVuKFxyXG4gICAgICAgICAgICAgICAgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICgpID0+IHNldFRpbWVvdXQoVGFza21hc3Rlci5vY2N1cHkuYmluZChudWxsLCBhY3RvciwgdGFyZ2V0LCBtYXApLCAxMDApXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFjdG9yXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0XHJcbiAgICAgKiBAcGFyYW0gbWFwXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBtb3ZlKGFjdG9yLCB0YXJnZXQsIG1hcCkge1xyXG5cclxuICAgICAgICBsZXQgdGFza3MsXHJcbiAgICAgICAgICAgIG5vZGVzO1xyXG5cclxuICAgICAgICBhY3Rvci50YXNrX2xpc3QuY2xlYXIoKS50aGVuKCgpPT4ge1xyXG5cclxuICAgICAgICAgICAgbm9kZXMgPSBUYXNrbWFzdGVyLl9nZXRfY2xlYW5fcGF0aChhY3RvciwgdGFyZ2V0LCBtYXApO1xyXG5cclxuICAgICAgICAgICAgLy8gY3JlYXRlIGEgdGFzayBmb3IgZWFjaCBub2RlLXRvLW5vZGUgbW92ZSBhY3Rpb24gcmVxdWlyZWRcclxuXHJcbiAgICAgICAgICAgIHRhc2tzID0gbm9kZXMubWFwKG5vZGUgPT4ge1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGFzayhBY3RvclRhc2tzLm1vdmVfdGFzaywgW25vZGVdLCBhY3Rvcik7XHJcblxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGFjdG9yLnRhc2tfbGlzdC5hZGRfdGFza3ModGFza3MpO1xyXG5cclxuICAgICAgICAgICAgLy8gc3RhcnQgcnVubmluZyB0aGUgdGFza2xpc3QuIGlmIGl0IGZhaWxzLCB0cnkgYWdhaW5cclxuICAgICAgICAgICAgLy8gVE9ETyBGSVhNRSBuZWVkIHNvbWUgd2F5IHRvIGxpbWl0IHRoZSByZS10cnlzXHJcbiAgICAgICAgICAgIC8vIGN1cnJlbnRseSwgaXQncyBvbmx5IHdvcmtpbmcgYmVjYXVzZSBhIG5ldyBwYXRoIGNhbid0IGJlIGNhbGN1bGF0ZWQgc28gaXQncyBhYm9ydGVkIHRoZSAybmQgdGltZVxyXG5cclxuICAgICAgICAgICAgYWN0b3IudGFza19saXN0LnN0YXJ0KCkudGhlbihcclxuICAgICAgICAgICAgICAgICgpID0+IHtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAoKSA9PiBzZXRUaW1lb3V0KFRhc2ttYXN0ZXIubW92ZS5iaW5kKG51bGwsIGFjdG9yLCB0YXJnZXQsIG1hcCksIDEwMClcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY3RvclxyXG4gICAgICogQHBhcmFtIHRhcmdldFxyXG4gICAgICogQHBhcmFtIG1hcFxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgX2dldF9jbGVhbl9wYXRoKGFjdG9yLCB0YXJnZXQsIG1hcCkge1xyXG5cclxuICAgICAgICBsZXQgbm9kZXM7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcblxyXG4gICAgICAgICAgICAvLyBnZXQgdGhlIHBhdGhcclxuXHJcbiAgICAgICAgICAgIG5vZGVzID0gbWFwLmdldF9wYXRoKGFjdG9yLm5vZGUucG9pbnQsIHRhcmdldC5wb2ludCk7XHJcblxyXG4gICAgICAgICAgICBub2RlcyA9IEFycmF5LmZyb20obm9kZXMpLnNsaWNlKDEpO1xyXG5cclxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBzdGFydGluZyBub2RlXHJcblxyXG4gICAgICAgICAgICBub2Rlcy5zaGlmdCgpO1xyXG5cclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBhYm9ydCBpZiB0aGUgdGFyZ2V0IGZpZWxkIGlzIGFscmVhZHkgbG9ja2VkIG9yIGdlbmVyYWxseSB1bnBhc3NhYmxlXHJcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgaG9uZXN0bHksIHRoaXMgd2lsbCBoYXBwZW4gb2Z0ZW5cclxuXHJcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgUGF0aEVycm9yKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiI1Rhc2ttYXN0ZXI6IENhbid0IGZpbmQgcGF0aFwiLCBlKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHNvbWV0aGluZyB1bmV4cGVjdGVkIGhhcHBlbmVkLCBpbiB0aGF0IGNhc2VcclxuXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG5cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUYXNrbWFzdGVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmxldCBUd2VlbiA9IHJlcXVpcmUoXCIuLi9jb21tb24vdHdlZW5cIik7XHJcbmxldCBNYXBFcnJvciA9IHJlcXVpcmUoXCIuLi9jb21tb24vZXJyb3JzXCIpLk1hcEVycm9yO1xyXG5sZXQgRGVmZXJyZWQgPSByZXF1aXJlKFwiLi4vLi4vbGliL210LXByb21pc2VcIik7XHJcblxyXG4vKipcclxuICogVGhpcyBjbGFzcyBjb250YWlucyBcInRhc2tzXCIgZm9yIHRoZSBhY3Rvci5cclxuICogVGFza3MgYXJlIGZ1bmN0aW9ucyB0aGF0IGFyZSBleGVjdXRlZCB3aXRoIHRoZSBjb250ZXh0IG9mIHRoZSBhY3RvciB0byBwZXJmb3JtIHNwZWNpZmljIGFjdGlvbnMuXHJcbiAqL1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogTW92ZXMgdG8gYSBuZWlnaGJvdXJpbmcgbm9kZVxyXG4gKiBAcGFyYW0gdGFyZ2V0IE1BS0UgU1VSRSBJVFMgQSBORUlHSEJPVVIgT1IgSVQnTEwgTE9PSyBXRUlSRFxyXG4gKiBAcmV0dXJucyBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0YXJnZXQgaXMgcmVhY2hlcyBhbmQgcmVqZWN0cyBpZiBpdCdzIGltcG9zc2libGVcclxuICovXHJcbmZ1bmN0aW9uIG1vdmVfdGFzayh0YXJnZXQpIHtcclxuXHJcbiAgICBsZXQgZGVmID0gbmV3IERlZmVycmVkKCk7XHJcblxyXG4gICAgdHJ5IHtcclxuXHJcbiAgICAgICAgdGFyZ2V0LmxvY2sodGhpcyk7XHJcblxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG5cclxuICAgICAgICAvLyBpZiBsb2NraW5nIGlzIG5vdCBwb3NzaWJsZSBiZWNhdXNlIHNvbWV0aGluZyBhbHJlYWR5IGlzIHRoZXJlLCBhYm9ydFxyXG5cclxuICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgTWFwRXJyb3IpKSB0aHJvdyBlO1xyXG5cclxuICAgICAgICBkZWYucmVqZWN0KCk7XHJcblxyXG4gICAgICAgIHJldHVybiBkZWYucHJvbWlzZTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gZ2V0IHRoZSB0d2VlbmluZyBwb2ludHNcclxuXHJcbiAgICBsZXQgcG9pbnRzID0gbmV3IFR3ZWVuKFxyXG4gICAgICAgIHRoaXMubm9kZS5wb2ludCxcclxuXHJcbiAgICAgICAgdGFyZ2V0LnBvaW50LFxyXG5cclxuICAgICAgICB0aGlzLm5vZGUucG9pbnQuZGlzdGFuY2VfdG8odGFyZ2V0LnBvaW50KSAqIDEwXHJcbiAgICApO1xyXG5cclxuICAgIHBvaW50cyA9IEFycmF5LmZyb20ocG9pbnRzKTtcclxuXHJcbiAgICAvLyBwdXQgdGhlIG1vdmUtZnVuY3Rpb24gaW50byB0aGUgY3VycmVudCBob29rc1xyXG4gICAgdmFyIHVwZGF0ZV9mdW5jID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICBsZXQgY3VycmVudCA9IHBvaW50cy5zaGlmdCgpO1xyXG5cclxuICAgICAgICB0aGlzLm1lc2gucG9zaXRpb24ueCA9IGN1cnJlbnQueDtcclxuXHJcbiAgICAgICAgdGhpcy5tZXNoLnBvc2l0aW9uLnkgPSBjdXJyZW50Lnk7XHJcblxyXG4gICAgICAgIHRoaXMubWVzaC5wb3NpdGlvbi56ID0gY3VycmVudC56O1xyXG5cclxuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xyXG5cclxuICAgICAgICAgICAgLy8gc3RvcCBtb3ZpbmdcclxuXHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjZW5lX3VwZGF0ZWRcIiwgdXBkYXRlX2Z1bmMpO1xyXG5cclxuICAgICAgICAgICAgLy8gdW5sb2NrIHRoZSBvbGQgbm9kZSBhbmQgc2V0IHRoZSBjdXJyZW50IG5vZGUgdG8gdGhlIG5ldyBwb3NpdGlvblxyXG5cclxuICAgICAgICAgICAgdGhpcy5ub2RlLnVubG9jaygpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5ub2RlID0gdGFyZ2V0O1xyXG5cclxuICAgICAgICAgICAgZGVmLnJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcblxyXG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKFwic2NlbmVfdXBkYXRlZFwiLCB1cGRhdGVfZnVuYyk7XHJcblxyXG4gICAgcmV0dXJuIGRlZi5wcm9taXNlO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSByZXNvdXJjZVxyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcbmZ1bmN0aW9uIGdhdGhlcl90YXNrKHJlc291cmNlLCBhYm9ydCl7XHJcblxyXG4gICAgbGV0IGRlZiA9IG5ldyBEZWZlcnJlZCgpO1xyXG5cclxuXHJcbiAgICBsZXQgZmluaXNoX2dhdGhlcmluZyA9IGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgICAgIHRoaXMubWVzaC5yb3RhdGlvbi56ID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwic2NlbmVfdXBkYXRlZFwiLCB1cGRhdGVfZnVuYyk7XHJcblxyXG4gICAgICAgIGRlYnVnZ2VyO1xyXG5cclxuICAgICAgICBkZWYucmVzb2x2ZSgpO1xyXG5cclxuICAgIH0uYmluZCh0aGlzKTtcclxuXHJcblxyXG4gICAgLy8gcHV0IHRoZSBtb3ZlLWZ1bmN0aW9uIGludG8gdGhlIGN1cnJlbnQgaG9va3NcclxuICAgIHZhciB1cGRhdGVfZnVuYyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgLy8gcGxheSBhbmltYXRpb25cclxuICAgICAgICAvLyBGSVhNRSB5b3Uga25vdyB3aHlcclxuXHJcbiAgICAgICAgdGhpcy5tZXNoLnJvdGF0ZVooMC4wNSk7XHJcblxyXG4gICAgICAgIC8vIGdldCByZXNvdXJjZVxyXG5cclxuICAgICAgICBsZXQgcmVzID0gIHJlc291cmNlLndvcmtfb24oKTtcclxuXHJcbiAgICAgICAgaWYoIXJlcykgZmluaXNoX2dhdGhlcmluZygpO1xyXG5cclxuICAgICAgICBsZXQgaGFzX2ludmVudG9yeV9zcGFjZSA9IHRoaXMuaW52ZW50b3J5LmFkZChyZXMpO1xyXG5cclxuICAgICAgICBpZighaGFzX2ludmVudG9yeV9zcGFjZSkgZmluaXNoX2dhdGhlcmluZygpO1xyXG5cclxuXHJcbiAgICB9LmJpbmQodGhpcyk7XHJcblxyXG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKFwic2NlbmVfdXBkYXRlZFwiLCB1cGRhdGVfZnVuYyk7XHJcblxyXG4gICAgcmV0dXJuIGRlZi5wcm9taXNlO1xyXG5cclxufVxyXG5cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIG1vdmVfdGFzazogbW92ZV90YXNrLFxyXG4gICAgZ2F0aGVyX3Rhc2s6IGdhdGhlcl90YXNrXHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgVEhSRUUgPSByZXF1aXJlKFwiLi4vbGliL3RocmVlXCIpO1xudmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKFwiLi9jb21tb24vZ2FtZW9iamVjdFwiKTtcbi8qKlxuICogVGhpcyBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3IgdGhlIHJlbmRlcmVyLCBzY2VuZSBldGMuXG4gKiBJdCBiYXNpY2FsbHkgaGFuZGxlcyBhbGwgdGhlIGFuaW1hdGlvbi1yZWxhdGVkIHN0dWZmXG4gKlxuICogVE9ETzogSGFuZGxlIHdpbmRvdyByZXNpemUgaGVyZVxuICovXG5jbGFzcyBBbmltYXRpb24ge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBuZXcgQW5pbWF0aW9uLU9iamVjdCBhbmQgc2V0cyB1cCB0aGUgc3Vycm91bmRpbmcgKGV2ZXJ5dGhpbmcgYnV0IHRoZSBib2RpZXMgdGhlbXNlbHZlcylcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICBUSFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KHRoaXMpO1xuICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibWFpbl9jYW52YXNcIik7XG5cblxuICAgICAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2xcIik7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKHtcbiAgICAgICAgICAgIGNhbnZhczogdGhpcy5jYW52YXMsXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHQsXG4gICAgICAgICAgICBhbnRpYWxpYXM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcblxuICAgICAgICB0aGlzLnNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XG5cblxuICAgICAgICB0aGlzLmNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg3NSwgd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQsIDAuMSwgMTAwMCk7XG4gICAgICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnggPSA1MDtcbiAgICAgICAgdGhpcy5jYW1lcmEucG9zaXRpb24ueSA9IDI1O1xuICAgICAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi56ID0gNTA7XG4gICAgICAgIHRoaXMuY2FtZXJhLnJvdGF0aW9uLnggPSAwLjM7XG5cblxuICAgICAgICB2YXIgZGlyZWN0aW9uYWxMaWdodCA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KDB4ZmZmZmZmLCAxKTtcbiAgICAgICAgZGlyZWN0aW9uYWxMaWdodC5wb3NpdGlvbi5zZXQoMCwgNiwgMTIpO1xuICAgICAgICB0aGlzLnNjZW5lLmFkZChkaXJlY3Rpb25hbExpZ2h0KTtcblxuICAgICAgICB0aGlzLmFjdG9ycyA9IFtdO1xuXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyB0aGUgbWFwXG4gICAgICogQHBhcmFtIG1hcFxuICAgICAqL1xuICAgIGxvYWRfbWFwKG1hcCkge1xuICAgICAgICB0aGlzLnNjZW5lLmFkZChtYXAubWVzaCk7XG4gICAgICAgIG1hcC5yZXNvdXJjZXMuZm9yRWFjaChyZXMgPT4gdGhpcy5zY2VuZS5hZGQocmVzLm1lc2gpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGVsZW1lbnQgdG8gdGhlIHNjZW5lXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2JqXG4gICAgICovXG4gICAgYWRkX2VsZW1lbnQob2JqKSB7XG4gICAgICAgIGlmICghKG9iaiBpbnN0YW5jZW9mIEdhbWVPYmplY3QpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiI0FuaW1hdGlvbjogQ2FuIG9ubHkgYWRkIGdhbWVvYmplY3RzIHRvIHRoZSBzY2VuZVwiKTtcbiAgICAgICAgdGhpcy5hY3RvcnMucHVzaChvYmopO1xuICAgICAgICB0aGlzLnNjZW5lLmFkZChvYmoubWVzaCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBTdGFydHMgdGhlIGFuaW1hdGlvblxuICAgICAqL1xuICAgIHN0YXJ0KCkge1xuICAgICAgICAvLyByZWN1cnNpdmUgY2FsbFxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5zdGFydC5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy8gdGhpcyB3YXkgd2UgY2FuIGhvb2sgdHdlZW5zIGFuZCBzdHVmZiBsaWtlIHRoYXQgb24gZWFjaCBmcmFtZVxuICAgICAgICB0aGlzLmFjdG9ycy5mb3JFYWNoKHggPT4geC5kaXNwYXRjaEV2ZW50KHt0eXBlOiBcInNjZW5lX3VwZGF0ZWRcIn0pKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiBcInNjZW5lX3VwZGF0ZWRcIn0pO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XG4gICAgfVxuXG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBbmltYXRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmNsYXNzIE1hcEVycm9yIGV4dGVuZHMgRXJyb3J7XHJcblxyXG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XHJcbiAgICAgICAgc3VwZXIoYXJncylcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmNsYXNzIFBhdGhFcnJvciBleHRlbmRzIEVycm9ye1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xyXG4gICAgICAgIHN1cGVyKGFyZ3MpXHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBNYXBFcnJvcjogTWFwRXJyb3IsXHJcbiAgICBQYXRoRXJyb3I6IFBhdGhFcnJvclxyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBUSFJFRSA9IHJlcXVpcmUoXCIuLi8uLi9saWIvdGhyZWVcIik7XHJcblxyXG4vLyBqdXN0IGZvciBmdW47IG5lZWQgYSBnaXQtaG9vayBvciBzb21ldGhpbmcgdGhhdCB0aHJvd3MgZXJyb3JzIGlmIGl0IHNlZXMgXCJnZXRvd25wcm9wZXJ0eXN5bWJvbHNcIlxyXG52YXIgbWVzaFN5bWJvbCA9IFN5bWJvbCgpO1xyXG5cclxuLyoqXHJcbiAqIFBhcmVudCBjbGFzcyBmb3IgYWxsIEdhbWVvYmplY3RzIHdoaWNoIGd1YXJhbnRlZXMgYXZhaWxhYmlsaXR5IG9mIGNvbW1vbiBnYW1lb2JqZWN0LXByb3BlcnRpZXMgbGlrZSBtZXNoZXNcclxuICovXHJcbmNsYXNzIEdhbWVPYmplY3Qge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogd2UgX19ORUVEX18gdG8gY2FsbCB0aGlzIGluIGFsbCBzdWJjbGFzc2VzIVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkodGhpcyk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcndyaXRlIVxyXG4gICAgICovXHJcbiAgICBwcm9ncmVzcygpe1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHJldHVybnMgdGhlIG1lc2ggaWYgYXNrZWQgZm9yIGl0XHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgZ2V0IG1lc2goKXtcclxuICAgICAgICBpZiAodGhpc1ttZXNoU3ltYm9sXSkgcmV0dXJuIHRoaXNbbWVzaFN5bWJvbF07XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgbGV0IGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJveEdlb21ldHJ5KDEsIDEsIDEpO1xyXG4gICAgICAgICAgICBsZXQgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCh7Y29sb3I6IDB4ZmZmZmZmfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIG1ha2Ugc3VyZSB3ZSBjYW4gbm90IG92ZXJ3cml0ZSB0aGUgbWVzaFxyXG4gICAgICogQHBhcmFtIG1lc2hcclxuICAgICAqL1xyXG4gICAgc2V0IG1lc2gobWVzaCl7XHJcbiAgICAgICAgaWYgKHRoaXNbbWVzaFN5bWJvbF0pIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcIkNhbid0IG92ZXJ3cml0ZSBleGlzdGluZyBtZXNoZXMhXCIpO1xyXG4gICAgICAgIHRoaXNbbWVzaFN5bWJvbF0gPSBtZXNoO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHYW1lT2JqZWN0O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsaXN0U3ltYm9sID0gU3ltYm9sKCk7XHJcblxyXG4vKipcclxuICogQSBzaW1wbGUgMmQtbGlzdCBjbGFzc1xyXG4gKlxyXG4gKiBUT0RPOiBtYXliZSBpbnZlcnQgcm93cy9jb2xzIGluIHRoZSBkYXRhIHN0cnVjdHVyZSBiZWNhdXNlIHdlIGhhdmUgdG8gcXVlcnkgcm93cyBtb3JlIG9mdGVuXHJcbiAqIGFuZCBpdCdzIGN1cnJlbnRseSBtb3JlIGV4cGVuc2l2ZVxyXG4gKi9cclxuY2xhc3MgTGlzdDJEIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGluaXRpYWxpemVzIGFuIGVtcHR5IDJkIGxpc3Qgd2l0aCBudWxsLXZhbHVlc1xyXG4gICAgICogQHBhcmFtIHdpZHRoOiBmaXJzdCB2YWx1ZSwgYWtpbiB0byBYIGluIGEgc2NyZWVuIGNvb3JkaW5hdGUgc3lzdGVtXHJcbiAgICAgKiBAcGFyYW0gbGVuZ3RoOiBzZWNvbmQgdmFsdWUsIGFraW4gdG8gWSBpbiBhIHNjcmVlbiBjb29yZGluYXRlIHN5c3RlbVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcih3aWR0aCwgbGVuZ3RoKSB7XHJcblxyXG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLmNvbHVtbnMgPSB3aWR0aCB8fCAxO1xyXG5cclxuICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMucm93cyA9IGxlbmd0aCB8fCB0aGlzLndpZHRoO1xyXG5cclxuICAgICAgICBsZXQgY29sX2FycmF5ID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgY29sX2FycmF5LmZpbGwobnVsbCk7XHJcblxyXG4gICAgICAgIHRoaXNbbGlzdFN5bWJvbF0gPSBbXTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLndpZHRoOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXNbbGlzdFN5bWJvbF1baV0gPSBjb2xfYXJyYXkuc2xpY2UoMCk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB4XHJcbiAgICAgKiBAcGFyYW0geVxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIGdldCh4LCB5KSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzW2xpc3RTeW1ib2xdW3hdW3ldO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHJldHVybnMgYWxsIHN1cnJvdW5kaW5nIHBvaW50cyBvZiBhIHBvaW50IHg6eVxyXG4gICAgICogQHBhcmFtIHhcclxuICAgICAqIEBwYXJhbSB5XHJcbiAgICAgKi9cclxuICAgIGdldF9zdXJyb3VuZGluZyh4LCB5KSB7XHJcblxyXG4gICAgICAgIGxldCBsaXN0ID0gW107XHJcblxyXG4gICAgICAgIGZvciAobGV0IHhpID0geCAtIDE7IHhpIDw9IHggKyAxOyB4aSsrKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCB5aSA9IHkgLSAxOyB5aSA8PSB5ICsgMTsgeWkrKykge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh4aSA9PT0geCAmJiB5aSA9PT0geSkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHhpIDwgMCB8fCB4aSA+PSB0aGlzLndpZHRoIHx8IHlpIDwgMCB8fCB5aSA+PSB0aGlzLmxlbmd0aCkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGVsZW0gPSB0aGlzLmdldCh4aSwgeWkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghZWxlbSkgZGVidWdnZXI7XHJcblxyXG4gICAgICAgICAgICAgICAgbGlzdC5wdXNoKGVsZW0pO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBsaXN0O1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7TWFwTm9kZX1cclxuICAgICAqL1xyXG4gICAgZ2V0X3JhbmRvbSgpIHtcclxuXHJcbiAgICAgICAgbGV0IHggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0aGlzLmNvbHVtbnMpLFxyXG4gICAgICAgICAgICB5ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy5yb3dzKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHgsIHkpO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHhcclxuICAgICAqIEBwYXJhbSB5XHJcbiAgICAgKiBAcGFyYW0gdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBzZXQoeCwgeSwgdmFsdWUpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXNbbGlzdFN5bWJvbF1beF1beV0gPSB2YWx1ZTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBmb3JlYWNoIGdvZXMgZnJvbSB0b3AtbGVmdCB0byBib3R0b20tcmlnaHRcclxuICAgICAqIEBwYXJhbSBjYWxsYmFja1xyXG4gICAgICovXHJcbiAgICBmb3JfZWFjaChjYWxsYmFjaykge1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmdldF9yb3coaSkuZm9yRWFjaCgoZWxlbSwgaikgPT4gY2FsbGJhY2soZWxlbSwgaiwgaSkpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBnZXRfcm93KGluZGV4KSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzW2xpc3RTeW1ib2xdLm1hcChzdWJsaXN0ID0+IHN1Ymxpc3RbaW5kZXhdKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0X2NvbChpbmRleCkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpc1tsaXN0U3ltYm9sXVtpbmRleF0uc2xpY2UoMCk7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIHByaW50cyB0aGUgbGlzdCBmcm9tIHRvcC1sZWZ0IHRvIGJvdHRvbS1yaWdodDtcclxuICAgICAqL1xyXG4gICAgcHJpbnQoKSB7XHJcblxyXG4gICAgICAgIGxldCBvdXRwdXQgPSBcIlwiO1xyXG5cclxuICAgICAgICBsZXQgY3VycmVudF9yb3cgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLmZvcl9lYWNoKGZ1bmN0aW9uIChlbGVtLCB4LCB5KSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoeSA+IGN1cnJlbnRfcm93KSBvdXRwdXQgKz0gXCJcXG5cIjtcclxuXHJcbiAgICAgICAgICAgIG91dHB1dCArPSBcIiB8IFwiICsgU3RyaW5nKGVsZW0pICsgXCIgfCBcIjtcclxuXHJcbiAgICAgICAgICAgIGN1cnJlbnRfcm93ID0geTtcclxuXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKG91dHB1dCk7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTGlzdDJEO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBUSFJFRSA9IHJlcXVpcmUoXCIuLi8uLi9saWIvdGhyZWVcIik7XHJcblxyXG5jbGFzcyBQb2ludCB7XHJcblxyXG4gICAgY29uc3RydWN0b3IoeCwgeSwgeikge1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB0aGlzLnogPSB6IHx8IDA7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGZyb20odmVjKXtcclxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHZlYy54LCB2ZWMueSwgdmVjLnopO1xyXG4gICAgfVxyXG5cclxuICAgIHRvX3ZlY3Rvcigpe1xyXG4gICAgICAgIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyh0aGlzLngsIHRoaXMueSwgdGhpcy56KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xyXG4gICAgICogQHBhcmFtIG90aGVyXHJcbiAgICAgKiBAcGFyYW0gaW5jbHVkZV96XHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBkaXN0YW5jZV90byhvdGhlciwgaW5jbHVkZV96KXtcclxuXHJcbiAgICAgICAgaW5jbHVkZV96ID0gaW5jbHVkZV96IHx8IGZhbHNlO1xyXG4gICAgICAgIGlmKGluY2x1ZGVfeikgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwiI1BvaW50OiBEaXN0YW5jZSBiYXNlZCBvbiBaIG5vdCBpbXBsZW1lbnRlZCFcIik7XHJcblxyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cob3RoZXIueCAtIHRoaXMueCwgMikgKyBNYXRoLnBvdyhvdGhlci55IC0gdGhpcy55LCAyKSk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBlcXVhbHMob3RoZXIpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLnggPT09IG90aGVyLnggJiYgdGhpcy55ID09PSBvdGhlci55O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJldHR5IHByaW50c1xyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCl7XHJcbiAgICAgICAgcmV0dXJuIGAoJHt0aGlzLnh9OiR7dGhpcy55fToke3RoaXMuen0pYDtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUG9pbnQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxubGV0IERlZmVycmVkID0gcmVxdWlyZShcIi4uLy4uL2xpYi9tdC1wcm9taXNlXCIpO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBBIFRhc2sgaXMgYSB3cmFwcGVyIGFyb3VuZCBmdW5jdGlvbnMgdGhhdCBhbGxvd3Mgc29tZW9uZSB0byBzdG9yZSBhIGZ1bmN0aW9uIGFuZCBydW4gaXQgbGF0ZXIuXHJcbiAqIFRoZSBjYWxsIHRvIC5ydW4oKSB3aWxsIEFMV0FZUyByZXR1cm4gYSBwcm9taXNlLlxyXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBmdW5jdGlvbiB3aWxsIGJlIGFjY2Vzc2libGUgdmlhIGFyZ3VtZW50c1swXS5hcmd1bWVudHMgYW5kIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuICogc3VwcGxpZWQgYnkgcnVuKGFyZzEsIGFyZzIpIHdpbGwgYmUgYXZhaWxhYmxlIHZpYSBhcmd1bWVudHNbMF0uYWRkaXRpb25hbC5cclxuICovXHJcbmNsYXNzIFRhc2sge1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBDcmVhdGVzIGEgdGFzayBiYXNlZCBvbiB0aGUgZ2l2ZW4gZnVuY3Rpb24sIGFyZ3MsIGFuZCBjb250ZXh0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZ1bmNcclxuICAgICAqIEBwYXJhbSBhcmdzXHJcbiAgICAgKiBAcGFyYW0gY29udGV4dFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihmdW5jLCBhcmdzLCBjb250ZXh0KSB7XHJcblxyXG4gICAgICAgIHRoaXMuZnVuYyA9ICEhY29udGV4dCA/IGZ1bmMuYmluZChjb250ZXh0KSA6IGZ1bmM7XHJcblxyXG4gICAgICAgIHRoaXMuYXJncyA9IEFycmF5LmlzQXJyYXkoYXJncykgPyBhcmdzIDogW2FyZ3NdO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogUnVuIGEgZ2l2ZW4gdGFzayB3aXRoIGFsbCBwcm92aWRlZCBhcmd1bWVudHMgYXBwZW5kZWQgb24gdGhlIG9yaWdpbmFsXHJcbiAgICAgKiBhcmd1bWVudHMgbGlzdCB0aGF0IGlzIGdpdmVuIHRvIHRoZSBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIGFkZF9hcmdzXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgcnVuKC4uLmFkZF9hcmdzKSB7XHJcblxyXG4gICAgICAgIGFkZF9hcmdzID0gYWRkX2FyZ3MgfHwgW107XHJcblxyXG4gICAgICAgIC8vIGNhbGwgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIHN1cHBsaWVkIGFyZ3VtZW50cyBhbmQgYm9udXMgYXJndW1lbnRzXHJcblxyXG4gICAgICAgIGxldCBwcm9taXNlID0gdGhpcy5mdW5jKC4uLnRoaXMuYXJncywgLi4uYWRkX2FyZ3MpO1xyXG5cclxuXHJcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIGFsd2F5cyByZXR1cm4gYSBwcm9taXNlIGZvciBjb25zaXN0ZW5jeVxyXG4gICAgICAgIGlmIChwcm9taXNlIGluc3RhbmNlb2YgRGVmZXJyZWQuUHJvbWlzZSkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICBsZXQgZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG5cclxuICAgICAgICAgICAgZC5yZXNvbHZlKHByb21pc2UpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGQucHJvbWlzZTtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufVxyXG5cclxuXHJcbmNsYXNzIFRhc2tMaXN0IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFF1YXNpLXN0YXRpYyB2YXJpYWJsZSBob2xkaW5nIHRoZSBwb3NzaWJsZSBzdGF0ZXMgb2YgdGhlIHRhc2stbGlzdFxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt7UlVOTklORzogbnVtYmVyLCBQQVVTSU5HOiBudW1iZXIsIFNUT1BQRUQ6IG51bWJlcn19XHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBTVEFURVMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgUlVOTklORzogMSxcclxuICAgICAgICAgICAgUEFVU0lORzogMixcclxuICAgICAgICAgICAgU1RPUFBFRDogM1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHRhc2tsaXN0IHdpdGggdGhlIGdpdmVuIGFycmF5IG9mIHRhc2tzIG9yIGFuIGVtcHR5IG9uZVxyXG4gICAgICogQHBhcmFtIHRhc2tzIDxvcHRpb25hbD4gYXJyYXkgb2YgdGFza3NcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IodGFza3MpIHtcclxuXHJcbiAgICAgICAgdGhpcy50YXNrcyA9IEFycmF5LmlzQXJyYXkodGFza3MpID8gdGFza3MgOiBbXTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFRhc2tMaXN0LlNUQVRFUy5TVE9QUEVEO1xyXG5cclxuICAgICAgICB0aGlzLmRlZmVycmVkID0gbnVsbDtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyB7VGFza3xudWxsfSB0aGUgY3VycmVudGx5IGFjdGl2ZSB0YXNrXHJcbiAgICAgKi9cclxuICAgIGdldCBjdXJyZW50X3Rhc2soKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnRhc2tzLmxlbmd0aCA+IDAgPyB0aGlzLnRhc2tzWzBdIDogbnVsbDtcclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhbm90aGVyIHRhc2sgdG8gdGhlIHRhc2tsaXN0XHJcbiAgICAgKiBAcGFyYW0gdGFza3NcclxuICAgICAqL1xyXG4gICAgYWRkX3Rhc2tzKHRhc2tzKSB7XHJcblxyXG4gICAgICAgIHRhc2tzID0gQXJyYXkuaXNBcnJheSh0YXNrcykgPyB0YXNrcyA6IFt0YXNrc107XHJcblxyXG4gICAgICAgIHRhc2tzLmZvckVhY2godGFzayA9PiB0aGlzLnRhc2tzLnB1c2godGFzaykpO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJcyBndWFyYW50ZWVkIHRvIGJlIGFzeW5jL25leHQgdGlja1xyXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCBiZWhhdmVzIGFzIGZvbGxvd2luZzpcclxuICAgICAqXHJcbiAgICAgKiByZXNvbHZlcyB3aXRoIHZhbHVlOiBXaGVuIHRoZSB0YXNrbGlzdCBoYXMgYmVlbiBjb21wbGV0ZWx5IGVtcHRpZXMsIHJlc29sdmVzIHdpdGggdGhlIHZhbHVlIG9mIHRoZSBsYXN0IHByb21pc2VcclxuICAgICAqIHJlc29sdmVzIHdpdGggVGFza0xpc3QuU1RBVEVTLlBBVVNJTkc6IEluZGljYXRlcyB0aGF0IHRoZSB0YXNrbGlzdCBoYXMgYmVlbiBwYXVzZWRcclxuICAgICAqIHJlamVjdHM6IFdoZW4gYSB0YXNrIGhhcyBmYWlsZWRcclxuICAgICAqIHVwZGF0ZXM6IG9uIGV2ZXJ5IHRhc2sgY29tcGxldGlvbiwgaW5kZXBlbmRlbnQgd2hldGhlciBpdCB3YXMgc3VjY2Vzc2Z1bFxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgc3RhcnQoLi4uYWRkaXRpb25zKSB7XHJcblxyXG4gICAgICAgIC8vIGlmIHRoZSB0aGluZyBpcyBhbHJlYWR5IHJ1bm5pbmcsIHJldHVybiB0aGUgY3VycmVudCBwcm9taXNlIGFuZCB3YXJuXHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFRhc2tMaXN0LlNUQVRFUy5SVU5OSU5HKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZlcnJlZC5wcm9taXNlO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGFkZGl0aW9ucyA9IGFkZGl0aW9ucyB8fCBbXTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFRhc2tMaXN0LlNUQVRFUy5SVU5OSU5HO1xyXG5cclxuICAgICAgICB0aGlzLmRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbih0aGlzOlRhc2tMaXN0KX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBsZXQgb25fbmV4dF90YXNrID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQudXBkYXRlKC4uLmFyZ3MpO1xyXG5cclxuICAgICAgICAgICAgLy8gcmVzb2x2ZSB3aXRoIHBhdXNlIG5vdGljZVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFRhc2tMaXN0LlNUQVRFUy5QQVVTSU5HKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFRhc2tMaXN0LlNUQVRFUy5TVE9QUEVEO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBidWZmZXJfZGVmZXJyZWQgPSB0aGlzLmRlZmVycmVkO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgIGJ1ZmZlcl9kZWZlcnJlZC5yZXNvbHZlKFRhc2tMaXN0LlNUQVRFUy5QQVVTSU5HKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyByZXNvbHZlIHdpdGggbGFzdCB2YWx1ZVxyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnRfdGFzaykge1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBUYXNrTGlzdC5TVEFURVMuU1RPUFBFRDtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgYnVmZmVyX2RlZmVycmVkID0gdGhpcy5kZWZlcnJlZDtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmVycmVkID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICBidWZmZXJfZGVmZXJyZWQucmVzb2x2ZSguLi5hcmdzKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBpZiBubyBhYm9ydCBjb25kaXRpb25zIGFyZSBtZXQsIGNvbnRpbnVlXHJcblxyXG4gICAgICAgICAgICB0aGlzLl9ydW5fbmV4dCguLi5hcmdzKS50aGVuKG9uX25leHRfdGFzaywgb25fdGFza19mYWlsdXJlKTtcclxuXHJcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbih0aGlzOlRhc2tMaXN0KX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBsZXQgb25fdGFza19mYWlsdXJlID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQudXBkYXRlKC4uLmFyZ3MpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFRhc2tMaXN0LlNUQVRFUy5TVE9QUEVEO1xyXG5cclxuICAgICAgICAgICAgbGV0IGJ1ZmZlcl9kZWZlcnJlZCA9IHRoaXMuZGVmZXJyZWQ7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRlZmVycmVkID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIGJ1ZmZlcl9kZWZlcnJlZC5yZWplY3QoLi4uYXJncyk7XHJcblxyXG4gICAgICAgIH0uYmluZCh0aGlzKTtcclxuXHJcblxyXG4gICAgICAgIC8vIG5lZWQgdG8gZW5mb3JjZSBhc3luYyBoZXJlIGJlY2F1c2UgZW1wdHkgdGFzayBsaXN0cyB3b3VsZCByZXNvbHZlIGltbWVkaWF0ZWx5IG90aGVyd2lzZVxyXG5cclxuICAgICAgICAvL25vaW5zcGVjdGlvbiBKU1VucmVzb2x2ZWRWYXJpYWJsZVxyXG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4gdGhpcy5fcnVuX25leHQoLi4uYWRkaXRpb25zKS50aGVuKG9uX25leHRfdGFzaywgb25fdGFza19mYWlsdXJlKSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmRlZmVycmVkLnByb21pc2U7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWRkaXRpb25zXHJcbiAgICAgKiBAcmV0dXJucyB7RGVmZXJyZWQucHJvbWlzZX1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9ydW5fbmV4dCguLi5hZGRpdGlvbnMpIHtcclxuXHJcbiAgICAgICAgbGV0IGRlZiA9IG5ldyBEZWZlcnJlZCgpO1xyXG5cclxuICAgICAgICBhZGRpdGlvbnMgPSBhZGRpdGlvbnMgfHwgW107XHJcblxyXG4gICAgICAgIC8vIGZpeCBlcnJvciB3aGVuIGVtcHR5IHRhc2tsaXN0IGdldHMgc3RhcnRlZFxyXG5cclxuICAgICAgICBpZiAodGhpcy50YXNrcy5sZW5ndGggPT09IDApIHtcclxuXHJcbiAgICAgICAgICAgIGRlZi5yZXNvbHZlKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZGVmLnByb21pc2U7XHJcblxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIGxldCBwID0gdGhpcy50YXNrc1swXS5ydW4oLi4uYWRkaXRpb25zKTtcclxuXHJcbiAgICAgICAgcC50aGVuKCguLi5hcmdzKSA9PiB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnRhc2tzLnNoaWZ0KCk7XHJcblxyXG4gICAgICAgICAgICBkZWYucmVzb2x2ZSguLi5hcmdzKTtcclxuXHJcbiAgICAgICAgfSwgKC4uLmFyZ3MpID0+IHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudGFza3Muc2hpZnQoKTtcclxuXHJcbiAgICAgICAgICAgIGRlZi5yZWplY3QoLi4uYXJncyk7XHJcblxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gZGVmLnByb21pc2U7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbGwgdGFza3MgYW5kIHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgb25jZSB0aGUgdGFzayBoYXMgYmVlbiBhYm9ydGVkXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB0aGF0IGlzIGd1YXJhbnRlZWQgdG8gcmVzb2x2ZSBhc3luY1xyXG4gICAgICovXHJcbiAgICBjbGVhcigpIHtcclxuXHJcbiAgICAgICAgdGhpcy50YXNrcy5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5kZWZlcnJlZCkgcmV0dXJuIHRoaXMuZGVmZXJyZWQucHJvbWlzZTtcclxuXHJcbiAgICAgICAgbGV0IGQgPSBuZXcgRGVmZXJyZWQoKTtcclxuXHJcbiAgICAgICAgLy9ub2luc3BlY3Rpb24gSlNVbnJlc29sdmVkVmFyaWFibGVcclxuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IGQucmVzb2x2ZSgpKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGQucHJvbWlzZTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxufVxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgVGFza0xpc3Q6IFRhc2tMaXN0LFxyXG4gICAgVGFzazogVGFza1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG4vKipcclxuICogVXNhZ2U6XHJcbiAqXHJcbiAqIGxldCBhID0gbmV3IFR3ZWVuKHt4OiAwfSwge3g6IDEwfSwgNCk7XHJcbiAqIGZvcih2YXIgaSBvZiBhKXtcclxuICogICBjb25zb2xlLmxvZyhpKTtcclxuICogfVxyXG4gKlxyXG4gKi9cclxuY2xhc3MgVHdlZW4ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvLCBzdGVwcykge1xyXG5cclxuICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xyXG5cclxuICAgICAgICBsZXQgY3VycmVudF9zdGVwID0gMDtcclxuICAgICAgICBsZXQgY3VycmVudF92YWwgPSB7fTtcclxuICAgICAgICBsZXQgc3RlcF9zaXplID0ge307XHJcblxyXG4gICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRfdmFsW2tleV0gPSBmcm9tW2tleV07XHJcbiAgICAgICAgICAgIHN0ZXBfc2l6ZVtrZXldID0gKHRvW2tleV0gLSBmcm9tW2tleV0pIC8gc3RlcHM7XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICB0aGlzW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiogKCkge1xyXG5cclxuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnRfc3RlcCA8IHN0ZXBzKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50X3N0ZXArKztcclxuICAgICAgICAgICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gY3VycmVudF92YWxba2V5XSArPSBzdGVwX3NpemVba2V5XSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY2xvbmUgYW5kIHJldHVybiBvYmplY3RcclxuICAgICAgICAgICAgICAgIGxldCBjbG9uZSA9IHt9O1xyXG4gICAgICAgICAgICAgICAga2V5cy5mb3JFYWNoKGtleT0+IGNsb25lW2tleV0gPSBjdXJyZW50X3ZhbFtrZXldKTtcclxuXHJcbiAgICAgICAgICAgICAgICB5aWVsZCBjbG9uZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgfVxyXG5cclxufVxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVHdlZW47XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIFRIUkVFID0gcmVxdWlyZShcIi4uLy4uL2xpYi90aHJlZVwiKTtcclxuXHJcbmNsYXNzIElucHV0SGFuZGxlciB7XHJcblxyXG4gICAgY29uc3RydWN0b3IoY2FtZXJhLCBzY2VuZSl7XHJcblxyXG4gICAgICAgIFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5jYWxsKHRoaXMpO1xyXG5cclxuICAgICAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcclxuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XHJcblxyXG4gICAgICAgIHdpbmRvdy5vbmtleWRvd24gPSB0aGlzLmhhbmRsZV9rZXlkb3duLmJpbmQodGhpcyk7XHJcbiAgICAgICAgd2luZG93Lm9ubW91c2V3aGVlbCA9IHRoaXMuaGFuZGxlX21vdXNld2hlZWwuYmluZCh0aGlzKTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuXHJcbiAgICBoYW5kbGVfbW91c2V3aGVlbChldnQpe1xyXG4gICAgICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnogKz0gZXZ0LndoZWVsRGVsdGEgPiAwID8gLTEgOiAxO1xyXG4gICAgfVxyXG5cclxuICAgIGhhbmRsZV9rZXlkb3duKGV2dCl7XHJcbiAgICAgICAgbGV0IGtleWJpbmRzID0ge1xyXG4gICAgICAgICAgICBEOiBbMSwgMF0sXHJcbiAgICAgICAgICAgIFM6IFswLCAtMV0sXHJcbiAgICAgICAgICAgIEE6ICBbLTEsIDBdLFxyXG4gICAgICAgICAgICBXOiBbMCwgMV1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBsZXQga2V5ID0gZXZ0LmNvZGUuc3Vic3RyaW5nKDMpO1xyXG5cclxuICAgICAgICBpZigha2V5YmluZHNba2V5XSl7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBkZWx0YSA9IGtleWJpbmRzW2tleV07XHJcblxyXG4gICAgICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnggKz0gZGVsdGFbMF0gKiA0O1xyXG4gICAgICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnkgKz0gZGVsdGFbMV0gKiA0O1xyXG5cclxuICAgIH1cclxuXHJcblxyXG5cclxuXHJcblxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IElucHV0SGFuZGxlcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5sZXQgSW5wdXRIYW5kbGVyID0gcmVxdWlyZShcIi4vaW5wdXRoYW5kbGVyXCIpO1xyXG5sZXQgVEhSRUUgPSByZXF1aXJlKFwiLi4vLi4vbGliL3RocmVlXCIpO1xyXG5sZXQgTWFwID0gcmVxdWlyZShcIi4uL21hcC9tYXBcIik7XHJcbmxldCBNYXBOb2RlID0gcmVxdWlyZShcIi4uL21hcC9tYXBub2RlXCIpO1xyXG5sZXQgQWN0b3IgPSByZXF1aXJlKFwiLi4vYWN0b3IvYWN0b3JcIik7XHJcbmxldCBUYXNrbWFzdGVyID0gcmVxdWlyZShcIi4uL2FjdG9yL3Rhc2ttYXN0ZXJcIik7XHJcbmxldCBHYW1lT2JqZWN0ID0gcmVxdWlyZShcIi4uL2NvbW1vbi9nYW1lb2JqZWN0XCIpO1xyXG5sZXQgUGF0aCA9IHJlcXVpcmUoXCIuLi9tYXAvcGF0aFwiKTtcclxubGV0IE1vdXNlSGFuZGxlciA9IHJlcXVpcmUoXCIuL21vdXNlaGFuZGxlclwiKTtcclxubGV0IFBvaW50ID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wb2ludFwiKTtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKi9cclxuY2xhc3MgTWFpbkNvbnRyb2xsZXIge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGFuaW1hdGlvbiwgbWFwLCBhY3RvcnMpIHtcclxuXHJcbiAgICAgICAgdGhpcy5hbmltYXRpb24gPSBhbmltYXRpb247XHJcblxyXG4gICAgICAgIHRoaXMubWFwID0gbWFwO1xyXG5cclxuICAgICAgICB0aGlzLmFjdG9ycyA9IGFjdG9ycztcclxuXHJcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBbXTtcclxuXHJcbiAgICAgICAgdGhpcy5pbnB1dF9oYW5kbGVyID0gbmV3IElucHV0SGFuZGxlcihhbmltYXRpb24uY2FtZXJhLCBhbmltYXRpb24uc2NlbmUpO1xyXG5cclxuICAgICAgICB0aGlzLm1vdXNlX2hhbmRsZXIgPSBuZXcgTW91c2VIYW5kbGVyKGFuaW1hdGlvbiwgbWFwLCBhY3RvcnMpO1xyXG5cclxuICAgICAgICB0aGlzLm1vdXNlX2hhbmRsZXIub24oXCJjbGlja1wiLCB0aGlzLmhhbmRsZV9jbGljay5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgICAgdGhpcy5tb3VzZV9oYW5kbGVyLm9uKFwic2VsZWN0aW9uXCIsIHRoaXMuaGFuZGxlX3NlbGVjdC5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgICAgdGhpcy5tb3VzZV9oYW5kbGVyLm9uKFwicmlnaHRjbGlja1wiLCB0aGlzLmhhbmRsZV9yaWdodGNsaWNrLmJpbmQodGhpcykpO1xyXG5cclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNsaWNrZWQgT2JqZWN0e29iamVjdCwgZmFjZSwgcG9pbnQsIC4uLilcclxuICAgICAqL1xyXG4gICAgaGFuZGxlX2NsaWNrKGNsaWNrZWQpIHtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXCIjTUM6IGNsaWNrXCIsIGNsaWNrZWQpO1xyXG5cclxuICAgICAgICBsZXQgb2JqID0gY2xpY2tlZC5vYmplY3Q7XHJcblxyXG4gICAgICAgIGlmIChvYmoudXNlckRhdGEgaW5zdGFuY2VvZiBBY3RvcikgdGhpcy5zZWxlY3Rpb24gPSBbb2JqLnVzZXJEYXRhXTtcclxuXHJcbiAgICAgICAgZWxzZSB0aGlzLnNlbGVjdGlvbi5sZW5ndGggPSAwO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc2VsZWN0aW9ucyBBcnJheTxBY3Rvcj5cclxuICAgICAqL1xyXG4gICAgaGFuZGxlX3NlbGVjdChzZWxlY3Rpb25zKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiI01DOiBzZWxlY3RcIiwgc2VsZWN0aW9ucyk7XHJcblxyXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLnB1c2guYXBwbHkodGhpcy5zZWxlY3Rpb24sIHNlbGVjdGlvbnMpO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXAtbm9kZSBjbG9zZXN0IGZvciBhIGdpdmVuIGNsaWNrLWV2ZW50XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNsaWNrZWRcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBnZXRfY2xvc2VzdF9ub2RlKGNsaWNrZWQpe1xyXG5cclxuICAgICAgICBsZXQgcG9pbnQgPSBQb2ludC5mcm9tKGNsaWNrZWQucG9pbnQpO1xyXG5cclxuICAgICAgICAvLyBkZXRlcm1pbmUgdGhlIHZlcnRpY2VzIChhbmQgdGhlcmVieSB0aGUgcG9zc2libGUgcG9zaXRpb25zKSBiYXNlZCBvbiB0aGUgY2xpY2tlZCBmYWNlXHJcblxyXG4gICAgICAgIGxldCBhbGxfdmVydGljZXMgPSBjbGlja2VkLm9iamVjdC5nZW9tZXRyeS52ZXJ0aWNlcztcclxuXHJcbiAgICAgICAgbGV0IHZlcnRpY2VzID0gW1xyXG4gICAgICAgICAgICBhbGxfdmVydGljZXNbY2xpY2tlZC5mYWNlLmFdLFxyXG4gICAgICAgICAgICBhbGxfdmVydGljZXNbY2xpY2tlZC5mYWNlLmJdLFxyXG4gICAgICAgICAgICBhbGxfdmVydGljZXNbY2xpY2tlZC5mYWNlLmNdXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgLy8gZmluZCBvdXQgd2hpY2ggcG9pbnQgaXMgdGhlIGNsb3Nlc3QgdmlhIFBvaW50LmRpc3RhbmNlX3RvXHJcblxyXG4gICAgICAgIGxldCBkaXN0YW5jZXMgPSB2ZXJ0aWNlcy5tYXAocCA9PiAgcG9pbnQuZGlzdGFuY2VfdG8oUG9pbnQuZnJvbShwKSkgKTtcclxuXHJcbiAgICAgICAgbGV0IHNtYWxsZXN0X2Rpc3QgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBkaXN0YW5jZXMpO1xyXG5cclxuICAgICAgICAvLyBnZXQgdGhlIGNsb3Nlc3QgdmVydGljZVxyXG5cclxuICAgICAgICBsZXQgY2xvc2VzdF9wb2ludCA9IHZlcnRpY2VzW2Rpc3RhbmNlcy5pbmRleE9mKHNtYWxsZXN0X2Rpc3QpXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLnN0cnVjdHVyZS5nZXQoY2xvc2VzdF9wb2ludC54LCBjbG9zZXN0X3BvaW50LnkpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIGFjdG9ycyBhcmUgc2VsZWN0ZWQsIHdpbGwgc2VuZCB0aGVtIHRvIHRoZSB0YXJnZXQgZmllbGRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2xpY2tlZCBPYmplY3R7b2JqZWN0LCBmYWNlLCBwb2ludCwgLi4uKVxyXG4gICAgICovXHJcbiAgICBoYW5kbGVfcmlnaHRjbGljayhjbGlja2VkKSB7XHJcblxyXG4gICAgICAgIC8vIHJpZ2h0Y2xpY2sgb25seSBkb2VzIHN0dWZmIHdoZW4gd2UgaGF2ZSBzb21ldGhpbmcgc2VsZWN0ZWRcclxuXHJcbiAgICAgICAgaWYodGhpcy5zZWxlY3Rpb24ubGVuZ3RoID09PSAwKSByZXR1cm47XHJcblxyXG4gICAgICAgIGNsaWNrZWQgPSBjbGlja2VkLmZpbHRlcihldnQgPT4gZXZ0Lm9iamVjdC51c2VyRGF0YSBpbnN0YW5jZW9mIE1hcClbMF07XHJcblxyXG4gICAgICAgIC8vIGdldCB0aGUgdGFyZ2V0IG5vZGVcclxuXHJcbiAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuZ2V0X2Nsb3Nlc3Rfbm9kZShjbGlja2VkKTtcclxuXHJcbiAgICAgICAgLy8gbW92ZSBlYWNoIGFjdG9yIHNvbWV3aGVyZVxyXG5cclxuICAgICAgICB0aGlzLnNlbGVjdGlvbi5mb3JFYWNoKCBhY3RvciA9PiBUYXNrbWFzdGVyLnNlbmQoYWN0b3IsIHRhcmdldCwgdGhpcy5tYXApICk7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTWFpbkNvbnRyb2xsZXI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxubGV0IFRIUkVFID0gcmVxdWlyZShcIi4uLy4uL2xpYi90aHJlZVwiKTtcclxubGV0IEV2ZW50ZWQgPSByZXF1aXJlKFwiLi4vLi4vbGliL210LWV2ZW50XCIpO1xyXG5cclxuXHJcbmNsYXNzIE1vdXNlSGFuZGxlciB7XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhbmltYXRpb25cclxuICAgICAqIEBwYXJhbSBtYXBcclxuICAgICAqIEBwYXJhbSBhY3RvcnNcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoYW5pbWF0aW9uLCBtYXAsIGFjdG9ycykge1xyXG5cclxuICAgICAgICBFdmVudGVkLm1ha2VFdmVudGVkKHRoaXMpO1xyXG5cclxuICAgICAgICB0aGlzLmNsaWNrX2RlbGF5ID0gMC4xNSAqIDEwMDA7XHJcblxyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uID0gYW5pbWF0aW9uO1xyXG4gICAgICAgIHRoaXMubWFwID0gbWFwO1xyXG4gICAgICAgIHRoaXMuYWN0b3JzID0gYWN0b3JzO1xyXG5cclxuICAgICAgICB0aGlzLm1vdXNlZG93biA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubW91c2Vkb3duX2V2dCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tb3VzZWRvd25fb2JqX2J1ZmZlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tb3VzZWRvd25fdGltZSA9IG51bGw7XHJcblxyXG5cclxuICAgICAgICAvLyBzcGVjaWFsIHRocmVlIGpzIG1lc2ggdGhhdCB3ZSB1c2UgdG8gZGlzcGxheSBzZWxlY3Rpb25cclxuICAgICAgICB0aGlzLnNlbGVjdGlvbl9tb2RlbCA9IHRoaXMubG9hZF9zZWxlY3Rpb25fbW9kZWwoKTtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvbi5zY2VuZS5hZGQodGhpcy5zZWxlY3Rpb25fbW9kZWwpO1xyXG5cclxuICAgICAgICB0aGlzLmxvYWRfaG9va3MoKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBsb2FkX2hvb2tzKCkge1xyXG5cclxuICAgICAgICB3aW5kb3cub25tb3VzZWRvd24gPSB0aGlzLm9ubW91c2Vkb3duLmJpbmQodGhpcyk7XHJcbiAgICAgICAgd2luZG93Lm9ubW91c2V1cCA9IHRoaXMub25tb3VzZXVwLmJpbmQodGhpcyk7XHJcbiAgICAgICAgd2luZG93Lm9uY29udGV4dG1lbnUgPSB0aGlzLm9uY29udGV4dG1lbnUuYmluZCh0aGlzKTtcclxuICAgICAgICB3aW5kb3cub25tb3VzZW1vdmUgPSB0aGlzLm9ubW91c2Vtb3ZlLmJpbmQodGhpcyk7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZ0XHJcbiAgICAgKi9cclxuICAgIG9ubW91c2Vkb3duKGV2dCkge1xyXG4gICAgICAgIC8vIGluIHRoZSBjYXNlIG9mIHJpZ2h0Y2xpY2tzOlxyXG4gICAgICAgIGlmIChldnQuYnV0dG9uICE9PSAwKSByZXR1cm47XHJcblxyXG4gICAgICAgIHRoaXMubW91c2Vkb3duID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLm1vdXNlZG93bl9ldnQgPSBldnQ7XHJcbiAgICAgICAgdGhpcy5tb3VzZWRvd25fdGltZSA9IERhdGUubm93KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2dFxyXG4gICAgICovXHJcbiAgICBvbm1vdXNlbW92ZShldnQpIHtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLm1vdXNlZG93biB8fCB0aGlzLm1vdXNlZG93bl90aW1lICsgdGhpcy5jbGlja19kZWxheSA+IERhdGUubm93KCkpIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IGdlb21ldHJ5ID0gdGhpcy5zZWxlY3Rpb25fbW9kZWwuZ2VvbWV0cnk7XHJcblxyXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgdGhlIGZpcnN0IG1vdmUtYWN0aW9uLCBidWZmZXIgdGhlIG9yaWdpbmFsIG1vdmUgY29vcmRpbmF0ZXMgdG8gZHJhdyB0aGUgc2VsZWN0aW9uIHJlY3RhbmdsZVxyXG4gICAgICAgIGlmICghdGhpcy5tb3VzZWRvd25fb2JqX2J1ZmZlcikgdGhpcy5tb3VzZWRvd25fb2JqX2J1ZmZlciA9IHRoaXMuX2dldF9vYmplY3QodGhpcy5tb3VzZWRvd25fZXZ0KVswXTtcclxuXHJcblxyXG4gICAgICAgIGxldCBwMSA9IHRoaXMubW91c2Vkb3duX29ial9idWZmZXIucG9pbnQ7XHJcbiAgICAgICAgbGV0IHA0ID0gdGhpcy5fZ2V0X29iamVjdChldnQpWzBdLnBvaW50O1xyXG4gICAgICAgIHZhciBwMiwgcDM7XHJcblxyXG4gICAgICAgIC8vIG5lZWQgdG8gc3dpdGNoIHZlcnRpY2VzIGluIHRvcC1yaWdodCBhbmQgYm90dG9tLWxlZnQgcXVhZHJhbnRzXHJcbiAgICAgICAgLy8gc28gd2UgY2FuIG1ha2Ugc3VyZSB0aGF0IGZhY2VzIGFsd2F5cyBmYWNlIHVwd2FyZHNcclxuXHJcbiAgICAgICAgLy8gaWYgaW4gdG9wLWxlZnQgb3IgYm90dG9tLXJpZ2h0IHF1YWRyYW50OlxyXG4gICAgICAgIGlmICgocDQueCA+IHAxLnggJiYgcDQueSA8IHAxLnkpIHx8IChwNC54IDwgcDEueCAmJiBwNC55ID4gcDEueSkpIHtcclxuICAgICAgICAgICAgcDIgPSBwMS5jbG9uZSgpO1xyXG4gICAgICAgICAgICBwMi54ID0gcDQueDtcclxuICAgICAgICAgICAgcDMgPSBwMS5jbG9uZSgpO1xyXG4gICAgICAgICAgICBwMy55ID0gcDQueTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwMyA9IHAxLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHAzLnggPSBwNC54O1xyXG4gICAgICAgICAgICBwMiA9IHAxLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHAyLnkgPSBwNC55O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgW3AxLCBwMiwgcDMsIHA0XS5mb3JFYWNoKChwLCBpKSA9PiB7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzW2ldLnggPSBwLng7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzW2ldLnkgPSBwLnk7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzW2ldLnogPSA1O1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLnNlbGVjdGlvbl9tb2RlbC52aXNpYmxlID0gdHJ1ZTtcclxuXHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZ0XHJcbiAgICAgKi9cclxuICAgIG9ubW91c2V1cChldnQpIHtcclxuXHJcbiAgICAgICAgLy8gaW4gdGhlIGNhc2Ugb2YgcmlnaHRjbGlja3M6XHJcbiAgICAgICAgaWYgKGV2dC5idXR0b24gIT09IDApIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMubW91c2Vkb3duX3RpbWUgKyB0aGlzLmNsaWNrX2RlbGF5ID4gRGF0ZS5ub3coKSkge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJjbGlja1wiLCB0aGlzLl9nZXRfb2JqZWN0KGV2dClbMF0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbGN1bGF0ZV9zZWxlY3Rpb24oKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNsZWFudXAgdGhlIG1lc3NcclxuICAgICAgICB0aGlzLm1vdXNlZG93biA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubW91c2Vkb3duX2V2dCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tb3VzZWRvd25fdGltZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tb3VzZWRvd25fb2JqX2J1ZmZlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25fbW9kZWwudmlzaWJsZSA9IGZhbHNlO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2dFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIG9uY29udGV4dG1lbnUoZXZ0KSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KFwicmlnaHRjbGlja1wiLCB0aGlzLl9nZXRfb2JqZWN0KGV2dCkpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2dFxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfZ2V0X29iamVjdChldnQpIHtcclxuICAgICAgICBsZXQgcmF5Y2FzdGVyID0gbmV3IFRIUkVFLlJheWNhc3RlcigpO1xyXG4gICAgICAgIGxldCBtb3VzZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblxyXG4gICAgICAgIG1vdXNlLnggPSAoIGV2dC5jbGllbnRYIC8gdGhpcy5hbmltYXRpb24ucmVuZGVyZXIuZG9tRWxlbWVudC53aWR0aCApICogMiAtIDE7XHJcbiAgICAgICAgbW91c2UueSA9IC0oIGV2dC5jbGllbnRZIC8gdGhpcy5hbmltYXRpb24ucmVuZGVyZXIuZG9tRWxlbWVudC5oZWlnaHQgKSAqIDIgKyAxO1xyXG4gICAgICAgIHJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKG1vdXNlLCB0aGlzLmFuaW1hdGlvbi5jYW1lcmEpO1xyXG5cclxuICAgICAgICByZXR1cm4gcmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdHModGhpcy5hbmltYXRpb24uc2NlbmUuY2hpbGRyZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgYWxsIGdhbWVvYmplY3RzIGluc2lkZSBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb25cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9jYWxjdWxhdGVfc2VsZWN0aW9uKCkge1xyXG5cclxuICAgICAgICB0aGlzLnNlbGVjdGlvbl9tb2RlbC5nZW9tZXRyeS52ZXJ0aWNlcy5mb3JFYWNoKHYgPT4gdi56ID0gMCk7XHJcblxyXG4gICAgICAgIGxldCBib3VuZGluZ19ib3hfaGVpZ2h0ID0gMTAwOyAvLyBGSVhNRTogc2hvdWxkIGJlIHNhZmVcclxuICAgICAgICBsZXQgYmJveCA9IG5ldyBUSFJFRS5Cb3gzKCkuc2V0RnJvbU9iamVjdCh0aGlzLnNlbGVjdGlvbl9tb2RlbCk7XHJcblxyXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBhbGwgaW50ZXJzZWN0aW5nIGFjdG9yc1xyXG4gICAgICAgIGxldCBoaXRzID0gdGhpcy5hY3RvcnMuZmlsdGVyKHggPT4ge1xyXG5cclxuICAgICAgICAgICAgbGV0IGIgPSBuZXcgVEhSRUUuQm94MygpLnNldEZyb21PYmplY3QoeC5tZXNoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGNoYW5nZSB0aGUgYWN0b3JzIGJvdW5kaW5nIGJveGVzIHRvIGdvIHByZXR0eSBoaWdoIGluIHRoZSBaLWF4aXNcclxuICAgICAgICAgICAgLy8gc28gdGhlIHNlbGVjdGlvbiBtb2RlbCB3aWxsIGRlZmluaXRlbHkgaW50ZXJzZWN0IGl0XHJcbiAgICAgICAgICAgIGIuZXhwYW5kQnlWZWN0b3IobmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgYm91bmRpbmdfYm94X2hlaWdodCkpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJib3guaXNJbnRlcnNlY3Rpb25Cb3goYik7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuZW1pdChcInNlbGVjdGlvblwiLCBoaXRzKTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtUSFJFRS5NZXNofVxyXG4gICAgICovXHJcbiAgICBsb2FkX3NlbGVjdGlvbl9tb2RlbCgpIHtcclxuXHJcbiAgICAgICAgbGV0IGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcbiAgICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAwKSwgbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMCksIG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDApLCBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAwKSk7XHJcbiAgICAgICAgZ2VvbWV0cnkuZmFjZXMucHVzaChuZXcgVEhSRUUuRmFjZTMoMCwgMiwgMSksIG5ldyBUSFJFRS5GYWNlMygyLCAzLCAxKSk7XHJcblxyXG5cclxuICAgICAgICBsZXQgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCh7Y29sb3I6IDB4ZmYwMDAwfSk7XHJcbiAgICAgICAgbWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xyXG4gICAgICAgIG1hdGVyaWFsLm9wYWNpdHkgPSAwLjU7XHJcblxyXG4gICAgICAgIGxldCBtZXNoID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcclxuICAgICAgICBtZXNoLnZpc2libGUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG1lc2g7XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTW91c2VIYW5kbGVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmxldCBBbmltYXRpb24gPSByZXF1aXJlKFwiLi9hbmltYXRpb25cIik7XHJcbmxldCBNYXAgPSByZXF1aXJlKFwiLi9tYXAvbWFwXCIpO1xyXG5sZXQgTWFpbkNvbnRyb2xsZXIgPSByZXF1aXJlKFwiLi9jb250cm9sbGVycy9tYWluY29udHJvbGxlclwiKTtcclxubGV0IEFjdG9yID0gcmVxdWlyZShcIi4vYWN0b3IvYWN0b3JcIik7XHJcbmxldCBSZXNvdXJjZSA9IHJlcXVpcmUoXCIuL3Jlc291cmNlL3Jlc291cmNlXCIpO1xyXG5cclxuXHJcblxyXG5cclxubGV0IGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oKTtcclxuXHJcbmxldCBtYXAgPSBuZXcgTWFwKCk7XHJcblxyXG4vL2xldCByZXNvdXJjZSA9IG5ldyBSZXNvdXJjZSgpO1xyXG4vL21hcC5hZGRfcmVzb3VyY2UocmVzb3VyY2UpO1xyXG5cclxuXHJcblxyXG5cclxuXHJcbmFuaW1hdGlvbi5sb2FkX21hcChtYXApO1xyXG5cclxuXHJcblxyXG5sZXQgYWN0b3JzID0gW25ldyBBY3RvcihtYXAuc3RydWN0dXJlLmdldCgyMCwgMjApKSwgbmV3IEFjdG9yKG1hcC5zdHJ1Y3R1cmUuZ2V0KDMwLCAyMCkpXTtcclxuYW5pbWF0aW9uLmFkZF9lbGVtZW50KGFjdG9yc1swXSk7XHJcbmFuaW1hdGlvbi5hZGRfZWxlbWVudChhY3RvcnNbMV0pO1xyXG5cclxuXHJcblxyXG5sZXQgYyA9IG5ldyBNYWluQ29udHJvbGxlcihhbmltYXRpb24sIG1hcCwgYWN0b3JzKTtcclxuYW5pbWF0aW9uLnN0YXJ0KCk7XHJcblxyXG5cclxuXHJcblxyXG5jb25zb2xlLmxvZyhcImxvYWRlZFwiKTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5sZXQgR2FtZU9iamVjdCA9IHJlcXVpcmUoXCIuLi9jb21tb24vZ2FtZW9iamVjdFwiKTtcclxubGV0IFRIUkVFID0gcmVxdWlyZShcIi4uLy4uL2xpYi90aHJlZVwiKTtcclxubGV0IExpc3QyRCA9IHJlcXVpcmUoXCIuLi9jb21tb24vbGlzdDJkXCIpO1xyXG5sZXQgUG9pbnQgPSByZXF1aXJlKFwiLi4vY29tbW9uL3BvaW50XCIpO1xyXG5sZXQgU3RydWN0dXJlQnVpbGRlciA9IHJlcXVpcmUoXCIuL3N0cnVjdHVyZWJ1aWxkZXJcIik7XHJcbmxldCBNYXBFcnJvciA9IHJlcXVpcmUoXCIuLi9jb21tb24vZXJyb3JzXCIpLk1hcEVycm9yO1xyXG5sZXQgTW9kZWwgPSByZXF1aXJlKFwiLi9tb2RlbFwiKTtcclxubGV0IFBhdGggPSByZXF1aXJlKFwiLi9wYXRoXCIpO1xyXG5cclxuXHJcbmxldCBkZWZhdWx0X3Byb3BlcnRpZXMgPSB7XHJcbiAgICBzaXplX3g6IDEwMCxcclxuICAgIHNpemVfeTogMTAwLFxyXG4gICAgc3RydWN0dXJlOiBudWxsLFxyXG4gICAgZ3JvdW5kd2F0ZXI6IC0wLjgsXHJcbiAgICBtb3VudGFpbjogMSxcclxuICAgIGhpZ2hsaWdodF9jaGFuY2U6IDMwMCAvLyAxMDAwIG1lYW5zIDEgaW4gMTAwMFxyXG59O1xyXG5cclxuY2xhc3MgTWFwIGV4dGVuZHMgR2FtZU9iamVjdCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHByb3BlcnRpZXM6IE1hcCB3aXRoIGtleXM6IHNpemVfeCwgc2l6ZV95XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByb3BlcnRpZXMpIHtcclxuXHJcbiAgICAgICAgc3VwZXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcyB8fCBkZWZhdWx0X3Byb3BlcnRpZXM7XHJcblxyXG4gICAgICAgIC8vIHN0cnVjdHVyZSBpcyBhIExpc3QyRCBmaWxsZWQgd2l0aCBNYXBOb2Rlc1xyXG5cclxuICAgICAgICB0aGlzLnN0cnVjdHVyZSA9IFN0cnVjdHVyZUJ1aWxkZXIuY3JlYXRlX3JhbmRvbSh0aGlzLnByb3BlcnRpZXMpO1xyXG5cclxuICAgICAgICB0aGlzLm1lc2ggPSBNb2RlbC5nZW5lcmF0ZV9tb2RlbCh0aGlzLnByb3BlcnRpZXMsIHRoaXMuc3RydWN0dXJlKTtcclxuXHJcbiAgICAgICAgdGhpcy5tZXNoLnVzZXJEYXRhID0gdGhpcztcclxuXHJcblxyXG4gICAgICAgIC8vIGdlbmVyYXRlIHRoZSByZXNvdXJjZXNcclxuXHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZXMgPSBTdHJ1Y3R1cmVCdWlsZGVyLmNhbGN1bGF0ZV9yZXNvdXJjZXModGhpcy5zdHJ1Y3R1cmUpO1xyXG5cclxuICAgICAgICAvLyBwbGFjZSB0aGUgcmVzb3VyY2VzIG9uIHRoZSBub2Rlc1xyXG4gICAgICAgIC8vIEZJWE1FIE1ha2Ugc3VyZSB0aGF0IHR3byByZXNvdXJjZXMgY2FuJ3Qgb3ZlcmxhcCFcclxuXHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZXMuZm9yRWFjaChyZXNvdXJjZSA9PiB7XHJcblxyXG4gICAgICAgICAgICByZXNvdXJjZS5maWVsZHMuZm9yRWFjaChmaWVsZCA9PntcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IHRoaXMuc3RydWN0dXJlLmdldChmaWVsZC54LCBmaWVsZC55KTtcclxuXHJcbiAgICAgICAgICAgICAgICBub2RlLmxvY2socmVzb3VyY2UpO1xyXG5cclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgfSlcclxuXHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSByZXNvdXJjZSB0byB0aGlzIG1hcFxyXG4gICAgICogQHBhcmFtIHJlc291cmNlXHJcbiAgICAgKi9cclxuICAgIGFkZF9yZXNvdXJjZShyZXNvdXJjZSl7XHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZXMucHVzaChyZXNvdXJjZSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyB0aGUgYmVzdCBwb3NzaWJsZSBwYXRoIGJldHdlZW4gdHdvIHBvaW50c1xyXG4gICAgICogQHBhcmFtIGZyb21cclxuICAgICAqIEBwYXJhbSB0b1xyXG4gICAgICogQHJldHVybnMge1BhdGh8ZXhwb3J0c3xtb2R1bGUuZXhwb3J0c31cclxuICAgICAqL1xyXG4gICAgZ2V0X3BhdGgoZnJvbSwgdG8pe1xyXG5cclxuICAgICAgICBpZighZnJvbS54IHx8ICFmcm9tLnkgfHwgIXRvLnggfHwgIXRvLnkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCIjTWFwOiBOZWVkIHRvIHBhc3MgdHdvIHBvaW50cyB3aXRoIHgveSB2YWwhXCIpO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFBhdGgoZnJvbSwgdG8sIHRoaXMuc3RydWN0dXJlKTtcclxuICAgIH07XHJcblxyXG5cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNYXA7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxubGV0IE1hcEVycm9yID0gcmVxdWlyZShcIi4uL2NvbW1vbi9lcnJvcnNcIikuTWFwRXJyb3I7XHJcblxyXG5jbGFzcyBNYXBOb2RlIHtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwb2ludCwgcGFzc2FibGUpIHtcclxuICAgICAgICB0aGlzLnBvaW50ID0gcG9pbnQ7XHJcbiAgICAgICAgdGhpcy5wYXNzYWJsZSA9IHBhc3NhYmxlIHx8IGZhbHNlO1xyXG5cclxuICAgICAgICB0aGlzLl9fbG9ja19vYmplY3QgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGxvY2sobG9ja19vYmopIHtcclxuICAgICAgICBpZiAoISF0aGlzLl9fbG9ja19vYmplY3QpIHRocm93IG5ldyBNYXBFcnJvcihcIiNNYXBub2RlOiBOb2RlIGlzIGFscmVhZHkgbG9ja2VkIVwiKTtcclxuICAgICAgICB0aGlzLl9fbG9ja19vYmplY3QgPSBsb2NrX29iajtcclxuICAgIH1cclxuXHJcbiAgICB1bmxvY2soKSB7XHJcbiAgICAgICAgdGhpcy5fX2xvY2tfb2JqZWN0ID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgbG9ja2VkKCkge1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuX19sb2NrX29iamVjdDtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgb2JqZWN0KCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX19sb2NrX29iamVjdDtcclxuICAgIH1cclxuXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gYCgke3RoaXMucG9pbnQueH06JHt0aGlzLnBvaW50Lnl9KSAke3RoaXMucG9pbnQuei50b1N0cmluZygpLnN1YnN0cmluZygwLCAzKX0gJHt0aGlzLnBhc3NhYmxlID8gXCJvXCIgOiBcInhcIn1gO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNYXBOb2RlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBUSFJFRSA9IHJlcXVpcmUoXCIuLi8uLi9saWIvdGhyZWVcIik7XHJcblxyXG5jbGFzcyBNb2RlbCB7XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgcmF0aGVyIGNvbXBsZXggbWFwLW1lc2ggaW5jbHVkaW5nIHRleHR1cmVzXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge1RIUkVFLk1lc2h9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2VuZXJhdGVfbW9kZWwocHJvcGVydGllcywgc3RydWN0dXJlKSB7XHJcblxyXG5cclxuICAgICAgICBsZXQgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHJcbiAgICAgICAgbGV0IHdpZHRoID0gc3RydWN0dXJlLndpZHRoO1xyXG4gICAgICAgIGxldCBsZW5ndGggPSBzdHJ1Y3R1cmUubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggZmFjZXMgYXJlIHdhdGVyIGFuZCBtb3VudGFpbnNcclxuICAgICAgICBsZXQgd2F0ZXIgPSBwcm9wZXJ0aWVzLmdyb3VuZHdhdGVyO1xyXG4gICAgICAgIGxldCBtb3VudGFpbiA9IHByb3BlcnRpZXMubW91bnRhaW47XHJcblxyXG5cclxuICAgICAgICBsZXQgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCh7dmVydGV4Q29sb3JzOiBUSFJFRS5WZXJ0ZXhDb2xvcnN9KTtcclxuXHJcblxyXG4gICAgICAgIC8vIDA6IHdhdGVyLCAxOiBlYXJ0aCwgMjogbW91bnRhaW50b3BcclxuICAgICAgICBsZXQgdmVydGljZV9jb2xvcnMgPSBbXHJcbiAgICAgICAgICAgIG5ldyBUSFJFRS5Db2xvcigweDIyOUNFNCksXHJcbiAgICAgICAgICAgIG5ldyBUSFJFRS5Db2xvcigweDAwNjQwMCksXHJcbiAgICAgICAgICAgIG5ldyBUSFJFRS5Db2xvcigweGY0YTQ2MClcclxuICAgICAgICBdO1xyXG5cclxuXHJcblxyXG5cclxuICAgICAgICAvLyBjcmVhdGUgdmVydGljZXMgYmFzZWQgb24gdGhlIHN0cnVjdHVyZVxyXG4gICAgICAgIHN0cnVjdHVyZS5mb3JfZWFjaChmdW5jdGlvbiAobm9kZSwgeCwgeSkge1xyXG4gICAgICAgICAgICAvLyBhZGQgdGhlIHZlcnRpY2VzIGZvciBlYWNoIHBvaW50XHJcbiAgICAgICAgICAgIGxldCB2ZXJ0ID0gbmV3IFRIUkVFLlZlY3RvcjMobm9kZS5wb2ludC54LCBub2RlLnBvaW50LnksIG5vZGUucG9pbnQueik7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2godmVydCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAvLyBjcmVhdGUgMiBmYWNlcyBmb3IgZWFjaCBwb2ludCwgZXhjbHVkaW5nIHRoZSBwb2ludHMgYXQgdGhlIGNvcm5lcnNcclxuICAgICAgICBzdHJ1Y3R1cmUuZm9yX2VhY2goZnVuY3Rpb24gKG5vZGUsIHgsIHkpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIG5vIGZhY2VzIGlmIHdlIGFyZSBhdCB0aGUgcmlnaHQgb3IgYm90dG9tL3RvcCg/KSBib3JkZXJcclxuICAgICAgICAgICAgaWYgKHggPT09IHdpZHRoIC0gMSB8fCB5ID09PSBsZW5ndGggLSAxKSByZXR1cm47XHJcblxyXG5cclxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBpbmRleCBvZiB0aGUgY29ycmVzcG9uZGluZyB2ZXJ0aWNlcy92ZXJ0aXgvdmVydGl4ZXM/P1xyXG4gICAgICAgICAgICBsZXQgZmFjZTFfY29vcmRzID0ge1xyXG4gICAgICAgICAgICAgICAgYTogeCArIHkgKiB3aWR0aCxcclxuICAgICAgICAgICAgICAgIGI6IHggKyAxICsgeSAqIHdpZHRoLFxyXG4gICAgICAgICAgICAgICAgYzogeCArICh5ICsgMSkgKiB3aWR0aFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSB2ZXJ0aWNlIGNvbG9ycyBieSBjcm9zcy1jaGVja2luZyB0aGVpciB2YWx1ZXMgd2l0aCB0aGUgdGhyZXNoaG9sZHNcclxuICAgICAgICAgICAgbGV0IGZhY2UxX2NvbG9ycyA9IFtcImFcIiwgXCJiXCIsIFwiY1wiXS5tYXAobWF0X2Nvb3JkID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB2ZXJ0ID0gZ2VvbWV0cnkudmVydGljZXNbZmFjZTFfY29vcmRzW21hdF9jb29yZF1dO1xyXG4gICAgICAgICAgICAgICAgbGV0IGkgPSB2ZXJ0LnogPD0gd2F0ZXIgPyAwIDogdmVydC56ID49IG1vdW50YWluID8gMjogMTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2ZXJ0aWNlX2NvbG9yc1tpXTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBsZXQgZmFjZTEgPSBuZXcgVEhSRUUuRmFjZTMoXHJcbiAgICAgICAgICAgICAgICBmYWNlMV9jb29yZHMuYSxcclxuICAgICAgICAgICAgICAgIGZhY2UxX2Nvb3Jkcy5iLFxyXG4gICAgICAgICAgICAgICAgZmFjZTFfY29vcmRzLmMsXHJcbiAgICAgICAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgICAgICAgZmFjZTFfY29sb3JzXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAvLysrKysrKysrKysrKysrXHJcblxyXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIGluZGV4IG9mIHRoZSBjb3JyZXNwb25kaW5nIHZlcnRpY2VzL3ZlcnRpeC92ZXJ0aXhlcz8/XHJcbiAgICAgICAgICAgIGxldCBmYWNlMl9jb29yZHMgPSB7XHJcbiAgICAgICAgICAgICAgICBhOiB4ICsgKHkgKyAxKSAqIHdpZHRoLFxyXG4gICAgICAgICAgICAgICAgYjogeCArIDEgKyB5ICogd2lkdGgsXHJcbiAgICAgICAgICAgICAgICBjOiB4ICsgMSArICh5ICsgMSkgKiB3aWR0aFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSB2ZXJ0aWNlIGNvbG9ycyBieSBjcm9zcy1jaGVja2luZyB0aGVpciB2YWx1ZXMgd2l0aCB0aGUgdGhyZXNoaG9sZHNcclxuICAgICAgICAgICAgbGV0IGZhY2UyX2NvbG9ycyA9IFtcImFcIiwgXCJiXCIsIFwiY1wiXS5tYXAobWF0X2Nvb3JkID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB2ZXJ0ID0gZ2VvbWV0cnkudmVydGljZXNbZmFjZTJfY29vcmRzW21hdF9jb29yZF1dO1xyXG4gICAgICAgICAgICAgICAgbGV0IGkgPSB2ZXJ0LnogPD0gd2F0ZXIgPyAwIDogdmVydC56ID49IG1vdW50YWluID8gMjogMTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2ZXJ0aWNlX2NvbG9yc1tpXTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAgICAgbGV0IGZhY2UyID0gbmV3IFRIUkVFLkZhY2UzKFxyXG4gICAgICAgICAgICAgICAgZmFjZTJfY29vcmRzLmEsXHJcbiAgICAgICAgICAgICAgICBmYWNlMl9jb29yZHMuYixcclxuICAgICAgICAgICAgICAgIGZhY2UyX2Nvb3Jkcy5jLFxyXG4gICAgICAgICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgICAgIGZhY2UyX2NvbG9yc1xyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgZ2VvbWV0cnkuZmFjZXMucHVzaChmYWNlMSwgZmFjZTIpO1xyXG5cclxuXHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICBnZW9tZXRyeS5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuICAgICAgICBnZW9tZXRyeS5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xyXG4gICAgICAgIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG4gICAgICAgIC8vZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNb2RlbDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5sZXQgUGF0aEVycm9yID0gcmVxdWlyZShcIi4uL2NvbW1vbi9lcnJvcnNcIikuUGF0aEVycm9yO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgY2xhc3MgdG8gZW5jYXBzdWxhdGUgdGhlIGRpc3RhbmNlL2hldXJpc3RpY3MgdmFsdWVzXHJcbiAqL1xyXG5jbGFzcyBQYXRoTm9kZSB7XHJcblxyXG4gICAgY29uc3RydWN0b3Iobm9kZSwgZGlzdGFuY2UsIGhldXJpc3RpY3MsIHBhcmVudCkge1xyXG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XHJcbiAgICAgICAgdGhpcy5kID0gZGlzdGFuY2U7XHJcbiAgICAgICAgdGhpcy5oID0gaGV1cmlzdGljcztcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgcGF0aCBiZXR3ZWVuIHR3byBwb2ludHMgYmFzZWQgb24gYSBnaXZlbiBzdHJ1Y3R1cmVcclxuICovXHJcbmNsYXNzIFBhdGgge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHBhdGggYmV0d2VlbiB0d28gcG9pbnRzIGFuZCBtYWtlcyB0aGUgcGF0aC1pbnN0YW5jZSBhbiBpdGVyYWJsZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmcm9tXHJcbiAgICAgKiBAcGFyYW0gdG9cclxuICAgICAqIEBwYXJhbSBzdHJ1Y3R1cmVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIHN0cnVjdHVyZSkge1xyXG5cclxuICAgICAgICAvLyBzYW5pdGl6ZSBpbnB1dFxyXG4gICAgICAgIGZyb20gPSBzdHJ1Y3R1cmUuZ2V0KGZyb20ueCwgZnJvbS55KTtcclxuICAgICAgICB0byA9IHN0cnVjdHVyZS5nZXQodG8ueCwgdG8ueSk7XHJcblxyXG5cclxuICAgICAgICAvLyB0aHJvdyBlcnJvciBpZiBpbXBvc3NpYmxlXHJcbiAgICAgICAgaWYoIWZyb20ucGFzc2FibGUgfHwgIXRvLnBhc3NhYmxlIHx8IHRvLmxvY2tlZCl7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBQYXRoRXJyb3IoXCIjUGF0aDogQ2FuJ3QgZGV0ZXJtaW5lIGEgcGF0aCBiZWNhdXNlIGVpdGhlciBvcmlnaW4gb3IgdGFyZ2V0IGlzbid0IHBhc3NhYmxlXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGN1cnJlbnQsXHJcbiAgICAgICAgICAgIHN1cnJvdW5kaW5nID0gW10sXHJcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMgPSBbXSxcclxuICAgICAgICAgICAgcGF0aCA9IFtdLFxyXG4gICAgICAgICAgICBrbm93biA9IFtdO1xyXG5cclxuXHJcbiAgICAgICAgLy8gYmVmb3JlIHRoZSBmaXJzdCBpdGVyYXRpb24sIHdlJ2xsIHNldCB0aGUgY3VycmVudCBwb2ludCB0byB0aGUgc3RhcnQgbm9kZVxyXG4gICAgICAgIGN1cnJlbnQgPSBuZXcgUGF0aE5vZGUoZnJvbSwgMCwgZnJvbS5wb2ludC5kaXN0YW5jZV90byh0by5wb2ludCksIG51bGwpO1xyXG5cclxuICAgICAgICB3aGlsZSAoIWN1cnJlbnQubm9kZS5wb2ludC5lcXVhbHModG8ucG9pbnQpKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgc3Vycm91bmRpbmcgbm9kZXNcclxuICAgICAgICAgICAgc3Vycm91bmRpbmcgPSBzdHJ1Y3R1cmUuZ2V0X3N1cnJvdW5kaW5nKGN1cnJlbnQubm9kZS5wb2ludC54LCBjdXJyZW50Lm5vZGUucG9pbnQueSk7XHJcblxyXG4gICAgICAgICAgICAvLyBmaWx0ZXIgYWxyZWFkIGtub3duIG9uZXNcclxuICAgICAgICAgICAgc3Vycm91bmRpbmcgPSBzdXJyb3VuZGluZy5maWx0ZXIoZWxlbSA9PiBrbm93bi5pbmRleE9mKGVsZW0pID09PSAtMSk7XHJcbiAgICAgICAgICAgIC8vIGFkZCB0aGUgbmV3IG9uZXMgdG8gdGhlIGtub3duLWxpc3RcclxuICAgICAgICAgICAga25vd24gPSBrbm93bi5jb25jYXQoc3Vycm91bmRpbmcpO1xyXG4gICAgICAgICAgICAvLyBmaWx0ZXIgYmxvY2tlZCBvbmVzXHJcbiAgICAgICAgICAgIHN1cnJvdW5kaW5nID0gc3Vycm91bmRpbmcuZmlsdGVyKGVsZW0gPT4gZWxlbS5wYXNzYWJsZSAmJiAhZWxlbS5sb2NrZWQpO1xyXG5cclxuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGRpc3RhbmNlcyBhbmQgdHVybiB0aGVtIGludG8gUGF0aE5vZGVzXHJcbiAgICAgICAgICAgIC8vIGNvbmNhdCB3aXRoIHByZXZpb3VzIGNhbmRpZGF0ZXMgdG8gd2UnbGwgbW9yZSBlYXNpbHkgYmUgYWJsZSB0byBzd2l0Y2ggcGF0aHMgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMgPSBjYW5kaWRhdGVzLmNvbmNhdChcclxuICAgICAgICAgICAgICAgIHN1cnJvdW5kaW5nLm1hcChlbGVtID0+IG5ldyBQYXRoTm9kZShcclxuICAgICAgICAgICAgICAgICAgICBlbGVtLFxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuZCArIGN1cnJlbnQubm9kZS5wb2ludC5kaXN0YW5jZV90byhlbGVtLnBvaW50KSxcclxuICAgICAgICAgICAgICAgICAgICBlbGVtLnBvaW50LmRpc3RhbmNlX3RvKHRvLnBvaW50KSxcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50XHJcbiAgICAgICAgICAgICAgICApKVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgLy8gc29ydCBsaXN0IHNvIHRoZSBsb3dlc3QgaW5kZXggaGFzIHRoZSBiZXN0IGV4cGVjdGVkIHZhbHVlXHJcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMuc29ydCgoYSwgYikgPT4gKGEuZCArIGEuaCkgLSAoYi5kICsgYi5oKSk7XHJcblxyXG4gICAgICAgICAgICBjdXJyZW50ID0gY2FuZGlkYXRlcy5zaGlmdCgpO1xyXG5cclxuICAgICAgICAgICAgaWYoIWN1cnJlbnQpIHRocm93IG5ldyBQYXRoRXJyb3IoXCIjUGF0aDogQ2FuJ3QgZmluZCBhIHBhdGggdG8gdGhlIHRhcmdldCFcIik7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLy8gZ28gYmFjayB0byBjb2xsZWN0IHRoZSBjaG9zZW4gbm9kZXNcclxuICAgICAgICB3aGlsZShjdXJyZW50ICE9PSBudWxsKXtcclxuICAgICAgICAgICAgcGF0aC51bnNoaWZ0KGN1cnJlbnQubm9kZSk7XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLyBtYWtlIGl0IGl0ZXJhYmxlXHJcbiAgICAgICAgdGhpc1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgd2hpbGUgKHBhdGgubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgICAgICAgICB5aWVsZCBwYXRoLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIH1cclxuXHJcblxyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQYXRoO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmxldCBMaXN0MkQgPSByZXF1aXJlKFwiLi4vY29tbW9uL2xpc3QyZFwiKTtcclxubGV0IE1hcE5vZGUgPSByZXF1aXJlKFwiLi9tYXBub2RlXCIpO1xyXG5sZXQgUG9pbnQgPSByZXF1aXJlKFwiLi4vY29tbW9uL3BvaW50XCIpO1xyXG5sZXQgUmVzb3VyY2UgPSByZXF1aXJlKFwiLi4vcmVzb3VyY2UvcmVzb3VyY2VcIik7XHJcblxyXG4vKipcclxuICogSGVscGVyIGNsYXNzIGZvciBtYXAgc3RydWN0dXJlc1xyXG4gKi9cclxuY2xhc3MgU3RydWN0dXJlQnVpbGRlciB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgcmFuZG9tIHN0cnVjdHVyZVxyXG4gICAgICogQHBhcmFtIHByb3BlcnRpZXNcclxuICAgICAqIEByZXR1cm5zIHtMaXN0MkR8ZXhwb3J0c3xtb2R1bGUuZXhwb3J0c31cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZV9yYW5kb20ocHJvcGVydGllcykge1xyXG5cclxuICAgICAgICBsZXQgbDJkID0gU3RydWN0dXJlQnVpbGRlci5nZXRfYmFzaWNfc3RydWN0dXJlKHByb3BlcnRpZXMpO1xyXG5cclxuICAgICAgICBTdHJ1Y3R1cmVCdWlsZGVyLnJlZmluZShsMmQsIDIwKTtcclxuXHJcbiAgICAgICAgU3RydWN0dXJlQnVpbGRlci5ibG9ja19hcmVhcyhsMmQsIHByb3BlcnRpZXMpO1xyXG5cclxuICAgICAgICByZXR1cm4gbDJkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwcm9wZXJ0aWVzXHJcbiAgICAgKiBAcmV0dXJucyB7TGlzdDJEfGV4cG9ydHN8bW9kdWxlLmV4cG9ydHN9XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRfYmFzaWNfc3RydWN0dXJlKHByb3BlcnRpZXMpIHtcclxuXHJcbiAgICAgICAgbGV0IGwyZCA9IG5ldyBMaXN0MkQocHJvcGVydGllcy5zaXplX3gsIHByb3BlcnRpZXMuc2l6ZV95KTtcclxuXHJcbiAgICAgICAgLy8gZmlsbCBlYWNoIHBvaW50IHdpdGggYSByYW5kb20gaGVpZ2h0XHJcbiAgICAgICAgbDJkLmZvcl9lYWNoKGZ1bmN0aW9uIChlbGVtLCB4LCB5KSB7XHJcblxyXG4gICAgICAgICAgICBsZXQgaGVpZ2h0ID0gTWF0aC5yYW5kb20oKSAqIDEwIC0gNTtcclxuXHJcbiAgICAgICAgICAgIC8vIGNoYW5jZSBmb3IgaGlnaGxpZ2h0OlxyXG5cclxuICAgICAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgKiBwcm9wZXJ0aWVzLmhpZ2hsaWdodF9jaGFuY2UgPCAxKSBoZWlnaHQgKj0gMTA7XHJcblxyXG4gICAgICAgICAgICBsZXQgcG9pbnQgPSBuZXcgUG9pbnQoeCwgeSwgaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgIGxldCBub2RlID0gbmV3IE1hcE5vZGUocG9pbnQsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgbDJkLnNldCh4LCB5LCBub2RlKTtcclxuXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBsMmQ7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsMmRcclxuICAgICAqIEBwYXJhbSBjbGVhbl9ydW5zXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyByZWZpbmUobDJkLCBjbGVhbl9ydW5zKSB7XHJcblxyXG4gICAgICAgIGNsZWFuX3J1bnMgPSBjbGVhbl9ydW5zIHx8IDU7XHJcblxyXG4gICAgICAgIC8vIHNtb290aCB0aGUgaGVpZ2h0cyB0byBnZXQgYSBuYXR1cmFsIGxvb2tpbmcgbWFwXHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2xlYW5fcnVuczsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBoYXJtb25pemUgZWFjaCBub2RlIHdpdGggdGhlIHN1cnJvdW5kaW5nIG5vZGVzXHJcblxyXG4gICAgICAgICAgICBsMmQuZm9yX2VhY2goZnVuY3Rpb24gKGVsZW0sIHgsIHkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgc3Vycm91bmRpbmcgPSBsMmQuZ2V0X3N1cnJvdW5kaW5nKHgsIHkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBhdmcgPSBzdXJyb3VuZGluZy5yZWR1Y2UoKHZhbCwgZWxlbSkgPT4gdmFsICsgZWxlbS5wb2ludC56LCAwKSAvIHN1cnJvdW5kaW5nLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjaGFuZ2UgdGhlLnBvaW50LnogdG8gYmUgMjAlIGNsb3NlciB0byB0aGUgYXZlcmFnZVxyXG5cclxuICAgICAgICAgICAgICAgIGVsZW0ucG9pbnQueiA9ICggZWxlbS5wb2ludC56ICogNCArIGF2ZyApIC8gNVxyXG5cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGwyZDtcclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsMmRcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJsb2NrX2FyZWFzKGwyZCwgcHJvcGVydGllcykge1xyXG5cclxuICAgICAgICAvLyBibG9jayB3YXRlci9tb3VudGFpbiBmaWVsZHNcclxuXHJcbiAgICAgICAgbDJkLmZvcl9lYWNoKGZ1bmN0aW9uIChlbGVtKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoZWxlbS5wb2ludC56IDw9IHByb3BlcnRpZXMuZ3JvdW5kd2F0ZXIgfHxcclxuICAgICAgICAgICAgICAgIGVsZW0ucG9pbnQueiA+PSBwcm9wZXJ0aWVzLm1vdW50YWluKVxyXG5cclxuICAgICAgICAgICAgICAgIGVsZW0ucGFzc2FibGUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbDJkXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjYWxjdWxhdGVfcmVzb3VyY2VzKGwyZCwgYW1vdW50KSB7XHJcblxyXG4gICAgICAgIGFtb3VudCA9IGFtb3VudCB8fCAxO1xyXG5cclxuICAgICAgICBsZXQgcmVzb3VyY2VzID0gW107XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYW1vdW50OyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGdlbmVyYXRlIGEgc3BvdCBvZiByYW5kb20sIGZyZWUgcmVzb3VyY2VzXHJcblxyXG4gICAgICAgICAgICBsZXQgcmFuZG9tID0gbDJkLmdldF9yYW5kb20oKTtcclxuXHJcbiAgICAgICAgICAgIHdoaWxlICghcmFuZG9tLnBhc3NhYmxlKSByYW5kb20gPSBsMmQuZ2V0X3JhbmRvbSgpO1xyXG5cclxuICAgICAgICAgICAgbGV0IHNwb3QgPSBsMmQuZ2V0X3N1cnJvdW5kaW5nKHJhbmRvbS5wb2ludC54LCByYW5kb20ucG9pbnQueSk7XHJcblxyXG4gICAgICAgICAgICBzcG90ID0gc3BvdC5maWx0ZXIobm9kZSA9PiBub2RlLnBhc3NhYmxlKTtcclxuXHJcbiAgICAgICAgICAgIHNwb3QucHVzaChyYW5kb20pO1xyXG5cclxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBwb3NpdGlvbnMgb2YgdGhlIHJlc291cmNlXHJcblxyXG4gICAgICAgICAgICBsZXQgY29vcmRzID0gc3BvdC5tYXAobm9kZSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IG5vZGUucG9pbnQueCxcclxuICAgICAgICAgICAgICAgICAgICB5OiBub2RlLnBvaW50LnlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBsZXQgcmVzID0gbmV3IFJlc291cmNlKHtcclxuICAgICAgICAgICAgICAgIHJlczogUmVzb3VyY2UuUkVTLldPT0QsXHJcbiAgICAgICAgICAgICAgICBhbW91bnQ6IDEwLFxyXG4gICAgICAgICAgICAgICAgZmllbGRzOiBjb29yZHNcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXNvdXJjZXMucHVzaChyZXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc291cmNlcztcclxuXHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTdHJ1Y3R1cmVCdWlsZGVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmxldCBHYW1lT2JqZWN0ID0gcmVxdWlyZShcIi4uL2NvbW1vbi9nYW1lb2JqZWN0XCIpO1xyXG5sZXQgVEhSRUUgPSByZXF1aXJlKFwiLi4vLi4vbGliL3RocmVlXCIpO1xyXG5cclxuXHJcbmxldCBkZWZhdWx0X3Byb3BlcnRpZXMgPSB7XHJcbiAgICByZXM6IFwiV09PRFwiLFxyXG4gICAgYW1vdW50OiAxMCxcclxuICAgIGZpZWxkczogW1xyXG4gICAgICAgIHt4OiAyMCwgeTogNDB9LFxyXG4gICAgICAgIHt4OiAyMCwgeTogNDF9LFxyXG4gICAgICAgIHt4OiAyMSwgeTogNDB9LFxyXG4gICAgICAgIHt4OiAyMSwgeTogNDF9XHJcbiAgICBdXHJcbn07XHJcblxyXG5cclxuY2xhc3MgUmVzb3VyY2UgZXh0ZW5kcyBHYW1lT2JqZWN0IHtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0aWVzKSB7XHJcblxyXG4gICAgICAgIHN1cGVyKCk7XHJcblxyXG4gICAgICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IGRlZmF1bHRfcHJvcGVydGllcztcclxuXHJcbiAgICAgICAgdGhpcy50eXBlID0gUmVzb3VyY2UuUkVTW3Byb3BlcnRpZXMucmVzXTtcclxuXHJcbiAgICAgICAgdGhpcy5hbW91bnQgPSBwcm9wZXJ0aWVzLmFtb3VudDtcclxuXHJcbiAgICAgICAgdGhpcy5maWVsZHMgPSBwcm9wZXJ0aWVzLmZpZWxkcztcclxuXHJcbiAgICAgICAgdGhpcy5tZXNoID0gdGhpcy5nZW5lcmF0ZV9tZXNoKCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBnZXQgUkVTKCl7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIFwiV09PRFwiOiBcIldPT0RcIixcclxuICAgICAgICAgICAgXCJTVE9ORVwiOiBcIlNUT05FXCJcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBnZW5lcmF0ZV9tZXNoKCkge1xyXG5cclxuICAgICAgICAvLyBnZW5lcmF0ZSB0aGUgZ2VvbWV0cnlcclxuICAgICAgICBsZXQgZ2VvbWV0cnkgPSB0aGlzLmZpZWxkcy5tYXAoZmllbGQgPT4ge1xyXG5cclxuICAgICAgICAgICAgLy8gY3JlYXRlIGEgZ2VvbWV0cnkgb2JqZWN0IGZvciBlYWNoIGZpZWxkIHRoaXMgcmVzb3VyY2UgaXMgb25cclxuICAgICAgICAgICAgbGV0IGdlbyA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSgwLjI1LCAwLjI1LCA1KTtcclxuICAgICAgICAgICAgZ2VvLnZlcnRpY2VzLmZvckVhY2godmVydCA9PiB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0LnggKz0gZmllbGQueDtcclxuICAgICAgICAgICAgICAgIHZlcnQueSArPSBmaWVsZC55O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGdlbztcclxuXHJcbiAgICAgICAgICAgIC8vIG1lcmdlIGFsbCB0aG9zZSBnZW9tZXRyaWVzIGludG8gb25lXHJcbiAgICAgICAgfSkucmVkdWNlKChwcmV2LCBjdXJyKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChwcmV2KSBjdXJyLm1lcmdlKHByZXYpO1xyXG4gICAgICAgICAgICByZXR1cm4gY3VycjtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbGV0IG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwoe2NvbG9yOiAweGZmZmZmZn0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgd29ya19vbigpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIFwiV09PRFwiO1xyXG5cclxuICAgIH1cclxuXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVzb3VyY2U7XHJcbiIsInZhciBNdEV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIE10RXZlbnRIYW5kbGVyKCl7XHJcblxyXG4gICAgdGhpcy5fX2NoYW5uZWxzID0ge307XHJcblxyXG4gICAgLy9ETyBOT1QgQ0hBTkdFIERVUklORyBSVU5USU1FISEhXHJcbiAgICB0aGlzLl9fZXZlbnRsaXN0UHJvcGVydHlOYW1lID0gXCJfX210X2V2dHNfX1wiO1xyXG5cclxuXHJcbiAgICB0aGlzLl9fZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbihvYmosIHZhbCwgZnVuYyl7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgdmFsLCB7XHJcbiAgICAgICAgICB2YWx1ZTogZnVuYyxcclxuICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcclxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKlxyXG4gICAgICogVGhpcyBpbml0aWFsaXplcyB3aGlsZSBsb2FkaW5nIGFuZCBzZXRzIHRoZSBwcm9wZXJ0eS1uYW1lIG9mIHRoZSBldmVudGxpc3QgZm9yIGFsbCBvYmplY3RzXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX19ldmVudEZ1bmN0aW9ucyA9IHtcclxuICAgICAgICBcIm9uXCI6IChmdW5jdGlvbihwcm9wZXJ0eU5hbWUpe1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZXZlbnROYW1lLCBmdW5jKXtcclxuICAgICAgICAgICAgICAgIHZhciBldmVudE1hcCA9IHRoaXNbcHJvcGVydHlOYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmKCFldmVudE1hcCkgdGhyb3cgVHlwZUVycm9yKFwiVGhpcyBpcyBub3QgYW4gbXQtRXZlbnRlZCBPYmplY3QhXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYoIShmdW5jIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB0aHJvdyBUeXBlRXJyb3IoXCJOZWVkIHRvIHByb3ZpZGUgRnVuY3Rpb24gT2JqZWN0IHRvIFxcXCJPTlxcXCJcIik7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGlzIHRoZSBmaXJzdCBldmVudCB3aXRoIHRoaXMgbmFtZSwgY3JlYXRlIG5ldyBhcnJheSBmb3IgdGhpcyBldmVudCB0eXBlXHJcbiAgICAgICAgICAgICAgICBpZighZXZlbnRNYXBbZXZlbnROYW1lXSkgZXZlbnRNYXBbZXZlbnROYW1lXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlkZW50aWZpZXIgPSBldmVudE1hcFtldmVudE5hbWVdLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGV2ZW50TWFwW2V2ZW50TmFtZV0ucHVzaChmdW5jKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpZGVudGlmaWVyO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pKHRoaXMuX19ldmVudGxpc3RQcm9wZXJ0eU5hbWUpLFxyXG5cclxuICAgICAgICBcImVtaXRcIjogKGZ1bmN0aW9uKHByb3BlcnR5TmFtZSl7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihldmVudE5hbWUsIGluZm9PYmope1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50TWFwID0gdGhpc1twcm9wZXJ0eU5hbWVdO1xyXG4gICAgICAgICAgICAgICAgaWYoIWV2ZW50TWFwIHx8ICEoZXZlbnRNYXAgaW5zdGFuY2VvZiBPYmplY3QpKSB0aHJvdyBUeXBlRXJyb3IoXCJUaGlzIGlzIG5vdCBhbiBtdC1FdmVudGVkIE9iamVjdCFcIik7XHJcbiAgICAgICAgICAgICAgICAvLyBhYm9ydCBpZiB0aGVyZSBhcmUgbm8gc3Vic2NyaXB0aW9ucyBvbiB0aGlzIGV2ZW50XHJcbiAgICAgICAgICAgICAgICBpZighZXZlbnRNYXBbZXZlbnROYW1lXSkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgLy8gY2FsbCBhbGwgc3Vic2NyaXB0aW9uc1xyXG4gICAgICAgICAgICAgICAgZXZlbnRNYXBbZXZlbnROYW1lXS5mb3JFYWNoKGZ1bmN0aW9uKGZ1bmMpe1xyXG4gICAgICAgICAgICAgICAgICAgICEhZnVuYyAmJiBmdW5jKGluZm9PYmopO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSkodGhpcy5fX2V2ZW50bGlzdFByb3BlcnR5TmFtZSksXHJcblxyXG4gICAgICAgIFwiaWdub3JlXCI6IChmdW5jdGlvbihwcm9wZXJ0eU5hbWUpe1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZXZlbnROYW1lLCBpZGVudGlmaWVyKXtcclxuICAgICAgICAgICAgICAgIHZhciBldmVudE1hcCA9IHRoaXNbcHJvcGVydHlOYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmKCFldmVudE1hcCApIHRocm93IFR5cGVFcnJvcihcIlRoaXMgaXMgbm90IGFuIG10LUV2ZW50ZWQgT2JqZWN0IVwiKTtcclxuICAgICAgICAgICAgICAgIGlmKCFldmVudE1hcFtldmVudE5hbWVdIHx8ICFldmVudE1hcFtldmVudE5hbWVdW2lkZW50aWZpZXJdKSB0aHJvdyBSYW5nZUVycm9yKFwiRG9uJ3QgaGF2ZSB0aGlzIGV2ZW50IVwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRGdW5jID0gZXZlbnRNYXBbZXZlbnROYW1lXVtpZGVudGlmaWVyXTtcclxuICAgICAgICAgICAgICAgIGV2ZW50TWFwW2V2ZW50TmFtZV1baWRlbnRpZmllcl0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnRGdW5jO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pKHRoaXMuX19ldmVudGxpc3RQcm9wZXJ0eU5hbWUpXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMubWFrZUV2ZW50ZWQgPSBmdW5jdGlvbihvYmope1xyXG4gICAgICAgIHRoaXMuX19kZWZpbmVQcm9wZXJ0eShvYmosIHRoaXMuX19ldmVudGxpc3RQcm9wZXJ0eU5hbWUsIHt9KTtcclxuICAgICAgICB0aGlzLl9fZGVmaW5lUHJvcGVydHkob2JqLCBcIm9uXCIsIHRoaXMuX19ldmVudEZ1bmN0aW9ucy5vbik7XHJcbiAgICAgICAgdGhpcy5fX2RlZmluZVByb3BlcnR5KG9iaiwgXCJlbWl0XCIsIHRoaXMuX19ldmVudEZ1bmN0aW9ucy5lbWl0KTtcclxuICAgICAgICB0aGlzLl9fZGVmaW5lUHJvcGVydHkob2JqLCBcImlnbm9yZVwiLCB0aGlzLl9fZXZlbnRGdW5jdGlvbnMuaWdub3JlKTtcclxuICAgIH07XHJcblxyXG59O1xyXG5cclxuaWYodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgIT09IFwidW5kZWZpbmVkXCIpIG1vZHVsZS5leHBvcnRzID0gbmV3IE10RXZlbnRIYW5kbGVyKCk7XHJcbiIsInZhciBEZWZlcnJlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKCk7XHJcbiAgICB0aGlzLnN0YXRlID0gRGVmZXJyZWQuUEVORElORztcclxufTtcclxuXHJcbkRlZmVycmVkLkZVTEZJTExFRCA9IDA7XHJcbkRlZmVycmVkLlJFSkVDVEVEID0gMTtcclxuRGVmZXJyZWQuUEVORElORyA9IDI7XHJcblxyXG5EZWZlcnJlZC5kZWJ1ZyA9IGZhbHNlO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgaXMgYSB1dGlsaXR5LWZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHNpbmdsZSBwcm9taXNlIGZvciBhbiBhcnJheSBvZiBwcm9taXNlcy5cclxuICogSXQgdXBkYXRlcyB0aGUgcHJvbWlzZSBmb3IgZXZlcnkgcmVzb2x2ZWQgZGVmZXJyZWQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIG9yaWdpbmFsIGVycm9yLlxyXG4gKiBJdCByZXNvbHZlcyBvbmNlIGFsbCBwcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQuXHJcbiAqL1xyXG5EZWZlcnJlZC53aGVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIF9fZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuXHJcbiAgICAvLyBleGNsdWRlIG5vbi1wcm9taXNlIHZhbHVlcyBhbmQgY29udmVydCBhcmd1bWVudHMgdG8gYXJyYXkgaW4gb25lIGdvXHJcbiAgICB2YXIgcHJvbWlzZXMgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoYXJndW1lbnRzLCBmdW5jdGlvbiAoYXJnKSB7XHJcbiAgICAgICAgcmV0dXJuIChhcmcgaW5zdGFuY2VvZiBQcm9taXNlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHZhciB0b0dvID0gcHJvbWlzZXMubGVuZ3RoO1xyXG5cclxuICAgIGlmICh0b0dvIDwgMSkgdGhyb3cgUmFuZ2VFcnJvcihcIk5vIFByb21pc2VzIGhhdmUgYmVlbiBzdWJtaXR0ZWQgdG8gRGVmZXJyZWQud2hlbiwgbmVlZCBhdCBsZWFzdCBvbmUuXCIpO1xyXG5cclxuICAgIC8vIHNhdmUgdGhlIHNvbHZlZCB2YWx1ZXMgZm9yIHRoZSBwcm9taXNlcyBpbiB0aGUgc2FtZSBvcmRlclxyXG4gICAgdmFyIHNvbHZlVmFsdWVzID0gW107XHJcbiAgICBzb2x2ZVZhbHVlcy5sZW5ndGggPSB0b0dvO1xyXG5cclxuICAgIHByb21pc2VzLmZvckVhY2goZnVuY3Rpb24gKHByb21pc2UsIGluZGV4KSB7XHJcblxyXG4gICAgICAgIC8vIGFmdGVyIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZFxyXG4gICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcclxuXHJcbiAgICAgICAgICAgIHNvbHZlVmFsdWVzW2luZGV4XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICBfX2RlZmVycmVkLnVwZGF0ZShzb2x2ZVZhbHVlcyk7XHJcblxyXG4gICAgICAgICAgICAvLyBkZWNyZW1lbnQgY291bnRlciBhbmQgcmVzb2x2ZSBpZiB3ZSdyZSBkb25lXHJcbiAgICAgICAgICAgIGlmICgtLXRvR28gPT09IDApIF9fZGVmZXJyZWQucmVzb2x2ZShzb2x2ZVZhbHVlcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gX19kZWZlcnJlZC5wcm9taXNlO1xyXG59O1xyXG5cclxuRGVmZXJyZWQucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUsIHN0cmljdCkge1xyXG5cclxuICAgIC8vIElmIHRoZSBkZWZlcnJlZCBpcyBhbHJlYWR5IGNsb3NlZCwgd2UgY2hlY2sgZm9yIHRoZSBkZWJ1Zy1mbGFnIGFuZCB0aGUgc3RyaWN0LXBhcmFtZXRlclxyXG4gICAgLy8gYW5kIGdpdmUgZmVlZGJhY2sgdG8gdGhlIGNhbGxlciBhY2NvcmRpbmdseVxyXG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IERlZmVycmVkLlBFTkRJTkcpIHtcclxuICAgICAgICBEZWZlcnJlZC5kZWJ1ZyAmJiBjb25zb2xlLndhcm4oXCJQcm9taXNlIGFscmVhZHlcIiwgdGhpcy5zdGF0ZSwgXCIsIGNhbid0IHJlc29sdmUgYWdhaW5cIik7XHJcbiAgICAgICAgaWYgKHN0cmljdCkgdGhyb3cgbmV3IEVycm9yKFwiUHJvbWlzZSBhbHJlYWR5XCIsIHRoaXMuc3RhdGUpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiBldmVyeXRoaW5nIGlzIG5vcm1hbCAod2hhdCBpcyBub3JtYWwgYW55d2F5cz8pLCB3ZSBtYXJrIHRoZSBkZWZlcnJlZCBhbmQgaXRzIHByb21pc2UgYXMgcmVzb2x2ZWRcclxuICAgIHRoaXMuc3RhdGUgPSBEZWZlcnJlZC5GVUxGSUxMRUQ7XHJcbiAgICB0aGlzLnByb21pc2Uuc3RhdGUgPSBEZWZlcnJlZC5GVUxGSUxMRUQ7XHJcbiAgICB0aGlzLnByb21pc2UuZW5kVmFsdWUgPSB2YWx1ZTtcclxuXHJcbiAgICAvLyBsYXN0IHRoaW5nIHRvIGRvIGlzIGV4ZWN1dGUgYWxsIGNhY2hlZCBcInRoZW5cIi1jYWxscyB3aXRoIHRoZSBnaXZlbiB2YWx1ZVxyXG4gICAgLy8gTk9URTogY2hhaW5pbmcgb2YgcHJvbWlzZXMgZ2V0cyBoYW5kbGVkIGJ5IHRoZSBwcm9taXNlcyBcInRoZW5cIiBmdW5jdGlvblxyXG4gICAgdGhpcy5wcm9taXNlLl9yZXNvbHZlRnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGZ1bmMpIHtcclxuICAgICAgICBmdW5jKHZhbHVlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIHRoZSByZWFzb24gZm9yIHJldHVybmluZyBhIGJvb2xlYW4gZGVwZW5kaW5nIG9uIHdoZXRoZXIgcmVzb2x2aW5nIHdhcyBzdWNjZXNzZnVsIGlzXHJcbiAgICAvLyB0aGF0IHlvdSBjYW4gc3RyaXAgb3V0IHRoZSBcInN0cmljdCA9IHRydWVcIiBwYXJhbWV0ZXIgYW5kIGltcHJvdmUgcGVyZm9ybWFuY2VcclxuICAgIC8vIGZvciBwcm9kdWN0aW9uIGNvZGUgYnkganVzdCBjaGVja2luZyBmb3IgdGhlIHJldHVybiB2YWx1ZSBvZiBcInJlc29sdmVcIlxyXG4gICAgcmV0dXJuIHRydWU7XHJcblxyXG59O1xyXG5cclxuRGVmZXJyZWQucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uIChlcnJvclZhbHVlLCBzdHJpY3QpIHtcclxuXHJcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gRGVmZXJyZWQuUEVORElORykge1xyXG4gICAgICAgIERlZmVycmVkLmRlYnVnICYmIGNvbnNvbGUud2FybihcIlByb21pc2UgYWxyZWFkeVwiLCB0aGlzLnN0YXRlLCBcIiwgY2FuJ3QgcmVzb2x2ZSBhZ2FpblwiKTtcclxuICAgICAgICBpZiAoc3RyaWN0KSB0aHJvdyBuZXcgRXJyb3IoXCJQcm9taXNlIGFscmVhZHlcIiwgdGhpcy5zdGF0ZSk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc3RhdGUgPSBEZWZlcnJlZC5SRUpFQ1RFRDtcclxuICAgIHRoaXMucHJvbWlzZS5zdGF0ZSA9IERlZmVycmVkLlJFSkVDVEVEO1xyXG4gICAgdGhpcy5wcm9taXNlLmVuZFZhbHVlID0gZXJyb3JWYWx1ZTtcclxuICAgIHRoaXMucHJvbWlzZS5fcmVqZWN0RnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGZ1bmMpIHtcclxuICAgICAgICBmdW5jKGVycm9yVmFsdWUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG5EZWZlcnJlZC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHZhbHVlLCBzdHJpY3QpIHtcclxuXHJcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gRGVmZXJyZWQuUEVORElORykge1xyXG4gICAgICAgIERlZmVycmVkLmRlYnVnICYmIGNvbnNvbGUud2FybihcIlByb21pc2UgYWxyZWFkeVwiLCB0aGlzLnN0YXRlLCBcIiwgY2FuJ3QgcmVzb2x2ZSBhZ2FpblwiKTtcclxuICAgICAgICBpZiAoc3RyaWN0KSB0aHJvdyBuZXcgRXJyb3IoXCJQcm9taXNlIGFscmVhZHlcIiwgdGhpcy5zdGF0ZSk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucHJvbWlzZS5fdXBkYXRlRnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGZ1bmMpIHtcclxuICAgICAgICBmdW5jKHZhbHVlKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG5cclxudmFyIFByb21pc2UgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdGhpcy5zdGF0ZSA9IERlZmVycmVkLlBFTkRJTkc7XHJcblxyXG4gICAgdGhpcy5lbmRWYWx1ZSA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5fcmVzb2x2ZUZ1bmN0aW9ucyA9IFtdO1xyXG5cclxuICAgIHRoaXMuX3JlamVjdEZ1bmN0aW9ucyA9IFtdO1xyXG5cclxuICAgIHRoaXMuX3VwZGF0ZUZ1bmN0aW9ucyA9IFtdO1xyXG5cclxufTtcclxuXHJcblByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAob25SZXNvbHZlLCBvbkVycm9yLCBvblVwZGF0ZSkge1xyXG5cclxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgcHJvbWlzZSBhdCB0aGUgZW5kIG9mIHRoZSBcInRoZW5cIi1jYWxsIHRvIGFsbG93IGNoYWluaW5nXHJcbiAgICB2YXIgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuXHJcbiAgICBpZiAob25SZXNvbHZlKSB7XHJcbiAgICAgICAgLy9pZiB0aGUgZGVmZXJyZWQgaXMgYWxyZWFkeSByZXNvbHZlZCwgdHJpZ2dlciB0aGUgZnVuY3Rpb24gcmlnaHQgbm93XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IERlZmVycmVkLkZVTEZJTExFRCkge1xyXG4gICAgICAgICAgICBEZWZlcnJlZC5kZWJ1ZyAmJiBjb25zb2xlLmluZm8oXCJQcm9taXNlIGFscmVhZHkgcmVzb2x2ZWQsIGV4ZWN1dGluZyBcXFwidGhlblxcXCIgaW1tZWRpYXRlbHlcIilcclxuICAgICAgICAgICAgLy8gZXhlY3V0ZSB0aGUgZnVuY3Rpb24gYW5kIHVzZSBpdHMgcmV0dXJuIHZhbHVlIGFzIGRlcml2ZWQgdmFsdWUuLi5cclxuICAgICAgICAgICAgdmFyIGRlcml2ZWRWYWx1ZSA9IG9uUmVzb2x2ZSh0aGlzLmVuZFZhbHVlKTtcclxuICAgICAgICAgICAgLy8gLi4gZm9yIHRoZSBwcm9taXNlIG9mIHRoZSBjdXJyZW50IFwidGhlblwiLWNhbGwgdG8gYWxsb3cgcHJvbWlzZS1jaGFpbmluZ1xyXG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGRlcml2ZWRWYWx1ZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gaWYgdGhlIGRlZmVycmVkIGlzIHN0aWxsIHBlbmRpbmcsIHB1dCB0aGUgcmVzb2x2ZSBmdW5jdGlvbiBpbiBxdWV1ZVxyXG4gICAgICAgICAgICAvLyBzbyBpdCBjYW4gYmUgZXhlY3V0ZWQgbGF0ZXIgYnkgdGhlIHBhcmVudGluZyBkZWZlcnJlZFxyXG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlRnVuY3Rpb25zLnB1c2goZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhcyBhYm92ZSwgc2F2ZSB0aGUgcmV0dXJuLXZhbHVlIG9mIHRoZSBmdW5jdGlvbiBjYWxsIGZvciB0aGVcclxuICAgICAgICAgICAgICAgIC8vIGRlZmVycmVkL3Byb21pc2Ugb2YgdGhlIGN1cnJlbnQgXCJ0aGVuXCItY2FsbFxyXG4gICAgICAgICAgICAgICAgdmFyIGRlcml2ZWRWYWx1ZSA9IG9uUmVzb2x2ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGRlcml2ZWRWYWx1ZSk7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFNhbWUgYXMgYWJvdmUgZm9yIG9uUmVzb2x2ZSwgc28gbm8gY29tbWVudHMgaGVyZVxyXG4gICAgaWYgKG9uRXJyb3IpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gRGVmZXJyZWQuUkVKRUNURUQpIHtcclxuICAgICAgICAgICAgRGVmZXJyZWQuZGVidWcgJiYgY29uc29sZS5pbmZvKFwiUHJvbWlzZSBhbHJlYWR5IHJlamVjdGVkLCBleGVjdXRpbmcgXFxcInRoZW5cXFwiIGltbWVkaWF0ZWx5XCIpXHJcbiAgICAgICAgICAgIHZhciBkZXJpdmVkRXJyb3JWYWx1ZSA9IG9uRXJyb3IodGhpcy5lbmRWYWx1ZSk7XHJcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChkZXJpdmVkRXJyb3JWYWx1ZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVqZWN0RnVuY3Rpb25zLnB1c2goZnVuY3Rpb24gKGVycm9yVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkZXJpdmVkRXJyb3JWYWx1ZSA9IG9uRXJyb3IoZXJyb3JWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZGVyaXZlZEVycm9yVmFsdWUpO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAob25VcGRhdGUpIHtcclxuICAgICAgICAvLyB3aGVuIHVwZGF0aW5nIHdlIERPTidUIHBhc3MgdmFsdWVzIHRvIHRoZSBkZXJpdmVkIHByb21pc2UgYmVjYXVzZVxyXG4gICAgICAgIC8vIHdlIGNhbid0IGRvIHRoYXQgaW4gYSB3YXkgdGhhdCBtYWtlcyBzZW5zZSBmb3IgdGhlIHVzZXJcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gRGVmZXJyZWQuUEVORElORykge1xyXG4gICAgICAgICAgICBEZWZlcnJlZC5kZWJ1ZyAmJiBjb25zb2xlLndhcm4oXCJUcnlpbmcgdG8gYWRkIG9uVXBkYXRlIGZ1bmN0aW9uIHRvIGFscmVhZHkgZnVsZmlsbGVkIHByb21pc2VcIik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRnVuY3Rpb25zLnB1c2goZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC51cGRhdGUob25VcGRhdGUodmFsdWUpKTtcclxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcblxyXG59O1xyXG5cclxuRGVmZXJyZWQuUHJvbWlzZSA9IFByb21pc2U7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERlZmVycmVkO1xyXG4iLCIvLyBGaWxlOnNyYy9UaHJlZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxudmFyIFRIUkVFID0geyBSRVZJU0lPTjogJzczJyB9O1xyXG5cclxuLy9cclxuXHJcbmlmICggdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xyXG5cclxuICAgIGRlZmluZSggJ3RocmVlJywgVEhSRUUgKTtcclxuXHJcbn0gZWxzZSBpZiAoICd1bmRlZmluZWQnICE9PSB0eXBlb2YgZXhwb3J0cyAmJiAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG1vZHVsZSApIHtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRIUkVFO1xyXG5cclxufVxyXG5cclxuXHJcbi8vIHBvbHlmaWxsc1xyXG5cclxuaWYgKCBzZWxmLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gdW5kZWZpbmVkIHx8IHNlbGYuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAvLyBNaXNzaW5nIGluIEFuZHJvaWQgc3RvY2sgYnJvd3Nlci5cclxuXHJcbiAgICAoIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIGxhc3RUaW1lID0gMDtcclxuICAgICAgICB2YXIgdmVuZG9ycyA9IFsgJ21zJywgJ21veicsICd3ZWJraXQnLCAnbycgXTtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIHggPSAwOyB4IDwgdmVuZG9ycy5sZW5ndGggJiYgISBzZWxmLnJlcXVlc3RBbmltYXRpb25GcmFtZTsgKysgeCApIHtcclxuXHJcbiAgICAgICAgICAgIHNlbGYucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gc2VsZlsgdmVuZG9yc1sgeCBdICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZScgXTtcclxuICAgICAgICAgICAgc2VsZi5jYW5jZWxBbmltYXRpb25GcmFtZSA9IHNlbGZbIHZlbmRvcnNbIHggXSArICdDYW5jZWxBbmltYXRpb25GcmFtZScgXSB8fCBzZWxmWyB2ZW5kb3JzWyB4IF0gKyAnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJyBdO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggc2VsZi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09IHVuZGVmaW5lZCAmJiBzZWxmLnNldFRpbWVvdXQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIHNlbGYucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgY3VyclRpbWUgPSBEYXRlLm5vdygpLCB0aW1lVG9DYWxsID0gTWF0aC5tYXgoIDAsIDE2IC0gKCBjdXJyVGltZSAtIGxhc3RUaW1lICkgKTtcclxuICAgICAgICAgICAgICAgIHZhciBpZCA9IHNlbGYuc2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayggY3VyclRpbWUgKyB0aW1lVG9DYWxsICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSwgdGltZVRvQ2FsbCApO1xyXG4gICAgICAgICAgICAgICAgbGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaWQ7XHJcblxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggc2VsZi5jYW5jZWxBbmltYXRpb25GcmFtZSA9PT0gdW5kZWZpbmVkICYmIHNlbGYuY2xlYXJUaW1lb3V0ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBzZWxmLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKCBpZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBzZWxmLmNsZWFyVGltZW91dCggaWQgKTtcclxuXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9ICkoKTtcclxuXHJcbn1cclxuXHJcbi8vXHJcblxyXG5pZiAoIHNlbGYucGVyZm9ybWFuY2UgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICBzZWxmLnBlcmZvcm1hbmNlID0ge307XHJcblxyXG59XHJcblxyXG5pZiAoIHNlbGYucGVyZm9ybWFuY2Uubm93ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgKCBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBzdGFydCA9IERhdGUubm93KCk7XHJcblxyXG4gICAgICAgIHNlbGYucGVyZm9ybWFuY2Uubm93ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIERhdGUubm93KCkgLSBzdGFydDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0gKSgpO1xyXG5cclxufVxyXG5cclxuLy9cclxuXHJcbmlmICggTnVtYmVyLkVQU0lMT04gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICBOdW1iZXIuRVBTSUxPTiA9IE1hdGgucG93KCAyLCAtNTIgKTtcclxuXHJcbn1cclxuXHJcbi8vXHJcblxyXG5pZiAoIE1hdGguc2lnbiA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvc2lnblxyXG5cclxuICAgIE1hdGguc2lnbiA9IGZ1bmN0aW9uICggeCApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuICggeCA8IDAgKSA/IC0gMSA6ICggeCA+IDAgKSA/IDEgOiArIHg7XHJcblxyXG4gICAgfTtcclxuXHJcbn1cclxuXHJcbmlmICggRnVuY3Rpb24ucHJvdG90eXBlLm5hbWUgPT09IHVuZGVmaW5lZCAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAvLyBNaXNzaW5nIGluIElFOS0xMS5cclxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL25hbWVcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIEZ1bmN0aW9uLnByb3RvdHlwZSwgJ25hbWUnLCB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKS5tYXRjaCggL15cXHMqZnVuY3Rpb25cXHMqKFxcUyopXFxzKlxcKC8gKVsgMSBdO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSApO1xyXG5cclxufVxyXG5cclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01vdXNlRXZlbnQuYnV0dG9uXHJcblxyXG5USFJFRS5NT1VTRSA9IHsgTEVGVDogMCwgTUlERExFOiAxLCBSSUdIVDogMiB9O1xyXG5cclxuLy8gR0wgU1RBVEUgQ09OU1RBTlRTXHJcblxyXG5USFJFRS5DdWxsRmFjZU5vbmUgPSAwO1xyXG5USFJFRS5DdWxsRmFjZUJhY2sgPSAxO1xyXG5USFJFRS5DdWxsRmFjZUZyb250ID0gMjtcclxuVEhSRUUuQ3VsbEZhY2VGcm9udEJhY2sgPSAzO1xyXG5cclxuVEhSRUUuRnJvbnRGYWNlRGlyZWN0aW9uQ1cgPSAwO1xyXG5USFJFRS5Gcm9udEZhY2VEaXJlY3Rpb25DQ1cgPSAxO1xyXG5cclxuLy8gU0hBRE9XSU5HIFRZUEVTXHJcblxyXG5USFJFRS5CYXNpY1NoYWRvd01hcCA9IDA7XHJcblRIUkVFLlBDRlNoYWRvd01hcCA9IDE7XHJcblRIUkVFLlBDRlNvZnRTaGFkb3dNYXAgPSAyO1xyXG5cclxuLy8gTUFURVJJQUwgQ09OU1RBTlRTXHJcblxyXG4vLyBzaWRlXHJcblxyXG5USFJFRS5Gcm9udFNpZGUgPSAwO1xyXG5USFJFRS5CYWNrU2lkZSA9IDE7XHJcblRIUkVFLkRvdWJsZVNpZGUgPSAyO1xyXG5cclxuLy8gc2hhZGluZ1xyXG5cclxuVEhSRUUuRmxhdFNoYWRpbmcgPSAxO1xyXG5USFJFRS5TbW9vdGhTaGFkaW5nID0gMjtcclxuXHJcbi8vIGNvbG9yc1xyXG5cclxuVEhSRUUuTm9Db2xvcnMgPSAwO1xyXG5USFJFRS5GYWNlQ29sb3JzID0gMTtcclxuVEhSRUUuVmVydGV4Q29sb3JzID0gMjtcclxuXHJcbi8vIGJsZW5kaW5nIG1vZGVzXHJcblxyXG5USFJFRS5Ob0JsZW5kaW5nID0gMDtcclxuVEhSRUUuTm9ybWFsQmxlbmRpbmcgPSAxO1xyXG5USFJFRS5BZGRpdGl2ZUJsZW5kaW5nID0gMjtcclxuVEhSRUUuU3VidHJhY3RpdmVCbGVuZGluZyA9IDM7XHJcblRIUkVFLk11bHRpcGx5QmxlbmRpbmcgPSA0O1xyXG5USFJFRS5DdXN0b21CbGVuZGluZyA9IDU7XHJcblxyXG4vLyBjdXN0b20gYmxlbmRpbmcgZXF1YXRpb25zXHJcbi8vIChudW1iZXJzIHN0YXJ0IGZyb20gMTAwIG5vdCB0byBjbGFzaCB3aXRoIG90aGVyXHJcbi8vIG1hcHBpbmdzIHRvIE9wZW5HTCBjb25zdGFudHMgZGVmaW5lZCBpbiBUZXh0dXJlLmpzKVxyXG5cclxuVEhSRUUuQWRkRXF1YXRpb24gPSAxMDA7XHJcblRIUkVFLlN1YnRyYWN0RXF1YXRpb24gPSAxMDE7XHJcblRIUkVFLlJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uID0gMTAyO1xyXG5USFJFRS5NaW5FcXVhdGlvbiA9IDEwMztcclxuVEhSRUUuTWF4RXF1YXRpb24gPSAxMDQ7XHJcblxyXG4vLyBjdXN0b20gYmxlbmRpbmcgZGVzdGluYXRpb24gZmFjdG9yc1xyXG5cclxuVEhSRUUuWmVyb0ZhY3RvciA9IDIwMDtcclxuVEhSRUUuT25lRmFjdG9yID0gMjAxO1xyXG5USFJFRS5TcmNDb2xvckZhY3RvciA9IDIwMjtcclxuVEhSRUUuT25lTWludXNTcmNDb2xvckZhY3RvciA9IDIwMztcclxuVEhSRUUuU3JjQWxwaGFGYWN0b3IgPSAyMDQ7XHJcblRIUkVFLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgPSAyMDU7XHJcblRIUkVFLkRzdEFscGhhRmFjdG9yID0gMjA2O1xyXG5USFJFRS5PbmVNaW51c0RzdEFscGhhRmFjdG9yID0gMjA3O1xyXG5cclxuLy8gY3VzdG9tIGJsZW5kaW5nIHNvdXJjZSBmYWN0b3JzXHJcblxyXG4vL1RIUkVFLlplcm9GYWN0b3IgPSAyMDA7XHJcbi8vVEhSRUUuT25lRmFjdG9yID0gMjAxO1xyXG4vL1RIUkVFLlNyY0FscGhhRmFjdG9yID0gMjA0O1xyXG4vL1RIUkVFLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgPSAyMDU7XHJcbi8vVEhSRUUuRHN0QWxwaGFGYWN0b3IgPSAyMDY7XHJcbi8vVEhSRUUuT25lTWludXNEc3RBbHBoYUZhY3RvciA9IDIwNztcclxuVEhSRUUuRHN0Q29sb3JGYWN0b3IgPSAyMDg7XHJcblRIUkVFLk9uZU1pbnVzRHN0Q29sb3JGYWN0b3IgPSAyMDk7XHJcblRIUkVFLlNyY0FscGhhU2F0dXJhdGVGYWN0b3IgPSAyMTA7XHJcblxyXG4vLyBkZXB0aCBtb2Rlc1xyXG5cclxuVEhSRUUuTmV2ZXJEZXB0aCA9IDA7XHJcblRIUkVFLkFsd2F5c0RlcHRoID0gMTtcclxuVEhSRUUuTGVzc0RlcHRoID0gMjtcclxuVEhSRUUuTGVzc0VxdWFsRGVwdGggPSAzO1xyXG5USFJFRS5FcXVhbERlcHRoID0gNDtcclxuVEhSRUUuR3JlYXRlckVxdWFsRGVwdGggPSA1O1xyXG5USFJFRS5HcmVhdGVyRGVwdGggPSA2O1xyXG5USFJFRS5Ob3RFcXVhbERlcHRoID0gNztcclxuXHJcblxyXG4vLyBURVhUVVJFIENPTlNUQU5UU1xyXG5cclxuVEhSRUUuTXVsdGlwbHlPcGVyYXRpb24gPSAwO1xyXG5USFJFRS5NaXhPcGVyYXRpb24gPSAxO1xyXG5USFJFRS5BZGRPcGVyYXRpb24gPSAyO1xyXG5cclxuLy8gTWFwcGluZyBtb2Rlc1xyXG5cclxuVEhSRUUuVVZNYXBwaW5nID0gMzAwO1xyXG5cclxuVEhSRUUuQ3ViZVJlZmxlY3Rpb25NYXBwaW5nID0gMzAxO1xyXG5USFJFRS5DdWJlUmVmcmFjdGlvbk1hcHBpbmcgPSAzMDI7XHJcblxyXG5USFJFRS5FcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyA9IDMwMztcclxuVEhSRUUuRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcgPSAzMDQ7XHJcblxyXG5USFJFRS5TcGhlcmljYWxSZWZsZWN0aW9uTWFwcGluZyA9IDMwNTtcclxuXHJcbi8vIFdyYXBwaW5nIG1vZGVzXHJcblxyXG5USFJFRS5SZXBlYXRXcmFwcGluZyA9IDEwMDA7XHJcblRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcgPSAxMDAxO1xyXG5USFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nID0gMTAwMjtcclxuXHJcbi8vIEZpbHRlcnNcclxuXHJcblRIUkVFLk5lYXJlc3RGaWx0ZXIgPSAxMDAzO1xyXG5USFJFRS5OZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciA9IDEwMDQ7XHJcblRIUkVFLk5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIgPSAxMDA1O1xyXG5USFJFRS5MaW5lYXJGaWx0ZXIgPSAxMDA2O1xyXG5USFJFRS5MaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyID0gMTAwNztcclxuVEhSRUUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyID0gMTAwODtcclxuXHJcbi8vIERhdGEgdHlwZXNcclxuXHJcblRIUkVFLlVuc2lnbmVkQnl0ZVR5cGUgPSAxMDA5O1xyXG5USFJFRS5CeXRlVHlwZSA9IDEwMTA7XHJcblRIUkVFLlNob3J0VHlwZSA9IDEwMTE7XHJcblRIUkVFLlVuc2lnbmVkU2hvcnRUeXBlID0gMTAxMjtcclxuVEhSRUUuSW50VHlwZSA9IDEwMTM7XHJcblRIUkVFLlVuc2lnbmVkSW50VHlwZSA9IDEwMTQ7XHJcblRIUkVFLkZsb2F0VHlwZSA9IDEwMTU7XHJcblRIUkVFLkhhbGZGbG9hdFR5cGUgPSAxMDI1O1xyXG5cclxuLy8gUGl4ZWwgdHlwZXNcclxuXHJcbi8vVEhSRUUuVW5zaWduZWRCeXRlVHlwZSA9IDEwMDk7XHJcblRIUkVFLlVuc2lnbmVkU2hvcnQ0NDQ0VHlwZSA9IDEwMTY7XHJcblRIUkVFLlVuc2lnbmVkU2hvcnQ1NTUxVHlwZSA9IDEwMTc7XHJcblRIUkVFLlVuc2lnbmVkU2hvcnQ1NjVUeXBlID0gMTAxODtcclxuXHJcbi8vIFBpeGVsIGZvcm1hdHNcclxuXHJcblRIUkVFLkFscGhhRm9ybWF0ID0gMTAxOTtcclxuVEhSRUUuUkdCRm9ybWF0ID0gMTAyMDtcclxuVEhSRUUuUkdCQUZvcm1hdCA9IDEwMjE7XHJcblRIUkVFLkx1bWluYW5jZUZvcm1hdCA9IDEwMjI7XHJcblRIUkVFLkx1bWluYW5jZUFscGhhRm9ybWF0ID0gMTAyMztcclxuLy8gVEhSRUUuUkdCRUZvcm1hdCBoYW5kbGVkIGFzIFRIUkVFLlJHQkFGb3JtYXQgaW4gc2hhZGVyc1xyXG5USFJFRS5SR0JFRm9ybWF0ID0gVEhSRUUuUkdCQUZvcm1hdDsgLy8xMDI0O1xyXG5cclxuLy8gRERTIC8gU1QzQyBDb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0c1xyXG5cclxuVEhSRUUuUkdCX1MzVENfRFhUMV9Gb3JtYXQgPSAyMDAxO1xyXG5USFJFRS5SR0JBX1MzVENfRFhUMV9Gb3JtYXQgPSAyMDAyO1xyXG5USFJFRS5SR0JBX1MzVENfRFhUM19Gb3JtYXQgPSAyMDAzO1xyXG5USFJFRS5SR0JBX1MzVENfRFhUNV9Gb3JtYXQgPSAyMDA0O1xyXG5cclxuXHJcbi8vIFBWUlRDIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXRzXHJcblxyXG5USFJFRS5SR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDIxMDA7XHJcblRIUkVFLlJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMjEwMTtcclxuVEhSRUUuUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0ID0gMjEwMjtcclxuVEhSRUUuUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMjEwMztcclxuXHJcbi8vIExvb3Agc3R5bGVzIGZvciBBbmltYXRpb25BY3Rpb25cclxuXHJcblRIUkVFLkxvb3BPbmNlID0gMjIwMDtcclxuVEhSRUUuTG9vcFJlcGVhdCA9IDIyMDE7XHJcblRIUkVFLkxvb3BQaW5nUG9uZyA9IDIyMDI7XHJcblxyXG4vLyBERVBSRUNBVEVEXHJcblxyXG5USFJFRS5Qcm9qZWN0b3IgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgY29uc29sZS5lcnJvciggJ1RIUkVFLlByb2plY3RvciBoYXMgYmVlbiBtb3ZlZCB0byAvZXhhbXBsZXMvanMvcmVuZGVyZXJzL1Byb2plY3Rvci5qcy4nICk7XHJcblxyXG4gICAgdGhpcy5wcm9qZWN0VmVjdG9yID0gZnVuY3Rpb24gKCB2ZWN0b3IsIGNhbWVyYSApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuUHJvamVjdG9yOiAucHJvamVjdFZlY3RvcigpIGlzIG5vdyB2ZWN0b3IucHJvamVjdCgpLicgKTtcclxuICAgICAgICB2ZWN0b3IucHJvamVjdCggY2FtZXJhICk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnVucHJvamVjdFZlY3RvciA9IGZ1bmN0aW9uICggdmVjdG9yLCBjYW1lcmEgKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlByb2plY3RvcjogLnVucHJvamVjdFZlY3RvcigpIGlzIG5vdyB2ZWN0b3IudW5wcm9qZWN0KCkuJyApO1xyXG4gICAgICAgIHZlY3Rvci51bnByb2plY3QoIGNhbWVyYSApO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5waWNraW5nUmF5ID0gZnVuY3Rpb24gKCB2ZWN0b3IsIGNhbWVyYSApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLlByb2plY3RvcjogLnBpY2tpbmdSYXkoKSBpcyBub3cgcmF5Y2FzdGVyLnNldEZyb21DYW1lcmEoKS4nICk7XHJcblxyXG4gICAgfTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DYW52YXNSZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuQ2FudmFzUmVuZGVyZXIgaGFzIGJlZW4gbW92ZWQgdG8gL2V4YW1wbGVzL2pzL3JlbmRlcmVycy9DYW52YXNSZW5kZXJlci5qcycgKTtcclxuXHJcbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xyXG4gICAgdGhpcy5jbGVhciA9IGZ1bmN0aW9uICgpIHt9O1xyXG4gICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7fTtcclxuICAgIHRoaXMuc2V0Q2xlYXJDb2xvciA9IGZ1bmN0aW9uICgpIHt9O1xyXG4gICAgdGhpcy5zZXRTaXplID0gZnVuY3Rpb24gKCkge307XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9Db2xvci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQ29sb3IgPSBmdW5jdGlvbiAoIGNvbG9yICkge1xyXG5cclxuICAgIGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMyApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbUFycmF5KCBhcmd1bWVudHMgKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuc2V0KCBjb2xvciApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkNvbG9yLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuQ29sb3IsXHJcblxyXG4gICAgcjogMSwgZzogMSwgYjogMSxcclxuXHJcbiAgICBzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIGlmICggdmFsdWUgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY29weSggdmFsdWUgKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICggdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2V0SGV4KCB2YWx1ZSApO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zZXRTdHlsZSggdmFsdWUgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldEhleDogZnVuY3Rpb24gKCBoZXggKSB7XHJcblxyXG4gICAgICAgIGhleCA9IE1hdGguZmxvb3IoIGhleCApO1xyXG5cclxuICAgICAgICB0aGlzLnIgPSAoIGhleCA+PiAxNiAmIDI1NSApIC8gMjU1O1xyXG4gICAgICAgIHRoaXMuZyA9ICggaGV4ID4+IDggJiAyNTUgKSAvIDI1NTtcclxuICAgICAgICB0aGlzLmIgPSAoIGhleCAmIDI1NSApIC8gMjU1O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldFJHQjogZnVuY3Rpb24gKCByLCBnLCBiICkge1xyXG5cclxuICAgICAgICB0aGlzLnIgPSByO1xyXG4gICAgICAgIHRoaXMuZyA9IGc7XHJcbiAgICAgICAgdGhpcy5iID0gYjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRIU0w6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaHVlMnJnYiggcCwgcSwgdCApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggdCA8IDAgKSB0ICs9IDE7XHJcbiAgICAgICAgICAgIGlmICggdCA+IDEgKSB0IC09IDE7XHJcbiAgICAgICAgICAgIGlmICggdCA8IDEgLyA2ICkgcmV0dXJuIHAgKyAoIHEgLSBwICkgKiA2ICogdDtcclxuICAgICAgICAgICAgaWYgKCB0IDwgMSAvIDIgKSByZXR1cm4gcTtcclxuICAgICAgICAgICAgaWYgKCB0IDwgMiAvIDMgKSByZXR1cm4gcCArICggcSAtIHAgKSAqIDYgKiAoIDIgLyAzIC0gdCApO1xyXG4gICAgICAgICAgICByZXR1cm4gcDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCBoLCBzLCBsICkge1xyXG5cclxuICAgICAgICAgICAgLy8gaCxzLGwgcmFuZ2VzIGFyZSBpbiAwLjAgLSAxLjBcclxuICAgICAgICAgICAgaCA9IFRIUkVFLk1hdGguZXVjbGlkZWFuTW9kdWxvKCBoLCAxICk7XHJcbiAgICAgICAgICAgIHMgPSBUSFJFRS5NYXRoLmNsYW1wKCBzLCAwLCAxICk7XHJcbiAgICAgICAgICAgIGwgPSBUSFJFRS5NYXRoLmNsYW1wKCBsLCAwLCAxICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHMgPT09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5yID0gdGhpcy5nID0gdGhpcy5iID0gbDtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSBsIDw9IDAuNSA/IGwgKiAoIDEgKyBzICkgOiBsICsgcyAtICggbCAqIHMgKTtcclxuICAgICAgICAgICAgICAgIHZhciBxID0gKCAyICogbCApIC0gcDtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnIgPSBodWUycmdiKCBxLCBwLCBoICsgMSAvIDMgKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZyA9IGh1ZTJyZ2IoIHEsIHAsIGggKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYiA9IGh1ZTJyZ2IoIHEsIHAsIGggLSAxIC8gMyApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIHNldFN0eWxlOiBmdW5jdGlvbiAoIHN0eWxlICkge1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVBbHBoYSggc3RyaW5nICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBzdHJpbmcgPT09IHVuZGVmaW5lZCApIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGlmICggcGFyc2VGbG9hdCggc3RyaW5nICkgPCAxICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbG9yOiBBbHBoYSBjb21wb25lbnQgb2YgJyArIHN0eWxlICsgJyB3aWxsIGJlIGlnbm9yZWQuJyApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICB2YXIgbTtcclxuXHJcbiAgICAgICAgaWYgKCBtID0gL14oKD86cmdifGhzbClhPylcXChcXHMqKFteXFwpXSopXFwpLy5leGVjKCBzdHlsZSApICkge1xyXG5cclxuICAgICAgICAgICAgLy8gcmdiIC8gaHNsXHJcblxyXG4gICAgICAgICAgICB2YXIgY29sb3I7XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gbVsgMSBdO1xyXG4gICAgICAgICAgICB2YXIgY29tcG9uZW50cyA9IG1bIDIgXTtcclxuXHJcbiAgICAgICAgICAgIHN3aXRjaCAoIG5hbWUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAncmdiJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3JnYmEnOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGNvbG9yID0gL14oXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqKCxcXHMqKFswLTldKlxcLj9bMC05XSspXFxzKik/JC8uZXhlYyggY29tcG9uZW50cyApICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmdiKDI1NSwwLDApIHJnYmEoMjU1LDAsMCwwLjUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuciA9IE1hdGgubWluKCAyNTUsIHBhcnNlSW50KCBjb2xvclsgMSBdLCAxMCApICkgLyAyNTU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZyA9IE1hdGgubWluKCAyNTUsIHBhcnNlSW50KCBjb2xvclsgMiBdLCAxMCApICkgLyAyNTU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYiA9IE1hdGgubWluKCAyNTUsIHBhcnNlSW50KCBjb2xvclsgMyBdLCAxMCApICkgLyAyNTU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVBbHBoYSggY29sb3JbIDUgXSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjb2xvciA9IC9eKFxcZCspXFwlXFxzKixcXHMqKFxcZCspXFwlXFxzKixcXHMqKFxcZCspXFwlXFxzKigsXFxzKihbMC05XSpcXC4/WzAtOV0rKVxccyopPyQvLmV4ZWMoIGNvbXBvbmVudHMgKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJnYigxMDAlLDAlLDAlKSByZ2JhKDEwMCUsMCUsMCUsMC41KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnIgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDEgXSwgMTAgKSApIC8gMTAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmcgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDIgXSwgMTAgKSApIC8gMTAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmIgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDMgXSwgMTAgKSApIC8gMTAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlQWxwaGEoIGNvbG9yWyA1IF0gKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ2hzbCc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdoc2xhJzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjb2xvciA9IC9eKFswLTldKlxcLj9bMC05XSspXFxzKixcXHMqKFxcZCspXFwlXFxzKixcXHMqKFxcZCspXFwlXFxzKigsXFxzKihbMC05XSpcXC4/WzAtOV0rKVxccyopPyQvLmV4ZWMoIGNvbXBvbmVudHMgKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhzbCgxMjAsNTAlLDUwJSkgaHNsYSgxMjAsNTAlLDUwJSwwLjUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoID0gcGFyc2VGbG9hdCggY29sb3JbIDEgXSApIC8gMzYwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHBhcnNlSW50KCBjb2xvclsgMiBdLCAxMCApIC8gMTAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IHBhcnNlSW50KCBjb2xvclsgMyBdLCAxMCApIC8gMTAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlQWxwaGEoIGNvbG9yWyA1IF0gKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldEhTTCggaCwgcywgbCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCBtID0gL15cXCMoW0EtRmEtZjAtOV0rKSQvLmV4ZWMoIHN0eWxlICkgKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBoZXggY29sb3JcclxuXHJcbiAgICAgICAgICAgIHZhciBoZXggPSBtWyAxIF07XHJcbiAgICAgICAgICAgIHZhciBzaXplID0gaGV4Lmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIGlmICggc2l6ZSA9PT0gMyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAjZmYwXHJcbiAgICAgICAgICAgICAgICB0aGlzLnIgPSBwYXJzZUludCggaGV4LmNoYXJBdCggMCApICsgaGV4LmNoYXJBdCggMCApLCAxNiApIC8gMjU1O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDEgKSArIGhleC5jaGFyQXQoIDEgKSwgMTYgKSAvIDI1NTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYiA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAyICkgKyBoZXguY2hhckF0KCAyICksIDE2ICkgLyAyNTU7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBzaXplID09PSA2ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vICNmZjAwMDBcclxuICAgICAgICAgICAgICAgIHRoaXMuciA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAwICkgKyBoZXguY2hhckF0KCAxICksIDE2ICkgLyAyNTU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmcgPSBwYXJzZUludCggaGV4LmNoYXJBdCggMiApICsgaGV4LmNoYXJBdCggMyApLCAxNiApIC8gMjU1O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5iID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDQgKSArIGhleC5jaGFyQXQoIDUgKSwgMTYgKSAvIDI1NTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIHN0eWxlICYmIHN0eWxlLmxlbmd0aCA+IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBjb2xvciBrZXl3b3Jkc1xyXG4gICAgICAgICAgICB2YXIgaGV4ID0gVEhSRUUuQ29sb3JLZXl3b3Jkc1sgc3R5bGUgXTtcclxuXHJcbiAgICAgICAgICAgIGlmICggaGV4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcmVkXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldEhleCggaGV4ICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHVua25vd24gY29sb3JcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbG9yOiBVbmtub3duIGNvbG9yICcgKyBzdHlsZSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLnIsIHRoaXMuZywgdGhpcy5iICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb3B5OiBmdW5jdGlvbiAoIGNvbG9yICkge1xyXG5cclxuICAgICAgICB0aGlzLnIgPSBjb2xvci5yO1xyXG4gICAgICAgIHRoaXMuZyA9IGNvbG9yLmc7XHJcbiAgICAgICAgdGhpcy5iID0gY29sb3IuYjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb3B5R2FtbWFUb0xpbmVhcjogZnVuY3Rpb24gKCBjb2xvciwgZ2FtbWFGYWN0b3IgKSB7XHJcblxyXG4gICAgICAgIGlmICggZ2FtbWFGYWN0b3IgPT09IHVuZGVmaW5lZCApIGdhbW1hRmFjdG9yID0gMi4wO1xyXG5cclxuICAgICAgICB0aGlzLnIgPSBNYXRoLnBvdyggY29sb3IuciwgZ2FtbWFGYWN0b3IgKTtcclxuICAgICAgICB0aGlzLmcgPSBNYXRoLnBvdyggY29sb3IuZywgZ2FtbWFGYWN0b3IgKTtcclxuICAgICAgICB0aGlzLmIgPSBNYXRoLnBvdyggY29sb3IuYiwgZ2FtbWFGYWN0b3IgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb3B5TGluZWFyVG9HYW1tYTogZnVuY3Rpb24gKCBjb2xvciwgZ2FtbWFGYWN0b3IgKSB7XHJcblxyXG4gICAgICAgIGlmICggZ2FtbWFGYWN0b3IgPT09IHVuZGVmaW5lZCApIGdhbW1hRmFjdG9yID0gMi4wO1xyXG5cclxuICAgICAgICB2YXIgc2FmZUludmVyc2UgPSAoIGdhbW1hRmFjdG9yID4gMCApID8gKCAxLjAgLyBnYW1tYUZhY3RvciApIDogMS4wO1xyXG5cclxuICAgICAgICB0aGlzLnIgPSBNYXRoLnBvdyggY29sb3Iuciwgc2FmZUludmVyc2UgKTtcclxuICAgICAgICB0aGlzLmcgPSBNYXRoLnBvdyggY29sb3IuZywgc2FmZUludmVyc2UgKTtcclxuICAgICAgICB0aGlzLmIgPSBNYXRoLnBvdyggY29sb3IuYiwgc2FmZUludmVyc2UgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb252ZXJ0R2FtbWFUb0xpbmVhcjogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgciA9IHRoaXMuciwgZyA9IHRoaXMuZywgYiA9IHRoaXMuYjtcclxuXHJcbiAgICAgICAgdGhpcy5yID0gciAqIHI7XHJcbiAgICAgICAgdGhpcy5nID0gZyAqIGc7XHJcbiAgICAgICAgdGhpcy5iID0gYiAqIGI7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29udmVydExpbmVhclRvR2FtbWE6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdGhpcy5yID0gTWF0aC5zcXJ0KCB0aGlzLnIgKTtcclxuICAgICAgICB0aGlzLmcgPSBNYXRoLnNxcnQoIHRoaXMuZyApO1xyXG4gICAgICAgIHRoaXMuYiA9IE1hdGguc3FydCggdGhpcy5iICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0SGV4OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiAoIHRoaXMuciAqIDI1NSApIDw8IDE2IF4gKCB0aGlzLmcgKiAyNTUgKSA8PCA4IF4gKCB0aGlzLmIgKiAyNTUgKSA8PCAwO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0SGV4U3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiAoICcwMDAwMDAnICsgdGhpcy5nZXRIZXgoKS50b1N0cmluZyggMTYgKSApLnNsaWNlKCAtIDYgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldEhTTDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcbiAgICAgICAgLy8gaCxzLGwgcmFuZ2VzIGFyZSBpbiAwLjAgLSAxLjBcclxuXHJcbiAgICAgICAgdmFyIGhzbCA9IG9wdGlvbmFsVGFyZ2V0IHx8IHsgaDogMCwgczogMCwgbDogMCB9O1xyXG5cclxuICAgICAgICB2YXIgciA9IHRoaXMuciwgZyA9IHRoaXMuZywgYiA9IHRoaXMuYjtcclxuXHJcbiAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4KCByLCBnLCBiICk7XHJcbiAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKCByLCBnLCBiICk7XHJcblxyXG4gICAgICAgIHZhciBodWUsIHNhdHVyYXRpb247XHJcbiAgICAgICAgdmFyIGxpZ2h0bmVzcyA9ICggbWluICsgbWF4ICkgLyAyLjA7XHJcblxyXG4gICAgICAgIGlmICggbWluID09PSBtYXggKSB7XHJcblxyXG4gICAgICAgICAgICBodWUgPSAwO1xyXG4gICAgICAgICAgICBzYXR1cmF0aW9uID0gMDtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IG1heCAtIG1pbjtcclxuXHJcbiAgICAgICAgICAgIHNhdHVyYXRpb24gPSBsaWdodG5lc3MgPD0gMC41ID8gZGVsdGEgLyAoIG1heCArIG1pbiApIDogZGVsdGEgLyAoIDIgLSBtYXggLSBtaW4gKTtcclxuXHJcbiAgICAgICAgICAgIHN3aXRjaCAoIG1heCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIHI6IGh1ZSA9ICggZyAtIGIgKSAvIGRlbHRhICsgKCBnIDwgYiA/IDYgOiAwICk7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBnOiBodWUgPSAoIGIgLSByICkgLyBkZWx0YSArIDI7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBiOiBodWUgPSAoIHIgLSBnICkgLyBkZWx0YSArIDQ7IGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaHVlIC89IDY7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaHNsLmggPSBodWU7XHJcbiAgICAgICAgaHNsLnMgPSBzYXR1cmF0aW9uO1xyXG4gICAgICAgIGhzbC5sID0gbGlnaHRuZXNzO1xyXG5cclxuICAgICAgICByZXR1cm4gaHNsO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0U3R5bGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuICdyZ2IoJyArICggKCB0aGlzLnIgKiAyNTUgKSB8IDAgKSArICcsJyArICggKCB0aGlzLmcgKiAyNTUgKSB8IDAgKSArICcsJyArICggKCB0aGlzLmIgKiAyNTUgKSB8IDAgKSArICcpJztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG9mZnNldEhTTDogZnVuY3Rpb24gKCBoLCBzLCBsICkge1xyXG5cclxuICAgICAgICB2YXIgaHNsID0gdGhpcy5nZXRIU0woKTtcclxuXHJcbiAgICAgICAgaHNsLmggKz0gaDsgaHNsLnMgKz0gczsgaHNsLmwgKz0gbDtcclxuXHJcbiAgICAgICAgdGhpcy5zZXRIU0woIGhzbC5oLCBoc2wucywgaHNsLmwgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhZGQ6IGZ1bmN0aW9uICggY29sb3IgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuciArPSBjb2xvci5yO1xyXG4gICAgICAgIHRoaXMuZyArPSBjb2xvci5nO1xyXG4gICAgICAgIHRoaXMuYiArPSBjb2xvci5iO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFkZENvbG9yczogZnVuY3Rpb24gKCBjb2xvcjEsIGNvbG9yMiApIHtcclxuXHJcbiAgICAgICAgdGhpcy5yID0gY29sb3IxLnIgKyBjb2xvcjIucjtcclxuICAgICAgICB0aGlzLmcgPSBjb2xvcjEuZyArIGNvbG9yMi5nO1xyXG4gICAgICAgIHRoaXMuYiA9IGNvbG9yMS5iICsgY29sb3IyLmI7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuciArPSBzO1xyXG4gICAgICAgIHRoaXMuZyArPSBzO1xyXG4gICAgICAgIHRoaXMuYiArPSBzO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG11bHRpcGx5OiBmdW5jdGlvbiAoIGNvbG9yICkge1xyXG5cclxuICAgICAgICB0aGlzLnIgKj0gY29sb3IucjtcclxuICAgICAgICB0aGlzLmcgKj0gY29sb3IuZztcclxuICAgICAgICB0aGlzLmIgKj0gY29sb3IuYjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuICAgICAgICB0aGlzLnIgKj0gcztcclxuICAgICAgICB0aGlzLmcgKj0gcztcclxuICAgICAgICB0aGlzLmIgKj0gcztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBsZXJwOiBmdW5jdGlvbiAoIGNvbG9yLCBhbHBoYSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5yICs9ICggY29sb3IuciAtIHRoaXMuciApICogYWxwaGE7XHJcbiAgICAgICAgdGhpcy5nICs9ICggY29sb3IuZyAtIHRoaXMuZyApICogYWxwaGE7XHJcbiAgICAgICAgdGhpcy5iICs9ICggY29sb3IuYiAtIHRoaXMuYiApICogYWxwaGE7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZXF1YWxzOiBmdW5jdGlvbiAoIGMgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiAoIGMuciA9PT0gdGhpcy5yICkgJiYgKCBjLmcgPT09IHRoaXMuZyApICYmICggYy5iID09PSB0aGlzLmIgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5yID0gYXJyYXlbIG9mZnNldCBdO1xyXG4gICAgICAgIHRoaXMuZyA9IGFycmF5WyBvZmZzZXQgKyAxIF07XHJcbiAgICAgICAgdGhpcy5iID0gYXJyYXlbIG9mZnNldCArIDIgXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG4gICAgICAgIGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XHJcbiAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgXSA9IHRoaXMucjtcclxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy5nO1xyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLmI7XHJcblxyXG4gICAgICAgIHJldHVybiBhcnJheTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ29sb3JLZXl3b3JkcyA9IHsgJ2FsaWNlYmx1ZSc6IDB4RjBGOEZGLCAnYW50aXF1ZXdoaXRlJzogMHhGQUVCRDcsICdhcXVhJzogMHgwMEZGRkYsICdhcXVhbWFyaW5lJzogMHg3RkZGRDQsICdhenVyZSc6IDB4RjBGRkZGLFxyXG4gICAgJ2JlaWdlJzogMHhGNUY1REMsICdiaXNxdWUnOiAweEZGRTRDNCwgJ2JsYWNrJzogMHgwMDAwMDAsICdibGFuY2hlZGFsbW9uZCc6IDB4RkZFQkNELCAnYmx1ZSc6IDB4MDAwMEZGLCAnYmx1ZXZpb2xldCc6IDB4OEEyQkUyLFxyXG4gICAgJ2Jyb3duJzogMHhBNTJBMkEsICdidXJseXdvb2QnOiAweERFQjg4NywgJ2NhZGV0Ymx1ZSc6IDB4NUY5RUEwLCAnY2hhcnRyZXVzZSc6IDB4N0ZGRjAwLCAnY2hvY29sYXRlJzogMHhEMjY5MUUsICdjb3JhbCc6IDB4RkY3RjUwLFxyXG4gICAgJ2Nvcm5mbG93ZXJibHVlJzogMHg2NDk1RUQsICdjb3Juc2lsayc6IDB4RkZGOERDLCAnY3JpbXNvbic6IDB4REMxNDNDLCAnY3lhbic6IDB4MDBGRkZGLCAnZGFya2JsdWUnOiAweDAwMDA4QiwgJ2RhcmtjeWFuJzogMHgwMDhCOEIsXHJcbiAgICAnZGFya2dvbGRlbnJvZCc6IDB4Qjg4NjBCLCAnZGFya2dyYXknOiAweEE5QTlBOSwgJ2RhcmtncmVlbic6IDB4MDA2NDAwLCAnZGFya2dyZXknOiAweEE5QTlBOSwgJ2RhcmtraGFraSc6IDB4QkRCNzZCLCAnZGFya21hZ2VudGEnOiAweDhCMDA4QixcclxuICAgICdkYXJrb2xpdmVncmVlbic6IDB4NTU2QjJGLCAnZGFya29yYW5nZSc6IDB4RkY4QzAwLCAnZGFya29yY2hpZCc6IDB4OTkzMkNDLCAnZGFya3JlZCc6IDB4OEIwMDAwLCAnZGFya3NhbG1vbic6IDB4RTk5NjdBLCAnZGFya3NlYWdyZWVuJzogMHg4RkJDOEYsXHJcbiAgICAnZGFya3NsYXRlYmx1ZSc6IDB4NDgzRDhCLCAnZGFya3NsYXRlZ3JheSc6IDB4MkY0RjRGLCAnZGFya3NsYXRlZ3JleSc6IDB4MkY0RjRGLCAnZGFya3R1cnF1b2lzZSc6IDB4MDBDRUQxLCAnZGFya3Zpb2xldCc6IDB4OTQwMEQzLFxyXG4gICAgJ2RlZXBwaW5rJzogMHhGRjE0OTMsICdkZWVwc2t5Ymx1ZSc6IDB4MDBCRkZGLCAnZGltZ3JheSc6IDB4Njk2OTY5LCAnZGltZ3JleSc6IDB4Njk2OTY5LCAnZG9kZ2VyYmx1ZSc6IDB4MUU5MEZGLCAnZmlyZWJyaWNrJzogMHhCMjIyMjIsXHJcbiAgICAnZmxvcmFsd2hpdGUnOiAweEZGRkFGMCwgJ2ZvcmVzdGdyZWVuJzogMHgyMjhCMjIsICdmdWNoc2lhJzogMHhGRjAwRkYsICdnYWluc2Jvcm8nOiAweERDRENEQywgJ2dob3N0d2hpdGUnOiAweEY4RjhGRiwgJ2dvbGQnOiAweEZGRDcwMCxcclxuICAgICdnb2xkZW5yb2QnOiAweERBQTUyMCwgJ2dyYXknOiAweDgwODA4MCwgJ2dyZWVuJzogMHgwMDgwMDAsICdncmVlbnllbGxvdyc6IDB4QURGRjJGLCAnZ3JleSc6IDB4ODA4MDgwLCAnaG9uZXlkZXcnOiAweEYwRkZGMCwgJ2hvdHBpbmsnOiAweEZGNjlCNCxcclxuICAgICdpbmRpYW5yZWQnOiAweENENUM1QywgJ2luZGlnbyc6IDB4NEIwMDgyLCAnaXZvcnknOiAweEZGRkZGMCwgJ2toYWtpJzogMHhGMEU2OEMsICdsYXZlbmRlcic6IDB4RTZFNkZBLCAnbGF2ZW5kZXJibHVzaCc6IDB4RkZGMEY1LCAnbGF3bmdyZWVuJzogMHg3Q0ZDMDAsXHJcbiAgICAnbGVtb25jaGlmZm9uJzogMHhGRkZBQ0QsICdsaWdodGJsdWUnOiAweEFERDhFNiwgJ2xpZ2h0Y29yYWwnOiAweEYwODA4MCwgJ2xpZ2h0Y3lhbic6IDB4RTBGRkZGLCAnbGlnaHRnb2xkZW5yb2R5ZWxsb3cnOiAweEZBRkFEMiwgJ2xpZ2h0Z3JheSc6IDB4RDNEM0QzLFxyXG4gICAgJ2xpZ2h0Z3JlZW4nOiAweDkwRUU5MCwgJ2xpZ2h0Z3JleSc6IDB4RDNEM0QzLCAnbGlnaHRwaW5rJzogMHhGRkI2QzEsICdsaWdodHNhbG1vbic6IDB4RkZBMDdBLCAnbGlnaHRzZWFncmVlbic6IDB4MjBCMkFBLCAnbGlnaHRza3libHVlJzogMHg4N0NFRkEsXHJcbiAgICAnbGlnaHRzbGF0ZWdyYXknOiAweDc3ODg5OSwgJ2xpZ2h0c2xhdGVncmV5JzogMHg3Nzg4OTksICdsaWdodHN0ZWVsYmx1ZSc6IDB4QjBDNERFLCAnbGlnaHR5ZWxsb3cnOiAweEZGRkZFMCwgJ2xpbWUnOiAweDAwRkYwMCwgJ2xpbWVncmVlbic6IDB4MzJDRDMyLFxyXG4gICAgJ2xpbmVuJzogMHhGQUYwRTYsICdtYWdlbnRhJzogMHhGRjAwRkYsICdtYXJvb24nOiAweDgwMDAwMCwgJ21lZGl1bWFxdWFtYXJpbmUnOiAweDY2Q0RBQSwgJ21lZGl1bWJsdWUnOiAweDAwMDBDRCwgJ21lZGl1bW9yY2hpZCc6IDB4QkE1NUQzLFxyXG4gICAgJ21lZGl1bXB1cnBsZSc6IDB4OTM3MERCLCAnbWVkaXVtc2VhZ3JlZW4nOiAweDNDQjM3MSwgJ21lZGl1bXNsYXRlYmx1ZSc6IDB4N0I2OEVFLCAnbWVkaXVtc3ByaW5nZ3JlZW4nOiAweDAwRkE5QSwgJ21lZGl1bXR1cnF1b2lzZSc6IDB4NDhEMUNDLFxyXG4gICAgJ21lZGl1bXZpb2xldHJlZCc6IDB4QzcxNTg1LCAnbWlkbmlnaHRibHVlJzogMHgxOTE5NzAsICdtaW50Y3JlYW0nOiAweEY1RkZGQSwgJ21pc3R5cm9zZSc6IDB4RkZFNEUxLCAnbW9jY2FzaW4nOiAweEZGRTRCNSwgJ25hdmFqb3doaXRlJzogMHhGRkRFQUQsXHJcbiAgICAnbmF2eSc6IDB4MDAwMDgwLCAnb2xkbGFjZSc6IDB4RkRGNUU2LCAnb2xpdmUnOiAweDgwODAwMCwgJ29saXZlZHJhYic6IDB4NkI4RTIzLCAnb3JhbmdlJzogMHhGRkE1MDAsICdvcmFuZ2VyZWQnOiAweEZGNDUwMCwgJ29yY2hpZCc6IDB4REE3MEQ2LFxyXG4gICAgJ3BhbGVnb2xkZW5yb2QnOiAweEVFRThBQSwgJ3BhbGVncmVlbic6IDB4OThGQjk4LCAncGFsZXR1cnF1b2lzZSc6IDB4QUZFRUVFLCAncGFsZXZpb2xldHJlZCc6IDB4REI3MDkzLCAncGFwYXlhd2hpcCc6IDB4RkZFRkQ1LCAncGVhY2hwdWZmJzogMHhGRkRBQjksXHJcbiAgICAncGVydSc6IDB4Q0Q4NTNGLCAncGluayc6IDB4RkZDMENCLCAncGx1bSc6IDB4RERBMERELCAncG93ZGVyYmx1ZSc6IDB4QjBFMEU2LCAncHVycGxlJzogMHg4MDAwODAsICdyZWQnOiAweEZGMDAwMCwgJ3Jvc3licm93bic6IDB4QkM4RjhGLFxyXG4gICAgJ3JveWFsYmx1ZSc6IDB4NDE2OUUxLCAnc2FkZGxlYnJvd24nOiAweDhCNDUxMywgJ3NhbG1vbic6IDB4RkE4MDcyLCAnc2FuZHlicm93bic6IDB4RjRBNDYwLCAnc2VhZ3JlZW4nOiAweDJFOEI1NywgJ3NlYXNoZWxsJzogMHhGRkY1RUUsXHJcbiAgICAnc2llbm5hJzogMHhBMDUyMkQsICdzaWx2ZXInOiAweEMwQzBDMCwgJ3NreWJsdWUnOiAweDg3Q0VFQiwgJ3NsYXRlYmx1ZSc6IDB4NkE1QUNELCAnc2xhdGVncmF5JzogMHg3MDgwOTAsICdzbGF0ZWdyZXknOiAweDcwODA5MCwgJ3Nub3cnOiAweEZGRkFGQSxcclxuICAgICdzcHJpbmdncmVlbic6IDB4MDBGRjdGLCAnc3RlZWxibHVlJzogMHg0NjgyQjQsICd0YW4nOiAweEQyQjQ4QywgJ3RlYWwnOiAweDAwODA4MCwgJ3RoaXN0bGUnOiAweEQ4QkZEOCwgJ3RvbWF0byc6IDB4RkY2MzQ3LCAndHVycXVvaXNlJzogMHg0MEUwRDAsXHJcbiAgICAndmlvbGV0JzogMHhFRTgyRUUsICd3aGVhdCc6IDB4RjVERUIzLCAnd2hpdGUnOiAweEZGRkZGRiwgJ3doaXRlc21va2UnOiAweEY1RjVGNSwgJ3llbGxvdyc6IDB4RkZGRjAwLCAneWVsbG93Z3JlZW4nOiAweDlBQ0QzMiB9O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9RdWF0ZXJuaW9uLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICovXHJcblxyXG5USFJFRS5RdWF0ZXJuaW9uID0gZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xyXG5cclxuICAgIHRoaXMuX3ggPSB4IHx8IDA7XHJcbiAgICB0aGlzLl95ID0geSB8fCAwO1xyXG4gICAgdGhpcy5feiA9IHogfHwgMDtcclxuICAgIHRoaXMuX3cgPSAoIHcgIT09IHVuZGVmaW5lZCApID8gdyA6IDE7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUXVhdGVybmlvbi5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLlF1YXRlcm5pb24sXHJcblxyXG4gICAgZ2V0IHggKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5feDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldCB4ICggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuX3ggPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldCB5ICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3k7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXQgeSAoIHZhbHVlICkge1xyXG5cclxuICAgICAgICB0aGlzLl95ID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXQgeiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLl96O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0IHogKCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5feiA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0IHcgKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5fdztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldCB3ICggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuX3cgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldDogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xyXG5cclxuICAgICAgICB0aGlzLl94ID0geDtcclxuICAgICAgICB0aGlzLl95ID0geTtcclxuICAgICAgICB0aGlzLl96ID0gejtcclxuICAgICAgICB0aGlzLl93ID0gdztcclxuXHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl93ICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb3B5OiBmdW5jdGlvbiAoIHF1YXRlcm5pb24gKSB7XHJcblxyXG4gICAgICAgIHRoaXMuX3ggPSBxdWF0ZXJuaW9uLng7XHJcbiAgICAgICAgdGhpcy5feSA9IHF1YXRlcm5pb24ueTtcclxuICAgICAgICB0aGlzLl96ID0gcXVhdGVybmlvbi56O1xyXG4gICAgICAgIHRoaXMuX3cgPSBxdWF0ZXJuaW9uLnc7XHJcblxyXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZyb21FdWxlcjogZnVuY3Rpb24gKCBldWxlciwgdXBkYXRlICkge1xyXG5cclxuICAgICAgICBpZiAoIGV1bGVyIGluc3RhbmNlb2YgVEhSRUUuRXVsZXIgPT09IGZhbHNlICkge1xyXG5cclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuUXVhdGVybmlvbjogLnNldEZyb21FdWxlcigpIG5vdyBleHBlY3RzIGEgRXVsZXIgcm90YXRpb24gcmF0aGVyIHRoYW4gYSBWZWN0b3IzIGFuZCBvcmRlci4nICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaHR0cDovL3d3dy5tYXRod29ya3MuY29tL21hdGxhYmNlbnRyYWwvZmlsZWV4Y2hhbmdlL1xyXG4gICAgICAgIC8vIFx0MjA2OTYtZnVuY3Rpb24tdG8tY29udmVydC1iZXR3ZWVuLWRjbS1ldWxlci1hbmdsZXMtcXVhdGVybmlvbnMtYW5kLWV1bGVyLXZlY3RvcnMvXHJcbiAgICAgICAgLy9cdGNvbnRlbnQvU3BpbkNhbGMubVxyXG5cclxuICAgICAgICB2YXIgYzEgPSBNYXRoLmNvcyggZXVsZXIuX3ggLyAyICk7XHJcbiAgICAgICAgdmFyIGMyID0gTWF0aC5jb3MoIGV1bGVyLl95IC8gMiApO1xyXG4gICAgICAgIHZhciBjMyA9IE1hdGguY29zKCBldWxlci5feiAvIDIgKTtcclxuICAgICAgICB2YXIgczEgPSBNYXRoLnNpbiggZXVsZXIuX3ggLyAyICk7XHJcbiAgICAgICAgdmFyIHMyID0gTWF0aC5zaW4oIGV1bGVyLl95IC8gMiApO1xyXG4gICAgICAgIHZhciBzMyA9IE1hdGguc2luKCBldWxlci5feiAvIDIgKTtcclxuXHJcbiAgICAgICAgdmFyIG9yZGVyID0gZXVsZXIub3JkZXI7XHJcblxyXG4gICAgICAgIGlmICggb3JkZXIgPT09ICdYWVonICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcclxuICAgICAgICAgICAgdGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcclxuICAgICAgICAgICAgdGhpcy5feiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcclxuICAgICAgICAgICAgdGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICggb3JkZXIgPT09ICdZWFonICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcclxuICAgICAgICAgICAgdGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcclxuICAgICAgICAgICAgdGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcclxuICAgICAgICAgICAgdGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICggb3JkZXIgPT09ICdaWFknICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcclxuICAgICAgICAgICAgdGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcclxuICAgICAgICAgICAgdGhpcy5feiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcclxuICAgICAgICAgICAgdGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICggb3JkZXIgPT09ICdaWVgnICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcclxuICAgICAgICAgICAgdGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcclxuICAgICAgICAgICAgdGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcclxuICAgICAgICAgICAgdGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICggb3JkZXIgPT09ICdZWlgnICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcclxuICAgICAgICAgICAgdGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcclxuICAgICAgICAgICAgdGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcclxuICAgICAgICAgICAgdGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICggb3JkZXIgPT09ICdYWlknICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcclxuICAgICAgICAgICAgdGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcclxuICAgICAgICAgICAgdGhpcy5feiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcclxuICAgICAgICAgICAgdGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIHVwZGF0ZSAhPT0gZmFsc2UgKSB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRGcm9tQXhpc0FuZ2xlOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xyXG5cclxuICAgICAgICAvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvYW5nbGVUb1F1YXRlcm5pb24vaW5kZXguaHRtXHJcblxyXG4gICAgICAgIC8vIGFzc3VtZXMgYXhpcyBpcyBub3JtYWxpemVkXHJcblxyXG4gICAgICAgIHZhciBoYWxmQW5nbGUgPSBhbmdsZSAvIDIsIHMgPSBNYXRoLnNpbiggaGFsZkFuZ2xlICk7XHJcblxyXG4gICAgICAgIHRoaXMuX3ggPSBheGlzLnggKiBzO1xyXG4gICAgICAgIHRoaXMuX3kgPSBheGlzLnkgKiBzO1xyXG4gICAgICAgIHRoaXMuX3ogPSBheGlzLnogKiBzO1xyXG4gICAgICAgIHRoaXMuX3cgPSBNYXRoLmNvcyggaGFsZkFuZ2xlICk7XHJcblxyXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuICAgICAgICAvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxyXG5cclxuICAgICAgICAvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxyXG5cclxuICAgICAgICB2YXIgdGUgPSBtLmVsZW1lbnRzLFxyXG5cclxuICAgICAgICAgICAgbTExID0gdGVbIDAgXSwgbTEyID0gdGVbIDQgXSwgbTEzID0gdGVbIDggXSxcclxuICAgICAgICAgICAgbTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXSxcclxuICAgICAgICAgICAgbTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF0sXHJcblxyXG4gICAgICAgICAgICB0cmFjZSA9IG0xMSArIG0yMiArIG0zMyxcclxuICAgICAgICAgICAgcztcclxuXHJcbiAgICAgICAgaWYgKCB0cmFjZSA+IDAgKSB7XHJcblxyXG4gICAgICAgICAgICBzID0gMC41IC8gTWF0aC5zcXJ0KCB0cmFjZSArIDEuMCApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fdyA9IDAuMjUgLyBzO1xyXG4gICAgICAgICAgICB0aGlzLl94ID0gKCBtMzIgLSBtMjMgKSAqIHM7XHJcbiAgICAgICAgICAgIHRoaXMuX3kgPSAoIG0xMyAtIG0zMSApICogcztcclxuICAgICAgICAgICAgdGhpcy5feiA9ICggbTIxIC0gbTEyICkgKiBzO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCBtMTEgPiBtMjIgJiYgbTExID4gbTMzICkge1xyXG5cclxuICAgICAgICAgICAgcyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTExIC0gbTIyIC0gbTMzICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl93ID0gKCBtMzIgLSBtMjMgKSAvIHM7XHJcbiAgICAgICAgICAgIHRoaXMuX3ggPSAwLjI1ICogcztcclxuICAgICAgICAgICAgdGhpcy5feSA9ICggbTEyICsgbTIxICkgLyBzO1xyXG4gICAgICAgICAgICB0aGlzLl96ID0gKCBtMTMgKyBtMzEgKSAvIHM7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIG0yMiA+IG0zMyApIHtcclxuXHJcbiAgICAgICAgICAgIHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0yMiAtIG0xMSAtIG0zMyApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fdyA9ICggbTEzIC0gbTMxICkgLyBzO1xyXG4gICAgICAgICAgICB0aGlzLl94ID0gKCBtMTIgKyBtMjEgKSAvIHM7XHJcbiAgICAgICAgICAgIHRoaXMuX3kgPSAwLjI1ICogcztcclxuICAgICAgICAgICAgdGhpcy5feiA9ICggbTIzICsgbTMyICkgLyBzO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgcyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTMzIC0gbTExIC0gbTIyICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl93ID0gKCBtMjEgLSBtMTIgKSAvIHM7XHJcbiAgICAgICAgICAgIHRoaXMuX3ggPSAoIG0xMyArIG0zMSApIC8gcztcclxuICAgICAgICAgICAgdGhpcy5feSA9ICggbTIzICsgbTMyICkgLyBzO1xyXG4gICAgICAgICAgICB0aGlzLl96ID0gMC4yNSAqIHM7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0RnJvbVVuaXRWZWN0b3JzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIC8vIGh0dHA6Ly9sb2xlbmdpbmUubmV0L2Jsb2cvMjAxNC8wMi8yNC9xdWF0ZXJuaW9uLWZyb20tdHdvLXZlY3RvcnMtZmluYWxcclxuXHJcbiAgICAgICAgLy8gYXNzdW1lcyBkaXJlY3Rpb24gdmVjdG9ycyB2RnJvbSBhbmQgdlRvIGFyZSBub3JtYWxpemVkXHJcblxyXG4gICAgICAgIHZhciB2MSwgcjtcclxuXHJcbiAgICAgICAgdmFyIEVQUyA9IDAuMDAwMDAxO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCB2RnJvbSwgdlRvICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICAgICAgciA9IHZGcm9tLmRvdCggdlRvICkgKyAxO1xyXG5cclxuICAgICAgICAgICAgaWYgKCByIDwgRVBTICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHIgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggTWF0aC5hYnMoIHZGcm9tLnggKSA+IE1hdGguYWJzKCB2RnJvbS56ICkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHYxLnNldCggLSB2RnJvbS55LCB2RnJvbS54LCAwICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdjEuc2V0KCAwLCAtIHZGcm9tLnosIHZGcm9tLnkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIHYxLmNyb3NzVmVjdG9ycyggdkZyb20sIHZUbyApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5feCA9IHYxLng7XHJcbiAgICAgICAgICAgIHRoaXMuX3kgPSB2MS55O1xyXG4gICAgICAgICAgICB0aGlzLl96ID0gdjEuejtcclxuICAgICAgICAgICAgdGhpcy5fdyA9IHI7XHJcblxyXG4gICAgICAgICAgICB0aGlzLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgaW52ZXJzZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0aGlzLmNvbmp1Z2F0ZSgpLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvbmp1Z2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0aGlzLl94ICo9IC0gMTtcclxuICAgICAgICB0aGlzLl95ICo9IC0gMTtcclxuICAgICAgICB0aGlzLl96ICo9IC0gMTtcclxuXHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZG90OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLl94ICogdi5feCArIHRoaXMuX3kgKiB2Ll95ICsgdGhpcy5feiAqIHYuX3ogKyB0aGlzLl93ICogdi5fdztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGxlbmd0aDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBsID0gdGhpcy5sZW5ndGgoKTtcclxuXHJcbiAgICAgICAgaWYgKCBsID09PSAwICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5feCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3kgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl96ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fdyA9IDE7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICBsID0gMSAvIGw7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl94ID0gdGhpcy5feCAqIGw7XHJcbiAgICAgICAgICAgIHRoaXMuX3kgPSB0aGlzLl95ICogbDtcclxuICAgICAgICAgICAgdGhpcy5feiA9IHRoaXMuX3ogKiBsO1xyXG4gICAgICAgICAgICB0aGlzLl93ID0gdGhpcy5fdyAqIGw7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbXVsdGlwbHk6IGZ1bmN0aW9uICggcSwgcCApIHtcclxuXHJcbiAgICAgICAgaWYgKCBwICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5RdWF0ZXJuaW9uOiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseVF1YXRlcm5pb25zKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoIHEsIHAgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCB0aGlzLCBxICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBtdWx0aXBseVF1YXRlcm5pb25zOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG4gICAgICAgIC8vIGZyb20gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9jb2RlL2luZGV4Lmh0bVxyXG5cclxuICAgICAgICB2YXIgcWF4ID0gYS5feCwgcWF5ID0gYS5feSwgcWF6ID0gYS5feiwgcWF3ID0gYS5fdztcclxuICAgICAgICB2YXIgcWJ4ID0gYi5feCwgcWJ5ID0gYi5feSwgcWJ6ID0gYi5feiwgcWJ3ID0gYi5fdztcclxuXHJcbiAgICAgICAgdGhpcy5feCA9IHFheCAqIHFidyArIHFhdyAqIHFieCArIHFheSAqIHFieiAtIHFheiAqIHFieTtcclxuICAgICAgICB0aGlzLl95ID0gcWF5ICogcWJ3ICsgcWF3ICogcWJ5ICsgcWF6ICogcWJ4IC0gcWF4ICogcWJ6O1xyXG4gICAgICAgIHRoaXMuX3ogPSBxYXogKiBxYncgKyBxYXcgKiBxYnogKyBxYXggKiBxYnkgLSBxYXkgKiBxYng7XHJcbiAgICAgICAgdGhpcy5fdyA9IHFhdyAqIHFidyAtIHFheCAqIHFieCAtIHFheSAqIHFieSAtIHFheiAqIHFiejtcclxuXHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbXVsdGlwbHlWZWN0b3IzOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuUXVhdGVybmlvbjogLm11bHRpcGx5VmVjdG9yMygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBpcyBub3cgdmVjdG9yLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApIGluc3RlYWQuJyApO1xyXG4gICAgICAgIHJldHVybiB2ZWN0b3IuYXBwbHlRdWF0ZXJuaW9uKCB0aGlzICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzbGVycDogZnVuY3Rpb24gKCBxYiwgdCApIHtcclxuXHJcbiAgICAgICAgaWYgKCB0ID09PSAwICkgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgaWYgKCB0ID09PSAxICkgcmV0dXJuIHRoaXMuY29weSggcWIgKTtcclxuXHJcbiAgICAgICAgdmFyIHggPSB0aGlzLl94LCB5ID0gdGhpcy5feSwgeiA9IHRoaXMuX3osIHcgPSB0aGlzLl93O1xyXG5cclxuICAgICAgICAvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL3NsZXJwL1xyXG5cclxuICAgICAgICB2YXIgY29zSGFsZlRoZXRhID0gdyAqIHFiLl93ICsgeCAqIHFiLl94ICsgeSAqIHFiLl95ICsgeiAqIHFiLl96O1xyXG5cclxuICAgICAgICBpZiAoIGNvc0hhbGZUaGV0YSA8IDAgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl93ID0gLSBxYi5fdztcclxuICAgICAgICAgICAgdGhpcy5feCA9IC0gcWIuX3g7XHJcbiAgICAgICAgICAgIHRoaXMuX3kgPSAtIHFiLl95O1xyXG4gICAgICAgICAgICB0aGlzLl96ID0gLSBxYi5fejtcclxuXHJcbiAgICAgICAgICAgIGNvc0hhbGZUaGV0YSA9IC0gY29zSGFsZlRoZXRhO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jb3B5KCBxYiApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggY29zSGFsZlRoZXRhID49IDEuMCApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3cgPSB3O1xyXG4gICAgICAgICAgICB0aGlzLl94ID0geDtcclxuICAgICAgICAgICAgdGhpcy5feSA9IHk7XHJcbiAgICAgICAgICAgIHRoaXMuX3ogPSB6O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGhhbGZUaGV0YSA9IE1hdGguYWNvcyggY29zSGFsZlRoZXRhICk7XHJcbiAgICAgICAgdmFyIHNpbkhhbGZUaGV0YSA9IE1hdGguc3FydCggMS4wIC0gY29zSGFsZlRoZXRhICogY29zSGFsZlRoZXRhICk7XHJcblxyXG4gICAgICAgIGlmICggTWF0aC5hYnMoIHNpbkhhbGZUaGV0YSApIDwgMC4wMDEgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl93ID0gMC41ICogKCB3ICsgdGhpcy5fdyApO1xyXG4gICAgICAgICAgICB0aGlzLl94ID0gMC41ICogKCB4ICsgdGhpcy5feCApO1xyXG4gICAgICAgICAgICB0aGlzLl95ID0gMC41ICogKCB5ICsgdGhpcy5feSApO1xyXG4gICAgICAgICAgICB0aGlzLl96ID0gMC41ICogKCB6ICsgdGhpcy5feiApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHJhdGlvQSA9IE1hdGguc2luKCAoIDEgLSB0ICkgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YSxcclxuICAgICAgICAgICAgcmF0aW9CID0gTWF0aC5zaW4oIHQgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YTtcclxuXHJcbiAgICAgICAgdGhpcy5fdyA9ICggdyAqIHJhdGlvQSArIHRoaXMuX3cgKiByYXRpb0IgKTtcclxuICAgICAgICB0aGlzLl94ID0gKCB4ICogcmF0aW9BICsgdGhpcy5feCAqIHJhdGlvQiApO1xyXG4gICAgICAgIHRoaXMuX3kgPSAoIHkgKiByYXRpb0EgKyB0aGlzLl95ICogcmF0aW9CICk7XHJcbiAgICAgICAgdGhpcy5feiA9ICggeiAqIHJhdGlvQSArIHRoaXMuX3ogKiByYXRpb0IgKTtcclxuXHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZXF1YWxzOiBmdW5jdGlvbiAoIHF1YXRlcm5pb24gKSB7XHJcblxyXG4gICAgICAgIHJldHVybiAoIHF1YXRlcm5pb24uX3ggPT09IHRoaXMuX3ggKSAmJiAoIHF1YXRlcm5pb24uX3kgPT09IHRoaXMuX3kgKSAmJiAoIHF1YXRlcm5pb24uX3ogPT09IHRoaXMuX3ogKSAmJiAoIHF1YXRlcm5pb24uX3cgPT09IHRoaXMuX3cgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5feCA9IGFycmF5WyBvZmZzZXQgXTtcclxuICAgICAgICB0aGlzLl95ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcclxuICAgICAgICB0aGlzLl96ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcclxuICAgICAgICB0aGlzLl93ID0gYXJyYXlbIG9mZnNldCArIDMgXTtcclxuXHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuICAgICAgICBpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xyXG4gICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuICAgICAgICBhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLl94O1xyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLl95O1xyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLl96O1xyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0aGlzLl93O1xyXG5cclxuICAgICAgICByZXR1cm4gYXJyYXk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBvbkNoYW5nZTogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcclxuXHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgb25DaGFuZ2VDYWxsYmFjazogZnVuY3Rpb24gKCkge31cclxuXHJcbn07XHJcblxyXG5USFJFRS5RdWF0ZXJuaW9uLnNsZXJwID0gZnVuY3Rpb24gKCBxYSwgcWIsIHFtLCB0ICkge1xyXG5cclxuICAgIHJldHVybiBxbS5jb3B5KCBxYSApLnNsZXJwKCBxYiwgdCApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGgvVmVjdG9yMi5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXHJcbiAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICovXHJcblxyXG5USFJFRS5WZWN0b3IyID0gZnVuY3Rpb24gKCB4LCB5ICkge1xyXG5cclxuICAgIHRoaXMueCA9IHggfHwgMDtcclxuICAgIHRoaXMueSA9IHkgfHwgMDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5WZWN0b3IyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuVmVjdG9yMixcclxuXHJcbiAgICBnZXQgd2lkdGgoKSB7IHJldHVybiB0aGlzLnggfSxcclxuICAgIHNldCB3aWR0aCggdmFsdWUgKSB7IHRoaXMueCA9IHZhbHVlIH0sXHJcblxyXG4gICAgZ2V0IGhlaWdodCgpIHsgcmV0dXJuIHRoaXMueSB9LFxyXG4gICAgc2V0IGhlaWdodCggdmFsdWUgKSB7IHRoaXMueSA9IHZhbHVlIH0sXHJcblxyXG4gICAgLy9cclxuXHJcbiAgICBzZXQ6IGZ1bmN0aW9uICggeCwgeSApIHtcclxuXHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldFg6IGZ1bmN0aW9uICggeCApIHtcclxuXHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRZOiBmdW5jdGlvbiAoIHkgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4LCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgc3dpdGNoICggaW5kZXggKSB7XHJcblxyXG4gICAgICAgICAgICBjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCApIHtcclxuXHJcbiAgICAgICAgc3dpdGNoICggaW5kZXggKSB7XHJcblxyXG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiB0aGlzLng7XHJcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIHRoaXMueTtcclxuICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLngsIHRoaXMueSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29weTogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuICAgICAgICB0aGlzLnggPSB2Lng7XHJcbiAgICAgICAgdGhpcy55ID0gdi55O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuICAgICAgICBpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjI6IC5hZGQoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5hZGRWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZFZlY3RvcnMoIHYsIHcgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnggKz0gdi54O1xyXG4gICAgICAgIHRoaXMueSArPSB2Lnk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCArPSBzO1xyXG4gICAgICAgIHRoaXMueSArPSBzO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFkZFZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gYS54ICsgYi54O1xyXG4gICAgICAgIHRoaXMueSA9IGEueSArIGIueTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhZGRTY2FsZWRWZWN0b3I6IGZ1bmN0aW9uICggdiwgcyApIHtcclxuXHJcbiAgICAgICAgdGhpcy54ICs9IHYueCAqIHM7XHJcbiAgICAgICAgdGhpcy55ICs9IHYueSAqIHM7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc3ViOiBmdW5jdGlvbiAoIHYsIHcgKSB7XHJcblxyXG4gICAgICAgIGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMjogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdiwgdyApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMueCAtPSB2Lng7XHJcbiAgICAgICAgdGhpcy55IC09IHYueTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzdWJTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcclxuXHJcbiAgICAgICAgdGhpcy54IC09IHM7XHJcbiAgICAgICAgdGhpcy55IC09IHM7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuICAgICAgICB0aGlzLnggPSBhLnggLSBiLng7XHJcbiAgICAgICAgdGhpcy55ID0gYS55IC0gYi55O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG11bHRpcGx5OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCAqPSB2Lng7XHJcbiAgICAgICAgdGhpcy55ICo9IHYueTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XHJcblxyXG4gICAgICAgIGlmICggaXNGaW5pdGUoIHNjYWxhciApICkge1xyXG4gICAgICAgICAgICB0aGlzLnggKj0gc2NhbGFyO1xyXG4gICAgICAgICAgICB0aGlzLnkgKj0gc2NhbGFyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRpdmlkZTogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuICAgICAgICB0aGlzLnggLz0gdi54O1xyXG4gICAgICAgIHRoaXMueSAvPSB2Lnk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIDEgLyBzY2FsYXIgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG1pbjogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuICAgICAgICB0aGlzLnggPSBNYXRoLm1pbiggdGhpcy54LCB2LnggKTtcclxuICAgICAgICB0aGlzLnkgPSBNYXRoLm1pbiggdGhpcy55LCB2LnkgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBtYXg6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gTWF0aC5tYXgoIHRoaXMueCwgdi54ICk7XHJcbiAgICAgICAgdGhpcy55ID0gTWF0aC5tYXgoIHRoaXMueSwgdi55ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2xhbXA6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyBtaW4gPCBtYXgsIGlmIHRoaXMgYXNzdW1wdGlvbiBpc24ndCB0cnVlIGl0IHdpbGwgbm90IG9wZXJhdGUgY29ycmVjdGx5XHJcblxyXG4gICAgICAgIHRoaXMueCA9IE1hdGgubWF4KCBtaW4ueCwgTWF0aC5taW4oIG1heC54LCB0aGlzLnggKSApO1xyXG4gICAgICAgIHRoaXMueSA9IE1hdGgubWF4KCBtaW4ueSwgTWF0aC5taW4oIG1heC55LCB0aGlzLnkgKSApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNsYW1wU2NhbGFyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBtaW4sIG1heDtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNsYW1wU2NhbGFyKCBtaW5WYWwsIG1heFZhbCApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggbWluID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgbWluID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuICAgICAgICAgICAgICAgIG1heCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBtaW4uc2V0KCBtaW5WYWwsIG1pblZhbCApO1xyXG4gICAgICAgICAgICBtYXguc2V0KCBtYXhWYWwsIG1heFZhbCApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xhbXAoIG1pbiwgbWF4ICk7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIGNsYW1wTGVuZ3RoOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xyXG5cclxuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcclxuXHJcbiAgICAgICAgdGhpcy5tdWx0aXBseVNjYWxhciggTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgbGVuZ3RoICkgKSAvIGxlbmd0aCApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGZsb29yOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xyXG4gICAgICAgIHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNlaWw6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gTWF0aC5jZWlsKCB0aGlzLnggKTtcclxuICAgICAgICB0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJvdW5kOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xyXG4gICAgICAgIHRoaXMueSA9IE1hdGgucm91bmQoIHRoaXMueSApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9ICggdGhpcy54IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnggKSA6IE1hdGguZmxvb3IoIHRoaXMueCApO1xyXG4gICAgICAgIHRoaXMueSA9ICggdGhpcy55IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnkgKSA6IE1hdGguZmxvb3IoIHRoaXMueSApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0aGlzLnggPSAtIHRoaXMueDtcclxuICAgICAgICB0aGlzLnkgPSAtIHRoaXMueTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBkb3Q6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBsZW5ndGg6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBsZW5ndGhNYW5oYXR0YW46IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gTWF0aC5hYnMoIHRoaXMueCApICsgTWF0aC5hYnMoIHRoaXMueSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZGlzdGFuY2VUbzogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKCB2ICkgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRpc3RhbmNlVG9TcXVhcmVkOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG4gICAgICAgIHZhciBkeCA9IHRoaXMueCAtIHYueCwgZHkgPSB0aGlzLnkgLSB2Lnk7XHJcbiAgICAgICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0TGVuZ3RoOiBmdW5jdGlvbiAoIGxlbmd0aCApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIGxlbmd0aCAvIHRoaXMubGVuZ3RoKCkgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGxlcnA6IGZ1bmN0aW9uICggdiwgYWxwaGEgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XHJcbiAgICAgICAgdGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBsZXJwVmVjdG9yczogZnVuY3Rpb24gKCB2MSwgdjIsIGFscGhhICkge1xyXG5cclxuICAgICAgICB0aGlzLnN1YlZlY3RvcnMoIHYyLCB2MSApLm11bHRpcGx5U2NhbGFyKCBhbHBoYSApLmFkZCggdjEgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBlcXVhbHM6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG4gICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XHJcbiAgICAgICAgdGhpcy55ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG4gICAgICAgIGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XHJcbiAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcclxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy55O1xyXG5cclxuICAgICAgICByZXR1cm4gYXJyYXk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBmcm9tQXR0cmlidXRlOiBmdW5jdGlvbiAoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcclxuXHJcbiAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG4gICAgICAgIGluZGV4ID0gaW5kZXggKiBhdHRyaWJ1dGUuaXRlbVNpemUgKyBvZmZzZXQ7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggXTtcclxuICAgICAgICB0aGlzLnkgPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4ICsgMSBdO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJvdGF0ZUFyb3VuZDogZnVuY3Rpb24gKCBjZW50ZXIsIGFuZ2xlICkge1xyXG5cclxuICAgICAgICB2YXIgYyA9IE1hdGguY29zKCBhbmdsZSApLCBzID0gTWF0aC5zaW4oIGFuZ2xlICk7XHJcblxyXG4gICAgICAgIHZhciB4ID0gdGhpcy54IC0gY2VudGVyLng7XHJcbiAgICAgICAgdmFyIHkgPSB0aGlzLnkgLSBjZW50ZXIueTtcclxuXHJcbiAgICAgICAgdGhpcy54ID0geCAqIGMgLSB5ICogcyArIGNlbnRlci54O1xyXG4gICAgICAgIHRoaXMueSA9IHggKiBzICsgeSAqIGMgKyBjZW50ZXIueTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGgvVmVjdG9yMy5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgKmtpbGUgLyBodHRwOi8va2lsZS5zdHJhdmFnYW56YS5vcmcvXHJcbiAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKi9cclxuXHJcblRIUkVFLlZlY3RvcjMgPSBmdW5jdGlvbiAoIHgsIHksIHogKSB7XHJcblxyXG4gICAgdGhpcy54ID0geCB8fCAwO1xyXG4gICAgdGhpcy55ID0geSB8fCAwO1xyXG4gICAgdGhpcy56ID0geiB8fCAwO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlZlY3RvcjMucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5WZWN0b3IzLFxyXG5cclxuICAgIHNldDogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xyXG5cclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgdGhpcy56ID0gejtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRYOiBmdW5jdGlvbiAoIHggKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0WTogZnVuY3Rpb24gKCB5ICkge1xyXG5cclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldFo6IGZ1bmN0aW9uICggeiApIHtcclxuXHJcbiAgICAgICAgdGhpcy56ID0gejtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXgsIHZhbHVlICkge1xyXG5cclxuICAgICAgICBzd2l0Y2ggKCBpbmRleCApIHtcclxuXHJcbiAgICAgICAgICAgIGNhc2UgMDogdGhpcy54ID0gdmFsdWU7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOiB0aGlzLnogPSB2YWx1ZTsgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCApIHtcclxuXHJcbiAgICAgICAgc3dpdGNoICggaW5kZXggKSB7XHJcblxyXG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiB0aGlzLng7XHJcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIHRoaXMueTtcclxuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gdGhpcy56O1xyXG4gICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMueCwgdGhpcy55LCB0aGlzLnogKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvcHk6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gdi54O1xyXG4gICAgICAgIHRoaXMueSA9IHYueTtcclxuICAgICAgICB0aGlzLnogPSB2Lno7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYWRkOiBmdW5jdGlvbiAoIHYsIHcgKSB7XHJcblxyXG4gICAgICAgIGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkVmVjdG9ycyggdiwgdyApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMueCArPSB2Lng7XHJcbiAgICAgICAgdGhpcy55ICs9IHYueTtcclxuICAgICAgICB0aGlzLnogKz0gdi56O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuICAgICAgICB0aGlzLnggKz0gcztcclxuICAgICAgICB0aGlzLnkgKz0gcztcclxuICAgICAgICB0aGlzLnogKz0gcztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhZGRWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IGEueCArIGIueDtcclxuICAgICAgICB0aGlzLnkgPSBhLnkgKyBiLnk7XHJcbiAgICAgICAgdGhpcy56ID0gYS56ICsgYi56O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFkZFNjYWxlZFZlY3RvcjogZnVuY3Rpb24gKCB2LCBzICkge1xyXG5cclxuICAgICAgICB0aGlzLnggKz0gdi54ICogcztcclxuICAgICAgICB0aGlzLnkgKz0gdi55ICogcztcclxuICAgICAgICB0aGlzLnogKz0gdi56ICogcztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzdWI6IGZ1bmN0aW9uICggdiwgdyApIHtcclxuXHJcbiAgICAgICAgaWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2LCB3ICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy54IC09IHYueDtcclxuICAgICAgICB0aGlzLnkgLT0gdi55O1xyXG4gICAgICAgIHRoaXMueiAtPSB2Lno7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc3ViU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCAtPSBzO1xyXG4gICAgICAgIHRoaXMueSAtPSBzO1xyXG4gICAgICAgIHRoaXMueiAtPSBzO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHN1YlZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gYS54IC0gYi54O1xyXG4gICAgICAgIHRoaXMueSA9IGEueSAtIGIueTtcclxuICAgICAgICB0aGlzLnogPSBhLnogLSBiLno7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbXVsdGlwbHk6IGZ1bmN0aW9uICggdiwgdyApIHtcclxuXHJcbiAgICAgICAgaWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseVZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlWZWN0b3JzKCB2LCB3ICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy54ICo9IHYueDtcclxuICAgICAgICB0aGlzLnkgKj0gdi55O1xyXG4gICAgICAgIHRoaXMueiAqPSB2Lno7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuICAgICAgICBpZiAoIGlzRmluaXRlKCBzY2FsYXIgKSApIHtcclxuICAgICAgICAgICAgdGhpcy54ICo9IHNjYWxhcjtcclxuICAgICAgICAgICAgdGhpcy55ICo9IHNjYWxhcjtcclxuICAgICAgICAgICAgdGhpcy56ICo9IHNjYWxhcjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnkgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnogPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBtdWx0aXBseVZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gYS54ICogYi54O1xyXG4gICAgICAgIHRoaXMueSA9IGEueSAqIGIueTtcclxuICAgICAgICB0aGlzLnogPSBhLnogKiBiLno7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYXBwbHlFdWxlcjogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgcXVhdGVybmlvbjtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGFwcGx5RXVsZXIoIGV1bGVyICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBldWxlciBpbnN0YW5jZW9mIFRIUkVFLkV1bGVyID09PSBmYWxzZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogLmFwcGx5RXVsZXIoKSBub3cgZXhwZWN0cyBhIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBxdWF0ZXJuaW9uID09PSB1bmRlZmluZWQgKSBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLnNldEZyb21FdWxlciggZXVsZXIgKSApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIGFwcGx5QXhpc0FuZ2xlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBxdWF0ZXJuaW9uO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gYXBwbHlBeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBxdWF0ZXJuaW9uID09PSB1bmRlZmluZWQgKSBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICkgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBhcHBseU1hdHJpeDM6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcbiAgICAgICAgdmFyIHggPSB0aGlzLng7XHJcbiAgICAgICAgdmFyIHkgPSB0aGlzLnk7XHJcbiAgICAgICAgdmFyIHogPSB0aGlzLno7XHJcblxyXG4gICAgICAgIHZhciBlID0gbS5lbGVtZW50cztcclxuXHJcbiAgICAgICAgdGhpcy54ID0gZVsgMCBdICogeCArIGVbIDMgXSAqIHkgKyBlWyA2IF0gKiB6O1xyXG4gICAgICAgIHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgNyBdICogejtcclxuICAgICAgICB0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDggXSAqIHo7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG4gICAgICAgIC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0IGFmZmluZSBtYXRyaXhcclxuXHJcbiAgICAgICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XHJcblxyXG4gICAgICAgIHZhciBlID0gbS5lbGVtZW50cztcclxuXHJcbiAgICAgICAgdGhpcy54ID0gZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gICogeiArIGVbIDEyIF07XHJcbiAgICAgICAgdGhpcy55ID0gZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gICogeiArIGVbIDEzIF07XHJcbiAgICAgICAgdGhpcy56ID0gZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF07XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYXBwbHlQcm9qZWN0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG4gICAgICAgIC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0IHByb2plY3Rpb24gbWF0cml4XHJcblxyXG4gICAgICAgIHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xyXG5cclxuICAgICAgICB2YXIgZSA9IG0uZWxlbWVudHM7XHJcbiAgICAgICAgdmFyIGQgPSAxIC8gKCBlWyAzIF0gKiB4ICsgZVsgNyBdICogeSArIGVbIDExIF0gKiB6ICsgZVsgMTUgXSApOyAvLyBwZXJzcGVjdGl2ZSBkaXZpZGVcclxuXHJcbiAgICAgICAgdGhpcy54ID0gKCBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAgKiB6ICsgZVsgMTIgXSApICogZDtcclxuICAgICAgICB0aGlzLnkgPSAoIGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICAqIHogKyBlWyAxMyBdICkgKiBkO1xyXG4gICAgICAgIHRoaXMueiA9ICggZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF0gKSAqIGQ7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYXBwbHlRdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XHJcblxyXG4gICAgICAgIHZhciB4ID0gdGhpcy54O1xyXG4gICAgICAgIHZhciB5ID0gdGhpcy55O1xyXG4gICAgICAgIHZhciB6ID0gdGhpcy56O1xyXG5cclxuICAgICAgICB2YXIgcXggPSBxLng7XHJcbiAgICAgICAgdmFyIHF5ID0gcS55O1xyXG4gICAgICAgIHZhciBxeiA9IHEuejtcclxuICAgICAgICB2YXIgcXcgPSBxLnc7XHJcblxyXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjdG9yXHJcblxyXG4gICAgICAgIHZhciBpeCA9ICBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHk7XHJcbiAgICAgICAgdmFyIGl5ID0gIHF3ICogeSArIHF6ICogeCAtIHF4ICogejtcclxuICAgICAgICB2YXIgaXogPSAgcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4O1xyXG4gICAgICAgIHZhciBpdyA9IC0gcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xyXG5cclxuICAgICAgICAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XHJcblxyXG4gICAgICAgIHRoaXMueCA9IGl4ICogcXcgKyBpdyAqIC0gcXggKyBpeSAqIC0gcXogLSBpeiAqIC0gcXk7XHJcbiAgICAgICAgdGhpcy55ID0gaXkgKiBxdyArIGl3ICogLSBxeSArIGl6ICogLSBxeCAtIGl4ICogLSBxejtcclxuICAgICAgICB0aGlzLnogPSBpeiAqIHF3ICsgaXcgKiAtIHF6ICsgaXggKiAtIHF5IC0gaXkgKiAtIHF4O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHByb2plY3Q6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIG1hdHJpeDtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHByb2plY3QoIGNhbWVyYSApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggbWF0cml4ID09PSB1bmRlZmluZWQgKSBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuICAgICAgICAgICAgbWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBtYXRyaXguZ2V0SW52ZXJzZSggY2FtZXJhLm1hdHJpeFdvcmxkICkgKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlQcm9qZWN0aW9uKCBtYXRyaXggKTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgdW5wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBtYXRyaXg7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiB1bnByb2plY3QoIGNhbWVyYSApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggbWF0cml4ID09PSB1bmRlZmluZWQgKSBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuICAgICAgICAgICAgbWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZCwgbWF0cml4LmdldEludmVyc2UoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICkgKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlQcm9qZWN0aW9uKCBtYXRyaXggKTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgdHJhbnNmb3JtRGlyZWN0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG4gICAgICAgIC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0IGFmZmluZSBtYXRyaXhcclxuICAgICAgICAvLyB2ZWN0b3IgaW50ZXJwcmV0ZWQgYXMgYSBkaXJlY3Rpb25cclxuXHJcbiAgICAgICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XHJcblxyXG4gICAgICAgIHZhciBlID0gbS5lbGVtZW50cztcclxuXHJcbiAgICAgICAgdGhpcy54ID0gZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gICogejtcclxuICAgICAgICB0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAgKiB6O1xyXG4gICAgICAgIHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHo7XHJcblxyXG4gICAgICAgIHRoaXMubm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZGl2aWRlOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCAvPSB2Lng7XHJcbiAgICAgICAgdGhpcy55IC89IHYueTtcclxuICAgICAgICB0aGlzLnogLz0gdi56O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRpdmlkZVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCAxIC8gc2NhbGFyICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBtaW46IGZ1bmN0aW9uICggdiApIHtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gTWF0aC5taW4oIHRoaXMueCwgdi54ICk7XHJcbiAgICAgICAgdGhpcy55ID0gTWF0aC5taW4oIHRoaXMueSwgdi55ICk7XHJcbiAgICAgICAgdGhpcy56ID0gTWF0aC5taW4oIHRoaXMueiwgdi56ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbWF4OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IE1hdGgubWF4KCB0aGlzLngsIHYueCApO1xyXG4gICAgICAgIHRoaXMueSA9IE1hdGgubWF4KCB0aGlzLnksIHYueSApO1xyXG4gICAgICAgIHRoaXMueiA9IE1hdGgubWF4KCB0aGlzLnosIHYueiApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNsYW1wOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xyXG5cclxuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgbWluIDwgbWF4LCBpZiB0aGlzIGFzc3VtcHRpb24gaXNuJ3QgdHJ1ZSBpdCB3aWxsIG5vdCBvcGVyYXRlIGNvcnJlY3RseVxyXG5cclxuICAgICAgICB0aGlzLnggPSBNYXRoLm1heCggbWluLngsIE1hdGgubWluKCBtYXgueCwgdGhpcy54ICkgKTtcclxuICAgICAgICB0aGlzLnkgPSBNYXRoLm1heCggbWluLnksIE1hdGgubWluKCBtYXgueSwgdGhpcy55ICkgKTtcclxuICAgICAgICB0aGlzLnogPSBNYXRoLm1heCggbWluLnosIE1hdGgubWluKCBtYXgueiwgdGhpcy56ICkgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjbGFtcFNjYWxhcjogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgbWluLCBtYXg7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjbGFtcFNjYWxhciggbWluVmFsLCBtYXhWYWwgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG1pbiA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIG1pbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgICAgICAgICBtYXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbWluLnNldCggbWluVmFsLCBtaW5WYWwsIG1pblZhbCApO1xyXG4gICAgICAgICAgICBtYXguc2V0KCBtYXhWYWwsIG1heFZhbCwgbWF4VmFsICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGFtcCggbWluLCBtYXggKTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgY2xhbXBMZW5ndGg6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xyXG5cclxuICAgICAgICB0aGlzLm11bHRpcGx5U2NhbGFyKCBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCBsZW5ndGggKSApIC8gbGVuZ3RoICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XHJcbiAgICAgICAgdGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XHJcbiAgICAgICAgdGhpcy56ID0gTWF0aC5mbG9vciggdGhpcy56ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2VpbDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xyXG4gICAgICAgIHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XHJcbiAgICAgICAgdGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICByb3VuZDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0aGlzLnggPSBNYXRoLnJvdW5kKCB0aGlzLnggKTtcclxuICAgICAgICB0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcclxuICAgICAgICB0aGlzLnogPSBNYXRoLnJvdW5kKCB0aGlzLnogKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICByb3VuZFRvWmVybzogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0aGlzLnggPSAoIHRoaXMueCA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy54ICkgOiBNYXRoLmZsb29yKCB0aGlzLnggKTtcclxuICAgICAgICB0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcclxuICAgICAgICB0aGlzLnogPSAoIHRoaXMueiA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy56ICkgOiBNYXRoLmZsb29yKCB0aGlzLnogKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBuZWdhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gLSB0aGlzLng7XHJcbiAgICAgICAgdGhpcy55ID0gLSB0aGlzLnk7XHJcbiAgICAgICAgdGhpcy56ID0gLSB0aGlzLno7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZG90OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2LnkgKyB0aGlzLnogKiB2Lno7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbGVuZ3RoTWFuaGF0dGFuOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICkgKyBNYXRoLmFicyggdGhpcy56ICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRMZW5ndGg6IGZ1bmN0aW9uICggbGVuZ3RoICkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggbGVuZ3RoIC8gdGhpcy5sZW5ndGgoKSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbGVycDogZnVuY3Rpb24gKCB2LCBhbHBoYSApIHtcclxuXHJcbiAgICAgICAgdGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcclxuICAgICAgICB0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xyXG4gICAgICAgIHRoaXMueiArPSAoIHYueiAtIHRoaXMueiApICogYWxwaGE7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbGVycFZlY3RvcnM6IGZ1bmN0aW9uICggdjEsIHYyLCBhbHBoYSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5zdWJWZWN0b3JzKCB2MiwgdjEgKS5tdWx0aXBseVNjYWxhciggYWxwaGEgKS5hZGQoIHYxICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY3Jvc3M6IGZ1bmN0aW9uICggdiwgdyApIHtcclxuXHJcbiAgICAgICAgaWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuY3Jvc3MoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5jcm9zc1ZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3Jvc3NWZWN0b3JzKCB2LCB3ICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHkgKiB2LnogLSB6ICogdi55O1xyXG4gICAgICAgIHRoaXMueSA9IHogKiB2LnggLSB4ICogdi56O1xyXG4gICAgICAgIHRoaXMueiA9IHggKiB2LnkgLSB5ICogdi54O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNyb3NzVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuICAgICAgICB2YXIgYXggPSBhLngsIGF5ID0gYS55LCBheiA9IGEuejtcclxuICAgICAgICB2YXIgYnggPSBiLngsIGJ5ID0gYi55LCBieiA9IGIuejtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gYXkgKiBieiAtIGF6ICogYnk7XHJcbiAgICAgICAgdGhpcy55ID0gYXogKiBieCAtIGF4ICogYno7XHJcbiAgICAgICAgdGhpcy56ID0gYXggKiBieSAtIGF5ICogYng7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcHJvamVjdE9uVmVjdG9yOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciB2MSwgZG90O1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcHJvamVjdE9uVmVjdG9yKCB2ZWN0b3IgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgICAgICB2MS5jb3B5KCB2ZWN0b3IgKS5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAgICAgICAgIGRvdCA9IHRoaXMuZG90KCB2MSApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29weSggdjEgKS5tdWx0aXBseVNjYWxhciggZG90ICk7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIHByb2plY3RPblBsYW5lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciB2MTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHByb2plY3RPblBsYW5lKCBwbGFuZU5vcm1hbCApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgICAgIHYxLmNvcHkoIHRoaXMgKS5wcm9qZWN0T25WZWN0b3IoIHBsYW5lTm9ybWFsICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdWIoIHYxICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgcmVmbGVjdDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAvLyByZWZsZWN0IGluY2lkZW50IHZlY3RvciBvZmYgcGxhbmUgb3J0aG9nb25hbCB0byBub3JtYWxcclxuICAgICAgICAvLyBub3JtYWwgaXMgYXNzdW1lZCB0byBoYXZlIHVuaXQgbGVuZ3RoXHJcblxyXG4gICAgICAgIHZhciB2MTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlZmxlY3QoIG5vcm1hbCApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YiggdjEuY29weSggbm9ybWFsICkubXVsdGlwbHlTY2FsYXIoIDIgKiB0aGlzLmRvdCggbm9ybWFsICkgKSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIGFuZ2xlVG86IGZ1bmN0aW9uICggdiApIHtcclxuXHJcbiAgICAgICAgdmFyIHRoZXRhID0gdGhpcy5kb3QoIHYgKSAvICggdGhpcy5sZW5ndGgoKSAqIHYubGVuZ3RoKCkgKTtcclxuXHJcbiAgICAgICAgLy8gY2xhbXAsIHRvIGhhbmRsZSBudW1lcmljYWwgcHJvYmxlbXNcclxuXHJcbiAgICAgICAgcmV0dXJuIE1hdGguYWNvcyggVEhSRUUuTWF0aC5jbGFtcCggdGhldGEsIC0gMSwgMSApICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBkaXN0YW5jZVRvOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZGlzdGFuY2VUb1NxdWFyZWQ6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcbiAgICAgICAgdmFyIGR4ID0gdGhpcy54IC0gdi54O1xyXG4gICAgICAgIHZhciBkeSA9IHRoaXMueSAtIHYueTtcclxuICAgICAgICB2YXIgZHogPSB0aGlzLnogLSB2Lno7XHJcblxyXG4gICAgICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHo7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRFdWxlckZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCBtLCBvcmRlciApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLlZlY3RvcjM6IC5zZXRFdWxlckZyb21Sb3RhdGlvbk1hdHJpeCgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBFdWxlci5zZXRGcm9tUm90YXRpb25NYXRyaXgoKSBpbnN0ZWFkLicgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldEV1bGVyRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSwgb3JkZXIgKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5WZWN0b3IzOiAuc2V0RXVsZXJGcm9tUXVhdGVybmlvbigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBFdWxlci5zZXRGcm9tUXVhdGVybmlvbigpIGluc3RlYWQuJyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0UG9zaXRpb25Gcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5nZXRQb3NpdGlvbkZyb21NYXRyaXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRGcm9tTWF0cml4UG9zaXRpb24oKS4nICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0U2NhbGVGcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5nZXRTY2FsZUZyb21NYXRyaXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRGcm9tTWF0cml4U2NhbGUoKS4nICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnNldEZyb21NYXRyaXhTY2FsZSggbSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0Q29sdW1uRnJvbU1hdHJpeDogZnVuY3Rpb24gKCBpbmRleCwgbWF0cml4ICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuZ2V0Q29sdW1uRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhDb2x1bW4oKS4nICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIGluZGV4LCBtYXRyaXggKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZyb21NYXRyaXhQb3NpdGlvbjogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuICAgICAgICB0aGlzLnggPSBtLmVsZW1lbnRzWyAxMiBdO1xyXG4gICAgICAgIHRoaXMueSA9IG0uZWxlbWVudHNbIDEzIF07XHJcbiAgICAgICAgdGhpcy56ID0gbS5lbGVtZW50c1sgMTQgXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRGcm9tTWF0cml4U2NhbGU6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcbiAgICAgICAgdmFyIHN4ID0gdGhpcy5zZXQoIG0uZWxlbWVudHNbIDAgXSwgbS5lbGVtZW50c1sgMSBdLCBtLmVsZW1lbnRzWyAyIF0gKS5sZW5ndGgoKTtcclxuICAgICAgICB2YXIgc3kgPSB0aGlzLnNldCggbS5lbGVtZW50c1sgNCBdLCBtLmVsZW1lbnRzWyA1IF0sIG0uZWxlbWVudHNbIDYgXSApLmxlbmd0aCgpO1xyXG4gICAgICAgIHZhciBzeiA9IHRoaXMuc2V0KCBtLmVsZW1lbnRzWyA4IF0sIG0uZWxlbWVudHNbIDkgXSwgbS5lbGVtZW50c1sgMTAgXSApLmxlbmd0aCgpO1xyXG5cclxuICAgICAgICB0aGlzLnggPSBzeDtcclxuICAgICAgICB0aGlzLnkgPSBzeTtcclxuICAgICAgICB0aGlzLnogPSBzejtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRGcm9tTWF0cml4Q29sdW1uOiBmdW5jdGlvbiAoIGluZGV4LCBtYXRyaXggKSB7XHJcblxyXG4gICAgICAgIHZhciBvZmZzZXQgPSBpbmRleCAqIDQ7XHJcblxyXG4gICAgICAgIHZhciBtZSA9IG1hdHJpeC5lbGVtZW50cztcclxuXHJcbiAgICAgICAgdGhpcy54ID0gbWVbIG9mZnNldCBdO1xyXG4gICAgICAgIHRoaXMueSA9IG1lWyBvZmZzZXQgKyAxIF07XHJcbiAgICAgICAgdGhpcy56ID0gbWVbIG9mZnNldCArIDIgXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBlcXVhbHM6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSAmJiAoIHYueiA9PT0gdGhpcy56ICkgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xyXG4gICAgICAgIHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XHJcbiAgICAgICAgdGhpcy56ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG4gICAgICAgIGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XHJcbiAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcclxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy55O1xyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLno7XHJcblxyXG4gICAgICAgIHJldHVybiBhcnJheTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGZyb21BdHRyaWJ1dGU6IGZ1bmN0aW9uICggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICkge1xyXG5cclxuICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcbiAgICAgICAgaW5kZXggPSBpbmRleCAqIGF0dHJpYnV0ZS5pdGVtU2l6ZSArIG9mZnNldDtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCBdO1xyXG4gICAgICAgIHRoaXMueSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAxIF07XHJcbiAgICAgICAgdGhpcy56ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCArIDIgXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGgvVmVjdG9yNC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igc3VwZXJlZ2diZXJ0IC8gaHR0cDovL3d3dy5wYXVsYnJ1bnQuY28udWsvXHJcbiAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKi9cclxuXHJcblRIUkVFLlZlY3RvcjQgPSBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XHJcblxyXG4gICAgdGhpcy54ID0geCB8fCAwO1xyXG4gICAgdGhpcy55ID0geSB8fCAwO1xyXG4gICAgdGhpcy56ID0geiB8fCAwO1xyXG4gICAgdGhpcy53ID0gKCB3ICE9PSB1bmRlZmluZWQgKSA/IHcgOiAxO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlZlY3RvcjQucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5WZWN0b3I0LFxyXG5cclxuICAgIHNldDogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xyXG5cclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgdGhpcy56ID0gejtcclxuICAgICAgICB0aGlzLncgPSB3O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldFg6IGZ1bmN0aW9uICggeCApIHtcclxuXHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRZOiBmdW5jdGlvbiAoIHkgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0WjogZnVuY3Rpb24gKCB6ICkge1xyXG5cclxuICAgICAgICB0aGlzLnogPSB6O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldFc6IGZ1bmN0aW9uICggdyApIHtcclxuXHJcbiAgICAgICAgdGhpcy53ID0gdztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXgsIHZhbHVlICkge1xyXG5cclxuICAgICAgICBzd2l0Y2ggKCBpbmRleCApIHtcclxuXHJcbiAgICAgICAgICAgIGNhc2UgMDogdGhpcy54ID0gdmFsdWU7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOiB0aGlzLnogPSB2YWx1ZTsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMzogdGhpcy53ID0gdmFsdWU7IGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG4gICAgICAgIHN3aXRjaCAoIGluZGV4ICkge1xyXG5cclxuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gdGhpcy54O1xyXG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiB0aGlzLnk7XHJcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIHRoaXMuejtcclxuICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gdGhpcy53O1xyXG4gICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMueCwgdGhpcy55LCB0aGlzLnosIHRoaXMudyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29weTogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuICAgICAgICB0aGlzLnggPSB2Lng7XHJcbiAgICAgICAgdGhpcy55ID0gdi55O1xyXG4gICAgICAgIHRoaXMueiA9IHYuejtcclxuICAgICAgICB0aGlzLncgPSAoIHYudyAhPT0gdW5kZWZpbmVkICkgPyB2LncgOiAxO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuICAgICAgICBpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjQ6IC5hZGQoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5hZGRWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZFZlY3RvcnMoIHYsIHcgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnggKz0gdi54O1xyXG4gICAgICAgIHRoaXMueSArPSB2Lnk7XHJcbiAgICAgICAgdGhpcy56ICs9IHYuejtcclxuICAgICAgICB0aGlzLncgKz0gdi53O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuICAgICAgICB0aGlzLnggKz0gcztcclxuICAgICAgICB0aGlzLnkgKz0gcztcclxuICAgICAgICB0aGlzLnogKz0gcztcclxuICAgICAgICB0aGlzLncgKz0gcztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhZGRWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IGEueCArIGIueDtcclxuICAgICAgICB0aGlzLnkgPSBhLnkgKyBiLnk7XHJcbiAgICAgICAgdGhpcy56ID0gYS56ICsgYi56O1xyXG4gICAgICAgIHRoaXMudyA9IGEudyArIGIudztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhZGRTY2FsZWRWZWN0b3I6IGZ1bmN0aW9uICggdiwgcyApIHtcclxuXHJcbiAgICAgICAgdGhpcy54ICs9IHYueCAqIHM7XHJcbiAgICAgICAgdGhpcy55ICs9IHYueSAqIHM7XHJcbiAgICAgICAgdGhpcy56ICs9IHYueiAqIHM7XHJcbiAgICAgICAgdGhpcy53ICs9IHYudyAqIHM7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc3ViOiBmdW5jdGlvbiAoIHYsIHcgKSB7XHJcblxyXG4gICAgICAgIGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yNDogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdiwgdyApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMueCAtPSB2Lng7XHJcbiAgICAgICAgdGhpcy55IC09IHYueTtcclxuICAgICAgICB0aGlzLnogLT0gdi56O1xyXG4gICAgICAgIHRoaXMudyAtPSB2Lnc7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc3ViU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCAtPSBzO1xyXG4gICAgICAgIHRoaXMueSAtPSBzO1xyXG4gICAgICAgIHRoaXMueiAtPSBzO1xyXG4gICAgICAgIHRoaXMudyAtPSBzO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHN1YlZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gYS54IC0gYi54O1xyXG4gICAgICAgIHRoaXMueSA9IGEueSAtIGIueTtcclxuICAgICAgICB0aGlzLnogPSBhLnogLSBiLno7XHJcbiAgICAgICAgdGhpcy53ID0gYS53IC0gYi53O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcclxuXHJcbiAgICAgICAgaWYgKCBpc0Zpbml0ZSggc2NhbGFyICkgKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCAqPSBzY2FsYXI7XHJcbiAgICAgICAgICAgIHRoaXMueSAqPSBzY2FsYXI7XHJcbiAgICAgICAgICAgIHRoaXMueiAqPSBzY2FsYXI7XHJcbiAgICAgICAgICAgIHRoaXMudyAqPSBzY2FsYXI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy54ID0gMDtcclxuICAgICAgICAgICAgdGhpcy55ID0gMDtcclxuICAgICAgICAgICAgdGhpcy56ID0gMDtcclxuICAgICAgICAgICAgdGhpcy53ID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG4gICAgICAgIHZhciB4ID0gdGhpcy54O1xyXG4gICAgICAgIHZhciB5ID0gdGhpcy55O1xyXG4gICAgICAgIHZhciB6ID0gdGhpcy56O1xyXG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xyXG5cclxuICAgICAgICB2YXIgZSA9IG0uZWxlbWVudHM7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICogeiArIGVbIDEyIF0gKiB3O1xyXG4gICAgICAgIHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICogeiArIGVbIDEzIF0gKiB3O1xyXG4gICAgICAgIHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHogKyBlWyAxNCBdICogdztcclxuICAgICAgICB0aGlzLncgPSBlWyAzIF0gKiB4ICsgZVsgNyBdICogeSArIGVbIDExIF0gKiB6ICsgZVsgMTUgXSAqIHc7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIDEgLyBzY2FsYXIgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldEF4aXNBbmdsZUZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XHJcblxyXG4gICAgICAgIC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9xdWF0ZXJuaW9uVG9BbmdsZS9pbmRleC5odG1cclxuXHJcbiAgICAgICAgLy8gcSBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcclxuXHJcbiAgICAgICAgdGhpcy53ID0gMiAqIE1hdGguYWNvcyggcS53ICk7XHJcblxyXG4gICAgICAgIHZhciBzID0gTWF0aC5zcXJ0KCAxIC0gcS53ICogcS53ICk7XHJcblxyXG4gICAgICAgIGlmICggcyA8IDAuMDAwMSApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMueCA9IDE7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMueiA9IDA7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnggPSBxLnggLyBzO1xyXG4gICAgICAgICAgICB0aGlzLnkgPSBxLnkgLyBzO1xyXG4gICAgICAgICAgICB0aGlzLnogPSBxLnogLyBzO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0QXhpc0FuZ2xlRnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG4gICAgICAgIC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb0FuZ2xlL2luZGV4Lmh0bVxyXG5cclxuICAgICAgICAvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxyXG5cclxuICAgICAgICB2YXIgYW5nbGUsIHgsIHksIHosXHRcdC8vIHZhcmlhYmxlcyBmb3IgcmVzdWx0XHJcbiAgICAgICAgICAgIGVwc2lsb24gPSAwLjAxLFx0XHQvLyBtYXJnaW4gdG8gYWxsb3cgZm9yIHJvdW5kaW5nIGVycm9yc1xyXG4gICAgICAgICAgICBlcHNpbG9uMiA9IDAuMSxcdFx0Ly8gbWFyZ2luIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gMCBhbmQgMTgwIGRlZ3JlZXNcclxuXHJcbiAgICAgICAgICAgIHRlID0gbS5lbGVtZW50cyxcclxuXHJcbiAgICAgICAgICAgIG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF0sXHJcbiAgICAgICAgICAgIG0yMSA9IHRlWyAxIF0sIG0yMiA9IHRlWyA1IF0sIG0yMyA9IHRlWyA5IF0sXHJcbiAgICAgICAgICAgIG0zMSA9IHRlWyAyIF0sIG0zMiA9IHRlWyA2IF0sIG0zMyA9IHRlWyAxMCBdO1xyXG5cclxuICAgICAgICBpZiAoICggTWF0aC5hYnMoIG0xMiAtIG0yMSApIDwgZXBzaWxvbiApXHJcbiAgICAgICAgICAgICYmICggTWF0aC5hYnMoIG0xMyAtIG0zMSApIDwgZXBzaWxvbiApXHJcbiAgICAgICAgICAgICYmICggTWF0aC5hYnMoIG0yMyAtIG0zMiApIDwgZXBzaWxvbiApICkge1xyXG5cclxuICAgICAgICAgICAgLy8gc2luZ3VsYXJpdHkgZm91bmRcclxuICAgICAgICAgICAgLy8gZmlyc3QgY2hlY2sgZm9yIGlkZW50aXR5IG1hdHJpeCB3aGljaCBtdXN0IGhhdmUgKzEgZm9yIGFsbCB0ZXJtc1xyXG4gICAgICAgICAgICAvLyBpbiBsZWFkaW5nIGRpYWdvbmFsIGFuZCB6ZXJvIGluIG90aGVyIHRlcm1zXHJcblxyXG4gICAgICAgICAgICBpZiAoICggTWF0aC5hYnMoIG0xMiArIG0yMSApIDwgZXBzaWxvbjIgKVxyXG4gICAgICAgICAgICAgICAgJiYgKCBNYXRoLmFicyggbTEzICsgbTMxICkgPCBlcHNpbG9uMiApXHJcbiAgICAgICAgICAgICAgICAmJiAoIE1hdGguYWJzKCBtMjMgKyBtMzIgKSA8IGVwc2lsb24yIClcclxuICAgICAgICAgICAgICAgICYmICggTWF0aC5hYnMoIG0xMSArIG0yMiArIG0zMyAtIDMgKSA8IGVwc2lsb24yICkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBzaW5ndWxhcml0eSBpcyBpZGVudGl0eSBtYXRyaXggc28gYW5nbGUgPSAwXHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoIDEsIDAsIDAsIDAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gemVybyBhbmdsZSwgYXJiaXRyYXJ5IGF4aXNcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSB0aGlzIHNpbmd1bGFyaXR5IGlzIGFuZ2xlID0gMTgwXHJcblxyXG4gICAgICAgICAgICBhbmdsZSA9IE1hdGguUEk7XHJcblxyXG4gICAgICAgICAgICB2YXIgeHggPSAoIG0xMSArIDEgKSAvIDI7XHJcbiAgICAgICAgICAgIHZhciB5eSA9ICggbTIyICsgMSApIC8gMjtcclxuICAgICAgICAgICAgdmFyIHp6ID0gKCBtMzMgKyAxICkgLyAyO1xyXG4gICAgICAgICAgICB2YXIgeHkgPSAoIG0xMiArIG0yMSApIC8gNDtcclxuICAgICAgICAgICAgdmFyIHh6ID0gKCBtMTMgKyBtMzEgKSAvIDQ7XHJcbiAgICAgICAgICAgIHZhciB5eiA9ICggbTIzICsgbTMyICkgLyA0O1xyXG5cclxuICAgICAgICAgICAgaWYgKCAoIHh4ID4geXkgKSAmJiAoIHh4ID4genogKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBtMTEgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICggeHggPCBlcHNpbG9uICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB5ID0gMC43MDcxMDY3ODE7XHJcbiAgICAgICAgICAgICAgICAgICAgeiA9IDAuNzA3MTA2NzgxO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHggPSBNYXRoLnNxcnQoIHh4ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IHh5IC8geDtcclxuICAgICAgICAgICAgICAgICAgICB6ID0geHogLyB4O1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHl5ID4genogKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbTIyIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHl5IDwgZXBzaWxvbiApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IDAuNzA3MTA2NzgxO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHogPSAwLjcwNzEwNjc4MTtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB5ID0gTWF0aC5zcXJ0KCB5eSApO1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSB4eSAvIHk7XHJcbiAgICAgICAgICAgICAgICAgICAgeiA9IHl6IC8geTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG0zMyBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtIHNvIGJhc2UgcmVzdWx0IG9uIHRoaXNcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHp6IDwgZXBzaWxvbiApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IDAuNzA3MTA2NzgxO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSAwLjcwNzEwNjc4MTtcclxuICAgICAgICAgICAgICAgICAgICB6ID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB6ID0gTWF0aC5zcXJ0KCB6eiApO1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSB4eiAvIHo7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IHl6IC8gejtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNldCggeCwgeSwgeiwgYW5nbGUgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyByZXR1cm4gMTgwIGRlZyByb3RhdGlvblxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGFzIHdlIGhhdmUgcmVhY2hlZCBoZXJlIHRoZXJlIGFyZSBubyBzaW5ndWxhcml0aWVzIHNvIHdlIGNhbiBoYW5kbGUgbm9ybWFsbHlcclxuXHJcbiAgICAgICAgdmFyIHMgPSBNYXRoLnNxcnQoICggbTMyIC0gbTIzICkgKiAoIG0zMiAtIG0yMyApXHJcbiAgICAgICAgICAgICsgKCBtMTMgLSBtMzEgKSAqICggbTEzIC0gbTMxIClcclxuICAgICAgICAgICAgKyAoIG0yMSAtIG0xMiApICogKCBtMjEgLSBtMTIgKSApOyAvLyB1c2VkIHRvIG5vcm1hbGl6ZVxyXG5cclxuICAgICAgICBpZiAoIE1hdGguYWJzKCBzICkgPCAwLjAwMSApIHMgPSAxO1xyXG5cclxuICAgICAgICAvLyBwcmV2ZW50IGRpdmlkZSBieSB6ZXJvLCBzaG91bGQgbm90IGhhcHBlbiBpZiBtYXRyaXggaXMgb3J0aG9nb25hbCBhbmQgc2hvdWxkIGJlXHJcbiAgICAgICAgLy8gY2F1Z2h0IGJ5IHNpbmd1bGFyaXR5IHRlc3QgYWJvdmUsIGJ1dCBJJ3ZlIGxlZnQgaXQgaW4ganVzdCBpbiBjYXNlXHJcblxyXG4gICAgICAgIHRoaXMueCA9ICggbTMyIC0gbTIzICkgLyBzO1xyXG4gICAgICAgIHRoaXMueSA9ICggbTEzIC0gbTMxICkgLyBzO1xyXG4gICAgICAgIHRoaXMueiA9ICggbTIxIC0gbTEyICkgLyBzO1xyXG4gICAgICAgIHRoaXMudyA9IE1hdGguYWNvcyggKCBtMTEgKyBtMjIgKyBtMzMgLSAxICkgLyAyICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbWluOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IE1hdGgubWluKCB0aGlzLngsIHYueCApO1xyXG4gICAgICAgIHRoaXMueSA9IE1hdGgubWluKCB0aGlzLnksIHYueSApO1xyXG4gICAgICAgIHRoaXMueiA9IE1hdGgubWluKCB0aGlzLnosIHYueiApO1xyXG4gICAgICAgIHRoaXMudyA9IE1hdGgubWluKCB0aGlzLncsIHYudyApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG1heDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuICAgICAgICB0aGlzLnggPSBNYXRoLm1heCggdGhpcy54LCB2LnggKTtcclxuICAgICAgICB0aGlzLnkgPSBNYXRoLm1heCggdGhpcy55LCB2LnkgKTtcclxuICAgICAgICB0aGlzLnogPSBNYXRoLm1heCggdGhpcy56LCB2LnogKTtcclxuICAgICAgICB0aGlzLncgPSBNYXRoLm1heCggdGhpcy53LCB2LncgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjbGFtcDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcclxuXHJcbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIG1pbiA8IG1heCwgaWYgdGhpcyBhc3N1bXB0aW9uIGlzbid0IHRydWUgaXQgd2lsbCBub3Qgb3BlcmF0ZSBjb3JyZWN0bHlcclxuXHJcbiAgICAgICAgdGhpcy54ID0gTWF0aC5tYXgoIG1pbi54LCBNYXRoLm1pbiggbWF4LngsIHRoaXMueCApICk7XHJcbiAgICAgICAgdGhpcy55ID0gTWF0aC5tYXgoIG1pbi55LCBNYXRoLm1pbiggbWF4LnksIHRoaXMueSApICk7XHJcbiAgICAgICAgdGhpcy56ID0gTWF0aC5tYXgoIG1pbi56LCBNYXRoLm1pbiggbWF4LnosIHRoaXMueiApICk7XHJcbiAgICAgICAgdGhpcy53ID0gTWF0aC5tYXgoIG1pbi53LCBNYXRoLm1pbiggbWF4LncsIHRoaXMudyApICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2xhbXBTY2FsYXI6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIG1pbiwgbWF4O1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBtaW4gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBtaW4gPSBuZXcgVEhSRUUuVmVjdG9yNCgpO1xyXG4gICAgICAgICAgICAgICAgbWF4ID0gbmV3IFRIUkVFLlZlY3RvcjQoKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG1pbi5zZXQoIG1pblZhbCwgbWluVmFsLCBtaW5WYWwsIG1pblZhbCApO1xyXG4gICAgICAgICAgICBtYXguc2V0KCBtYXhWYWwsIG1heFZhbCwgbWF4VmFsLCBtYXhWYWwgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsYW1wKCBtaW4sIG1heCApO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBmbG9vcjogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0aGlzLnggPSBNYXRoLmZsb29yKCB0aGlzLnggKTtcclxuICAgICAgICB0aGlzLnkgPSBNYXRoLmZsb29yKCB0aGlzLnkgKTtcclxuICAgICAgICB0aGlzLnogPSBNYXRoLmZsb29yKCB0aGlzLnogKTtcclxuICAgICAgICB0aGlzLncgPSBNYXRoLmZsb29yKCB0aGlzLncgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjZWlsOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XHJcbiAgICAgICAgdGhpcy55ID0gTWF0aC5jZWlsKCB0aGlzLnkgKTtcclxuICAgICAgICB0aGlzLnogPSBNYXRoLmNlaWwoIHRoaXMueiApO1xyXG4gICAgICAgIHRoaXMudyA9IE1hdGguY2VpbCggdGhpcy53ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XHJcbiAgICAgICAgdGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XHJcbiAgICAgICAgdGhpcy56ID0gTWF0aC5yb3VuZCggdGhpcy56ICk7XHJcbiAgICAgICAgdGhpcy53ID0gTWF0aC5yb3VuZCggdGhpcy53ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcm91bmRUb1plcm86IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gKCB0aGlzLnggPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueCApIDogTWF0aC5mbG9vciggdGhpcy54ICk7XHJcbiAgICAgICAgdGhpcy55ID0gKCB0aGlzLnkgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueSApIDogTWF0aC5mbG9vciggdGhpcy55ICk7XHJcbiAgICAgICAgdGhpcy56ID0gKCB0aGlzLnogPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueiApIDogTWF0aC5mbG9vciggdGhpcy56ICk7XHJcbiAgICAgICAgdGhpcy53ID0gKCB0aGlzLncgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMudyApIDogTWF0aC5mbG9vciggdGhpcy53ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbmVnYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IC0gdGhpcy54O1xyXG4gICAgICAgIHRoaXMueSA9IC0gdGhpcy55O1xyXG4gICAgICAgIHRoaXMueiA9IC0gdGhpcy56O1xyXG4gICAgICAgIHRoaXMudyA9IC0gdGhpcy53O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRvdDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56ICsgdGhpcy53ICogdi53O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGxlbmd0aDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLncgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGxlbmd0aE1hbmhhdHRhbjogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gTWF0aC5hYnMoIHRoaXMueCApICsgTWF0aC5hYnMoIHRoaXMueSApICsgTWF0aC5hYnMoIHRoaXMueiApICsgTWF0aC5hYnMoIHRoaXMudyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0TGVuZ3RoOiBmdW5jdGlvbiAoIGxlbmd0aCApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIGxlbmd0aCAvIHRoaXMubGVuZ3RoKCkgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGxlcnA6IGZ1bmN0aW9uICggdiwgYWxwaGEgKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XHJcbiAgICAgICAgdGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcclxuICAgICAgICB0aGlzLnogKz0gKCB2LnogLSB0aGlzLnogKSAqIGFscGhhO1xyXG4gICAgICAgIHRoaXMudyArPSAoIHYudyAtIHRoaXMudyApICogYWxwaGE7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbGVycFZlY3RvcnM6IGZ1bmN0aW9uICggdjEsIHYyLCBhbHBoYSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5zdWJWZWN0b3JzKCB2MiwgdjEgKS5tdWx0aXBseVNjYWxhciggYWxwaGEgKS5hZGQoIHYxICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZXF1YWxzOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgJiYgKCB2LnogPT09IHRoaXMueiApICYmICggdi53ID09PSB0aGlzLncgKSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG4gICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XHJcbiAgICAgICAgdGhpcy55ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcclxuICAgICAgICB0aGlzLnogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xyXG4gICAgICAgIHRoaXMudyA9IGFycmF5WyBvZmZzZXQgKyAzIF07XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuICAgICAgICBpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xyXG4gICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuICAgICAgICBhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLng7XHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcclxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy56O1xyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0aGlzLnc7XHJcblxyXG4gICAgICAgIHJldHVybiBhcnJheTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGZyb21BdHRyaWJ1dGU6IGZ1bmN0aW9uICggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICkge1xyXG5cclxuICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcbiAgICAgICAgaW5kZXggPSBpbmRleCAqIGF0dHJpYnV0ZS5pdGVtU2l6ZSArIG9mZnNldDtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCBdO1xyXG4gICAgICAgIHRoaXMueSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAxIF07XHJcbiAgICAgICAgdGhpcy56ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCArIDIgXTtcclxuICAgICAgICB0aGlzLncgPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4ICsgMyBdO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9FdWxlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXHJcbiAqL1xyXG5cclxuVEhSRUUuRXVsZXIgPSBmdW5jdGlvbiAoIHgsIHksIHosIG9yZGVyICkge1xyXG5cclxuICAgIHRoaXMuX3ggPSB4IHx8IDA7XHJcbiAgICB0aGlzLl95ID0geSB8fCAwO1xyXG4gICAgdGhpcy5feiA9IHogfHwgMDtcclxuICAgIHRoaXMuX29yZGVyID0gb3JkZXIgfHwgVEhSRUUuRXVsZXIuRGVmYXVsdE9yZGVyO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkV1bGVyLlJvdGF0aW9uT3JkZXJzID0gWyAnWFlaJywgJ1laWCcsICdaWFknLCAnWFpZJywgJ1lYWicsICdaWVgnIF07XHJcblxyXG5USFJFRS5FdWxlci5EZWZhdWx0T3JkZXIgPSAnWFlaJztcclxuXHJcblRIUkVFLkV1bGVyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuRXVsZXIsXHJcblxyXG4gICAgZ2V0IHggKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5feDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldCB4ICggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuX3ggPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldCB5ICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3k7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXQgeSAoIHZhbHVlICkge1xyXG5cclxuICAgICAgICB0aGlzLl95ID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXQgeiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLl96O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0IHogKCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5feiA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0IG9yZGVyICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yZGVyO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0IG9yZGVyICggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuX29yZGVyID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiwgb3JkZXIgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuX3ggPSB4O1xyXG4gICAgICAgIHRoaXMuX3kgPSB5O1xyXG4gICAgICAgIHRoaXMuX3ogPSB6O1xyXG4gICAgICAgIHRoaXMuX29yZGVyID0gb3JkZXIgfHwgdGhpcy5fb3JkZXI7XHJcblxyXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fb3JkZXIpO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29weTogZnVuY3Rpb24gKCBldWxlciApIHtcclxuXHJcbiAgICAgICAgdGhpcy5feCA9IGV1bGVyLl94O1xyXG4gICAgICAgIHRoaXMuX3kgPSBldWxlci5feTtcclxuICAgICAgICB0aGlzLl96ID0gZXVsZXIuX3o7XHJcbiAgICAgICAgdGhpcy5fb3JkZXIgPSBldWxlci5fb3JkZXI7XHJcblxyXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCBtLCBvcmRlciwgdXBkYXRlICkge1xyXG5cclxuICAgICAgICB2YXIgY2xhbXAgPSBUSFJFRS5NYXRoLmNsYW1wO1xyXG5cclxuICAgICAgICAvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxyXG5cclxuICAgICAgICB2YXIgdGUgPSBtLmVsZW1lbnRzO1xyXG4gICAgICAgIHZhciBtMTEgPSB0ZVsgMCBdLCBtMTIgPSB0ZVsgNCBdLCBtMTMgPSB0ZVsgOCBdO1xyXG4gICAgICAgIHZhciBtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdO1xyXG4gICAgICAgIHZhciBtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXTtcclxuXHJcbiAgICAgICAgb3JkZXIgPSBvcmRlciB8fCB0aGlzLl9vcmRlcjtcclxuXHJcbiAgICAgICAgaWYgKCBvcmRlciA9PT0gJ1hZWicgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl95ID0gTWF0aC5hc2luKCBjbGFtcCggbTEzLCAtIDEsIDEgKSApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBNYXRoLmFicyggbTEzICkgPCAwLjk5OTk5ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTMzICk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0xMSApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMjIgKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ogPSAwO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1lYWicgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl94ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMjMsIC0gMSwgMSApICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIE1hdGguYWJzKCBtMjMgKSA8IDAuOTk5OTkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTMzICk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMjIgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMTEgKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ogPSAwO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pYWScgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl94ID0gTWF0aC5hc2luKCBjbGFtcCggbTMyLCAtIDEsIDEgKSApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBNYXRoLmFicyggbTMyICkgPCAwLjk5OTk5ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTMzICk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0yMiApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl95ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0xMSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pZWCcgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl95ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMzEsIC0gMSwgMSApICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIE1hdGguYWJzKCBtMzEgKSA8IDAuOTk5OTkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTMzICk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMTEgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5feCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0yMiApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1laWCcgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl96ID0gTWF0aC5hc2luKCBjbGFtcCggbTIxLCAtIDEsIDEgKSApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBNYXRoLmFicyggbTIxICkgPCAwLjk5OTk5ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTIyICk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0xMSApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl94ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSBNYXRoLmF0YW4yKCBtMTMsIG0zMyApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1haWScgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl96ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMTIsIC0gMSwgMSApICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIE1hdGguYWJzKCBtMTIgKSA8IDAuOTk5OTkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTIyICk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMTEgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMzMgKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSAwO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuRXVsZXI6IC5zZXRGcm9tUm90YXRpb25NYXRyaXgoKSBnaXZlbiB1bnN1cHBvcnRlZCBvcmRlcjogJyArIG9yZGVyIClcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9vcmRlciA9IG9yZGVyO1xyXG5cclxuICAgICAgICBpZiAoIHVwZGF0ZSAhPT0gZmFsc2UgKSB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRGcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgbWF0cml4O1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCBxLCBvcmRlciwgdXBkYXRlICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBtYXRyaXggPT09IHVuZGVmaW5lZCApIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcbiAgICAgICAgICAgIG1hdHJpeC5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbiggcSApO1xyXG4gICAgICAgICAgICB0aGlzLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbWF0cml4LCBvcmRlciwgdXBkYXRlICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgc2V0RnJvbVZlY3RvcjM6IGZ1bmN0aW9uICggdiwgb3JkZXIgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnNldCggdi54LCB2LnksIHYueiwgb3JkZXIgfHwgdGhpcy5fb3JkZXIgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJlb3JkZXI6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgLy8gV0FSTklORzogdGhpcyBkaXNjYXJkcyByZXZvbHV0aW9uIGluZm9ybWF0aW9uIC1iaG91c3RvblxyXG5cclxuICAgICAgICB2YXIgcSA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIG5ld09yZGVyICkge1xyXG5cclxuICAgICAgICAgICAgcS5zZXRGcm9tRXVsZXIoIHRoaXMgKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRGcm9tUXVhdGVybmlvbiggcSwgbmV3T3JkZXIgKTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgZXF1YWxzOiBmdW5jdGlvbiAoIGV1bGVyICkge1xyXG5cclxuICAgICAgICByZXR1cm4gKCBldWxlci5feCA9PT0gdGhpcy5feCApICYmICggZXVsZXIuX3kgPT09IHRoaXMuX3kgKSAmJiAoIGV1bGVyLl96ID09PSB0aGlzLl96ICkgJiYgKCBldWxlci5fb3JkZXIgPT09IHRoaXMuX29yZGVyICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuX3ggPSBhcnJheVsgMCBdO1xyXG4gICAgICAgIHRoaXMuX3kgPSBhcnJheVsgMSBdO1xyXG4gICAgICAgIHRoaXMuX3ogPSBhcnJheVsgMiBdO1xyXG4gICAgICAgIGlmICggYXJyYXlbIDMgXSAhPT0gdW5kZWZpbmVkICkgdGhpcy5fb3JkZXIgPSBhcnJheVsgMyBdO1xyXG5cclxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG4gICAgICAgIGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XHJcbiAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgXSA9IHRoaXMuX3g7XHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuX3k7XHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuX3o7XHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDMgXSA9IHRoaXMuX29yZGVyO1xyXG5cclxuICAgICAgICByZXR1cm4gYXJyYXk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0b1ZlY3RvcjM6IGZ1bmN0aW9uICggb3B0aW9uYWxSZXN1bHQgKSB7XHJcblxyXG4gICAgICAgIGlmICggb3B0aW9uYWxSZXN1bHQgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uYWxSZXN1bHQuc2V0KCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96ICk7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3ogKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgb25DaGFuZ2U6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XHJcblxyXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG9uQ2hhbmdlQ2FsbGJhY2s6IGZ1bmN0aW9uICgpIHt9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9MaW5lMy5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICovXHJcblxyXG5USFJFRS5MaW5lMyA9IGZ1bmN0aW9uICggc3RhcnQsIGVuZCApIHtcclxuXHJcbiAgICB0aGlzLnN0YXJ0ID0gKCBzdGFydCAhPT0gdW5kZWZpbmVkICkgPyBzdGFydCA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICB0aGlzLmVuZCA9ICggZW5kICE9PSB1bmRlZmluZWQgKSA/IGVuZCA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGluZTMucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5MaW5lMyxcclxuXHJcbiAgICBzZXQ6IGZ1bmN0aW9uICggc3RhcnQsIGVuZCApIHtcclxuXHJcbiAgICAgICAgdGhpcy5zdGFydC5jb3B5KCBzdGFydCApO1xyXG4gICAgICAgIHRoaXMuZW5kLmNvcHkoIGVuZCApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvcHk6IGZ1bmN0aW9uICggbGluZSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5zdGFydC5jb3B5KCBsaW5lLnN0YXJ0ICk7XHJcbiAgICAgICAgdGhpcy5lbmQuY29weSggbGluZS5lbmQgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjZW50ZXI6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5zdGFydCwgdGhpcy5lbmQgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBkZWx0YTogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLmVuZCwgdGhpcy5zdGFydCApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZGlzdGFuY2VTcTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydC5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5lbmQgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRpc3RhbmNlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0LmRpc3RhbmNlVG8oIHRoaXMuZW5kICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhdDogZnVuY3Rpb24gKCB0LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmRlbHRhKCByZXN1bHQgKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy5zdGFydCApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2xvc2VzdFBvaW50VG9Qb2ludFBhcmFtZXRlcjogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgc3RhcnRQID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICB2YXIgc3RhcnRFbmQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCBwb2ludCwgY2xhbXBUb0xpbmUgKSB7XHJcblxyXG4gICAgICAgICAgICBzdGFydFAuc3ViVmVjdG9ycyggcG9pbnQsIHRoaXMuc3RhcnQgKTtcclxuICAgICAgICAgICAgc3RhcnRFbmQuc3ViVmVjdG9ycyggdGhpcy5lbmQsIHRoaXMuc3RhcnQgKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBzdGFydEVuZDIgPSBzdGFydEVuZC5kb3QoIHN0YXJ0RW5kICk7XHJcbiAgICAgICAgICAgIHZhciBzdGFydEVuZF9zdGFydFAgPSBzdGFydEVuZC5kb3QoIHN0YXJ0UCApO1xyXG5cclxuICAgICAgICAgICAgdmFyIHQgPSBzdGFydEVuZF9zdGFydFAgLyBzdGFydEVuZDI7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGNsYW1wVG9MaW5lICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHQgPSBUSFJFRS5NYXRoLmNsYW1wKCB0LCAwLCAxICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdDtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgY2xvc2VzdFBvaW50VG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCwgY2xhbXBUb0xpbmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuICAgICAgICB2YXIgdCA9IHRoaXMuY2xvc2VzdFBvaW50VG9Qb2ludFBhcmFtZXRlciggcG9pbnQsIGNsYW1wVG9MaW5lICk7XHJcblxyXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5kZWx0YSggcmVzdWx0ICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMuc3RhcnQgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XHJcblxyXG4gICAgICAgIHRoaXMuc3RhcnQuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcclxuICAgICAgICB0aGlzLmVuZC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGVxdWFsczogZnVuY3Rpb24gKCBsaW5lICkge1xyXG5cclxuICAgICAgICByZXR1cm4gbGluZS5zdGFydC5lcXVhbHMoIHRoaXMuc3RhcnQgKSAmJiBsaW5lLmVuZC5lcXVhbHMoIHRoaXMuZW5kICk7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGgvQm94Mi5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICovXHJcblxyXG5USFJFRS5Cb3gyID0gZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcclxuXHJcbiAgICB0aGlzLm1pbiA9ICggbWluICE9PSB1bmRlZmluZWQgKSA/IG1pbiA6IG5ldyBUSFJFRS5WZWN0b3IyKCBJbmZpbml0eSwgSW5maW5pdHkgKTtcclxuICAgIHRoaXMubWF4ID0gKCBtYXggIT09IHVuZGVmaW5lZCApID8gbWF4IDogbmV3IFRIUkVFLlZlY3RvcjIoIC0gSW5maW5pdHksIC0gSW5maW5pdHkgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Cb3gyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuQm94MixcclxuXHJcbiAgICBzZXQ6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG4gICAgICAgIHRoaXMubWluLmNvcHkoIG1pbiApO1xyXG4gICAgICAgIHRoaXMubWF4LmNvcHkoIG1heCApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICggcG9pbnRzICkge1xyXG5cclxuICAgICAgICB0aGlzLm1ha2VFbXB0eSgpO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5leHBhbmRCeVBvaW50KCBwb2ludHNbIGkgXSApXHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRGcm9tQ2VudGVyQW5kU2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCBjZW50ZXIsIHNpemUgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgaGFsZlNpemUgPSB2MS5jb3B5KCBzaXplICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xyXG4gICAgICAgICAgICB0aGlzLm1pbi5jb3B5KCBjZW50ZXIgKS5zdWIoIGhhbGZTaXplICk7XHJcbiAgICAgICAgICAgIHRoaXMubWF4LmNvcHkoIGNlbnRlciApLmFkZCggaGFsZlNpemUgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb3B5OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcbiAgICAgICAgdGhpcy5taW4uY29weSggYm94Lm1pbiApO1xyXG4gICAgICAgIHRoaXMubWF4LmNvcHkoIGJveC5tYXggKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBtYWtlRW1wdHk6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdGhpcy5taW4ueCA9IHRoaXMubWluLnkgPSBJbmZpbml0eTtcclxuICAgICAgICB0aGlzLm1heC54ID0gdGhpcy5tYXgueSA9IC0gSW5maW5pdHk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZW1wdHk6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgLy8gdGhpcyBpcyBhIG1vcmUgcm9idXN0IGNoZWNrIGZvciBlbXB0eSB0aGFuICggdm9sdW1lIDw9IDAgKSBiZWNhdXNlIHZvbHVtZSBjYW4gZ2V0IHBvc2l0aXZlIHdpdGggdHdvIG5lZ2F0aXZlIGF4ZXNcclxuXHJcbiAgICAgICAgcmV0dXJuICggdGhpcy5tYXgueCA8IHRoaXMubWluLnggKSB8fCAoIHRoaXMubWF4LnkgPCB0aGlzLm1pbi55ICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjZW50ZXI6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5taW4sIHRoaXMubWF4ICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2l6ZTogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLm1heCwgdGhpcy5taW4gKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGV4cGFuZEJ5UG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG4gICAgICAgIHRoaXMubWluLm1pbiggcG9pbnQgKTtcclxuICAgICAgICB0aGlzLm1heC5tYXgoIHBvaW50ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZXhwYW5kQnlWZWN0b3I6IGZ1bmN0aW9uICggdmVjdG9yICkge1xyXG5cclxuICAgICAgICB0aGlzLm1pbi5zdWIoIHZlY3RvciApO1xyXG4gICAgICAgIHRoaXMubWF4LmFkZCggdmVjdG9yICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZXhwYW5kQnlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuICAgICAgICB0aGlzLm1pbi5hZGRTY2FsYXIoIC0gc2NhbGFyICk7XHJcbiAgICAgICAgdGhpcy5tYXguYWRkU2NhbGFyKCBzY2FsYXIgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb250YWluc1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuICAgICAgICBpZiAoIHBvaW50LnggPCB0aGlzLm1pbi54IHx8IHBvaW50LnggPiB0aGlzLm1heC54IHx8XHJcbiAgICAgICAgICAgIHBvaW50LnkgPCB0aGlzLm1pbi55IHx8IHBvaW50LnkgPiB0aGlzLm1heC55ICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29udGFpbnNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuICAgICAgICBpZiAoICggdGhpcy5taW4ueCA8PSBib3gubWluLnggKSAmJiAoIGJveC5tYXgueCA8PSB0aGlzLm1heC54ICkgJiZcclxuICAgICAgICAgICAgKCB0aGlzLm1pbi55IDw9IGJveC5taW4ueSApICYmICggYm94Lm1heC55IDw9IHRoaXMubWF4LnkgKSApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldFBhcmFtZXRlcjogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG4gICAgICAgIC8vIFRoaXMgY2FuIHBvdGVudGlhbGx5IGhhdmUgYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgYm94XHJcbiAgICAgICAgLy8gaGFzIGEgc2l6ZSBkaW1lbnNpb24gb2YgMC5cclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQuc2V0KFxyXG4gICAgICAgICAgICAoIHBvaW50LnggLSB0aGlzLm1pbi54ICkgLyAoIHRoaXMubWF4LnggLSB0aGlzLm1pbi54ICksXHJcbiAgICAgICAgICAgICggcG9pbnQueSAtIHRoaXMubWluLnkgKSAvICggdGhpcy5tYXgueSAtIHRoaXMubWluLnkgKVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBpc0ludGVyc2VjdGlvbkJveDogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG4gICAgICAgIC8vIHVzaW5nIDYgc3BsaXR0aW5nIHBsYW5lcyB0byBydWxlIG91dCBpbnRlcnNlY3Rpb25zLlxyXG5cclxuICAgICAgICBpZiAoIGJveC5tYXgueCA8IHRoaXMubWluLnggfHwgYm94Lm1pbi54ID4gdGhpcy5tYXgueCB8fFxyXG4gICAgICAgICAgICBib3gubWF4LnkgPCB0aGlzLm1pbi55IHx8IGJveC5taW4ueSA+IHRoaXMubWF4LnkgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjbGFtcFBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBjbGFtcGVkUG9pbnQgPSB2MS5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNsYW1wZWRQb2ludC5zdWIoIHBvaW50ICkubGVuZ3RoKCk7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIGludGVyc2VjdDogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG4gICAgICAgIHRoaXMubWluLm1heCggYm94Lm1pbiApO1xyXG4gICAgICAgIHRoaXMubWF4Lm1pbiggYm94Lm1heCApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHVuaW9uOiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcbiAgICAgICAgdGhpcy5taW4ubWluKCBib3gubWluICk7XHJcbiAgICAgICAgdGhpcy5tYXgubWF4KCBib3gubWF4ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcclxuXHJcbiAgICAgICAgdGhpcy5taW4uYWRkKCBvZmZzZXQgKTtcclxuICAgICAgICB0aGlzLm1heC5hZGQoIG9mZnNldCApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGVxdWFsczogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBib3gubWluLmVxdWFscyggdGhpcy5taW4gKSAmJiBib3gubWF4LmVxdWFscyggdGhpcy5tYXggKTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9Cb3gzLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICovXHJcblxyXG5USFJFRS5Cb3gzID0gZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcclxuXHJcbiAgICB0aGlzLm1pbiA9ICggbWluICE9PSB1bmRlZmluZWQgKSA/IG1pbiA6IG5ldyBUSFJFRS5WZWN0b3IzKCBJbmZpbml0eSwgSW5maW5pdHksIEluZmluaXR5ICk7XHJcbiAgICB0aGlzLm1heCA9ICggbWF4ICE9PSB1bmRlZmluZWQgKSA/IG1heCA6IG5ldyBUSFJFRS5WZWN0b3IzKCAtIEluZmluaXR5LCAtIEluZmluaXR5LCAtIEluZmluaXR5ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQm94My5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkJveDMsXHJcblxyXG4gICAgc2V0OiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xyXG5cclxuICAgICAgICB0aGlzLm1pbi5jb3B5KCBtaW4gKTtcclxuICAgICAgICB0aGlzLm1heC5jb3B5KCBtYXggKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAoIHBvaW50cyApIHtcclxuXHJcbiAgICAgICAgdGhpcy5tYWtlRW1wdHkoKTtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kQnlQb2ludCggcG9pbnRzWyBpIF0gKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZyb21DZW50ZXJBbmRTaXplOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIGNlbnRlciwgc2l6ZSApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBoYWxmU2l6ZSA9IHYxLmNvcHkoIHNpemUgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLm1pbi5jb3B5KCBjZW50ZXIgKS5zdWIoIGhhbGZTaXplICk7XHJcbiAgICAgICAgICAgIHRoaXMubWF4LmNvcHkoIGNlbnRlciApLmFkZCggaGFsZlNpemUgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBzZXRGcm9tT2JqZWN0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIC8vIENvbXB1dGVzIHRoZSB3b3JsZC1heGlzLWFsaWduZWQgYm91bmRpbmcgYm94IG9mIGFuIG9iamVjdCAoaW5jbHVkaW5nIGl0cyBjaGlsZHJlbiksXHJcbiAgICAgICAgLy8gYWNjb3VudGluZyBmb3IgYm90aCB0aGUgb2JqZWN0J3MsIGFuZCBjaGlsZHJlbidzLCB3b3JsZCB0cmFuc2Zvcm1zXHJcblxyXG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICBvYmplY3QudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubWFrZUVtcHR5KCk7XHJcblxyXG4gICAgICAgICAgICBvYmplY3QudHJhdmVyc2UoIGZ1bmN0aW9uICggbm9kZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSBub2RlLmdlb21ldHJ5O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjEuY29weSggdmVydGljZXNbIGkgXSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYxLmFwcGx5TWF0cml4NCggbm9kZS5tYXRyaXhXb3JsZCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLmV4cGFuZEJ5UG9pbnQoIHYxICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgJiYgZ2VvbWV0cnkuYXR0cmlidXRlc1sgJ3Bvc2l0aW9uJyBdICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gZ2VvbWV0cnkuYXR0cmlidXRlc1sgJ3Bvc2l0aW9uJyBdLmFycmF5O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArPSAzICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYxLnNldCggcG9zaXRpb25zWyBpIF0sIHBvc2l0aW9uc1sgaSArIDEgXSwgcG9zaXRpb25zWyBpICsgMiBdICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjEuYXBwbHlNYXRyaXg0KCBub2RlLm1hdHJpeFdvcmxkICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuZXhwYW5kQnlQb2ludCggdjEgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb3B5OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcbiAgICAgICAgdGhpcy5taW4uY29weSggYm94Lm1pbiApO1xyXG4gICAgICAgIHRoaXMubWF4LmNvcHkoIGJveC5tYXggKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBtYWtlRW1wdHk6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdGhpcy5taW4ueCA9IHRoaXMubWluLnkgPSB0aGlzLm1pbi56ID0gSW5maW5pdHk7XHJcbiAgICAgICAgdGhpcy5tYXgueCA9IHRoaXMubWF4LnkgPSB0aGlzLm1heC56ID0gLSBJbmZpbml0eTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBlbXB0eTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAvLyB0aGlzIGlzIGEgbW9yZSByb2J1c3QgY2hlY2sgZm9yIGVtcHR5IHRoYW4gKCB2b2x1bWUgPD0gMCApIGJlY2F1c2Ugdm9sdW1lIGNhbiBnZXQgcG9zaXRpdmUgd2l0aCB0d28gbmVnYXRpdmUgYXhlc1xyXG5cclxuICAgICAgICByZXR1cm4gKCB0aGlzLm1heC54IDwgdGhpcy5taW4ueCApIHx8ICggdGhpcy5tYXgueSA8IHRoaXMubWluLnkgKSB8fCAoIHRoaXMubWF4LnogPCB0aGlzLm1pbi56ICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjZW50ZXI6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5taW4sIHRoaXMubWF4ICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2l6ZTogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLm1heCwgdGhpcy5taW4gKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGV4cGFuZEJ5UG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG4gICAgICAgIHRoaXMubWluLm1pbiggcG9pbnQgKTtcclxuICAgICAgICB0aGlzLm1heC5tYXgoIHBvaW50ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZXhwYW5kQnlWZWN0b3I6IGZ1bmN0aW9uICggdmVjdG9yICkge1xyXG5cclxuICAgICAgICB0aGlzLm1pbi5zdWIoIHZlY3RvciApO1xyXG4gICAgICAgIHRoaXMubWF4LmFkZCggdmVjdG9yICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZXhwYW5kQnlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuICAgICAgICB0aGlzLm1pbi5hZGRTY2FsYXIoIC0gc2NhbGFyICk7XHJcbiAgICAgICAgdGhpcy5tYXguYWRkU2NhbGFyKCBzY2FsYXIgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb250YWluc1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuICAgICAgICBpZiAoIHBvaW50LnggPCB0aGlzLm1pbi54IHx8IHBvaW50LnggPiB0aGlzLm1heC54IHx8XHJcbiAgICAgICAgICAgIHBvaW50LnkgPCB0aGlzLm1pbi55IHx8IHBvaW50LnkgPiB0aGlzLm1heC55IHx8XHJcbiAgICAgICAgICAgIHBvaW50LnogPCB0aGlzLm1pbi56IHx8IHBvaW50LnogPiB0aGlzLm1heC56ICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29udGFpbnNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuICAgICAgICBpZiAoICggdGhpcy5taW4ueCA8PSBib3gubWluLnggKSAmJiAoIGJveC5tYXgueCA8PSB0aGlzLm1heC54ICkgJiZcclxuICAgICAgICAgICAgKCB0aGlzLm1pbi55IDw9IGJveC5taW4ueSApICYmICggYm94Lm1heC55IDw9IHRoaXMubWF4LnkgKSAmJlxyXG4gICAgICAgICAgICAoIHRoaXMubWluLnogPD0gYm94Lm1pbi56ICkgJiYgKCBib3gubWF4LnogPD0gdGhpcy5tYXgueiApICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0UGFyYW1ldGVyOiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcbiAgICAgICAgLy8gVGhpcyBjYW4gcG90ZW50aWFsbHkgaGF2ZSBhIGRpdmlkZSBieSB6ZXJvIGlmIHRoZSBib3hcclxuICAgICAgICAvLyBoYXMgYSBzaXplIGRpbWVuc2lvbiBvZiAwLlxyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zZXQoXHJcbiAgICAgICAgICAgICggcG9pbnQueCAtIHRoaXMubWluLnggKSAvICggdGhpcy5tYXgueCAtIHRoaXMubWluLnggKSxcclxuICAgICAgICAgICAgKCBwb2ludC55IC0gdGhpcy5taW4ueSApIC8gKCB0aGlzLm1heC55IC0gdGhpcy5taW4ueSApLFxyXG4gICAgICAgICAgICAoIHBvaW50LnogLSB0aGlzLm1pbi56ICkgLyAoIHRoaXMubWF4LnogLSB0aGlzLm1pbi56IClcclxuICAgICAgICApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgaXNJbnRlcnNlY3Rpb25Cb3g6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuICAgICAgICAvLyB1c2luZyA2IHNwbGl0dGluZyBwbGFuZXMgdG8gcnVsZSBvdXQgaW50ZXJzZWN0aW9ucy5cclxuXHJcbiAgICAgICAgaWYgKCBib3gubWF4LnggPCB0aGlzLm1pbi54IHx8IGJveC5taW4ueCA+IHRoaXMubWF4LnggfHxcclxuICAgICAgICAgICAgYm94Lm1heC55IDwgdGhpcy5taW4ueSB8fCBib3gubWluLnkgPiB0aGlzLm1heC55IHx8XHJcbiAgICAgICAgICAgIGJveC5tYXgueiA8IHRoaXMubWluLnogfHwgYm94Lm1pbi56ID4gdGhpcy5tYXgueiApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNsYW1wUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0LmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGNsYW1wZWRQb2ludCA9IHYxLmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xyXG4gICAgICAgICAgICByZXR1cm4gY2xhbXBlZFBvaW50LnN1YiggcG9pbnQgKS5sZW5ndGgoKTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgZ2V0Qm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlNwaGVyZSgpO1xyXG5cclxuICAgICAgICAgICAgcmVzdWx0LmNlbnRlciA9IHRoaXMuY2VudGVyKCk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5yYWRpdXMgPSB0aGlzLnNpemUoIHYxICkubGVuZ3RoKCkgKiAwLjU7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBpbnRlcnNlY3Q6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuICAgICAgICB0aGlzLm1pbi5tYXgoIGJveC5taW4gKTtcclxuICAgICAgICB0aGlzLm1heC5taW4oIGJveC5tYXggKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB1bmlvbjogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG4gICAgICAgIHRoaXMubWluLm1pbiggYm94Lm1pbiApO1xyXG4gICAgICAgIHRoaXMubWF4Lm1heCggYm94Lm1heCApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgcG9pbnRzID0gW1xyXG4gICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG4gICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG4gICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG4gICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG4gICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG4gICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG4gICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG4gICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMygpXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggbWF0cml4ICkge1xyXG5cclxuICAgICAgICAgICAgLy8gTk9URTogSSBhbSB1c2luZyBhIGJpbmFyeSBwYXR0ZXJuIHRvIHNwZWNpZnkgYWxsIDJeMyBjb21iaW5hdGlvbnMgYmVsb3dcclxuICAgICAgICAgICAgcG9pbnRzWyAwIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1pbi55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDAwXHJcbiAgICAgICAgICAgIHBvaW50c1sgMSBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5taW4ueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAwMVxyXG4gICAgICAgICAgICBwb2ludHNbIDIgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWF4LnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMTBcclxuICAgICAgICAgICAgcG9pbnRzWyAzIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1heC55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDExXHJcbiAgICAgICAgICAgIHBvaW50c1sgNCBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5taW4ueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDEwMFxyXG4gICAgICAgICAgICBwb2ludHNbIDUgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWluLnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMDFcclxuICAgICAgICAgICAgcG9pbnRzWyA2IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1heC55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTEwXHJcbiAgICAgICAgICAgIHBvaW50c1sgNyBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5tYXgueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7ICAvLyAxMTFcclxuXHJcbiAgICAgICAgICAgIHRoaXMubWFrZUVtcHR5KCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0RnJvbVBvaW50cyggcG9pbnRzICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcclxuXHJcbiAgICAgICAgdGhpcy5taW4uYWRkKCBvZmZzZXQgKTtcclxuICAgICAgICB0aGlzLm1heC5hZGQoIG9mZnNldCApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGVxdWFsczogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBib3gubWluLmVxdWFscyggdGhpcy5taW4gKSAmJiBib3gubWF4LmVxdWFscyggdGhpcy5tYXggKTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9NYXRyaXgzLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICovXHJcblxyXG5USFJFRS5NYXRyaXgzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHRoaXMuZWxlbWVudHMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXHJcblxyXG4gICAgICAgIDEsIDAsIDAsXHJcbiAgICAgICAgMCwgMSwgMCxcclxuICAgICAgICAwLCAwLCAxXHJcblxyXG4gICAgXSApO1xyXG5cclxuICAgIGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXgzOiB0aGUgY29uc3RydWN0b3Igbm8gbG9uZ2VyIHJlYWRzIGFyZ3VtZW50cy4gdXNlIC5zZXQoKSBpbnN0ZWFkLicgKTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTWF0cml4My5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLk1hdHJpeDMsXHJcblxyXG4gICAgc2V0OiBmdW5jdGlvbiAoIG4xMSwgbjEyLCBuMTMsIG4yMSwgbjIyLCBuMjMsIG4zMSwgbjMyLCBuMzMgKSB7XHJcblxyXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG4gICAgICAgIHRlWyAwIF0gPSBuMTE7IHRlWyAzIF0gPSBuMTI7IHRlWyA2IF0gPSBuMTM7XHJcbiAgICAgICAgdGVbIDEgXSA9IG4yMTsgdGVbIDQgXSA9IG4yMjsgdGVbIDcgXSA9IG4yMztcclxuICAgICAgICB0ZVsgMiBdID0gbjMxOyB0ZVsgNSBdID0gbjMyOyB0ZVsgOCBdID0gbjMzO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGlkZW50aXR5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0KFxyXG5cclxuICAgICAgICAgICAgMSwgMCwgMCxcclxuICAgICAgICAgICAgMCwgMSwgMCxcclxuICAgICAgICAgICAgMCwgMCwgMVxyXG5cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmZyb21BcnJheSggdGhpcy5lbGVtZW50cyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29weTogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuICAgICAgICB2YXIgbWUgPSBtLmVsZW1lbnRzO1xyXG5cclxuICAgICAgICB0aGlzLnNldChcclxuXHJcbiAgICAgICAgICAgIG1lWyAwIF0sIG1lWyAzIF0sIG1lWyA2IF0sXHJcbiAgICAgICAgICAgIG1lWyAxIF0sIG1lWyA0IF0sIG1lWyA3IF0sXHJcbiAgICAgICAgICAgIG1lWyAyIF0sIG1lWyA1IF0sIG1lWyA4IF1cclxuXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBtdWx0aXBseVZlY3RvcjM6IGZ1bmN0aW9uICggdmVjdG9yICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXgzOiAubXVsdGlwbHlWZWN0b3IzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDMoIG1hdHJpeCApIGluc3RlYWQuJyApO1xyXG4gICAgICAgIHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXgzKCB0aGlzICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBtdWx0aXBseVZlY3RvcjNBcnJheTogZnVuY3Rpb24gKCBhICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXgzOiAubXVsdGlwbHlWZWN0b3IzQXJyYXkoKSBoYXMgYmVlbiByZW5hbWVkLiBVc2UgbWF0cml4LmFwcGx5VG9WZWN0b3IzQXJyYXkoIGFycmF5ICkgaW5zdGVhZC4nICk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlUb1ZlY3RvcjNBcnJheSggYSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYXBwbHlUb1ZlY3RvcjNBcnJheTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgdjE7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQsIGxlbmd0aCApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgIGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSBhcnJheS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGogPSBvZmZzZXQ7IGkgPCBsZW5ndGg7IGkgKz0gMywgaiArPSAzICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHYxLmZyb21BcnJheSggYXJyYXksIGogKTtcclxuICAgICAgICAgICAgICAgIHYxLmFwcGx5TWF0cml4MyggdGhpcyApO1xyXG4gICAgICAgICAgICAgICAgdjEudG9BcnJheSggYXJyYXksIGogKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBhcnJheTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgYXBwbHlUb0J1ZmZlcjogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgdjE7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBhcHBseVRvQnVmZmVyKCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgaWYgKCBsZW5ndGggPT09IHVuZGVmaW5lZCApIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGggLyBidWZmZXIuaXRlbVNpemU7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGogPSBvZmZzZXQ7IGkgPCBsZW5ndGg7IGkgKyssIGogKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdjEueCA9IGJ1ZmZlci5nZXRYKCBqICk7XHJcbiAgICAgICAgICAgICAgICB2MS55ID0gYnVmZmVyLmdldFkoIGogKTtcclxuICAgICAgICAgICAgICAgIHYxLnogPSBidWZmZXIuZ2V0WiggaiApO1xyXG5cclxuICAgICAgICAgICAgICAgIHYxLmFwcGx5TWF0cml4MyggdGhpcyApO1xyXG5cclxuICAgICAgICAgICAgICAgIGJ1ZmZlci5zZXRYWVooIHYxLngsIHYxLnksIHYxLnogKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBidWZmZXI7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG4gICAgICAgIHRlWyAwIF0gKj0gczsgdGVbIDMgXSAqPSBzOyB0ZVsgNiBdICo9IHM7XHJcbiAgICAgICAgdGVbIDEgXSAqPSBzOyB0ZVsgNCBdICo9IHM7IHRlWyA3IF0gKj0gcztcclxuICAgICAgICB0ZVsgMiBdICo9IHM7IHRlWyA1IF0gKj0gczsgdGVbIDggXSAqPSBzO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRldGVybWluYW50OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG4gICAgICAgIHZhciBhID0gdGVbIDAgXSwgYiA9IHRlWyAxIF0sIGMgPSB0ZVsgMiBdLFxyXG4gICAgICAgICAgICBkID0gdGVbIDMgXSwgZSA9IHRlWyA0IF0sIGYgPSB0ZVsgNSBdLFxyXG4gICAgICAgICAgICBnID0gdGVbIDYgXSwgaCA9IHRlWyA3IF0sIGkgPSB0ZVsgOCBdO1xyXG5cclxuICAgICAgICByZXR1cm4gYSAqIGUgKiBpIC0gYSAqIGYgKiBoIC0gYiAqIGQgKiBpICsgYiAqIGYgKiBnICsgYyAqIGQgKiBoIC0gYyAqIGUgKiBnO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0SW52ZXJzZTogZnVuY3Rpb24gKCBtYXRyaXgsIHRocm93T25JbnZlcnRpYmxlICkge1xyXG5cclxuICAgICAgICAvLyBpbnB1dDogVEhSRUUuTWF0cml4NFxyXG4gICAgICAgIC8vICggYmFzZWQgb24gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3dlYmdsLW1qcy8gKVxyXG5cclxuICAgICAgICB2YXIgbWUgPSBtYXRyaXguZWxlbWVudHM7XHJcbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcbiAgICAgICAgdGVbIDAgXSA9ICAgbWVbIDEwIF0gKiBtZVsgNSBdIC0gbWVbIDYgXSAqIG1lWyA5IF07XHJcbiAgICAgICAgdGVbIDEgXSA9IC0gbWVbIDEwIF0gKiBtZVsgMSBdICsgbWVbIDIgXSAqIG1lWyA5IF07XHJcbiAgICAgICAgdGVbIDIgXSA9ICAgbWVbIDYgXSAqIG1lWyAxIF0gLSBtZVsgMiBdICogbWVbIDUgXTtcclxuICAgICAgICB0ZVsgMyBdID0gLSBtZVsgMTAgXSAqIG1lWyA0IF0gKyBtZVsgNiBdICogbWVbIDggXTtcclxuICAgICAgICB0ZVsgNCBdID0gICBtZVsgMTAgXSAqIG1lWyAwIF0gLSBtZVsgMiBdICogbWVbIDggXTtcclxuICAgICAgICB0ZVsgNSBdID0gLSBtZVsgNiBdICogbWVbIDAgXSArIG1lWyAyIF0gKiBtZVsgNCBdO1xyXG4gICAgICAgIHRlWyA2IF0gPSAgIG1lWyA5IF0gKiBtZVsgNCBdIC0gbWVbIDUgXSAqIG1lWyA4IF07XHJcbiAgICAgICAgdGVbIDcgXSA9IC0gbWVbIDkgXSAqIG1lWyAwIF0gKyBtZVsgMSBdICogbWVbIDggXTtcclxuICAgICAgICB0ZVsgOCBdID0gICBtZVsgNSBdICogbWVbIDAgXSAtIG1lWyAxIF0gKiBtZVsgNCBdO1xyXG5cclxuICAgICAgICB2YXIgZGV0ID0gbWVbIDAgXSAqIHRlWyAwIF0gKyBtZVsgMSBdICogdGVbIDMgXSArIG1lWyAyIF0gKiB0ZVsgNiBdO1xyXG5cclxuICAgICAgICAvLyBubyBpbnZlcnNlXHJcblxyXG4gICAgICAgIGlmICggZGV0ID09PSAwICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIG1zZyA9IFwiTWF0cml4My5nZXRJbnZlcnNlKCk6IGNhbid0IGludmVydCBtYXRyaXgsIGRldGVybWluYW50IGlzIDBcIjtcclxuXHJcbiAgICAgICAgICAgIGlmICggdGhyb3dPbkludmVydGlibGUgfHwgZmFsc2UgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCBtc2cgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuaWRlbnRpdHkoKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMubXVsdGlwbHlTY2FsYXIoIDEuMCAvIGRldCApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRyYW5zcG9zZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgdG1wLCBtID0gdGhpcy5lbGVtZW50cztcclxuXHJcbiAgICAgICAgdG1wID0gbVsgMSBdOyBtWyAxIF0gPSBtWyAzIF07IG1bIDMgXSA9IHRtcDtcclxuICAgICAgICB0bXAgPSBtWyAyIF07IG1bIDIgXSA9IG1bIDYgXTsgbVsgNiBdID0gdG1wO1xyXG4gICAgICAgIHRtcCA9IG1bIDUgXTsgbVsgNSBdID0gbVsgNyBdOyBtWyA3IF0gPSB0bXA7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZmxhdHRlblRvQXJyYXlPZmZzZXQ6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCBdID0gdGVbIDAgXTtcclxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGVbIDEgXTtcclxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGVbIDIgXTtcclxuXHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDMgXSA9IHRlWyAzIF07XHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDUgXSA9IHRlWyA1IF07XHJcblxyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyA2IF0gPSB0ZVsgNiBdO1xyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyA3IF0gPSB0ZVsgNyBdO1xyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyA4IF0gID0gdGVbIDggXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGFycmF5O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0Tm9ybWFsTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG4gICAgICAgIC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0XHJcblxyXG4gICAgICAgIHRoaXMuZ2V0SW52ZXJzZSggbSApLnRyYW5zcG9zZSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRyYW5zcG9zZUludG9BcnJheTogZnVuY3Rpb24gKCByICkge1xyXG5cclxuICAgICAgICB2YXIgbSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG4gICAgICAgIHJbIDAgXSA9IG1bIDAgXTtcclxuICAgICAgICByWyAxIF0gPSBtWyAzIF07XHJcbiAgICAgICAgclsgMiBdID0gbVsgNiBdO1xyXG4gICAgICAgIHJbIDMgXSA9IG1bIDEgXTtcclxuICAgICAgICByWyA0IF0gPSBtWyA0IF07XHJcbiAgICAgICAgclsgNSBdID0gbVsgNyBdO1xyXG4gICAgICAgIHJbIDYgXSA9IG1bIDIgXTtcclxuICAgICAgICByWyA3IF0gPSBtWyA1IF07XHJcbiAgICAgICAgclsgOCBdID0gbVsgOCBdO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5lbGVtZW50cy5zZXQoIGFycmF5ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdG9BcnJheTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICB0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdLFxyXG4gICAgICAgICAgICB0ZVsgMyBdLCB0ZVsgNCBdLCB0ZVsgNSBdLFxyXG4gICAgICAgICAgICB0ZVsgNiBdLCB0ZVsgNyBdLCB0ZVsgOCBdXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9NYXRyaXg0LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBzdXBlcmVnZ2JlcnQgLyBodHRwOi8vd3d3LnBhdWxicnVudC5jby51ay9cclxuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cclxuICogQGF1dGhvciBqb3JkaV9yb3MgLyBodHRwOi8vcGxhdHRzb2Z0LmNvbVxyXG4gKiBAYXV0aG9yIEQxcGxvMWQgLyBodHRwOi8vZ2l0aHViLmNvbS9EMXBsbzFkXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgdGlta25pcCAvIGh0dHA6Ly93d3cuZmxvb3JwbGFubmVyLmNvbS9cclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICovXHJcblxyXG5USFJFRS5NYXRyaXg0ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHRoaXMuZWxlbWVudHMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXHJcblxyXG4gICAgICAgIDEsIDAsIDAsIDAsXHJcbiAgICAgICAgMCwgMSwgMCwgMCxcclxuICAgICAgICAwLCAwLCAxLCAwLFxyXG4gICAgICAgIDAsIDAsIDAsIDFcclxuXHJcbiAgICBdICk7XHJcblxyXG4gICAgaWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMCApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IHRoZSBjb25zdHJ1Y3RvciBubyBsb25nZXIgcmVhZHMgYXJndW1lbnRzLiB1c2UgLnNldCgpIGluc3RlYWQuJyApO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5NYXRyaXg0LnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuTWF0cml4NCxcclxuXHJcbiAgICBzZXQ6IGZ1bmN0aW9uICggbjExLCBuMTIsIG4xMywgbjE0LCBuMjEsIG4yMiwgbjIzLCBuMjQsIG4zMSwgbjMyLCBuMzMsIG4zNCwgbjQxLCBuNDIsIG40MywgbjQ0ICkge1xyXG5cclxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuICAgICAgICB0ZVsgMCBdID0gbjExOyB0ZVsgNCBdID0gbjEyOyB0ZVsgOCBdID0gbjEzOyB0ZVsgMTIgXSA9IG4xNDtcclxuICAgICAgICB0ZVsgMSBdID0gbjIxOyB0ZVsgNSBdID0gbjIyOyB0ZVsgOSBdID0gbjIzOyB0ZVsgMTMgXSA9IG4yNDtcclxuICAgICAgICB0ZVsgMiBdID0gbjMxOyB0ZVsgNiBdID0gbjMyOyB0ZVsgMTAgXSA9IG4zMzsgdGVbIDE0IF0gPSBuMzQ7XHJcbiAgICAgICAgdGVbIDMgXSA9IG40MTsgdGVbIDcgXSA9IG40MjsgdGVbIDExIF0gPSBuNDM7IHRlWyAxNSBdID0gbjQ0O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGlkZW50aXR5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0KFxyXG5cclxuICAgICAgICAgICAgMSwgMCwgMCwgMCxcclxuICAgICAgICAgICAgMCwgMSwgMCwgMCxcclxuICAgICAgICAgICAgMCwgMCwgMSwgMCxcclxuICAgICAgICAgICAgMCwgMCwgMCwgMVxyXG5cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgVEhSRUUuTWF0cml4NCgpLmZyb21BcnJheSggdGhpcy5lbGVtZW50cyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29weTogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuICAgICAgICB0aGlzLmVsZW1lbnRzLnNldCggbS5lbGVtZW50cyApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGV4dHJhY3RQb3NpdGlvbjogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuZXh0cmFjdFBvc2l0aW9uKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuY29weVBvc2l0aW9uKCkuJyApO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvcHlQb3NpdGlvbiggbSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29weVBvc2l0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcbiAgICAgICAgdmFyIG1lID0gbS5lbGVtZW50cztcclxuXHJcbiAgICAgICAgdGVbIDEyIF0gPSBtZVsgMTIgXTtcclxuICAgICAgICB0ZVsgMTMgXSA9IG1lWyAxMyBdO1xyXG4gICAgICAgIHRlWyAxNCBdID0gbWVbIDE0IF07XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZXh0cmFjdEJhc2lzOiBmdW5jdGlvbiAoIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XHJcblxyXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG4gICAgICAgIHhBeGlzLnNldCggdGVbIDAgXSwgdGVbIDEgXSwgdGVbIDIgXSApO1xyXG4gICAgICAgIHlBeGlzLnNldCggdGVbIDQgXSwgdGVbIDUgXSwgdGVbIDYgXSApO1xyXG4gICAgICAgIHpBeGlzLnNldCggdGVbIDggXSwgdGVbIDkgXSwgdGVbIDEwIF0gKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBtYWtlQmFzaXM6IGZ1bmN0aW9uICggeEF4aXMsIHlBeGlzLCB6QXhpcyApIHtcclxuXHJcbiAgICAgICAgdGhpcy5zZXQoXHJcbiAgICAgICAgICAgIHhBeGlzLngsIHlBeGlzLngsIHpBeGlzLngsIDAsXHJcbiAgICAgICAgICAgIHhBeGlzLnksIHlBeGlzLnksIHpBeGlzLnksIDAsXHJcbiAgICAgICAgICAgIHhBeGlzLnosIHlBeGlzLnosIHpBeGlzLnosIDAsXHJcbiAgICAgICAgICAgIDAsICAgICAgIDAsICAgICAgIDAsICAgICAgIDFcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGV4dHJhY3RSb3RhdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgdjE7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgICAgICAgICB2YXIgbWUgPSBtLmVsZW1lbnRzO1xyXG5cclxuICAgICAgICAgICAgdmFyIHNjYWxlWCA9IDEgLyB2MS5zZXQoIG1lWyAwIF0sIG1lWyAxIF0sIG1lWyAyIF0gKS5sZW5ndGgoKTtcclxuICAgICAgICAgICAgdmFyIHNjYWxlWSA9IDEgLyB2MS5zZXQoIG1lWyA0IF0sIG1lWyA1IF0sIG1lWyA2IF0gKS5sZW5ndGgoKTtcclxuICAgICAgICAgICAgdmFyIHNjYWxlWiA9IDEgLyB2MS5zZXQoIG1lWyA4IF0sIG1lWyA5IF0sIG1lWyAxMCBdICkubGVuZ3RoKCk7XHJcblxyXG4gICAgICAgICAgICB0ZVsgMCBdID0gbWVbIDAgXSAqIHNjYWxlWDtcclxuICAgICAgICAgICAgdGVbIDEgXSA9IG1lWyAxIF0gKiBzY2FsZVg7XHJcbiAgICAgICAgICAgIHRlWyAyIF0gPSBtZVsgMiBdICogc2NhbGVYO1xyXG5cclxuICAgICAgICAgICAgdGVbIDQgXSA9IG1lWyA0IF0gKiBzY2FsZVk7XHJcbiAgICAgICAgICAgIHRlWyA1IF0gPSBtZVsgNSBdICogc2NhbGVZO1xyXG4gICAgICAgICAgICB0ZVsgNiBdID0gbWVbIDYgXSAqIHNjYWxlWTtcclxuXHJcbiAgICAgICAgICAgIHRlWyA4IF0gPSBtZVsgOCBdICogc2NhbGVaO1xyXG4gICAgICAgICAgICB0ZVsgOSBdID0gbWVbIDkgXSAqIHNjYWxlWjtcclxuICAgICAgICAgICAgdGVbIDEwIF0gPSBtZVsgMTAgXSAqIHNjYWxlWjtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBtYWtlUm90YXRpb25Gcm9tRXVsZXI6IGZ1bmN0aW9uICggZXVsZXIgKSB7XHJcblxyXG4gICAgICAgIGlmICggZXVsZXIgaW5zdGFuY2VvZiBUSFJFRS5FdWxlciA9PT0gZmFsc2UgKSB7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4OiAubWFrZVJvdGF0aW9uRnJvbUV1bGVyKCkgbm93IGV4cGVjdHMgYSBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuICAgICAgICB2YXIgeCA9IGV1bGVyLngsIHkgPSBldWxlci55LCB6ID0gZXVsZXIuejtcclxuICAgICAgICB2YXIgYSA9IE1hdGguY29zKCB4ICksIGIgPSBNYXRoLnNpbiggeCApO1xyXG4gICAgICAgIHZhciBjID0gTWF0aC5jb3MoIHkgKSwgZCA9IE1hdGguc2luKCB5ICk7XHJcbiAgICAgICAgdmFyIGUgPSBNYXRoLmNvcyggeiApLCBmID0gTWF0aC5zaW4oIHogKTtcclxuXHJcbiAgICAgICAgaWYgKCBldWxlci5vcmRlciA9PT0gJ1hZWicgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYWUgPSBhICogZSwgYWYgPSBhICogZiwgYmUgPSBiICogZSwgYmYgPSBiICogZjtcclxuXHJcbiAgICAgICAgICAgIHRlWyAwIF0gPSBjICogZTtcclxuICAgICAgICAgICAgdGVbIDQgXSA9IC0gYyAqIGY7XHJcbiAgICAgICAgICAgIHRlWyA4IF0gPSBkO1xyXG5cclxuICAgICAgICAgICAgdGVbIDEgXSA9IGFmICsgYmUgKiBkO1xyXG4gICAgICAgICAgICB0ZVsgNSBdID0gYWUgLSBiZiAqIGQ7XHJcbiAgICAgICAgICAgIHRlWyA5IF0gPSAtIGIgKiBjO1xyXG5cclxuICAgICAgICAgICAgdGVbIDIgXSA9IGJmIC0gYWUgKiBkO1xyXG4gICAgICAgICAgICB0ZVsgNiBdID0gYmUgKyBhZiAqIGQ7XHJcbiAgICAgICAgICAgIHRlWyAxMCBdID0gYSAqIGM7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWVhaJyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBjZSA9IGMgKiBlLCBjZiA9IGMgKiBmLCBkZSA9IGQgKiBlLCBkZiA9IGQgKiBmO1xyXG5cclxuICAgICAgICAgICAgdGVbIDAgXSA9IGNlICsgZGYgKiBiO1xyXG4gICAgICAgICAgICB0ZVsgNCBdID0gZGUgKiBiIC0gY2Y7XHJcbiAgICAgICAgICAgIHRlWyA4IF0gPSBhICogZDtcclxuXHJcbiAgICAgICAgICAgIHRlWyAxIF0gPSBhICogZjtcclxuICAgICAgICAgICAgdGVbIDUgXSA9IGEgKiBlO1xyXG4gICAgICAgICAgICB0ZVsgOSBdID0gLSBiO1xyXG5cclxuICAgICAgICAgICAgdGVbIDIgXSA9IGNmICogYiAtIGRlO1xyXG4gICAgICAgICAgICB0ZVsgNiBdID0gZGYgKyBjZSAqIGI7XHJcbiAgICAgICAgICAgIHRlWyAxMCBdID0gYSAqIGM7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWlhZJyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBjZSA9IGMgKiBlLCBjZiA9IGMgKiBmLCBkZSA9IGQgKiBlLCBkZiA9IGQgKiBmO1xyXG5cclxuICAgICAgICAgICAgdGVbIDAgXSA9IGNlIC0gZGYgKiBiO1xyXG4gICAgICAgICAgICB0ZVsgNCBdID0gLSBhICogZjtcclxuICAgICAgICAgICAgdGVbIDggXSA9IGRlICsgY2YgKiBiO1xyXG5cclxuICAgICAgICAgICAgdGVbIDEgXSA9IGNmICsgZGUgKiBiO1xyXG4gICAgICAgICAgICB0ZVsgNSBdID0gYSAqIGU7XHJcbiAgICAgICAgICAgIHRlWyA5IF0gPSBkZiAtIGNlICogYjtcclxuXHJcbiAgICAgICAgICAgIHRlWyAyIF0gPSAtIGEgKiBkO1xyXG4gICAgICAgICAgICB0ZVsgNiBdID0gYjtcclxuICAgICAgICAgICAgdGVbIDEwIF0gPSBhICogYztcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWVgnICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGFlID0gYSAqIGUsIGFmID0gYSAqIGYsIGJlID0gYiAqIGUsIGJmID0gYiAqIGY7XHJcblxyXG4gICAgICAgICAgICB0ZVsgMCBdID0gYyAqIGU7XHJcbiAgICAgICAgICAgIHRlWyA0IF0gPSBiZSAqIGQgLSBhZjtcclxuICAgICAgICAgICAgdGVbIDggXSA9IGFlICogZCArIGJmO1xyXG5cclxuICAgICAgICAgICAgdGVbIDEgXSA9IGMgKiBmO1xyXG4gICAgICAgICAgICB0ZVsgNSBdID0gYmYgKiBkICsgYWU7XHJcbiAgICAgICAgICAgIHRlWyA5IF0gPSBhZiAqIGQgLSBiZTtcclxuXHJcbiAgICAgICAgICAgIHRlWyAyIF0gPSAtIGQ7XHJcbiAgICAgICAgICAgIHRlWyA2IF0gPSBiICogYztcclxuICAgICAgICAgICAgdGVbIDEwIF0gPSBhICogYztcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdZWlgnICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGFjID0gYSAqIGMsIGFkID0gYSAqIGQsIGJjID0gYiAqIGMsIGJkID0gYiAqIGQ7XHJcblxyXG4gICAgICAgICAgICB0ZVsgMCBdID0gYyAqIGU7XHJcbiAgICAgICAgICAgIHRlWyA0IF0gPSBiZCAtIGFjICogZjtcclxuICAgICAgICAgICAgdGVbIDggXSA9IGJjICogZiArIGFkO1xyXG5cclxuICAgICAgICAgICAgdGVbIDEgXSA9IGY7XHJcbiAgICAgICAgICAgIHRlWyA1IF0gPSBhICogZTtcclxuICAgICAgICAgICAgdGVbIDkgXSA9IC0gYiAqIGU7XHJcblxyXG4gICAgICAgICAgICB0ZVsgMiBdID0gLSBkICogZTtcclxuICAgICAgICAgICAgdGVbIDYgXSA9IGFkICogZiArIGJjO1xyXG4gICAgICAgICAgICB0ZVsgMTAgXSA9IGFjIC0gYmQgKiBmO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1haWScgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYWMgPSBhICogYywgYWQgPSBhICogZCwgYmMgPSBiICogYywgYmQgPSBiICogZDtcclxuXHJcbiAgICAgICAgICAgIHRlWyAwIF0gPSBjICogZTtcclxuICAgICAgICAgICAgdGVbIDQgXSA9IC0gZjtcclxuICAgICAgICAgICAgdGVbIDggXSA9IGQgKiBlO1xyXG5cclxuICAgICAgICAgICAgdGVbIDEgXSA9IGFjICogZiArIGJkO1xyXG4gICAgICAgICAgICB0ZVsgNSBdID0gYSAqIGU7XHJcbiAgICAgICAgICAgIHRlWyA5IF0gPSBhZCAqIGYgLSBiYztcclxuXHJcbiAgICAgICAgICAgIHRlWyAyIF0gPSBiYyAqIGYgLSBhZDtcclxuICAgICAgICAgICAgdGVbIDYgXSA9IGIgKiBlO1xyXG4gICAgICAgICAgICB0ZVsgMTAgXSA9IGJkICogZiArIGFjO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGxhc3QgY29sdW1uXHJcbiAgICAgICAgdGVbIDMgXSA9IDA7XHJcbiAgICAgICAgdGVbIDcgXSA9IDA7XHJcbiAgICAgICAgdGVbIDExIF0gPSAwO1xyXG5cclxuICAgICAgICAvLyBib3R0b20gcm93XHJcbiAgICAgICAgdGVbIDEyIF0gPSAwO1xyXG4gICAgICAgIHRlWyAxMyBdID0gMDtcclxuICAgICAgICB0ZVsgMTQgXSA9IDA7XHJcbiAgICAgICAgdGVbIDE1IF0gPSAxO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLnNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24oKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbigpLicgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XHJcblxyXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG4gICAgICAgIHZhciB4ID0gcS54LCB5ID0gcS55LCB6ID0gcS56LCB3ID0gcS53O1xyXG4gICAgICAgIHZhciB4MiA9IHggKyB4LCB5MiA9IHkgKyB5LCB6MiA9IHogKyB6O1xyXG4gICAgICAgIHZhciB4eCA9IHggKiB4MiwgeHkgPSB4ICogeTIsIHh6ID0geCAqIHoyO1xyXG4gICAgICAgIHZhciB5eSA9IHkgKiB5MiwgeXogPSB5ICogejIsIHp6ID0geiAqIHoyO1xyXG4gICAgICAgIHZhciB3eCA9IHcgKiB4Miwgd3kgPSB3ICogeTIsIHd6ID0gdyAqIHoyO1xyXG5cclxuICAgICAgICB0ZVsgMCBdID0gMSAtICggeXkgKyB6eiApO1xyXG4gICAgICAgIHRlWyA0IF0gPSB4eSAtIHd6O1xyXG4gICAgICAgIHRlWyA4IF0gPSB4eiArIHd5O1xyXG5cclxuICAgICAgICB0ZVsgMSBdID0geHkgKyB3ejtcclxuICAgICAgICB0ZVsgNSBdID0gMSAtICggeHggKyB6eiApO1xyXG4gICAgICAgIHRlWyA5IF0gPSB5eiAtIHd4O1xyXG5cclxuICAgICAgICB0ZVsgMiBdID0geHogLSB3eTtcclxuICAgICAgICB0ZVsgNiBdID0geXogKyB3eDtcclxuICAgICAgICB0ZVsgMTAgXSA9IDEgLSAoIHh4ICsgeXkgKTtcclxuXHJcbiAgICAgICAgLy8gbGFzdCBjb2x1bW5cclxuICAgICAgICB0ZVsgMyBdID0gMDtcclxuICAgICAgICB0ZVsgNyBdID0gMDtcclxuICAgICAgICB0ZVsgMTEgXSA9IDA7XHJcblxyXG4gICAgICAgIC8vIGJvdHRvbSByb3dcclxuICAgICAgICB0ZVsgMTIgXSA9IDA7XHJcbiAgICAgICAgdGVbIDEzIF0gPSAwO1xyXG4gICAgICAgIHRlWyAxNCBdID0gMDtcclxuICAgICAgICB0ZVsgMTUgXSA9IDE7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbG9va0F0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciB4LCB5LCB6O1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCBleWUsIHRhcmdldCwgdXAgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHggPT09IHVuZGVmaW5lZCApIHggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgICAgICBpZiAoIHkgPT09IHVuZGVmaW5lZCApIHkgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgICAgICBpZiAoIHogPT09IHVuZGVmaW5lZCApIHogPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcbiAgICAgICAgICAgIHouc3ViVmVjdG9ycyggZXllLCB0YXJnZXQgKS5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggei5sZW5ndGhTcSgpID09PSAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHoueiA9IDE7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB4LmNyb3NzVmVjdG9ycyggdXAsIHogKS5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggeC5sZW5ndGhTcSgpID09PSAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHoueCArPSAwLjAwMDE7XHJcbiAgICAgICAgICAgICAgICB4LmNyb3NzVmVjdG9ycyggdXAsIHogKS5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHkuY3Jvc3NWZWN0b3JzKCB6LCB4ICk7XHJcblxyXG5cclxuICAgICAgICAgICAgdGVbIDAgXSA9IHgueDsgdGVbIDQgXSA9IHkueDsgdGVbIDggXSA9IHoueDtcclxuICAgICAgICAgICAgdGVbIDEgXSA9IHgueTsgdGVbIDUgXSA9IHkueTsgdGVbIDkgXSA9IHoueTtcclxuICAgICAgICAgICAgdGVbIDIgXSA9IHguejsgdGVbIDYgXSA9IHkuejsgdGVbIDEwIF0gPSB6Lno7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgbXVsdGlwbHk6IGZ1bmN0aW9uICggbSwgbiApIHtcclxuXHJcbiAgICAgICAgaWYgKCBuICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseU1hdHJpY2VzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIG0sIG4gKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLCBtICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBtdWx0aXBseU1hdHJpY2VzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG4gICAgICAgIHZhciBhZSA9IGEuZWxlbWVudHM7XHJcbiAgICAgICAgdmFyIGJlID0gYi5lbGVtZW50cztcclxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuICAgICAgICB2YXIgYTExID0gYWVbIDAgXSwgYTEyID0gYWVbIDQgXSwgYTEzID0gYWVbIDggXSwgYTE0ID0gYWVbIDEyIF07XHJcbiAgICAgICAgdmFyIGEyMSA9IGFlWyAxIF0sIGEyMiA9IGFlWyA1IF0sIGEyMyA9IGFlWyA5IF0sIGEyNCA9IGFlWyAxMyBdO1xyXG4gICAgICAgIHZhciBhMzEgPSBhZVsgMiBdLCBhMzIgPSBhZVsgNiBdLCBhMzMgPSBhZVsgMTAgXSwgYTM0ID0gYWVbIDE0IF07XHJcbiAgICAgICAgdmFyIGE0MSA9IGFlWyAzIF0sIGE0MiA9IGFlWyA3IF0sIGE0MyA9IGFlWyAxMSBdLCBhNDQgPSBhZVsgMTUgXTtcclxuXHJcbiAgICAgICAgdmFyIGIxMSA9IGJlWyAwIF0sIGIxMiA9IGJlWyA0IF0sIGIxMyA9IGJlWyA4IF0sIGIxNCA9IGJlWyAxMiBdO1xyXG4gICAgICAgIHZhciBiMjEgPSBiZVsgMSBdLCBiMjIgPSBiZVsgNSBdLCBiMjMgPSBiZVsgOSBdLCBiMjQgPSBiZVsgMTMgXTtcclxuICAgICAgICB2YXIgYjMxID0gYmVbIDIgXSwgYjMyID0gYmVbIDYgXSwgYjMzID0gYmVbIDEwIF0sIGIzNCA9IGJlWyAxNCBdO1xyXG4gICAgICAgIHZhciBiNDEgPSBiZVsgMyBdLCBiNDIgPSBiZVsgNyBdLCBiNDMgPSBiZVsgMTEgXSwgYjQ0ID0gYmVbIDE1IF07XHJcblxyXG4gICAgICAgIHRlWyAwIF0gPSBhMTEgKiBiMTEgKyBhMTIgKiBiMjEgKyBhMTMgKiBiMzEgKyBhMTQgKiBiNDE7XHJcbiAgICAgICAgdGVbIDQgXSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMiArIGExNCAqIGI0MjtcclxuICAgICAgICB0ZVsgOCBdID0gYTExICogYjEzICsgYTEyICogYjIzICsgYTEzICogYjMzICsgYTE0ICogYjQzO1xyXG4gICAgICAgIHRlWyAxMiBdID0gYTExICogYjE0ICsgYTEyICogYjI0ICsgYTEzICogYjM0ICsgYTE0ICogYjQ0O1xyXG5cclxuICAgICAgICB0ZVsgMSBdID0gYTIxICogYjExICsgYTIyICogYjIxICsgYTIzICogYjMxICsgYTI0ICogYjQxO1xyXG4gICAgICAgIHRlWyA1IF0gPSBhMjEgKiBiMTIgKyBhMjIgKiBiMjIgKyBhMjMgKiBiMzIgKyBhMjQgKiBiNDI7XHJcbiAgICAgICAgdGVbIDkgXSA9IGEyMSAqIGIxMyArIGEyMiAqIGIyMyArIGEyMyAqIGIzMyArIGEyNCAqIGI0MztcclxuICAgICAgICB0ZVsgMTMgXSA9IGEyMSAqIGIxNCArIGEyMiAqIGIyNCArIGEyMyAqIGIzNCArIGEyNCAqIGI0NDtcclxuXHJcbiAgICAgICAgdGVbIDIgXSA9IGEzMSAqIGIxMSArIGEzMiAqIGIyMSArIGEzMyAqIGIzMSArIGEzNCAqIGI0MTtcclxuICAgICAgICB0ZVsgNiBdID0gYTMxICogYjEyICsgYTMyICogYjIyICsgYTMzICogYjMyICsgYTM0ICogYjQyO1xyXG4gICAgICAgIHRlWyAxMCBdID0gYTMxICogYjEzICsgYTMyICogYjIzICsgYTMzICogYjMzICsgYTM0ICogYjQzO1xyXG4gICAgICAgIHRlWyAxNCBdID0gYTMxICogYjE0ICsgYTMyICogYjI0ICsgYTMzICogYjM0ICsgYTM0ICogYjQ0O1xyXG5cclxuICAgICAgICB0ZVsgMyBdID0gYTQxICogYjExICsgYTQyICogYjIxICsgYTQzICogYjMxICsgYTQ0ICogYjQxO1xyXG4gICAgICAgIHRlWyA3IF0gPSBhNDEgKiBiMTIgKyBhNDIgKiBiMjIgKyBhNDMgKiBiMzIgKyBhNDQgKiBiNDI7XHJcbiAgICAgICAgdGVbIDExIF0gPSBhNDEgKiBiMTMgKyBhNDIgKiBiMjMgKyBhNDMgKiBiMzMgKyBhNDQgKiBiNDM7XHJcbiAgICAgICAgdGVbIDE1IF0gPSBhNDEgKiBiMTQgKyBhNDIgKiBiMjQgKyBhNDMgKiBiMzQgKyBhNDQgKiBiNDQ7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbXVsdGlwbHlUb0FycmF5OiBmdW5jdGlvbiAoIGEsIGIsIHIgKSB7XHJcblxyXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG4gICAgICAgIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggYSwgYiApO1xyXG5cclxuICAgICAgICByWyAwIF0gPSB0ZVsgMCBdOyByWyAxIF0gPSB0ZVsgMSBdOyByWyAyIF0gPSB0ZVsgMiBdOyByWyAzIF0gPSB0ZVsgMyBdO1xyXG4gICAgICAgIHJbIDQgXSA9IHRlWyA0IF07IHJbIDUgXSA9IHRlWyA1IF07IHJbIDYgXSA9IHRlWyA2IF07IHJbIDcgXSA9IHRlWyA3IF07XHJcbiAgICAgICAgclsgOCBdICA9IHRlWyA4IF07IHJbIDkgXSAgPSB0ZVsgOSBdOyByWyAxMCBdID0gdGVbIDEwIF07IHJbIDExIF0gPSB0ZVsgMTEgXTtcclxuICAgICAgICByWyAxMiBdID0gdGVbIDEyIF07IHJbIDEzIF0gPSB0ZVsgMTMgXTsgclsgMTQgXSA9IHRlWyAxNCBdOyByWyAxNSBdID0gdGVbIDE1IF07XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcclxuXHJcbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcbiAgICAgICAgdGVbIDAgXSAqPSBzOyB0ZVsgNCBdICo9IHM7IHRlWyA4IF0gKj0gczsgdGVbIDEyIF0gKj0gcztcclxuICAgICAgICB0ZVsgMSBdICo9IHM7IHRlWyA1IF0gKj0gczsgdGVbIDkgXSAqPSBzOyB0ZVsgMTMgXSAqPSBzO1xyXG4gICAgICAgIHRlWyAyIF0gKj0gczsgdGVbIDYgXSAqPSBzOyB0ZVsgMTAgXSAqPSBzOyB0ZVsgMTQgXSAqPSBzO1xyXG4gICAgICAgIHRlWyAzIF0gKj0gczsgdGVbIDcgXSAqPSBzOyB0ZVsgMTEgXSAqPSBzOyB0ZVsgMTUgXSAqPSBzO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG11bHRpcGx5VmVjdG9yMzogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4NCggbWF0cml4ICkgb3IgdmVjdG9yLmFwcGx5UHJvamVjdGlvbiggbWF0cml4ICkgaW5zdGVhZC4nICk7XHJcbiAgICAgICAgcmV0dXJuIHZlY3Rvci5hcHBseVByb2plY3Rpb24oIHRoaXMgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG11bHRpcGx5VmVjdG9yNDogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVZlY3RvcjQoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4NCggbWF0cml4ICkgaW5zdGVhZC4nICk7XHJcbiAgICAgICAgcmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG11bHRpcGx5VmVjdG9yM0FycmF5OiBmdW5jdGlvbiAoIGEgKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVZlY3RvcjNBcnJheSgpIGhhcyBiZWVuIHJlbmFtZWQuIFVzZSBtYXRyaXguYXBwbHlUb1ZlY3RvcjNBcnJheSggYXJyYXkgKSBpbnN0ZWFkLicgKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcHBseVRvVmVjdG9yM0FycmF5KCBhICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhcHBseVRvVmVjdG9yM0FycmF5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciB2MTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCwgbGVuZ3RoICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgaWYgKCBsZW5ndGggPT09IHVuZGVmaW5lZCApIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaiA9IG9mZnNldDsgaSA8IGxlbmd0aDsgaSArPSAzLCBqICs9IDMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdjEuZnJvbUFycmF5KCBhcnJheSwgaiApO1xyXG4gICAgICAgICAgICAgICAgdjEuYXBwbHlNYXRyaXg0KCB0aGlzICk7XHJcbiAgICAgICAgICAgICAgICB2MS50b0FycmF5KCBhcnJheSwgaiApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBhcHBseVRvQnVmZmVyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciB2MTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGFwcGx5VG9CdWZmZXIoIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGggKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICBpZiAoIGxlbmd0aCA9PT0gdW5kZWZpbmVkICkgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCAvIGJ1ZmZlci5pdGVtU2l6ZTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaiA9IG9mZnNldDsgaSA8IGxlbmd0aDsgaSArKywgaiArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2MS54ID0gYnVmZmVyLmdldFgoIGogKTtcclxuICAgICAgICAgICAgICAgIHYxLnkgPSBidWZmZXIuZ2V0WSggaiApO1xyXG4gICAgICAgICAgICAgICAgdjEueiA9IGJ1ZmZlci5nZXRaKCBqICk7XHJcblxyXG4gICAgICAgICAgICAgICAgdjEuYXBwbHlNYXRyaXg0KCB0aGlzICk7XHJcblxyXG4gICAgICAgICAgICAgICAgYnVmZmVyLnNldFhZWiggdjEueCwgdjEueSwgdjEueiApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgcm90YXRlQXhpczogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAucm90YXRlQXhpcygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBWZWN0b3IzLnRyYW5zZm9ybURpcmVjdGlvbiggbWF0cml4ICkgaW5zdGVhZC4nICk7XHJcblxyXG4gICAgICAgIHYudHJhbnNmb3JtRGlyZWN0aW9uKCB0aGlzICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjcm9zc1ZlY3RvcjogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5jcm9zc1ZlY3RvcigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcclxuICAgICAgICByZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggdGhpcyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZGV0ZXJtaW5hbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcbiAgICAgICAgdmFyIG4xMSA9IHRlWyAwIF0sIG4xMiA9IHRlWyA0IF0sIG4xMyA9IHRlWyA4IF0sIG4xNCA9IHRlWyAxMiBdO1xyXG4gICAgICAgIHZhciBuMjEgPSB0ZVsgMSBdLCBuMjIgPSB0ZVsgNSBdLCBuMjMgPSB0ZVsgOSBdLCBuMjQgPSB0ZVsgMTMgXTtcclxuICAgICAgICB2YXIgbjMxID0gdGVbIDIgXSwgbjMyID0gdGVbIDYgXSwgbjMzID0gdGVbIDEwIF0sIG4zNCA9IHRlWyAxNCBdO1xyXG4gICAgICAgIHZhciBuNDEgPSB0ZVsgMyBdLCBuNDIgPSB0ZVsgNyBdLCBuNDMgPSB0ZVsgMTEgXSwgbjQ0ID0gdGVbIDE1IF07XHJcblxyXG4gICAgICAgIC8vVE9ETzogbWFrZSB0aGlzIG1vcmUgZWZmaWNpZW50XHJcbiAgICAgICAgLy8oIGJhc2VkIG9uIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bSApXHJcblxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIG40MSAqIChcclxuICAgICAgICAgICAgICAgICsgbjE0ICogbjIzICogbjMyXHJcbiAgICAgICAgICAgICAgICAtIG4xMyAqIG4yNCAqIG4zMlxyXG4gICAgICAgICAgICAgICAgLSBuMTQgKiBuMjIgKiBuMzNcclxuICAgICAgICAgICAgICAgICsgbjEyICogbjI0ICogbjMzXHJcbiAgICAgICAgICAgICAgICArIG4xMyAqIG4yMiAqIG4zNFxyXG4gICAgICAgICAgICAgICAgLSBuMTIgKiBuMjMgKiBuMzRcclxuICAgICAgICAgICAgKSArXHJcbiAgICAgICAgICAgIG40MiAqIChcclxuICAgICAgICAgICAgICAgICsgbjExICogbjIzICogbjM0XHJcbiAgICAgICAgICAgICAgICAtIG4xMSAqIG4yNCAqIG4zM1xyXG4gICAgICAgICAgICAgICAgKyBuMTQgKiBuMjEgKiBuMzNcclxuICAgICAgICAgICAgICAgIC0gbjEzICogbjIxICogbjM0XHJcbiAgICAgICAgICAgICAgICArIG4xMyAqIG4yNCAqIG4zMVxyXG4gICAgICAgICAgICAgICAgLSBuMTQgKiBuMjMgKiBuMzFcclxuICAgICAgICAgICAgKSArXHJcbiAgICAgICAgICAgIG40MyAqIChcclxuICAgICAgICAgICAgICAgICsgbjExICogbjI0ICogbjMyXHJcbiAgICAgICAgICAgICAgICAtIG4xMSAqIG4yMiAqIG4zNFxyXG4gICAgICAgICAgICAgICAgLSBuMTQgKiBuMjEgKiBuMzJcclxuICAgICAgICAgICAgICAgICsgbjEyICogbjIxICogbjM0XHJcbiAgICAgICAgICAgICAgICArIG4xNCAqIG4yMiAqIG4zMVxyXG4gICAgICAgICAgICAgICAgLSBuMTIgKiBuMjQgKiBuMzFcclxuICAgICAgICAgICAgKSArXHJcbiAgICAgICAgICAgIG40NCAqIChcclxuICAgICAgICAgICAgICAgIC0gbjEzICogbjIyICogbjMxXHJcbiAgICAgICAgICAgICAgICAtIG4xMSAqIG4yMyAqIG4zMlxyXG4gICAgICAgICAgICAgICAgKyBuMTEgKiBuMjIgKiBuMzNcclxuICAgICAgICAgICAgICAgICsgbjEzICogbjIxICogbjMyXHJcbiAgICAgICAgICAgICAgICAtIG4xMiAqIG4yMSAqIG4zM1xyXG4gICAgICAgICAgICAgICAgKyBuMTIgKiBuMjMgKiBuMzFcclxuICAgICAgICAgICAgKVxyXG5cclxuICAgICAgICApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdHJhbnNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcbiAgICAgICAgdmFyIHRtcDtcclxuXHJcbiAgICAgICAgdG1wID0gdGVbIDEgXTsgdGVbIDEgXSA9IHRlWyA0IF07IHRlWyA0IF0gPSB0bXA7XHJcbiAgICAgICAgdG1wID0gdGVbIDIgXTsgdGVbIDIgXSA9IHRlWyA4IF07IHRlWyA4IF0gPSB0bXA7XHJcbiAgICAgICAgdG1wID0gdGVbIDYgXTsgdGVbIDYgXSA9IHRlWyA5IF07IHRlWyA5IF0gPSB0bXA7XHJcblxyXG4gICAgICAgIHRtcCA9IHRlWyAzIF07IHRlWyAzIF0gPSB0ZVsgMTIgXTsgdGVbIDEyIF0gPSB0bXA7XHJcbiAgICAgICAgdG1wID0gdGVbIDcgXTsgdGVbIDcgXSA9IHRlWyAxMyBdOyB0ZVsgMTMgXSA9IHRtcDtcclxuICAgICAgICB0bXAgPSB0ZVsgMTEgXTsgdGVbIDExIF0gPSB0ZVsgMTQgXTsgdGVbIDE0IF0gPSB0bXA7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZmxhdHRlblRvQXJyYXlPZmZzZXQ6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCBdID0gdGVbIDAgXTtcclxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGVbIDEgXTtcclxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGVbIDIgXTtcclxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGVbIDMgXTtcclxuXHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDUgXSA9IHRlWyA1IF07XHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDYgXSA9IHRlWyA2IF07XHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDcgXSA9IHRlWyA3IF07XHJcblxyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyA4IF0gID0gdGVbIDggXTtcclxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgOSBdICA9IHRlWyA5IF07XHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDEwIF0gPSB0ZVsgMTAgXTtcclxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMTEgXSA9IHRlWyAxMSBdO1xyXG5cclxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMTIgXSA9IHRlWyAxMiBdO1xyXG4gICAgICAgIGFycmF5WyBvZmZzZXQgKyAxMyBdID0gdGVbIDEzIF07XHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDE0IF0gPSB0ZVsgMTQgXTtcclxuICAgICAgICBhcnJheVsgb2Zmc2V0ICsgMTUgXSA9IHRlWyAxNSBdO1xyXG5cclxuICAgICAgICByZXR1cm4gYXJyYXk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgdjE7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5nZXRQb3NpdGlvbigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBWZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbWF0cml4ICkgaW5zdGVhZC4nICk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgICAgICAgICByZXR1cm4gdjEuc2V0KCB0ZVsgMTIgXSwgdGVbIDEzIF0sIHRlWyAxNCBdICk7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG4gICAgICAgIHRlWyAxMiBdID0gdi54O1xyXG4gICAgICAgIHRlWyAxMyBdID0gdi55O1xyXG4gICAgICAgIHRlWyAxNCBdID0gdi56O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldEludmVyc2U6IGZ1bmN0aW9uICggbSwgdGhyb3dPbkludmVydGlibGUgKSB7XHJcblxyXG4gICAgICAgIC8vIGJhc2VkIG9uIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bVxyXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcbiAgICAgICAgdmFyIG1lID0gbS5lbGVtZW50cztcclxuXHJcbiAgICAgICAgdmFyIG4xMSA9IG1lWyAwIF0sIG4xMiA9IG1lWyA0IF0sIG4xMyA9IG1lWyA4IF0sIG4xNCA9IG1lWyAxMiBdO1xyXG4gICAgICAgIHZhciBuMjEgPSBtZVsgMSBdLCBuMjIgPSBtZVsgNSBdLCBuMjMgPSBtZVsgOSBdLCBuMjQgPSBtZVsgMTMgXTtcclxuICAgICAgICB2YXIgbjMxID0gbWVbIDIgXSwgbjMyID0gbWVbIDYgXSwgbjMzID0gbWVbIDEwIF0sIG4zNCA9IG1lWyAxNCBdO1xyXG4gICAgICAgIHZhciBuNDEgPSBtZVsgMyBdLCBuNDIgPSBtZVsgNyBdLCBuNDMgPSBtZVsgMTEgXSwgbjQ0ID0gbWVbIDE1IF07XHJcblxyXG4gICAgICAgIHRlWyAwIF0gPSBuMjMgKiBuMzQgKiBuNDIgLSBuMjQgKiBuMzMgKiBuNDIgKyBuMjQgKiBuMzIgKiBuNDMgLSBuMjIgKiBuMzQgKiBuNDMgLSBuMjMgKiBuMzIgKiBuNDQgKyBuMjIgKiBuMzMgKiBuNDQ7XHJcbiAgICAgICAgdGVbIDQgXSA9IG4xNCAqIG4zMyAqIG40MiAtIG4xMyAqIG4zNCAqIG40MiAtIG4xNCAqIG4zMiAqIG40MyArIG4xMiAqIG4zNCAqIG40MyArIG4xMyAqIG4zMiAqIG40NCAtIG4xMiAqIG4zMyAqIG40NDtcclxuICAgICAgICB0ZVsgOCBdID0gbjEzICogbjI0ICogbjQyIC0gbjE0ICogbjIzICogbjQyICsgbjE0ICogbjIyICogbjQzIC0gbjEyICogbjI0ICogbjQzIC0gbjEzICogbjIyICogbjQ0ICsgbjEyICogbjIzICogbjQ0O1xyXG4gICAgICAgIHRlWyAxMiBdID0gbjE0ICogbjIzICogbjMyIC0gbjEzICogbjI0ICogbjMyIC0gbjE0ICogbjIyICogbjMzICsgbjEyICogbjI0ICogbjMzICsgbjEzICogbjIyICogbjM0IC0gbjEyICogbjIzICogbjM0O1xyXG4gICAgICAgIHRlWyAxIF0gPSBuMjQgKiBuMzMgKiBuNDEgLSBuMjMgKiBuMzQgKiBuNDEgLSBuMjQgKiBuMzEgKiBuNDMgKyBuMjEgKiBuMzQgKiBuNDMgKyBuMjMgKiBuMzEgKiBuNDQgLSBuMjEgKiBuMzMgKiBuNDQ7XHJcbiAgICAgICAgdGVbIDUgXSA9IG4xMyAqIG4zNCAqIG40MSAtIG4xNCAqIG4zMyAqIG40MSArIG4xNCAqIG4zMSAqIG40MyAtIG4xMSAqIG4zNCAqIG40MyAtIG4xMyAqIG4zMSAqIG40NCArIG4xMSAqIG4zMyAqIG40NDtcclxuICAgICAgICB0ZVsgOSBdID0gbjE0ICogbjIzICogbjQxIC0gbjEzICogbjI0ICogbjQxIC0gbjE0ICogbjIxICogbjQzICsgbjExICogbjI0ICogbjQzICsgbjEzICogbjIxICogbjQ0IC0gbjExICogbjIzICogbjQ0O1xyXG4gICAgICAgIHRlWyAxMyBdID0gbjEzICogbjI0ICogbjMxIC0gbjE0ICogbjIzICogbjMxICsgbjE0ICogbjIxICogbjMzIC0gbjExICogbjI0ICogbjMzIC0gbjEzICogbjIxICogbjM0ICsgbjExICogbjIzICogbjM0O1xyXG4gICAgICAgIHRlWyAyIF0gPSBuMjIgKiBuMzQgKiBuNDEgLSBuMjQgKiBuMzIgKiBuNDEgKyBuMjQgKiBuMzEgKiBuNDIgLSBuMjEgKiBuMzQgKiBuNDIgLSBuMjIgKiBuMzEgKiBuNDQgKyBuMjEgKiBuMzIgKiBuNDQ7XHJcbiAgICAgICAgdGVbIDYgXSA9IG4xNCAqIG4zMiAqIG40MSAtIG4xMiAqIG4zNCAqIG40MSAtIG4xNCAqIG4zMSAqIG40MiArIG4xMSAqIG4zNCAqIG40MiArIG4xMiAqIG4zMSAqIG40NCAtIG4xMSAqIG4zMiAqIG40NDtcclxuICAgICAgICB0ZVsgMTAgXSA9IG4xMiAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMiAqIG40MSArIG4xNCAqIG4yMSAqIG40MiAtIG4xMSAqIG4yNCAqIG40MiAtIG4xMiAqIG4yMSAqIG40NCArIG4xMSAqIG4yMiAqIG40NDtcclxuICAgICAgICB0ZVsgMTQgXSA9IG4xNCAqIG4yMiAqIG4zMSAtIG4xMiAqIG4yNCAqIG4zMSAtIG4xNCAqIG4yMSAqIG4zMiArIG4xMSAqIG4yNCAqIG4zMiArIG4xMiAqIG4yMSAqIG4zNCAtIG4xMSAqIG4yMiAqIG4zNDtcclxuICAgICAgICB0ZVsgMyBdID0gbjIzICogbjMyICogbjQxIC0gbjIyICogbjMzICogbjQxIC0gbjIzICogbjMxICogbjQyICsgbjIxICogbjMzICogbjQyICsgbjIyICogbjMxICogbjQzIC0gbjIxICogbjMyICogbjQzO1xyXG4gICAgICAgIHRlWyA3IF0gPSBuMTIgKiBuMzMgKiBuNDEgLSBuMTMgKiBuMzIgKiBuNDEgKyBuMTMgKiBuMzEgKiBuNDIgLSBuMTEgKiBuMzMgKiBuNDIgLSBuMTIgKiBuMzEgKiBuNDMgKyBuMTEgKiBuMzIgKiBuNDM7XHJcbiAgICAgICAgdGVbIDExIF0gPSBuMTMgKiBuMjIgKiBuNDEgLSBuMTIgKiBuMjMgKiBuNDEgLSBuMTMgKiBuMjEgKiBuNDIgKyBuMTEgKiBuMjMgKiBuNDIgKyBuMTIgKiBuMjEgKiBuNDMgLSBuMTEgKiBuMjIgKiBuNDM7XHJcbiAgICAgICAgdGVbIDE1IF0gPSBuMTIgKiBuMjMgKiBuMzEgLSBuMTMgKiBuMjIgKiBuMzEgKyBuMTMgKiBuMjEgKiBuMzIgLSBuMTEgKiBuMjMgKiBuMzIgLSBuMTIgKiBuMjEgKiBuMzMgKyBuMTEgKiBuMjIgKiBuMzM7XHJcblxyXG4gICAgICAgIHZhciBkZXQgPSBuMTEgKiB0ZVsgMCBdICsgbjIxICogdGVbIDQgXSArIG4zMSAqIHRlWyA4IF0gKyBuNDEgKiB0ZVsgMTIgXTtcclxuXHJcbiAgICAgICAgaWYgKCBkZXQgPT09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbXNnID0gXCJUSFJFRS5NYXRyaXg0LmdldEludmVyc2UoKTogY2FuJ3QgaW52ZXJ0IG1hdHJpeCwgZGV0ZXJtaW5hbnQgaXMgMFwiO1xyXG5cclxuICAgICAgICAgICAgaWYgKCB0aHJvd09uSW52ZXJ0aWJsZSB8fCBmYWxzZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oIG1zZyApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5pZGVudGl0eSgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5tdWx0aXBseVNjYWxhciggMSAvIGRldCApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLnRyYW5zbGF0ZSgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcm90YXRlWDogZnVuY3Rpb24gKCBhbmdsZSApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVYKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICByb3RhdGVZOiBmdW5jdGlvbiAoIGFuZ2xlICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZVkoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJvdGF0ZVo6IGZ1bmN0aW9uICggYW5nbGUgKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAucm90YXRlWigpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcm90YXRlQnlBeGlzOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZUJ5QXhpcygpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2NhbGU6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICB2YXIgeCA9IHYueCwgeSA9IHYueSwgeiA9IHYuejtcclxuXHJcbiAgICAgICAgdGVbIDAgXSAqPSB4OyB0ZVsgNCBdICo9IHk7IHRlWyA4IF0gKj0gejtcclxuICAgICAgICB0ZVsgMSBdICo9IHg7IHRlWyA1IF0gKj0geTsgdGVbIDkgXSAqPSB6O1xyXG4gICAgICAgIHRlWyAyIF0gKj0geDsgdGVbIDYgXSAqPSB5OyB0ZVsgMTAgXSAqPSB6O1xyXG4gICAgICAgIHRlWyAzIF0gKj0geDsgdGVbIDcgXSAqPSB5OyB0ZVsgMTEgXSAqPSB6O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldE1heFNjYWxlT25BeGlzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG4gICAgICAgIHZhciBzY2FsZVhTcSA9IHRlWyAwIF0gKiB0ZVsgMCBdICsgdGVbIDEgXSAqIHRlWyAxIF0gKyB0ZVsgMiBdICogdGVbIDIgXTtcclxuICAgICAgICB2YXIgc2NhbGVZU3EgPSB0ZVsgNCBdICogdGVbIDQgXSArIHRlWyA1IF0gKiB0ZVsgNSBdICsgdGVbIDYgXSAqIHRlWyA2IF07XHJcbiAgICAgICAgdmFyIHNjYWxlWlNxID0gdGVbIDggXSAqIHRlWyA4IF0gKyB0ZVsgOSBdICogdGVbIDkgXSArIHRlWyAxMCBdICogdGVbIDEwIF07XHJcblxyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoIE1hdGgubWF4KCBzY2FsZVhTcSwgc2NhbGVZU3EsIHNjYWxlWlNxICkgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG1ha2VUcmFuc2xhdGlvbjogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xyXG5cclxuICAgICAgICB0aGlzLnNldChcclxuXHJcbiAgICAgICAgICAgIDEsIDAsIDAsIHgsXHJcbiAgICAgICAgICAgIDAsIDEsIDAsIHksXHJcbiAgICAgICAgICAgIDAsIDAsIDEsIHosXHJcbiAgICAgICAgICAgIDAsIDAsIDAsIDFcclxuXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBtYWtlUm90YXRpb25YOiBmdW5jdGlvbiAoIHRoZXRhICkge1xyXG5cclxuICAgICAgICB2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0KFxyXG5cclxuICAgICAgICAgICAgMSwgMCwgIDAsIDAsXHJcbiAgICAgICAgICAgIDAsIGMsIC0gcywgMCxcclxuICAgICAgICAgICAgMCwgcywgIGMsIDAsXHJcbiAgICAgICAgICAgIDAsIDAsICAwLCAxXHJcblxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbWFrZVJvdGF0aW9uWTogZnVuY3Rpb24gKCB0aGV0YSApIHtcclxuXHJcbiAgICAgICAgdmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xyXG5cclxuICAgICAgICB0aGlzLnNldChcclxuXHJcbiAgICAgICAgICAgIGMsIDAsIHMsIDAsXHJcbiAgICAgICAgICAgIDAsIDEsIDAsIDAsXHJcbiAgICAgICAgICAgIC0gcywgMCwgYywgMCxcclxuICAgICAgICAgICAgMCwgMCwgMCwgMVxyXG5cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG1ha2VSb3RhdGlvblo6IGZ1bmN0aW9uICggdGhldGEgKSB7XHJcblxyXG4gICAgICAgIHZhciBjID0gTWF0aC5jb3MoIHRoZXRhICksIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcclxuXHJcbiAgICAgICAgdGhpcy5zZXQoXHJcblxyXG4gICAgICAgICAgICBjLCAtIHMsIDAsIDAsXHJcbiAgICAgICAgICAgIHMsICBjLCAwLCAwLFxyXG4gICAgICAgICAgICAwLCAgMCwgMSwgMCxcclxuICAgICAgICAgICAgMCwgIDAsIDAsIDFcclxuXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBtYWtlUm90YXRpb25BeGlzOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xyXG5cclxuICAgICAgICAvLyBCYXNlZCBvbiBodHRwOi8vd3d3LmdhbWVkZXYubmV0L3JlZmVyZW5jZS9hcnRpY2xlcy9hcnRpY2xlMTE5OS5hc3BcclxuXHJcbiAgICAgICAgdmFyIGMgPSBNYXRoLmNvcyggYW5nbGUgKTtcclxuICAgICAgICB2YXIgcyA9IE1hdGguc2luKCBhbmdsZSApO1xyXG4gICAgICAgIHZhciB0ID0gMSAtIGM7XHJcbiAgICAgICAgdmFyIHggPSBheGlzLngsIHkgPSBheGlzLnksIHogPSBheGlzLno7XHJcbiAgICAgICAgdmFyIHR4ID0gdCAqIHgsIHR5ID0gdCAqIHk7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0KFxyXG5cclxuICAgICAgICAgICAgdHggKiB4ICsgYywgdHggKiB5IC0gcyAqIHosIHR4ICogeiArIHMgKiB5LCAwLFxyXG4gICAgICAgICAgICB0eCAqIHkgKyBzICogeiwgdHkgKiB5ICsgYywgdHkgKiB6IC0gcyAqIHgsIDAsXHJcbiAgICAgICAgICAgIHR4ICogeiAtIHMgKiB5LCB0eSAqIHogKyBzICogeCwgdCAqIHogKiB6ICsgYywgMCxcclxuICAgICAgICAgICAgMCwgMCwgMCwgMVxyXG5cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG1ha2VTY2FsZTogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xyXG5cclxuICAgICAgICB0aGlzLnNldChcclxuXHJcbiAgICAgICAgICAgIHgsIDAsIDAsIDAsXHJcbiAgICAgICAgICAgIDAsIHksIDAsIDAsXHJcbiAgICAgICAgICAgIDAsIDAsIHosIDAsXHJcbiAgICAgICAgICAgIDAsIDAsIDAsIDFcclxuXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb21wb3NlOiBmdW5jdGlvbiAoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xyXG4gICAgICAgIHRoaXMuc2NhbGUoIHNjYWxlICk7XHJcbiAgICAgICAgdGhpcy5zZXRQb3NpdGlvbiggcG9zaXRpb24gKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBkZWNvbXBvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHZlY3RvciwgbWF0cml4O1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHZlY3RvciA9PT0gdW5kZWZpbmVkICkgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICAgICAgaWYgKCBtYXRyaXggPT09IHVuZGVmaW5lZCApIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuICAgICAgICAgICAgdmFyIHN4ID0gdmVjdG9yLnNldCggdGVbIDAgXSwgdGVbIDEgXSwgdGVbIDIgXSApLmxlbmd0aCgpO1xyXG4gICAgICAgICAgICB2YXIgc3kgPSB2ZWN0b3Iuc2V0KCB0ZVsgNCBdLCB0ZVsgNSBdLCB0ZVsgNiBdICkubGVuZ3RoKCk7XHJcbiAgICAgICAgICAgIHZhciBzeiA9IHZlY3Rvci5zZXQoIHRlWyA4IF0sIHRlWyA5IF0sIHRlWyAxMCBdICkubGVuZ3RoKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBpZiBkZXRlcm1pbmUgaXMgbmVnYXRpdmUsIHdlIG5lZWQgdG8gaW52ZXJ0IG9uZSBzY2FsZVxyXG4gICAgICAgICAgICB2YXIgZGV0ID0gdGhpcy5kZXRlcm1pbmFudCgpO1xyXG4gICAgICAgICAgICBpZiAoIGRldCA8IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgc3ggPSAtIHN4O1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcG9zaXRpb24ueCA9IHRlWyAxMiBdO1xyXG4gICAgICAgICAgICBwb3NpdGlvbi55ID0gdGVbIDEzIF07XHJcbiAgICAgICAgICAgIHBvc2l0aW9uLnogPSB0ZVsgMTQgXTtcclxuXHJcbiAgICAgICAgICAgIC8vIHNjYWxlIHRoZSByb3RhdGlvbiBwYXJ0XHJcblxyXG4gICAgICAgICAgICBtYXRyaXguZWxlbWVudHMuc2V0KCB0aGlzLmVsZW1lbnRzICk7IC8vIGF0IHRoaXMgcG9pbnQgbWF0cml4IGlzIGluY29tcGxldGUgc28gd2UgY2FuJ3QgdXNlIC5jb3B5KClcclxuXHJcbiAgICAgICAgICAgIHZhciBpbnZTWCA9IDEgLyBzeDtcclxuICAgICAgICAgICAgdmFyIGludlNZID0gMSAvIHN5O1xyXG4gICAgICAgICAgICB2YXIgaW52U1ogPSAxIC8gc3o7XHJcblxyXG4gICAgICAgICAgICBtYXRyaXguZWxlbWVudHNbIDAgXSAqPSBpbnZTWDtcclxuICAgICAgICAgICAgbWF0cml4LmVsZW1lbnRzWyAxIF0gKj0gaW52U1g7XHJcbiAgICAgICAgICAgIG1hdHJpeC5lbGVtZW50c1sgMiBdICo9IGludlNYO1xyXG5cclxuICAgICAgICAgICAgbWF0cml4LmVsZW1lbnRzWyA0IF0gKj0gaW52U1k7XHJcbiAgICAgICAgICAgIG1hdHJpeC5lbGVtZW50c1sgNSBdICo9IGludlNZO1xyXG4gICAgICAgICAgICBtYXRyaXguZWxlbWVudHNbIDYgXSAqPSBpbnZTWTtcclxuXHJcbiAgICAgICAgICAgIG1hdHJpeC5lbGVtZW50c1sgOCBdICo9IGludlNaO1xyXG4gICAgICAgICAgICBtYXRyaXguZWxlbWVudHNbIDkgXSAqPSBpbnZTWjtcclxuICAgICAgICAgICAgbWF0cml4LmVsZW1lbnRzWyAxMCBdICo9IGludlNaO1xyXG5cclxuICAgICAgICAgICAgcXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG1hdHJpeCApO1xyXG5cclxuICAgICAgICAgICAgc2NhbGUueCA9IHN4O1xyXG4gICAgICAgICAgICBzY2FsZS55ID0gc3k7XHJcbiAgICAgICAgICAgIHNjYWxlLnogPSBzejtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBtYWtlRnJ1c3R1bTogZnVuY3Rpb24gKCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhciApIHtcclxuXHJcbiAgICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICB2YXIgeCA9IDIgKiBuZWFyIC8gKCByaWdodCAtIGxlZnQgKTtcclxuICAgICAgICB2YXIgeSA9IDIgKiBuZWFyIC8gKCB0b3AgLSBib3R0b20gKTtcclxuXHJcbiAgICAgICAgdmFyIGEgPSAoIHJpZ2h0ICsgbGVmdCApIC8gKCByaWdodCAtIGxlZnQgKTtcclxuICAgICAgICB2YXIgYiA9ICggdG9wICsgYm90dG9tICkgLyAoIHRvcCAtIGJvdHRvbSApO1xyXG4gICAgICAgIHZhciBjID0gLSAoIGZhciArIG5lYXIgKSAvICggZmFyIC0gbmVhciApO1xyXG4gICAgICAgIHZhciBkID0gLSAyICogZmFyICogbmVhciAvICggZmFyIC0gbmVhciApO1xyXG5cclxuICAgICAgICB0ZVsgMCBdID0geDtcdHRlWyA0IF0gPSAwO1x0dGVbIDggXSA9IGE7XHR0ZVsgMTIgXSA9IDA7XHJcbiAgICAgICAgdGVbIDEgXSA9IDA7XHR0ZVsgNSBdID0geTtcdHRlWyA5IF0gPSBiO1x0dGVbIDEzIF0gPSAwO1xyXG4gICAgICAgIHRlWyAyIF0gPSAwO1x0dGVbIDYgXSA9IDA7XHR0ZVsgMTAgXSA9IGM7XHR0ZVsgMTQgXSA9IGQ7XHJcbiAgICAgICAgdGVbIDMgXSA9IDA7XHR0ZVsgNyBdID0gMDtcdHRlWyAxMSBdID0gLSAxO1x0dGVbIDE1IF0gPSAwO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG1ha2VQZXJzcGVjdGl2ZTogZnVuY3Rpb24gKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICkge1xyXG5cclxuICAgICAgICB2YXIgeW1heCA9IG5lYXIgKiBNYXRoLnRhbiggVEhSRUUuTWF0aC5kZWdUb1JhZCggZm92ICogMC41ICkgKTtcclxuICAgICAgICB2YXIgeW1pbiA9IC0geW1heDtcclxuICAgICAgICB2YXIgeG1pbiA9IHltaW4gKiBhc3BlY3Q7XHJcbiAgICAgICAgdmFyIHhtYXggPSB5bWF4ICogYXNwZWN0O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5tYWtlRnJ1c3R1bSggeG1pbiwgeG1heCwgeW1pbiwgeW1heCwgbmVhciwgZmFyICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBtYWtlT3J0aG9ncmFwaGljOiBmdW5jdGlvbiAoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyICkge1xyXG5cclxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgICAgIHZhciB3ID0gcmlnaHQgLSBsZWZ0O1xyXG4gICAgICAgIHZhciBoID0gdG9wIC0gYm90dG9tO1xyXG4gICAgICAgIHZhciBwID0gZmFyIC0gbmVhcjtcclxuXHJcbiAgICAgICAgdmFyIHggPSAoIHJpZ2h0ICsgbGVmdCApIC8gdztcclxuICAgICAgICB2YXIgeSA9ICggdG9wICsgYm90dG9tICkgLyBoO1xyXG4gICAgICAgIHZhciB6ID0gKCBmYXIgKyBuZWFyICkgLyBwO1xyXG5cclxuICAgICAgICB0ZVsgMCBdID0gMiAvIHc7XHR0ZVsgNCBdID0gMDtcdHRlWyA4IF0gPSAwO1x0dGVbIDEyIF0gPSAtIHg7XHJcbiAgICAgICAgdGVbIDEgXSA9IDA7XHR0ZVsgNSBdID0gMiAvIGg7XHR0ZVsgOSBdID0gMDtcdHRlWyAxMyBdID0gLSB5O1xyXG4gICAgICAgIHRlWyAyIF0gPSAwO1x0dGVbIDYgXSA9IDA7XHR0ZVsgMTAgXSA9IC0gMiAvIHA7XHR0ZVsgMTQgXSA9IC0gejtcclxuICAgICAgICB0ZVsgMyBdID0gMDtcdHRlWyA3IF0gPSAwO1x0dGVbIDExIF0gPSAwO1x0dGVbIDE1IF0gPSAxO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGVxdWFsczogZnVuY3Rpb24gKCBtYXRyaXggKSB7XHJcblxyXG4gICAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcbiAgICAgICAgdmFyIG1lID0gbWF0cml4LmVsZW1lbnRzO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCAxNjsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggdGVbIGkgXSAhPT0gbWVbIGkgXSApIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5lbGVtZW50cy5zZXQoIGFycmF5ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdG9BcnJheTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICB0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdLCB0ZVsgMyBdLFxyXG4gICAgICAgICAgICB0ZVsgNCBdLCB0ZVsgNSBdLCB0ZVsgNiBdLCB0ZVsgNyBdLFxyXG4gICAgICAgICAgICB0ZVsgOCBdLCB0ZVsgOSBdLCB0ZVsgMTAgXSwgdGVbIDExIF0sXHJcbiAgICAgICAgICAgIHRlWyAxMiBdLCB0ZVsgMTMgXSwgdGVbIDE0IF0sIHRlWyAxNSBdXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9SYXkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXHJcbiAqL1xyXG5cclxuVEhSRUUuUmF5ID0gZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiApIHtcclxuXHJcbiAgICB0aGlzLm9yaWdpbiA9ICggb3JpZ2luICE9PSB1bmRlZmluZWQgKSA/IG9yaWdpbiA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICB0aGlzLmRpcmVjdGlvbiA9ICggZGlyZWN0aW9uICE9PSB1bmRlZmluZWQgKSA/IGRpcmVjdGlvbiA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUmF5LnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuUmF5LFxyXG5cclxuICAgIHNldDogZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiApIHtcclxuXHJcbiAgICAgICAgdGhpcy5vcmlnaW4uY29weSggb3JpZ2luICk7XHJcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24uY29weSggZGlyZWN0aW9uICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29weTogZnVuY3Rpb24gKCByYXkgKSB7XHJcblxyXG4gICAgICAgIHRoaXMub3JpZ2luLmNvcHkoIHJheS5vcmlnaW4gKTtcclxuICAgICAgICB0aGlzLmRpcmVjdGlvbi5jb3B5KCByYXkuZGlyZWN0aW9uICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYXQ6IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMub3JpZ2luICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICByZWNhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggdCApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMub3JpZ2luLmNvcHkoIHRoaXMuYXQoIHQsIHYxICkgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBjbG9zZXN0UG9pbnRUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgcmVzdWx0LnN1YlZlY3RvcnMoIHBvaW50LCB0aGlzLm9yaWdpbiApO1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb25EaXN0YW5jZSA9IHJlc3VsdC5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XHJcblxyXG4gICAgICAgIGlmICggZGlyZWN0aW9uRGlzdGFuY2UgPCAwICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLm9yaWdpbiApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggZGlyZWN0aW9uRGlzdGFuY2UgKS5hZGQoIHRoaXMub3JpZ2luICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VTcVRvUG9pbnQoIHBvaW50ICkgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRpc3RhbmNlU3FUb1BvaW50OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGRpcmVjdGlvbkRpc3RhbmNlID0gdjEuc3ViVmVjdG9ycyggcG9pbnQsIHRoaXMub3JpZ2luICkuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xyXG5cclxuICAgICAgICAgICAgLy8gcG9pbnQgYmVoaW5kIHRoZSByYXlcclxuXHJcbiAgICAgICAgICAgIGlmICggZGlyZWN0aW9uRGlzdGFuY2UgPCAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9yaWdpbi5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHYxLmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIGRpcmVjdGlvbkRpc3RhbmNlICkuYWRkKCB0aGlzLm9yaWdpbiApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHYxLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBkaXN0YW5jZVNxVG9TZWdtZW50OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWdDZW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgIHZhciBzZWdEaXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgIHZhciBkaWZmID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggdjAsIHYxLCBvcHRpb25hbFBvaW50T25SYXksIG9wdGlvbmFsUG9pbnRPblNlZ21lbnQgKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBmcm9tIGh0dHA6Ly93d3cuZ2VvbWV0cmljdG9vbHMuY29tL0xpYk1hdGhlbWF0aWNzL0Rpc3RhbmNlL1dtNURpc3RSYXkzU2VnbWVudDMuY3BwXHJcbiAgICAgICAgICAgIC8vIEl0IHJldHVybnMgdGhlIG1pbiBkaXN0YW5jZSBiZXR3ZWVuIHRoZSByYXkgYW5kIHRoZSBzZWdtZW50XHJcbiAgICAgICAgICAgIC8vIGRlZmluZWQgYnkgdjAgYW5kIHYxXHJcbiAgICAgICAgICAgIC8vIEl0IGNhbiBhbHNvIHNldCB0d28gb3B0aW9uYWwgdGFyZ2V0cyA6XHJcbiAgICAgICAgICAgIC8vIC0gVGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIHJheVxyXG4gICAgICAgICAgICAvLyAtIFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBzZWdtZW50XHJcblxyXG4gICAgICAgICAgICBzZWdDZW50ZXIuY29weSggdjAgKS5hZGQoIHYxICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xyXG4gICAgICAgICAgICBzZWdEaXIuY29weSggdjEgKS5zdWIoIHYwICkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgIGRpZmYuY29weSggdGhpcy5vcmlnaW4gKS5zdWIoIHNlZ0NlbnRlciApO1xyXG5cclxuICAgICAgICAgICAgdmFyIHNlZ0V4dGVudCA9IHYwLmRpc3RhbmNlVG8oIHYxICkgKiAwLjU7XHJcbiAgICAgICAgICAgIHZhciBhMDEgPSAtIHRoaXMuZGlyZWN0aW9uLmRvdCggc2VnRGlyICk7XHJcbiAgICAgICAgICAgIHZhciBiMCA9IGRpZmYuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xyXG4gICAgICAgICAgICB2YXIgYjEgPSAtIGRpZmYuZG90KCBzZWdEaXIgKTtcclxuICAgICAgICAgICAgdmFyIGMgPSBkaWZmLmxlbmd0aFNxKCk7XHJcbiAgICAgICAgICAgIHZhciBkZXQgPSBNYXRoLmFicyggMSAtIGEwMSAqIGEwMSApO1xyXG4gICAgICAgICAgICB2YXIgczAsIHMxLCBzcXJEaXN0LCBleHREZXQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGRldCA+IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVGhlIHJheSBhbmQgc2VnbWVudCBhcmUgbm90IHBhcmFsbGVsLlxyXG5cclxuICAgICAgICAgICAgICAgIHMwID0gYTAxICogYjEgLSBiMDtcclxuICAgICAgICAgICAgICAgIHMxID0gYTAxICogYjAgLSBiMTtcclxuICAgICAgICAgICAgICAgIGV4dERldCA9IHNlZ0V4dGVudCAqIGRldDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHMwID49IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggczEgPj0gLSBleHREZXQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHMxIDw9IGV4dERldCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWdpb24gMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWluaW11bSBhdCBpbnRlcmlvciBwb2ludHMgb2YgcmF5IGFuZCBzZWdtZW50LlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnZEZXQgPSAxIC8gZGV0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgKj0gaW52RGV0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgczEgKj0gaW52RGV0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3FyRGlzdCA9IHMwICogKCBzMCArIGEwMSAqIHMxICsgMiAqIGIwICkgKyBzMSAqICggYTAxICogczAgKyBzMSArIDIgKiBiMSApICsgYztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVnaW9uIDFcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMSA9IHNlZ0V4dGVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gTWF0aC5tYXgoIDAsIC0gKCBhMDEgKiBzMSArIGIwICkgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWdpb24gNVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgczEgPSAtIHNlZ0V4dGVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHMxICsgYjAgKSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzMSA8PSAtIGV4dERldCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlZ2lvbiA0XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzMCA9IE1hdGgubWF4KCAwLCAtICggLSBhMDEgKiBzZWdFeHRlbnQgKyBiMCApICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHMxID0gKCBzMCA+IDAgKSA/IC0gc2VnRXh0ZW50IDogTWF0aC5taW4oIE1hdGgubWF4KCAtIHNlZ0V4dGVudCwgLSBiMSApLCBzZWdFeHRlbnQgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggczEgPD0gZXh0RGV0ICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVnaW9uIDNcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgczEgPSBNYXRoLm1pbiggTWF0aC5tYXgoIC0gc2VnRXh0ZW50LCAtIGIxICksIHNlZ0V4dGVudCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcXJEaXN0ID0gczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVnaW9uIDJcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gTWF0aC5tYXgoIDAsIC0gKCBhMDEgKiBzZWdFeHRlbnQgKyBiMCApICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHMxID0gKCBzMCA+IDAgKSA/IHNlZ0V4dGVudCA6IE1hdGgubWluKCBNYXRoLm1heCggLSBzZWdFeHRlbnQsIC0gYjEgKSwgc2VnRXh0ZW50ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJheSBhbmQgc2VnbWVudCBhcmUgcGFyYWxsZWwuXHJcblxyXG4gICAgICAgICAgICAgICAgczEgPSAoIGEwMSA+IDAgKSA/IC0gc2VnRXh0ZW50IDogc2VnRXh0ZW50O1xyXG4gICAgICAgICAgICAgICAgczAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHMxICsgYjAgKSApO1xyXG4gICAgICAgICAgICAgICAgc3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggb3B0aW9uYWxQb2ludE9uUmF5ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIG9wdGlvbmFsUG9pbnRPblJheS5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCBzMCApLmFkZCggdGhpcy5vcmlnaW4gKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggb3B0aW9uYWxQb2ludE9uU2VnbWVudCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBvcHRpb25hbFBvaW50T25TZWdtZW50LmNvcHkoIHNlZ0RpciApLm11bHRpcGx5U2NhbGFyKCBzMSApLmFkZCggc2VnQ2VudGVyICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc3FyRGlzdDtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG5cclxuICAgIGlzSW50ZXJzZWN0aW9uU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzdGFuY2VUb1BvaW50KCBzcGhlcmUuY2VudGVyICkgPD0gc3BoZXJlLnJhZGl1cztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGludGVyc2VjdFNwaGVyZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAvLyBmcm9tIGh0dHA6Ly93d3cuc2NyYXRjaGFwaXhlbC5jb20vbGVzc29ucy8zZC1iYXNpYy1sZXNzb25zL2xlc3Nvbi03LWludGVyc2VjdGluZy1zaW1wbGUtc2hhcGVzL3JheS1zcGhlcmUtaW50ZXJzZWN0aW9uL1xyXG5cclxuICAgICAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCBzcGhlcmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuICAgICAgICAgICAgdjEuc3ViVmVjdG9ycyggc3BoZXJlLmNlbnRlciwgdGhpcy5vcmlnaW4gKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB0Y2EgPSB2MS5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XHJcblxyXG4gICAgICAgICAgICB2YXIgZDIgPSB2MS5kb3QoIHYxICkgLSB0Y2EgKiB0Y2E7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmFkaXVzMiA9IHNwaGVyZS5yYWRpdXMgKiBzcGhlcmUucmFkaXVzO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBkMiA+IHJhZGl1czIgKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIHZhciB0aGMgPSBNYXRoLnNxcnQoIHJhZGl1czIgLSBkMiApO1xyXG5cclxuICAgICAgICAgICAgLy8gdDAgPSBmaXJzdCBpbnRlcnNlY3QgcG9pbnQgLSBlbnRyYW5jZSBvbiBmcm9udCBvZiBzcGhlcmVcclxuICAgICAgICAgICAgdmFyIHQwID0gdGNhIC0gdGhjO1xyXG5cclxuICAgICAgICAgICAgLy8gdDEgPSBzZWNvbmQgaW50ZXJzZWN0IHBvaW50IC0gZXhpdCBwb2ludCBvbiBiYWNrIG9mIHNwaGVyZVxyXG4gICAgICAgICAgICB2YXIgdDEgPSB0Y2EgKyB0aGM7XHJcblxyXG4gICAgICAgICAgICAvLyB0ZXN0IHRvIHNlZSBpZiBib3RoIHQwIGFuZCB0MSBhcmUgYmVoaW5kIHRoZSByYXkgLSBpZiBzbywgcmV0dXJuIG51bGxcclxuICAgICAgICAgICAgaWYgKCB0MCA8IDAgJiYgdDEgPCAwICkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgICAgICAvLyB0ZXN0IHRvIHNlZSBpZiB0MCBpcyBiZWhpbmQgdGhlIHJheTpcclxuICAgICAgICAgICAgLy8gaWYgaXQgaXMsIHRoZSByYXkgaXMgaW5zaWRlIHRoZSBzcGhlcmUsIHNvIHJldHVybiB0aGUgc2Vjb25kIGV4aXQgcG9pbnQgc2NhbGVkIGJ5IHQxLFxyXG4gICAgICAgICAgICAvLyBpbiBvcmRlciB0byBhbHdheXMgcmV0dXJuIGFuIGludGVyc2VjdCBwb2ludCB0aGF0IGlzIGluIGZyb250IG9mIHRoZSByYXkuXHJcbiAgICAgICAgICAgIGlmICggdDAgPCAwICkgcmV0dXJuIHRoaXMuYXQoIHQxLCBvcHRpb25hbFRhcmdldCApO1xyXG5cclxuICAgICAgICAgICAgLy8gZWxzZSB0MCBpcyBpbiBmcm9udCBvZiB0aGUgcmF5LCBzbyByZXR1cm4gdGhlIGZpcnN0IGNvbGxpc2lvbiBwb2ludCBzY2FsZWQgYnkgdDBcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXQoIHQwLCBvcHRpb25hbFRhcmdldCApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIGlzSW50ZXJzZWN0aW9uUGxhbmU6IGZ1bmN0aW9uICggcGxhbmUgKSB7XHJcblxyXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSByYXkgbGllcyBvbiB0aGUgcGxhbmUgZmlyc3RcclxuXHJcbiAgICAgICAgdmFyIGRpc3RUb1BvaW50ID0gcGxhbmUuZGlzdGFuY2VUb1BvaW50KCB0aGlzLm9yaWdpbiApO1xyXG5cclxuICAgICAgICBpZiAoIGRpc3RUb1BvaW50ID09PSAwICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gcGxhbmUubm9ybWFsLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcclxuXHJcbiAgICAgICAgaWYgKCBkZW5vbWluYXRvciAqIGRpc3RUb1BvaW50IDwgMCApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJheSBvcmlnaW4gaXMgYmVoaW5kIHRoZSBwbGFuZSAoYW5kIGlzIHBvaW50aW5nIGJlaGluZCBpdClcclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZGlzdGFuY2VUb1BsYW5lOiBmdW5jdGlvbiAoIHBsYW5lICkge1xyXG5cclxuICAgICAgICB2YXIgZGVub21pbmF0b3IgPSBwbGFuZS5ub3JtYWwuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xyXG4gICAgICAgIGlmICggZGVub21pbmF0b3IgPT09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBsaW5lIGlzIGNvcGxhbmFyLCByZXR1cm4gb3JpZ2luXHJcbiAgICAgICAgICAgIGlmICggcGxhbmUuZGlzdGFuY2VUb1BvaW50KCB0aGlzLm9yaWdpbiApID09PSAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTnVsbCBpcyBwcmVmZXJhYmxlIHRvIHVuZGVmaW5lZCBzaW5jZSB1bmRlZmluZWQgbWVhbnMuLi4uIGl0IGlzIHVuZGVmaW5lZFxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHQgPSAtICggdGhpcy5vcmlnaW4uZG90KCBwbGFuZS5ub3JtYWwgKSArIHBsYW5lLmNvbnN0YW50ICkgLyBkZW5vbWluYXRvcjtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIGlmIHRoZSByYXkgbmV2ZXIgaW50ZXJzZWN0cyB0aGUgcGxhbmVcclxuXHJcbiAgICAgICAgcmV0dXJuIHQgPj0gMCA/IHQgOiAgbnVsbDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGludGVyc2VjdFBsYW5lOiBmdW5jdGlvbiAoIHBsYW5lLCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcbiAgICAgICAgdmFyIHQgPSB0aGlzLmRpc3RhbmNlVG9QbGFuZSggcGxhbmUgKTtcclxuXHJcbiAgICAgICAgaWYgKCB0ID09PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXQoIHQsIG9wdGlvbmFsVGFyZ2V0ICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBpc0ludGVyc2VjdGlvbkJveDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgdiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVyc2VjdEJveCggYm94LCB2ICkgIT09IG51bGw7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIGludGVyc2VjdEJveDogZnVuY3Rpb24gKCBib3gsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuICAgICAgICAvLyBodHRwOi8vd3d3LnNjcmF0Y2hhcGl4ZWwuY29tL2xlc3NvbnMvM2QtYmFzaWMtbGVzc29ucy9sZXNzb24tNy1pbnRlcnNlY3Rpbmctc2ltcGxlLXNoYXBlcy9yYXktYm94LWludGVyc2VjdGlvbi9cclxuXHJcbiAgICAgICAgdmFyIHRtaW4sIHRtYXgsIHR5bWluLCB0eW1heCwgdHptaW4sIHR6bWF4O1xyXG5cclxuICAgICAgICB2YXIgaW52ZGlyeCA9IDEgLyB0aGlzLmRpcmVjdGlvbi54LFxyXG4gICAgICAgICAgICBpbnZkaXJ5ID0gMSAvIHRoaXMuZGlyZWN0aW9uLnksXHJcbiAgICAgICAgICAgIGludmRpcnogPSAxIC8gdGhpcy5kaXJlY3Rpb24uejtcclxuXHJcbiAgICAgICAgdmFyIG9yaWdpbiA9IHRoaXMub3JpZ2luO1xyXG5cclxuICAgICAgICBpZiAoIGludmRpcnggPj0gMCApIHtcclxuXHJcbiAgICAgICAgICAgIHRtaW4gPSAoIGJveC5taW4ueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xyXG4gICAgICAgICAgICB0bWF4ID0gKCBib3gubWF4LnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIHRtaW4gPSAoIGJveC5tYXgueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xyXG4gICAgICAgICAgICB0bWF4ID0gKCBib3gubWluLnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIGludmRpcnkgPj0gMCApIHtcclxuXHJcbiAgICAgICAgICAgIHR5bWluID0gKCBib3gubWluLnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcclxuICAgICAgICAgICAgdHltYXggPSAoIGJveC5tYXgueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgdHltaW4gPSAoIGJveC5tYXgueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xyXG4gICAgICAgICAgICB0eW1heCA9ICggYm94Lm1pbi55IC0gb3JpZ2luLnkgKSAqIGludmRpcnk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCAoIHRtaW4gPiB0eW1heCApIHx8ICggdHltaW4gPiB0bWF4ICkgKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gVGhlc2UgbGluZXMgYWxzbyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdG1pbiBvciB0bWF4IGlzIE5hTlxyXG4gICAgICAgIC8vIChyZXN1bHQgb2YgMCAqIEluZmluaXR5KS4geCAhPT0geCByZXR1cm5zIHRydWUgaWYgeCBpcyBOYU5cclxuXHJcbiAgICAgICAgaWYgKCB0eW1pbiA+IHRtaW4gfHwgdG1pbiAhPT0gdG1pbiApIHRtaW4gPSB0eW1pbjtcclxuXHJcbiAgICAgICAgaWYgKCB0eW1heCA8IHRtYXggfHwgdG1heCAhPT0gdG1heCApIHRtYXggPSB0eW1heDtcclxuXHJcbiAgICAgICAgaWYgKCBpbnZkaXJ6ID49IDAgKSB7XHJcblxyXG4gICAgICAgICAgICB0em1pbiA9ICggYm94Lm1pbi56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XHJcbiAgICAgICAgICAgIHR6bWF4ID0gKCBib3gubWF4LnogLSBvcmlnaW4ueiApICogaW52ZGlyejtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIHR6bWluID0gKCBib3gubWF4LnogLSBvcmlnaW4ueiApICogaW52ZGlyejtcclxuICAgICAgICAgICAgdHptYXggPSAoIGJveC5taW4ueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggKCB0bWluID4gdHptYXggKSB8fCAoIHR6bWluID4gdG1heCApICkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIGlmICggdHptaW4gPiB0bWluIHx8IHRtaW4gIT09IHRtaW4gKSB0bWluID0gdHptaW47XHJcblxyXG4gICAgICAgIGlmICggdHptYXggPCB0bWF4IHx8IHRtYXggIT09IHRtYXggKSB0bWF4ID0gdHptYXg7XHJcblxyXG4gICAgICAgIC8vcmV0dXJuIHBvaW50IGNsb3Nlc3QgdG8gdGhlIHJheSAocG9zaXRpdmUgc2lkZSlcclxuXHJcbiAgICAgICAgaWYgKCB0bWF4IDwgMCApIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5hdCggdG1pbiA+PSAwID8gdG1pbiA6IHRtYXgsIG9wdGlvbmFsVGFyZ2V0ICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBpbnRlcnNlY3RUcmlhbmdsZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAvLyBDb21wdXRlIHRoZSBvZmZzZXQgb3JpZ2luLCBlZGdlcywgYW5kIG5vcm1hbC5cclxuICAgICAgICB2YXIgZGlmZiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgdmFyIGVkZ2UxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICB2YXIgZWRnZTIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgIHZhciBub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCBhLCBiLCBjLCBiYWNrZmFjZUN1bGxpbmcsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuICAgICAgICAgICAgLy8gZnJvbSBodHRwOi8vd3d3Lmdlb21ldHJpY3Rvb2xzLmNvbS9MaWJNYXRoZW1hdGljcy9JbnRlcnNlY3Rpb24vV201SW50clJheTNUcmlhbmdsZTMuY3BwXHJcblxyXG4gICAgICAgICAgICBlZGdlMS5zdWJWZWN0b3JzKCBiLCBhICk7XHJcbiAgICAgICAgICAgIGVkZ2UyLnN1YlZlY3RvcnMoIGMsIGEgKTtcclxuICAgICAgICAgICAgbm9ybWFsLmNyb3NzVmVjdG9ycyggZWRnZTEsIGVkZ2UyICk7XHJcblxyXG4gICAgICAgICAgICAvLyBTb2x2ZSBRICsgdCpEID0gYjEqRTEgKyBiMipFMiAoUSA9IGtEaWZmLCBEID0gcmF5IGRpcmVjdGlvbixcclxuICAgICAgICAgICAgLy8gRTEgPSBrRWRnZTEsIEUyID0ga0VkZ2UyLCBOID0gQ3Jvc3MoRTEsRTIpKSBieVxyXG4gICAgICAgICAgICAvLyAgIHxEb3QoRCxOKXwqYjEgPSBzaWduKERvdChELE4pKSpEb3QoRCxDcm9zcyhRLEUyKSlcclxuICAgICAgICAgICAgLy8gICB8RG90KEQsTil8KmIyID0gc2lnbihEb3QoRCxOKSkqRG90KEQsQ3Jvc3MoRTEsUSkpXHJcbiAgICAgICAgICAgIC8vICAgfERvdChELE4pfCp0ID0gLXNpZ24oRG90KEQsTikpKkRvdChRLE4pXHJcbiAgICAgICAgICAgIHZhciBEZE4gPSB0aGlzLmRpcmVjdGlvbi5kb3QoIG5vcm1hbCApO1xyXG4gICAgICAgICAgICB2YXIgc2lnbjtcclxuXHJcbiAgICAgICAgICAgIGlmICggRGROID4gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGJhY2tmYWNlQ3VsbGluZyApIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgc2lnbiA9IDE7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBEZE4gPCAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHNpZ24gPSAtIDE7XHJcbiAgICAgICAgICAgICAgICBEZE4gPSAtIERkTjtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBkaWZmLnN1YlZlY3RvcnMoIHRoaXMub3JpZ2luLCBhICk7XHJcbiAgICAgICAgICAgIHZhciBEZFF4RTIgPSBzaWduICogdGhpcy5kaXJlY3Rpb24uZG90KCBlZGdlMi5jcm9zc1ZlY3RvcnMoIGRpZmYsIGVkZ2UyICkgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGIxIDwgMCwgbm8gaW50ZXJzZWN0aW9uXHJcbiAgICAgICAgICAgIGlmICggRGRReEUyIDwgMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBEZEUxeFEgPSBzaWduICogdGhpcy5kaXJlY3Rpb24uZG90KCBlZGdlMS5jcm9zcyggZGlmZiApICk7XHJcblxyXG4gICAgICAgICAgICAvLyBiMiA8IDAsIG5vIGludGVyc2VjdGlvblxyXG4gICAgICAgICAgICBpZiAoIERkRTF4USA8IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBiMStiMiA+IDEsIG5vIGludGVyc2VjdGlvblxyXG4gICAgICAgICAgICBpZiAoIERkUXhFMiArIERkRTF4USA+IERkTiApIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIExpbmUgaW50ZXJzZWN0cyB0cmlhbmdsZSwgY2hlY2sgaWYgcmF5IGRvZXMuXHJcbiAgICAgICAgICAgIHZhciBRZE4gPSAtIHNpZ24gKiBkaWZmLmRvdCggbm9ybWFsICk7XHJcblxyXG4gICAgICAgICAgICAvLyB0IDwgMCwgbm8gaW50ZXJzZWN0aW9uXHJcbiAgICAgICAgICAgIGlmICggUWROIDwgMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFJheSBpbnRlcnNlY3RzIHRyaWFuZ2xlLlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdCggUWROIC8gRGROLCBvcHRpb25hbFRhcmdldCApO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICggbWF0cml4NCApIHtcclxuXHJcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24uYWRkKCB0aGlzLm9yaWdpbiApLmFwcGx5TWF0cml4NCggbWF0cml4NCApO1xyXG4gICAgICAgIHRoaXMub3JpZ2luLmFwcGx5TWF0cml4NCggbWF0cml4NCApO1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aW9uLnN1YiggdGhpcy5vcmlnaW4gKTtcclxuICAgICAgICB0aGlzLmRpcmVjdGlvbi5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBlcXVhbHM6IGZ1bmN0aW9uICggcmF5ICkge1xyXG5cclxuICAgICAgICByZXR1cm4gcmF5Lm9yaWdpbi5lcXVhbHMoIHRoaXMub3JpZ2luICkgJiYgcmF5LmRpcmVjdGlvbi5lcXVhbHMoIHRoaXMuZGlyZWN0aW9uICk7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGgvU3BoZXJlLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlNwaGVyZSA9IGZ1bmN0aW9uICggY2VudGVyLCByYWRpdXMgKSB7XHJcblxyXG4gICAgdGhpcy5jZW50ZXIgPSAoIGNlbnRlciAhPT0gdW5kZWZpbmVkICkgPyBjZW50ZXIgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgdGhpcy5yYWRpdXMgPSAoIHJhZGl1cyAhPT0gdW5kZWZpbmVkICkgPyByYWRpdXMgOiAwO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNwaGVyZS5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLlNwaGVyZSxcclxuXHJcbiAgICBzZXQ6IGZ1bmN0aW9uICggY2VudGVyLCByYWRpdXMgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY2VudGVyLmNvcHkoIGNlbnRlciApO1xyXG4gICAgICAgIHRoaXMucmFkaXVzID0gcmFkaXVzO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIGJveCA9IG5ldyBUSFJFRS5Cb3gzKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIHBvaW50cywgb3B0aW9uYWxDZW50ZXIgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5jZW50ZXI7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG9wdGlvbmFsQ2VudGVyICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY2VudGVyLmNvcHkoIG9wdGlvbmFsQ2VudGVyICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIGJveC5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKS5jZW50ZXIoIGNlbnRlciApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIG1heFJhZGl1c1NxID0gMDtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgbWF4UmFkaXVzU3EgPSBNYXRoLm1heCggbWF4UmFkaXVzU3EsIGNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnRzWyBpIF0gKSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5yYWRpdXMgPSBNYXRoLnNxcnQoIG1heFJhZGl1c1NxICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29weTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY2VudGVyLmNvcHkoIHNwaGVyZS5jZW50ZXIgKTtcclxuICAgICAgICB0aGlzLnJhZGl1cyA9IHNwaGVyZS5yYWRpdXM7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZW1wdHk6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuICggdGhpcy5yYWRpdXMgPD0gMCApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuICggcG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQoIHRoaXMuY2VudGVyICkgPD0gKCB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzICkgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuICggcG9pbnQuZGlzdGFuY2VUbyggdGhpcy5jZW50ZXIgKSAtIHRoaXMucmFkaXVzICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcclxuXHJcbiAgICAgICAgdmFyIHJhZGl1c1N1bSA9IHRoaXMucmFkaXVzICsgc3BoZXJlLnJhZGl1cztcclxuXHJcbiAgICAgICAgcmV0dXJuIHNwaGVyZS5jZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHRoaXMuY2VudGVyICkgPD0gKCByYWRpdXNTdW0gKiByYWRpdXNTdW0gKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNsYW1wUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuICAgICAgICB2YXIgZGVsdGFMZW5ndGhTcSA9IHRoaXMuY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICByZXN1bHQuY29weSggcG9pbnQgKTtcclxuXHJcbiAgICAgICAgaWYgKCBkZWx0YUxlbmd0aFNxID4gKCB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzICkgKSB7XHJcblxyXG4gICAgICAgICAgICByZXN1bHQuc3ViKCB0aGlzLmNlbnRlciApLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICByZXN1bHQubXVsdGlwbHlTY2FsYXIoIHRoaXMucmFkaXVzICkuYWRkKCB0aGlzLmNlbnRlciApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRCb3VuZGluZ0JveDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcbiAgICAgICAgdmFyIGJveCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5Cb3gzKCk7XHJcblxyXG4gICAgICAgIGJveC5zZXQoIHRoaXMuY2VudGVyLCB0aGlzLmNlbnRlciApO1xyXG4gICAgICAgIGJveC5leHBhbmRCeVNjYWxhciggdGhpcy5yYWRpdXMgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGJveDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY2VudGVyLmFwcGx5TWF0cml4NCggbWF0cml4ICk7XHJcbiAgICAgICAgdGhpcy5yYWRpdXMgPSB0aGlzLnJhZGl1cyAqIG1hdHJpeC5nZXRNYXhTY2FsZU9uQXhpcygpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBvZmZzZXQgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY2VudGVyLmFkZCggb2Zmc2V0ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZXF1YWxzOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHNwaGVyZS5jZW50ZXIuZXF1YWxzKCB0aGlzLmNlbnRlciApICYmICggc3BoZXJlLnJhZGl1cyA9PT0gdGhpcy5yYWRpdXMgKTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9GcnVzdHVtLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG4gKi9cclxuXHJcblRIUkVFLkZydXN0dW0gPSBmdW5jdGlvbiAoIHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUgKSB7XHJcblxyXG4gICAgdGhpcy5wbGFuZXMgPSBbXHJcblxyXG4gICAgICAgICggcDAgIT09IHVuZGVmaW5lZCApID8gcDAgOiBuZXcgVEhSRUUuUGxhbmUoKSxcclxuICAgICAgICAoIHAxICE9PSB1bmRlZmluZWQgKSA/IHAxIDogbmV3IFRIUkVFLlBsYW5lKCksXHJcbiAgICAgICAgKCBwMiAhPT0gdW5kZWZpbmVkICkgPyBwMiA6IG5ldyBUSFJFRS5QbGFuZSgpLFxyXG4gICAgICAgICggcDMgIT09IHVuZGVmaW5lZCApID8gcDMgOiBuZXcgVEhSRUUuUGxhbmUoKSxcclxuICAgICAgICAoIHA0ICE9PSB1bmRlZmluZWQgKSA/IHA0IDogbmV3IFRIUkVFLlBsYW5lKCksXHJcbiAgICAgICAgKCBwNSAhPT0gdW5kZWZpbmVkICkgPyBwNSA6IG5ldyBUSFJFRS5QbGFuZSgpXHJcblxyXG4gICAgXTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5GcnVzdHVtLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuRnJ1c3R1bSxcclxuXHJcbiAgICBzZXQ6IGZ1bmN0aW9uICggcDAsIHAxLCBwMiwgcDMsIHA0LCBwNSApIHtcclxuXHJcbiAgICAgICAgdmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xyXG5cclxuICAgICAgICBwbGFuZXNbIDAgXS5jb3B5KCBwMCApO1xyXG4gICAgICAgIHBsYW5lc1sgMSBdLmNvcHkoIHAxICk7XHJcbiAgICAgICAgcGxhbmVzWyAyIF0uY29weSggcDIgKTtcclxuICAgICAgICBwbGFuZXNbIDMgXS5jb3B5KCBwMyApO1xyXG4gICAgICAgIHBsYW5lc1sgNCBdLmNvcHkoIHA0ICk7XHJcbiAgICAgICAgcGxhbmVzWyA1IF0uY29weSggcDUgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb3B5OiBmdW5jdGlvbiAoIGZydXN0dW0gKSB7XHJcblxyXG4gICAgICAgIHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHBsYW5lc1sgaSBdLmNvcHkoIGZydXN0dW0ucGxhbmVzWyBpIF0gKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZyb21NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcbiAgICAgICAgdmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xyXG4gICAgICAgIHZhciBtZSA9IG0uZWxlbWVudHM7XHJcbiAgICAgICAgdmFyIG1lMCA9IG1lWyAwIF0sIG1lMSA9IG1lWyAxIF0sIG1lMiA9IG1lWyAyIF0sIG1lMyA9IG1lWyAzIF07XHJcbiAgICAgICAgdmFyIG1lNCA9IG1lWyA0IF0sIG1lNSA9IG1lWyA1IF0sIG1lNiA9IG1lWyA2IF0sIG1lNyA9IG1lWyA3IF07XHJcbiAgICAgICAgdmFyIG1lOCA9IG1lWyA4IF0sIG1lOSA9IG1lWyA5IF0sIG1lMTAgPSBtZVsgMTAgXSwgbWUxMSA9IG1lWyAxMSBdO1xyXG4gICAgICAgIHZhciBtZTEyID0gbWVbIDEyIF0sIG1lMTMgPSBtZVsgMTMgXSwgbWUxNCA9IG1lWyAxNCBdLCBtZTE1ID0gbWVbIDE1IF07XHJcblxyXG4gICAgICAgIHBsYW5lc1sgMCBdLnNldENvbXBvbmVudHMoIG1lMyAtIG1lMCwgbWU3IC0gbWU0LCBtZTExIC0gbWU4LCBtZTE1IC0gbWUxMiApLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIHBsYW5lc1sgMSBdLnNldENvbXBvbmVudHMoIG1lMyArIG1lMCwgbWU3ICsgbWU0LCBtZTExICsgbWU4LCBtZTE1ICsgbWUxMiApLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIHBsYW5lc1sgMiBdLnNldENvbXBvbmVudHMoIG1lMyArIG1lMSwgbWU3ICsgbWU1LCBtZTExICsgbWU5LCBtZTE1ICsgbWUxMyApLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIHBsYW5lc1sgMyBdLnNldENvbXBvbmVudHMoIG1lMyAtIG1lMSwgbWU3IC0gbWU1LCBtZTExIC0gbWU5LCBtZTE1IC0gbWUxMyApLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIHBsYW5lc1sgNCBdLnNldENvbXBvbmVudHMoIG1lMyAtIG1lMiwgbWU3IC0gbWU2LCBtZTExIC0gbWUxMCwgbWUxNSAtIG1lMTQgKS5ub3JtYWxpemUoKTtcclxuICAgICAgICBwbGFuZXNbIDUgXS5zZXRDb21wb25lbnRzKCBtZTMgKyBtZTIsIG1lNyArIG1lNiwgbWUxMSArIG1lMTAsIG1lMTUgKyBtZTE0ICkubm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgaW50ZXJzZWN0c09iamVjdDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgc3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG4gICAgICAgICAgICBzcGhlcmUuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKTtcclxuICAgICAgICAgICAgc3BoZXJlLmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgaW50ZXJzZWN0c1NwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XHJcblxyXG4gICAgICAgIHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcclxuICAgICAgICB2YXIgY2VudGVyID0gc3BoZXJlLmNlbnRlcjtcclxuICAgICAgICB2YXIgbmVnUmFkaXVzID0gLSBzcGhlcmUucmFkaXVzO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gcGxhbmVzWyBpIF0uZGlzdGFuY2VUb1BvaW50KCBjZW50ZXIgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggZGlzdGFuY2UgPCBuZWdSYWRpdXMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgaW50ZXJzZWN0c0JveDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgcDEgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG4gICAgICAgICAgICBwMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDYgOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBwbGFuZSA9IHBsYW5lc1sgaSBdO1xyXG5cclxuICAgICAgICAgICAgICAgIHAxLnggPSBwbGFuZS5ub3JtYWwueCA+IDAgPyBib3gubWluLnggOiBib3gubWF4Lng7XHJcbiAgICAgICAgICAgICAgICBwMi54ID0gcGxhbmUubm9ybWFsLnggPiAwID8gYm94Lm1heC54IDogYm94Lm1pbi54O1xyXG4gICAgICAgICAgICAgICAgcDEueSA9IHBsYW5lLm5vcm1hbC55ID4gMCA/IGJveC5taW4ueSA6IGJveC5tYXgueTtcclxuICAgICAgICAgICAgICAgIHAyLnkgPSBwbGFuZS5ub3JtYWwueSA+IDAgPyBib3gubWF4LnkgOiBib3gubWluLnk7XHJcbiAgICAgICAgICAgICAgICBwMS56ID0gcGxhbmUubm9ybWFsLnogPiAwID8gYm94Lm1pbi56IDogYm94Lm1heC56O1xyXG4gICAgICAgICAgICAgICAgcDIueiA9IHBsYW5lLm5vcm1hbC56ID4gMCA/IGJveC5tYXgueiA6IGJveC5taW4uejtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZDEgPSBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHAxICk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZDIgPSBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHAyICk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaWYgYm90aCBvdXRzaWRlIHBsYW5lLCBubyBpbnRlcnNlY3Rpb25cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGQxIDwgMCAmJiBkMiA8IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG5cclxuICAgIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG4gICAgICAgIHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggcGxhbmVzWyBpIF0uZGlzdGFuY2VUb1BvaW50KCBwb2ludCApIDwgMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGgvUGxhbmUuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXHJcbiAqL1xyXG5cclxuVEhSRUUuUGxhbmUgPSBmdW5jdGlvbiAoIG5vcm1hbCwgY29uc3RhbnQgKSB7XHJcblxyXG4gICAgdGhpcy5ub3JtYWwgPSAoIG5vcm1hbCAhPT0gdW5kZWZpbmVkICkgPyBub3JtYWwgOiBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMCwgMCApO1xyXG4gICAgdGhpcy5jb25zdGFudCA9ICggY29uc3RhbnQgIT09IHVuZGVmaW5lZCApID8gY29uc3RhbnQgOiAwO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBsYW5lLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuUGxhbmUsXHJcblxyXG4gICAgc2V0OiBmdW5jdGlvbiAoIG5vcm1hbCwgY29uc3RhbnQgKSB7XHJcblxyXG4gICAgICAgIHRoaXMubm9ybWFsLmNvcHkoIG5vcm1hbCApO1xyXG4gICAgICAgIHRoaXMuY29uc3RhbnQgPSBjb25zdGFudDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRDb21wb25lbnRzOiBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XHJcblxyXG4gICAgICAgIHRoaXMubm9ybWFsLnNldCggeCwgeSwgeiApO1xyXG4gICAgICAgIHRoaXMuY29uc3RhbnQgPSB3O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50OiBmdW5jdGlvbiAoIG5vcm1hbCwgcG9pbnQgKSB7XHJcblxyXG4gICAgICAgIHRoaXMubm9ybWFsLmNvcHkoIG5vcm1hbCApO1xyXG4gICAgICAgIHRoaXMuY29uc3RhbnQgPSAtIHBvaW50LmRvdCggdGhpcy5ub3JtYWwgKTtcdC8vIG11c3QgYmUgdGhpcy5ub3JtYWwsIG5vdCBub3JtYWwsIGFzIHRoaXMubm9ybWFsIGlzIG5vcm1hbGl6ZWRcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRGcm9tQ29wbGFuYXJQb2ludHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICB2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCBhLCBiLCBjICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIG5vcm1hbCA9IHYxLnN1YlZlY3RvcnMoIGMsIGIgKS5jcm9zcyggdjIuc3ViVmVjdG9ycyggYSwgYiApICkubm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBROiBzaG91bGQgYW4gZXJyb3IgYmUgdGhyb3duIGlmIG5vcm1hbCBpcyB6ZXJvIChlLmcuIGRlZ2VuZXJhdGUgcGxhbmUpP1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludCggbm9ybWFsLCBhICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29weTogZnVuY3Rpb24gKCBwbGFuZSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5ub3JtYWwuY29weSggcGxhbmUubm9ybWFsICk7XHJcbiAgICAgICAgdGhpcy5jb25zdGFudCA9IHBsYW5lLmNvbnN0YW50O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAvLyBOb3RlOiB3aWxsIGxlYWQgdG8gYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgcGxhbmUgaXMgaW52YWxpZC5cclxuXHJcbiAgICAgICAgdmFyIGludmVyc2VOb3JtYWxMZW5ndGggPSAxLjAgLyB0aGlzLm5vcm1hbC5sZW5ndGgoKTtcclxuICAgICAgICB0aGlzLm5vcm1hbC5tdWx0aXBseVNjYWxhciggaW52ZXJzZU5vcm1hbExlbmd0aCApO1xyXG4gICAgICAgIHRoaXMuY29uc3RhbnQgKj0gaW52ZXJzZU5vcm1hbExlbmd0aDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBuZWdhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdGhpcy5jb25zdGFudCAqPSAtIDE7XHJcbiAgICAgICAgdGhpcy5ub3JtYWwubmVnYXRlKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWwuZG90KCBwb2ludCApICsgdGhpcy5jb25zdGFudDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRpc3RhbmNlVG9TcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIHNwaGVyZS5jZW50ZXIgKSAtIHNwaGVyZS5yYWRpdXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBwcm9qZWN0UG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5vcnRob1BvaW50KCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKS5zdWIoIHBvaW50ICkubmVnYXRlKCk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBvcnRob1BvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcbiAgICAgICAgdmFyIHBlcnBlbmRpY3VsYXJNYWduaXR1ZGUgPSB0aGlzLmRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKTtcclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLm5vcm1hbCApLm11bHRpcGx5U2NhbGFyKCBwZXJwZW5kaWN1bGFyTWFnbml0dWRlICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBpc0ludGVyc2VjdGlvbkxpbmU6IGZ1bmN0aW9uICggbGluZSApIHtcclxuXHJcbiAgICAgICAgLy8gTm90ZTogdGhpcyB0ZXN0cyBpZiBhIGxpbmUgaW50ZXJzZWN0cyB0aGUgcGxhbmUsIG5vdCB3aGV0aGVyIGl0IChvciBpdHMgZW5kLXBvaW50cykgYXJlIGNvcGxhbmFyIHdpdGggaXQuXHJcblxyXG4gICAgICAgIHZhciBzdGFydFNpZ24gPSB0aGlzLmRpc3RhbmNlVG9Qb2ludCggbGluZS5zdGFydCApO1xyXG4gICAgICAgIHZhciBlbmRTaWduID0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIGxpbmUuZW5kICk7XHJcblxyXG4gICAgICAgIHJldHVybiAoIHN0YXJ0U2lnbiA8IDAgJiYgZW5kU2lnbiA+IDAgKSB8fCAoIGVuZFNpZ24gPCAwICYmIHN0YXJ0U2lnbiA+IDAgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggbGluZSwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBsaW5lLmRlbHRhKCB2MSApO1xyXG5cclxuICAgICAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gdGhpcy5ub3JtYWwuZG90KCBkaXJlY3Rpb24gKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggZGVub21pbmF0b3IgPT09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbGluZSBpcyBjb3BsYW5hciwgcmV0dXJuIG9yaWdpblxyXG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzLmRpc3RhbmNlVG9Qb2ludCggbGluZS5zdGFydCApID09PSAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LmNvcHkoIGxpbmUuc3RhcnQgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVW5zdXJlIGlmIHRoaXMgaXMgdGhlIGNvcnJlY3QgbWV0aG9kIHRvIGhhbmRsZSB0aGlzIGNhc2UuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHQgPSAtICggbGluZS5zdGFydC5kb3QoIHRoaXMubm9ybWFsICkgKyB0aGlzLmNvbnN0YW50ICkgLyBkZW5vbWluYXRvcjtcclxuXHJcbiAgICAgICAgICAgIGlmICggdCA8IDAgfHwgdCA+IDEgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuY29weSggZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIGxpbmUuc3RhcnQgKTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG5cclxuICAgIGNvcGxhbmFyUG9pbnQ6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQuY29weSggdGhpcy5ub3JtYWwgKS5tdWx0aXBseVNjYWxhciggLSB0aGlzLmNvbnN0YW50ICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICB2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgIHZhciBtMSA9IG5ldyBUSFJFRS5NYXRyaXgzKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIG1hdHJpeCwgb3B0aW9uYWxOb3JtYWxNYXRyaXggKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBjb21wdXRlIG5ldyBub3JtYWwgYmFzZWQgb24gdGhlb3J5IGhlcmU6XHJcbiAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cuc29uZ2hvLmNhL29wZW5nbC9nbF9ub3JtYWx0cmFuc2Zvcm0uaHRtbFxyXG4gICAgICAgICAgICB2YXIgbm9ybWFsTWF0cml4ID0gb3B0aW9uYWxOb3JtYWxNYXRyaXggfHwgbTEuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcclxuICAgICAgICAgICAgdmFyIG5ld05vcm1hbCA9IHYxLmNvcHkoIHRoaXMubm9ybWFsICkuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBuZXdDb3BsYW5hclBvaW50ID0gdGhpcy5jb3BsYW5hclBvaW50KCB2MiApO1xyXG4gICAgICAgICAgICBuZXdDb3BsYW5hclBvaW50LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KCBuZXdOb3JtYWwsIG5ld0NvcGxhbmFyUG9pbnQgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uICggb2Zmc2V0ICkge1xyXG5cclxuICAgICAgICB0aGlzLmNvbnN0YW50ID0gdGhpcy5jb25zdGFudCAtIG9mZnNldC5kb3QoIHRoaXMubm9ybWFsICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZXF1YWxzOiBmdW5jdGlvbiAoIHBsYW5lICkge1xyXG5cclxuICAgICAgICByZXR1cm4gcGxhbmUubm9ybWFsLmVxdWFscyggdGhpcy5ub3JtYWwgKSAmJiAoIHBsYW5lLmNvbnN0YW50ID09PSB0aGlzLmNvbnN0YW50ICk7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGgvTWF0aC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTWF0aCA9IHtcclxuXHJcbiAgICBnZW5lcmF0ZVVVSUQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgLy8gaHR0cDovL3d3dy5icm9vZmEuY29tL1Rvb2xzL01hdGgudXVpZC5odG1cclxuXHJcbiAgICAgICAgdmFyIGNoYXJzID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6Jy5zcGxpdCggJycgKTtcclxuICAgICAgICB2YXIgdXVpZCA9IG5ldyBBcnJheSggMzYgKTtcclxuICAgICAgICB2YXIgcm5kID0gMCwgcjtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDM2OyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggaSA9PT0gOCB8fCBpID09PSAxMyB8fCBpID09PSAxOCB8fCBpID09PSAyMyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdXVpZFsgaSBdID0gJy0nO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGkgPT09IDE0ICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB1dWlkWyBpIF0gPSAnNCc7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBybmQgPD0gMHgwMiApIHJuZCA9IDB4MjAwMDAwMCArICggTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMCApIHwgMDtcclxuICAgICAgICAgICAgICAgICAgICByID0gcm5kICYgMHhmO1xyXG4gICAgICAgICAgICAgICAgICAgIHJuZCA9IHJuZCA+PiA0O1xyXG4gICAgICAgICAgICAgICAgICAgIHV1aWRbIGkgXSA9IGNoYXJzWyAoIGkgPT09IDE5ICkgPyAoIHIgJiAweDMgKSB8IDB4OCA6IHIgXTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdXVpZC5qb2luKCAnJyApO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBjbGFtcDogZnVuY3Rpb24gKCB2YWx1ZSwgbWluLCBtYXggKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCB2YWx1ZSApICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBjb21wdXRlIGV1Y2xpZGlhbiBtb2R1bG8gb2YgbSAlIG5cclxuICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vZHVsb19vcGVyYXRpb25cclxuXHJcbiAgICBldWNsaWRlYW5Nb2R1bG86IGZ1bmN0aW9uICggbiwgbSApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuICggKCBuICUgbSApICsgbSApICUgbTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIExpbmVhciBtYXBwaW5nIGZyb20gcmFuZ2UgPGExLCBhMj4gdG8gcmFuZ2UgPGIxLCBiMj5cclxuXHJcbiAgICBtYXBMaW5lYXI6IGZ1bmN0aW9uICggeCwgYTEsIGEyLCBiMSwgYjIgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBiMSArICggeCAtIGExICkgKiAoIGIyIC0gYjEgKSAvICggYTIgLSBhMSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TbW9vdGhzdGVwXHJcblxyXG4gICAgc21vb3Roc3RlcDogZnVuY3Rpb24gKCB4LCBtaW4sIG1heCApIHtcclxuXHJcbiAgICAgICAgaWYgKCB4IDw9IG1pbiApIHJldHVybiAwO1xyXG4gICAgICAgIGlmICggeCA+PSBtYXggKSByZXR1cm4gMTtcclxuXHJcbiAgICAgICAgeCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHggKiB4ICogKCAzIC0gMiAqIHggKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNtb290aGVyc3RlcDogZnVuY3Rpb24gKCB4LCBtaW4sIG1heCApIHtcclxuXHJcbiAgICAgICAgaWYgKCB4IDw9IG1pbiApIHJldHVybiAwO1xyXG4gICAgICAgIGlmICggeCA+PSBtYXggKSByZXR1cm4gMTtcclxuXHJcbiAgICAgICAgeCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHggKiB4ICogeCAqICggeCAqICggeCAqIDYgLSAxNSApICsgMTAgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFJhbmRvbSBmbG9hdCBmcm9tIDwwLCAxPiB3aXRoIDE2IGJpdHMgb2YgcmFuZG9tbmVzc1xyXG4gICAgLy8gKHN0YW5kYXJkIE1hdGgucmFuZG9tKCkgY3JlYXRlcyByZXBldGl0aXZlIHBhdHRlcm5zIHdoZW4gYXBwbGllZCBvdmVyIGxhcmdlciBzcGFjZSlcclxuXHJcbiAgICByYW5kb20xNjogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gKCA2NTI4MCAqIE1hdGgucmFuZG9tKCkgKyAyNTUgKiBNYXRoLnJhbmRvbSgpICkgLyA2NTUzNTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFJhbmRvbSBpbnRlZ2VyIGZyb20gPGxvdywgaGlnaD4gaW50ZXJ2YWxcclxuXHJcbiAgICByYW5kSW50OiBmdW5jdGlvbiAoIGxvdywgaGlnaCApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIGxvdyArIE1hdGguZmxvb3IoIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKyAxICkgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFJhbmRvbSBmbG9hdCBmcm9tIDxsb3csIGhpZ2g+IGludGVydmFsXHJcblxyXG4gICAgcmFuZEZsb2F0OiBmdW5jdGlvbiAoIGxvdywgaGlnaCApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIGxvdyArIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFJhbmRvbSBmbG9hdCBmcm9tIDwtcmFuZ2UvMiwgcmFuZ2UvMj4gaW50ZXJ2YWxcclxuXHJcbiAgICByYW5kRmxvYXRTcHJlYWQ6IGZ1bmN0aW9uICggcmFuZ2UgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiByYW5nZSAqICggMC41IC0gTWF0aC5yYW5kb20oKSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZGVnVG9SYWQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIGRlZ3JlZVRvUmFkaWFuc0ZhY3RvciA9IE1hdGguUEkgLyAxODA7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIGRlZ3JlZXMgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZGVncmVlcyAqIGRlZ3JlZVRvUmFkaWFuc0ZhY3RvcjtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgcmFkVG9EZWc6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHJhZGlhblRvRGVncmVlc0ZhY3RvciA9IDE4MCAvIE1hdGguUEk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIHJhZGlhbnMgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmFkaWFucyAqIHJhZGlhblRvRGVncmVlc0ZhY3RvcjtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgaXNQb3dlck9mVHdvOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuICAgICAgICByZXR1cm4gKCB2YWx1ZSAmICggdmFsdWUgLSAxICkgKSA9PT0gMCAmJiB2YWx1ZSAhPT0gMDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG5lYXJlc3RQb3dlck9mVHdvOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuICAgICAgICByZXR1cm4gTWF0aC5wb3coIDIsIE1hdGgucm91bmQoIE1hdGgubG9nKCB2YWx1ZSApIC8gTWF0aC5MTjIgKSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbmV4dFBvd2VyT2ZUd286IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIHZhbHVlIC0tO1xyXG4gICAgICAgIHZhbHVlIHw9IHZhbHVlID4+IDE7XHJcbiAgICAgICAgdmFsdWUgfD0gdmFsdWUgPj4gMjtcclxuICAgICAgICB2YWx1ZSB8PSB2YWx1ZSA+PiA0O1xyXG4gICAgICAgIHZhbHVlIHw9IHZhbHVlID4+IDg7XHJcbiAgICAgICAgdmFsdWUgfD0gdmFsdWUgPj4gMTY7XHJcbiAgICAgICAgdmFsdWUgKys7XHJcblxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9TcGxpbmUuanNcclxuXHJcbi8qKlxyXG4gKiBTcGxpbmUgZnJvbSBUd2Vlbi5qcywgc2xpZ2h0bHkgb3B0aW1pemVkIChhbmQgdHJhc2hlZClcclxuICogaHR0cDovL3NvbGUuZ2l0aHViLmNvbS90d2Vlbi5qcy9leGFtcGxlcy8wNV9zcGxpbmUuaHRtbFxyXG4gKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlNwbGluZSA9IGZ1bmN0aW9uICggcG9pbnRzICkge1xyXG5cclxuICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xyXG5cclxuICAgIHZhciBjID0gW10sIHYzID0geyB4OiAwLCB5OiAwLCB6OiAwIH0sXHJcbiAgICAgICAgcG9pbnQsIGludFBvaW50LCB3ZWlnaHQsIHcyLCB3MyxcclxuICAgICAgICBwYSwgcGIsIHBjLCBwZDtcclxuXHJcbiAgICB0aGlzLmluaXRGcm9tQXJyYXkgPSBmdW5jdGlvbiAoIGEgKSB7XHJcblxyXG4gICAgICAgIHRoaXMucG9pbnRzID0gW107XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5wb2ludHNbIGkgXSA9IHsgeDogYVsgaSBdWyAwIF0sIHk6IGFbIGkgXVsgMSBdLCB6OiBhWyBpIF1bIDIgXSB9O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmdldFBvaW50ID0gZnVuY3Rpb24gKCBrICkge1xyXG5cclxuICAgICAgICBwb2ludCA9ICggdGhpcy5wb2ludHMubGVuZ3RoIC0gMSApICogaztcclxuICAgICAgICBpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XHJcbiAgICAgICAgd2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcclxuXHJcbiAgICAgICAgY1sgMCBdID0gaW50UG9pbnQgPT09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMTtcclxuICAgICAgICBjWyAxIF0gPSBpbnRQb2ludDtcclxuICAgICAgICBjWyAyIF0gPSBpbnRQb2ludCAgPiB0aGlzLnBvaW50cy5sZW5ndGggLSAyID8gdGhpcy5wb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMTtcclxuICAgICAgICBjWyAzIF0gPSBpbnRQb2ludCAgPiB0aGlzLnBvaW50cy5sZW5ndGggLSAzID8gdGhpcy5wb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMjtcclxuXHJcbiAgICAgICAgcGEgPSB0aGlzLnBvaW50c1sgY1sgMCBdIF07XHJcbiAgICAgICAgcGIgPSB0aGlzLnBvaW50c1sgY1sgMSBdIF07XHJcbiAgICAgICAgcGMgPSB0aGlzLnBvaW50c1sgY1sgMiBdIF07XHJcbiAgICAgICAgcGQgPSB0aGlzLnBvaW50c1sgY1sgMyBdIF07XHJcblxyXG4gICAgICAgIHcyID0gd2VpZ2h0ICogd2VpZ2h0O1xyXG4gICAgICAgIHczID0gd2VpZ2h0ICogdzI7XHJcblxyXG4gICAgICAgIHYzLnggPSBpbnRlcnBvbGF0ZSggcGEueCwgcGIueCwgcGMueCwgcGQueCwgd2VpZ2h0LCB3MiwgdzMgKTtcclxuICAgICAgICB2My55ID0gaW50ZXJwb2xhdGUoIHBhLnksIHBiLnksIHBjLnksIHBkLnksIHdlaWdodCwgdzIsIHczICk7XHJcbiAgICAgICAgdjMueiA9IGludGVycG9sYXRlKCBwYS56LCBwYi56LCBwYy56LCBwZC56LCB3ZWlnaHQsIHcyLCB3MyApO1xyXG5cclxuICAgICAgICByZXR1cm4gdjM7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmdldENvbnRyb2xQb2ludHNBcnJheSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIGksIHAsIGwgPSB0aGlzLnBvaW50cy5sZW5ndGgsXHJcbiAgICAgICAgICAgIGNvb3JkcyA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICBwID0gdGhpcy5wb2ludHNbIGkgXTtcclxuICAgICAgICAgICAgY29vcmRzWyBpIF0gPSBbIHAueCwgcC55LCBwLnogXTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY29vcmRzO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLy8gYXBwcm94aW1hdGUgbGVuZ3RoIGJ5IHN1bW1pbmcgbGluZWFyIHNlZ21lbnRzXHJcblxyXG4gICAgdGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbiAoIG5TdWJEaXZpc2lvbnMgKSB7XHJcblxyXG4gICAgICAgIHZhciBpLCBpbmRleCwgblNhbXBsZXMsIHBvc2l0aW9uLFxyXG4gICAgICAgICAgICBwb2ludCA9IDAsIGludFBvaW50ID0gMCwgb2xkSW50UG9pbnQgPSAwLFxyXG4gICAgICAgICAgICBvbGRQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcbiAgICAgICAgICAgIHRtcFZlYyA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcbiAgICAgICAgICAgIGNodW5rTGVuZ3RocyA9IFtdLFxyXG4gICAgICAgICAgICB0b3RhbExlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgIC8vIGZpcnN0IHBvaW50IGhhcyAwIGxlbmd0aFxyXG5cclxuICAgICAgICBjaHVua0xlbmd0aHNbIDAgXSA9IDA7XHJcblxyXG4gICAgICAgIGlmICggISBuU3ViRGl2aXNpb25zICkgblN1YkRpdmlzaW9ucyA9IDEwMDtcclxuXHJcbiAgICAgICAgblNhbXBsZXMgPSB0aGlzLnBvaW50cy5sZW5ndGggKiBuU3ViRGl2aXNpb25zO1xyXG5cclxuICAgICAgICBvbGRQb3NpdGlvbi5jb3B5KCB0aGlzLnBvaW50c1sgMCBdICk7XHJcblxyXG4gICAgICAgIGZvciAoIGkgPSAxOyBpIDwgblNhbXBsZXM7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICBpbmRleCA9IGkgLyBuU2FtcGxlcztcclxuXHJcbiAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5nZXRQb2ludCggaW5kZXggKTtcclxuICAgICAgICAgICAgdG1wVmVjLmNvcHkoIHBvc2l0aW9uICk7XHJcblxyXG4gICAgICAgICAgICB0b3RhbExlbmd0aCArPSB0bXBWZWMuZGlzdGFuY2VUbyggb2xkUG9zaXRpb24gKTtcclxuXHJcbiAgICAgICAgICAgIG9sZFBvc2l0aW9uLmNvcHkoIHBvc2l0aW9uICk7XHJcblxyXG4gICAgICAgICAgICBwb2ludCA9ICggdGhpcy5wb2ludHMubGVuZ3RoIC0gMSApICogaW5kZXg7XHJcbiAgICAgICAgICAgIGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggaW50UG9pbnQgIT09IG9sZEludFBvaW50ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNodW5rTGVuZ3Roc1sgaW50UG9pbnQgXSA9IHRvdGFsTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgb2xkSW50UG9pbnQgPSBpbnRQb2ludDtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBsYXN0IHBvaW50IGVuZHMgd2l0aCB0b3RhbCBsZW5ndGhcclxuXHJcbiAgICAgICAgY2h1bmtMZW5ndGhzWyBjaHVua0xlbmd0aHMubGVuZ3RoIF0gPSB0b3RhbExlbmd0aDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHsgY2h1bmtzOiBjaHVua0xlbmd0aHMsIHRvdGFsOiB0b3RhbExlbmd0aCB9O1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5yZXBhcmFtZXRyaXplQnlBcmNMZW5ndGggPSBmdW5jdGlvbiAoIHNhbXBsaW5nQ29lZiApIHtcclxuXHJcbiAgICAgICAgdmFyIGksIGosXHJcbiAgICAgICAgICAgIGluZGV4LCBpbmRleEN1cnJlbnQsIGluZGV4TmV4dCxcclxuICAgICAgICAgICAgcmVhbERpc3RhbmNlLFxyXG4gICAgICAgICAgICBzYW1wbGluZywgcG9zaXRpb24sXHJcbiAgICAgICAgICAgIG5ld3BvaW50cyA9IFtdLFxyXG4gICAgICAgICAgICB0bXBWZWMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG4gICAgICAgICAgICBzbCA9IHRoaXMuZ2V0TGVuZ3RoKCk7XHJcblxyXG4gICAgICAgIG5ld3BvaW50cy5wdXNoKCB0bXBWZWMuY29weSggdGhpcy5wb2ludHNbIDAgXSApLmNsb25lKCkgKTtcclxuXHJcbiAgICAgICAgZm9yICggaSA9IDE7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAvL3RtcFZlYy5jb3B5KCB0aGlzLnBvaW50c1sgaSAtIDEgXSApO1xyXG4gICAgICAgICAgICAvL2xpbmVhckRpc3RhbmNlID0gdG1wVmVjLmRpc3RhbmNlVG8oIHRoaXMucG9pbnRzWyBpIF0gKTtcclxuXHJcbiAgICAgICAgICAgIHJlYWxEaXN0YW5jZSA9IHNsLmNodW5rc1sgaSBdIC0gc2wuY2h1bmtzWyBpIC0gMSBdO1xyXG5cclxuICAgICAgICAgICAgc2FtcGxpbmcgPSBNYXRoLmNlaWwoIHNhbXBsaW5nQ29lZiAqIHJlYWxEaXN0YW5jZSAvIHNsLnRvdGFsICk7XHJcblxyXG4gICAgICAgICAgICBpbmRleEN1cnJlbnQgPSAoIGkgLSAxICkgLyAoIHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgKTtcclxuICAgICAgICAgICAgaW5kZXhOZXh0ID0gaSAvICggdGhpcy5wb2ludHMubGVuZ3RoIC0gMSApO1xyXG5cclxuICAgICAgICAgICAgZm9yICggaiA9IDE7IGogPCBzYW1wbGluZyAtIDE7IGogKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaW5kZXggPSBpbmRleEN1cnJlbnQgKyBqICogKCAxIC8gc2FtcGxpbmcgKSAqICggaW5kZXhOZXh0IC0gaW5kZXhDdXJyZW50ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLmdldFBvaW50KCBpbmRleCApO1xyXG4gICAgICAgICAgICAgICAgbmV3cG9pbnRzLnB1c2goIHRtcFZlYy5jb3B5KCBwb3NpdGlvbiApLmNsb25lKCkgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG5ld3BvaW50cy5wdXNoKCB0bXBWZWMuY29weSggdGhpcy5wb2ludHNbIGkgXSApLmNsb25lKCkgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnBvaW50cyA9IG5ld3BvaW50cztcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIENhdG11bGwtUm9tXHJcblxyXG4gICAgZnVuY3Rpb24gaW50ZXJwb2xhdGUoIHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMgKSB7XHJcblxyXG4gICAgICAgIHZhciB2MCA9ICggcDIgLSBwMCApICogMC41LFxyXG4gICAgICAgICAgICB2MSA9ICggcDMgLSBwMSApICogMC41O1xyXG5cclxuICAgICAgICByZXR1cm4gKCAyICogKCBwMSAtIHAyICkgKyB2MCArIHYxICkgKiB0MyArICggLSAzICogKCBwMSAtIHAyICkgLSAyICogdjAgLSB2MSApICogdDIgKyB2MCAqIHQgKyBwMTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9UcmlhbmdsZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5UcmlhbmdsZSA9IGZ1bmN0aW9uICggYSwgYiwgYyApIHtcclxuXHJcbiAgICB0aGlzLmEgPSAoIGEgIT09IHVuZGVmaW5lZCApID8gYSA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICB0aGlzLmIgPSAoIGIgIT09IHVuZGVmaW5lZCApID8gYiA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICB0aGlzLmMgPSAoIGMgIT09IHVuZGVmaW5lZCApID8gYyA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVHJpYW5nbGUubm9ybWFsID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciB2MCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggYSwgYiwgYywgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICByZXN1bHQuc3ViVmVjdG9ycyggYywgYiApO1xyXG4gICAgICAgIHYwLnN1YlZlY3RvcnMoIGEsIGIgKTtcclxuICAgICAgICByZXN1bHQuY3Jvc3MoIHYwICk7XHJcblxyXG4gICAgICAgIHZhciByZXN1bHRMZW5ndGhTcSA9IHJlc3VsdC5sZW5ndGhTcSgpO1xyXG4gICAgICAgIGlmICggcmVzdWx0TGVuZ3RoU3EgPiAwICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5tdWx0aXBseVNjYWxhciggMSAvIE1hdGguc3FydCggcmVzdWx0TGVuZ3RoU3EgKSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQuc2V0KCAwLCAwLCAwICk7XHJcblxyXG4gICAgfTtcclxuXHJcbn0oKTtcclxuXHJcbi8vIHN0YXRpYy9pbnN0YW5jZSBtZXRob2QgdG8gY2FsY3VsYXRlIGJhcnljZW50cmljIGNvb3JkaW5hdGVzXHJcbi8vIGJhc2VkIG9uOiBodHRwOi8vd3d3LmJsYWNrcGF3bi5jb20vdGV4dHMvcG9pbnRpbnBvbHkvZGVmYXVsdC5odG1sXHJcblRIUkVFLlRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgdjAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgIHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggcG9pbnQsIGEsIGIsIGMsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuICAgICAgICB2MC5zdWJWZWN0b3JzKCBjLCBhICk7XHJcbiAgICAgICAgdjEuc3ViVmVjdG9ycyggYiwgYSApO1xyXG4gICAgICAgIHYyLnN1YlZlY3RvcnMoIHBvaW50LCBhICk7XHJcblxyXG4gICAgICAgIHZhciBkb3QwMCA9IHYwLmRvdCggdjAgKTtcclxuICAgICAgICB2YXIgZG90MDEgPSB2MC5kb3QoIHYxICk7XHJcbiAgICAgICAgdmFyIGRvdDAyID0gdjAuZG90KCB2MiApO1xyXG4gICAgICAgIHZhciBkb3QxMSA9IHYxLmRvdCggdjEgKTtcclxuICAgICAgICB2YXIgZG90MTIgPSB2MS5kb3QoIHYyICk7XHJcblxyXG4gICAgICAgIHZhciBkZW5vbSA9ICggZG90MDAgKiBkb3QxMSAtIGRvdDAxICogZG90MDEgKTtcclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgIC8vIGNvbGxpbmVhciBvciBzaW5ndWxhciB0cmlhbmdsZVxyXG4gICAgICAgIGlmICggZGVub20gPT09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBhcmJpdHJhcnkgbG9jYXRpb24gb3V0c2lkZSBvZiB0cmlhbmdsZT9cclxuICAgICAgICAgICAgLy8gbm90IHN1cmUgaWYgdGhpcyBpcyB0aGUgYmVzdCBpZGVhLCBtYXliZSBzaG91bGQgYmUgcmV0dXJuaW5nIHVuZGVmaW5lZFxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnNldCggLSAyLCAtIDEsIC0gMSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBpbnZEZW5vbSA9IDEgLyBkZW5vbTtcclxuICAgICAgICB2YXIgdSA9ICggZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIgKSAqIGludkRlbm9tO1xyXG4gICAgICAgIHZhciB2ID0gKCBkb3QwMCAqIGRvdDEyIC0gZG90MDEgKiBkb3QwMiApICogaW52RGVub207XHJcblxyXG4gICAgICAgIC8vIGJhcnljZW50cmljIGNvb3JkaW5hdGVzIG11c3QgYWx3YXlzIHN1bSB0byAxXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zZXQoIDEgLSB1IC0gdiwgdiwgdSApO1xyXG5cclxuICAgIH07XHJcblxyXG59KCk7XHJcblxyXG5USFJFRS5UcmlhbmdsZS5jb250YWluc1BvaW50ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggcG9pbnQsIGEsIGIsIGMgKSB7XHJcblxyXG4gICAgICAgIHZhciByZXN1bHQgPSBUSFJFRS5UcmlhbmdsZS5iYXJ5Y29vcmRGcm9tUG9pbnQoIHBvaW50LCBhLCBiLCBjLCB2MSApO1xyXG5cclxuICAgICAgICByZXR1cm4gKCByZXN1bHQueCA+PSAwICkgJiYgKCByZXN1bHQueSA+PSAwICkgJiYgKCAoIHJlc3VsdC54ICsgcmVzdWx0LnkgKSA8PSAxICk7XHJcblxyXG4gICAgfTtcclxuXHJcbn0oKTtcclxuXHJcblRIUkVFLlRyaWFuZ2xlLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuVHJpYW5nbGUsXHJcblxyXG4gICAgc2V0OiBmdW5jdGlvbiAoIGEsIGIsIGMgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuYS5jb3B5KCBhICk7XHJcbiAgICAgICAgdGhpcy5iLmNvcHkoIGIgKTtcclxuICAgICAgICB0aGlzLmMuY29weSggYyApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZyb21Qb2ludHNBbmRJbmRpY2VzOiBmdW5jdGlvbiAoIHBvaW50cywgaTAsIGkxLCBpMiApIHtcclxuXHJcbiAgICAgICAgdGhpcy5hLmNvcHkoIHBvaW50c1sgaTAgXSApO1xyXG4gICAgICAgIHRoaXMuYi5jb3B5KCBwb2ludHNbIGkxIF0gKTtcclxuICAgICAgICB0aGlzLmMuY29weSggcG9pbnRzWyBpMiBdICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29weTogZnVuY3Rpb24gKCB0cmlhbmdsZSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5hLmNvcHkoIHRyaWFuZ2xlLmEgKTtcclxuICAgICAgICB0aGlzLmIuY29weSggdHJpYW5nbGUuYiApO1xyXG4gICAgICAgIHRoaXMuYy5jb3B5KCB0cmlhbmdsZS5jICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYXJlYTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgdjAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICB2MC5zdWJWZWN0b3JzKCB0aGlzLmMsIHRoaXMuYiApO1xyXG4gICAgICAgICAgICB2MS5zdWJWZWN0b3JzKCB0aGlzLmEsIHRoaXMuYiApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHYwLmNyb3NzKCB2MSApLmxlbmd0aCgpICogMC41O1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBtaWRwb2ludDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLmEsIHRoaXMuYiApLmFkZCggdGhpcy5jICkubXVsdGlwbHlTY2FsYXIoIDEgLyAzICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBub3JtYWw6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBUSFJFRS5UcmlhbmdsZS5ub3JtYWwoIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIG9wdGlvbmFsVGFyZ2V0ICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBwbGFuZTogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5QbGFuZSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0LnNldEZyb21Db3BsYW5hclBvaW50cyggdGhpcy5hLCB0aGlzLmIsIHRoaXMuYyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYmFyeWNvb3JkRnJvbVBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIFRIUkVFLlRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCggcG9pbnQsIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIG9wdGlvbmFsVGFyZ2V0ICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb250YWluc1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuICAgICAgICByZXR1cm4gVEhSRUUuVHJpYW5nbGUuY29udGFpbnNQb2ludCggcG9pbnQsIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGVxdWFsczogZnVuY3Rpb24gKCB0cmlhbmdsZSApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRyaWFuZ2xlLmEuZXF1YWxzKCB0aGlzLmEgKSAmJiB0cmlhbmdsZS5iLmVxdWFscyggdGhpcy5iICkgJiYgdHJpYW5nbGUuYy5lcXVhbHMoIHRoaXMuYyApO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9jb3JlL0NoYW5uZWxzLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5DaGFubmVscyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB0aGlzLm1hc2sgPSAxO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkNoYW5uZWxzLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuQ2hhbm5lbHMsXHJcblxyXG4gICAgc2V0OiBmdW5jdGlvbiAoIGNoYW5uZWwgKSB7XHJcblxyXG4gICAgICAgIHRoaXMubWFzayA9IDEgPDwgY2hhbm5lbDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGVuYWJsZTogZnVuY3Rpb24gKCBjaGFubmVsICkge1xyXG5cclxuICAgICAgICB0aGlzLm1hc2sgfD0gMSA8PCBjaGFubmVsO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdG9nZ2xlOiBmdW5jdGlvbiAoIGNoYW5uZWwgKSB7XHJcblxyXG4gICAgICAgIHRoaXMubWFzayBePSAxIDw8IGNoYW5uZWw7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBkaXNhYmxlOiBmdW5jdGlvbiAoIGNoYW5uZWwgKSB7XHJcblxyXG4gICAgICAgIHRoaXMubWFzayAmPSB+ICggMSA8PCBjaGFubmVsICk7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2NvcmUvQ2xvY2suanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkNsb2NrID0gZnVuY3Rpb24gKCBhdXRvU3RhcnQgKSB7XHJcblxyXG4gICAgdGhpcy5hdXRvU3RhcnQgPSAoIGF1dG9TdGFydCAhPT0gdW5kZWZpbmVkICkgPyBhdXRvU3RhcnQgOiB0cnVlO1xyXG5cclxuICAgIHRoaXMuc3RhcnRUaW1lID0gMDtcclxuICAgIHRoaXMub2xkVGltZSA9IDA7XHJcbiAgICB0aGlzLmVsYXBzZWRUaW1lID0gMDtcclxuXHJcbiAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DbG9jay5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkNsb2NrLFxyXG5cclxuICAgIHN0YXJ0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcclxuXHJcbiAgICAgICAgdGhpcy5vbGRUaW1lID0gdGhpcy5zdGFydFRpbWU7XHJcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdGhpcy5nZXRFbGFwc2VkVGltZSgpO1xyXG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0RWxhcHNlZFRpbWU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdGhpcy5nZXREZWx0YSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVsYXBzZWRUaW1lO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0RGVsdGE6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIGRpZmYgPSAwO1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMuYXV0b1N0YXJ0ICYmICEgdGhpcy5ydW5uaW5nICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zdGFydCgpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5ydW5uaW5nICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIG5ld1RpbWUgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xyXG5cclxuICAgICAgICAgICAgZGlmZiA9IDAuMDAxICogKCBuZXdUaW1lIC0gdGhpcy5vbGRUaW1lICk7XHJcbiAgICAgICAgICAgIHRoaXMub2xkVGltZSA9IG5ld1RpbWU7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmVsYXBzZWRUaW1lICs9IGRpZmY7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGRpZmY7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2NvcmUvRXZlbnREaXNwYXRjaGVyLmpzXHJcblxyXG4vKipcclxuICogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi9ldmVudGRpc3BhdGNoZXIuanMvXHJcbiAqL1xyXG5cclxuVEhSRUUuRXZlbnREaXNwYXRjaGVyID0gZnVuY3Rpb24gKCkge307XHJcblxyXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5FdmVudERpc3BhdGNoZXIsXHJcblxyXG4gICAgYXBwbHk6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuICAgICAgICBvYmplY3QuYWRkRXZlbnRMaXN0ZW5lciA9IFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcjtcclxuICAgICAgICBvYmplY3QuaGFzRXZlbnRMaXN0ZW5lciA9IFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuaGFzRXZlbnRMaXN0ZW5lcjtcclxuICAgICAgICBvYmplY3QucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcclxuICAgICAgICBvYmplY3QuZGlzcGF0Y2hFdmVudCA9IFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcclxuXHJcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcclxuXHJcbiAgICAgICAgaWYgKCBsaXN0ZW5lcnNbIHR5cGUgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgbGlzdGVuZXJzWyB0eXBlIF0gPSBbXTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgPT09IC0gMSApIHtcclxuXHJcbiAgICAgICAgICAgIGxpc3RlbmVyc1sgdHlwZSBdLnB1c2goIGxpc3RlbmVyICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGhhc0V2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XHJcblxyXG4gICAgICAgIGlmICggbGlzdGVuZXJzWyB0eXBlIF0gIT09IHVuZGVmaW5lZCAmJiBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApICE9PSAtIDEgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xyXG5cclxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xyXG4gICAgICAgIHZhciBsaXN0ZW5lckFycmF5ID0gbGlzdGVuZXJzWyB0eXBlIF07XHJcblxyXG4gICAgICAgIGlmICggbGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gbGlzdGVuZXJBcnJheS5pbmRleE9mKCBsaXN0ZW5lciApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBpbmRleCAhPT0gLSAxICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyQXJyYXkuc3BsaWNlKCBpbmRleCwgMSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbiAoIGV2ZW50ICkge1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xyXG5cclxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xyXG4gICAgICAgIHZhciBsaXN0ZW5lckFycmF5ID0gbGlzdGVuZXJzWyBldmVudC50eXBlIF07XHJcblxyXG4gICAgICAgIGlmICggbGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgZXZlbnQudGFyZ2V0ID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHZhciBhcnJheSA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJBcnJheS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgYXJyYXlbIGkgXSA9IGxpc3RlbmVyQXJyYXlbIGkgXTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBhcnJheVsgaSBdLmNhbGwoIHRoaXMsIGV2ZW50ICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvY29yZS9SYXljYXN0ZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xyXG4gKiBAYXV0aG9yIHN0ZXBob21pIC8gaHR0cDovL3N0ZXBoYW5lZ2luaWVyLmNvbS9cclxuICovXHJcblxyXG4oIGZ1bmN0aW9uICggVEhSRUUgKSB7XHJcblxyXG4gICAgVEhSRUUuUmF5Y2FzdGVyID0gZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiwgbmVhciwgZmFyICkge1xyXG5cclxuICAgICAgICB0aGlzLnJheSA9IG5ldyBUSFJFRS5SYXkoIG9yaWdpbiwgZGlyZWN0aW9uICk7XHJcbiAgICAgICAgLy8gZGlyZWN0aW9uIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZCAoZm9yIGFjY3VyYXRlIGRpc3RhbmNlIGNhbGN1bGF0aW9ucylcclxuXHJcbiAgICAgICAgdGhpcy5uZWFyID0gbmVhciB8fCAwO1xyXG4gICAgICAgIHRoaXMuZmFyID0gZmFyIHx8IEluZmluaXR5O1xyXG5cclxuICAgICAgICB0aGlzLnBhcmFtcyA9IHtcclxuICAgICAgICAgICAgTWVzaDoge30sXHJcbiAgICAgICAgICAgIExpbmU6IHt9LFxyXG4gICAgICAgICAgICBMT0Q6IHt9LFxyXG4gICAgICAgICAgICBQb2ludHM6IHsgdGhyZXNob2xkOiAxIH0sXHJcbiAgICAgICAgICAgIFNwcml0ZToge31cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcy5wYXJhbXMsIHtcclxuICAgICAgICAgICAgUG9pbnRDbG91ZDoge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuUmF5Y2FzdGVyOiBwYXJhbXMuUG9pbnRDbG91ZCBoYXMgYmVlbiByZW5hbWVkIHRvIHBhcmFtcy5Qb2ludHMuJyApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlBvaW50cztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGRlc2NTb3J0KCBhLCBiICkge1xyXG5cclxuICAgICAgICByZXR1cm4gYS5kaXN0YW5jZSAtIGIuZGlzdGFuY2U7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGludGVyc2VjdE9iamVjdCggb2JqZWN0LCByYXljYXN0ZXIsIGludGVyc2VjdHMsIHJlY3Vyc2l2ZSApIHtcclxuXHJcbiAgICAgICAgaWYgKCBvYmplY3QudmlzaWJsZSA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG4gICAgICAgIG9iamVjdC5yYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKTtcclxuXHJcbiAgICAgICAgaWYgKCByZWN1cnNpdmUgPT09IHRydWUgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGludGVyc2VjdE9iamVjdCggY2hpbGRyZW5bIGkgXSwgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzLCB0cnVlICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy9cclxuXHJcbiAgICBUSFJFRS5SYXljYXN0ZXIucHJvdG90eXBlID0ge1xyXG5cclxuICAgICAgICBjb25zdHJ1Y3RvcjogVEhSRUUuUmF5Y2FzdGVyLFxyXG5cclxuICAgICAgICBsaW5lUHJlY2lzaW9uOiAxLFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICggb3JpZ2luLCBkaXJlY3Rpb24gKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBkaXJlY3Rpb24gaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkIChmb3IgYWNjdXJhdGUgZGlzdGFuY2UgY2FsY3VsYXRpb25zKVxyXG5cclxuICAgICAgICAgICAgdGhpcy5yYXkuc2V0KCBvcmlnaW4sIGRpcmVjdGlvbiApO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXRGcm9tQ2FtZXJhOiBmdW5jdGlvbiAoIGNvb3JkcywgY2FtZXJhICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBjYW1lcmEgaW5zdGFuY2VvZiBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJheS5vcmlnaW4uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmF5LmRpcmVjdGlvbi5zZXQoIGNvb3Jkcy54LCBjb29yZHMueSwgMC41ICkudW5wcm9qZWN0KCBjYW1lcmEgKS5zdWIoIHRoaXMucmF5Lm9yaWdpbiApLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIGlmICggY2FtZXJhIGluc3RhbmNlb2YgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMucmF5Lm9yaWdpbi5zZXQoIGNvb3Jkcy54LCBjb29yZHMueSwgLSAxICkudW5wcm9qZWN0KCBjYW1lcmEgKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmF5LmRpcmVjdGlvbi5zZXQoIDAsIDAsIC0gMSApLnRyYW5zZm9ybURpcmVjdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5SYXljYXN0ZXI6IFVuc3VwcG9ydGVkIGNhbWVyYSB0eXBlLicgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaW50ZXJzZWN0T2JqZWN0OiBmdW5jdGlvbiAoIG9iamVjdCwgcmVjdXJzaXZlICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGludGVyc2VjdHMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGludGVyc2VjdE9iamVjdCggb2JqZWN0LCB0aGlzLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUgKTtcclxuXHJcbiAgICAgICAgICAgIGludGVyc2VjdHMuc29ydCggZGVzY1NvcnQgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBpbnRlcnNlY3RzO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBpbnRlcnNlY3RPYmplY3RzOiBmdW5jdGlvbiAoIG9iamVjdHMsIHJlY3Vyc2l2ZSApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3RzID0gW107XHJcblxyXG4gICAgICAgICAgICBpZiAoIEFycmF5LmlzQXJyYXkoIG9iamVjdHMgKSA9PT0gZmFsc2UgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuUmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdHM6IG9iamVjdHMgaXMgbm90IGFuIEFycmF5LicgKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcnNlY3RzO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGludGVyc2VjdE9iamVjdCggb2JqZWN0c1sgaSBdLCB0aGlzLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGludGVyc2VjdHMuc29ydCggZGVzY1NvcnQgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBpbnRlcnNlY3RzO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbn0oIFRIUkVFICkgKTtcclxuXHJcbi8vIEZpbGU6c3JjL2NvcmUvT2JqZWN0M0QuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICogQGF1dGhvciBlbGVwaGFudGF0d29yayAvIHd3dy5lbGVwaGFudGF0d29yay5jaFxyXG4gKi9cclxuXHJcblRIUkVFLk9iamVjdDNEID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogVEhSRUUuT2JqZWN0M0RJZENvdW50ICsrIH0gKTtcclxuXHJcbiAgICB0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xyXG5cclxuICAgIHRoaXMubmFtZSA9ICcnO1xyXG4gICAgdGhpcy50eXBlID0gJ09iamVjdDNEJztcclxuXHJcbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XHJcbiAgICB0aGlzLmNoYW5uZWxzID0gbmV3IFRIUkVFLkNoYW5uZWxzKCk7XHJcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XHJcblxyXG4gICAgdGhpcy51cCA9IFRIUkVFLk9iamVjdDNELkRlZmF1bHRVcC5jbG9uZSgpO1xyXG5cclxuICAgIHZhciBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICB2YXIgcm90YXRpb24gPSBuZXcgVEhSRUUuRXVsZXIoKTtcclxuICAgIHZhciBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcclxuICAgIHZhciBzY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAxLCAxICk7XHJcblxyXG4gICAgZnVuY3Rpb24gb25Sb3RhdGlvbkNoYW5nZSgpIHtcclxuXHJcbiAgICAgICAgcXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIHJvdGF0aW9uLCBmYWxzZSApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBvblF1YXRlcm5pb25DaGFuZ2UoKSB7XHJcblxyXG4gICAgICAgIHJvdGF0aW9uLnNldEZyb21RdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLCB1bmRlZmluZWQsIGZhbHNlICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJvdGF0aW9uLm9uQ2hhbmdlKCBvblJvdGF0aW9uQ2hhbmdlICk7XHJcbiAgICBxdWF0ZXJuaW9uLm9uQ2hhbmdlKCBvblF1YXRlcm5pb25DaGFuZ2UgKTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xyXG4gICAgICAgIHBvc2l0aW9uOiB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBwb3NpdGlvblxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcm90YXRpb246IHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHJvdGF0aW9uXHJcbiAgICAgICAgfSxcclxuICAgICAgICBxdWF0ZXJuaW9uOiB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBxdWF0ZXJuaW9uXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzY2FsZToge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogc2NhbGVcclxuICAgICAgICB9LFxyXG4gICAgICAgIG1vZGVsVmlld01hdHJpeDoge1xyXG4gICAgICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLk1hdHJpeDQoKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbm9ybWFsTWF0cml4OiB7XHJcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuTWF0cml4MygpXHJcbiAgICAgICAgfVxyXG4gICAgfSApO1xyXG5cclxuICAgIHRoaXMucm90YXRpb25BdXRvVXBkYXRlID0gdHJ1ZTtcclxuXHJcbiAgICB0aGlzLm1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcbiAgICB0aGlzLm1hdHJpeFdvcmxkID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcbiAgICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBUSFJFRS5PYmplY3QzRC5EZWZhdWx0TWF0cml4QXV0b1VwZGF0ZTtcclxuICAgIHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XHJcblxyXG4gICAgdGhpcy5jYXN0U2hhZG93ID0gZmFsc2U7XHJcbiAgICB0aGlzLnJlY2VpdmVTaGFkb3cgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLmZydXN0dW1DdWxsZWQgPSB0cnVlO1xyXG4gICAgdGhpcy5yZW5kZXJPcmRlciA9IDA7XHJcblxyXG4gICAgdGhpcy51c2VyRGF0YSA9IHt9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLk9iamVjdDNELkRlZmF1bHRVcCA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XHJcblRIUkVFLk9iamVjdDNELkRlZmF1bHRNYXRyaXhBdXRvVXBkYXRlID0gdHJ1ZTtcclxuXHJcblRIUkVFLk9iamVjdDNELnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuT2JqZWN0M0QsXHJcblxyXG4gICAgZ2V0IGV1bGVyT3JkZXIgKCkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLmV1bGVyT3JkZXIgaXMgbm93IC5yb3RhdGlvbi5vcmRlci4nICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnJvdGF0aW9uLm9yZGVyO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0IGV1bGVyT3JkZXIgKCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5ldWxlck9yZGVyIGlzIG5vdyAucm90YXRpb24ub3JkZXIuJyApO1xyXG5cclxuICAgICAgICB0aGlzLnJvdGF0aW9uLm9yZGVyID0gdmFsdWU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXQgdXNlUXVhdGVybmlvbiAoKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAudXNlUXVhdGVybmlvbiBoYXMgYmVlbiByZW1vdmVkLiBUaGUgbGlicmFyeSBub3cgdXNlcyBxdWF0ZXJuaW9ucyBieSBkZWZhdWx0LicgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldCB1c2VRdWF0ZXJuaW9uICggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAudXNlUXVhdGVybmlvbiBoYXMgYmVlbiByZW1vdmVkLiBUaGUgbGlicmFyeSBub3cgdXNlcyBxdWF0ZXJuaW9ucyBieSBkZWZhdWx0LicgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldCByZW5kZXJEZXB0aCAoIHZhbHVlICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLnJlbmRlckRlcHRoIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAucmVuZGVyT3JkZXIsIGluc3RlYWQuJyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLy9cclxuXHJcbiAgICBhcHBseU1hdHJpeDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XHJcblxyXG4gICAgICAgIHRoaXMubWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeCwgdGhpcy5tYXRyaXggKTtcclxuXHJcbiAgICAgICAgdGhpcy5tYXRyaXguZGVjb21wb3NlKCB0aGlzLnBvc2l0aW9uLCB0aGlzLnF1YXRlcm5pb24sIHRoaXMuc2NhbGUgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldFJvdGF0aW9uRnJvbUF4aXNBbmdsZTogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcclxuXHJcbiAgICAgICAgLy8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcclxuXHJcbiAgICAgICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRSb3RhdGlvbkZyb21FdWxlcjogZnVuY3Rpb24gKCBldWxlciApIHtcclxuXHJcbiAgICAgICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21FdWxlciggZXVsZXIsIHRydWUgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldFJvdGF0aW9uRnJvbU1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuICAgICAgICAvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxyXG5cclxuICAgICAgICB0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XHJcblxyXG4gICAgICAgIC8vIGFzc3VtZXMgcSBpcyBub3JtYWxpemVkXHJcblxyXG4gICAgICAgIHRoaXMucXVhdGVybmlvbi5jb3B5KCBxICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICByb3RhdGVPbkF4aXM6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgLy8gcm90YXRlIG9iamVjdCBvbiBheGlzIGluIG9iamVjdCBzcGFjZVxyXG4gICAgICAgIC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXHJcblxyXG4gICAgICAgIHZhciBxMSA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xyXG5cclxuICAgICAgICAgICAgcTEuc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucXVhdGVybmlvbi5tdWx0aXBseSggcTEgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICByb3RhdGVYOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIGFuZ2xlICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgcm90YXRlWTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCBhbmdsZSApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyggdjEsIGFuZ2xlICk7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIHJvdGF0ZVo6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggYW5nbGUgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIHYxLCBhbmdsZSApO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICB0cmFuc2xhdGVPbkF4aXM6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgLy8gdHJhbnNsYXRlIG9iamVjdCBieSBkaXN0YW5jZSBhbG9uZyBheGlzIGluIG9iamVjdCBzcGFjZVxyXG4gICAgICAgIC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXHJcblxyXG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIGF4aXMsIGRpc3RhbmNlICkge1xyXG5cclxuICAgICAgICAgICAgdjEuY29weSggYXhpcyApLmFwcGx5UXVhdGVybmlvbiggdGhpcy5xdWF0ZXJuaW9uICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLmFkZCggdjEubXVsdGlwbHlTY2FsYXIoIGRpc3RhbmNlICkgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uICggZGlzdGFuY2UsIGF4aXMgKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAudHJhbnNsYXRlKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIC50cmFuc2xhdGVPbkF4aXMoIGF4aXMsIGRpc3RhbmNlICkgaW5zdGVhZC4nICk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCBheGlzLCBkaXN0YW5jZSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdHJhbnNsYXRlWDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMCwgMCApO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggdjEsIGRpc3RhbmNlICk7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIHRyYW5zbGF0ZVk6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggZGlzdGFuY2UgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIHYxLCBkaXN0YW5jZSApO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICB0cmFuc2xhdGVaOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgbG9jYWxUb1dvcmxkOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHdvcmxkVG9Mb2NhbDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggbTEuZ2V0SW52ZXJzZSggdGhpcy5tYXRyaXhXb3JsZCApICk7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIGxvb2tBdDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAvLyBUaGlzIHJvdXRpbmUgZG9lcyBub3Qgc3VwcG9ydCBvYmplY3RzIHdpdGggcm90YXRlZCBhbmQvb3IgdHJhbnNsYXRlZCBwYXJlbnQocylcclxuXHJcbiAgICAgICAgdmFyIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggdmVjdG9yICkge1xyXG5cclxuICAgICAgICAgICAgbTEubG9va0F0KCB2ZWN0b3IsIHRoaXMucG9zaXRpb24sIHRoaXMudXAgKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG0xICk7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG4gICAgICAgIGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDEgKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkKCBhcmd1bWVudHNbIGkgXSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBvYmplY3QgPT09IHRoaXMgKSB7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCBcIlRIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IGNhbid0IGJlIGFkZGVkIGFzIGEgY2hpbGQgb2YgaXRzZWxmLlwiLCBvYmplY3QgKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5PYmplY3QzRCApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggb2JqZWN0LnBhcmVudCAhPT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBvYmplY3QucGFyZW50LnJlbW92ZSggb2JqZWN0ICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBvYmplY3QucGFyZW50ID0gdGhpcztcclxuICAgICAgICAgICAgb2JqZWN0LmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2FkZGVkJyB9ICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goIG9iamVjdCApO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggXCJUSFJFRS5PYmplY3QzRC5hZGQ6IG9iamVjdCBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuT2JqZWN0M0QuXCIsIG9iamVjdCApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcbiAgICAgICAgaWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoIGFyZ3VtZW50c1sgaSBdICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKCBvYmplY3QgKTtcclxuXHJcbiAgICAgICAgaWYgKCBpbmRleCAhPT0gLSAxICkge1xyXG5cclxuICAgICAgICAgICAgb2JqZWN0LnBhcmVudCA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICBvYmplY3QuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAncmVtb3ZlZCcgfSApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoIGluZGV4LCAxICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldENoaWxkQnlOYW1lOiBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAuZ2V0Q2hpbGRCeU5hbWUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRPYmplY3RCeU5hbWUoKS4nICk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlOYW1lKCBuYW1lICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRPYmplY3RCeUlkOiBmdW5jdGlvbiAoIGlkICkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCAnaWQnLCBpZCApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0T2JqZWN0QnlOYW1lOiBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmdldE9iamVjdEJ5UHJvcGVydHkoICduYW1lJywgbmFtZSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0T2JqZWN0QnlQcm9wZXJ0eTogZnVuY3Rpb24gKCBuYW1lLCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgaWYgKCB0aGlzWyBuYW1lIF0gPT09IHZhbHVlICkgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5bIGkgXTtcclxuICAgICAgICAgICAgdmFyIG9iamVjdCA9IGNoaWxkLmdldE9iamVjdEJ5UHJvcGVydHkoIG5hbWUsIHZhbHVlICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG9iamVjdCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldFdvcmxkUG9zaXRpb246IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRXb3JsZFF1YXRlcm5pb246IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICB2YXIgc2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHBvc2l0aW9uLCByZXN1bHQsIHNjYWxlICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBnZXRXb3JsZFJvdGF0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLkV1bGVyKCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmdldFdvcmxkUXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5zZXRGcm9tUXVhdGVybmlvbiggcXVhdGVybmlvbiwgdGhpcy5yb3RhdGlvbi5vcmRlciwgZmFsc2UgKTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgZ2V0V29ybGRTY2FsZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgIHZhciBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgcmVzdWx0ICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBnZXRXb3JsZERpcmVjdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmdldFdvcmxkUXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5zZXQoIDAsIDAsIDEgKS5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgcmF5Y2FzdDogZnVuY3Rpb24gKCkge30sXHJcblxyXG4gICAgdHJhdmVyc2U6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XHJcblxyXG4gICAgICAgIGNhbGxiYWNrKCB0aGlzICk7XHJcblxyXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICBjaGlsZHJlblsgaSBdLnRyYXZlcnNlKCBjYWxsYmFjayApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0cmF2ZXJzZVZpc2libGU6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcbiAgICAgICAgY2FsbGJhY2soIHRoaXMgKTtcclxuXHJcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIGNoaWxkcmVuWyBpIF0udHJhdmVyc2VWaXNpYmxlKCBjYWxsYmFjayApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0cmF2ZXJzZUFuY2VzdG9yczogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcclxuXHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xyXG5cclxuICAgICAgICBpZiAoIHBhcmVudCAhPT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCBwYXJlbnQgKTtcclxuXHJcbiAgICAgICAgICAgIHBhcmVudC50cmF2ZXJzZUFuY2VzdG9ycyggY2FsbGJhY2sgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlTWF0cml4OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMubWF0cml4LmNvbXBvc2UoIHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSApO1xyXG5cclxuICAgICAgICB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlTWF0cml4V29ybGQ6IGZ1bmN0aW9uICggZm9yY2UgKSB7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5tYXRyaXhBdXRvVXBkYXRlID09PSB0cnVlICkgdGhpcy51cGRhdGVNYXRyaXgoKTtcclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPT09IHRydWUgfHwgZm9yY2UgPT09IHRydWUgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHRoaXMucGFyZW50ID09PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMubWF0cml4V29ybGQuY29weSggdGhpcy5tYXRyaXggKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCwgdGhpcy5tYXRyaXggKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgZm9yY2UgPSB0cnVlO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSBjaGlsZHJlblxyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuWyBpIF0udXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xyXG5cclxuICAgICAgICB2YXIgaXNSb290T2JqZWN0ID0gKCBtZXRhID09PSB1bmRlZmluZWQgKTtcclxuXHJcbiAgICAgICAgdmFyIG91dHB1dCA9IHt9O1xyXG5cclxuICAgICAgICAvLyBtZXRhIGlzIGEgaGFzaCB1c2VkIHRvIGNvbGxlY3QgZ2VvbWV0cmllcywgbWF0ZXJpYWxzLlxyXG4gICAgICAgIC8vIG5vdCBwcm92aWRpbmcgaXQgaW1wbGllcyB0aGF0IHRoaXMgaXMgdGhlIHJvb3Qgb2JqZWN0XHJcbiAgICAgICAgLy8gYmVpbmcgc2VyaWFsaXplZC5cclxuICAgICAgICBpZiAoIGlzUm9vdE9iamVjdCApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGluaXRpYWxpemUgbWV0YSBvYmpcclxuICAgICAgICAgICAgbWV0YSA9IHtcclxuICAgICAgICAgICAgICAgIGdlb21ldHJpZXM6IHt9LFxyXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWxzOiB7fSxcclxuICAgICAgICAgICAgICAgIHRleHR1cmVzOiB7fSxcclxuICAgICAgICAgICAgICAgIGltYWdlczoge31cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIG91dHB1dC5tZXRhZGF0YSA9IHtcclxuICAgICAgICAgICAgICAgIHZlcnNpb246IDQuNCxcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdPYmplY3QnLFxyXG4gICAgICAgICAgICAgICAgZ2VuZXJhdG9yOiAnT2JqZWN0M0QudG9KU09OJ1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHN0YW5kYXJkIE9iamVjdDNEIHNlcmlhbGl6YXRpb25cclxuXHJcbiAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xyXG5cclxuICAgICAgICBvYmplY3QudXVpZCA9IHRoaXMudXVpZDtcclxuICAgICAgICBvYmplY3QudHlwZSA9IHRoaXMudHlwZTtcclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLm5hbWUgIT09ICcnICkgb2JqZWN0Lm5hbWUgPSB0aGlzLm5hbWU7XHJcbiAgICAgICAgaWYgKCBKU09OLnN0cmluZ2lmeSggdGhpcy51c2VyRGF0YSApICE9PSAne30nICkgb2JqZWN0LnVzZXJEYXRhID0gdGhpcy51c2VyRGF0YTtcclxuICAgICAgICBpZiAoIHRoaXMuY2FzdFNoYWRvdyA9PT0gdHJ1ZSApIG9iamVjdC5jYXN0U2hhZG93ID0gdHJ1ZTtcclxuICAgICAgICBpZiAoIHRoaXMucmVjZWl2ZVNoYWRvdyA9PT0gdHJ1ZSApIG9iamVjdC5yZWNlaXZlU2hhZG93ID0gdHJ1ZTtcclxuICAgICAgICBpZiAoIHRoaXMudmlzaWJsZSA9PT0gZmFsc2UgKSBvYmplY3QudmlzaWJsZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICBvYmplY3QubWF0cml4ID0gdGhpcy5tYXRyaXgudG9BcnJheSgpO1xyXG5cclxuICAgICAgICAvL1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMuZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggbWV0YS5nZW9tZXRyaWVzWyB0aGlzLmdlb21ldHJ5LnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIG1ldGEuZ2VvbWV0cmllc1sgdGhpcy5nZW9tZXRyeS51dWlkIF0gPSB0aGlzLmdlb21ldHJ5LnRvSlNPTiggbWV0YSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgb2JqZWN0Lmdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeS51dWlkO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5tYXRlcmlhbCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBtZXRhLm1hdGVyaWFsc1sgdGhpcy5tYXRlcmlhbC51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBtZXRhLm1hdGVyaWFsc1sgdGhpcy5tYXRlcmlhbC51dWlkIF0gPSB0aGlzLm1hdGVyaWFsLnRvSlNPTiggbWV0YSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgb2JqZWN0Lm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbC51dWlkO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vXHJcblxyXG4gICAgICAgIGlmICggdGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwICkge1xyXG5cclxuICAgICAgICAgICAgb2JqZWN0LmNoaWxkcmVuID0gW107XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBvYmplY3QuY2hpbGRyZW4ucHVzaCggdGhpcy5jaGlsZHJlblsgaSBdLnRvSlNPTiggbWV0YSApLm9iamVjdCApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggaXNSb290T2JqZWN0ICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGdlb21ldHJpZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLmdlb21ldHJpZXMgKTtcclxuICAgICAgICAgICAgdmFyIG1hdGVyaWFscyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEubWF0ZXJpYWxzICk7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEudGV4dHVyZXMgKTtcclxuICAgICAgICAgICAgdmFyIGltYWdlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuaW1hZ2VzICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGdlb21ldHJpZXMubGVuZ3RoID4gMCApIG91dHB1dC5nZW9tZXRyaWVzID0gZ2VvbWV0cmllcztcclxuICAgICAgICAgICAgaWYgKCBtYXRlcmlhbHMubGVuZ3RoID4gMCApIG91dHB1dC5tYXRlcmlhbHMgPSBtYXRlcmlhbHM7XHJcbiAgICAgICAgICAgIGlmICggdGV4dHVyZXMubGVuZ3RoID4gMCApIG91dHB1dC50ZXh0dXJlcyA9IHRleHR1cmVzO1xyXG4gICAgICAgICAgICBpZiAoIGltYWdlcy5sZW5ndGggPiAwICkgb3V0cHV0LmltYWdlcyA9IGltYWdlcztcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvdXRwdXQub2JqZWN0ID0gb2JqZWN0O1xyXG5cclxuICAgICAgICByZXR1cm4gb3V0cHV0O1xyXG5cclxuICAgICAgICAvLyBleHRyYWN0IGRhdGEgZnJvbSB0aGUgY2FjaGUgaGFzaFxyXG4gICAgICAgIC8vIHJlbW92ZSBtZXRhZGF0YSBvbiBlYWNoIGl0ZW1cclxuICAgICAgICAvLyBhbmQgcmV0dXJuIGFzIGFycmF5XHJcbiAgICAgICAgZnVuY3Rpb24gZXh0cmFjdEZyb21DYWNoZSAoIGNhY2hlICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKCB2YXIga2V5IGluIGNhY2hlICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gY2FjaGVbIGtleSBdO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGRhdGEubWV0YWRhdGE7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCggZGF0YSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjbG9uZTogZnVuY3Rpb24gKCByZWN1cnNpdmUgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMsIHJlY3Vyc2l2ZSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29weTogZnVuY3Rpb24gKCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcclxuXHJcbiAgICAgICAgaWYgKCByZWN1cnNpdmUgPT09IHVuZGVmaW5lZCApIHJlY3Vyc2l2ZSA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xyXG5cclxuICAgICAgICB0aGlzLnVwLmNvcHkoIHNvdXJjZS51cCApO1xyXG5cclxuICAgICAgICB0aGlzLnBvc2l0aW9uLmNvcHkoIHNvdXJjZS5wb3NpdGlvbiApO1xyXG4gICAgICAgIHRoaXMucXVhdGVybmlvbi5jb3B5KCBzb3VyY2UucXVhdGVybmlvbiApO1xyXG4gICAgICAgIHRoaXMuc2NhbGUuY29weSggc291cmNlLnNjYWxlICk7XHJcblxyXG4gICAgICAgIHRoaXMucm90YXRpb25BdXRvVXBkYXRlID0gc291cmNlLnJvdGF0aW9uQXV0b1VwZGF0ZTtcclxuXHJcbiAgICAgICAgdGhpcy5tYXRyaXguY29weSggc291cmNlLm1hdHJpeCApO1xyXG4gICAgICAgIHRoaXMubWF0cml4V29ybGQuY29weSggc291cmNlLm1hdHJpeFdvcmxkICk7XHJcblxyXG4gICAgICAgIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhBdXRvVXBkYXRlO1xyXG4gICAgICAgIHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlO1xyXG5cclxuICAgICAgICB0aGlzLnZpc2libGUgPSBzb3VyY2UudmlzaWJsZTtcclxuXHJcbiAgICAgICAgdGhpcy5jYXN0U2hhZG93ID0gc291cmNlLmNhc3RTaGFkb3c7XHJcbiAgICAgICAgdGhpcy5yZWNlaXZlU2hhZG93ID0gc291cmNlLnJlY2VpdmVTaGFkb3c7XHJcblxyXG4gICAgICAgIHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHNvdXJjZS5mcnVzdHVtQ3VsbGVkO1xyXG4gICAgICAgIHRoaXMucmVuZGVyT3JkZXIgPSBzb3VyY2UucmVuZGVyT3JkZXI7XHJcblxyXG4gICAgICAgIHRoaXMudXNlckRhdGEgPSBKU09OLnBhcnNlKCBKU09OLnN0cmluZ2lmeSggc291cmNlLnVzZXJEYXRhICkgKTtcclxuXHJcbiAgICAgICAgaWYgKCByZWN1cnNpdmUgPT09IHRydWUgKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBzb3VyY2UuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHNvdXJjZS5jaGlsZHJlblsgaSBdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoIGNoaWxkLmNsb25lKCkgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5PYmplY3QzRElkQ291bnQgPSAwO1xyXG5cclxuLy8gRmlsZTpzcmMvY29yZS9GYWNlMy5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuRmFjZTMgPSBmdW5jdGlvbiAoIGEsIGIsIGMsIG5vcm1hbCwgY29sb3IsIG1hdGVyaWFsSW5kZXggKSB7XHJcblxyXG4gICAgdGhpcy5hID0gYTtcclxuICAgIHRoaXMuYiA9IGI7XHJcbiAgICB0aGlzLmMgPSBjO1xyXG5cclxuICAgIHRoaXMubm9ybWFsID0gbm9ybWFsIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyA/IG5vcm1hbCA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICB0aGlzLnZlcnRleE5vcm1hbHMgPSBBcnJheS5pc0FycmF5KCBub3JtYWwgKSA/IG5vcm1hbCA6IFtdO1xyXG5cclxuICAgIHRoaXMuY29sb3IgPSBjb2xvciBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yID8gY29sb3IgOiBuZXcgVEhSRUUuQ29sb3IoKTtcclxuICAgIHRoaXMudmVydGV4Q29sb3JzID0gQXJyYXkuaXNBcnJheSggY29sb3IgKSA/IGNvbG9yIDogW107XHJcblxyXG4gICAgdGhpcy5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWxJbmRleCA6IDA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRmFjZTMucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5GYWNlMyxcclxuXHJcbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5hID0gc291cmNlLmE7XHJcbiAgICAgICAgdGhpcy5iID0gc291cmNlLmI7XHJcbiAgICAgICAgdGhpcy5jID0gc291cmNlLmM7XHJcblxyXG4gICAgICAgIHRoaXMubm9ybWFsLmNvcHkoIHNvdXJjZS5ub3JtYWwgKTtcclxuICAgICAgICB0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xyXG5cclxuICAgICAgICB0aGlzLm1hdGVyaWFsSW5kZXggPSBzb3VyY2UubWF0ZXJpYWxJbmRleDtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHNvdXJjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhOb3JtYWxzWyBpIF0gPSBzb3VyY2UudmVydGV4Tm9ybWFsc1sgaSBdLmNsb25lKCk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnZlcnRleENvbG9yc1sgaSBdID0gc291cmNlLnZlcnRleENvbG9yc1sgaSBdLmNsb25lKCk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2NvcmUvRmFjZTQuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkZhY2U0ID0gZnVuY3Rpb24gKCBhLCBiLCBjLCBkLCBub3JtYWwsIGNvbG9yLCBtYXRlcmlhbEluZGV4ICkge1xyXG5cclxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkZhY2U0IGhhcyBiZWVuIHJlbW92ZWQuIEEgVEhSRUUuRmFjZTMgd2lsbCBiZSBjcmVhdGVkIGluc3RlYWQuJyApO1xyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgYywgbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxJbmRleCApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5CdWZmZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcclxuXHJcbiAgICB0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xyXG5cclxuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcclxuICAgIHRoaXMuaXRlbVNpemUgPSBpdGVtU2l6ZTtcclxuXHJcbiAgICB0aGlzLmR5bmFtaWMgPSBmYWxzZTtcclxuICAgIHRoaXMudXBkYXRlUmFuZ2UgPSB7IG9mZnNldDogMCwgY291bnQ6IC0gMSB9O1xyXG5cclxuICAgIHRoaXMudmVyc2lvbiA9IDA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuQnVmZmVyQXR0cmlidXRlLFxyXG5cclxuICAgIGdldCBsZW5ndGgoKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogLmxlbmd0aCBoYXMgYmVlbiBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIC5jb3VudC4nICk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0IGNvdW50KCkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5hcnJheS5sZW5ndGggLyB0aGlzLml0ZW1TaXplO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0IG5lZWRzVXBkYXRlKCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgaWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudmVyc2lvbiArKztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldER5bmFtaWM6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuZHluYW1pYyA9IHZhbHVlO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuICAgICAgICB0aGlzLmFycmF5ID0gbmV3IHNvdXJjZS5hcnJheS5jb25zdHJ1Y3Rvciggc291cmNlLmFycmF5ICk7XHJcbiAgICAgICAgdGhpcy5pdGVtU2l6ZSA9IHNvdXJjZS5pdGVtU2l6ZTtcclxuXHJcbiAgICAgICAgdGhpcy5keW5hbWljID0gc291cmNlLmR5bmFtaWM7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29weUF0OiBmdW5jdGlvbiAoIGluZGV4MSwgYXR0cmlidXRlLCBpbmRleDIgKSB7XHJcblxyXG4gICAgICAgIGluZGV4MSAqPSB0aGlzLml0ZW1TaXplO1xyXG4gICAgICAgIGluZGV4MiAqPSBhdHRyaWJ1dGUuaXRlbVNpemU7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuaXRlbVNpemU7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hcnJheVsgaW5kZXgxICsgaSBdID0gYXR0cmlidXRlLmFycmF5WyBpbmRleDIgKyBpIF07XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb3B5QXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuYXJyYXkuc2V0KCBhcnJheSApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvcHlDb2xvcnNBcnJheTogZnVuY3Rpb24gKCBjb2xvcnMgKSB7XHJcblxyXG4gICAgICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGNvbG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGNvbG9yID0gY29sb3JzWyBpIF07XHJcblxyXG4gICAgICAgICAgICBpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlDb2xvcnNBcnJheSgpOiBjb2xvciBpcyB1bmRlZmluZWQnLCBpICk7XHJcbiAgICAgICAgICAgICAgICBjb2xvciA9IG5ldyBUSFJFRS5Db2xvcigpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYXJyYXlbIG9mZnNldCArKyBdID0gY29sb3IucjtcclxuICAgICAgICAgICAgYXJyYXlbIG9mZnNldCArKyBdID0gY29sb3IuZztcclxuICAgICAgICAgICAgYXJyYXlbIG9mZnNldCArKyBdID0gY29sb3IuYjtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvcHlJbmRpY2VzQXJyYXk6IGZ1bmN0aW9uICggaW5kaWNlcyApIHtcclxuXHJcbiAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gaW5kaWNlc1sgaSBdO1xyXG5cclxuICAgICAgICAgICAgYXJyYXlbIG9mZnNldCArKyBdID0gaW5kZXguYTtcclxuICAgICAgICAgICAgYXJyYXlbIG9mZnNldCArKyBdID0gaW5kZXguYjtcclxuICAgICAgICAgICAgYXJyYXlbIG9mZnNldCArKyBdID0gaW5kZXguYztcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvcHlWZWN0b3Iyc0FycmF5OiBmdW5jdGlvbiAoIHZlY3RvcnMgKSB7XHJcblxyXG4gICAgICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHZlY3RvcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciB2ZWN0b3IgPSB2ZWN0b3JzWyBpIF07XHJcblxyXG4gICAgICAgICAgICBpZiAoIHZlY3RvciA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5VmVjdG9yMnNBcnJheSgpOiB2ZWN0b3IgaXMgdW5kZWZpbmVkJywgaSApO1xyXG4gICAgICAgICAgICAgICAgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci54O1xyXG4gICAgICAgICAgICBhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvcHlWZWN0b3Izc0FycmF5OiBmdW5jdGlvbiAoIHZlY3RvcnMgKSB7XHJcblxyXG4gICAgICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHZlY3RvcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciB2ZWN0b3IgPSB2ZWN0b3JzWyBpIF07XHJcblxyXG4gICAgICAgICAgICBpZiAoIHZlY3RvciA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5VmVjdG9yM3NBcnJheSgpOiB2ZWN0b3IgaXMgdW5kZWZpbmVkJywgaSApO1xyXG4gICAgICAgICAgICAgICAgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci54O1xyXG4gICAgICAgICAgICBhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueTtcclxuICAgICAgICAgICAgYXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLno7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb3B5VmVjdG9yNHNBcnJheTogZnVuY3Rpb24gKCB2ZWN0b3JzICkge1xyXG5cclxuICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5LCBvZmZzZXQgPSAwO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZWN0b3JzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgdmVjdG9yID0gdmVjdG9yc1sgaSBdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCB2ZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weVZlY3RvcjRzQXJyYXkoKTogdmVjdG9yIGlzIHVuZGVmaW5lZCcsIGkgKTtcclxuICAgICAgICAgICAgICAgIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3I0KCk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueDtcclxuICAgICAgICAgICAgYXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLnk7XHJcbiAgICAgICAgICAgIGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci56O1xyXG4gICAgICAgICAgICBhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IudztcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldDogZnVuY3Rpb24gKCB2YWx1ZSwgb2Zmc2V0ICkge1xyXG5cclxuICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5hcnJheS5zZXQoIHZhbHVlLCBvZmZzZXQgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRYOiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplIF07XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRYOiBmdW5jdGlvbiAoIGluZGV4LCB4ICkge1xyXG5cclxuICAgICAgICB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgXSA9IHg7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0WTogZnVuY3Rpb24gKCBpbmRleCApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDEgXTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldFk6IGZ1bmN0aW9uICggaW5kZXgsIHkgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDEgXSA9IHk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0WjogZnVuY3Rpb24gKCBpbmRleCApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDIgXTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldFo6IGZ1bmN0aW9uICggaW5kZXgsIHogKSB7XHJcblxyXG4gICAgICAgIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDIgXSA9IHo7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VzogZnVuY3Rpb24gKCBpbmRleCApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDMgXTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldFc6IGZ1bmN0aW9uICggaW5kZXgsIHcgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDMgXSA9IHc7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0WFk6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHkgKSB7XHJcblxyXG4gICAgICAgIGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XHJcblxyXG4gICAgICAgIHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcclxuICAgICAgICB0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0WFlaOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5LCB6ICkge1xyXG5cclxuICAgICAgICBpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xyXG5cclxuICAgICAgICB0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XHJcbiAgICAgICAgdGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xyXG4gICAgICAgIHRoaXMuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRYWVpXOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5LCB6LCB3ICkge1xyXG5cclxuICAgICAgICBpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xyXG5cclxuICAgICAgICB0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XHJcbiAgICAgICAgdGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xyXG4gICAgICAgIHRoaXMuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcclxuICAgICAgICB0aGlzLmFycmF5WyBpbmRleCArIDMgXSA9IHc7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vL1xyXG5cclxuVEhSRUUuSW50OEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgSW50OEFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlVpbnQ4QXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBVaW50OEFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlVpbnQ4Q2xhbXBlZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgVWludDhDbGFtcGVkQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuSW50MTZBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcclxuXHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEludDE2QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVWludDE2QXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBVaW50MTZBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5JbnQzMkF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgSW50MzJBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5VaW50MzJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcclxuXHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IFVpbnQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcclxuXHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5GbG9hdDY0QXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDY0QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XHJcblxyXG59O1xyXG5cclxuXHJcbi8vIERlcHJlY2F0ZWRcclxuXHJcblRIUkVFLkR5bmFtaWNCdWZmZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcclxuXHJcbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5EeW5hbWljQnVmZmVyQXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCkuc2V0RHluYW1pYyggdHJ1ZSApIGluc3RlYWQuJyApO1xyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApLnNldER5bmFtaWMoIHRydWUgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9jb3JlL0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xyXG4gKi9cclxuXHJcblRIUkVFLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplLCBtZXNoUGVyQXR0cmlidXRlICkge1xyXG5cclxuICAgIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBhcnJheSwgaXRlbVNpemUgKTtcclxuXHJcbiAgICB0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBtZXNoUGVyQXR0cmlidXRlIHx8IDE7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgKTtcclxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZTtcclxuXHJcblRIUkVFLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuICAgIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcbiAgICB0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBzb3VyY2UubWVzaFBlckF0dHJpYnV0ZTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9jb3JlL0ludGVybGVhdmVkQnVmZmVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXHJcbiAqL1xyXG5cclxuVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXIgPSBmdW5jdGlvbiAoIGFycmF5LCBzdHJpZGUgKSB7XHJcblxyXG4gICAgdGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XHJcbiAgICB0aGlzLnN0cmlkZSA9IHN0cmlkZTtcclxuXHJcbiAgICB0aGlzLmR5bmFtaWMgPSBmYWxzZTtcclxuICAgIHRoaXMudXBkYXRlUmFuZ2UgPSB7IG9mZnNldDogMCwgY291bnQ6IC0gMSB9O1xyXG5cclxuICAgIHRoaXMudmVyc2lvbiA9IDA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlcixcclxuXHJcbiAgICBnZXQgbGVuZ3RoICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0IGNvdW50ICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoIC8gdGhpcy5zdHJpZGU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXQgbmVlZHNVcGRhdGUoIHZhbHVlICkge1xyXG5cclxuICAgICAgICBpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy52ZXJzaW9uICsrO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0RHluYW1pYzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5keW5hbWljID0gdmFsdWU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuYXJyYXkgPSBuZXcgc291cmNlLmFycmF5LmNvbnN0cnVjdG9yKCBzb3VyY2UuYXJyYXkgKTtcclxuICAgICAgICB0aGlzLnN0cmlkZSA9IHNvdXJjZS5zdHJpZGU7XHJcbiAgICAgICAgdGhpcy5keW5hbWljID0gc291cmNlLmR5bmFtaWM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb3B5QXQ6IGZ1bmN0aW9uICggaW5kZXgxLCBhdHRyaWJ1dGUsIGluZGV4MiApIHtcclxuXHJcbiAgICAgICAgaW5kZXgxICo9IHRoaXMuc3RyaWRlO1xyXG4gICAgICAgIGluZGV4MiAqPSBhdHRyaWJ1dGUuc3RyaWRlO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLnN0cmlkZTsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFycmF5WyBpbmRleDEgKyBpIF0gPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4MiArIGkgXTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldDogZnVuY3Rpb24gKCB2YWx1ZSwgb2Zmc2V0ICkge1xyXG5cclxuICAgICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5hcnJheS5zZXQoIHZhbHVlLCBvZmZzZXQgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2NvcmUvSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcclxuICovXHJcblxyXG5USFJFRS5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciA9IGZ1bmN0aW9uICggYXJyYXksIHN0cmlkZSwgbWVzaFBlckF0dHJpYnV0ZSApIHtcclxuXHJcbiAgICBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlci5jYWxsKCB0aGlzLCBhcnJheSwgc3RyaWRlICk7XHJcblxyXG4gICAgdGhpcy5tZXNoUGVyQXR0cmlidXRlID0gbWVzaFBlckF0dHJpYnV0ZSB8fCAxO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZSApO1xyXG5USFJFRS5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlcjtcclxuXHJcblRIUkVFLkluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG4gICAgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG4gICAgdGhpcy5tZXNoUGVyQXR0cmlidXRlID0gc291cmNlLm1lc2hQZXJBdHRyaWJ1dGU7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvY29yZS9JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xyXG4gKi9cclxuXHJcblRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlID0gZnVuY3Rpb24gKCBpbnRlcmxlYXZlZEJ1ZmZlciwgaXRlbVNpemUsIG9mZnNldCApIHtcclxuXHJcbiAgICB0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xyXG5cclxuICAgIHRoaXMuZGF0YSA9IGludGVybGVhdmVkQnVmZmVyO1xyXG4gICAgdGhpcy5pdGVtU2l6ZSA9IGl0ZW1TaXplO1xyXG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUsXHJcblxyXG4gICAgZ2V0IGxlbmd0aCgpIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlOiAubGVuZ3RoIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgLmNvdW50LicgKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcnJheS5sZW5ndGg7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXQgY291bnQoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuYXJyYXkubGVuZ3RoIC8gdGhpcy5kYXRhLnN0cmlkZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldFg6IGZ1bmN0aW9uICggaW5kZXgsIHggKSB7XHJcblxyXG4gICAgICAgIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgXSA9IHg7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0WTogZnVuY3Rpb24gKCBpbmRleCwgeSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDEgXSA9IHk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0WjogZnVuY3Rpb24gKCBpbmRleCwgeiApIHtcclxuXHJcbiAgICAgICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDIgXSA9IHo7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0VzogZnVuY3Rpb24gKCBpbmRleCwgdyApIHtcclxuXHJcbiAgICAgICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDMgXSA9IHc7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0WDogZnVuY3Rpb24gKCBpbmRleCApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgXTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldFk6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMSBdO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0WjogZnVuY3Rpb24gKCBpbmRleCApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAyIF07XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRXOiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDMgXTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldFhZOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5ICkge1xyXG5cclxuICAgICAgICBpbmRleCA9IGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xyXG5cclxuICAgICAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcclxuICAgICAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRYWVo6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHksIHogKSB7XHJcblxyXG4gICAgICAgIGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XHJcblxyXG4gICAgICAgIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xyXG4gICAgICAgIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xyXG4gICAgICAgIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldFhZWlc6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHksIHosIHcgKSB7XHJcblxyXG4gICAgICAgIGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XHJcblxyXG4gICAgICAgIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xyXG4gICAgICAgIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xyXG4gICAgICAgIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xyXG4gICAgICAgIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAzIF0gPSB3O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvY29yZS9HZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3Iga2lsZSAvIGh0dHA6Ly9raWxlLnN0cmF2YWdhbnphLm9yZy9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXHJcbiAqL1xyXG5cclxuVEhSRUUuR2VvbWV0cnkgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBUSFJFRS5HZW9tZXRyeUlkQ291bnQgKysgfSApO1xyXG5cclxuICAgIHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XHJcblxyXG4gICAgdGhpcy5uYW1lID0gJyc7XHJcbiAgICB0aGlzLnR5cGUgPSAnR2VvbWV0cnknO1xyXG5cclxuICAgIHRoaXMudmVydGljZXMgPSBbXTtcclxuICAgIHRoaXMuY29sb3JzID0gW107XHJcbiAgICB0aGlzLmZhY2VzID0gW107XHJcbiAgICB0aGlzLmZhY2VWZXJ0ZXhVdnMgPSBbIFtdIF07XHJcblxyXG4gICAgdGhpcy5tb3JwaFRhcmdldHMgPSBbXTtcclxuICAgIHRoaXMubW9ycGhOb3JtYWxzID0gW107XHJcblxyXG4gICAgdGhpcy5za2luV2VpZ2h0cyA9IFtdO1xyXG4gICAgdGhpcy5za2luSW5kaWNlcyA9IFtdO1xyXG5cclxuICAgIHRoaXMubGluZURpc3RhbmNlcyA9IFtdO1xyXG5cclxuICAgIHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xyXG4gICAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XHJcblxyXG4gICAgLy8gdXBkYXRlIGZsYWdzXHJcblxyXG4gICAgdGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuICAgIHRoaXMuZWxlbWVudHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcbiAgICB0aGlzLnV2c05lZWRVcGRhdGUgPSBmYWxzZTtcclxuICAgIHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuICAgIHRoaXMuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5ncm91cHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5HZW9tZXRyeSxcclxuXHJcbiAgICBhcHBseU1hdHJpeDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XHJcblxyXG4gICAgICAgIHZhciBub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHZlcnRleCA9IHRoaXMudmVydGljZXNbIGkgXTtcclxuICAgICAgICAgICAgdmVydGV4LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgZmFjZSA9IHRoaXMuZmFjZXNbIGkgXTtcclxuICAgICAgICAgICAgZmFjZS5ub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZmFjZS52ZXJ0ZXhOb3JtYWxzWyBqIF0uYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIHRoaXMuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcm90YXRlWDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHgtYXhpc1xyXG5cclxuICAgICAgICB2YXIgbTE7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiByb3RhdGVYKCBhbmdsZSApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcbiAgICAgICAgICAgIG0xLm1ha2VSb3RhdGlvblgoIGFuZ2xlICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgLy8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB5LWF4aXNcclxuXHJcbiAgICAgICAgdmFyIG0xO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcm90YXRlWSggYW5nbGUgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG4gICAgICAgICAgICBtMS5tYWtlUm90YXRpb25ZKCBhbmdsZSApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hcHBseU1hdHJpeCggbTEgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICByb3RhdGVaOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgei1heGlzXHJcblxyXG4gICAgICAgIHZhciBtMTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVooIGFuZ2xlICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuICAgICAgICAgICAgbTEubWFrZVJvdGF0aW9uWiggYW5nbGUgKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIC8vIHRyYW5zbGF0ZSBnZW9tZXRyeVxyXG5cclxuICAgICAgICB2YXIgbTE7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiB0cmFuc2xhdGUoIHgsIHksIHogKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG4gICAgICAgICAgICBtMS5tYWtlVHJhbnNsYXRpb24oIHgsIHksIHogKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgc2NhbGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgLy8gc2NhbGUgZ2VvbWV0cnlcclxuXHJcbiAgICAgICAgdmFyIG0xO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc2NhbGUoIHgsIHksIHogKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG4gICAgICAgICAgICBtMS5tYWtlU2NhbGUoIHgsIHksIHogKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgbG9va0F0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBvYmo7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBsb29rQXQoIHZlY3RvciApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggb2JqID09PSB1bmRlZmluZWQgKSBvYmogPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcclxuXHJcbiAgICAgICAgICAgIG9iai5sb29rQXQoIHZlY3RvciApO1xyXG5cclxuICAgICAgICAgICAgb2JqLnVwZGF0ZU1hdHJpeCgpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hcHBseU1hdHJpeCggb2JqLm1hdHJpeCApO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBmcm9tQnVmZmVyR2VvbWV0cnk6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XHJcblxyXG4gICAgICAgIHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG4gICAgICAgIHZhciBpbmRpY2VzID0gZ2VvbWV0cnkuaW5kZXggIT09IG51bGwgPyBnZW9tZXRyeS5pbmRleC5hcnJheSA6IHVuZGVmaW5lZDtcclxuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XHJcblxyXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcbiAgICAgICAgdmFyIG5vcm1hbHMgPSBhdHRyaWJ1dGVzLm5vcm1hbCAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy5ub3JtYWwuYXJyYXkgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgdmFyIGNvbG9ycyA9IGF0dHJpYnV0ZXMuY29sb3IgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMuY29sb3IuYXJyYXkgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgdmFyIHV2cyA9IGF0dHJpYnV0ZXMudXYgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMudXYuYXJyYXkgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgdmFyIHV2czIgPSBhdHRyaWJ1dGVzLnV2MiAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy51djIuYXJyYXkgOiB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIGlmICggdXZzMiAhPT0gdW5kZWZpbmVkICkgdGhpcy5mYWNlVmVydGV4VXZzWyAxIF0gPSBbXTtcclxuXHJcbiAgICAgICAgdmFyIHRlbXBOb3JtYWxzID0gW107XHJcbiAgICAgICAgdmFyIHRlbXBVVnMgPSBbXTtcclxuICAgICAgICB2YXIgdGVtcFVWczIgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBqID0gMCwgayA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkgKz0gMywgaiArPSAyLCBrICs9IDQgKSB7XHJcblxyXG4gICAgICAgICAgICBzY29wZS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggdmVydGljZXNbIGkgXSwgdmVydGljZXNbIGkgKyAxIF0sIHZlcnRpY2VzWyBpICsgMiBdICkgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggbm9ybWFscyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHRlbXBOb3JtYWxzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCBub3JtYWxzWyBpIF0sIG5vcm1hbHNbIGkgKyAxIF0sIG5vcm1hbHNbIGkgKyAyIF0gKSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBjb2xvcnMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBzY29wZS5jb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCBjb2xvcnNbIGkgXSwgY29sb3JzWyBpICsgMSBdLCBjb2xvcnNbIGkgKyAyIF0gKSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCB1dnMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0ZW1wVVZzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB1dnNbIGogXSwgdXZzWyBqICsgMSBdICkgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggdXZzMiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHRlbXBVVnMyLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB1dnMyWyBqIF0sIHV2czJbIGogKyAxIF0gKSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGFkZEZhY2UoIGEsIGIsIGMgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgdmVydGV4Tm9ybWFscyA9IG5vcm1hbHMgIT09IHVuZGVmaW5lZCA/IFsgdGVtcE5vcm1hbHNbIGEgXS5jbG9uZSgpLCB0ZW1wTm9ybWFsc1sgYiBdLmNsb25lKCksIHRlbXBOb3JtYWxzWyBjIF0uY2xvbmUoKSBdIDogW107XHJcbiAgICAgICAgICAgIHZhciB2ZXJ0ZXhDb2xvcnMgPSBjb2xvcnMgIT09IHVuZGVmaW5lZCA/IFsgc2NvcGUuY29sb3JzWyBhIF0uY2xvbmUoKSwgc2NvcGUuY29sb3JzWyBiIF0uY2xvbmUoKSwgc2NvcGUuY29sb3JzWyBjIF0uY2xvbmUoKSBdIDogW107XHJcblxyXG4gICAgICAgICAgICB2YXIgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgYywgdmVydGV4Tm9ybWFscywgdmVydGV4Q29sb3JzICk7XHJcblxyXG4gICAgICAgICAgICBzY29wZS5mYWNlcy5wdXNoKCBmYWNlICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHV2cyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHRlbXBVVnNbIGEgXS5jbG9uZSgpLCB0ZW1wVVZzWyBiIF0uY2xvbmUoKSwgdGVtcFVWc1sgYyBdLmNsb25lKCkgXSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCB1dnMyICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgc2NvcGUuZmFjZVZlcnRleFV2c1sgMSBdLnB1c2goIFsgdGVtcFVWczJbIGEgXS5jbG9uZSgpLCB0ZW1wVVZzMlsgYiBdLmNsb25lKCksIHRlbXBVVnMyWyBjIF0uY2xvbmUoKSBdICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmICggaW5kaWNlcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcclxuXHJcbiAgICAgICAgICAgIGlmICggZ3JvdXBzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gZ3JvdXBzWyBpIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGdyb3VwLnN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IGdyb3VwLmNvdW50O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaiA9IHN0YXJ0LCBqbCA9IHN0YXJ0ICsgY291bnQ7IGogPCBqbDsgaiArPSAzICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkRmFjZSggaW5kaWNlc1sgaiBdLCBpbmRpY2VzWyBqICsgMSBdLCBpbmRpY2VzWyBqICsgMiBdICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpICs9IDMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGFkZEZhY2UoIGluZGljZXNbIGkgXSwgaW5kaWNlc1sgaSArIDEgXSwgaW5kaWNlc1sgaSArIDIgXSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aCAvIDM7IGkgKz0gMyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBhZGRGYWNlKCBpLCBpICsgMSwgaSArIDIgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cclxuICAgICAgICBpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IGdlb21ldHJ5LmJvdW5kaW5nQm94LmNsb25lKCk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2VudGVyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XHJcblxyXG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLmJvdW5kaW5nQm94LmNlbnRlcigpLm5lZ2F0ZSgpO1xyXG5cclxuICAgICAgICB0aGlzLnRyYW5zbGF0ZSggb2Zmc2V0LngsIG9mZnNldC55LCBvZmZzZXQueiApO1xyXG5cclxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG4gICAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLmNlbnRlcjtcclxuICAgICAgICB2YXIgcmFkaXVzID0gdGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXM7XHJcblxyXG4gICAgICAgIHZhciBzID0gcmFkaXVzID09PSAwID8gMSA6IDEuMCAvIHJhZGl1cztcclxuXHJcbiAgICAgICAgdmFyIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcbiAgICAgICAgbWF0cml4LnNldChcclxuICAgICAgICAgICAgcywgMCwgMCwgLSBzICogY2VudGVyLngsXHJcbiAgICAgICAgICAgIDAsIHMsIDAsIC0gcyAqIGNlbnRlci55LFxyXG4gICAgICAgICAgICAwLCAwLCBzLCAtIHMgKiBjZW50ZXIueixcclxuICAgICAgICAgICAgMCwgMCwgMCwgMVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHRoaXMuYXBwbHlNYXRyaXgoIG1hdHJpeCApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvbXB1dGVGYWNlTm9ybWFsczogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgY2IgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCBhYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XHJcblxyXG4gICAgICAgICAgICB2YXIgdkEgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmEgXTtcclxuICAgICAgICAgICAgdmFyIHZCID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5iIF07XHJcbiAgICAgICAgICAgIHZhciB2QyA9IHRoaXMudmVydGljZXNbIGZhY2UuYyBdO1xyXG5cclxuICAgICAgICAgICAgY2Iuc3ViVmVjdG9ycyggdkMsIHZCICk7XHJcbiAgICAgICAgICAgIGFiLnN1YlZlY3RvcnMoIHZBLCB2QiApO1xyXG4gICAgICAgICAgICBjYi5jcm9zcyggYWIgKTtcclxuXHJcbiAgICAgICAgICAgIGNiLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICAgICAgZmFjZS5ub3JtYWwuY29weSggY2IgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29tcHV0ZVZlcnRleE5vcm1hbHM6IGZ1bmN0aW9uICggYXJlYVdlaWdodGVkICkge1xyXG5cclxuICAgICAgICB2YXIgdiwgdmwsIGYsIGZsLCBmYWNlLCB2ZXJ0aWNlcztcclxuXHJcbiAgICAgICAgdmVydGljZXMgPSBuZXcgQXJyYXkoIHRoaXMudmVydGljZXMubGVuZ3RoICk7XHJcblxyXG4gICAgICAgIGZvciAoIHYgPSAwLCB2bCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2ZXJ0aWNlc1sgdiBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIGFyZWFXZWlnaHRlZCApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIHZlcnRleCBub3JtYWxzIHdlaWdodGVkIGJ5IHRyaWFuZ2xlIGFyZWFzXHJcbiAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cuaXF1aWxlemxlcy5vcmcvd3d3L2FydGljbGVzL25vcm1hbHMvbm9ybWFscy5odG1cclxuXHJcbiAgICAgICAgICAgIHZhciB2QSwgdkIsIHZDO1xyXG4gICAgICAgICAgICB2YXIgY2IgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCBhYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XHJcblxyXG4gICAgICAgICAgICAgICAgdkEgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmEgXTtcclxuICAgICAgICAgICAgICAgIHZCID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5iIF07XHJcbiAgICAgICAgICAgICAgICB2QyA9IHRoaXMudmVydGljZXNbIGZhY2UuYyBdO1xyXG5cclxuICAgICAgICAgICAgICAgIGNiLnN1YlZlY3RvcnMoIHZDLCB2QiApO1xyXG4gICAgICAgICAgICAgICAgYWIuc3ViVmVjdG9ycyggdkEsIHZCICk7XHJcbiAgICAgICAgICAgICAgICBjYi5jcm9zcyggYWIgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1sgZmFjZS5hIF0uYWRkKCBjYiApO1xyXG4gICAgICAgICAgICAgICAgdmVydGljZXNbIGZhY2UuYiBdLmFkZCggY2IgKTtcclxuICAgICAgICAgICAgICAgIHZlcnRpY2VzWyBmYWNlLmMgXS5hZGQoIGNiICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XHJcblxyXG4gICAgICAgICAgICAgICAgdmVydGljZXNbIGZhY2UuYSBdLmFkZCggZmFjZS5ub3JtYWwgKTtcclxuICAgICAgICAgICAgICAgIHZlcnRpY2VzWyBmYWNlLmIgXS5hZGQoIGZhY2Uubm9ybWFsICk7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1sgZmFjZS5jIF0uYWRkKCBmYWNlLm5vcm1hbCApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoIHYgPSAwLCB2bCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2ZXJ0aWNlc1sgdiBdLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG4gICAgICAgICAgICBmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xyXG5cclxuICAgICAgICAgICAgdmFyIHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHZlcnRleE5vcm1hbHMubGVuZ3RoID09PSAzICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZlcnRleE5vcm1hbHNbIDAgXS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5hIF0gKTtcclxuICAgICAgICAgICAgICAgIHZlcnRleE5vcm1hbHNbIDEgXS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5iIF0gKTtcclxuICAgICAgICAgICAgICAgIHZlcnRleE5vcm1hbHNbIDIgXS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5jIF0gKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmVydGV4Tm9ybWFsc1sgMCBdID0gdmVydGljZXNbIGZhY2UuYSBdLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhOb3JtYWxzWyAxIF0gPSB2ZXJ0aWNlc1sgZmFjZS5iIF0uY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgIHZlcnRleE5vcm1hbHNbIDIgXSA9IHZlcnRpY2VzWyBmYWNlLmMgXS5jbG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb21wdXRlTW9ycGhOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBpLCBpbCwgZiwgZmwsIGZhY2U7XHJcblxyXG4gICAgICAgIC8vIHNhdmUgb3JpZ2luYWwgbm9ybWFsc1xyXG4gICAgICAgIC8vIC0gY3JlYXRlIHRlbXAgdmFyaWFibGVzIG9uIGZpcnN0IGFjY2Vzc1xyXG4gICAgICAgIC8vICAgb3RoZXJ3aXNlIGp1c3QgY29weSAoZm9yIGZhc3RlciByZXBlYXRlZCBjYWxscylcclxuXHJcbiAgICAgICAgZm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcbiAgICAgICAgICAgIGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XHJcblxyXG4gICAgICAgICAgICBpZiAoICEgZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsID0gZmFjZS5ub3JtYWwuY2xvbmUoKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbC5jb3B5KCBmYWNlLm5vcm1hbCApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCAhIGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHMgKSBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzID0gW107XHJcblxyXG4gICAgICAgICAgICBmb3IgKCBpID0gMCwgaWwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCAhIGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbIGkgXSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFsc1sgaSBdID0gZmFjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0uY2xvbmUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzWyBpIF0uY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0gKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdXNlIHRlbXAgZ2VvbWV0cnkgdG8gY29tcHV0ZSBmYWNlIGFuZCB2ZXJ0ZXggbm9ybWFscyBmb3IgZWFjaCBtb3JwaFxyXG5cclxuICAgICAgICB2YXIgdG1wR2VvID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcbiAgICAgICAgdG1wR2VvLmZhY2VzID0gdGhpcy5mYWNlcztcclxuXHJcbiAgICAgICAgZm9yICggaSA9IDAsIGlsID0gdGhpcy5tb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBjcmVhdGUgb24gZmlyc3QgYWNjZXNzXHJcblxyXG4gICAgICAgICAgICBpZiAoICEgdGhpcy5tb3JwaE5vcm1hbHNbIGkgXSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdID0ge307XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLmZhY2VOb3JtYWxzID0gW107XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLnZlcnRleE5vcm1hbHMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZHN0Tm9ybWFsc0ZhY2UgPSB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLmZhY2VOb3JtYWxzO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRzdE5vcm1hbHNWZXJ0ZXggPSB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLnZlcnRleE5vcm1hbHM7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGZhY2VOb3JtYWwsIHZlcnRleE5vcm1hbHM7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZmFjZU5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4Tm9ybWFscyA9IHsgYTogbmV3IFRIUkVFLlZlY3RvcjMoKSwgYjogbmV3IFRIUkVFLlZlY3RvcjMoKSwgYzogbmV3IFRIUkVFLlZlY3RvcjMoKSB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBkc3ROb3JtYWxzRmFjZS5wdXNoKCBmYWNlTm9ybWFsICk7XHJcbiAgICAgICAgICAgICAgICAgICAgZHN0Tm9ybWFsc1ZlcnRleC5wdXNoKCB2ZXJ0ZXhOb3JtYWxzICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIG1vcnBoTm9ybWFscyA9IHRoaXMubW9ycGhOb3JtYWxzWyBpIF07XHJcblxyXG4gICAgICAgICAgICAvLyBzZXQgdmVydGljZXMgdG8gbW9ycGggdGFyZ2V0XHJcblxyXG4gICAgICAgICAgICB0bXBHZW8udmVydGljZXMgPSB0aGlzLm1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzO1xyXG5cclxuICAgICAgICAgICAgLy8gY29tcHV0ZSBtb3JwaCBub3JtYWxzXHJcblxyXG4gICAgICAgICAgICB0bXBHZW8uY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcbiAgICAgICAgICAgIHRtcEdlby5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xyXG5cclxuICAgICAgICAgICAgLy8gc3RvcmUgbW9ycGggbm9ybWFsc1xyXG5cclxuICAgICAgICAgICAgdmFyIGZhY2VOb3JtYWwsIHZlcnRleE5vcm1hbHM7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XHJcblxyXG4gICAgICAgICAgICAgICAgZmFjZU5vcm1hbCA9IG1vcnBoTm9ybWFscy5mYWNlTm9ybWFsc1sgZiBdO1xyXG4gICAgICAgICAgICAgICAgdmVydGV4Tm9ybWFscyA9IG1vcnBoTm9ybWFscy52ZXJ0ZXhOb3JtYWxzWyBmIF07XHJcblxyXG4gICAgICAgICAgICAgICAgZmFjZU5vcm1hbC5jb3B5KCBmYWNlLm5vcm1hbCApO1xyXG5cclxuICAgICAgICAgICAgICAgIHZlcnRleE5vcm1hbHMuYS5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDAgXSApO1xyXG4gICAgICAgICAgICAgICAgdmVydGV4Tm9ybWFscy5iLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgMSBdICk7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhOb3JtYWxzLmMuY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyAyIF0gKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyByZXN0b3JlIG9yaWdpbmFsIG5vcm1hbHNcclxuXHJcbiAgICAgICAgZm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcbiAgICAgICAgICAgIGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XHJcblxyXG4gICAgICAgICAgICBmYWNlLm5vcm1hbCA9IGZhY2UuX19vcmlnaW5hbEZhY2VOb3JtYWw7XHJcbiAgICAgICAgICAgIGZhY2UudmVydGV4Tm9ybWFscyA9IGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHM7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvbXB1dGVUYW5nZW50czogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5HZW9tZXRyeTogLmNvbXB1dGVUYW5nZW50cygpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29tcHV0ZUxpbmVEaXN0YW5jZXM6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIGQgPSAwO1xyXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggaSA+IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZCArPSB2ZXJ0aWNlc1sgaSBdLmRpc3RhbmNlVG8oIHZlcnRpY2VzWyBpIC0gMSBdICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmxpbmVEaXN0YW5jZXNbIGkgXSA9IGQ7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvbXB1dGVCb3VuZGluZ0JveDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94ID0gbmV3IFRIUkVFLkJveDMoKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnNldEZyb21Qb2ludHMoIHRoaXMudmVydGljZXMgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvbXB1dGVCb3VuZGluZ1NwaGVyZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSgpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUuc2V0RnJvbVBvaW50cyggdGhpcy52ZXJ0aWNlcyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbWVyZ2U6IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdHJpeCwgbWF0ZXJpYWxJbmRleE9mZnNldCApIHtcclxuXHJcbiAgICAgICAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ID09PSBmYWxzZSApIHtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5HZW9tZXRyeS5tZXJnZSgpOiBnZW9tZXRyeSBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuR2VvbWV0cnkuJywgZ2VvbWV0cnkgKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBub3JtYWxNYXRyaXgsXHJcbiAgICAgICAgICAgIHZlcnRleE9mZnNldCA9IHRoaXMudmVydGljZXMubGVuZ3RoLFxyXG4gICAgICAgICAgICB2ZXJ0aWNlczEgPSB0aGlzLnZlcnRpY2VzLFxyXG4gICAgICAgICAgICB2ZXJ0aWNlczIgPSBnZW9tZXRyeS52ZXJ0aWNlcyxcclxuICAgICAgICAgICAgZmFjZXMxID0gdGhpcy5mYWNlcyxcclxuICAgICAgICAgICAgZmFjZXMyID0gZ2VvbWV0cnkuZmFjZXMsXHJcbiAgICAgICAgICAgIHV2czEgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXSxcclxuICAgICAgICAgICAgdXZzMiA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIDAgXTtcclxuXHJcbiAgICAgICAgaWYgKCBtYXRlcmlhbEluZGV4T2Zmc2V0ID09PSB1bmRlZmluZWQgKSBtYXRlcmlhbEluZGV4T2Zmc2V0ID0gMDtcclxuXHJcbiAgICAgICAgaWYgKCBtYXRyaXggIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIG5vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB2ZXJ0aWNlc1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmVydGljZXMyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHZlcnRleCA9IHZlcnRpY2VzMlsgaSBdO1xyXG5cclxuICAgICAgICAgICAgdmFyIHZlcnRleENvcHkgPSB2ZXJ0ZXguY2xvbmUoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggbWF0cml4ICE9PSB1bmRlZmluZWQgKSB2ZXJ0ZXhDb3B5LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XHJcblxyXG4gICAgICAgICAgICB2ZXJ0aWNlczEucHVzaCggdmVydGV4Q29weSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGZhY2VzXHJcblxyXG4gICAgICAgIGZvciAoIGkgPSAwLCBpbCA9IGZhY2VzMi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBmYWNlID0gZmFjZXMyWyBpIF0sIGZhY2VDb3B5LCBub3JtYWwsIGNvbG9yLFxyXG4gICAgICAgICAgICAgICAgZmFjZVZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHMsXHJcbiAgICAgICAgICAgICAgICBmYWNlVmVydGV4Q29sb3JzID0gZmFjZS52ZXJ0ZXhDb2xvcnM7XHJcblxyXG4gICAgICAgICAgICBmYWNlQ29weSA9IG5ldyBUSFJFRS5GYWNlMyggZmFjZS5hICsgdmVydGV4T2Zmc2V0LCBmYWNlLmIgKyB2ZXJ0ZXhPZmZzZXQsIGZhY2UuYyArIHZlcnRleE9mZnNldCApO1xyXG4gICAgICAgICAgICBmYWNlQ29weS5ub3JtYWwuY29weSggZmFjZS5ub3JtYWwgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggbm9ybWFsTWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZmFjZUNvcHkubm9ybWFsLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZVZlcnRleE5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgbm9ybWFsID0gZmFjZVZlcnRleE5vcm1hbHNbIGogXS5jbG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggbm9ybWFsTWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmYWNlQ29weS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZmFjZUNvcHkuY29sb3IuY29weSggZmFjZS5jb2xvciApO1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2VWZXJ0ZXhDb2xvcnMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY29sb3IgPSBmYWNlVmVydGV4Q29sb3JzWyBqIF07XHJcbiAgICAgICAgICAgICAgICBmYWNlQ29weS52ZXJ0ZXhDb2xvcnMucHVzaCggY29sb3IuY2xvbmUoKSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZmFjZUNvcHkubWF0ZXJpYWxJbmRleCA9IGZhY2UubWF0ZXJpYWxJbmRleCArIG1hdGVyaWFsSW5kZXhPZmZzZXQ7XHJcblxyXG4gICAgICAgICAgICBmYWNlczEucHVzaCggZmFjZUNvcHkgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB1dnNcclxuXHJcbiAgICAgICAgZm9yICggaSA9IDAsIGlsID0gdXZzMi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciB1diA9IHV2czJbIGkgXSwgdXZDb3B5ID0gW107XHJcblxyXG4gICAgICAgICAgICBpZiAoIHV2ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gdXYubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdXZDb3B5LnB1c2goIHV2WyBqIF0uY2xvbmUoKSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdXZzMS5wdXNoKCB1dkNvcHkgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbWVyZ2VNZXNoOiBmdW5jdGlvbiAoIG1lc2ggKSB7XHJcblxyXG4gICAgICAgIGlmICggbWVzaCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggPT09IGZhbHNlICkge1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLkdlb21ldHJ5Lm1lcmdlTWVzaCgpOiBtZXNoIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5NZXNoLicsIG1lc2ggKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG1lc2gubWF0cml4QXV0b1VwZGF0ZSAmJiBtZXNoLnVwZGF0ZU1hdHJpeCgpO1xyXG5cclxuICAgICAgICB0aGlzLm1lcmdlKCBtZXNoLmdlb21ldHJ5LCBtZXNoLm1hdHJpeCApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLypcclxuICAgICAqIENoZWNrcyBmb3IgZHVwbGljYXRlIHZlcnRpY2VzIHdpdGggaGFzaG1hcC5cclxuICAgICAqIER1cGxpY2F0ZWQgdmVydGljZXMgYXJlIHJlbW92ZWRcclxuICAgICAqIGFuZCBmYWNlcycgdmVydGljZXMgYXJlIHVwZGF0ZWQuXHJcbiAgICAgKi9cclxuXHJcbiAgICBtZXJnZVZlcnRpY2VzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciB2ZXJ0aWNlc01hcCA9IHt9OyAvLyBIYXNobWFwIGZvciBsb29raW5nIHVwIHZlcnRpY2VzIGJ5IHBvc2l0aW9uIGNvb3JkaW5hdGVzIChhbmQgbWFraW5nIHN1cmUgdGhleSBhcmUgdW5pcXVlKVxyXG4gICAgICAgIHZhciB1bmlxdWUgPSBbXSwgY2hhbmdlcyA9IFtdO1xyXG5cclxuICAgICAgICB2YXIgdiwga2V5O1xyXG4gICAgICAgIHZhciBwcmVjaXNpb25Qb2ludHMgPSA0OyAvLyBudW1iZXIgb2YgZGVjaW1hbCBwb2ludHMsIGUuZy4gNCBmb3IgZXBzaWxvbiBvZiAwLjAwMDFcclxuICAgICAgICB2YXIgcHJlY2lzaW9uID0gTWF0aC5wb3coIDEwLCBwcmVjaXNpb25Qb2ludHMgKTtcclxuICAgICAgICB2YXIgaSwgaWwsIGZhY2U7XHJcbiAgICAgICAgdmFyIGluZGljZXMsIGosIGpsO1xyXG5cclxuICAgICAgICBmb3IgKCBpID0gMCwgaWwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdiA9IHRoaXMudmVydGljZXNbIGkgXTtcclxuICAgICAgICAgICAga2V5ID0gTWF0aC5yb3VuZCggdi54ICogcHJlY2lzaW9uICkgKyAnXycgKyBNYXRoLnJvdW5kKCB2LnkgKiBwcmVjaXNpb24gKSArICdfJyArIE1hdGgucm91bmQoIHYueiAqIHByZWNpc2lvbiApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCB2ZXJ0aWNlc01hcFsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc01hcFsga2V5IF0gPSBpO1xyXG4gICAgICAgICAgICAgICAgdW5pcXVlLnB1c2goIHRoaXMudmVydGljZXNbIGkgXSApO1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlc1sgaSBdID0gdW5pcXVlLmxlbmd0aCAtIDE7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ0R1cGxpY2F0ZSB2ZXJ0ZXggZm91bmQuICcsIGksICcgY291bGQgYmUgdXNpbmcgJywgdmVydGljZXNNYXBba2V5XSk7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VzWyBpIF0gPSBjaGFuZ2VzWyB2ZXJ0aWNlc01hcFsga2V5IF0gXTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLy8gaWYgZmFjZXMgYXJlIGNvbXBsZXRlbHkgZGVnZW5lcmF0ZSBhZnRlciBtZXJnaW5nIHZlcnRpY2VzLCB3ZVxyXG4gICAgICAgIC8vIGhhdmUgdG8gcmVtb3ZlIHRoZW0gZnJvbSB0aGUgZ2VvbWV0cnkuXHJcbiAgICAgICAgdmFyIGZhY2VJbmRpY2VzVG9SZW1vdmUgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICggaSA9IDAsIGlsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIGZhY2UgPSB0aGlzLmZhY2VzWyBpIF07XHJcblxyXG4gICAgICAgICAgICBmYWNlLmEgPSBjaGFuZ2VzWyBmYWNlLmEgXTtcclxuICAgICAgICAgICAgZmFjZS5iID0gY2hhbmdlc1sgZmFjZS5iIF07XHJcbiAgICAgICAgICAgIGZhY2UuYyA9IGNoYW5nZXNbIGZhY2UuYyBdO1xyXG5cclxuICAgICAgICAgICAgaW5kaWNlcyA9IFsgZmFjZS5hLCBmYWNlLmIsIGZhY2UuYyBdO1xyXG5cclxuICAgICAgICAgICAgdmFyIGR1cEluZGV4ID0gLSAxO1xyXG5cclxuICAgICAgICAgICAgLy8gaWYgYW55IGR1cGxpY2F0ZSB2ZXJ0aWNlcyBhcmUgZm91bmQgaW4gYSBGYWNlM1xyXG4gICAgICAgICAgICAvLyB3ZSBoYXZlIHRvIHJlbW92ZSB0aGUgZmFjZSBhcyBub3RoaW5nIGNhbiBiZSBzYXZlZFxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgbiA9IDA7IG4gPCAzOyBuICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggaW5kaWNlc1sgbiBdID09PSBpbmRpY2VzWyAoIG4gKyAxICkgJSAzIF0gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGR1cEluZGV4ID0gbjtcclxuICAgICAgICAgICAgICAgICAgICBmYWNlSW5kaWNlc1RvUmVtb3ZlLnB1c2goIGkgKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICggaSA9IGZhY2VJbmRpY2VzVG9SZW1vdmUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC0tICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGlkeCA9IGZhY2VJbmRpY2VzVG9SZW1vdmVbIGkgXTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZmFjZXMuc3BsaWNlKCBpZHgsIDEgKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIGogPSAwLCBqbCA9IHRoaXMuZmFjZVZlcnRleFV2cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIGogXS5zcGxpY2UoIGlkeCwgMSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVzZSB1bmlxdWUgc2V0IG9mIHZlcnRpY2VzXHJcblxyXG4gICAgICAgIHZhciBkaWZmID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSB1bmlxdWUubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMudmVydGljZXMgPSB1bmlxdWU7XHJcbiAgICAgICAgcmV0dXJuIGRpZmY7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzb3J0RmFjZXNCeU1hdGVyaWFsSW5kZXg6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIGZhY2VzID0gdGhpcy5mYWNlcztcclxuICAgICAgICB2YXIgbGVuZ3RoID0gZmFjZXMubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyB0YWcgZmFjZXNcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgZmFjZXNbIGkgXS5faWQgPSBpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHNvcnQgZmFjZXNcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbWF0ZXJpYWxJbmRleFNvcnQoIGEsIGIgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYS5tYXRlcmlhbEluZGV4IC0gYi5tYXRlcmlhbEluZGV4O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZhY2VzLnNvcnQoIG1hdGVyaWFsSW5kZXhTb3J0ICk7XHJcblxyXG4gICAgICAgIC8vIHNvcnQgdXZzXHJcblxyXG4gICAgICAgIHZhciB1dnMxID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF07XHJcbiAgICAgICAgdmFyIHV2czIgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDEgXTtcclxuXHJcbiAgICAgICAgdmFyIG5ld1V2czEsIG5ld1V2czI7XHJcblxyXG4gICAgICAgIGlmICggdXZzMSAmJiB1dnMxLmxlbmd0aCA9PT0gbGVuZ3RoICkgbmV3VXZzMSA9IFtdO1xyXG4gICAgICAgIGlmICggdXZzMiAmJiB1dnMyLmxlbmd0aCA9PT0gbGVuZ3RoICkgbmV3VXZzMiA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgaWQgPSBmYWNlc1sgaSBdLl9pZDtcclxuXHJcbiAgICAgICAgICAgIGlmICggbmV3VXZzMSApIG5ld1V2czEucHVzaCggdXZzMVsgaWQgXSApO1xyXG4gICAgICAgICAgICBpZiAoIG5ld1V2czIgKSBuZXdVdnMyLnB1c2goIHV2czJbIGlkIF0gKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIG5ld1V2czEgKSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXSA9IG5ld1V2czE7XHJcbiAgICAgICAgaWYgKCBuZXdVdnMyICkgdGhpcy5mYWNlVmVydGV4VXZzWyAxIF0gPSBuZXdVdnMyO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBkYXRhID0ge1xyXG4gICAgICAgICAgICBtZXRhZGF0YToge1xyXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogNC40LFxyXG4gICAgICAgICAgICAgICAgdHlwZTogJ0dlb21ldHJ5JyxcclxuICAgICAgICAgICAgICAgIGdlbmVyYXRvcjogJ0dlb21ldHJ5LnRvSlNPTidcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIHN0YW5kYXJkIEdlb21ldHJ5IHNlcmlhbGl6YXRpb25cclxuXHJcbiAgICAgICAgZGF0YS51dWlkID0gdGhpcy51dWlkO1xyXG4gICAgICAgIGRhdGEudHlwZSA9IHRoaXMudHlwZTtcclxuICAgICAgICBpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBkYXRhLm5hbWUgPSB0aGlzLm5hbWU7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5wYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBrZXkgaW4gcGFyYW1ldGVycyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHBhcmFtZXRlcnNbIGtleSBdICE9PSB1bmRlZmluZWQgKSBkYXRhWyBrZXkgXSA9IHBhcmFtZXRlcnNbIGtleSBdO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gW107XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHZlcnRleCA9IHRoaXMudmVydGljZXNbIGkgXTtcclxuICAgICAgICAgICAgdmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBmYWNlcyA9IFtdO1xyXG4gICAgICAgIHZhciBub3JtYWxzID0gW107XHJcbiAgICAgICAgdmFyIG5vcm1hbHNIYXNoID0ge307XHJcbiAgICAgICAgdmFyIGNvbG9ycyA9IFtdO1xyXG4gICAgICAgIHZhciBjb2xvcnNIYXNoID0ge307XHJcbiAgICAgICAgdmFyIHV2cyA9IFtdO1xyXG4gICAgICAgIHZhciB1dnNIYXNoID0ge307XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuZmFjZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGZhY2UgPSB0aGlzLmZhY2VzWyBpIF07XHJcblxyXG4gICAgICAgICAgICB2YXIgaGFzTWF0ZXJpYWwgPSBmYWxzZTsgLy8gZmFjZS5tYXRlcmlhbEluZGV4ICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHZhciBoYXNGYWNlVXYgPSBmYWxzZTsgLy8gZGVwcmVjYXRlZFxyXG4gICAgICAgICAgICB2YXIgaGFzRmFjZVZlcnRleFV2ID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF1bIGkgXSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB2YXIgaGFzRmFjZU5vcm1hbCA9IGZhY2Uubm9ybWFsLmxlbmd0aCgpID4gMDtcclxuICAgICAgICAgICAgdmFyIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoID4gMDtcclxuICAgICAgICAgICAgdmFyIGhhc0ZhY2VDb2xvciA9IGZhY2UuY29sb3IuciAhPT0gMSB8fCBmYWNlLmNvbG9yLmcgIT09IDEgfHwgZmFjZS5jb2xvci5iICE9PSAxO1xyXG4gICAgICAgICAgICB2YXIgaGFzRmFjZVZlcnRleENvbG9yID0gZmFjZS52ZXJ0ZXhDb2xvcnMubGVuZ3RoID4gMDtcclxuXHJcbiAgICAgICAgICAgIHZhciBmYWNlVHlwZSA9IDA7XHJcblxyXG4gICAgICAgICAgICBmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDAsIDAgKTtcclxuICAgICAgICAgICAgZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAxLCBoYXNNYXRlcmlhbCApO1xyXG4gICAgICAgICAgICBmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDIsIGhhc0ZhY2VVdiApO1xyXG4gICAgICAgICAgICBmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDMsIGhhc0ZhY2VWZXJ0ZXhVdiApO1xyXG4gICAgICAgICAgICBmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDQsIGhhc0ZhY2VOb3JtYWwgKTtcclxuICAgICAgICAgICAgZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA1LCBoYXNGYWNlVmVydGV4Tm9ybWFsICk7XHJcbiAgICAgICAgICAgIGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgNiwgaGFzRmFjZUNvbG9yICk7XHJcbiAgICAgICAgICAgIGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgNywgaGFzRmFjZVZlcnRleENvbG9yICk7XHJcblxyXG4gICAgICAgICAgICBmYWNlcy5wdXNoKCBmYWNlVHlwZSApO1xyXG4gICAgICAgICAgICBmYWNlcy5wdXNoKCBmYWNlLmEsIGZhY2UuYiwgZmFjZS5jICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZmFjZVZlcnRleFV2cyA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdWyBpIF07XHJcblxyXG4gICAgICAgICAgICAgICAgZmFjZXMucHVzaChcclxuICAgICAgICAgICAgICAgICAgICBnZXRVdkluZGV4KCBmYWNlVmVydGV4VXZzWyAwIF0gKSxcclxuICAgICAgICAgICAgICAgICAgICBnZXRVdkluZGV4KCBmYWNlVmVydGV4VXZzWyAxIF0gKSxcclxuICAgICAgICAgICAgICAgICAgICBnZXRVdkluZGV4KCBmYWNlVmVydGV4VXZzWyAyIF0gKVxyXG4gICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggaGFzRmFjZU5vcm1hbCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBmYWNlcy5wdXNoKCBnZXROb3JtYWxJbmRleCggZmFjZS5ub3JtYWwgKSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBoYXNGYWNlVmVydGV4Tm9ybWFsICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXhOb3JtYWxzID0gZmFjZS52ZXJ0ZXhOb3JtYWxzO1xyXG5cclxuICAgICAgICAgICAgICAgIGZhY2VzLnB1c2goXHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0Tm9ybWFsSW5kZXgoIHZlcnRleE5vcm1hbHNbIDAgXSApLFxyXG4gICAgICAgICAgICAgICAgICAgIGdldE5vcm1hbEluZGV4KCB2ZXJ0ZXhOb3JtYWxzWyAxIF0gKSxcclxuICAgICAgICAgICAgICAgICAgICBnZXROb3JtYWxJbmRleCggdmVydGV4Tm9ybWFsc1sgMiBdIClcclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIGhhc0ZhY2VDb2xvciApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBmYWNlcy5wdXNoKCBnZXRDb2xvckluZGV4KCBmYWNlLmNvbG9yICkgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggaGFzRmFjZVZlcnRleENvbG9yICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXhDb2xvcnMgPSBmYWNlLnZlcnRleENvbG9ycztcclxuXHJcbiAgICAgICAgICAgICAgICBmYWNlcy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgICAgIGdldENvbG9ySW5kZXgoIHZlcnRleENvbG9yc1sgMCBdICksXHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q29sb3JJbmRleCggdmVydGV4Q29sb3JzWyAxIF0gKSxcclxuICAgICAgICAgICAgICAgICAgICBnZXRDb2xvckluZGV4KCB2ZXJ0ZXhDb2xvcnNbIDIgXSApXHJcbiAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHNldEJpdCggdmFsdWUsIHBvc2l0aW9uLCBlbmFibGVkICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGVuYWJsZWQgPyB2YWx1ZSB8ICggMSA8PCBwb3NpdGlvbiApIDogdmFsdWUgJiAoIH4gKCAxIDw8IHBvc2l0aW9uICkgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBnZXROb3JtYWxJbmRleCggbm9ybWFsICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGhhc2ggPSBub3JtYWwueC50b1N0cmluZygpICsgbm9ybWFsLnkudG9TdHJpbmcoKSArIG5vcm1hbC56LnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG5vcm1hbHNIYXNoWyBoYXNoIF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsc0hhc2hbIGhhc2ggXTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG5vcm1hbHNIYXNoWyBoYXNoIF0gPSBub3JtYWxzLmxlbmd0aCAvIDM7XHJcbiAgICAgICAgICAgIG5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbHNIYXNoWyBoYXNoIF07XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0Q29sb3JJbmRleCggY29sb3IgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgaGFzaCA9IGNvbG9yLnIudG9TdHJpbmcoKSArIGNvbG9yLmcudG9TdHJpbmcoKSArIGNvbG9yLmIudG9TdHJpbmcoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggY29sb3JzSGFzaFsgaGFzaCBdICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yc0hhc2hbIGhhc2ggXTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbG9yc0hhc2hbIGhhc2ggXSA9IGNvbG9ycy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbG9ycy5wdXNoKCBjb2xvci5nZXRIZXgoKSApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNvbG9yc0hhc2hbIGhhc2ggXTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBnZXRVdkluZGV4KCB1diApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBoYXNoID0gdXYueC50b1N0cmluZygpICsgdXYueS50b1N0cmluZygpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCB1dnNIYXNoWyBoYXNoIF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXZzSGFzaFsgaGFzaCBdO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdXZzSGFzaFsgaGFzaCBdID0gdXZzLmxlbmd0aCAvIDI7XHJcbiAgICAgICAgICAgIHV2cy5wdXNoKCB1di54LCB1di55ICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdXZzSGFzaFsgaGFzaCBdO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRhdGEuZGF0YSA9IHt9O1xyXG5cclxuICAgICAgICBkYXRhLmRhdGEudmVydGljZXMgPSB2ZXJ0aWNlcztcclxuICAgICAgICBkYXRhLmRhdGEubm9ybWFscyA9IG5vcm1hbHM7XHJcbiAgICAgICAgaWYgKCBjb2xvcnMubGVuZ3RoID4gMCApIGRhdGEuZGF0YS5jb2xvcnMgPSBjb2xvcnM7XHJcbiAgICAgICAgaWYgKCB1dnMubGVuZ3RoID4gMCApIGRhdGEuZGF0YS51dnMgPSBbIHV2cyBdOyAvLyB0ZW1wb3JhbCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XHJcbiAgICAgICAgZGF0YS5kYXRhLmZhY2VzID0gZmFjZXM7XHJcblxyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG4gICAgICAgIHRoaXMudmVydGljZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmZhY2VzID0gW107XHJcbiAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzID0gWyBbXSBdO1xyXG5cclxuICAgICAgICB2YXIgdmVydGljZXMgPSBzb3VyY2UudmVydGljZXM7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudmVydGljZXMucHVzaCggdmVydGljZXNbIGkgXS5jbG9uZSgpICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGZhY2VzID0gc291cmNlLmZhY2VzO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gZmFjZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmZhY2VzLnB1c2goIGZhY2VzWyBpIF0uY2xvbmUoKSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBzb3VyY2UuZmFjZVZlcnRleFV2cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBmYWNlVmVydGV4VXZzID0gc291cmNlLmZhY2VWZXJ0ZXhVdnNbIGkgXTtcclxuXHJcbiAgICAgICAgICAgIGlmICggdGhpcy5mYWNlVmVydGV4VXZzWyBpIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIGkgXSA9IFtdO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2VWZXJ0ZXhVdnMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHV2cyA9IGZhY2VWZXJ0ZXhVdnNbIGogXSwgdXZzQ29weSA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBrID0gMCwga2wgPSB1dnMubGVuZ3RoOyBrIDwga2w7IGsgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1diA9IHV2c1sgayBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB1dnNDb3B5LnB1c2goIHV2LmNsb25lKCkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyBpIF0ucHVzaCggdXZzQ29weSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5HZW9tZXRyeUlkQ291bnQgPSAwO1xyXG5cclxuLy8gRmlsZTpzcmMvY29yZS9EaXJlY3RHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuRGlyZWN0R2VvbWV0cnkgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBUSFJFRS5HZW9tZXRyeUlkQ291bnQgKysgfSApO1xyXG5cclxuICAgIHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XHJcblxyXG4gICAgdGhpcy5uYW1lID0gJyc7XHJcbiAgICB0aGlzLnR5cGUgPSAnRGlyZWN0R2VvbWV0cnknO1xyXG5cclxuICAgIHRoaXMuaW5kaWNlcyA9IFtdO1xyXG4gICAgdGhpcy52ZXJ0aWNlcyA9IFtdO1xyXG4gICAgdGhpcy5ub3JtYWxzID0gW107XHJcbiAgICB0aGlzLmNvbG9ycyA9IFtdO1xyXG4gICAgdGhpcy51dnMgPSBbXTtcclxuICAgIHRoaXMudXZzMiA9IFtdO1xyXG5cclxuICAgIHRoaXMuZ3JvdXBzID0gW107XHJcblxyXG4gICAgdGhpcy5tb3JwaFRhcmdldHMgPSB7fTtcclxuXHJcbiAgICB0aGlzLnNraW5XZWlnaHRzID0gW107XHJcbiAgICB0aGlzLnNraW5JbmRpY2VzID0gW107XHJcblxyXG4gICAgLy8gdGhpcy5saW5lRGlzdGFuY2VzID0gW107XHJcblxyXG4gICAgdGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XHJcbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcclxuXHJcbiAgICAvLyB1cGRhdGUgZmxhZ3NcclxuXHJcbiAgICB0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XHJcbiAgICB0aGlzLnV2c05lZWRVcGRhdGUgPSBmYWxzZTtcclxuICAgIHRoaXMuZ3JvdXBzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkRpcmVjdEdlb21ldHJ5LnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuRGlyZWN0R2VvbWV0cnksXHJcblxyXG4gICAgY29tcHV0ZUJvdW5kaW5nQm94OiBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUuY29tcHV0ZUJvdW5kaW5nQm94LFxyXG4gICAgY29tcHV0ZUJvdW5kaW5nU3BoZXJlOiBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUuY29tcHV0ZUJvdW5kaW5nU3BoZXJlLFxyXG5cclxuICAgIGNvbXB1dGVGYWNlTm9ybWFsczogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5EaXJlY3RHZW9tZXRyeTogY29tcHV0ZUZhY2VOb3JtYWxzKCkgaXMgbm90IGEgbWV0aG9kIG9mIHRoaXMgdHlwZSBvZiBnZW9tZXRyeS4nICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb21wdXRlVmVydGV4Tm9ybWFsczogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5EaXJlY3RHZW9tZXRyeTogY29tcHV0ZVZlcnRleE5vcm1hbHMoKSBpcyBub3QgYSBtZXRob2Qgb2YgdGhpcyB0eXBlIG9mIGdlb21ldHJ5LicgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvbXB1dGVHcm91cHM6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XHJcblxyXG4gICAgICAgIHZhciBncm91cDtcclxuICAgICAgICB2YXIgZ3JvdXBzID0gW107XHJcbiAgICAgICAgdmFyIG1hdGVyaWFsSW5kZXg7XHJcblxyXG4gICAgICAgIHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBmYWNlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgZmFjZSA9IGZhY2VzWyBpIF07XHJcblxyXG4gICAgICAgICAgICAvLyBtYXRlcmlhbHNcclxuXHJcbiAgICAgICAgICAgIGlmICggZmFjZS5tYXRlcmlhbEluZGV4ICE9PSBtYXRlcmlhbEluZGV4ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIG1hdGVyaWFsSW5kZXggPSBmYWNlLm1hdGVyaWFsSW5kZXg7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBncm91cCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBncm91cC5jb3VudCA9ICggaSAqIDMgKSAtIGdyb3VwLnN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIGdyb3Vwcy5wdXNoKCBncm91cCApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBncm91cCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydDogaSAqIDMsXHJcbiAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxJbmRleDogbWF0ZXJpYWxJbmRleFxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIGdyb3VwICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBncm91cC5jb3VudCA9ICggaSAqIDMgKSAtIGdyb3VwLnN0YXJ0O1xyXG4gICAgICAgICAgICBncm91cHMucHVzaCggZ3JvdXAgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmdyb3VwcyA9IGdyb3VwcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGZyb21HZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcclxuXHJcbiAgICAgICAgdmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XHJcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XHJcbiAgICAgICAgdmFyIGZhY2VWZXJ0ZXhVdnMgPSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzO1xyXG5cclxuICAgICAgICB2YXIgaGFzRmFjZVZlcnRleFV2ID0gZmFjZVZlcnRleFV2c1sgMCBdICYmIGZhY2VWZXJ0ZXhVdnNbIDAgXS5sZW5ndGggPiAwO1xyXG4gICAgICAgIHZhciBoYXNGYWNlVmVydGV4VXYyID0gZmFjZVZlcnRleFV2c1sgMSBdICYmIGZhY2VWZXJ0ZXhVdnNbIDEgXS5sZW5ndGggPiAwO1xyXG5cclxuICAgICAgICAvLyBtb3JwaHNcclxuXHJcbiAgICAgICAgdmFyIG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cztcclxuICAgICAgICB2YXIgbW9ycGhUYXJnZXRzTGVuZ3RoID0gbW9ycGhUYXJnZXRzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgaWYgKCBtb3JwaFRhcmdldHNMZW5ndGggPiAwICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIG1vcnBoVGFyZ2V0c1Bvc2l0aW9uID0gW107XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBtb3JwaFRhcmdldHNMZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgbW9ycGhUYXJnZXRzUG9zaXRpb25bIGkgXSA9IFtdO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5tb3JwaFRhcmdldHMucG9zaXRpb24gPSBtb3JwaFRhcmdldHNQb3NpdGlvbjtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbW9ycGhOb3JtYWxzID0gZ2VvbWV0cnkubW9ycGhOb3JtYWxzO1xyXG4gICAgICAgIHZhciBtb3JwaE5vcm1hbHNMZW5ndGggPSBtb3JwaE5vcm1hbHMubGVuZ3RoO1xyXG5cclxuICAgICAgICBpZiAoIG1vcnBoTm9ybWFsc0xlbmd0aCA+IDAgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbW9ycGhUYXJnZXRzTm9ybWFsID0gW107XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBtb3JwaE5vcm1hbHNMZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgbW9ycGhUYXJnZXRzTm9ybWFsWyBpIF0gPSBbXTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMubW9ycGhUYXJnZXRzLm5vcm1hbCA9IG1vcnBoVGFyZ2V0c05vcm1hbDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBza2luc1xyXG5cclxuICAgICAgICB2YXIgc2tpbkluZGljZXMgPSBnZW9tZXRyeS5za2luSW5kaWNlcztcclxuICAgICAgICB2YXIgc2tpbldlaWdodHMgPSBnZW9tZXRyeS5za2luV2VpZ2h0cztcclxuXHJcbiAgICAgICAgdmFyIGhhc1NraW5JbmRpY2VzID0gc2tpbkluZGljZXMubGVuZ3RoID09PSB2ZXJ0aWNlcy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGhhc1NraW5XZWlnaHRzID0gc2tpbldlaWdodHMubGVuZ3RoID09PSB2ZXJ0aWNlcy5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vXHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGZhY2VzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBmYWNlID0gZmFjZXNbIGkgXTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudmVydGljZXMucHVzaCggdmVydGljZXNbIGZhY2UuYSBdLCB2ZXJ0aWNlc1sgZmFjZS5iIF0sIHZlcnRpY2VzWyBmYWNlLmMgXSApO1xyXG5cclxuICAgICAgICAgICAgdmFyIHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHZlcnRleE5vcm1hbHMubGVuZ3RoID09PSAzICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMubm9ybWFscy5wdXNoKCB2ZXJ0ZXhOb3JtYWxzWyAwIF0sIHZlcnRleE5vcm1hbHNbIDEgXSwgdmVydGV4Tm9ybWFsc1sgMiBdICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBub3JtYWwgPSBmYWNlLm5vcm1hbDtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vcm1hbHMucHVzaCggbm9ybWFsLCBub3JtYWwsIG5vcm1hbCApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHZlcnRleENvbG9ycyA9IGZhY2UudmVydGV4Q29sb3JzO1xyXG5cclxuICAgICAgICAgICAgaWYgKCB2ZXJ0ZXhDb2xvcnMubGVuZ3RoID09PSAzICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuY29sb3JzLnB1c2goIHZlcnRleENvbG9yc1sgMCBdLCB2ZXJ0ZXhDb2xvcnNbIDEgXSwgdmVydGV4Q29sb3JzWyAyIF0gKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gZmFjZS5jb2xvcjtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbG9ycy5wdXNoKCBjb2xvciwgY29sb3IsIGNvbG9yICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiA9PT0gdHJ1ZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdmVydGV4VXZzID0gZmFjZVZlcnRleFV2c1sgMCBdWyBpIF07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCB2ZXJ0ZXhVdnMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51dnMucHVzaCggdmVydGV4VXZzWyAwIF0sIHZlcnRleFV2c1sgMSBdLCB2ZXJ0ZXhVdnNbIDIgXSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkRpcmVjdEdlb21ldHJ5LmZyb21HZW9tZXRyeSgpOiBVbmRlZmluZWQgdmVydGV4VXYgJywgaSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnV2cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMigpLCBuZXcgVEhSRUUuVmVjdG9yMigpLCBuZXcgVEhSRUUuVmVjdG9yMigpICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBoYXNGYWNlVmVydGV4VXYyID09PSB0cnVlICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXhVdnMgPSBmYWNlVmVydGV4VXZzWyAxIF1bIGkgXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHZlcnRleFV2cyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnV2czIucHVzaCggdmVydGV4VXZzWyAwIF0sIHZlcnRleFV2c1sgMSBdLCB2ZXJ0ZXhVdnNbIDIgXSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkRpcmVjdEdlb21ldHJ5LmZyb21HZW9tZXRyeSgpOiBVbmRlZmluZWQgdmVydGV4VXYyICcsIGkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51dnMyLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCksIG5ldyBUSFJFRS5WZWN0b3IyKCksIG5ldyBUSFJFRS5WZWN0b3IyKCkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBtb3JwaHNcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IG1vcnBoVGFyZ2V0c0xlbmd0aDsgaiArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbW9ycGhUYXJnZXQgPSBtb3JwaFRhcmdldHNbIGogXS52ZXJ0aWNlcztcclxuXHJcbiAgICAgICAgICAgICAgICBtb3JwaFRhcmdldHNQb3NpdGlvblsgaiBdLnB1c2goIG1vcnBoVGFyZ2V0WyBmYWNlLmEgXSwgbW9ycGhUYXJnZXRbIGZhY2UuYiBdLCBtb3JwaFRhcmdldFsgZmFjZS5jIF0gKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IG1vcnBoTm9ybWFsc0xlbmd0aDsgaiArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbW9ycGhOb3JtYWwgPSBtb3JwaE5vcm1hbHNbIGogXS52ZXJ0ZXhOb3JtYWxzWyBpIF07XHJcblxyXG4gICAgICAgICAgICAgICAgbW9ycGhUYXJnZXRzTm9ybWFsWyBqIF0ucHVzaCggbW9ycGhOb3JtYWwuYSwgbW9ycGhOb3JtYWwuYiwgbW9ycGhOb3JtYWwuYyApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gc2tpbnNcclxuXHJcbiAgICAgICAgICAgIGlmICggaGFzU2tpbkluZGljZXMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5za2luSW5kaWNlcy5wdXNoKCBza2luSW5kaWNlc1sgZmFjZS5hIF0sIHNraW5JbmRpY2VzWyBmYWNlLmIgXSwgc2tpbkluZGljZXNbIGZhY2UuYyBdICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIGhhc1NraW5XZWlnaHRzICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuc2tpbldlaWdodHMucHVzaCggc2tpbldlaWdodHNbIGZhY2UuYSBdLCBza2luV2VpZ2h0c1sgZmFjZS5iIF0sIHNraW5XZWlnaHRzWyBmYWNlLmMgXSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY29tcHV0ZUdyb3VwcyggZ2VvbWV0cnkgKTtcclxuXHJcbiAgICAgICAgdGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGU7XHJcbiAgICAgICAgdGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlO1xyXG4gICAgICAgIHRoaXMuY29sb3JzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGU7XHJcbiAgICAgICAgdGhpcy51dnNOZWVkVXBkYXRlID0gZ2VvbWV0cnkudXZzTmVlZFVwZGF0ZTtcclxuICAgICAgICB0aGlzLmdyb3Vwc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLkRpcmVjdEdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cclxuLy8gRmlsZTpzcmMvY29yZS9CdWZmZXJHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQnVmZmVyR2VvbWV0cnkgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBUSFJFRS5HZW9tZXRyeUlkQ291bnQgKysgfSApO1xyXG5cclxuICAgIHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XHJcblxyXG4gICAgdGhpcy5uYW1lID0gJyc7XHJcbiAgICB0aGlzLnR5cGUgPSAnQnVmZmVyR2VvbWV0cnknO1xyXG5cclxuICAgIHRoaXMuaW5kZXggPSBudWxsO1xyXG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XHJcblxyXG4gICAgdGhpcy5tb3JwaEF0dHJpYnV0ZXMgPSB7fTtcclxuXHJcbiAgICB0aGlzLmdyb3VwcyA9IFtdO1xyXG5cclxuICAgIHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xyXG4gICAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5kcmF3UmFuZ2UgPSB7IHN0YXJ0OiAwLCBjb3VudDogSW5maW5pdHkgfTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkJ1ZmZlckdlb21ldHJ5LFxyXG5cclxuICAgIGFkZEluZGV4OiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZEluZGV4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0SW5kZXgoKS4nICk7XHJcbiAgICAgICAgdGhpcy5zZXRJbmRleCggaW5kZXggKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldEluZGV4OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0SW5kZXg6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFkZEF0dHJpYnV0ZTogZnVuY3Rpb24gKCBuYW1lLCBhdHRyaWJ1dGUgKSB7XHJcblxyXG4gICAgICAgIGlmICggYXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyQXR0cmlidXRlID09PSBmYWxzZSAmJiBhdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSA9PT0gZmFsc2UgKSB7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZEF0dHJpYnV0ZSgpIG5vdyBleHBlY3RzICggbmFtZSwgYXR0cmlidXRlICkuJyApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoIG5hbWUsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGFyZ3VtZW50c1sgMSBdLCBhcmd1bWVudHNbIDIgXSApICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBuYW1lID09PSAnaW5kZXgnICkge1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkuYWRkQXR0cmlidXRlOiBVc2UgLnNldEluZGV4KCkgZm9yIGluZGV4IGF0dHJpYnV0ZS4nICk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0SW5kZXgoIGF0dHJpYnV0ZSApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdID0gYXR0cmlidXRlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0QXR0cmlidXRlOiBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZUF0dHJpYnV0ZTogZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuICAgICAgICBkZWxldGUgdGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF07XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXQgZHJhd2NhbGxzKCkge1xyXG5cclxuICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5kcmF3Y2FsbHMgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ3JvdXBzLicgKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5ncm91cHM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXQgb2Zmc2V0cygpIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5vZmZzZXRzIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdyb3Vwcy4nICk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYWRkRHJhd0NhbGw6IGZ1bmN0aW9uICggc3RhcnQsIGNvdW50LCBpbmRleE9mZnNldCApIHtcclxuXHJcbiAgICAgICAgaWYgKCBpbmRleE9mZnNldCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hZGREcmF3Q2FsbCgpIG5vIGxvbmdlciBzdXBwb3J0cyBpbmRleE9mZnNldC4nICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hZGREcmF3Q2FsbCgpIGlzIG5vdyAuYWRkR3JvdXAoKS4nICk7XHJcbiAgICAgICAgdGhpcy5hZGRHcm91cCggc3RhcnQsIGNvdW50ICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjbGVhckRyYXdDYWxsczogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmNsZWFyRHJhd0NhbGxzKCkgaXMgbm93IC5jbGVhckdyb3VwcygpLicgKTtcclxuICAgICAgICB0aGlzLmNsZWFyR3JvdXBzKCk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhZGRHcm91cDogZnVuY3Rpb24gKCBzdGFydCwgY291bnQsIG1hdGVyaWFsSW5kZXggKSB7XHJcblxyXG4gICAgICAgIHRoaXMuZ3JvdXBzLnB1c2goIHtcclxuXHJcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuICAgICAgICAgICAgY291bnQ6IGNvdW50LFxyXG4gICAgICAgICAgICBtYXRlcmlhbEluZGV4OiBtYXRlcmlhbEluZGV4ICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbEluZGV4IDogMFxyXG5cclxuICAgICAgICB9ICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjbGVhckdyb3VwczogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0aGlzLmdyb3VwcyA9IFtdO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0RHJhd1JhbmdlOiBmdW5jdGlvbiAoIHN0YXJ0LCBjb3VudCApIHtcclxuXHJcbiAgICAgICAgdGhpcy5kcmF3UmFuZ2Uuc3RhcnQgPSBzdGFydDtcclxuICAgICAgICB0aGlzLmRyYXdSYW5nZS5jb3VudCA9IGNvdW50O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYXBwbHlNYXRyaXg6IGZ1bmN0aW9uICggbWF0cml4ICkge1xyXG5cclxuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XHJcblxyXG4gICAgICAgIGlmICggcG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIG1hdHJpeC5hcHBseVRvVmVjdG9yM0FycmF5KCBwb3NpdGlvbi5hcnJheSApO1xyXG4gICAgICAgICAgICBwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG5vcm1hbCA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWw7XHJcblxyXG4gICAgICAgIGlmICggbm9ybWFsICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbm9ybWFsTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xyXG5cclxuICAgICAgICAgICAgbm9ybWFsTWF0cml4LmFwcGx5VG9WZWN0b3IzQXJyYXkoIG5vcm1hbC5hcnJheSApO1xyXG4gICAgICAgICAgICBub3JtYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcm90YXRlWDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHgtYXhpc1xyXG5cclxuICAgICAgICB2YXIgbTE7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiByb3RhdGVYKCBhbmdsZSApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcbiAgICAgICAgICAgIG0xLm1ha2VSb3RhdGlvblgoIGFuZ2xlICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgLy8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB5LWF4aXNcclxuXHJcbiAgICAgICAgdmFyIG0xO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcm90YXRlWSggYW5nbGUgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG4gICAgICAgICAgICBtMS5tYWtlUm90YXRpb25ZKCBhbmdsZSApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hcHBseU1hdHJpeCggbTEgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICByb3RhdGVaOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgei1heGlzXHJcblxyXG4gICAgICAgIHZhciBtMTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVooIGFuZ2xlICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuICAgICAgICAgICAgbTEubWFrZVJvdGF0aW9uWiggYW5nbGUgKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIC8vIHRyYW5zbGF0ZSBnZW9tZXRyeVxyXG5cclxuICAgICAgICB2YXIgbTE7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiB0cmFuc2xhdGUoIHgsIHksIHogKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG4gICAgICAgICAgICBtMS5tYWtlVHJhbnNsYXRpb24oIHgsIHksIHogKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgc2NhbGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgLy8gc2NhbGUgZ2VvbWV0cnlcclxuXHJcbiAgICAgICAgdmFyIG0xO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc2NhbGUoIHgsIHksIHogKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG4gICAgICAgICAgICBtMS5tYWtlU2NhbGUoIHgsIHksIHogKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgbG9va0F0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBvYmo7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBsb29rQXQoIHZlY3RvciApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggb2JqID09PSB1bmRlZmluZWQgKSBvYmogPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcclxuXHJcbiAgICAgICAgICAgIG9iai5sb29rQXQoIHZlY3RvciApO1xyXG5cclxuICAgICAgICAgICAgb2JqLnVwZGF0ZU1hdHJpeCgpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hcHBseU1hdHJpeCggb2JqLm1hdHJpeCApO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0oKSxcclxuXHJcbiAgICBjZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcclxuXHJcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuYm91bmRpbmdCb3guY2VudGVyKCkubmVnYXRlKCk7XHJcblxyXG4gICAgICAgIHRoaXMudHJhbnNsYXRlKCBvZmZzZXQueCwgb2Zmc2V0LnksIG9mZnNldC56ICk7XHJcblxyXG4gICAgICAgIHJldHVybiBvZmZzZXQ7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRGcm9tT2JqZWN0OiBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5zZXRGcm9tT2JqZWN0KCkuIENvbnZlcnRpbmcnLCBvYmplY3QsIHRoaXMgKTtcclxuXHJcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuICAgICAgICBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50cyB8fCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IG5ldyBUSFJFRS5GbG9hdDMyQXR0cmlidXRlKCBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggKiAzLCAzICk7XHJcbiAgICAgICAgICAgIHZhciBjb2xvcnMgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggZ2VvbWV0cnkuY29sb3JzLmxlbmd0aCAqIDMsIDMgKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBwb3NpdGlvbnMuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5LnZlcnRpY2VzICkgKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIGNvbG9ycy5jb3B5Q29sb3JzQXJyYXkoIGdlb21ldHJ5LmNvbG9ycyApICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMgJiYgZ2VvbWV0cnkubGluZURpc3RhbmNlcy5sZW5ndGggPT09IGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbGluZURpc3RhbmNlcyA9IG5ldyBUSFJFRS5GbG9hdDMyQXR0cmlidXRlKCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzLmxlbmd0aCwgMSApO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAnbGluZURpc3RhbmNlJywgbGluZURpc3RhbmNlcy5jb3B5QXJyYXkoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMgKSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IGdlb21ldHJ5LmJvdW5kaW5nQm94LmNsb25lKCk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tR2VvbWV0cnkoIGdlb21ldHJ5ICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVGcm9tT2JqZWN0OiBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuICAgICAgICBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgZGlyZWN0ID0gZ2VvbWV0cnkuX19kaXJlY3RHZW9tZXRyeTtcclxuXHJcbiAgICAgICAgICAgIGlmICggZGlyZWN0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbUdlb21ldHJ5KCBnZW9tZXRyeSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZGlyZWN0LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZTtcclxuICAgICAgICAgICAgZGlyZWN0Lm5vcm1hbHNOZWVkVXBkYXRlID0gZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGU7XHJcbiAgICAgICAgICAgIGRpcmVjdC5jb2xvcnNOZWVkVXBkYXRlID0gZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZTtcclxuICAgICAgICAgICAgZGlyZWN0LnV2c05lZWRVcGRhdGUgPSBnZW9tZXRyeS51dnNOZWVkVXBkYXRlO1xyXG4gICAgICAgICAgICBkaXJlY3QuZ3JvdXBzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5Lmdyb3Vwc05lZWRVcGRhdGU7XHJcblxyXG4gICAgICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBnZW9tZXRyeS51dnNOZWVkVXBkYXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5Lmdyb3Vwc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGdlb21ldHJ5ID0gZGlyZWN0O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID09PSB0cnVlICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuXHJcbiAgICAgICAgICAgIGlmICggYXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcyApO1xyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgPT09IHRydWUgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtcclxuXHJcbiAgICAgICAgICAgIGlmICggYXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS5ub3JtYWxzICk7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPT09IHRydWUgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLmNvbG9yO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUuY29weUNvbG9yc0FycmF5KCBnZW9tZXRyeS5jb2xvcnMgKTtcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBnZW9tZXRyeS51dnNOZWVkVXBkYXRlICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlcy51djtcclxuXHJcbiAgICAgICAgICAgIGlmICggYXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlLmNvcHlWZWN0b3Iyc0FycmF5KCBnZW9tZXRyeS51dnMgKTtcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBnZW9tZXRyeS51dnNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZSApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMubGluZURpc3RhbmNlO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUuY29weUFycmF5KCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzICk7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZ2VvbWV0cnkubGluZURpc3RhbmNlc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIGdlb21ldHJ5Lmdyb3Vwc05lZWRVcGRhdGUgKSB7XHJcblxyXG4gICAgICAgICAgICBnZW9tZXRyeS5jb21wdXRlR3JvdXBzKCBvYmplY3QuZ2VvbWV0cnkgKTtcclxuICAgICAgICAgICAgdGhpcy5ncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XHJcblxyXG4gICAgICAgICAgICBnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBmcm9tR2VvbWV0cnk6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XHJcblxyXG4gICAgICAgIGdlb21ldHJ5Ll9fZGlyZWN0R2VvbWV0cnkgPSBuZXcgVEhSRUUuRGlyZWN0R2VvbWV0cnkoKS5mcm9tR2VvbWV0cnkoIGdlb21ldHJ5ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmZyb21EaXJlY3RHZW9tZXRyeSggZ2VvbWV0cnkuX19kaXJlY3RHZW9tZXRyeSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZnJvbURpcmVjdEdlb21ldHJ5OiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xyXG5cclxuICAgICAgICB2YXIgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICogMyApO1xyXG4gICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIDMgKS5jb3B5VmVjdG9yM3NBcnJheSggZ2VvbWV0cnkudmVydGljZXMgKSApO1xyXG5cclxuICAgICAgICBpZiAoIGdlb21ldHJ5Lm5vcm1hbHMubGVuZ3RoID4gMCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkubm9ybWFscy5sZW5ndGggKiAzICk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS5ub3JtYWxzICkgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIGdlb21ldHJ5LmNvbG9ycy5sZW5ndGggPiAwICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGNvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5LmNvbG9ycy5sZW5ndGggKiAzICk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKS5jb3B5Q29sb3JzQXJyYXkoIGdlb21ldHJ5LmNvbG9ycyApICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBnZW9tZXRyeS51dnMubGVuZ3RoID4gMCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciB1dnMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS51dnMubGVuZ3RoICogMiApO1xyXG4gICAgICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkuY29weVZlY3RvcjJzQXJyYXkoIGdlb21ldHJ5LnV2cyApICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBnZW9tZXRyeS51dnMyLmxlbmd0aCA+IDAgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgdXZzMiA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5LnV2czIubGVuZ3RoICogMiApO1xyXG4gICAgICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2MicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHV2czIsIDIgKS5jb3B5VmVjdG9yMnNBcnJheSggZ2VvbWV0cnkudXZzMiApICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBnZW9tZXRyeS5pbmRpY2VzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgVHlwZUFycmF5ID0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoID4gNjU1MzUgPyBVaW50MzJBcnJheSA6IFVpbnQxNkFycmF5O1xyXG4gICAgICAgICAgICB2YXIgaW5kaWNlcyA9IG5ldyBUeXBlQXJyYXkoIGdlb21ldHJ5LmluZGljZXMubGVuZ3RoICogMyApO1xyXG4gICAgICAgICAgICB0aGlzLnNldEluZGV4KCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBpbmRpY2VzLCAxICkuY29weUluZGljZXNBcnJheSggZ2VvbWV0cnkuaW5kaWNlcyApICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gZ3JvdXBzXHJcblxyXG4gICAgICAgIHRoaXMuZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xyXG5cclxuICAgICAgICAvLyBtb3JwaHNcclxuXHJcbiAgICAgICAgZm9yICggdmFyIG5hbWUgaW4gZ2VvbWV0cnkubW9ycGhUYXJnZXRzICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGFycmF5ID0gW107XHJcbiAgICAgICAgICAgIHZhciBtb3JwaFRhcmdldHMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNbIG5hbWUgXTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBtb3JwaFRhcmdldCA9IG1vcnBoVGFyZ2V0c1sgaSBdO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggbW9ycGhUYXJnZXQubGVuZ3RoICogMywgMyApO1xyXG5cclxuICAgICAgICAgICAgICAgIGFycmF5LnB1c2goIGF0dHJpYnV0ZS5jb3B5VmVjdG9yM3NBcnJheSggbW9ycGhUYXJnZXQgKSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5tb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXSA9IGFycmF5O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHNraW5uaW5nXHJcblxyXG4gICAgICAgIGlmICggZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoID4gMCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBza2luSW5kaWNlcyA9IG5ldyBUSFJFRS5GbG9hdDMyQXR0cmlidXRlKCBnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggKiA0LCA0ICk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAnc2tpbkluZGV4Jywgc2tpbkluZGljZXMuY29weVZlY3RvcjRzQXJyYXkoIGdlb21ldHJ5LnNraW5JbmRpY2VzICkgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIGdlb21ldHJ5LnNraW5XZWlnaHRzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgc2tpbldlaWdodHMgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoICogNCwgNCApO1xyXG4gICAgICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3NraW5XZWlnaHQnLCBza2luV2VpZ2h0cy5jb3B5VmVjdG9yNHNBcnJheSggZ2VvbWV0cnkuc2tpbldlaWdodHMgKSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vXHJcblxyXG4gICAgICAgIGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IGdlb21ldHJ5LmJvdW5kaW5nQm94LmNsb25lKCk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb21wdXRlQm91bmRpbmdCb3g6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHRoaXMuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IG5ldyBUSFJFRS5Cb3gzKCk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xyXG5cclxuICAgICAgICAgICAgaWYgKCBwb3NpdGlvbnMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGJiID0gdGhpcy5ib3VuZGluZ0JveDtcclxuICAgICAgICAgICAgICAgIGJiLm1ha2VFbXB0eSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKz0gMyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmVjdG9yLmZyb21BcnJheSggcG9zaXRpb25zLCBpICk7XHJcbiAgICAgICAgICAgICAgICAgICAgYmIuZXhwYW5kQnlQb2ludCggdmVjdG9yICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBwb3NpdGlvbnMgPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbnMubGVuZ3RoID09PSAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuYm91bmRpbmdCb3gubWluLnNldCggMCwgMCwgMCApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5tYXguc2V0KCAwLCAwLCAwICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIGlzTmFOKCB0aGlzLmJvdW5kaW5nQm94Lm1pbi54ICkgfHwgaXNOYU4oIHRoaXMuYm91bmRpbmdCb3gubWluLnkgKSB8fCBpc05hTiggdGhpcy5ib3VuZGluZ0JveC5taW4ueiApICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3g6IENvbXB1dGVkIG1pbi9tYXggaGF2ZSBOYU4gdmFsdWVzLiBUaGUgXCJwb3NpdGlvblwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicsIHRoaXMgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KCksXHJcblxyXG4gICAgY29tcHV0ZUJvdW5kaW5nU3BoZXJlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBib3ggPSBuZXcgVEhSRUUuQm94MygpO1xyXG4gICAgICAgIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xyXG5cclxuICAgICAgICAgICAgaWYgKCBwb3NpdGlvbnMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgYm94Lm1ha2VFbXB0eSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLmNlbnRlcjtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZlY3Rvci5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJveC5leHBhbmRCeVBvaW50KCB2ZWN0b3IgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYm94LmNlbnRlciggY2VudGVyICk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaG9waW5nIHRvIGZpbmQgYSBib3VuZGluZ1NwaGVyZSB3aXRoIGEgcmFkaXVzIHNtYWxsZXIgdGhhbiB0aGVcclxuICAgICAgICAgICAgICAgIC8vIGJvdW5kaW5nU3BoZXJlIG9mIHRoZSBib3VuZGluZ0JveDogc3FydCgzKSBzbWFsbGVyIGluIHRoZSBiZXN0IGNhc2VcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbWF4UmFkaXVzU3EgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKz0gMyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmVjdG9yLmZyb21BcnJheSggcG9zaXRpb25zLCBpICk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4UmFkaXVzU3EgPSBNYXRoLm1heCggbWF4UmFkaXVzU3EsIGNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggdmVjdG9yICkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgPSBNYXRoLnNxcnQoIG1heFJhZGl1c1NxICk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBpc05hTiggdGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpOiBDb21wdXRlZCByYWRpdXMgaXMgTmFOLiBUaGUgXCJwb3NpdGlvblwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicsIHRoaXMgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSgpLFxyXG5cclxuICAgIGNvbXB1dGVGYWNlTm9ybWFsczogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29tcHV0ZVZlcnRleE5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleDtcclxuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcclxuICAgICAgICB2YXIgZ3JvdXBzID0gdGhpcy5ncm91cHM7XHJcblxyXG4gICAgICAgIGlmICggYXR0cmlidXRlcy5wb3NpdGlvbiApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xyXG5cclxuICAgICAgICAgICAgaWYgKCBhdHRyaWJ1dGVzLm5vcm1hbCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggcG9zaXRpb25zLmxlbmd0aCApLCAzICkgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgZXhpc3Rpbmcgbm9ybWFscyB0byB6ZXJvXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbHMgPSBhdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gbm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgaSBdID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgbm9ybWFscyA9IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xyXG5cclxuICAgICAgICAgICAgdmFyIHZBLCB2QiwgdkMsXHJcblxyXG4gICAgICAgICAgICAgICAgcEEgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG4gICAgICAgICAgICAgICAgcEIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG4gICAgICAgICAgICAgICAgcEMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cclxuICAgICAgICAgICAgICAgIGNiID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuICAgICAgICAgICAgICAgIGFiID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGluZGV4ZWQgZWxlbWVudHNcclxuXHJcbiAgICAgICAgICAgIGlmICggaW5kZXggKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGluZGljZXMgPSBpbmRleC5hcnJheTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGdyb3Vwcy5sZW5ndGggPT09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkR3JvdXAoIDAsIGluZGljZXMubGVuZ3RoICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBncm91cHMubGVuZ3RoOyBqIDwgamw7ICsrIGogKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBncm91cCA9IGdyb3Vwc1sgaiBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBncm91cC5zdGFydDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY291bnQgPSBncm91cC5jb3VudDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSBzdGFydCwgaWwgPSBzdGFydCArIGNvdW50OyBpIDwgaWw7IGkgKz0gMyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZBID0gaW5kaWNlc1sgaSArIDAgXSAqIDM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZCID0gaW5kaWNlc1sgaSArIDEgXSAqIDM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZDID0gaW5kaWNlc1sgaSArIDIgXSAqIDM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwQS5mcm9tQXJyYXkoIHBvc2l0aW9ucywgdkEgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcEIuZnJvbUFycmF5KCBwb3NpdGlvbnMsIHZCICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBDLmZyb21BcnJheSggcG9zaXRpb25zLCB2QyApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2Iuc3ViVmVjdG9ycyggcEMsIHBCICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFiLnN1YlZlY3RvcnMoIHBBLCBwQiApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYi5jcm9zcyggYWIgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIHZBIF0gKz0gY2IueDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgdkEgKyAxIF0gKz0gY2IueTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgdkEgKyAyIF0gKz0gY2IuejtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIHZCIF0gKz0gY2IueDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgdkIgKyAxIF0gKz0gY2IueTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgdkIgKyAyIF0gKz0gY2IuejtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIHZDIF0gKz0gY2IueDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgdkMgKyAxIF0gKz0gY2IueTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgdkMgKyAyIF0gKz0gY2IuejtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbm9uLWluZGV4ZWQgZWxlbWVudHMgKHVuY29ubmVjdGVkIHRyaWFuZ2xlIHNvdXApXHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArPSA5ICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwQS5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSApO1xyXG4gICAgICAgICAgICAgICAgICAgIHBCLmZyb21BcnJheSggcG9zaXRpb25zLCBpICsgMyApO1xyXG4gICAgICAgICAgICAgICAgICAgIHBDLmZyb21BcnJheSggcG9zaXRpb25zLCBpICsgNiApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYi5zdWJWZWN0b3JzKCBwQywgcEIgKTtcclxuICAgICAgICAgICAgICAgICAgICBhYi5zdWJWZWN0b3JzKCBwQSwgcEIgKTtcclxuICAgICAgICAgICAgICAgICAgICBjYi5jcm9zcyggYWIgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgaSBdID0gY2IueDtcclxuICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBpICsgMSBdID0gY2IueTtcclxuICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBpICsgMiBdID0gY2IuejtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgaSArIDMgXSA9IGNiLng7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgaSArIDQgXSA9IGNiLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgaSArIDUgXSA9IGNiLno7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIGkgKyA2IF0gPSBjYi54O1xyXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIGkgKyA3IF0gPSBjYi55O1xyXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIGkgKyA4IF0gPSBjYi56O1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMubm9ybWFsaXplTm9ybWFscygpO1xyXG5cclxuICAgICAgICAgICAgYXR0cmlidXRlcy5ub3JtYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb21wdXRlVGFuZ2VudHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5jb21wdXRlVGFuZ2VudHMoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvbXB1dGVPZmZzZXRzOiBmdW5jdGlvbiAoIHNpemUgKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuY29tcHV0ZU9mZnNldHMoKSBoYXMgYmVlbiByZW1vdmVkLicpXHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBtZXJnZTogZnVuY3Rpb24gKCBnZW9tZXRyeSwgb2Zmc2V0ICkge1xyXG5cclxuICAgICAgICBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgPT09IGZhbHNlICkge1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5Lm1lcmdlKCk6IGdlb21ldHJ5IG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeS4nLCBnZW9tZXRyeSApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIga2V5IGluIGF0dHJpYnV0ZXMgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGdlb21ldHJ5LmF0dHJpYnV0ZXNbIGtleSBdID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUxID0gYXR0cmlidXRlc1sga2V5IF07XHJcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVBcnJheTEgPSBhdHRyaWJ1dGUxLmFycmF5O1xyXG5cclxuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZTIgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzWyBrZXkgXTtcclxuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZUFycmF5MiA9IGF0dHJpYnV0ZTIuYXJyYXk7XHJcblxyXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlU2l6ZSA9IGF0dHJpYnV0ZTIuaXRlbVNpemU7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGogPSBhdHRyaWJ1dGVTaXplICogb2Zmc2V0OyBpIDwgYXR0cmlidXRlQXJyYXkyLmxlbmd0aDsgaSArKywgaiArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVBcnJheTFbIGogXSA9IGF0dHJpYnV0ZUFycmF5MlsgaSBdO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbm9ybWFsaXplTm9ybWFsczogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgbm9ybWFscyA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XHJcblxyXG4gICAgICAgIHZhciB4LCB5LCB6LCBuO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gbm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArPSAzICkge1xyXG5cclxuICAgICAgICAgICAgeCA9IG5vcm1hbHNbIGkgXTtcclxuICAgICAgICAgICAgeSA9IG5vcm1hbHNbIGkgKyAxIF07XHJcbiAgICAgICAgICAgIHogPSBub3JtYWxzWyBpICsgMiBdO1xyXG5cclxuICAgICAgICAgICAgbiA9IDEuMCAvIE1hdGguc3FydCggeCAqIHggKyB5ICogeSArIHogKiB6ICk7XHJcblxyXG4gICAgICAgICAgICBub3JtYWxzWyBpIF0gKj0gbjtcclxuICAgICAgICAgICAgbm9ybWFsc1sgaSArIDEgXSAqPSBuO1xyXG4gICAgICAgICAgICBub3JtYWxzWyBpICsgMiBdICo9IG47XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRvSlNPTjogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgZGF0YSA9IHtcclxuICAgICAgICAgICAgbWV0YWRhdGE6IHtcclxuICAgICAgICAgICAgICAgIHZlcnNpb246IDQuNCxcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdCdWZmZXJHZW9tZXRyeScsXHJcbiAgICAgICAgICAgICAgICBnZW5lcmF0b3I6ICdCdWZmZXJHZW9tZXRyeS50b0pTT04nXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBzdGFuZGFyZCBCdWZmZXJHZW9tZXRyeSBzZXJpYWxpemF0aW9uXHJcblxyXG4gICAgICAgIGRhdGEudXVpZCA9IHRoaXMudXVpZDtcclxuICAgICAgICBkYXRhLnR5cGUgPSB0aGlzLnR5cGU7XHJcbiAgICAgICAgaWYgKCB0aGlzLm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMucGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIga2V5IGluIHBhcmFtZXRlcnMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBwYXJhbWV0ZXJzWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkgZGF0YVsga2V5IF0gPSBwYXJhbWV0ZXJzWyBrZXkgXTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRhdGEuZGF0YSA9IHsgYXR0cmlidXRlczoge30gfTtcclxuXHJcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleDtcclxuXHJcbiAgICAgICAgaWYgKCBpbmRleCAhPT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBhcnJheSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBpbmRleC5hcnJheSApO1xyXG5cclxuICAgICAgICAgICAgZGF0YS5kYXRhLmluZGV4ID0ge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogaW5kZXguYXJyYXkuY29uc3RydWN0b3IubmFtZSxcclxuICAgICAgICAgICAgICAgIGFycmF5OiBhcnJheVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIga2V5IGluIGF0dHJpYnV0ZXMgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1sga2V5IF07XHJcblxyXG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXR0cmlidXRlLmFycmF5ICk7XHJcblxyXG4gICAgICAgICAgICBkYXRhLmRhdGEuYXR0cmlidXRlc1sga2V5IF0gPSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtU2l6ZTogYXR0cmlidXRlLml0ZW1TaXplLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogYXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsXHJcbiAgICAgICAgICAgICAgICBhcnJheTogYXJyYXlcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZ3JvdXBzID0gdGhpcy5ncm91cHM7XHJcblxyXG4gICAgICAgIGlmICggZ3JvdXBzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG4gICAgICAgICAgICBkYXRhLmRhdGEuZ3JvdXBzID0gSlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkoIGdyb3VwcyApICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGJvdW5kaW5nU3BoZXJlID0gdGhpcy5ib3VuZGluZ1NwaGVyZTtcclxuXHJcbiAgICAgICAgaWYgKCBib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgIGRhdGEuZGF0YS5ib3VuZGluZ1NwaGVyZSA9IHtcclxuICAgICAgICAgICAgICAgIGNlbnRlcjogYm91bmRpbmdTcGhlcmUuY2VudGVyLnRvQXJyYXkoKSxcclxuICAgICAgICAgICAgICAgIHJhZGl1czogYm91bmRpbmdTcGhlcmUucmFkaXVzXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcbiAgICAgICAgdmFyIGluZGV4ID0gc291cmNlLmluZGV4O1xyXG5cclxuICAgICAgICBpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zZXRJbmRleCggaW5kZXguY2xvbmUoKSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gc291cmNlLmF0dHJpYnV0ZXM7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1sgbmFtZSBdO1xyXG4gICAgICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggbmFtZSwgYXR0cmlidXRlLmNsb25lKCkgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZ3JvdXBzID0gc291cmNlLmdyb3VwcztcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNbIGkgXTtcclxuICAgICAgICAgICAgdGhpcy5hZGRHcm91cCggZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50ICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLkJ1ZmZlckdlb21ldHJ5Lk1heEluZGV4ID0gNjU1MzU7XHJcblxyXG4vLyBGaWxlOnNyYy9jb3JlL0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXHJcbiAqL1xyXG5cclxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgVEhSRUUuQnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSc7XHJcbiAgICB0aGlzLm1heEluc3RhbmNlZENvdW50ID0gdW5kZWZpbmVkO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeTtcclxuXHJcblRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5hZGRHcm91cCA9IGZ1bmN0aW9uICggc3RhcnQsIGNvdW50LCBpbnN0YW5jZXMgKSB7XHJcblxyXG4gICAgdGhpcy5ncm91cHMucHVzaCgge1xyXG5cclxuICAgICAgICBzdGFydDogc3RhcnQsXHJcbiAgICAgICAgY291bnQ6IGNvdW50LFxyXG4gICAgICAgIGluc3RhbmNlczogaW5zdGFuY2VzXHJcblxyXG4gICAgfSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG4gICAgdmFyIGluZGV4ID0gc291cmNlLmluZGV4O1xyXG5cclxuICAgIGlmICggaW5kZXggIT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0SW5kZXgoIGluZGV4LmNsb25lKCkgKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBzb3VyY2UuYXR0cmlidXRlcztcclxuXHJcbiAgICBmb3IgKCB2YXIgbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xyXG5cclxuICAgICAgICB2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1sgbmFtZSBdO1xyXG4gICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCBuYW1lLCBhdHRyaWJ1dGUuY2xvbmUoKSApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB2YXIgZ3JvdXBzID0gc291cmNlLmdyb3VwcztcclxuXHJcbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBncm91cHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgdmFyIGdyb3VwID0gZ3JvdXBzWyBpIF07XHJcbiAgICAgICAgdGhpcy5hZGRHcm91cCggZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50LCBncm91cC5pbnN0YW5jZXMgKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblxyXG4vLyBGaWxlOnNyYy9hbmltYXRpb24vQW5pbWF0aW9uQWN0aW9uLmpzXHJcblxyXG4vKipcclxuICpcclxuICogQSBjbGlwIHRoYXQgaGFzIGJlZW4gZXhwbGljaXRseSBzY2hlZHVsZWQuXHJcbiAqXHJcbiAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXHJcbiAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xyXG4gKi9cclxuXHJcblRIUkVFLkFuaW1hdGlvbkFjdGlvbiA9IGZ1bmN0aW9uICggY2xpcCwgc3RhcnRUaW1lLCB0aW1lU2NhbGUsIHdlaWdodCwgbG9vcCApIHtcclxuXHJcbiAgICBpZiAoIGNsaXAgPT09IHVuZGVmaW5lZCApIHRocm93IG5ldyBFcnJvciggJ2NsaXAgaXMgbnVsbCcgKTtcclxuICAgIHRoaXMuY2xpcCA9IGNsaXA7XHJcbiAgICB0aGlzLmxvY2FsUm9vdCA9IG51bGw7XHJcbiAgICB0aGlzLnN0YXJ0VGltZSA9IHN0YXJ0VGltZSB8fCAwO1xyXG4gICAgdGhpcy50aW1lU2NhbGUgPSB0aW1lU2NhbGUgfHwgMTtcclxuICAgIHRoaXMud2VpZ2h0ID0gd2VpZ2h0IHx8IDE7XHJcbiAgICB0aGlzLmxvb3AgPSBsb29wIHx8IFRIUkVFLkxvb3BSZXBlYXQ7XHJcbiAgICB0aGlzLmxvb3BDb3VudCA9IDA7XHJcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1x0Ly8gYWxsb3cgZm9yIGVhc3kgZGlzYWJsaW5nIG9mIHRoZSBhY3Rpb24uXHJcblxyXG4gICAgdGhpcy5hY3Rpb25UaW1lID0gLSB0aGlzLnN0YXJ0VGltZTtcclxuICAgIHRoaXMuY2xpcFRpbWUgPSAwO1xyXG5cclxuICAgIHRoaXMucHJvcGVydHlCaW5kaW5ncyA9IFtdO1xyXG59O1xyXG5cclxuLypcclxuIFRIUkVFLkxvb3BPbmNlID0gMjIwMDtcclxuIFRIUkVFLkxvb3BSZXBlYXQgPSAyMjAxO1xyXG4gVEhSRUUuTG9vcFBpbmdQaW5nID0gMjIwMjtcclxuICovXHJcblxyXG5USFJFRS5BbmltYXRpb25BY3Rpb24ucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5BbmltYXRpb25BY3Rpb24sXHJcblxyXG4gICAgc2V0TG9jYWxSb290OiBmdW5jdGlvbiggbG9jYWxSb290ICkge1xyXG5cclxuICAgICAgICB0aGlzLmxvY2FsUm9vdCA9IGxvY2FsUm9vdDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVUaW1lOiBmdW5jdGlvbiggY2xpcERlbHRhVGltZSApIHtcclxuXHJcbiAgICAgICAgdmFyIHByZXZpb3VzQ2xpcFRpbWUgPSB0aGlzLmNsaXBUaW1lO1xyXG4gICAgICAgIHZhciBwcmV2aW91c0xvb3BDb3VudCA9IHRoaXMubG9vcENvdW50O1xyXG4gICAgICAgIHZhciBwcmV2aW91c0FjdGlvblRpbWUgPSB0aGlzLmFjdGlvblRpbWU7XHJcblxyXG4gICAgICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuY2xpcC5kdXJhdGlvbjtcclxuXHJcbiAgICAgICAgdGhpcy5hY3Rpb25UaW1lID0gdGhpcy5hY3Rpb25UaW1lICsgY2xpcERlbHRhVGltZTtcclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLmxvb3AgPT09IFRIUkVFLkxvb3BPbmNlICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5sb29wQ291bnQgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmNsaXBUaW1lID0gTWF0aC5taW4oIE1hdGgubWF4KCB0aGlzLmFjdGlvblRpbWUsIDAgKSwgZHVyYXRpb24gKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGlmIHRpbWUgaXMgY2hhbmdlZCBzaW5jZSBsYXN0IHRpbWUsIHNlZSBpZiB3ZSBoYXZlIGhpdCBhIHN0YXJ0L2VuZCBsaW1pdFxyXG4gICAgICAgICAgICBpZiAoIHRoaXMuY2xpcFRpbWUgIT09IHByZXZpb3VzQ2xpcFRpbWUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzLmNsaXBUaW1lID09PSBkdXJhdGlvbiApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taXhlci5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdmaW5pc2hlZCcsIGFjdGlvbjogdGhpcywgZGlyZWN0aW9uOiAxIH0gKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCB0aGlzLmNsaXBUaW1lID09PSAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1peGVyLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2ZpbmlzaGVkJywgYWN0aW9uOiB0aGlzLCBkaXJlY3Rpb246IC0xIH0gKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xpcFRpbWU7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5sb29wQ291bnQgPSBNYXRoLmZsb29yKCB0aGlzLmFjdGlvblRpbWUgLyBkdXJhdGlvbiApO1xyXG5cclxuICAgICAgICB2YXIgbmV3Q2xpcFRpbWUgPSB0aGlzLmFjdGlvblRpbWUgLSB0aGlzLmxvb3BDb3VudCAqIGR1cmF0aW9uO1xyXG4gICAgICAgIG5ld0NsaXBUaW1lID0gbmV3Q2xpcFRpbWUgJSBkdXJhdGlvbjtcclxuXHJcbiAgICAgICAgLy8gaWYgd2UgYXJlIHBpbmcgcG9uZyBsb29waW5nLCBlbnN1cmUgdGhhdCB3ZSBnbyBiYWNrd2FyZHMgd2hlbiBhcHByb3ByaWF0ZVxyXG4gICAgICAgIGlmICggdGhpcy5sb29wID09IFRIUkVFLkxvb3BQaW5nUG9uZyApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggTWF0aC5hYnMoIHRoaXMubG9vcENvdW50ICUgMiApID09PSAxICkge1xyXG5cclxuICAgICAgICAgICAgICAgIG5ld0NsaXBUaW1lID0gZHVyYXRpb24gLSBuZXdDbGlwVGltZTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmNsaXBUaW1lID0gbmV3Q2xpcFRpbWU7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5sb29wQ291bnQgIT09IHByZXZpb3VzTG9vcENvdW50ICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5taXhlci5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdsb29wJywgYWN0aW9uOiB0aGlzLCBsb29wRGVsdGE6ICggdGhpcy5sb29wQ291bnQgLSB0aGlzLmxvb3BDb3VudCApIH0gKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5jbGlwVGltZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHN5bmNXaXRoOiBmdW5jdGlvbiggYWN0aW9uICkge1xyXG5cclxuICAgICAgICB0aGlzLmFjdGlvblRpbWUgPSBhY3Rpb24uYWN0aW9uVGltZTtcclxuICAgICAgICB0aGlzLnRpbWVTY2FsZSA9IGFjdGlvbi50aW1lU2NhbGU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICB3YXJwVG9EdXJhdGlvbjogZnVuY3Rpb24oIGR1cmF0aW9uICkge1xyXG5cclxuICAgICAgICB0aGlzLnRpbWVTY2FsZSA9IHRoaXMuY2xpcC5kdXJhdGlvbiAvIGR1cmF0aW9uO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgaW5pdDogZnVuY3Rpb24oIHRpbWUgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY2xpcFRpbWUgPSB0aW1lIC0gdGhpcy5zdGFydFRpbWU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiggY2xpcERlbHRhVGltZSApIHtcclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGVUaW1lKCBjbGlwRGVsdGFUaW1lICk7XHJcblxyXG4gICAgICAgIHZhciBjbGlwUmVzdWx0cyA9IHRoaXMuY2xpcC5nZXRBdCggdGhpcy5jbGlwVGltZSApO1xyXG5cclxuICAgICAgICByZXR1cm4gY2xpcFJlc3VsdHM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRUaW1lU2NhbGVBdDogZnVuY3Rpb24oIHRpbWUgKSB7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy50aW1lU2NhbGUuZ2V0QXQgKSB7XHJcbiAgICAgICAgICAgIC8vIHBhc3MgaW4gdGltZSwgbm90IGNsaXAgdGltZSwgYWxsb3dzIGZvciBmYWRlaW4vZmFkZW91dCBhY3Jvc3MgbXVsdGlwbGUgbG9vcHMgb2YgdGhlIGNsaXBcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGltZVNjYWxlLmdldEF0KCB0aW1lICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZVNjYWxlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0V2VpZ2h0QXQ6IGZ1bmN0aW9uKCB0aW1lICkge1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMud2VpZ2h0LmdldEF0ICkge1xyXG4gICAgICAgICAgICAvLyBwYXNzIGluIHRpbWUsIG5vdCBjbGlwIHRpbWUsIGFsbG93cyBmb3IgZmFkZWluL2ZhZGVvdXQgYWNyb3NzIG11bHRpcGxlIGxvb3BzIG9mIHRoZSBjbGlwXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlaWdodC5nZXRBdCggdGltZSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLndlaWdodDtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvYW5pbWF0aW9uL0FuaW1hdGlvbkNsaXAuanNcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBSZXVzYWJsZSBzZXQgb2YgVHJhY2tzIHRoYXQgcmVwcmVzZW50IGFuIGFuaW1hdGlvbi5cclxuICpcclxuICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cclxuICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXHJcbiAqL1xyXG5cclxuVEhSRUUuQW5pbWF0aW9uQ2xpcCA9IGZ1bmN0aW9uICggbmFtZSwgZHVyYXRpb24sIHRyYWNrcyApIHtcclxuXHJcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgdGhpcy50cmFja3MgPSB0cmFja3M7XHJcbiAgICB0aGlzLmR1cmF0aW9uID0gKCBkdXJhdGlvbiAhPT0gdW5kZWZpbmVkICkgPyBkdXJhdGlvbiA6IC0xO1xyXG5cclxuICAgIC8vIHRoaXMgbWVhbnMgaXQgc2hvdWxkIGZpZ3VyZSBvdXQgaXRzIGR1cmF0aW9uIGJ5IHNjYW5uaW5nIHRoZSB0cmFja3NcclxuICAgIGlmICggdGhpcy5kdXJhdGlvbiA8IDAgKSB7XHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy50cmFja3MubGVuZ3RoOyBpICsrICkge1xyXG4gICAgICAgICAgICB2YXIgdHJhY2sgPSB0aGlzLnRyYWNrc1tpXTtcclxuICAgICAgICAgICAgdGhpcy5kdXJhdGlvbiA9IE1hdGgubWF4KCB0cmFjay5rZXlzWyB0cmFjay5rZXlzLmxlbmd0aCAtIDEgXS50aW1lICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIG1heWJlIG9ubHkgZG8gdGhlc2Ugb24gZGVtYW5kLCBhcyBkb2luZyB0aGVtIGhlcmUgY291bGQgcG90ZW50aWFsbHkgc2xvdyBkb3duIGxvYWRpbmdcclxuICAgIC8vIGJ1dCBsZWF2aW5nIHRoZXNlIGhlcmUgZHVyaW5nIGRldmVsb3BtZW50IGFzIHRoaXMgZW5zdXJlcyBhIGxvdCBvZiB0ZXN0aW5nIG9mIHRoZXNlIGZ1bmN0aW9uc1xyXG4gICAgdGhpcy50cmltKCk7XHJcbiAgICB0aGlzLm9wdGltaXplKCk7XHJcblxyXG4gICAgdGhpcy5yZXN1bHRzID0gW107XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQW5pbWF0aW9uQ2xpcC5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkFuaW1hdGlvbkNsaXAsXHJcblxyXG4gICAgZ2V0QXQ6IGZ1bmN0aW9uKCBjbGlwVGltZSApIHtcclxuXHJcbiAgICAgICAgY2xpcFRpbWUgPSBNYXRoLm1heCggMCwgTWF0aC5taW4oIGNsaXBUaW1lLCB0aGlzLmR1cmF0aW9uICkgKTtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy50cmFja3MubGVuZ3RoOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHRyYWNrID0gdGhpcy50cmFja3NbIGkgXTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucmVzdWx0c1sgaSBdID0gdHJhY2suZ2V0QXQoIGNsaXBUaW1lICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0cztcclxuICAgIH0sXHJcblxyXG4gICAgdHJpbTogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudHJhY2tzWyBpIF0udHJpbSggMCwgdGhpcy5kdXJhdGlvbiApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgb3B0aW1pemU6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLnRyYWNrcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnRyYWNrc1sgaSBdLm9wdGltaXplKCk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcblxyXG5USFJFRS5BbmltYXRpb25DbGlwLkNyZWF0ZUZyb21Nb3JwaFRhcmdldFNlcXVlbmNlID0gZnVuY3Rpb24oIG5hbWUsIG1vcnBoVGFyZ2V0U2VxdWVuY2UsIGZwcyApIHtcclxuXHJcblxyXG4gICAgdmFyIG51bU1vcnBoVGFyZ2V0cyA9IG1vcnBoVGFyZ2V0U2VxdWVuY2UubGVuZ3RoO1xyXG4gICAgdmFyIHRyYWNrcyA9IFtdO1xyXG5cclxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG51bU1vcnBoVGFyZ2V0czsgaSArKyApIHtcclxuXHJcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcclxuXHJcbiAgICAgICAga2V5cy5wdXNoKCB7IHRpbWU6ICggaSArIG51bU1vcnBoVGFyZ2V0cyAtIDEgKSAlIG51bU1vcnBoVGFyZ2V0cywgdmFsdWU6IDAgfSApO1xyXG4gICAgICAgIGtleXMucHVzaCggeyB0aW1lOiBpLCB2YWx1ZTogMSB9ICk7XHJcbiAgICAgICAga2V5cy5wdXNoKCB7IHRpbWU6ICggaSArIDEgKSAlIG51bU1vcnBoVGFyZ2V0cywgdmFsdWU6IDAgfSApO1xyXG5cclxuICAgICAgICBrZXlzLnNvcnQoIFRIUkVFLktleWZyYW1lVHJhY2sua2V5Q29tcGFyZXIgKTtcclxuXHJcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBrZXkgYXQgdGhlIGZpcnN0IGZyYW1lLCBkdXBsaWNhdGUgaXQgYXMgdGhlIGxhc3QgZnJhbWUgYXMgd2VsbCBmb3IgcGVyZmVjdCBsb29wLlxyXG4gICAgICAgIGlmICgga2V5c1swXS50aW1lID09PSAwICkge1xyXG4gICAgICAgICAgICBrZXlzLnB1c2goIHtcclxuICAgICAgICAgICAgICAgIHRpbWU6IG51bU1vcnBoVGFyZ2V0cyxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBrZXlzWzBdLnZhbHVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdHJhY2tzLnB1c2goIG5ldyBUSFJFRS5OdW1iZXJLZXlmcmFtZVRyYWNrKCAnLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1snICsgbW9ycGhUYXJnZXRTZXF1ZW5jZVtpXS5uYW1lICsgJ10nLCBrZXlzICkuc2NhbGUoIDEuMCAvIGZwcyApICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5BbmltYXRpb25DbGlwKCBuYW1lLCAtMSwgdHJhY2tzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQW5pbWF0aW9uQ2xpcC5maW5kQnlOYW1lID0gZnVuY3Rpb24oIGNsaXBBcnJheSwgbmFtZSApIHtcclxuXHJcbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBjbGlwQXJyYXkubGVuZ3RoOyBpICsrICkge1xyXG5cclxuICAgICAgICBpZiAoIGNsaXBBcnJheVtpXS5uYW1lID09PSBuYW1lICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNsaXBBcnJheVtpXTtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkFuaW1hdGlvbkNsaXAuQ3JlYXRlQ2xpcHNGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZXMgPSBmdW5jdGlvbiggbW9ycGhUYXJnZXRzLCBmcHMgKSB7XHJcblxyXG4gICAgdmFyIGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzID0ge307XHJcblxyXG4gICAgLy8gdGVzdGVkIHdpdGggaHR0cHM6Ly9yZWdleDEwMS5jb20vIG9uIHRyaWNrIHNlcXVlbmNlcyBzdWNoIGZsYW1pbmdvX2ZseUFfMDAzLCBmbGFtaW5nb19ydW4xXzAwMywgY3JkZWF0aDAwNTlcclxuICAgIHZhciBwYXR0ZXJuID0gL14oW1xcdy1dKj8pKFtcXGRdKykkLztcclxuXHJcbiAgICAvLyBzb3J0IG1vcnBoIHRhcmdldCBuYW1lcyBpbnRvIGFuaW1hdGlvbiBncm91cHMgYmFzZWQgcGF0dGVybnMgbGlrZSBXYWxrXzAwMSwgV2Fsa18wMDIsIFJ1bl8wMDEsIFJ1bl8wMDJcclxuICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBtb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIHZhciBtb3JwaFRhcmdldCA9IG1vcnBoVGFyZ2V0c1sgaSBdO1xyXG4gICAgICAgIHZhciBwYXJ0cyA9IG1vcnBoVGFyZ2V0Lm5hbWUubWF0Y2goIHBhdHRlcm4gKTtcclxuXHJcbiAgICAgICAgaWYgKCBwYXJ0cyAmJiBwYXJ0cy5sZW5ndGggPiAxICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIG5hbWUgPSBwYXJ0c1sgMSBdO1xyXG5cclxuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbk1vcnBoVGFyZ2V0cyA9IGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzWyBuYW1lIF07XHJcbiAgICAgICAgICAgIGlmICggISBhbmltYXRpb25Nb3JwaFRhcmdldHMgKSB7XHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb25Ub01vcnBoVGFyZ2V0c1sgbmFtZSBdID0gYW5pbWF0aW9uTW9ycGhUYXJnZXRzID0gW107XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGFuaW1hdGlvbk1vcnBoVGFyZ2V0cy5wdXNoKCBtb3JwaFRhcmdldCApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHZhciBjbGlwcyA9IFtdO1xyXG5cclxuICAgIGZvciAoIHZhciBuYW1lIGluIGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzICkge1xyXG5cclxuICAgICAgICBjbGlwcy5wdXNoKCBUSFJFRS5BbmltYXRpb25DbGlwLkNyZWF0ZUZyb21Nb3JwaFRhcmdldFNlcXVlbmNlKCBuYW1lLCBhbmltYXRpb25Ub01vcnBoVGFyZ2V0c1sgbmFtZSBdLCBmcHMgKSApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjbGlwcztcclxuXHJcbn07XHJcblxyXG4vLyBwYXJzZSB0aGUgc3RhbmRhcmQgSlNPTiBmb3JtYXQgZm9yIGNsaXBzXHJcblRIUkVFLkFuaW1hdGlvbkNsaXAucGFyc2UgPSBmdW5jdGlvbigganNvbiApIHtcclxuXHJcbiAgICB2YXIgdHJhY2tzID0gW107XHJcblxyXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwganNvbi50cmFja3MubGVuZ3RoOyBpICsrICkge1xyXG5cclxuICAgICAgICB0cmFja3MucHVzaCggVEhSRUUuS2V5ZnJhbWVUcmFjay5wYXJzZSgganNvbi50cmFja3NbaV0gKS5zY2FsZSggMS4wIC8ganNvbi5mcHMgKSApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLkFuaW1hdGlvbkNsaXAoIGpzb24ubmFtZSwganNvbi5kdXJhdGlvbiwgdHJhY2tzICk7XHJcblxyXG59O1xyXG5cclxuXHJcbi8vIHBhcnNlIHRoZSBhbmltYXRpb24uaGllcmFyY2h5IGZvcm1hdFxyXG5USFJFRS5BbmltYXRpb25DbGlwLnBhcnNlQW5pbWF0aW9uID0gZnVuY3Rpb24oIGFuaW1hdGlvbiwgYm9uZXMsIG5vZGVOYW1lICkge1xyXG5cclxuICAgIGlmICggISBhbmltYXRpb24gKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvciggXCIgIG5vIGFuaW1hdGlvbiBpbiBKU09OTG9hZGVyIGRhdGFcIiApO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjb252ZXJ0VHJhY2sgPSBmdW5jdGlvbiggdHJhY2tOYW1lLCBhbmltYXRpb25LZXlzLCBwcm9wZXJ0eU5hbWUsIHRyYWNrVHlwZSwgYW5pbWF0aW9uS2V5VG9WYWx1ZUZ1bmMgKSB7XHJcblxyXG4gICAgICAgIHZhciBrZXlzID0gW107XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBrID0gMDsgayA8IGFuaW1hdGlvbktleXMubGVuZ3RoOyBrICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbktleSA9IGFuaW1hdGlvbktleXNba107XHJcblxyXG4gICAgICAgICAgICBpZiAoIGFuaW1hdGlvbktleVtwcm9wZXJ0eU5hbWVdICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKCB7IHRpbWU6IGFuaW1hdGlvbktleS50aW1lLCB2YWx1ZTogYW5pbWF0aW9uS2V5VG9WYWx1ZUZ1bmMoIGFuaW1hdGlvbktleSApIH0gKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIG9ubHkgcmV0dXJuIHRyYWNrIGlmIHRoZXJlIGFyZSBhY3R1YWxseSBrZXlzLlxyXG4gICAgICAgIGlmICgga2V5cy5sZW5ndGggPiAwICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmFja1R5cGUoIHRyYWNrTmFtZSwga2V5cyApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgdmFyIHRyYWNrcyA9IFtdO1xyXG5cclxuICAgIHZhciBjbGlwTmFtZSA9IGFuaW1hdGlvbi5uYW1lIHx8ICdkZWZhdWx0JztcclxuICAgIHZhciBkdXJhdGlvbiA9IGFuaW1hdGlvbi5sZW5ndGggfHwgLTE7IC8vIGF1dG9tYXRpYyBsZW5ndGggZGV0ZXJtaW5hdGlvbiBpbiBBbmltYXRpb25DbGlwLlxyXG4gICAgdmFyIGZwcyA9IGFuaW1hdGlvbi5mcHMgfHwgMzA7XHJcblxyXG4gICAgdmFyIGhpZXJhcmNoeVRyYWNrcyA9IGFuaW1hdGlvbi5oaWVyYXJjaHkgfHwgW107XHJcblxyXG4gICAgZm9yICggdmFyIGggPSAwOyBoIDwgaGllcmFyY2h5VHJhY2tzLmxlbmd0aDsgaCArKyApIHtcclxuXHJcbiAgICAgICAgdmFyIGFuaW1hdGlvbktleXMgPSBoaWVyYXJjaHlUcmFja3NbIGggXS5rZXlzO1xyXG5cclxuICAgICAgICAvLyBza2lwIGVtcHR5IHRyYWNrc1xyXG4gICAgICAgIGlmICggISBhbmltYXRpb25LZXlzIHx8IGFuaW1hdGlvbktleXMubGVuZ3RoID09IDAgKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcHJvY2VzcyBtb3JwaCB0YXJnZXRzIGluIGEgd2F5IGV4YWN0bHkgY29tcGF0aWJsZSB3aXRoIEFuaW1hdGlvbkhhbmRsZXIuaW5pdCggYW5pbWF0aW9uIClcclxuICAgICAgICBpZiAoIGFuaW1hdGlvbktleXNbMF0ubW9ycGhUYXJnZXRzICkge1xyXG5cclxuICAgICAgICAgICAgLy8gZmlndXJlIG91dCBhbGwgbW9ycGggdGFyZ2V0cyB1c2VkIGluIHRoaXMgdHJhY2tcclxuICAgICAgICAgICAgdmFyIG1vcnBoVGFyZ2V0TmFtZXMgPSB7fTtcclxuICAgICAgICAgICAgZm9yICggdmFyIGsgPSAwOyBrIDwgYW5pbWF0aW9uS2V5cy5sZW5ndGg7IGsgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBhbmltYXRpb25LZXlzW2tdLm1vcnBoVGFyZ2V0cyApIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgbSA9IDA7IG0gPCBhbmltYXRpb25LZXlzW2tdLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IG0gKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3JwaFRhcmdldE5hbWVzWyBhbmltYXRpb25LZXlzW2tdLm1vcnBoVGFyZ2V0c1ttXSBdID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gY3JlYXRlIGEgdHJhY2sgZm9yIGVhY2ggbW9ycGggdGFyZ2V0IHdpdGggYWxsIHplcm8gbW9ycGhUYXJnZXRJbmZsdWVuY2VzIGV4Y2VwdCBmb3IgdGhlIGtleXMgaW4gd2hpY2ggdGhlIG1vcnBoVGFyZ2V0IGlzIG5hbWVkLlxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgbW9ycGhUYXJnZXROYW1lIGluIG1vcnBoVGFyZ2V0TmFtZXMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgbSA9IDA7IG0gPCBhbmltYXRpb25LZXlzW2tdLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IG0gKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25LZXkgPSBhbmltYXRpb25LZXlzW2tdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZTogYW5pbWF0aW9uS2V5LnRpbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAoKCBhbmltYXRpb25LZXkubW9ycGhUYXJnZXQgPT09IG1vcnBoVGFyZ2V0TmFtZSApID8gMSA6IDAgKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0cmFja3MucHVzaCggbmV3IFRIUkVFLk51bWJlcktleWZyYW1lVHJhY2soIG5vZGVOYW1lICsgJy5tb3JwaFRhcmdldEluZmx1ZW5jZVsnICsgbW9ycGhUYXJnZXROYW1lICsgJ10nLCBrZXlzICkgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGR1cmF0aW9uID0gbW9ycGhUYXJnZXROYW1lcy5sZW5ndGggKiAoIGZwcyB8fCAxLjAgKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBib25lTmFtZSA9IG5vZGVOYW1lICsgJy5ib25lc1snICsgYm9uZXNbIGggXS5uYW1lICsgJ10nO1xyXG5cclxuICAgICAgICAgICAgLy8gdHJhY2sgY29udGFpbnMgcG9zaXRpb25zLi4uXHJcbiAgICAgICAgICAgIHZhciBwb3NpdGlvblRyYWNrID0gY29udmVydFRyYWNrKCBib25lTmFtZSArICcucG9zaXRpb24nLCBhbmltYXRpb25LZXlzLCAncG9zJywgVEhSRUUuVmVjdG9yS2V5ZnJhbWVUcmFjaywgZnVuY3Rpb24oIGFuaW1hdGlvbktleSApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMygpLmZyb21BcnJheSggYW5pbWF0aW9uS2V5LnBvcyApXHJcbiAgICAgICAgICAgIH0gKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggcG9zaXRpb25UcmFjayApIHRyYWNrcy5wdXNoKCBwb3NpdGlvblRyYWNrICk7XHJcblxyXG4gICAgICAgICAgICAvLyB0cmFjayBjb250YWlucyBxdWF0ZXJuaW9ucy4uLlxyXG4gICAgICAgICAgICB2YXIgcXVhdGVybmlvblRyYWNrID0gY29udmVydFRyYWNrKCBib25lTmFtZSArICcucXVhdGVybmlvbicsIGFuaW1hdGlvbktleXMsICdyb3QnLCBUSFJFRS5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaywgZnVuY3Rpb24oIGFuaW1hdGlvbktleSApIHtcclxuICAgICAgICAgICAgICAgIGlmICggYW5pbWF0aW9uS2V5LnJvdC5zbGVycCApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYW5pbWF0aW9uS2V5LnJvdC5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRIUkVFLlF1YXRlcm5pb24oKS5mcm9tQXJyYXkoIGFuaW1hdGlvbktleS5yb3QgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBxdWF0ZXJuaW9uVHJhY2sgKSB0cmFja3MucHVzaCggcXVhdGVybmlvblRyYWNrICk7XHJcblxyXG4gICAgICAgICAgICAvLyB0cmFjayBjb250YWlucyBxdWF0ZXJuaW9ucy4uLlxyXG4gICAgICAgICAgICB2YXIgc2NhbGVUcmFjayA9IGNvbnZlcnRUcmFjayggYm9uZU5hbWUgKyAnLnNjYWxlJywgYW5pbWF0aW9uS2V5cywgJ3NjbCcsIFRIUkVFLlZlY3RvcktleWZyYW1lVHJhY2ssIGZ1bmN0aW9uKCBhbmltYXRpb25LZXkgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoKS5mcm9tQXJyYXkoIGFuaW1hdGlvbktleS5zY2wgKVxyXG4gICAgICAgICAgICB9ICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHNjYWxlVHJhY2sgKSB0cmFja3MucHVzaCggc2NhbGVUcmFjayApO1xyXG5cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCB0cmFja3MubGVuZ3RoID09PSAwICkge1xyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNsaXAgPSBuZXcgVEhSRUUuQW5pbWF0aW9uQ2xpcCggY2xpcE5hbWUsIGR1cmF0aW9uLCB0cmFja3MgKTtcclxuXHJcbiAgICByZXR1cm4gY2xpcDtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9hbmltYXRpb24vQW5pbWF0aW9uTWl4ZXIuanNcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBNaXhlcyB0b2dldGhlciB0aGUgQW5pbWF0aW9uQ2xpcHMgc2NoZWR1bGVkIGJ5IEFuaW1hdGlvbkFjdGlvbnMgYW5kIGFwcGxpZXMgdGhlbSB0byB0aGUgcm9vdCBhbmQgc3VidHJlZVxyXG4gKlxyXG4gKlxyXG4gKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xyXG4gKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cclxuICovXHJcblxyXG5USFJFRS5BbmltYXRpb25NaXhlciA9IGZ1bmN0aW9uKCByb290ICkge1xyXG5cclxuICAgIHRoaXMucm9vdCA9IHJvb3Q7XHJcbiAgICB0aGlzLnRpbWUgPSAwO1xyXG4gICAgdGhpcy50aW1lU2NhbGUgPSAxLjA7XHJcbiAgICB0aGlzLmFjdGlvbnMgPSBbXTtcclxuICAgIHRoaXMucHJvcGVydHlCaW5kaW5nTWFwID0ge307XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQW5pbWF0aW9uTWl4ZXIucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5BbmltYXRpb25NaXhlcixcclxuXHJcbiAgICBhZGRBY3Rpb246IGZ1bmN0aW9uKCBhY3Rpb24gKSB7XHJcblxyXG4gICAgICAgIC8vIFRPRE86IGNoZWNrIGZvciBkdXBsaWNhdGUgYWN0aW9uIG5hbWVzPyAgT3IgcHJvdmlkZSBlYWNoIGFjdGlvbiB3aXRoIGEgVVVJRD9cclxuXHJcbiAgICAgICAgdGhpcy5hY3Rpb25zLnB1c2goIGFjdGlvbiApO1xyXG4gICAgICAgIGFjdGlvbi5pbml0KCB0aGlzLnRpbWUgKTtcclxuICAgICAgICBhY3Rpb24ubWl4ZXIgPSB0aGlzO1xyXG5cclxuICAgICAgICB2YXIgdHJhY2tzID0gYWN0aW9uLmNsaXAudHJhY2tzO1xyXG5cclxuICAgICAgICB2YXIgcm9vdCA9IGFjdGlvbi5sb2NhbFJvb3QgfHwgdGhpcy5yb290O1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHRyYWNrID0gdHJhY2tzWyBpIF07XHJcblxyXG4gICAgICAgICAgICB2YXIgcHJvcGVydHlCaW5kaW5nS2V5ID0gcm9vdC51dWlkICsgJy0nICsgdHJhY2submFtZTtcclxuICAgICAgICAgICAgdmFyIHByb3BlcnR5QmluZGluZyA9IHRoaXMucHJvcGVydHlCaW5kaW5nTWFwWyBwcm9wZXJ0eUJpbmRpbmdLZXkgXTtcclxuXHJcbiAgICAgICAgICAgIGlmICggcHJvcGVydHlCaW5kaW5nID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcHJvcGVydHlCaW5kaW5nID0gbmV3IFRIUkVFLlByb3BlcnR5QmluZGluZyggcm9vdCwgdHJhY2submFtZSApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eUJpbmRpbmdNYXBbIHByb3BlcnR5QmluZGluZ0tleSBdID0gcHJvcGVydHlCaW5kaW5nO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gcHVzaCBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgdHJhY2tzLlxyXG4gICAgICAgICAgICBhY3Rpb24ucHJvcGVydHlCaW5kaW5ncy5wdXNoKCBwcm9wZXJ0eUJpbmRpbmcgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHRyYWNrIHVzYWdlcyBvZiBzaGFyZWQgcHJvcGVydHkgYmluZGluZ3MsIGJlY2F1c2UgaWYgd2UgbGVhdmUgdG9vIG1hbnkgYXJvdW5kLCB0aGUgbWl4ZXIgY2FuIGdldCBzbG93XHJcbiAgICAgICAgICAgIHByb3BlcnR5QmluZGluZy5yZWZlcmVuY2VDb3VudCArPSAxO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmVBbGxBY3Rpb25zOiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5hY3Rpb25zLmxlbmd0aDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uc1tpXS5taXhlciA9IG51bGw7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdW5iaW5kIGFsbCBwcm9wZXJ0eSBiaW5kaW5nc1xyXG4gICAgICAgIGZvciAoIHZhciBwcm9wZXJ5QmluZGluZ0tleSBpbiB0aGlzLnByb3BlcnR5QmluZGluZ01hcCApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydHlCaW5kaW5nTWFwWyBwcm9wZXJ5QmluZGluZ0tleSBdLnVuYmluZCgpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IFtdO1xyXG4gICAgICAgIHRoaXMucHJvcGVydHlCaW5kaW5nTWFwID0ge307XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlQWN0aW9uOiBmdW5jdGlvbiggYWN0aW9uICkge1xyXG5cclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmFjdGlvbnMuaW5kZXhPZiggYWN0aW9uICk7XHJcblxyXG4gICAgICAgIGlmICggaW5kZXggIT09IC0gMSApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5zcGxpY2UoIGluZGV4LCAxICk7XHJcbiAgICAgICAgICAgIGFjdGlvbi5taXhlciA9IG51bGw7XHJcblxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8vIHJlbW92ZSB1bnVzZWQgcHJvcGVydHkgYmluZGluZ3MgYmVjYXVzZSBpZiB3ZSBsZWF2ZSB0aGVtIGFyb3VuZCB0aGUgbWl4ZXIgY2FuIGdldCBzbG93XHJcbiAgICAgICAgdmFyIHJvb3QgPSBhY3Rpb24ubG9jYWxSb290IHx8IHRoaXMucm9vdDtcclxuICAgICAgICB2YXIgdHJhY2tzID0gYWN0aW9uLmNsaXAudHJhY2tzO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHRyYWNrID0gdHJhY2tzWyBpIF07XHJcblxyXG4gICAgICAgICAgICB2YXIgcHJvcGVydHlCaW5kaW5nS2V5ID0gcm9vdC51dWlkICsgJy0nICsgdHJhY2submFtZTtcclxuICAgICAgICAgICAgdmFyIHByb3BlcnR5QmluZGluZyA9IHRoaXMucHJvcGVydHlCaW5kaW5nTWFwWyBwcm9wZXJ0eUJpbmRpbmdLZXkgXTtcclxuXHJcbiAgICAgICAgICAgIHByb3BlcnR5QmluZGluZy5yZWZlcmVuY2VDb3VudCAtPSAxO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBwcm9wZXJ0eUJpbmRpbmcucmVmZXJlbmNlQ291bnQgPD0gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUJpbmRpbmcudW5iaW5kKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucHJvcGVydHlCaW5kaW5nTWFwWyBwcm9wZXJ0eUJpbmRpbmdLZXkgXTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLy8gY2FuIGJlIG9wdGltaXplZCBpZiBuZWVkZWRcclxuICAgIGZpbmRBY3Rpb25CeU5hbWU6IGZ1bmN0aW9uKCBuYW1lICkge1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmFjdGlvbnMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCB0aGlzLmFjdGlvbnNbaV0ubmFtZSA9PT0gbmFtZSApIHJldHVybiB0aGlzLmFjdGlvbnNbaV07XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBwbGF5OiBmdW5jdGlvbiggYWN0aW9uLCBvcHRpb25hbEZhZGVJbkR1cmF0aW9uICkge1xyXG5cclxuICAgICAgICBhY3Rpb24uc3RhcnRUaW1lID0gdGhpcy50aW1lO1xyXG4gICAgICAgIHRoaXMuYWRkQWN0aW9uKCBhY3Rpb24gKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBmYWRlT3V0OiBmdW5jdGlvbiggYWN0aW9uLCBkdXJhdGlvbiApIHtcclxuXHJcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcclxuXHJcbiAgICAgICAga2V5cy5wdXNoKCB7IHRpbWU6IHRoaXMudGltZSwgdmFsdWU6IDEgfSApO1xyXG4gICAgICAgIGtleXMucHVzaCggeyB0aW1lOiB0aGlzLnRpbWUgKyBkdXJhdGlvbiwgdmFsdWU6IDAgfSApO1xyXG5cclxuICAgICAgICBhY3Rpb24ud2VpZ2h0ID0gbmV3IFRIUkVFLk51bWJlcktleWZyYW1lVHJhY2soIFwid2VpZ2h0XCIsIGtleXMgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBmYWRlSW46IGZ1bmN0aW9uKCBhY3Rpb24sIGR1cmF0aW9uICkge1xyXG5cclxuICAgICAgICB2YXIga2V5cyA9IFtdO1xyXG5cclxuICAgICAgICBrZXlzLnB1c2goIHsgdGltZTogdGhpcy50aW1lLCB2YWx1ZTogMCB9ICk7XHJcbiAgICAgICAga2V5cy5wdXNoKCB7IHRpbWU6IHRoaXMudGltZSArIGR1cmF0aW9uLCB2YWx1ZTogMSB9ICk7XHJcblxyXG4gICAgICAgIGFjdGlvbi53ZWlnaHQgPSBuZXcgVEhSRUUuTnVtYmVyS2V5ZnJhbWVUcmFjayggXCJ3ZWlnaHRcIiwga2V5cyApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHdhcnA6IGZ1bmN0aW9uKCBhY3Rpb24sIHN0YXJ0VGltZVNjYWxlLCBlbmRUaW1lU2NhbGUsIGR1cmF0aW9uICkge1xyXG5cclxuICAgICAgICB2YXIga2V5cyA9IFtdO1xyXG5cclxuICAgICAgICBrZXlzLnB1c2goIHsgdGltZTogdGhpcy50aW1lLCB2YWx1ZTogc3RhcnRUaW1lU2NhbGUgfSApO1xyXG4gICAgICAgIGtleXMucHVzaCggeyB0aW1lOiB0aGlzLnRpbWUgKyBkdXJhdGlvbiwgdmFsdWU6IGVuZFRpbWVTY2FsZSB9ICk7XHJcblxyXG4gICAgICAgIGFjdGlvbi50aW1lU2NhbGUgPSBuZXcgVEhSRUUuTnVtYmVyS2V5ZnJhbWVUcmFjayggXCJ0aW1lU2NhbGVcIiwga2V5cyApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNyb3NzRmFkZTogZnVuY3Rpb24oIGZhZGVPdXRBY3Rpb24sIGZhZGVJbkFjdGlvbiwgZHVyYXRpb24sIHdhcnAgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuZmFkZU91dCggZmFkZU91dEFjdGlvbiwgZHVyYXRpb24gKTtcclxuICAgICAgICB0aGlzLmZhZGVJbiggZmFkZUluQWN0aW9uLCBkdXJhdGlvbiApO1xyXG5cclxuICAgICAgICBpZiAoIHdhcnAgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgc3RhcnRFbmRSYXRpbyA9IGZhZGVPdXRBY3Rpb24uY2xpcC5kdXJhdGlvbiAvIGZhZGVJbkFjdGlvbi5jbGlwLmR1cmF0aW9uO1xyXG4gICAgICAgICAgICB2YXIgZW5kU3RhcnRSYXRpbyA9IDEuMCAvIHN0YXJ0RW5kUmF0aW87XHJcblxyXG4gICAgICAgICAgICB0aGlzLndhcnAoIGZhZGVPdXRBY3Rpb24sIDEuMCwgc3RhcnRFbmRSYXRpbywgZHVyYXRpb24gKTtcclxuICAgICAgICAgICAgdGhpcy53YXJwKCBmYWRlSW5BY3Rpb24sIGVuZFN0YXJ0UmF0aW8sIDEuMCwgZHVyYXRpb24gKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24oIGRlbHRhVGltZSApIHtcclxuXHJcbiAgICAgICAgdmFyIG1peGVyRGVsdGFUaW1lID0gZGVsdGFUaW1lICogdGhpcy50aW1lU2NhbGU7XHJcbiAgICAgICAgdGhpcy50aW1lICs9IG1peGVyRGVsdGFUaW1lO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmFjdGlvbnMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGFjdGlvbiA9IHRoaXMuYWN0aW9uc1tpXTtcclxuXHJcbiAgICAgICAgICAgIHZhciB3ZWlnaHQgPSBhY3Rpb24uZ2V0V2VpZ2h0QXQoIHRoaXMudGltZSApO1xyXG5cclxuICAgICAgICAgICAgdmFyIGFjdGlvblRpbWVTY2FsZSA9IGFjdGlvbi5nZXRUaW1lU2NhbGVBdCggdGhpcy50aW1lICk7XHJcbiAgICAgICAgICAgIHZhciBhY3Rpb25EZWx0YVRpbWUgPSBtaXhlckRlbHRhVGltZSAqIGFjdGlvblRpbWVTY2FsZTtcclxuXHJcbiAgICAgICAgICAgIHZhciBhY3Rpb25SZXN1bHRzID0gYWN0aW9uLnVwZGF0ZSggYWN0aW9uRGVsdGFUaW1lICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGFjdGlvbi53ZWlnaHQgPD0gMCB8fCAhIGFjdGlvbi5lbmFibGVkICkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCBhY3Rpb25SZXN1bHRzLmxlbmd0aDsgaiArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGFjdGlvbi5jbGlwLnRyYWNrc1tqXS5uYW1lO1xyXG5cclxuICAgICAgICAgICAgICAgIGFjdGlvbi5wcm9wZXJ0eUJpbmRpbmdzWyBqIF0uYWNjdW11bGF0ZSggYWN0aW9uUmVzdWx0c1tqXSwgd2VpZ2h0ICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYXBwbHkgdG8gbm9kZXNcclxuICAgICAgICBmb3IgKCB2YXIgcHJvcGVydHlCaW5kaW5nS2V5IGluIHRoaXMucHJvcGVydHlCaW5kaW5nTWFwICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eUJpbmRpbmdNYXBbIHByb3BlcnR5QmluZGluZ0tleSBdLmFwcGx5KCk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLkFuaW1hdGlvbk1peGVyLnByb3RvdHlwZSApO1xyXG5cclxuLy8gRmlsZTpzcmMvYW5pbWF0aW9uL0FuaW1hdGlvblV0aWxzLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cclxuICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXHJcbiAqL1xyXG5cclxuVEhSRUUuQW5pbWF0aW9uVXRpbHMgPSB7XHJcblxyXG4gICAgZ2V0RXF1YWxzRnVuYzogZnVuY3Rpb24oIGV4ZW1wbGFyVmFsdWUgKSB7XHJcblxyXG4gICAgICAgIGlmICggZXhlbXBsYXJWYWx1ZS5lcXVhbHMgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBlcXVhbHNfb2JqZWN0KCBhLCBiICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuZXF1YWxzKCBiICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBlcXVhbHNfcHJpbWl0aXZlKCBhLCBiICkge1xyXG4gICAgICAgICAgICByZXR1cm4gKCBhID09PSBiICk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNsb25lOiBmdW5jdGlvbiggZXhlbXBsYXJWYWx1ZSApIHtcclxuXHJcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gdHlwZW9mIGV4ZW1wbGFyVmFsdWU7XHJcbiAgICAgICAgaWYgKCB0eXBlTmFtZSA9PT0gXCJvYmplY3RcIiApIHtcclxuICAgICAgICAgICAgaWYgKCBleGVtcGxhclZhbHVlLmNsb25lICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4ZW1wbGFyVmFsdWUuY2xvbmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCBcImNhbiBub3QgZmlndXJlIG91dCBob3cgdG8gY29weSBleGVtcGxhclZhbHVlXCIsIGV4ZW1wbGFyVmFsdWUgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBleGVtcGxhclZhbHVlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbGVycDogZnVuY3Rpb24oIGEsIGIsIGFscGhhLCBpbnRlclRyYWNrICkge1xyXG5cclxuICAgICAgICB2YXIgbGVycEZ1bmMgPSBUSFJFRS5BbmltYXRpb25VdGlscy5nZXRMZXJwRnVuYyggYSwgaW50ZXJUcmFjayApO1xyXG5cclxuICAgICAgICByZXR1cm4gbGVycEZ1bmMoIGEsIGIsIGFscGhhICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBsZXJwX29iamVjdDogZnVuY3Rpb24oIGEsIGIsIGFscGhhICkge1xyXG4gICAgICAgIHJldHVybiBhLmxlcnAoIGIsIGFscGhhICk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNsZXJwX29iamVjdDogZnVuY3Rpb24oIGEsIGIsIGFscGhhICkge1xyXG4gICAgICAgIHJldHVybiBhLnNsZXJwKCBiLCBhbHBoYSApO1xyXG4gICAgfSxcclxuXHJcbiAgICBsZXJwX251bWJlcjogZnVuY3Rpb24oIGEsIGIsIGFscGhhICkge1xyXG4gICAgICAgIHJldHVybiBhICogKCAxIC0gYWxwaGEgKSArIGIgKiBhbHBoYTtcclxuICAgIH0sXHJcblxyXG4gICAgbGVycF9ib29sZWFuOiBmdW5jdGlvbiggYSwgYiwgYWxwaGEgKSB7XHJcbiAgICAgICAgcmV0dXJuICggYWxwaGEgPCAwLjUgKSA/IGEgOiBiO1xyXG4gICAgfSxcclxuXHJcbiAgICBsZXJwX2Jvb2xlYW5faW1tZWRpYXRlOiBmdW5jdGlvbiggYSwgYiwgYWxwaGEgKSB7XHJcbiAgICAgICAgcmV0dXJuIGE7XHJcbiAgICB9LFxyXG5cclxuICAgIGxlcnBfc3RyaW5nOiBmdW5jdGlvbiggYSwgYiwgYWxwaGEgKSB7XHJcbiAgICAgICAgcmV0dXJuICggYWxwaGEgPCAwLjUgKSA/IGEgOiBiO1xyXG4gICAgfSxcclxuXHJcbiAgICBsZXJwX3N0cmluZ19pbW1lZGlhdGU6IGZ1bmN0aW9uKCBhLCBiLCBhbHBoYSApIHtcclxuICAgICAgICByZXR1cm4gYTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gTk9URTogdGhpcyBpcyBhbiBhY2N1bXVsYXRvciBmdW5jdGlvbiB0aGF0IG1vZGlmaWVzIHRoZSBmaXJzdCBhcmd1bWVudCAoZS5nLiBhKS5cdFRoaXMgaXMgdG8gbWluaW1pemUgbWVtb3J5IGFsb2NhdGlvbnMuXHJcbiAgICBnZXRMZXJwRnVuYzogZnVuY3Rpb24oIGV4ZW1wbGFyVmFsdWUsIGludGVyVHJhY2sgKSB7XHJcblxyXG4gICAgICAgIGlmICggZXhlbXBsYXJWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGV4ZW1wbGFyVmFsdWUgPT09IG51bGwgKSB0aHJvdyBuZXcgRXJyb3IoIFwiZXhhbXBsYXJWYWx1ZSBpcyBudWxsXCIgKTtcclxuXHJcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gdHlwZW9mIGV4ZW1wbGFyVmFsdWU7XHJcblxyXG4gICAgICAgIHN3aXRjaCggdHlwZU5hbWUgKSB7XHJcblxyXG4gICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XHJcbiAgICAgICAgICAgICAgICBpZiAoIGV4ZW1wbGFyVmFsdWUubGVycCApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVEhSRUUuQW5pbWF0aW9uVXRpbHMubGVycF9vYmplY3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBleGVtcGxhclZhbHVlLnNsZXJwICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUSFJFRS5BbmltYXRpb25VdGlscy5zbGVycF9vYmplY3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBUSFJFRS5BbmltYXRpb25VdGlscy5sZXJwX251bWJlcjtcclxuXHJcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XHJcbiAgICAgICAgICAgICAgICBpZiAoIGludGVyVHJhY2sgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRIUkVFLkFuaW1hdGlvblV0aWxzLmxlcnBfYm9vbGVhbjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRIUkVFLkFuaW1hdGlvblV0aWxzLmxlcnBfYm9vbGVhbl9pbW1lZGlhdGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XHJcbiAgICAgICAgICAgICAgICBpZiAoIGludGVyVHJhY2sgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRIUkVFLkFuaW1hdGlvblV0aWxzLmxlcnBfc3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVEhSRUUuQW5pbWF0aW9uVXRpbHMubGVycF9zdHJpbmdfaW1tZWRpYXRlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2FuaW1hdGlvbi9LZXlmcmFtZVRyYWNrLmpzXHJcblxyXG4vKipcclxuICpcclxuICogQSBUcmFjayB0aGF0IHJldHVybnMgYSBrZXlmcmFtZSBpbnRlcnBvbGF0ZWQgdmFsdWUsIGN1cnJlbnRseSBsaW5lYXJseSBpbnRlcnBvbGF0ZWRcclxuICpcclxuICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cclxuICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXHJcbiAqL1xyXG5cclxuVEhSRUUuS2V5ZnJhbWVUcmFjayA9IGZ1bmN0aW9uICggbmFtZSwga2V5cyApIHtcclxuXHJcbiAgICBpZiAoIG5hbWUgPT09IHVuZGVmaW5lZCApIHRocm93IG5ldyBFcnJvciggXCJ0cmFjayBuYW1lIGlzIHVuZGVmaW5lZFwiICk7XHJcbiAgICBpZiAoIGtleXMgPT09IHVuZGVmaW5lZCB8fCBrZXlzLmxlbmd0aCA9PT0gMCApIHRocm93IG5ldyBFcnJvciggXCJubyBrZXlzIGluIHRyYWNrIG5hbWVkIFwiICsgbmFtZSApO1xyXG5cclxuICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICB0aGlzLmtleXMgPSBrZXlzO1x0Ly8gdGltZSBpbiBzZWNvbmRzLCB2YWx1ZSBhcyB2YWx1ZVxyXG5cclxuICAgIC8vIHRoZSBpbmRleCBvZiB0aGUgbGFzdCByZXN1bHQsIHVzZWQgYXMgYSBzdGFydGluZyBwb2ludCBmb3IgbG9jYWwgc2VhcmNoLlxyXG4gICAgdGhpcy5sYXN0SW5kZXggPSAwO1xyXG5cclxuICAgIHRoaXMudmFsaWRhdGUoKTtcclxuICAgIHRoaXMub3B0aW1pemUoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuS2V5ZnJhbWVUcmFjayxcclxuXHJcbiAgICBnZXRBdDogZnVuY3Rpb24oIHRpbWUgKSB7XHJcblxyXG5cclxuICAgICAgICAvLyB0aGlzIGNhbiBub3QgZ28gaGlnaGVyIHRoYW4gdGhpcy5rZXlzLmxlbmd0aC5cclxuICAgICAgICB3aGlsZSggKCB0aGlzLmxhc3RJbmRleCA8IHRoaXMua2V5cy5sZW5ndGggKSAmJiAoIHRpbWUgPj0gdGhpcy5rZXlzW3RoaXMubGFzdEluZGV4XS50aW1lICkgKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdEluZGV4ICsrO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIHRoaXMgY2FuIG5vdCBnbyBsb3dlciB0aGFuIDAuXHJcbiAgICAgICAgd2hpbGUoICggdGhpcy5sYXN0SW5kZXggPiAwICkgJiYgKCB0aW1lIDwgdGhpcy5rZXlzW3RoaXMubGFzdEluZGV4IC0gMV0udGltZSApICkge1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RJbmRleCAtLTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5sYXN0SW5kZXggPj0gdGhpcy5rZXlzLmxlbmd0aCApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2V0UmVzdWx0KCB0aGlzLmtleXNbIHRoaXMua2V5cy5sZW5ndGggLSAxIF0udmFsdWUgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIHRoaXMubGFzdEluZGV4ID09PSAwICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zZXRSZXN1bHQoIHRoaXMua2V5c1sgMCBdLnZhbHVlICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQ7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHByZXZLZXkgPSB0aGlzLmtleXNbIHRoaXMubGFzdEluZGV4IC0gMSBdO1xyXG4gICAgICAgIHRoaXMuc2V0UmVzdWx0KCBwcmV2S2V5LnZhbHVlICk7XHJcblxyXG4gICAgICAgIC8vIGlmIHRydWUsIG1lYW5zIHRoYXQgcHJldi9jdXJyZW50IGtleXMgYXJlIGlkZW50aWNhbCwgdGh1cyBubyBpbnRlcnBvbGF0aW9uIHJlcXVpcmVkLlxyXG4gICAgICAgIGlmICggcHJldktleS5jb25zdGFudFRvTmV4dCApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBsaW5lYXIgaW50ZXJwb2xhdGlvbiB0byBzdGFydCB3aXRoXHJcbiAgICAgICAgdmFyIGN1cnJlbnRLZXkgPSB0aGlzLmtleXNbIHRoaXMubGFzdEluZGV4IF07XHJcbiAgICAgICAgdmFyIGFscGhhID0gKCB0aW1lIC0gcHJldktleS50aW1lICkgLyAoIGN1cnJlbnRLZXkudGltZSAtIHByZXZLZXkudGltZSApO1xyXG4gICAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5sZXJwVmFsdWVzKCB0aGlzLnJlc3VsdCwgY3VycmVudEtleS52YWx1ZSwgYWxwaGEgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLy8gbW92ZSBhbGwga2V5ZnJhbWVzIGVpdGhlciBmb3J3YXJkcyBvciBiYWNrd2FyZHMgaW4gdGltZVxyXG4gICAgc2hpZnQ6IGZ1bmN0aW9uKCB0aW1lT2Zmc2V0ICkge1xyXG5cclxuICAgICAgICBpZiAoIHRpbWVPZmZzZXQgIT09IDAuMCApIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMua2V5cy5sZW5ndGg7IGkgKysgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmtleXNbaV0udGltZSArPSB0aW1lT2Zmc2V0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBzY2FsZSBhbGwga2V5ZnJhbWUgdGltZXMgYnkgYSBmYWN0b3IgKHVzZWZ1bCBmb3IgZnJhbWUgPC0+IHNlY29uZHMgY29udmVyc2lvbnMpXHJcbiAgICBzY2FsZTogZnVuY3Rpb24oIHRpbWVTY2FsZSApIHtcclxuXHJcbiAgICAgICAgaWYgKCB0aW1lU2NhbGUgIT09IDEuMCApIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMua2V5cy5sZW5ndGg7IGkgKysgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmtleXNbaV0udGltZSAqPSB0aW1lU2NhbGU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHJlbW92ZXMga2V5ZnJhbWVzIGJlZm9yZSBhbmQgYWZ0ZXIgYW5pbWF0aW9uIHdpdGhvdXQgY2hhbmdpbmcgYW55IHZhbHVlcyB3aXRoaW4gdGhlIHJhbmdlIFtzdGFydFRpbWUsIGVuZFRpbWVdLlxyXG4gICAgLy8gSU1QT1JUQU5UOiBXZSBkbyBub3Qgc2hpZnQgYXJvdW5kIGtleXMgdG8gdGhlIHN0YXJ0IG9mIHRoZSB0cmFjayB0aW1lLCBiZWNhdXNlIGZvciBpbnRlcnBvbGF0ZWQga2V5cyB0aGlzIHdpbGwgY2hhbmdlIHRoZWlyIHZhbHVlc1xyXG4gICAgdHJpbTogZnVuY3Rpb24oIHN0YXJ0VGltZSwgZW5kVGltZSApIHtcclxuXHJcbiAgICAgICAgdmFyIGZpcnN0S2V5c1RvUmVtb3ZlID0gMDtcclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDE7IGkgPCB0aGlzLmtleXMubGVuZ3RoOyBpICsrICkge1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMua2V5c1tpXSA8PSBzdGFydFRpbWUgKSB7XHJcbiAgICAgICAgICAgICAgICBmaXJzdEtleXNUb1JlbW92ZSArKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGxhc3RLZXlzVG9SZW1vdmUgPSAwO1xyXG4gICAgICAgIGZvciAoIHZhciBpID0gdGhpcy5rZXlzLmxlbmd0aCAtIDI7IGkgPiAwOyBpICsrICkge1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMua2V5c1tpXSA+PSBlbmRUaW1lICkge1xyXG4gICAgICAgICAgICAgICAgbGFzdEtleXNUb1JlbW92ZSArKztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyByZW1vdmUgbGFzdCBrZXlzIGZpcnN0IGJlY2F1c2UgaXQgZG9lc24ndCBhZmZlY3QgdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBrZXlzICh0aGUgb3RoZXJ3YXkgYXJvdW5kIGRvZXNuJ3Qgd29yayBhcyBlYXNpbHkpXHJcbiAgICAgICAgaWYgKCAoIGZpcnN0S2V5c1RvUmVtb3ZlICsgbGFzdEtleXNUb1JlbW92ZSApID4gMCApIHtcclxuICAgICAgICAgICAgdGhpcy5rZXlzID0gdGhpcy5rZXlzLnNwbGljZSggZmlyc3RLZXlzVG9SZW1vdmUsIHRoaXMua2V5cy5sZW5ndGggLSBsYXN0S2V5c1RvUmVtb3ZlIC0gZmlyc3RLZXlzVG9SZW1vdmUgKTs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qIE5PVEU6IFRoaXMgaXMgY29tbWVudGVkIG91dCBiZWNhdXNlIHdlIHJlYWxseSBzaG91bGRuJ3QgaGF2ZSB0byBoYW5kbGUgdW5zb3J0ZWQga2V5IGxpc3RzXHJcbiAgICAgVHJhY2tzIHdpdGggb3V0IG9mIG9yZGVyIGtleXMgc2hvdWxkIGJlIGNvbnNpZGVyZWQgdG8gYmUgaW52YWxpZC4gIC0gYmhvdXN0b25cclxuICAgICBzb3J0OiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgdGhpcy5rZXlzLnNvcnQoIFRIUkVFLktleWZyYW1lVHJhY2sua2V5Q29tcGFyZXIgKTtcclxuXHJcbiAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgIH0sKi9cclxuXHJcbiAgICAvLyBlbnN1cmUgd2UgZG8gbm90IGdldCBhIEdhcmJhZ2VJbkdhcmJhZ2VPdXQgc2l0dWF0aW9uLCBtYWtlIHN1cmUgdHJhY2tzIGFyZSBhdCBsZWFzdCBtaW5pbWFsbHkgdmlhYmxlXHJcbiAgICAvLyBPbmUgY291bGQgZXZlbnR1YWxseSBlbnN1cmUgdGhhdCBhbGwga2V5LnZhbHVlcyBpbiBhIHRyYWNrIGFyZSBhbGwgb2YgdGhlIHNhbWUgdHlwZSAob3RoZXJ3aXNlIGludGVycG9sYXRpb24gbWFrZXMgbm8gc2Vuc2UuKVxyXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICB2YXIgcHJldktleSA9IG51bGw7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5rZXlzLmxlbmd0aCA9PT0gMCApIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggXCIgIHRyYWNrIGlzIGVtcHR5LCBubyBrZXlzXCIsIHRoaXMgKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5rZXlzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBjdXJyS2V5ID0gdGhpcy5rZXlzW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKCAhIGN1cnJLZXkgKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCBcIiAga2V5IGlzIG51bGwgaW4gdHJhY2tcIiwgdGhpcywgaSApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoICggdHlwZW9mIGN1cnJLZXkudGltZSApICE9PSAnbnVtYmVyJyB8fCBpc05hTiggY3VycktleS50aW1lICkgKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCBcIiAga2V5LnRpbWUgaXMgbm90IGEgdmFsaWQgbnVtYmVyXCIsIHRoaXMsIGksIGN1cnJLZXkgKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBjdXJyS2V5LnZhbHVlID09PSB1bmRlZmluZWQgfHwgY3VycktleS52YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvciggXCIgIGtleS52YWx1ZSBpcyBudWxsIGluIHRyYWNrXCIsIHRoaXMsIGksIGN1cnJLZXkgKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBwcmV2S2V5ICYmIHByZXZLZXkudGltZSA+IGN1cnJLZXkudGltZSApIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoIFwiICBrZXkudGltZSBpcyBsZXNzIHRoYW4gcHJldmlvdXMga2V5IHRpbWUsIG91dCBvZiBvcmRlciBrZXlzXCIsIHRoaXMsIGksIGN1cnJLZXksIHByZXZLZXkgKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHJldktleSA9IGN1cnJLZXk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBjdXJyZW50bHkgb25seSByZW1vdmVzIGVxdWl2YWxlbnQgc2VxdWVudGlhbCBrZXlzICgwLDAsMCwwLDEsMSwxLDAsMCwwLDAsMCwwLDApIC0tPiAoMCwwLDEsMSwwLDApLCB3aGljaCBhcmUgY29tbW9uIGluIG1vcnBoIHRhcmdldCBhbmltYXRpb25zXHJcbiAgICBvcHRpbWl6ZTogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHZhciBuZXdLZXlzID0gW107XHJcbiAgICAgICAgdmFyIHByZXZLZXkgPSB0aGlzLmtleXNbMF07XHJcbiAgICAgICAgbmV3S2V5cy5wdXNoKCBwcmV2S2V5ICk7XHJcblxyXG4gICAgICAgIHZhciBlcXVhbHNGdW5jID0gVEhSRUUuQW5pbWF0aW9uVXRpbHMuZ2V0RXF1YWxzRnVuYyggcHJldktleS52YWx1ZSApO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDE7IGkgPCB0aGlzLmtleXMubGVuZ3RoIC0gMTsgaSArKyApIHtcclxuICAgICAgICAgICAgdmFyIGN1cnJLZXkgPSB0aGlzLmtleXNbaV07XHJcbiAgICAgICAgICAgIHZhciBuZXh0S2V5ID0gdGhpcy5rZXlzW2krMV07XHJcblxyXG4gICAgICAgICAgICAvLyBpZiBwcmV2S2V5ICYgY3VycktleSBhcmUgdGhlIHNhbWUgdGltZSwgcmVtb3ZlIGN1cnJLZXkuICBJZiB5b3Ugd2FudCBpbW1lZGlhdGUgYWRqYWNlbnQga2V5cywgdXNlIGFuIGVwc2lsb24gb2Zmc2V0XHJcbiAgICAgICAgICAgIC8vIGl0IGlzIG5vdCBwb3NzaWJsZSB0byBoYXZlIHR3byBrZXlzIGF0IHRoZSBzYW1lIHRpbWUgYXMgd2Ugc29ydCB0aGVtLiAgVGhlIHNvcnQgaXMgbm90IHN0YWJsZSBvbiBrZXlzIHdpdGggdGhlIHNhbWUgdGltZS5cclxuICAgICAgICAgICAgaWYgKCAoIHByZXZLZXkudGltZSA9PT0gY3VycktleS50aW1lICkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyByZW1vdmUgY29tcGxldGVseSB1bm5lY2Vzc2FyeSBrZXlmcmFtZXMgdGhhdCBhcmUgdGhlIHNhbWUgYXMgdGhlaXIgcHJldiBhbmQgbmV4dCBrZXlzXHJcbiAgICAgICAgICAgIGlmICggdGhpcy5jb21wYXJlVmFsdWVzKCBwcmV2S2V5LnZhbHVlLCBjdXJyS2V5LnZhbHVlICkgJiYgdGhpcy5jb21wYXJlVmFsdWVzKCBjdXJyS2V5LnZhbHVlLCBuZXh0S2V5LnZhbHVlICkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgaWYgaW50ZXJwb2xhdGlvbiBpcyByZXF1aXJlZFxyXG4gICAgICAgICAgICBwcmV2S2V5LmNvbnN0YW50VG9OZXh0ID0gdGhpcy5jb21wYXJlVmFsdWVzKCBwcmV2S2V5LnZhbHVlLCBjdXJyS2V5LnZhbHVlICk7XHJcblxyXG4gICAgICAgICAgICBuZXdLZXlzLnB1c2goIGN1cnJLZXkgKTtcclxuICAgICAgICAgICAgcHJldktleSA9IGN1cnJLZXk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5ld0tleXMucHVzaCggdGhpcy5rZXlzWyB0aGlzLmtleXMubGVuZ3RoIC0gMSBdICk7XHJcblxyXG4gICAgICAgIHRoaXMua2V5cyA9IG5ld0tleXM7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5LZXlmcmFtZVRyYWNrLmtleUNvbXBhcmVyID0gZnVuY3Rpb24ga2V5Q29tcGFyYXRvcihrZXkwLCBrZXkxKSB7XHJcbiAgICByZXR1cm4ga2V5MC50aW1lIC0ga2V5MS50aW1lO1xyXG59O1xyXG5cclxuVEhSRUUuS2V5ZnJhbWVUcmFjay5wYXJzZSA9IGZ1bmN0aW9uKCBqc29uICkge1xyXG5cclxuICAgIGlmICgganNvbi50eXBlID09PSB1bmRlZmluZWQgKSB0aHJvdyBuZXcgRXJyb3IoIFwidHJhY2sgdHlwZSB1bmRlZmluZWQsIGNhbiBub3QgcGFyc2VcIiApO1xyXG5cclxuICAgIHZhciB0cmFja1R5cGUgPSBUSFJFRS5LZXlmcmFtZVRyYWNrLkdldFRyYWNrVHlwZUZvclR5cGVOYW1lKCBqc29uLnR5cGUgKTtcclxuXHJcbiAgICByZXR1cm4gdHJhY2tUeXBlLnBhcnNlKCBqc29uICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuS2V5ZnJhbWVUcmFjay5HZXRUcmFja1R5cGVGb3JUeXBlTmFtZSA9IGZ1bmN0aW9uKCB0eXBlTmFtZSApIHtcclxuICAgIHN3aXRjaCggdHlwZU5hbWUudG9Mb3dlckNhc2UoKSApIHtcclxuICAgICAgICBjYXNlIFwidmVjdG9yXCI6XHJcbiAgICAgICAgY2FzZSBcInZlY3RvcjJcIjpcclxuICAgICAgICBjYXNlIFwidmVjdG9yM1wiOlxyXG4gICAgICAgIGNhc2UgXCJ2ZWN0b3I0XCI6XHJcbiAgICAgICAgICAgIHJldHVybiBUSFJFRS5WZWN0b3JLZXlmcmFtZVRyYWNrO1xyXG5cclxuICAgICAgICBjYXNlIFwicXVhdGVybmlvblwiOlxyXG4gICAgICAgICAgICByZXR1cm4gVEhSRUUuUXVhdGVybmlvbktleWZyYW1lVHJhY2s7XHJcblxyXG4gICAgICAgIGNhc2UgXCJpbnRlZ2VyXCI6XHJcbiAgICAgICAgY2FzZSBcInNjYWxhclwiOlxyXG4gICAgICAgIGNhc2UgXCJkb3VibGVcIjpcclxuICAgICAgICBjYXNlIFwiZmxvYXRcIjpcclxuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBUSFJFRS5OdW1iZXJLZXlmcmFtZVRyYWNrO1xyXG5cclxuICAgICAgICBjYXNlIFwiYm9vbFwiOlxyXG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBUSFJFRS5Cb29sZWFuS2V5ZnJhbWVUcmFjaztcclxuXHJcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxyXG4gICAgICAgICAgICByZXR1cm4gVEhSRUUuU3RyaW5nS2V5ZnJhbWVUcmFjaztcclxuICAgIH07XHJcblxyXG4gICAgdGhyb3cgbmV3IEVycm9yKCBcIlVuc3VwcG9ydGVkIHR5cGVOYW1lOiBcIiArIHR5cGVOYW1lICk7XHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9hbmltYXRpb24vUHJvcGVydHlCaW5kaW5nLmpzXHJcblxyXG4vKipcclxuICpcclxuICogQSB0cmFjayBib3VuZCB0byBhIHJlYWwgdmFsdWUgaW4gdGhlIHNjZW5lIGdyYXBoLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xyXG4gKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cclxuICovXHJcblxyXG5USFJFRS5Qcm9wZXJ0eUJpbmRpbmcgPSBmdW5jdGlvbiAoIHJvb3ROb2RlLCB0cmFja05hbWUgKSB7XHJcblxyXG4gICAgdGhpcy5yb290Tm9kZSA9IHJvb3ROb2RlO1xyXG4gICAgdGhpcy50cmFja05hbWUgPSB0cmFja05hbWU7XHJcbiAgICB0aGlzLnJlZmVyZW5jZUNvdW50ID0gMDtcclxuICAgIHRoaXMub3JpZ2luYWxWYWx1ZSA9IG51bGw7IC8vIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgYmVmb3JlIGl0IHdhcyBjb250cm9sbGVkIGJ5IHRoaXMgYmluZGluZ1xyXG5cclxuICAgIHZhciBwYXJzZVJlc3VsdHMgPSBUSFJFRS5Qcm9wZXJ0eUJpbmRpbmcucGFyc2VUcmFja05hbWUoIHRyYWNrTmFtZSApO1xyXG5cclxuICAgIHRoaXMuZGlyZWN0b3J5TmFtZSA9IHBhcnNlUmVzdWx0cy5kaXJlY3RvcnlOYW1lO1xyXG4gICAgdGhpcy5ub2RlTmFtZSA9IHBhcnNlUmVzdWx0cy5ub2RlTmFtZTtcclxuICAgIHRoaXMub2JqZWN0TmFtZSA9IHBhcnNlUmVzdWx0cy5vYmplY3ROYW1lO1xyXG4gICAgdGhpcy5vYmplY3RJbmRleCA9IHBhcnNlUmVzdWx0cy5vYmplY3RJbmRleDtcclxuICAgIHRoaXMucHJvcGVydHlOYW1lID0gcGFyc2VSZXN1bHRzLnByb3BlcnR5TmFtZTtcclxuICAgIHRoaXMucHJvcGVydHlJbmRleCA9IHBhcnNlUmVzdWx0cy5wcm9wZXJ0eUluZGV4O1xyXG5cclxuICAgIHRoaXMubm9kZSA9IFRIUkVFLlByb3BlcnR5QmluZGluZy5maW5kTm9kZSggcm9vdE5vZGUsIHRoaXMubm9kZU5hbWUgKSB8fCByb290Tm9kZTtcclxuXHJcbiAgICB0aGlzLmN1bXVsYXRpdmVWYWx1ZSA9IG51bGw7XHJcbiAgICB0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSAwO1xyXG59O1xyXG5cclxuVEhSRUUuUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuUHJvcGVydHlCaW5kaW5nLFxyXG5cclxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgdGhpcy5jdW11bGF0aXZlVmFsdWUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY3VtdWxhdGl2ZVdlaWdodCA9IDA7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhY2N1bXVsYXRlOiBmdW5jdGlvbiggdmFsdWUsIHdlaWdodCApIHtcclxuXHJcbiAgICAgICAgaWYgKCAhIHRoaXMuaXNCb3VuZCApIHRoaXMuYmluZCgpO1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMuY3VtdWxhdGl2ZVdlaWdodCA9PT0gMCApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggd2VpZ2h0ID4gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMuY3VtdWxhdGl2ZVZhbHVlID09PSBudWxsICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VtdWxhdGl2ZVZhbHVlID0gVEhSRUUuQW5pbWF0aW9uVXRpbHMuY2xvbmUoIHZhbHVlICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSB3ZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbGVycEFscGhhID0gd2VpZ2h0IC8gKCB0aGlzLmN1bXVsYXRpdmVXZWlnaHQgKyB3ZWlnaHQgKTtcclxuICAgICAgICAgICAgdGhpcy5jdW11bGF0aXZlVmFsdWUgPSB0aGlzLmxlcnBWYWx1ZSggdGhpcy5jdW11bGF0aXZlVmFsdWUsIHZhbHVlLCBsZXJwQWxwaGEgKTtcclxuICAgICAgICAgICAgdGhpcy5jdW11bGF0aXZlV2VpZ2h0ICs9IHdlaWdodDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdW5iaW5kOiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgaWYgKCAhIHRoaXMuaXNCb3VuZCApIHJldHVybjtcclxuXHJcbiAgICAgICAgdGhpcy5zZXRWYWx1ZSggdGhpcy5vcmlnaW5hbFZhbHVlICk7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0VmFsdWUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZ2V0VmFsdWUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGVycFZhbHVlID0gbnVsbDtcclxuICAgICAgICB0aGlzLmVxdWFsc1ZhbHVlID0gbnVsbDtcclxuICAgICAgICB0aGlzLnRyaWdnZXJEaXJ0eSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pc0JvdW5kID0gZmFsc2U7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBiaW5kIHRvIHRoZSByZWFsIHByb3BlcnR5IGluIHRoZSBzY2VuZSBncmFwaCwgcmVtZW1iZXIgb3JpZ2luYWwgdmFsdWUsIG1lbW9yaXplIHZhcmlvdXMgYWNjZXNzb3JzIGZvciBzcGVlZC9pbmVmZmljaWVuY3lcclxuICAgIGJpbmQ6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMuaXNCb3VuZCApIHJldHVybjtcclxuXHJcbiAgICAgICAgdmFyIHRhcmdldE9iamVjdCA9IHRoaXMubm9kZTtcclxuXHJcbiAgICAgICAgLy8gZW5zdXJlIHRoZXJlIGlzIGEgdmFsdWUgbm9kZVxyXG4gICAgICAgIGlmICggISB0YXJnZXRPYmplY3QgKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoIFwiICB0cnlpbmcgdG8gdXBkYXRlIG5vZGUgZm9yIHRyYWNrOiBcIiArIHRoaXMudHJhY2tOYW1lICsgXCIgYnV0IGl0IHdhc24ndCBmb3VuZC5cIiApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIHRoaXMub2JqZWN0TmFtZSApIHtcclxuICAgICAgICAgICAgLy8gc3BlY2lhbCBjYXNlIHdlcmUgd2UgbmVlZCB0byByZWFjaCBkZWVwZXIgaW50byB0aGUgaGllcmFyY2h5IHRvIGdldCB0aGUgZmFjZSBtYXRlcmlhbHMuLi4uXHJcbiAgICAgICAgICAgIGlmICggdGhpcy5vYmplY3ROYW1lID09PSBcIm1hdGVyaWFsc1wiICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCAhIHRhcmdldE9iamVjdC5tYXRlcmlhbCApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnICBjYW4gbm90IGJpbmQgdG8gbWF0ZXJpYWwgYXMgbm9kZSBkb2VzIG5vdCBoYXZlIGEgbWF0ZXJpYWwnLCB0aGlzICk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCAhIHRhcmdldE9iamVjdC5tYXRlcmlhbC5tYXRlcmlhbHMgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvciggJyAgY2FuIG5vdCBiaW5kIHRvIG1hdGVyaWFsLm1hdGVyaWFscyBhcyBub2RlLm1hdGVyaWFsIGRvZXMgbm90IGhhdmUgYSBtYXRlcmlhbHMgYXJyYXknLCB0aGlzICk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0Lm1hdGVyaWFsLm1hdGVyaWFscztcclxuICAgICAgICAgICAgfSBlbHNlIGlmICggdGhpcy5vYmplY3ROYW1lID09PSBcImJvbmVzXCIgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoICEgdGFyZ2V0T2JqZWN0LnNrZWxldG9uICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICcgIGNhbiBub3QgYmluZCB0byBib25lcyBhcyBub2RlIGRvZXMgbm90IGhhdmUgYSBza2VsZXRvbicsIHRoaXMgKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBwb3RlbnRpYWwgZnV0dXJlIG9wdGltaXphdGlvbjogc2tpcCB0aGlzIGlmIHByb3BlcnR5SW5kZXggaXMgYWxyZWFkeSBhbiBpbnRlZ2VyLCBhbmQgY29udmVydCB0aGUgaW50ZWdlciBzdHJpbmcgdG8gYSB0cnVlIGludGVnZXIuXHJcblxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0LnNrZWxldG9uLmJvbmVzO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHN1cHBvcnQgcmVzb2x2aW5nIG1vcnBoVGFyZ2V0IG5hbWVzIGludG8gaW5kaWNlcy5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRhcmdldE9iamVjdC5sZW5ndGg7IGkgKysgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0YXJnZXRPYmplY3RbaV0ubmFtZSA9PT0gdGhpcy5vYmplY3RJbmRleCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmplY3RJbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHRhcmdldE9iamVjdFsgdGhpcy5vYmplY3ROYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnICBjYW4gbm90IGJpbmQgdG8gb2JqZWN0TmFtZSBvZiBub2RlLCB1bmRlZmluZWQnLCB0aGlzICk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0WyB0aGlzLm9iamVjdE5hbWUgXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCB0aGlzLm9iamVjdEluZGV4ICE9PSB1bmRlZmluZWQgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIHRhcmdldE9iamVjdFsgdGhpcy5vYmplY3RJbmRleCBdID09PSB1bmRlZmluZWQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvciggXCIgIHRyeWluZyB0byBiaW5kIHRvIG9iamVjdEluZGV4IG9mIG9iamVjdE5hbWUsIGJ1dCBpcyB1bmRlZmluZWQ6XCIsIHRoaXMsIHRhcmdldE9iamVjdCApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3RbIHRoaXMub2JqZWN0SW5kZXggXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZSBtYXBwaW5nc1xyXG4gICAgICAgIHZhciBub2RlUHJvcGVydHkgPSB0YXJnZXRPYmplY3RbIHRoaXMucHJvcGVydHlOYW1lIF07XHJcbiAgICAgICAgaWYgKCAhIG5vZGVQcm9wZXJ0eSApIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggXCIgIHRyeWluZyB0byB1cGRhdGUgcHJvcGVydHkgZm9yIHRyYWNrOiBcIiArIHRoaXMubm9kZU5hbWUgKyAnLicgKyB0aGlzLnByb3BlcnR5TmFtZSArIFwiIGJ1dCBpdCB3YXNuJ3QgZm91bmQuXCIsIHRhcmdldE9iamVjdCApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhY2Nlc3MgYSBzdWIgZWxlbWVudCBvZiB0aGUgcHJvcGVydHkgYXJyYXkgKG9ubHkgcHJpbWl0aXZlcyBhcmUgc3VwcG9ydGVkIHJpZ2h0IG5vdylcclxuICAgICAgICBpZiAoIHRoaXMucHJvcGVydHlJbmRleCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCB0aGlzLnByb3BlcnR5TmFtZSA9PT0gXCJtb3JwaFRhcmdldEluZmx1ZW5jZXNcIiApIHtcclxuICAgICAgICAgICAgICAgIC8vIHBvdGVudGlhbCBvcHRpbWl6YXRpb24sIHNraXAgdGhpcyBpZiBwcm9wZXJ0eUluZGV4IGlzIGFscmVhZHkgYW4gaW50ZWdlciwgYW5kIGNvbnZlcnQgdGhlIGludGVnZXIgc3RyaW5nIHRvIGEgdHJ1ZSBpbnRlZ2VyLlxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHN1cHBvcnQgcmVzb2x2aW5nIG1vcnBoVGFyZ2V0IG5hbWVzIGludG8gaW5kaWNlcy5cclxuICAgICAgICAgICAgICAgIGlmICggISB0YXJnZXRPYmplY3QuZ2VvbWV0cnkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvciggJyAgY2FuIG5vdCBiaW5kIHRvIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyBiZWNhc3VzZSBub2RlIGRvZXMgbm90IGhhdmUgYSBnZW9tZXRyeScsIHRoaXMgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICggISB0YXJnZXRPYmplY3QuZ2VvbWV0cnkubW9ycGhUYXJnZXRzICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICcgIGNhbiBub3QgYmluZCB0byBtb3JwaFRhcmdldEluZmx1ZW5jZXMgYmVjYXN1c2Ugbm9kZSBkb2VzIG5vdCBoYXZlIGEgZ2VvbWV0cnkubW9ycGhUYXJnZXRzJywgdGhpcyApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMubm9kZS5nZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoOyBpICsrICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggdGFyZ2V0T2JqZWN0Lmdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1tpXS5uYW1lID09PSB0aGlzLnByb3BlcnR5SW5kZXggKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydHlJbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZSA9IGZ1bmN0aW9uIHNldFZhbHVlX3Byb3BlcnR5SW5kZXhlZCggdmFsdWUgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoICEgdGhpcy5lcXVhbHNWYWx1ZSggbm9kZVByb3BlcnR5WyB0aGlzLnByb3BlcnR5SW5kZXggXSwgdmFsdWUgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlUHJvcGVydHlbIHRoaXMucHJvcGVydHlJbmRleCBdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB0aGlzLmdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWVfcHJvcGVydHlJbmRleGVkKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVQcm9wZXJ0eVsgdGhpcy5wcm9wZXJ0eUluZGV4IF07XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBtdXN0IHVzZSBjb3B5IGZvciBPYmplY3QzRC5FdWxlci9RdWF0ZXJuaW9uXHJcbiAgICAgICAgZWxzZSBpZiAoIG5vZGVQcm9wZXJ0eS5jb3B5ICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZSA9IGZ1bmN0aW9uIHNldFZhbHVlX3Byb3BlcnR5T2JqZWN0KCB2YWx1ZSApIHtcclxuICAgICAgICAgICAgICAgIGlmICggISB0aGlzLmVxdWFsc1ZhbHVlKCBub2RlUHJvcGVydHksIHZhbHVlICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZVByb3BlcnR5LmNvcHkoIHZhbHVlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZV9wcm9wZXJ0eU9iamVjdCgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlUHJvcGVydHk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBvdGhlcndpc2UganVzdCBzZXQgdGhlIHByb3BlcnR5IGRpcmVjdGx5IG9uIHRoZSBub2RlIChkbyBub3QgdXNlIG5vZGVQcm9wZXJ0eSBhcyBpdCBtYXkgbm90IGJlIGEgcmVmZXJlbmNlIG9iamVjdClcclxuICAgICAgICBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUgPSBmdW5jdGlvbiBzZXRWYWx1ZV9wcm9wZXJ0eSggdmFsdWUgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoICEgdGhpcy5lcXVhbHNWYWx1ZSggdGFyZ2V0T2JqZWN0WyB0aGlzLnByb3BlcnR5TmFtZSBdLCB2YWx1ZSApICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE9iamVjdFsgdGhpcy5wcm9wZXJ0eU5hbWUgXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWVfcHJvcGVydHkoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0T2JqZWN0WyB0aGlzLnByb3BlcnR5TmFtZSBdO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHRyaWdnZXIgbm9kZSBkaXJ0eVxyXG4gICAgICAgIGlmICggdGFyZ2V0T2JqZWN0Lm5lZWRzVXBkYXRlICE9PSB1bmRlZmluZWQgKSB7IC8vIG1hdGVyaWFsXHJcblxyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJEaXJ0eSA9IGZ1bmN0aW9uIHRyaWdnZXJEaXJ0eV9uZWVkc1VwZGF0ZSgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICggdGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgIT09IHVuZGVmaW5lZCApIHsgLy8gbm9kZSB0cmFuc2Zvcm1cclxuXHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckRpcnR5ID0gZnVuY3Rpb24gdHJpZ2dlckRpcnR5X21hdHJpeFdvcmxkTmVlZHNVcGRhdGUoKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRPYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm9yaWdpbmFsVmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XHJcblxyXG4gICAgICAgIHRoaXMuZXF1YWxzVmFsdWUgPSBUSFJFRS5BbmltYXRpb25VdGlscy5nZXRFcXVhbHNGdW5jKCB0aGlzLm9yaWdpbmFsVmFsdWUgKTtcclxuICAgICAgICB0aGlzLmxlcnBWYWx1ZSA9IFRIUkVFLkFuaW1hdGlvblV0aWxzLmdldExlcnBGdW5jKCB0aGlzLm9yaWdpbmFsVmFsdWUsIHRydWUgKTtcclxuXHJcbiAgICAgICAgdGhpcy5pc0JvdW5kID0gdHJ1ZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFwcGx5OiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgLy8gZm9yIHNwZWVkIGNhcHR1cmUgdGhlIHNldHRlciBwYXR0ZXJuIGFzIGEgY2xvc3VyZSAoc29ydCBvZiBhIG1lbW9pemF0aW9uIHBhdHRlcm46IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01lbW9pemF0aW9uKVxyXG4gICAgICAgIGlmICggISB0aGlzLmlzQm91bmQgKSB0aGlzLmJpbmQoKTtcclxuXHJcbiAgICAgICAgLy8gZWFybHkgZXhpdCBpZiB0aGVyZSBpcyBub3RoaW5nIHRvIGFwcGx5LlxyXG4gICAgICAgIGlmICggdGhpcy5jdW11bGF0aXZlV2VpZ2h0ID4gMCApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGJsZW5kIHdpdGggb3JpZ2luYWwgdmFsdWVcclxuICAgICAgICAgICAgaWYgKCB0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPCAxICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciByZW1haW5pbmdXZWlnaHQgPSAxIC0gdGhpcy5jdW11bGF0aXZlV2VpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGxlcnBBbHBoYSA9IHJlbWFpbmluZ1dlaWdodCAvICggdGhpcy5jdW11bGF0aXZlV2VpZ2h0ICsgcmVtYWluaW5nV2VpZ2h0ICk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1bXVsYXRpdmVWYWx1ZSA9IHRoaXMubGVycFZhbHVlKCB0aGlzLmN1bXVsYXRpdmVWYWx1ZSwgdGhpcy5vcmlnaW5hbFZhbHVlLCBsZXJwQWxwaGEgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB2YWx1ZUNoYW5nZWQgPSB0aGlzLnNldFZhbHVlKCB0aGlzLmN1bXVsYXRpdmVWYWx1ZSApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCB2YWx1ZUNoYW5nZWQgJiYgdGhpcy50cmlnZ2VyRGlydHkgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJEaXJ0eSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyByZXNldCBhY2N1bXVsYXRvclxyXG4gICAgICAgICAgICB0aGlzLmN1bXVsYXRpdmVWYWx1ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuY3VtdWxhdGl2ZVdlaWdodCA9IDA7XHJcblxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5cclxuVEhSRUUuUHJvcGVydHlCaW5kaW5nLnBhcnNlVHJhY2tOYW1lID0gZnVuY3Rpb24oIHRyYWNrTmFtZSApIHtcclxuXHJcbiAgICAvLyBtYXRjaGVzIHN0cmluZ3MgaW4gdGhlIGZvcm0gb2Y6XHJcbiAgICAvLyAgICBub2RlTmFtZS5wcm9wZXJ0eVxyXG4gICAgLy8gICAgbm9kZU5hbWUucHJvcGVydHlbYWNjZXNzb3JdXHJcbiAgICAvLyAgICBub2RlTmFtZS5tYXRlcmlhbC5wcm9wZXJ0eVthY2Nlc3Nvcl1cclxuICAgIC8vICAgIHV1aWQucHJvcGVydHlbYWNjZXNzb3JdXHJcbiAgICAvLyAgICB1dWlkLm9iamVjdE5hbWVbb2JqZWN0SW5kZXhdLnByb3BlcnR5TmFtZVtwcm9wZXJ0eUluZGV4XVxyXG4gICAgLy8gICAgcGFyZW50TmFtZS9ub2RlTmFtZS5wcm9wZXJ0eVxyXG4gICAgLy8gICAgcGFyZW50TmFtZS9wYXJlbnROYW1lL25vZGVOYW1lLnByb3BlcnR5W2luZGV4XVxyXG4gICAgLy9cdCAgLmJvbmVbQXJtYXR1cmUuREVGX2NvZ10ucG9zaXRpb25cclxuICAgIC8vIGNyZWF0ZWQgYW5kIHRlc3RlZCB2aWEgaHR0cHM6Ly9yZWdleDEwMS5jb20vI2phdmFzY3JpcHRcclxuXHJcbiAgICB2YXIgcmUgPSAvXigoW1xcd10rXFwvKSopKFtcXHctXFxkXSspPyhcXC4oW1xcd10rKShcXFsoW1xcd1xcZFxcW1xcXVxcXy4gXSspXFxdKT8pPyhcXC4oW1xcdy5dKykoXFxbKFtcXHdcXGRcXFtcXF1cXF8uIF0rKVxcXSk/KSQvO1xyXG4gICAgdmFyIG1hdGNoZXMgPSByZS5leGVjKHRyYWNrTmFtZSk7XHJcblxyXG4gICAgaWYgKCAhIG1hdGNoZXMgKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCBcImNhbm5vdCBwYXJzZSB0cmFja05hbWUgYXQgYWxsOiBcIiArIHRyYWNrTmFtZSApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChtYXRjaGVzLmluZGV4ID09PSByZS5sYXN0SW5kZXgpIHtcclxuICAgICAgICByZS5sYXN0SW5kZXgrKztcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcmVzdWx0cyA9IHtcclxuICAgICAgICBkaXJlY3RvcnlOYW1lOiBtYXRjaGVzWzFdLFxyXG4gICAgICAgIG5vZGVOYW1lOiBtYXRjaGVzWzNdLCBcdC8vIGFsbG93ZWQgdG8gYmUgbnVsbCwgc3BlY2lmaWVkIHJvb3Qgbm9kZS5cclxuICAgICAgICBvYmplY3ROYW1lOiBtYXRjaGVzWzVdLFxyXG4gICAgICAgIG9iamVjdEluZGV4OiBtYXRjaGVzWzddLFxyXG4gICAgICAgIHByb3BlcnR5TmFtZTogbWF0Y2hlc1s5XSxcclxuICAgICAgICBwcm9wZXJ0eUluZGV4OiBtYXRjaGVzWzExXVx0Ly8gYWxsb3dlZCB0byBiZSBudWxsLCBzcGVjaWZpZXMgdGhhdCB0aGUgd2hvbGUgcHJvcGVydHkgaXMgc2V0LlxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoIHJlc3VsdHMucHJvcGVydHlOYW1lID09PSBudWxsIHx8IHJlc3VsdHMucHJvcGVydHlOYW1lLmxlbmd0aCA9PT0gMCApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIFwiY2FuIG5vdCBwYXJzZSBwcm9wZXJ0eU5hbWUgZnJvbSB0cmFja05hbWU6IFwiICsgdHJhY2tOYW1lICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdHM7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUHJvcGVydHlCaW5kaW5nLmZpbmROb2RlID0gZnVuY3Rpb24oIHJvb3QsIG5vZGVOYW1lICkge1xyXG5cclxuICAgIGZ1bmN0aW9uIHNlYXJjaFNrZWxldG9uKCBza2VsZXRvbiApIHtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgc2tlbGV0b24uYm9uZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGJvbmUgPSBza2VsZXRvbi5ib25lc1tpXTtcclxuXHJcbiAgICAgICAgICAgIGlmICggYm9uZS5uYW1lID09PSBub2RlTmFtZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYm9uZTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZWFyY2hOb2RlU3VidHJlZSggY2hpbGRyZW4gKSB7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBjaGlsZHJlbltpXTtcclxuXHJcbiAgICAgICAgICAgIGlmICggY2hpbGROb2RlLm5hbWUgPT09IG5vZGVOYW1lIHx8IGNoaWxkTm9kZS51dWlkID09PSBub2RlTmFtZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGROb2RlO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHNlYXJjaE5vZGVTdWJ0cmVlKCBjaGlsZE5vZGUuY2hpbGRyZW4gKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggcmVzdWx0ICkgcmV0dXJuIHJlc3VsdDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy9cclxuXHJcbiAgICBpZiAoICEgbm9kZU5hbWUgfHwgbm9kZU5hbWUgPT09IFwiXCIgfHwgbm9kZU5hbWUgPT09IFwicm9vdFwiIHx8IG5vZGVOYW1lID09PSBcIi5cIiB8fCBub2RlTmFtZSA9PT0gLTEgfHwgbm9kZU5hbWUgPT09IHJvb3QubmFtZSB8fCBub2RlTmFtZSA9PT0gcm9vdC51dWlkICkge1xyXG5cclxuICAgICAgICByZXR1cm4gcm9vdDtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2VhcmNoIGludG8gc2tlbGV0b24gYm9uZXMuXHJcbiAgICBpZiAoIHJvb3Quc2tlbGV0b24gKSB7XHJcblxyXG4gICAgICAgIHZhciBib25lID0gc2VhcmNoU2tlbGV0b24oIHJvb3Quc2tlbGV0b24gKTtcclxuXHJcbiAgICAgICAgaWYgKCBib25lICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJvbmU7XHJcblxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBzZWFyY2ggaW50byBub2RlIHN1YnRyZWUuXHJcbiAgICBpZiAoIHJvb3QuY2hpbGRyZW4gKSB7XHJcblxyXG4gICAgICAgIHZhciBzdWJUcmVlTm9kZSA9IHNlYXJjaE5vZGVTdWJ0cmVlKCByb290LmNoaWxkcmVuICk7XHJcblxyXG4gICAgICAgIGlmICggc3ViVHJlZU5vZGUgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc3ViVHJlZU5vZGU7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbi8vIEZpbGU6c3JjL2FuaW1hdGlvbi90cmFja3MvVmVjdG9yS2V5ZnJhbWVUcmFjay5qc1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEEgVHJhY2sgdGhhdCBpbnRlcnBvbGF0ZXMgVmVjdG9yc1xyXG4gKlxyXG4gKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xyXG4gKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cclxuICovXHJcblxyXG5USFJFRS5WZWN0b3JLZXlmcmFtZVRyYWNrID0gZnVuY3Rpb24gKCBuYW1lLCBrZXlzICkge1xyXG5cclxuICAgIFRIUkVFLktleWZyYW1lVHJhY2suY2FsbCggdGhpcywgbmFtZSwga2V5cyApO1xyXG5cclxuICAgIC8vIGxvY2FsIGNhY2hlIG9mIHZhbHVlIHR5cGUgdG8gYXZvaWQgYWxsb2NhdGlvbnMgZHVyaW5nIHJ1bnRpbWUuXHJcbiAgICB0aGlzLnJlc3VsdCA9IHRoaXMua2V5c1swXS52YWx1ZS5jbG9uZSgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlZlY3RvcktleWZyYW1lVHJhY2sucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLlZlY3RvcktleWZyYW1lVHJhY2sucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuVmVjdG9yS2V5ZnJhbWVUcmFjaztcclxuXHJcblRIUkVFLlZlY3RvcktleWZyYW1lVHJhY2sucHJvdG90eXBlLnNldFJlc3VsdCA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcclxuXHJcbiAgICB0aGlzLnJlc3VsdC5jb3B5KCB2YWx1ZSApO1xyXG5cclxufTtcclxuXHJcbi8vIG1lbW9pemF0aW9uIG9mIHRoZSBsZXJwIGZ1bmN0aW9uIGZvciBzcGVlZC5cclxuLy8gTk9URTogRG8gbm90IG9wdGltaXplIGFzIGEgcHJvdG90eXBlIGluaXRpYWxpemF0aW9uIGNsb3N1cmUsIGFzIHZhbHVlMCB3aWxsIGJlIGRpZmZlcmVudCBvbiBhIHBlciBjbGFzcyBiYXNpcy5cclxuVEhSRUUuVmVjdG9yS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUubGVycFZhbHVlcyA9IGZ1bmN0aW9uKCB2YWx1ZTAsIHZhbHVlMSwgYWxwaGEgKSB7XHJcblxyXG4gICAgcmV0dXJuIHZhbHVlMC5sZXJwKCB2YWx1ZTEsIGFscGhhICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVmVjdG9yS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuY29tcGFyZVZhbHVlcyA9IGZ1bmN0aW9uKCB2YWx1ZTAsIHZhbHVlMSApIHtcclxuXHJcbiAgICByZXR1cm4gdmFsdWUwLmVxdWFscyggdmFsdWUxICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVmVjdG9yS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgY2xvbmVkS2V5cyA9IFtdO1xyXG5cclxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMua2V5cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIHZhciBrZXkgPSB0aGlzLmtleXNbaV07XHJcbiAgICAgICAgY2xvbmVkS2V5cy5wdXNoKCB7XHJcbiAgICAgICAgICAgIHRpbWU6IGtleS50aW1lLFxyXG4gICAgICAgICAgICB2YWx1ZToga2V5LnZhbHVlLmNsb25lKClcclxuICAgICAgICB9ICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3JLZXlmcmFtZVRyYWNrKCB0aGlzLm5hbWUsIGNsb25lZEtleXMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5WZWN0b3JLZXlmcmFtZVRyYWNrLnBhcnNlID0gZnVuY3Rpb24oIGpzb24gKSB7XHJcblxyXG4gICAgdmFyIGVsZW1lbnRDb3VudCA9IGpzb24ua2V5c1swXS52YWx1ZS5sZW5ndGg7XHJcbiAgICB2YXIgdmFsdWVUeXBlID0gVEhSRUVbICdWZWN0b3InICsgZWxlbWVudENvdW50IF07XHJcblxyXG4gICAgdmFyIGtleXMgPSBbXTtcclxuXHJcbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBqc29uLmtleXMubGVuZ3RoOyBpICsrICkge1xyXG4gICAgICAgIHZhciBqc29uS2V5ID0ganNvbi5rZXlzW2ldO1xyXG4gICAgICAgIGtleXMucHVzaCgge1xyXG4gICAgICAgICAgICB2YWx1ZTogbmV3IHZhbHVlVHlwZSgpLmZyb21BcnJheSgganNvbktleS52YWx1ZSApLFxyXG4gICAgICAgICAgICB0aW1lOiBqc29uS2V5LnRpbWVcclxuICAgICAgICB9ICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3JLZXlmcmFtZVRyYWNrKCBqc29uLm5hbWUsIGtleXMgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9hbmltYXRpb24vdHJhY2tzL1F1YXRlcm5pb25LZXlmcmFtZVRyYWNrLmpzXHJcblxyXG4vKipcclxuICpcclxuICogQSBUcmFjayB0aGF0IGludGVycG9sYXRlcyBRdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXHJcbiAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xyXG4gKi9cclxuXHJcblRIUkVFLlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrID0gZnVuY3Rpb24gKCBuYW1lLCBrZXlzICkge1xyXG5cclxuICAgIFRIUkVFLktleWZyYW1lVHJhY2suY2FsbCggdGhpcywgbmFtZSwga2V5cyApO1xyXG5cclxuICAgIC8vIGxvY2FsIGNhY2hlIG9mIHZhbHVlIHR5cGUgdG8gYXZvaWQgYWxsb2NhdGlvbnMgZHVyaW5nIHJ1bnRpbWUuXHJcbiAgICB0aGlzLnJlc3VsdCA9IHRoaXMua2V5c1swXS52YWx1ZS5jbG9uZSgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLktleWZyYW1lVHJhY2sucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaztcclxuXHJcblRIUkVFLlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5zZXRSZXN1bHQgPSBmdW5jdGlvbiggdmFsdWUgKSB7XHJcblxyXG4gICAgdGhpcy5yZXN1bHQuY29weSggdmFsdWUgKTtcclxuXHJcbn07XHJcblxyXG4vLyBtZW1vaXphdGlvbiBvZiB0aGUgbGVycCBmdW5jdGlvbiBmb3Igc3BlZWQuXHJcbi8vIE5PVEU6IERvIG5vdCBvcHRpbWl6ZSBhcyBhIHByb3RvdHlwZSBpbml0aWFsaXphdGlvbiBjbG9zdXJlLCBhcyB2YWx1ZTAgd2lsbCBiZSBkaWZmZXJlbnQgb24gYSBwZXIgY2xhc3MgYmFzaXMuXHJcblRIUkVFLlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5sZXJwVmFsdWVzID0gZnVuY3Rpb24oIHZhbHVlMCwgdmFsdWUxLCBhbHBoYSApIHtcclxuXHJcbiAgICByZXR1cm4gdmFsdWUwLnNsZXJwKCB2YWx1ZTEsIGFscGhhICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUXVhdGVybmlvbktleWZyYW1lVHJhY2sucHJvdG90eXBlLmNvbXBhcmVWYWx1ZXMgPSBmdW5jdGlvbiggdmFsdWUwLCB2YWx1ZTEgKSB7XHJcblxyXG4gICAgcmV0dXJuIHZhbHVlMC5lcXVhbHMoIHZhbHVlMSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uKCBxdWF0ICkge1xyXG5cclxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMua2V5cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIHRoaXMua2V5c1tpXS52YWx1ZS5tdWx0aXBseSggcXVhdCApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG5USFJFRS5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgY2xvbmVkS2V5cyA9IFtdO1xyXG5cclxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMua2V5cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIHZhciBrZXkgPSB0aGlzLmtleXNbaV07XHJcbiAgICAgICAgY2xvbmVkS2V5cy5wdXNoKCB7XHJcbiAgICAgICAgICAgIHRpbWU6IGtleS50aW1lLFxyXG4gICAgICAgICAgICB2YWx1ZToga2V5LnZhbHVlLmNsb25lKClcclxuICAgICAgICB9ICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjayggdGhpcy5uYW1lLCBjbG9uZWRLZXlzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUXVhdGVybmlvbktleWZyYW1lVHJhY2sucGFyc2UgPSBmdW5jdGlvbigganNvbiApIHtcclxuXHJcbiAgICB2YXIga2V5cyA9IFtdO1xyXG5cclxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGpzb24ua2V5cy5sZW5ndGg7IGkgKysgKSB7XHJcbiAgICAgICAgdmFyIGpzb25LZXkgPSBqc29uLmtleXNbaV07XHJcbiAgICAgICAga2V5cy5wdXNoKCB7XHJcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuUXVhdGVybmlvbigpLmZyb21BcnJheSgganNvbktleS52YWx1ZSApLFxyXG4gICAgICAgICAgICB0aW1lOiBqc29uS2V5LnRpbWVcclxuICAgICAgICB9ICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaygganNvbi5uYW1lLCBrZXlzICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvYW5pbWF0aW9uL3RyYWNrcy9TdHJpbmdLZXlmcmFtZVRyYWNrLmpzXHJcblxyXG4vKipcclxuICpcclxuICogQSBUcmFjayB0aGF0IGludGVycG9sYXRlcyBTdHJpbmdzXHJcbiAqXHJcbiAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXHJcbiAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xyXG4gKi9cclxuXHJcblRIUkVFLlN0cmluZ0tleWZyYW1lVHJhY2sgPSBmdW5jdGlvbiAoIG5hbWUsIGtleXMgKSB7XHJcblxyXG4gICAgVEhSRUUuS2V5ZnJhbWVUcmFjay5jYWxsKCB0aGlzLCBuYW1lLCBrZXlzICk7XHJcblxyXG4gICAgLy8gbG9jYWwgY2FjaGUgb2YgdmFsdWUgdHlwZSB0byBhdm9pZCBhbGxvY2F0aW9ucyBkdXJpbmcgcnVudGltZS5cclxuICAgIHRoaXMucmVzdWx0ID0gdGhpcy5rZXlzWzBdLnZhbHVlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlN0cmluZ0tleWZyYW1lVHJhY2sucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLlN0cmluZ0tleWZyYW1lVHJhY2sucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU3RyaW5nS2V5ZnJhbWVUcmFjaztcclxuXHJcblRIUkVFLlN0cmluZ0tleWZyYW1lVHJhY2sucHJvdG90eXBlLnNldFJlc3VsdCA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcclxuXHJcbiAgICB0aGlzLnJlc3VsdCA9IHZhbHVlO1xyXG5cclxufTtcclxuXHJcbi8vIG1lbW9pemF0aW9uIG9mIHRoZSBsZXJwIGZ1bmN0aW9uIGZvciBzcGVlZC5cclxuLy8gTk9URTogRG8gbm90IG9wdGltaXplIGFzIGEgcHJvdG90eXBlIGluaXRpYWxpemF0aW9uIGNsb3N1cmUsIGFzIHZhbHVlMCB3aWxsIGJlIGRpZmZlcmVudCBvbiBhIHBlciBjbGFzcyBiYXNpcy5cclxuVEhSRUUuU3RyaW5nS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUubGVycFZhbHVlcyA9IGZ1bmN0aW9uKCB2YWx1ZTAsIHZhbHVlMSwgYWxwaGEgKSB7XHJcblxyXG4gICAgcmV0dXJuICggYWxwaGEgPCAxLjAgKSA/IHZhbHVlMCA6IHZhbHVlMTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TdHJpbmdLZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5jb21wYXJlVmFsdWVzID0gZnVuY3Rpb24oIHZhbHVlMCwgdmFsdWUxICkge1xyXG5cclxuICAgIHJldHVybiAoIHZhbHVlMCA9PT0gdmFsdWUxICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU3RyaW5nS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgY2xvbmVkS2V5cyA9IFtdO1xyXG5cclxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMua2V5cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIHZhciBrZXkgPSB0aGlzLmtleXNbaV07XHJcbiAgICAgICAgY2xvbmVkS2V5cy5wdXNoKCB7XHJcbiAgICAgICAgICAgIHRpbWU6IGtleS50aW1lLFxyXG4gICAgICAgICAgICB2YWx1ZToga2V5LnZhbHVlXHJcbiAgICAgICAgfSApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuU3RyaW5nS2V5ZnJhbWVUcmFjayggdGhpcy5uYW1lLCBjbG9uZWRLZXlzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU3RyaW5nS2V5ZnJhbWVUcmFjay5wYXJzZSA9IGZ1bmN0aW9uKCBqc29uICkge1xyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuU3RyaW5nS2V5ZnJhbWVUcmFjaygganNvbi5uYW1lLCBqc29uLmtleXMgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9hbmltYXRpb24vdHJhY2tzL0Jvb2xlYW5LZXlmcmFtZVRyYWNrLmpzXHJcblxyXG4vKipcclxuICpcclxuICogQSBUcmFjayB0aGF0IGludGVycG9sYXRlcyBCb29sZWFuXHJcbiAqXHJcbiAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXHJcbiAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xyXG4gKi9cclxuXHJcblRIUkVFLkJvb2xlYW5LZXlmcmFtZVRyYWNrID0gZnVuY3Rpb24gKCBuYW1lLCBrZXlzICkge1xyXG5cclxuICAgIFRIUkVFLktleWZyYW1lVHJhY2suY2FsbCggdGhpcywgbmFtZSwga2V5cyApO1xyXG5cclxuICAgIC8vIGxvY2FsIGNhY2hlIG9mIHZhbHVlIHR5cGUgdG8gYXZvaWQgYWxsb2NhdGlvbnMgZHVyaW5nIHJ1bnRpbWUuXHJcbiAgICB0aGlzLnJlc3VsdCA9IHRoaXMua2V5c1swXS52YWx1ZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Cb29sZWFuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuQm9vbGVhbktleWZyYW1lVHJhY2sucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQm9vbGVhbktleWZyYW1lVHJhY2s7XHJcblxyXG5USFJFRS5Cb29sZWFuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuc2V0UmVzdWx0ID0gZnVuY3Rpb24oIHZhbHVlICkge1xyXG5cclxuICAgIHRoaXMucmVzdWx0ID0gdmFsdWU7XHJcblxyXG59O1xyXG5cclxuLy8gbWVtb2l6YXRpb24gb2YgdGhlIGxlcnAgZnVuY3Rpb24gZm9yIHNwZWVkLlxyXG4vLyBOT1RFOiBEbyBub3Qgb3B0aW1pemUgYXMgYSBwcm90b3R5cGUgaW5pdGlhbGl6YXRpb24gY2xvc3VyZSwgYXMgdmFsdWUwIHdpbGwgYmUgZGlmZmVyZW50IG9uIGEgcGVyIGNsYXNzIGJhc2lzLlxyXG5USFJFRS5Cb29sZWFuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUubGVycFZhbHVlcyA9IGZ1bmN0aW9uKCB2YWx1ZTAsIHZhbHVlMSwgYWxwaGEgKSB7XHJcblxyXG4gICAgcmV0dXJuICggYWxwaGEgPCAxLjAgKSA/IHZhbHVlMCA6IHZhbHVlMTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Cb29sZWFuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuY29tcGFyZVZhbHVlcyA9IGZ1bmN0aW9uKCB2YWx1ZTAsIHZhbHVlMSApIHtcclxuXHJcbiAgICByZXR1cm4gKCB2YWx1ZTAgPT09IHZhbHVlMSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkJvb2xlYW5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBjbG9uZWRLZXlzID0gW107XHJcblxyXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5rZXlzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgdmFyIGtleSA9IHRoaXMua2V5c1tpXTtcclxuICAgICAgICBjbG9uZWRLZXlzLnB1c2goIHtcclxuICAgICAgICAgICAgdGltZToga2V5LnRpbWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBrZXkudmFsdWVcclxuICAgICAgICB9ICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5Cb29sZWFuS2V5ZnJhbWVUcmFjayggdGhpcy5uYW1lLCBjbG9uZWRLZXlzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQm9vbGVhbktleWZyYW1lVHJhY2sucGFyc2UgPSBmdW5jdGlvbigganNvbiApIHtcclxuXHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLkJvb2xlYW5LZXlmcmFtZVRyYWNrKCBqc29uLm5hbWUsIGpzb24ua2V5cyApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2FuaW1hdGlvbi90cmFja3MvTnVtYmVyS2V5ZnJhbWVUcmFjay5qc1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEEgVHJhY2sgdGhhdCBpbnRlcnBvbGF0ZXMgTnVtYmVyc1xyXG4gKlxyXG4gKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xyXG4gKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cclxuICovXHJcblxyXG5USFJFRS5OdW1iZXJLZXlmcmFtZVRyYWNrID0gZnVuY3Rpb24gKCBuYW1lLCBrZXlzICkge1xyXG5cclxuICAgIFRIUkVFLktleWZyYW1lVHJhY2suY2FsbCggdGhpcywgbmFtZSwga2V5cyApO1xyXG5cclxuICAgIC8vIGxvY2FsIGNhY2hlIG9mIHZhbHVlIHR5cGUgdG8gYXZvaWQgYWxsb2NhdGlvbnMgZHVyaW5nIHJ1bnRpbWUuXHJcbiAgICB0aGlzLnJlc3VsdCA9IHRoaXMua2V5c1swXS52YWx1ZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5OdW1iZXJLZXlmcmFtZVRyYWNrLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLktleWZyYW1lVHJhY2sucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5OdW1iZXJLZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk51bWJlcktleWZyYW1lVHJhY2s7XHJcblxyXG5USFJFRS5OdW1iZXJLZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5zZXRSZXN1bHQgPSBmdW5jdGlvbiggdmFsdWUgKSB7XHJcblxyXG4gICAgdGhpcy5yZXN1bHQgPSB2YWx1ZTtcclxuXHJcbn07XHJcblxyXG4vLyBtZW1vaXphdGlvbiBvZiB0aGUgbGVycCBmdW5jdGlvbiBmb3Igc3BlZWQuXHJcbi8vIE5PVEU6IERvIG5vdCBvcHRpbWl6ZSBhcyBhIHByb3RvdHlwZSBpbml0aWFsaXphdGlvbiBjbG9zdXJlLCBhcyB2YWx1ZTAgd2lsbCBiZSBkaWZmZXJlbnQgb24gYSBwZXIgY2xhc3MgYmFzaXMuXHJcblRIUkVFLk51bWJlcktleWZyYW1lVHJhY2sucHJvdG90eXBlLmxlcnBWYWx1ZXMgPSBmdW5jdGlvbiggdmFsdWUwLCB2YWx1ZTEsIGFscGhhICkge1xyXG5cclxuICAgIHJldHVybiB2YWx1ZTAgKiAoIDEgLSBhbHBoYSApICsgdmFsdWUxICogYWxwaGE7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTnVtYmVyS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuY29tcGFyZVZhbHVlcyA9IGZ1bmN0aW9uKCB2YWx1ZTAsIHZhbHVlMSApIHtcclxuXHJcbiAgICByZXR1cm4gKCB2YWx1ZTAgPT09IHZhbHVlMSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk51bWJlcktleWZyYW1lVHJhY2sucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgdmFyIGNsb25lZEtleXMgPSBbXTtcclxuXHJcbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmtleXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuICAgICAgICB2YXIga2V5ID0gdGhpcy5rZXlzW2ldO1xyXG4gICAgICAgIGNsb25lZEtleXMucHVzaCgge1xyXG4gICAgICAgICAgICB0aW1lOiBrZXkudGltZSxcclxuICAgICAgICAgICAgdmFsdWU6IGtleS52YWx1ZVxyXG4gICAgICAgIH0gKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLk51bWJlcktleWZyYW1lVHJhY2soIHRoaXMubmFtZSwgY2xvbmVkS2V5cyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk51bWJlcktleWZyYW1lVHJhY2sucGFyc2UgPSBmdW5jdGlvbigganNvbiApIHtcclxuXHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLk51bWJlcktleWZyYW1lVHJhY2soIGpzb24ubmFtZSwganNvbi5rZXlzICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvY2FtZXJhcy9DYW1lcmEuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICovXHJcblxyXG5USFJFRS5DYW1lcmEgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdDYW1lcmEnO1xyXG5cclxuICAgIHRoaXMubWF0cml4V29ybGRJbnZlcnNlID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5USFJFRS5DYW1lcmEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ2FtZXJhO1xyXG5cclxuVEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5nZXRXb3JsZERpcmVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG4gICAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICB0aGlzLmdldFdvcmxkUXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0LnNldCggMCwgMCwgLSAxICkuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XHJcblxyXG4gICAgfTtcclxuXHJcbn0oKTtcclxuXHJcblRIUkVFLkNhbWVyYS5wcm90b3R5cGUubG9va0F0ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIC8vIFRoaXMgcm91dGluZSBkb2VzIG5vdCBzdXBwb3J0IGNhbWVyYXMgd2l0aCByb3RhdGVkIGFuZC9vciB0cmFuc2xhdGVkIHBhcmVudChzKVxyXG5cclxuICAgIHZhciBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggdmVjdG9yICkge1xyXG5cclxuICAgICAgICBtMS5sb29rQXQoIHRoaXMucG9zaXRpb24sIHZlY3RvciwgdGhpcy51cCApO1xyXG5cclxuICAgICAgICB0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtMSApO1xyXG5cclxuICAgIH07XHJcblxyXG59KCk7XHJcblxyXG5USFJFRS5DYW1lcmEucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DYW1lcmEucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcbiAgICBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcbiAgICB0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZS5jb3B5KCBzb3VyY2UubWF0cml4V29ybGRJbnZlcnNlICk7XHJcbiAgICB0aGlzLnByb2plY3Rpb25NYXRyaXguY29weSggc291cmNlLnByb2plY3Rpb25NYXRyaXggKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9jYW1lcmFzL0N1YmVDYW1lcmEuanNcclxuXHJcbi8qKlxyXG4gKiBDYW1lcmEgZm9yIHJlbmRlcmluZyBjdWJlIG1hcHNcclxuICpcdC0gcmVuZGVycyBzY2VuZSBpbnRvIGF4aXMtYWxpZ25lZCBjdWJlXHJcbiAqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQ3ViZUNhbWVyYSA9IGZ1bmN0aW9uICggbmVhciwgZmFyLCBjdWJlUmVzb2x1dGlvbiApIHtcclxuXHJcbiAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ0N1YmVDYW1lcmEnO1xyXG5cclxuICAgIHZhciBmb3YgPSA5MCwgYXNwZWN0ID0gMTtcclxuXHJcbiAgICB2YXIgY2FtZXJhUFggPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcclxuICAgIGNhbWVyYVBYLnVwLnNldCggMCwgLSAxLCAwICk7XHJcbiAgICBjYW1lcmFQWC5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICkgKTtcclxuICAgIHRoaXMuYWRkKCBjYW1lcmFQWCApO1xyXG5cclxuICAgIHZhciBjYW1lcmFOWCA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xyXG4gICAgY2FtZXJhTlgudXAuc2V0KCAwLCAtIDEsIDAgKTtcclxuICAgIGNhbWVyYU5YLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIC0gMSwgMCwgMCApICk7XHJcbiAgICB0aGlzLmFkZCggY2FtZXJhTlggKTtcclxuXHJcbiAgICB2YXIgY2FtZXJhUFkgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcclxuICAgIGNhbWVyYVBZLnVwLnNldCggMCwgMCwgMSApO1xyXG4gICAgY2FtZXJhUFkubG9va0F0KCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApICk7XHJcbiAgICB0aGlzLmFkZCggY2FtZXJhUFkgKTtcclxuXHJcbiAgICB2YXIgY2FtZXJhTlkgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcclxuICAgIGNhbWVyYU5ZLnVwLnNldCggMCwgMCwgLSAxICk7XHJcbiAgICBjYW1lcmFOWS5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtIDEsIDAgKSApO1xyXG4gICAgdGhpcy5hZGQoIGNhbWVyYU5ZICk7XHJcblxyXG4gICAgdmFyIGNhbWVyYVBaID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XHJcbiAgICBjYW1lcmFQWi51cC5zZXQoIDAsIC0gMSwgMCApO1xyXG4gICAgY2FtZXJhUFoubG9va0F0KCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApICk7XHJcbiAgICB0aGlzLmFkZCggY2FtZXJhUFogKTtcclxuXHJcbiAgICB2YXIgY2FtZXJhTlogPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcclxuICAgIGNhbWVyYU5aLnVwLnNldCggMCwgLSAxLCAwICk7XHJcbiAgICBjYW1lcmFOWi5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAtIDEgKSApO1xyXG4gICAgdGhpcy5hZGQoIGNhbWVyYU5aICk7XHJcblxyXG4gICAgdGhpcy5yZW5kZXJUYXJnZXQgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlKCBjdWJlUmVzb2x1dGlvbiwgY3ViZVJlc29sdXRpb24sIHsgZm9ybWF0OiBUSFJFRS5SR0JGb3JtYXQsIG1hZ0ZpbHRlcjogVEhSRUUuTGluZWFyRmlsdGVyLCBtaW5GaWx0ZXI6IFRIUkVFLkxpbmVhckZpbHRlciB9ICk7XHJcblxyXG4gICAgdGhpcy51cGRhdGVDdWJlTWFwID0gZnVuY3Rpb24gKCByZW5kZXJlciwgc2NlbmUgKSB7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5wYXJlbnQgPT09IG51bGwgKSB0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblxyXG4gICAgICAgIHZhciByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlclRhcmdldDtcclxuICAgICAgICB2YXIgZ2VuZXJhdGVNaXBtYXBzID0gcmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzO1xyXG5cclxuICAgICAgICByZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgcmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMDtcclxuICAgICAgICByZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFQWCwgcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG4gICAgICAgIHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDE7XHJcbiAgICAgICAgcmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhTlgsIHJlbmRlclRhcmdldCApO1xyXG5cclxuICAgICAgICByZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSAyO1xyXG4gICAgICAgIHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYVBZLCByZW5kZXJUYXJnZXQgKTtcclxuXHJcbiAgICAgICAgcmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMztcclxuICAgICAgICByZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFOWSwgcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG4gICAgICAgIHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDQ7XHJcbiAgICAgICAgcmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhUFosIHJlbmRlclRhcmdldCApO1xyXG5cclxuICAgICAgICByZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBnZW5lcmF0ZU1pcG1hcHM7XHJcblxyXG4gICAgICAgIHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDU7XHJcbiAgICAgICAgcmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhTlosIHJlbmRlclRhcmdldCApO1xyXG5cclxuICAgICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIG51bGwgKTtcclxuXHJcbiAgICB9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLkN1YmVDYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblRIUkVFLkN1YmVDYW1lcmEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ3ViZUNhbWVyYTtcclxuXHJcbi8vIEZpbGU6c3JjL2NhbWVyYXMvT3J0aG9ncmFwaGljQ2FtZXJhLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEgPSBmdW5jdGlvbiAoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyICkge1xyXG5cclxuICAgIFRIUkVFLkNhbWVyYS5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ09ydGhvZ3JhcGhpY0NhbWVyYSc7XHJcblxyXG4gICAgdGhpcy56b29tID0gMTtcclxuXHJcbiAgICB0aGlzLmxlZnQgPSBsZWZ0O1xyXG4gICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xyXG4gICAgdGhpcy50b3AgPSB0b3A7XHJcbiAgICB0aGlzLmJvdHRvbSA9IGJvdHRvbTtcclxuXHJcbiAgICB0aGlzLm5lYXIgPSAoIG5lYXIgIT09IHVuZGVmaW5lZCApID8gbmVhciA6IDAuMTtcclxuICAgIHRoaXMuZmFyID0gKCBmYXIgIT09IHVuZGVmaW5lZCApID8gZmFyIDogMjAwMDtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ2FtZXJhLnByb3RvdHlwZSApO1xyXG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhO1xyXG5cclxuVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhLnByb3RvdHlwZS51cGRhdGVQcm9qZWN0aW9uTWF0cml4ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBkeCA9ICggdGhpcy5yaWdodCAtIHRoaXMubGVmdCApIC8gKCAyICogdGhpcy56b29tICk7XHJcbiAgICB2YXIgZHkgPSAoIHRoaXMudG9wIC0gdGhpcy5ib3R0b20gKSAvICggMiAqIHRoaXMuem9vbSApO1xyXG4gICAgdmFyIGN4ID0gKCB0aGlzLnJpZ2h0ICsgdGhpcy5sZWZ0ICkgLyAyO1xyXG4gICAgdmFyIGN5ID0gKCB0aGlzLnRvcCArIHRoaXMuYm90dG9tICkgLyAyO1xyXG5cclxuICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlT3J0aG9ncmFwaGljKCBjeCAtIGR4LCBjeCArIGR4LCBjeSArIGR5LCBjeSAtIGR5LCB0aGlzLm5lYXIsIHRoaXMuZmFyICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG4gICAgVEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuICAgIHRoaXMubGVmdCA9IHNvdXJjZS5sZWZ0O1xyXG4gICAgdGhpcy5yaWdodCA9IHNvdXJjZS5yaWdodDtcclxuICAgIHRoaXMudG9wID0gc291cmNlLnRvcDtcclxuICAgIHRoaXMuYm90dG9tID0gc291cmNlLmJvdHRvbTtcclxuICAgIHRoaXMubmVhciA9IHNvdXJjZS5uZWFyO1xyXG4gICAgdGhpcy5mYXIgPSBzb3VyY2UuZmFyO1xyXG5cclxuICAgIHRoaXMuem9vbSA9IHNvdXJjZS56b29tO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCBtZXRhICkge1xyXG5cclxuICAgIHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XHJcblxyXG4gICAgZGF0YS5vYmplY3Quem9vbSA9IHRoaXMuem9vbTtcclxuICAgIGRhdGEub2JqZWN0LmxlZnQgPSB0aGlzLmxlZnQ7XHJcbiAgICBkYXRhLm9iamVjdC5yaWdodCA9IHRoaXMucmlnaHQ7XHJcbiAgICBkYXRhLm9iamVjdC50b3AgPSB0aGlzLnRvcDtcclxuICAgIGRhdGEub2JqZWN0LmJvdHRvbSA9IHRoaXMuYm90dG9tO1xyXG4gICAgZGF0YS5vYmplY3QubmVhciA9IHRoaXMubmVhcjtcclxuICAgIGRhdGEub2JqZWN0LmZhciA9IHRoaXMuZmFyO1xyXG5cclxuICAgIHJldHVybiBkYXRhO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2NhbWVyYXMvUGVyc3BlY3RpdmVDYW1lcmEuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGdyZWdnbWFuIC8gaHR0cDovL2dhbWVzLmdyZWdnbWFuLmNvbS9cclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKi9cclxuXHJcblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhID0gZnVuY3Rpb24gKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICkge1xyXG5cclxuICAgIFRIUkVFLkNhbWVyYS5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ1BlcnNwZWN0aXZlQ2FtZXJhJztcclxuXHJcbiAgICB0aGlzLnpvb20gPSAxO1xyXG5cclxuICAgIHRoaXMuZm92ID0gZm92ICE9PSB1bmRlZmluZWQgPyBmb3YgOiA1MDtcclxuICAgIHRoaXMuYXNwZWN0ID0gYXNwZWN0ICE9PSB1bmRlZmluZWQgPyBhc3BlY3QgOiAxO1xyXG4gICAgdGhpcy5uZWFyID0gbmVhciAhPT0gdW5kZWZpbmVkID8gbmVhciA6IDAuMTtcclxuICAgIHRoaXMuZmFyID0gZmFyICE9PSB1bmRlZmluZWQgPyBmYXIgOiAyMDAwO1xyXG5cclxuICAgIHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkNhbWVyYS5wcm90b3R5cGUgKTtcclxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmE7XHJcblxyXG5cclxuLyoqXHJcbiAqIFVzZXMgRm9jYWwgTGVuZ3RoIChpbiBtbSkgdG8gZXN0aW1hdGUgYW5kIHNldCBGT1ZcclxuICogMzVtbSAoZnVsbC1mcmFtZSkgY2FtZXJhIGlzIHVzZWQgaWYgZnJhbWUgc2l6ZSBpcyBub3Qgc3BlY2lmaWVkO1xyXG4gKiBGb3JtdWxhIGJhc2VkIG9uIGh0dHA6Ly93d3cuYm9iYXRraW5zLmNvbS9waG90b2dyYXBoeS90ZWNobmljYWwvZmllbGRfb2Zfdmlldy5odG1sXHJcbiAqL1xyXG5cclxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLnNldExlbnMgPSBmdW5jdGlvbiAoIGZvY2FsTGVuZ3RoLCBmcmFtZUhlaWdodCApIHtcclxuXHJcbiAgICBpZiAoIGZyYW1lSGVpZ2h0ID09PSB1bmRlZmluZWQgKSBmcmFtZUhlaWdodCA9IDI0O1xyXG5cclxuICAgIHRoaXMuZm92ID0gMiAqIFRIUkVFLk1hdGgucmFkVG9EZWcoIE1hdGguYXRhbiggZnJhbWVIZWlnaHQgLyAoIGZvY2FsTGVuZ3RoICogMiApICkgKTtcclxuICAgIHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG5cclxufTtcclxuXHJcblxyXG4vKipcclxuICogU2V0cyBhbiBvZmZzZXQgaW4gYSBsYXJnZXIgZnJ1c3R1bS4gVGhpcyBpcyB1c2VmdWwgZm9yIG11bHRpLXdpbmRvdyBvclxyXG4gKiBtdWx0aS1tb25pdG9yL211bHRpLW1hY2hpbmUgc2V0dXBzLlxyXG4gKlxyXG4gKiBGb3IgZXhhbXBsZSwgaWYgeW91IGhhdmUgM3gyIG1vbml0b3JzIGFuZCBlYWNoIG1vbml0b3IgaXMgMTkyMHgxMDgwIGFuZFxyXG4gKiB0aGUgbW9uaXRvcnMgYXJlIGluIGdyaWQgbGlrZSB0aGlzXHJcbiAqXHJcbiAqICAgKy0tLSstLS0rLS0tK1xyXG4gKiAgIHwgQSB8IEIgfCBDIHxcclxuICogICArLS0tKy0tLSstLS0rXHJcbiAqICAgfCBEIHwgRSB8IEYgfFxyXG4gKiAgICstLS0rLS0tKy0tLStcclxuICpcclxuICogdGhlbiBmb3IgZWFjaCBtb25pdG9yIHlvdSB3b3VsZCBjYWxsIGl0IGxpa2UgdGhpc1xyXG4gKlxyXG4gKiAgIHZhciB3ID0gMTkyMDtcclxuICogICB2YXIgaCA9IDEwODA7XHJcbiAqICAgdmFyIGZ1bGxXaWR0aCA9IHcgKiAzO1xyXG4gKiAgIHZhciBmdWxsSGVpZ2h0ID0gaCAqIDI7XHJcbiAqXHJcbiAqICAgLS1BLS1cclxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAwLCBoICogMCwgdywgaCApO1xyXG4gKiAgIC0tQi0tXHJcbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMSwgaCAqIDAsIHcsIGggKTtcclxuICogICAtLUMtLVxyXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDIsIGggKiAwLCB3LCBoICk7XHJcbiAqICAgLS1ELS1cclxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAwLCBoICogMSwgdywgaCApO1xyXG4gKiAgIC0tRS0tXHJcbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMSwgaCAqIDEsIHcsIGggKTtcclxuICogICAtLUYtLVxyXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDIsIGggKiAxLCB3LCBoICk7XHJcbiAqXHJcbiAqICAgTm90ZSB0aGVyZSBpcyBubyByZWFzb24gbW9uaXRvcnMgaGF2ZSB0byBiZSB0aGUgc2FtZSBzaXplIG9yIGluIGEgZ3JpZC5cclxuICovXHJcblxyXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuc2V0Vmlld09mZnNldCA9IGZ1bmN0aW9uICggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xyXG5cclxuICAgIHRoaXMuZnVsbFdpZHRoID0gZnVsbFdpZHRoO1xyXG4gICAgdGhpcy5mdWxsSGVpZ2h0ID0gZnVsbEhlaWdodDtcclxuICAgIHRoaXMueCA9IHg7XHJcbiAgICB0aGlzLnkgPSB5O1xyXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gICAgdGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS51cGRhdGVQcm9qZWN0aW9uTWF0cml4ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBmb3YgPSBUSFJFRS5NYXRoLnJhZFRvRGVnKCAyICogTWF0aC5hdGFuKCBNYXRoLnRhbiggVEhSRUUuTWF0aC5kZWdUb1JhZCggdGhpcy5mb3YgKSAqIDAuNSApIC8gdGhpcy56b29tICkgKTtcclxuXHJcbiAgICBpZiAoIHRoaXMuZnVsbFdpZHRoICkge1xyXG5cclxuICAgICAgICB2YXIgYXNwZWN0ID0gdGhpcy5mdWxsV2lkdGggLyB0aGlzLmZ1bGxIZWlnaHQ7XHJcbiAgICAgICAgdmFyIHRvcCA9IE1hdGgudGFuKCBUSFJFRS5NYXRoLmRlZ1RvUmFkKCBmb3YgKiAwLjUgKSApICogdGhpcy5uZWFyO1xyXG4gICAgICAgIHZhciBib3R0b20gPSAtIHRvcDtcclxuICAgICAgICB2YXIgbGVmdCA9IGFzcGVjdCAqIGJvdHRvbTtcclxuICAgICAgICB2YXIgcmlnaHQgPSBhc3BlY3QgKiB0b3A7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gTWF0aC5hYnMoIHJpZ2h0IC0gbGVmdCApO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBNYXRoLmFicyggdG9wIC0gYm90dG9tICk7XHJcblxyXG4gICAgICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlRnJ1c3R1bShcclxuICAgICAgICAgICAgbGVmdCArIHRoaXMueCAqIHdpZHRoIC8gdGhpcy5mdWxsV2lkdGgsXHJcbiAgICAgICAgICAgIGxlZnQgKyAoIHRoaXMueCArIHRoaXMud2lkdGggKSAqIHdpZHRoIC8gdGhpcy5mdWxsV2lkdGgsXHJcbiAgICAgICAgICAgIHRvcCAtICggdGhpcy55ICsgdGhpcy5oZWlnaHQgKSAqIGhlaWdodCAvIHRoaXMuZnVsbEhlaWdodCxcclxuICAgICAgICAgICAgdG9wIC0gdGhpcy55ICogaGVpZ2h0IC8gdGhpcy5mdWxsSGVpZ2h0LFxyXG4gICAgICAgICAgICB0aGlzLm5lYXIsXHJcbiAgICAgICAgICAgIHRoaXMuZmFyXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICB0aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZVBlcnNwZWN0aXZlKCBmb3YsIHRoaXMuYXNwZWN0LCB0aGlzLm5lYXIsIHRoaXMuZmFyICk7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG4gICAgVEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuICAgIHRoaXMuZm92ID0gc291cmNlLmZvdjtcclxuICAgIHRoaXMuYXNwZWN0ID0gc291cmNlLmFzcGVjdDtcclxuICAgIHRoaXMubmVhciA9IHNvdXJjZS5uZWFyO1xyXG4gICAgdGhpcy5mYXIgPSBzb3VyY2UuZmFyO1xyXG5cclxuICAgIHRoaXMuem9vbSA9IHNvdXJjZS56b29tO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoIG1ldGEgKSB7XHJcblxyXG4gICAgdmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcclxuXHJcbiAgICBkYXRhLm9iamVjdC56b29tID0gdGhpcy56b29tO1xyXG4gICAgZGF0YS5vYmplY3QuZm92ID0gdGhpcy5mb3Y7XHJcbiAgICBkYXRhLm9iamVjdC5hc3BlY3QgPSB0aGlzLmFzcGVjdDtcclxuICAgIGRhdGEub2JqZWN0Lm5lYXIgPSB0aGlzLm5lYXI7XHJcbiAgICBkYXRhLm9iamVjdC5mYXIgPSB0aGlzLmZhcjtcclxuXHJcbiAgICByZXR1cm4gZGF0YTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9saWdodHMvTGlnaHQuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkxpZ2h0ID0gZnVuY3Rpb24gKCBjb2xvciApIHtcclxuXHJcbiAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ0xpZ2h0JztcclxuXHJcbiAgICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCBjb2xvciApO1xyXG5cclxuICAgIHRoaXMucmVjZWl2ZVNoYWRvdyA9IHVuZGVmaW5lZDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5MaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuTGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGlnaHQ7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVEhSRUUuTGlnaHQucHJvdG90eXBlLCB7XHJcbiAgICBvbmx5U2hhZG93OiB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLm9ubHlTaGFkb3cgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHNoYWRvd0NhbWVyYUZvdjoge1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuICAgICAgICAgICAgdGhpcy5zaGFkb3cuY2FtZXJhLmZvdiA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBzaGFkb3dDYW1lcmFMZWZ0OiB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG4gICAgICAgICAgICB0aGlzLnNoYWRvdy5jYW1lcmEubGVmdCA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBzaGFkb3dDYW1lcmFSaWdodDoge1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuICAgICAgICAgICAgdGhpcy5zaGFkb3cuY2FtZXJhLnJpZ2h0ID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHNoYWRvd0NhbWVyYVRvcDoge1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuICAgICAgICAgICAgdGhpcy5zaGFkb3cuY2FtZXJhLnRvcCA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBzaGFkb3dDYW1lcmFCb3R0b206IHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhZG93LmNhbWVyYS5ib3R0b20gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgc2hhZG93Q2FtZXJhTmVhcjoge1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuICAgICAgICAgICAgdGhpcy5zaGFkb3cuY2FtZXJhLm5lYXIgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgc2hhZG93Q2FtZXJhRmFyOiB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG4gICAgICAgICAgICB0aGlzLnNoYWRvdy5jYW1lcmEuZmFyID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHNoYWRvd0NhbWVyYVZpc2libGU6IHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhVmlzaWJsZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLkNhbWVyYUhlbHBlciggbGlnaHQuc2hhZG93ICkgaW5zdGVhZC4nICk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHNoYWRvd0JpYXM6IHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhZG93LmJpYXMgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgc2hhZG93RGFya25lc3M6IHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhZG93LmRhcmtuZXNzID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHNoYWRvd01hcFdpZHRoOiB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG4gICAgICAgICAgICB0aGlzLnNoYWRvdy5tYXBTaXplLndpZHRoID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHNoYWRvd01hcEhlaWdodDoge1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuICAgICAgICAgICAgdGhpcy5zaGFkb3cubWFwU2l6ZS5oZWlnaHQgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0gKTtcclxuXHJcblRIUkVFLkxpZ2h0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG4gICAgVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG4gICAgdGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG5USFJFRS5MaWdodC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCBtZXRhICkge1xyXG5cclxuICAgIHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XHJcblxyXG4gICAgZGF0YS5vYmplY3QuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xyXG4gICAgaWYgKCB0aGlzLmdyb3VuZENvbG9yICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5ncm91bmRDb2xvciA9IHRoaXMuZ3JvdW5kQ29sb3IuZ2V0SGV4KCk7XHJcblxyXG4gICAgaWYgKCB0aGlzLmludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgZGF0YS5vYmplY3QuaW50ZW5zaXR5ID0gdGhpcy5pbnRlbnNpdHk7XHJcbiAgICBpZiAoIHRoaXMuZGlzdGFuY2UgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LmRpc3RhbmNlID0gdGhpcy5kaXN0YW5jZTtcclxuICAgIGlmICggdGhpcy5hbmdsZSAhPT0gdW5kZWZpbmVkICkgZGF0YS5vYmplY3QuYW5nbGUgPSB0aGlzLmFuZ2xlO1xyXG4gICAgaWYgKCB0aGlzLmRlY2F5ICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5kZWNheSA9IHRoaXMuZGVjYXk7XHJcbiAgICBpZiAoIHRoaXMuZXhwb25lbnQgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LmV4cG9uZW50ID0gdGhpcy5leHBvbmVudDtcclxuXHJcbiAgICByZXR1cm4gZGF0YTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9saWdodHMvTGlnaHRTaGFkb3cuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkxpZ2h0U2hhZG93ID0gZnVuY3Rpb24gKCBjYW1lcmEgKSB7XHJcblxyXG4gICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XHJcblxyXG4gICAgdGhpcy5iaWFzID0gMDtcclxuICAgIHRoaXMuZGFya25lc3MgPSAxO1xyXG5cclxuICAgIHRoaXMubWFwU2l6ZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCA1MTIsIDUxMiApO1xyXG5cclxuICAgIHRoaXMubWFwID0gbnVsbDtcclxuICAgIHRoaXMubWF0cml4ID0gbnVsbDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5MaWdodFNoYWRvdy5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkxpZ2h0U2hhZG93LFxyXG5cclxuICAgIGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuICAgICAgICB0aGlzLmNhbWVyYSA9IHNvdXJjZS5jYW1lcmEuY2xvbmUoKTtcclxuXHJcbiAgICAgICAgdGhpcy5iaWFzID0gc291cmNlLmJpYXM7XHJcbiAgICAgICAgdGhpcy5kYXJrbmVzcyA9IHNvdXJjZS5kYXJrbmVzcztcclxuXHJcbiAgICAgICAgdGhpcy5tYXBTaXplLmNvcHkoIHNvdXJjZS5tYXBTaXplICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2xpZ2h0cy9BbWJpZW50TGlnaHQuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkFtYmllbnRMaWdodCA9IGZ1bmN0aW9uICggY29sb3IgKSB7XHJcblxyXG4gICAgVEhSRUUuTGlnaHQuY2FsbCggdGhpcywgY29sb3IgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnQW1iaWVudExpZ2h0JztcclxuXHJcbiAgICB0aGlzLmNhc3RTaGFkb3cgPSB1bmRlZmluZWQ7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQW1iaWVudExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSApO1xyXG5USFJFRS5BbWJpZW50TGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQW1iaWVudExpZ2h0O1xyXG5cclxuLy8gRmlsZTpzcmMvbGlnaHRzL0RpcmVjdGlvbmFsTGlnaHQuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgPSBmdW5jdGlvbiAoIGNvbG9yLCBpbnRlbnNpdHkgKSB7XHJcblxyXG4gICAgVEhSRUUuTGlnaHQuY2FsbCggdGhpcywgY29sb3IgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnRGlyZWN0aW9uYWxMaWdodCc7XHJcblxyXG4gICAgdGhpcy5wb3NpdGlvbi5zZXQoIDAsIDEsIDAgKTtcclxuICAgIHRoaXMudXBkYXRlTWF0cml4KCk7XHJcblxyXG4gICAgdGhpcy50YXJnZXQgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcclxuXHJcbiAgICB0aGlzLmludGVuc2l0eSA9ICggaW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSA/IGludGVuc2l0eSA6IDE7XHJcblxyXG4gICAgdGhpcy5zaGFkb3cgPSBuZXcgVEhSRUUuTGlnaHRTaGFkb3coIG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoIC0gNTAwLCA1MDAsIDUwMCwgLSA1MDAsIDUwLCA1MDAwICkgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSApO1xyXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQ7XHJcblxyXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG4gICAgVEhSRUUuTGlnaHQucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG4gICAgdGhpcy5pbnRlbnNpdHkgPSBzb3VyY2UuaW50ZW5zaXR5O1xyXG4gICAgdGhpcy50YXJnZXQgPSBzb3VyY2UudGFyZ2V0LmNsb25lKCk7XHJcblxyXG4gICAgdGhpcy5zaGFkb3cgPSBzb3VyY2Uuc2hhZG93LmNsb25lKCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbGlnaHRzL0hlbWlzcGhlcmVMaWdodC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0ID0gZnVuY3Rpb24gKCBza3lDb2xvciwgZ3JvdW5kQ29sb3IsIGludGVuc2l0eSApIHtcclxuXHJcbiAgICBUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBza3lDb2xvciApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdIZW1pc3BoZXJlTGlnaHQnO1xyXG5cclxuICAgIHRoaXMuY2FzdFNoYWRvdyA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICB0aGlzLnBvc2l0aW9uLnNldCggMCwgMSwgMCApO1xyXG4gICAgdGhpcy51cGRhdGVNYXRyaXgoKTtcclxuXHJcbiAgICB0aGlzLmdyb3VuZENvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCBncm91bmRDb2xvciApO1xyXG4gICAgdGhpcy5pbnRlbnNpdHkgPSAoIGludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBpbnRlbnNpdHkgOiAxO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkhlbWlzcGhlcmVMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcclxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkhlbWlzcGhlcmVMaWdodDtcclxuXHJcblRIUkVFLkhlbWlzcGhlcmVMaWdodC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuICAgIFRIUkVFLkxpZ2h0LnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuICAgIHRoaXMuZ3JvdW5kQ29sb3IuY29weSggc291cmNlLmdyb3VuZENvbG9yICk7XHJcbiAgICB0aGlzLmludGVuc2l0eSA9IHNvdXJjZS5pbnRlbnNpdHk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbGlnaHRzL1BvaW50TGlnaHQuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblxyXG5USFJFRS5Qb2ludExpZ2h0ID0gZnVuY3Rpb24gKCBjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSwgZGVjYXkgKSB7XHJcblxyXG4gICAgVEhSRUUuTGlnaHQuY2FsbCggdGhpcywgY29sb3IgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnUG9pbnRMaWdodCc7XHJcblxyXG4gICAgdGhpcy5pbnRlbnNpdHkgPSAoIGludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBpbnRlbnNpdHkgOiAxO1xyXG4gICAgdGhpcy5kaXN0YW5jZSA9ICggZGlzdGFuY2UgIT09IHVuZGVmaW5lZCApID8gZGlzdGFuY2UgOiAwO1xyXG4gICAgdGhpcy5kZWNheSA9ICggZGVjYXkgIT09IHVuZGVmaW5lZCApID8gZGVjYXkgOiAxO1x0Ly8gZm9yIHBoeXNpY2FsbHkgY29ycmVjdCBsaWdodHMsIHNob3VsZCBiZSAyLlxyXG5cclxuICAgIHRoaXMuc2hhZG93ID0gbmV3IFRIUkVFLkxpZ2h0U2hhZG93KCBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIDkwLCAxLCAxLCA1MDAgKSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBvaW50TGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGlnaHQucHJvdG90eXBlICk7XHJcblRIUkVFLlBvaW50TGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUG9pbnRMaWdodDtcclxuXHJcblRIUkVFLlBvaW50TGlnaHQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcbiAgICBUSFJFRS5MaWdodC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcbiAgICB0aGlzLmludGVuc2l0eSA9IHNvdXJjZS5pbnRlbnNpdHk7XHJcbiAgICB0aGlzLmRpc3RhbmNlID0gc291cmNlLmRpc3RhbmNlO1xyXG4gICAgdGhpcy5kZWNheSA9IHNvdXJjZS5kZWNheTtcclxuXHJcbiAgICB0aGlzLnNoYWRvdyA9IHNvdXJjZS5zaGFkb3cuY2xvbmUoKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9saWdodHMvU3BvdExpZ2h0LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5TcG90TGlnaHQgPSBmdW5jdGlvbiAoIGNvbG9yLCBpbnRlbnNpdHksIGRpc3RhbmNlLCBhbmdsZSwgZXhwb25lbnQsIGRlY2F5ICkge1xyXG5cclxuICAgIFRIUkVFLkxpZ2h0LmNhbGwoIHRoaXMsIGNvbG9yICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ1Nwb3RMaWdodCc7XHJcblxyXG4gICAgdGhpcy5wb3NpdGlvbi5zZXQoIDAsIDEsIDAgKTtcclxuICAgIHRoaXMudXBkYXRlTWF0cml4KCk7XHJcblxyXG4gICAgdGhpcy50YXJnZXQgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcclxuXHJcbiAgICB0aGlzLmludGVuc2l0eSA9ICggaW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSA/IGludGVuc2l0eSA6IDE7XHJcbiAgICB0aGlzLmRpc3RhbmNlID0gKCBkaXN0YW5jZSAhPT0gdW5kZWZpbmVkICkgPyBkaXN0YW5jZSA6IDA7XHJcbiAgICB0aGlzLmFuZ2xlID0gKCBhbmdsZSAhPT0gdW5kZWZpbmVkICkgPyBhbmdsZSA6IE1hdGguUEkgLyAzO1xyXG4gICAgdGhpcy5leHBvbmVudCA9ICggZXhwb25lbnQgIT09IHVuZGVmaW5lZCApID8gZXhwb25lbnQgOiAxMDtcclxuICAgIHRoaXMuZGVjYXkgPSAoIGRlY2F5ICE9PSB1bmRlZmluZWQgKSA/IGRlY2F5IDogMTtcdC8vIGZvciBwaHlzaWNhbGx5IGNvcnJlY3QgbGlnaHRzLCBzaG91bGQgYmUgMi5cclxuXHJcbiAgICB0aGlzLnNoYWRvdyA9IG5ldyBUSFJFRS5MaWdodFNoYWRvdyggbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCA1MCwgMSwgNTAsIDUwMDAgKSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNwb3RMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcclxuVEhSRUUuU3BvdExpZ2h0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwb3RMaWdodDtcclxuXHJcblRIUkVFLlNwb3RMaWdodC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuICAgIFRIUkVFLkxpZ2h0LnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuICAgIHRoaXMuaW50ZW5zaXR5ID0gc291cmNlLmludGVuc2l0eTtcclxuICAgIHRoaXMuZGlzdGFuY2UgPSBzb3VyY2UuZGlzdGFuY2U7XHJcbiAgICB0aGlzLmFuZ2xlID0gc291cmNlLmFuZ2xlO1xyXG4gICAgdGhpcy5leHBvbmVudCA9IHNvdXJjZS5leHBvbmVudDtcclxuICAgIHRoaXMuZGVjYXkgPSBzb3VyY2UuZGVjYXk7XHJcblxyXG4gICAgdGhpcy50YXJnZXQgPSBzb3VyY2UudGFyZ2V0LmNsb25lKCk7XHJcblxyXG4gICAgdGhpcy5zaGFkb3cgPSBzb3VyY2Uuc2hhZG93LmNsb25lKCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbG9hZGVycy9DYWNoZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQ2FjaGUgPSB7XHJcblxyXG4gICAgZW5hYmxlZDogZmFsc2UsXHJcblxyXG4gICAgZmlsZXM6IHt9LFxyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKCBrZXksIGZpbGUgKSB7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coICdUSFJFRS5DYWNoZScsICdBZGRpbmcga2V5OicsIGtleSApO1xyXG5cclxuICAgICAgICB0aGlzLmZpbGVzWyBrZXkgXSA9IGZpbGU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgga2V5ICkge1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCAnVEhSRUUuQ2FjaGUnLCAnQ2hlY2tpbmcga2V5OicsIGtleSApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5maWxlc1sga2V5IF07XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmU6IGZ1bmN0aW9uICgga2V5ICkge1xyXG5cclxuICAgICAgICBkZWxldGUgdGhpcy5maWxlc1sga2V5IF07XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0aGlzLmZpbGVzID0ge307XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2xvYWRlcnMvTG9hZGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5Mb2FkZXIgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdGhpcy5vbkxvYWRTdGFydCA9IGZ1bmN0aW9uICgpIHt9O1xyXG4gICAgdGhpcy5vbkxvYWRQcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHt9O1xyXG4gICAgdGhpcy5vbkxvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxvYWRlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkxvYWRlcixcclxuXHJcbiAgICBjcm9zc09yaWdpbjogdW5kZWZpbmVkLFxyXG5cclxuICAgIGV4dHJhY3RVcmxCYXNlOiBmdW5jdGlvbiAoIHVybCApIHtcclxuXHJcbiAgICAgICAgdmFyIHBhcnRzID0gdXJsLnNwbGl0KCAnLycgKTtcclxuXHJcbiAgICAgICAgaWYgKCBwYXJ0cy5sZW5ndGggPT09IDEgKSByZXR1cm4gJy4vJztcclxuXHJcbiAgICAgICAgcGFydHMucG9wKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKCAnLycgKSArICcvJztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGluaXRNYXRlcmlhbHM6IGZ1bmN0aW9uICggbWF0ZXJpYWxzLCB0ZXh0dXJlUGF0aCwgY3Jvc3NPcmlnaW4gKSB7XHJcblxyXG4gICAgICAgIHZhciBhcnJheSA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBtYXRlcmlhbHMubGVuZ3RoOyArKyBpICkge1xyXG5cclxuICAgICAgICAgICAgYXJyYXlbIGkgXSA9IHRoaXMuY3JlYXRlTWF0ZXJpYWwoIG1hdGVyaWFsc1sgaSBdLCB0ZXh0dXJlUGF0aCwgY3Jvc3NPcmlnaW4gKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYXJyYXk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVNYXRlcmlhbDogKCBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBjb2xvciwgdGV4dHVyZUxvYWRlciwgbWF0ZXJpYWxMb2FkZXI7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIG0sIHRleHR1cmVQYXRoLCBjcm9zc09yaWdpbiApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggY29sb3IgPT09IHVuZGVmaW5lZCApIGNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCk7XHJcbiAgICAgICAgICAgIGlmICggdGV4dHVyZUxvYWRlciA9PT0gdW5kZWZpbmVkICkgdGV4dHVyZUxvYWRlciA9IG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCk7XHJcbiAgICAgICAgICAgIGlmICggbWF0ZXJpYWxMb2FkZXIgPT09IHVuZGVmaW5lZCApIG1hdGVyaWFsTG9hZGVyID0gbmV3IFRIUkVFLk1hdGVyaWFsTG9hZGVyKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBjb252ZXJ0IGZyb20gb2xkIG1hdGVyaWFsIGZvcm1hdFxyXG5cclxuICAgICAgICAgICAgdmFyIHRleHR1cmVzID0ge307XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBsb2FkVGV4dHVyZSggcGF0aCwgcmVwZWF0LCBvZmZzZXQsIHdyYXAsIGFuaXNvdHJvcHkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGZ1bGxQYXRoID0gdGV4dHVyZVBhdGggKyBwYXRoO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxvYWRlciA9IFRIUkVFLkxvYWRlci5IYW5kbGVycy5nZXQoIGZ1bGxQYXRoICk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHRleHR1cmU7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBsb2FkZXIgIT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUgPSBsb2FkZXIubG9hZCggZnVsbFBhdGggKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlTG9hZGVyLnNldENyb3NzT3JpZ2luKCBjcm9zc09yaWdpbiApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUgPSB0ZXh0dXJlTG9hZGVyLmxvYWQoIGZ1bGxQYXRoICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICggcmVwZWF0ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUucmVwZWF0LmZyb21BcnJheSggcmVwZWF0ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggcmVwZWF0WyAwIF0gIT09IDEgKSB0ZXh0dXJlLndyYXBTID0gVEhSRUUuUmVwZWF0V3JhcHBpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCByZXBlYXRbIDEgXSAhPT0gMSApIHRleHR1cmUud3JhcFQgPSBUSFJFRS5SZXBlYXRXcmFwcGluZztcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBvZmZzZXQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5vZmZzZXQuZnJvbUFycmF5KCBvZmZzZXQgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCB3cmFwICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggd3JhcFsgMCBdID09PSAncmVwZWF0JyApIHRleHR1cmUud3JhcFMgPSBUSFJFRS5SZXBlYXRXcmFwcGluZztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHdyYXBbIDAgXSA9PT0gJ21pcnJvcicgKSB0ZXh0dXJlLndyYXBTID0gVEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB3cmFwWyAxIF0gPT09ICdyZXBlYXQnICkgdGV4dHVyZS53cmFwVCA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggd3JhcFsgMSBdID09PSAnbWlycm9yJyApIHRleHR1cmUud3JhcFQgPSBUSFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5hbmlzb3Ryb3B5ID0gYW5pc290cm9weTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRleHR1cmVzWyB1dWlkIF0gPSB0ZXh0dXJlO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB1dWlkO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9cclxuXHJcbiAgICAgICAgICAgIHZhciBqc29uID0ge1xyXG4gICAgICAgICAgICAgICAgdXVpZDogVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKSxcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdNZXNoTGFtYmVydE1hdGVyaWFsJ1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIG5hbWUgaW4gbSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBtWyBuYW1lIF07XHJcblxyXG4gICAgICAgICAgICAgICAgc3dpdGNoICggbmFtZSApIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdEYmdDb2xvcic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb24uY29sb3IgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnRGJnSW5kZXgnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ29wdGljYWxEZW5zaXR5JzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdpbGx1bWluYXRpb24nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVzZSB3ZXJlIG5ldmVyIHN1cHBvcnRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdEYmdOYW1lJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAganNvbi5uYW1lID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JsZW5kaW5nJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAganNvbi5ibGVuZGluZyA9IFRIUkVFWyB2YWx1ZSBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb2xvckRpZmZ1c2UnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uLmNvbG9yID0gY29sb3IuZnJvbUFycmF5KCB2YWx1ZSApLmdldEhleCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb2xvclNwZWN1bGFyJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAganNvbi5zcGVjdWxhciA9IGNvbG9yLmZyb21BcnJheSggdmFsdWUgKS5nZXRIZXgoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29sb3JFbWlzc2l2ZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb24uZW1pc3NpdmUgPSBjb2xvci5mcm9tQXJyYXkoIHZhbHVlICkuZ2V0SGV4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NwZWN1bGFyQ29lZic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb24uc2hpbmluZXNzID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NoYWRpbmcnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICdiYXNpYycgKSBqc29uLnR5cGUgPSAnTWVzaEJhc2ljTWF0ZXJpYWwnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICdwaG9uZycgKSBqc29uLnR5cGUgPSAnTWVzaFBob25nTWF0ZXJpYWwnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXBEaWZmdXNlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAganNvbi5tYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwRGlmZnVzZVJlcGVhdCwgbS5tYXBEaWZmdXNlT2Zmc2V0LCBtLm1hcERpZmZ1c2VXcmFwLCBtLm1hcERpZmZ1c2VBbmlzb3Ryb3B5ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21hcERpZmZ1c2VSZXBlYXQnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21hcERpZmZ1c2VPZmZzZXQnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21hcERpZmZ1c2VXcmFwJzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXBEaWZmdXNlQW5pc290cm9weSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21hcExpZ2h0JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAganNvbi5saWdodE1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBMaWdodFJlcGVhdCwgbS5tYXBMaWdodE9mZnNldCwgbS5tYXBMaWdodFdyYXAsIG0ubWFwTGlnaHRBbmlzb3Ryb3B5ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21hcExpZ2h0UmVwZWF0JzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXBMaWdodE9mZnNldCc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWFwTGlnaHRXcmFwJzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXBMaWdodEFuaXNvdHJvcHknOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXBBTyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb24uYW9NYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwQU9SZXBlYXQsIG0ubWFwQU9PZmZzZXQsIG0ubWFwQU9XcmFwLCBtLm1hcEFPQW5pc290cm9weSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXBBT1JlcGVhdCc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWFwQU9PZmZzZXQnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21hcEFPV3JhcCc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWFwQU9Bbmlzb3Ryb3B5JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWFwQnVtcCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb24uYnVtcE1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBCdW1wUmVwZWF0LCBtLm1hcEJ1bXBPZmZzZXQsIG0ubWFwQnVtcFdyYXAsIG0ubWFwQnVtcEFuaXNvdHJvcHkgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWFwQnVtcFNjYWxlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAganNvbi5idW1wU2NhbGUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWFwQnVtcFJlcGVhdCc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWFwQnVtcE9mZnNldCc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWFwQnVtcFdyYXAnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21hcEJ1bXBBbmlzb3Ryb3B5JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWFwTm9ybWFsJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAganNvbi5ub3JtYWxNYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwTm9ybWFsUmVwZWF0LCBtLm1hcE5vcm1hbE9mZnNldCwgbS5tYXBOb3JtYWxXcmFwLCBtLm1hcE5vcm1hbEFuaXNvdHJvcHkgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWFwTm9ybWFsRmFjdG9yJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAganNvbi5ub3JtYWxTY2FsZSA9IFsgdmFsdWUsIHZhbHVlIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21hcE5vcm1hbFJlcGVhdCc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWFwTm9ybWFsT2Zmc2V0JzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXBOb3JtYWxXcmFwJzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXBOb3JtYWxBbmlzb3Ryb3B5JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWFwU3BlY3VsYXInOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uLnNwZWN1bGFyTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcFNwZWN1bGFyUmVwZWF0LCBtLm1hcFNwZWN1bGFyT2Zmc2V0LCBtLm1hcFNwZWN1bGFyV3JhcCwgbS5tYXBTcGVjdWxhckFuaXNvdHJvcHkgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWFwU3BlY3VsYXJSZXBlYXQnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21hcFNwZWN1bGFyT2Zmc2V0JzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXBTcGVjdWxhcldyYXAnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21hcFNwZWN1bGFyQW5pc290cm9weSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21hcEFscGhhJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAganNvbi5hbHBoYU1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBBbHBoYVJlcGVhdCwgbS5tYXBBbHBoYU9mZnNldCwgbS5tYXBBbHBoYVdyYXAsIG0ubWFwQWxwaGFBbmlzb3Ryb3B5ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21hcEFscGhhUmVwZWF0JzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXBBbHBoYU9mZnNldCc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWFwQWxwaGFXcmFwJzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXBBbHBoYUFuaXNvdHJvcHknOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdmbGlwU2lkZWQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uLnNpZGUgPSBUSFJFRS5CYWNrU2lkZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZG91YmxlU2lkZWQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uLnNpZGUgPSBUSFJFRS5Eb3VibGVTaWRlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICd0cmFuc3BhcmVuY3knOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5Mb2FkZXI6IHRyYW5zcGFyZW5jeSBoYXMgYmVlbiByZW5hbWVkIHRvIG9wYWNpdHknICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb24ub3BhY2l0eSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdvcGFjaXR5JzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICd0cmFuc3BhcmVudCc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGVwdGhUZXN0JzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdkZXB0aFdyaXRlJzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICd0cmFuc3BhcmVudCc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndmlzaWJsZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2lyZWZyYW1lJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAganNvblsgbmFtZSBdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3ZlcnRleENvbG9ycyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdmFsdWUgPT09IHRydWUgKSBqc29uLnZlcnRleENvbG9ycyA9IFRIUkVFLlZlcnRleENvbG9ycztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB2YWx1ZSA9PT0gJ2ZhY2UnICkganNvbi52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5GYWNlQ29sb3JzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnTG9hZGVyLmNyZWF0ZU1hdGVyaWFsOiBVbnN1cHBvcnRlZCcsIG5hbWUsIHZhbHVlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBqc29uLnR5cGUgIT09ICdNZXNoUGhvbmdNYXRlcmlhbCcgKSBkZWxldGUganNvbi5zcGVjdWxhcjtcclxuICAgICAgICAgICAgaWYgKCBqc29uLm9wYWNpdHkgPCAxICkganNvbi50cmFuc3BhcmVudCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBtYXRlcmlhbExvYWRlci5zZXRUZXh0dXJlcyggdGV4dHVyZXMgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBtYXRlcmlhbExvYWRlci5wYXJzZSgganNvbiApO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0gKSgpXHJcblxyXG59O1xyXG5cclxuVEhSRUUuTG9hZGVyLkhhbmRsZXJzID0ge1xyXG5cclxuICAgIGhhbmRsZXJzOiBbXSxcclxuXHJcbiAgICBhZGQ6IGZ1bmN0aW9uICggcmVnZXgsIGxvYWRlciApIHtcclxuXHJcbiAgICAgICAgdGhpcy5oYW5kbGVycy5wdXNoKCByZWdleCwgbG9hZGVyICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICggZmlsZSApIHtcclxuXHJcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgbDsgaSArPSAyICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlZ2V4ID0gaGFuZGxlcnNbIGkgXTtcclxuICAgICAgICAgICAgdmFyIGxvYWRlciAgPSBoYW5kbGVyc1sgaSArIDEgXTtcclxuXHJcbiAgICAgICAgICAgIGlmICggcmVnZXgudGVzdCggZmlsZSApICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkZXI7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2xvYWRlcnMvWEhSTG9hZGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5YSFJMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XHJcblxyXG4gICAgdGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuWEhSTG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuWEhSTG9hZGVyLFxyXG5cclxuICAgIGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XHJcblxyXG4gICAgICAgIHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG4gICAgICAgIHZhciBjYWNoZWQgPSBUSFJFRS5DYWNoZS5nZXQoIHVybCApO1xyXG5cclxuICAgICAgICBpZiAoIGNhY2hlZCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBvbkxvYWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBvbkxvYWQoIGNhY2hlZCApO1xyXG5cclxuICAgICAgICAgICAgICAgIH0sIDAgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICByZXF1ZXN0Lm9wZW4oICdHRVQnLCB1cmwsIHRydWUgKTtcclxuXHJcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSBldmVudC50YXJnZXQucmVzcG9uc2U7XHJcblxyXG4gICAgICAgICAgICBUSFJFRS5DYWNoZS5hZGQoIHVybCwgcmVzcG9uc2UgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggb25Mb2FkICkgb25Mb2FkKCByZXNwb25zZSApO1xyXG5cclxuICAgICAgICAgICAgc2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcclxuXHJcbiAgICAgICAgfSwgZmFsc2UgKTtcclxuXHJcbiAgICAgICAgaWYgKCBvblByb2dyZXNzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoICdwcm9ncmVzcycsIGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgb25Qcm9ncmVzcyggZXZlbnQgKTtcclxuXHJcbiAgICAgICAgICAgIH0sIGZhbHNlICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCAnZXJyb3InLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBvbkVycm9yICkgb25FcnJvciggZXZlbnQgKTtcclxuXHJcbiAgICAgICAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcclxuXHJcbiAgICAgICAgfSwgZmFsc2UgKTtcclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLmNyb3NzT3JpZ2luICE9PSB1bmRlZmluZWQgKSByZXF1ZXN0LmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcclxuICAgICAgICBpZiAoIHRoaXMucmVzcG9uc2VUeXBlICE9PSB1bmRlZmluZWQgKSByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IHRoaXMucmVzcG9uc2VUeXBlO1xyXG4gICAgICAgIGlmICggdGhpcy53aXRoQ3JlZGVudGlhbHMgIT09IHVuZGVmaW5lZCApIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gdGhpcy53aXRoQ3JlZGVudGlhbHM7XHJcblxyXG4gICAgICAgIHJlcXVlc3Quc2VuZCggbnVsbCApO1xyXG5cclxuICAgICAgICBzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XHJcblxyXG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0UmVzcG9uc2VUeXBlOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuICAgICAgICB0aGlzLnJlc3BvbnNlVHlwZSA9IHZhbHVlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldFdpdGhDcmVkZW50aWFsczogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgdGhpcy53aXRoQ3JlZGVudGlhbHMgPSB2YWx1ZTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbG9hZGVycy9JbWFnZUxvYWRlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuSW1hZ2VMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XHJcblxyXG4gICAgdGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuSW1hZ2VMb2FkZXIucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5JbWFnZUxvYWRlcixcclxuXHJcbiAgICBsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xyXG5cclxuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuICAgICAgICB2YXIgY2FjaGVkID0gVEhSRUUuQ2FjaGUuZ2V0KCB1cmwgKTtcclxuXHJcbiAgICAgICAgaWYgKCBjYWNoZWQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggb25Mb2FkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgb25Mb2FkKCBjYWNoZWQgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9LCAwICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBpbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdpbWcnICk7XHJcblxyXG4gICAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkJywgZnVuY3Rpb24gKCBldmVudCApIHtcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLkNhY2hlLmFkZCggdXJsLCB0aGlzICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG9uTG9hZCApIG9uTG9hZCggdGhpcyApO1xyXG5cclxuICAgICAgICAgICAgc2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcclxuXHJcbiAgICAgICAgfSwgZmFsc2UgKTtcclxuXHJcbiAgICAgICAgaWYgKCBvblByb2dyZXNzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCAncHJvZ3Jlc3MnLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIG9uUHJvZ3Jlc3MoIGV2ZW50ICk7XHJcblxyXG4gICAgICAgICAgICB9LCBmYWxzZSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdlcnJvcicsIGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG9uRXJyb3IgKSBvbkVycm9yKCBldmVudCApO1xyXG5cclxuICAgICAgICAgICAgc2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xyXG5cclxuICAgICAgICB9LCBmYWxzZSApO1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMuY3Jvc3NPcmlnaW4gIT09IHVuZGVmaW5lZCApIGltYWdlLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcclxuXHJcbiAgICAgICAgc2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xyXG5cclxuICAgICAgICBpbWFnZS5zcmMgPSB1cmw7XHJcblxyXG4gICAgICAgIHJldHVybiBpbWFnZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2xvYWRlcnMvSlNPTkxvYWRlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuSlNPTkxvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcclxuXHJcbiAgICBpZiAoIHR5cGVvZiBtYW5hZ2VyID09PSAnYm9vbGVhbicgKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkpTT05Mb2FkZXI6IHNob3dTdGF0dXMgcGFyYW1ldGVyIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSBjb25zdHJ1Y3Rvci4nICk7XHJcbiAgICAgICAgbWFuYWdlciA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XHJcblxyXG4gICAgdGhpcy53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5KU09OTG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuSlNPTkxvYWRlcixcclxuXHJcbiAgICAvLyBEZXByZWNhdGVkXHJcblxyXG4gICAgZ2V0IHN0YXR1c0RvbUVsZW1lbnQgKCkge1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMuX3N0YXR1c0RvbUVsZW1lbnQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXR1c0RvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkpTT05Mb2FkZXI6IC5zdGF0dXNEb21FbGVtZW50IGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0dXNEb21FbGVtZW50O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbG9hZDogZnVuY3Rpb24oIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xyXG5cclxuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuICAgICAgICB2YXIgdGV4dHVyZVBhdGggPSB0aGlzLnRleHR1cmVQYXRoICYmICggdHlwZW9mIHRoaXMudGV4dHVyZVBhdGggPT09IFwic3RyaW5nXCIgKSA/IHRoaXMudGV4dHVyZVBhdGggOiBUSFJFRS5Mb2FkZXIucHJvdG90eXBlLmV4dHJhY3RVcmxCYXNlKCB1cmwgKTtcclxuXHJcbiAgICAgICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoIHRoaXMubWFuYWdlciApO1xyXG4gICAgICAgIGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xyXG4gICAgICAgIGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHRoaXMud2l0aENyZWRlbnRpYWxzICk7XHJcbiAgICAgICAgbG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGpzb24gPSBKU09OLnBhcnNlKCB0ZXh0ICk7XHJcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YSA9IGpzb24ubWV0YWRhdGE7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG1ldGFkYXRhICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBtZXRhZGF0YS50eXBlID09PSAnb2JqZWN0JyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLkpTT05Mb2FkZXI6ICcgKyB1cmwgKyAnIHNob3VsZCBiZSBsb2FkZWQgd2l0aCBUSFJFRS5PYmplY3RMb2FkZXIgaW5zdGVhZC4nICk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIG1ldGFkYXRhLnR5cGUgPT09ICdzY2VuZScgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5KU09OTG9hZGVyOiAnICsgdXJsICsgJyBzaG91bGQgYmUgbG9hZGVkIHdpdGggVEhSRUUuU2NlbmVMb2FkZXIgaW5zdGVhZC4nICk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSBzY29wZS5wYXJzZSgganNvbiwgdGV4dHVyZVBhdGggKTtcclxuICAgICAgICAgICAgb25Mb2FkKCBvYmplY3QuZ2VvbWV0cnksIG9iamVjdC5tYXRlcmlhbHMgKTtcclxuXHJcbiAgICAgICAgfSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldFRleHR1cmVQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuICAgICAgICB0aGlzLnRleHR1cmVQYXRoID0gdmFsdWU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBwYXJzZTogZnVuY3Rpb24gKCBqc29uLCB0ZXh0dXJlUGF0aCApIHtcclxuXHJcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCksXHJcbiAgICAgICAgICAgIHNjYWxlID0gKCBqc29uLnNjYWxlICE9PSB1bmRlZmluZWQgKSA/IDEuMCAvIGpzb24uc2NhbGUgOiAxLjA7XHJcblxyXG4gICAgICAgIHBhcnNlTW9kZWwoIHNjYWxlICk7XHJcblxyXG4gICAgICAgIHBhcnNlU2tpbigpO1xyXG4gICAgICAgIHBhcnNlTW9ycGhpbmcoIHNjYWxlICk7XHJcbiAgICAgICAgcGFyc2VBbmltYXRpb25zKCk7XHJcblxyXG4gICAgICAgIGdlb21ldHJ5LmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG4gICAgICAgIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBwYXJzZU1vZGVsKCBzY2FsZSApIHtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzQml0U2V0KCB2YWx1ZSwgcG9zaXRpb24gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICYgKCAxIDw8IHBvc2l0aW9uICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgaSwgaiwgZmksXHJcblxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0LCB6TGVuZ3RoLFxyXG5cclxuICAgICAgICAgICAgICAgIGNvbG9ySW5kZXgsIG5vcm1hbEluZGV4LCB1dkluZGV4LCBtYXRlcmlhbEluZGV4LFxyXG5cclxuICAgICAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgICAgICBpc1F1YWQsXHJcbiAgICAgICAgICAgICAgICBoYXNNYXRlcmlhbCxcclxuICAgICAgICAgICAgICAgIGhhc0ZhY2VWZXJ0ZXhVdixcclxuICAgICAgICAgICAgICAgIGhhc0ZhY2VOb3JtYWwsIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwsXHJcbiAgICAgICAgICAgICAgICBoYXNGYWNlQ29sb3IsIGhhc0ZhY2VWZXJ0ZXhDb2xvcixcclxuXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXgsIGZhY2UsIGZhY2VBLCBmYWNlQiwgaGV4LCBub3JtYWwsXHJcblxyXG4gICAgICAgICAgICAgICAgdXZMYXllciwgdXYsIHUsIHYsXHJcblxyXG4gICAgICAgICAgICAgICAgZmFjZXMgPSBqc29uLmZhY2VzLFxyXG4gICAgICAgICAgICAgICAgdmVydGljZXMgPSBqc29uLnZlcnRpY2VzLFxyXG4gICAgICAgICAgICAgICAgbm9ybWFscyA9IGpzb24ubm9ybWFscyxcclxuICAgICAgICAgICAgICAgIGNvbG9ycyA9IGpzb24uY29sb3JzLFxyXG5cclxuICAgICAgICAgICAgICAgIG5VdkxheWVycyA9IDA7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGpzb24udXZzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gZGlzcmVnYXJkIGVtcHR5IGFycmF5c1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwganNvbi51dnMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGpzb24udXZzWyBpIF0ubGVuZ3RoICkgblV2TGF5ZXJzICsrO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgekxlbmd0aCA9IHZlcnRpY2VzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIHdoaWxlICggb2Zmc2V0IDwgekxlbmd0aCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZlcnRleC54ID0gdmVydGljZXNbIG9mZnNldCArKyBdICogc2NhbGU7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXgueSA9IHZlcnRpY2VzWyBvZmZzZXQgKysgXSAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgdmVydGV4LnogPSB2ZXJ0aWNlc1sgb2Zmc2V0ICsrIF0gKiBzY2FsZTtcclxuXHJcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgIHpMZW5ndGggPSBmYWNlcy5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICB3aGlsZSAoIG9mZnNldCA8IHpMZW5ndGggKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdHlwZSA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgaXNRdWFkICAgICAgICAgICAgICA9IGlzQml0U2V0KCB0eXBlLCAwICk7XHJcbiAgICAgICAgICAgICAgICBoYXNNYXRlcmlhbCAgICAgICAgID0gaXNCaXRTZXQoIHR5cGUsIDEgKTtcclxuICAgICAgICAgICAgICAgIGhhc0ZhY2VWZXJ0ZXhVdiAgICAgPSBpc0JpdFNldCggdHlwZSwgMyApO1xyXG4gICAgICAgICAgICAgICAgaGFzRmFjZU5vcm1hbCAgICAgICA9IGlzQml0U2V0KCB0eXBlLCA0ICk7XHJcbiAgICAgICAgICAgICAgICBoYXNGYWNlVmVydGV4Tm9ybWFsID0gaXNCaXRTZXQoIHR5cGUsIDUgKTtcclxuICAgICAgICAgICAgICAgIGhhc0ZhY2VDb2xvclx0ICAgICA9IGlzQml0U2V0KCB0eXBlLCA2ICk7XHJcbiAgICAgICAgICAgICAgICBoYXNGYWNlVmVydGV4Q29sb3IgID0gaXNCaXRTZXQoIHR5cGUsIDcgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInR5cGVcIiwgdHlwZSwgXCJiaXRzXCIsIGlzUXVhZCwgaGFzTWF0ZXJpYWwsIGhhc0ZhY2VWZXJ0ZXhVdiwgaGFzRmFjZU5vcm1hbCwgaGFzRmFjZVZlcnRleE5vcm1hbCwgaGFzRmFjZUNvbG9yLCBoYXNGYWNlVmVydGV4Q29sb3IpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggaXNRdWFkICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmYWNlQSA9IG5ldyBUSFJFRS5GYWNlMygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZhY2VBLmEgPSBmYWNlc1sgb2Zmc2V0IF07XHJcbiAgICAgICAgICAgICAgICAgICAgZmFjZUEuYiA9IGZhY2VzWyBvZmZzZXQgKyAxIF07XHJcbiAgICAgICAgICAgICAgICAgICAgZmFjZUEuYyA9IGZhY2VzWyBvZmZzZXQgKyAzIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZhY2VCID0gbmV3IFRIUkVFLkZhY2UzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmFjZUIuYSA9IGZhY2VzWyBvZmZzZXQgKyAxIF07XHJcbiAgICAgICAgICAgICAgICAgICAgZmFjZUIuYiA9IGZhY2VzWyBvZmZzZXQgKyAyIF07XHJcbiAgICAgICAgICAgICAgICAgICAgZmFjZUIuYyA9IGZhY2VzWyBvZmZzZXQgKyAzIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGhhc01hdGVyaWFsICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZUEubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2VCLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGdldCBmYWNlIDw9PiB1diBpbmRleCBjb3JyZXNwb25kZW5jZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmaSA9IGdlb21ldHJ5LmZhY2VzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBoYXNGYWNlVmVydGV4VXYgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dkxheWVyID0ganNvbi51dnNbIGkgXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgKyAxIF0gPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBqID0gMDsgaiA8IDQ7IGogKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV2SW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSB1dkxheWVyWyB1dkluZGV4ICogMiBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSB1dkxheWVyWyB1dkluZGV4ICogMiArIDEgXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXYgPSBuZXcgVEhSRUUuVmVjdG9yMiggdSwgdiApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGogIT09IDIgKSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0ucHVzaCggdXYgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGogIT09IDAgKSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpICsgMSBdLnB1c2goIHV2ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggaGFzRmFjZU5vcm1hbCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdICogMztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2VBLm5vcm1hbC5zZXQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIG5vcm1hbEluZGV4IF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2VCLm5vcm1hbC5jb3B5KCBmYWNlQS5ub3JtYWwgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IDQ7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF0gKiAzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBub3JtYWxJbmRleCBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGkgIT09IDIgKSBmYWNlQS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpICE9PSAwICkgZmFjZUIudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBoYXNGYWNlQ29sb3IgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvckluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZXggPSBjb2xvcnNbIGNvbG9ySW5kZXggXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2VBLmNvbG9yLnNldEhleCggaGV4ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2VCLmNvbG9yLnNldEhleCggaGV4ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggaGFzRmFjZVZlcnRleENvbG9yICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCA0OyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZXggPSBjb2xvcnNbIGNvbG9ySW5kZXggXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGkgIT09IDIgKSBmYWNlQS52ZXJ0ZXhDb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCBoZXggKSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpICE9PSAwICkgZmFjZUIudmVydGV4Q29sb3JzLnB1c2goIG5ldyBUSFJFRS5Db2xvciggaGV4ICkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5mYWNlcy5wdXNoKCBmYWNlQSApO1xyXG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LmZhY2VzLnB1c2goIGZhY2VCICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZhY2UuYSA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuICAgICAgICAgICAgICAgICAgICBmYWNlLmIgPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcbiAgICAgICAgICAgICAgICAgICAgZmFjZS5jID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGhhc01hdGVyaWFsICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZS5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyB0byBnZXQgZmFjZSA8PT4gdXYgaW5kZXggY29ycmVzcG9uZGVuY2VcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZmkgPSBnZW9tZXRyeS5mYWNlcy5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggaGFzRmFjZVZlcnRleFV2ICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBuVXZMYXllcnM7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXZMYXllciA9IGpzb24udXZzWyBpIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggaiA9IDA7IGogPCAzOyBqICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dkluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ID0gdXZMYXllclsgdXZJbmRleCAqIDIgXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gdXZMYXllclsgdXZJbmRleCAqIDIgKyAxIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV2ID0gbmV3IFRIUkVFLlZlY3RvcjIoIHUsIHYgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdLnB1c2goIHV2ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggaGFzRmFjZU5vcm1hbCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdICogMztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2Uubm9ybWFsLnNldChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgbm9ybWFsSW5kZXggXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggaGFzRmFjZVZlcnRleE5vcm1hbCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgMzsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXSAqIDM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbIG5vcm1hbEluZGV4IF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjZS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGhhc0ZhY2VDb2xvciApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2UuY29sb3Iuc2V0SGV4KCBjb2xvcnNbIGNvbG9ySW5kZXggXSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGhhc0ZhY2VWZXJ0ZXhDb2xvciApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgMzsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvckluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjZS52ZXJ0ZXhDb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCBjb2xvcnNbIGNvbG9ySW5kZXggXSApICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuZmFjZXMucHVzaCggZmFjZSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcGFyc2VTa2luKCkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPSAoIGpzb24uaW5mbHVlbmNlc1BlclZlcnRleCAhPT0gdW5kZWZpbmVkICkgPyBqc29uLmluZmx1ZW5jZXNQZXJWZXJ0ZXggOiAyO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBqc29uLnNraW5XZWlnaHRzICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24uc2tpbldlaWdodHMubGVuZ3RoOyBpIDwgbDsgaSArPSBpbmZsdWVuY2VzUGVyVmVydGV4ICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb24uc2tpbldlaWdodHNbIGkgXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeSA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDEgKSA/IGpzb24uc2tpbldlaWdodHNbIGkgKyAxIF0gOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB6ID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMiApID8ganNvbi5za2luV2VpZ2h0c1sgaSArIDIgXSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHcgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAzICkgPyBqc29uLnNraW5XZWlnaHRzWyBpICsgMyBdIDogMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuc2tpbldlaWdodHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjQoIHgsIHksIHosIHcgKSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICgganNvbi5za2luSW5kaWNlcyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLnNraW5JbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKz0gaW5mbHVlbmNlc1BlclZlcnRleCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uLnNraW5JbmRpY2VzWyBpIF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAxICkgPyBqc29uLnNraW5JbmRpY2VzWyBpICsgMSBdIDogMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDIgKSA/IGpzb24uc2tpbkluZGljZXNbIGkgKyAyIF0gOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMyApID8ganNvbi5za2luSW5kaWNlc1sgaSArIDMgXSA6IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LnNraW5JbmRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3I0KCBhLCBiLCBjLCBkICkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBnZW9tZXRyeS5ib25lcyA9IGpzb24uYm9uZXM7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGdlb21ldHJ5LmJvbmVzICYmIGdlb21ldHJ5LmJvbmVzLmxlbmd0aCA+IDAgJiYgKCBnZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggIT09IGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCB8fCBnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggIT09IGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCApICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1doZW4gc2tpbm5pbmcsIG51bWJlciBvZiB2ZXJ0aWNlcyAoJyArIGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCArICcpLCBza2luSW5kaWNlcyAoJyArXHJcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoICsgJyksIGFuZCBza2luV2VpZ2h0cyAoJyArIGdlb21ldHJ5LnNraW5XZWlnaHRzLmxlbmd0aCArICcpIHNob3VsZCBtYXRjaC4nICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlTW9ycGhpbmcoIHNjYWxlICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBqc29uLm1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0ubmFtZSA9IGpzb24ubW9ycGhUYXJnZXRzWyBpIF0ubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZHN0VmVydGljZXMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3JjVmVydGljZXMgPSBqc29uLm1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgdiA9IDAsIHZsID0gc3JjVmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKz0gMyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXgueCA9IHNyY1ZlcnRpY2VzWyB2IF0gKiBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4LnkgPSBzcmNWZXJ0aWNlc1sgdiArIDEgXSAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXgueiA9IHNyY1ZlcnRpY2VzWyB2ICsgMiBdICogc2NhbGU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkc3RWZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICgganNvbi5tb3JwaENvbG9ycyAhPT0gdW5kZWZpbmVkICYmIGpzb24ubW9ycGhDb2xvcnMubGVuZ3RoID4gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5KU09OTG9hZGVyOiBcIm1vcnBoQ29sb3JzXCIgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gVXNpbmcgdGhlbSBhcyBmYWNlIGNvbG9ycy4nICk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgbW9ycGhDb2xvcnMgPSBqc29uLm1vcnBoQ29sb3JzWyAwIF0uY29sb3JzO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZhY2VzWyBpIF0uY29sb3IuZnJvbUFycmF5KCBtb3JwaENvbG9ycywgaSAqIDMgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcGFyc2VBbmltYXRpb25zKCkge1xyXG5cclxuICAgICAgICAgICAgdmFyIG91dHB1dEFuaW1hdGlvbnMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIC8vIHBhcnNlIG9sZCBzdHlsZSBCb25lL0hpZXJhcmNoeSBhbmltYXRpb25zXHJcbiAgICAgICAgICAgIHZhciBhbmltYXRpb25zID0gW107XHJcbiAgICAgICAgICAgIGlmICgganNvbi5hbmltYXRpb24gIT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnMucHVzaCgganNvbi5hbmltYXRpb24gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIGpzb24uYW5pbWF0aW9ucyAhPT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCBqc29uLmFuaW1hdGlvbnMubGVuZ3RoICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbnMgPSBhbmltYXRpb25zLmNvbmNhdCgganNvbi5hbmltYXRpb25zICk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbnMucHVzaCgganNvbi5hbmltYXRpb25zICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGFuaW1hdGlvbnMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBjbGlwID0gVEhSRUUuQW5pbWF0aW9uQ2xpcC5wYXJzZUFuaW1hdGlvbiggYW5pbWF0aW9uc1tpXSwgZ2VvbWV0cnkuYm9uZXMgKTtcclxuICAgICAgICAgICAgICAgIGlmICggY2xpcCApIG91dHB1dEFuaW1hdGlvbnMucHVzaCggY2xpcCApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gcGFyc2UgaW1wbGljaXQgbW9ycGggYW5pbWF0aW9uc1xyXG4gICAgICAgICAgICBpZiAoIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoYXQgYW4gYXBwcm9wcmFpdGUgRlBTIGlzIGZvciBtb3JwaCB0YXJnZXQgYW5pbWF0aW9ucyAtLSBkZWZhdWx0aW5nIHRvIDEwLCBidXQgcmVhbGx5IGl0IGlzIGNvbXBsZXRlbHkgYXJiaXRyYXJ5LlxyXG4gICAgICAgICAgICAgICAgdmFyIG1vcnBoQW5pbWF0aW9uQ2xpcHMgPSBUSFJFRS5BbmltYXRpb25DbGlwLkNyZWF0ZUNsaXBzRnJvbU1vcnBoVGFyZ2V0U2VxdWVuY2VzKCBnZW9tZXRyeS5tb3JwaFRhcmdldHMsIDEwICk7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXRBbmltYXRpb25zID0gb3V0cHV0QW5pbWF0aW9ucy5jb25jYXQoIG1vcnBoQW5pbWF0aW9uQ2xpcHMgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggb3V0cHV0QW5pbWF0aW9ucy5sZW5ndGggPiAwICkgZ2VvbWV0cnkuYW5pbWF0aW9ucyA9IG91dHB1dEFuaW1hdGlvbnM7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmICgganNvbi5tYXRlcmlhbHMgPT09IHVuZGVmaW5lZCB8fCBqc29uLm1hdGVyaWFscy5sZW5ndGggPT09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4geyBnZW9tZXRyeTogZ2VvbWV0cnkgfTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBtYXRlcmlhbHMgPSBUSFJFRS5Mb2FkZXIucHJvdG90eXBlLmluaXRNYXRlcmlhbHMoIGpzb24ubWF0ZXJpYWxzLCB0ZXh0dXJlUGF0aCwgdGhpcy5jcm9zc09yaWdpbiApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHsgZ2VvbWV0cnk6IGdlb21ldHJ5LCBtYXRlcmlhbHM6IG1hdGVyaWFscyB9O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2xvYWRlcnMvTG9hZGluZ01hbmFnZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkxvYWRpbmdNYW5hZ2VyID0gZnVuY3Rpb24gKCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XHJcblxyXG4gICAgdmFyIHNjb3BlID0gdGhpcztcclxuXHJcbiAgICB2YXIgaXNMb2FkaW5nID0gZmFsc2UsIGl0ZW1zTG9hZGVkID0gMCwgaXRlbXNUb3RhbCA9IDA7XHJcblxyXG4gICAgdGhpcy5vblN0YXJ0ID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5vbkxvYWQgPSBvbkxvYWQ7XHJcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBvblByb2dyZXNzO1xyXG4gICAgdGhpcy5vbkVycm9yID0gb25FcnJvcjtcclxuXHJcbiAgICB0aGlzLml0ZW1TdGFydCA9IGZ1bmN0aW9uICggdXJsICkge1xyXG5cclxuICAgICAgICBpdGVtc1RvdGFsICsrO1xyXG5cclxuICAgICAgICBpZiAoIGlzTG9hZGluZyA9PT0gZmFsc2UgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHNjb3BlLm9uU3RhcnQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBzY29wZS5vblN0YXJ0KCB1cmwsIGl0ZW1zTG9hZGVkLCBpdGVtc1RvdGFsICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaXNMb2FkaW5nID0gdHJ1ZTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuaXRlbUVuZCA9IGZ1bmN0aW9uICggdXJsICkge1xyXG5cclxuICAgICAgICBpdGVtc0xvYWRlZCArKztcclxuXHJcbiAgICAgICAgaWYgKCBzY29wZS5vblByb2dyZXNzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBzY29wZS5vblByb2dyZXNzKCB1cmwsIGl0ZW1zTG9hZGVkLCBpdGVtc1RvdGFsICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBpdGVtc0xvYWRlZCA9PT0gaXRlbXNUb3RhbCApIHtcclxuXHJcbiAgICAgICAgICAgIGlzTG9hZGluZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBzY29wZS5vbkxvYWQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBzY29wZS5vbkxvYWQoKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5pdGVtRXJyb3IgPSBmdW5jdGlvbiAoIHVybCApIHtcclxuXHJcbiAgICAgICAgaWYgKCBzY29wZS5vbkVycm9yICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBzY29wZS5vbkVycm9yKCB1cmwgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyID0gbmV3IFRIUkVFLkxvYWRpbmdNYW5hZ2VyKCk7XHJcblxyXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0J1ZmZlckdlb21ldHJ5TG9hZGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5CdWZmZXJHZW9tZXRyeUxvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcclxuXHJcbiAgICB0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5CdWZmZXJHZW9tZXRyeUxvYWRlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkJ1ZmZlckdlb21ldHJ5TG9hZGVyLFxyXG5cclxuICAgIGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XHJcblxyXG4gICAgICAgIHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG4gICAgICAgIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuWEhSTG9hZGVyKCBzY29wZS5tYW5hZ2VyICk7XHJcbiAgICAgICAgbG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XHJcbiAgICAgICAgbG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xyXG5cclxuICAgICAgICAgICAgb25Mb2FkKCBzY29wZS5wYXJzZSggSlNPTi5wYXJzZSggdGV4dCApICkgKTtcclxuXHJcbiAgICAgICAgfSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHBhcnNlOiBmdW5jdGlvbiAoIGpzb24gKSB7XHJcblxyXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xyXG5cclxuICAgICAgICB2YXIgaW5kZXggPSBqc29uLmRhdGEuaW5kZXg7XHJcblxyXG4gICAgICAgIGlmICggaW5kZXggIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciB0eXBlZEFycmF5ID0gbmV3IHNlbGZbIGluZGV4LnR5cGUgXSggaW5kZXguYXJyYXkgKTtcclxuICAgICAgICAgICAgZ2VvbWV0cnkuc2V0SW5kZXgoIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHR5cGVkQXJyYXksIDEgKSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0ganNvbi5kYXRhLmF0dHJpYnV0ZXM7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBrZXkgaW4gYXR0cmlidXRlcyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcclxuICAgICAgICAgICAgdmFyIHR5cGVkQXJyYXkgPSBuZXcgc2VsZlsgYXR0cmlidXRlLnR5cGUgXSggYXR0cmlidXRlLmFycmF5ICk7XHJcblxyXG4gICAgICAgICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoIGtleSwgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdHlwZWRBcnJheSwgYXR0cmlidXRlLml0ZW1TaXplICkgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZ3JvdXBzID0ganNvbi5kYXRhLmdyb3VwcyB8fCBqc29uLmRhdGEuZHJhd2NhbGxzIHx8IGpzb24uZGF0YS5vZmZzZXRzO1xyXG5cclxuICAgICAgICBpZiAoIGdyb3VwcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBuID0gZ3JvdXBzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNbIGkgXTtcclxuXHJcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS5hZGRHcm91cCggZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50ICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGJvdW5kaW5nU3BoZXJlID0ganNvbi5kYXRhLmJvdW5kaW5nU3BoZXJlO1xyXG5cclxuICAgICAgICBpZiAoIGJvdW5kaW5nU3BoZXJlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgY2VudGVyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggYm91bmRpbmdTcGhlcmUuY2VudGVyICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY2VudGVyLmZyb21BcnJheSggYm91bmRpbmdTcGhlcmUuY2VudGVyICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoIGNlbnRlciwgYm91bmRpbmdTcGhlcmUucmFkaXVzICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGdlb21ldHJ5O1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9sb2FkZXJzL01hdGVyaWFsTG9hZGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5NYXRlcmlhbExvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcclxuXHJcbiAgICB0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcclxuICAgIHRoaXMudGV4dHVyZXMgPSB7fTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5NYXRlcmlhbExvYWRlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLk1hdGVyaWFsTG9hZGVyLFxyXG5cclxuICAgIGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XHJcblxyXG4gICAgICAgIHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG4gICAgICAgIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuWEhSTG9hZGVyKCBzY29wZS5tYW5hZ2VyICk7XHJcbiAgICAgICAgbG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XHJcbiAgICAgICAgbG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xyXG5cclxuICAgICAgICAgICAgb25Mb2FkKCBzY29wZS5wYXJzZSggSlNPTi5wYXJzZSggdGV4dCApICkgKTtcclxuXHJcbiAgICAgICAgfSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldFRleHR1cmVzOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuICAgICAgICB0aGlzLnRleHR1cmVzID0gdmFsdWU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRUZXh0dXJlOiBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG4gICAgICAgIHZhciB0ZXh0dXJlcyA9IHRoaXMudGV4dHVyZXM7XHJcblxyXG4gICAgICAgIGlmICggdGV4dHVyZXNbIG5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuTWF0ZXJpYWxMb2FkZXI6IFVuZGVmaW5lZCB0ZXh0dXJlJywgbmFtZSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0dXJlc1sgbmFtZSBdO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcGFyc2U6IGZ1bmN0aW9uICgganNvbiApIHtcclxuXHJcbiAgICAgICAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFWyBqc29uLnR5cGUgXTtcclxuICAgICAgICBtYXRlcmlhbC51dWlkID0ganNvbi51dWlkO1xyXG5cclxuICAgICAgICBpZiAoIGpzb24ubmFtZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubmFtZSA9IGpzb24ubmFtZTtcclxuICAgICAgICBpZiAoIGpzb24uY29sb3IgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmNvbG9yLnNldEhleCgganNvbi5jb2xvciApO1xyXG4gICAgICAgIGlmICgganNvbi5lbWlzc2l2ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZW1pc3NpdmUuc2V0SGV4KCBqc29uLmVtaXNzaXZlICk7XHJcbiAgICAgICAgaWYgKCBqc29uLnNwZWN1bGFyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zcGVjdWxhci5zZXRIZXgoIGpzb24uc3BlY3VsYXIgKTtcclxuICAgICAgICBpZiAoIGpzb24uc2hpbmluZXNzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaGluaW5lc3MgPSBqc29uLnNoaW5pbmVzcztcclxuICAgICAgICBpZiAoIGpzb24udW5pZm9ybXMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnVuaWZvcm1zID0ganNvbi51bmlmb3JtcztcclxuICAgICAgICBpZiAoIGpzb24udmVydGV4U2hhZGVyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC52ZXJ0ZXhTaGFkZXIgPSBqc29uLnZlcnRleFNoYWRlcjtcclxuICAgICAgICBpZiAoIGpzb24uZnJhZ21lbnRTaGFkZXIgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyID0ganNvbi5mcmFnbWVudFNoYWRlcjtcclxuICAgICAgICBpZiAoIGpzb24udmVydGV4Q29sb3JzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSBqc29uLnZlcnRleENvbG9ycztcclxuICAgICAgICBpZiAoIGpzb24uc2hhZGluZyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2hhZGluZyA9IGpzb24uc2hhZGluZztcclxuICAgICAgICBpZiAoIGpzb24uYmxlbmRpbmcgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmJsZW5kaW5nID0ganNvbi5ibGVuZGluZztcclxuICAgICAgICBpZiAoIGpzb24uc2lkZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2lkZSA9IGpzb24uc2lkZTtcclxuICAgICAgICBpZiAoIGpzb24ub3BhY2l0eSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwub3BhY2l0eSA9IGpzb24ub3BhY2l0eTtcclxuICAgICAgICBpZiAoIGpzb24udHJhbnNwYXJlbnQgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnRyYW5zcGFyZW50ID0ganNvbi50cmFuc3BhcmVudDtcclxuICAgICAgICBpZiAoIGpzb24uYWxwaGFUZXN0ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hbHBoYVRlc3QgPSBqc29uLmFscGhhVGVzdDtcclxuICAgICAgICBpZiAoIGpzb24uZGVwdGhUZXN0ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kZXB0aFRlc3QgPSBqc29uLmRlcHRoVGVzdDtcclxuICAgICAgICBpZiAoIGpzb24uZGVwdGhXcml0ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGVwdGhXcml0ZSA9IGpzb24uZGVwdGhXcml0ZTtcclxuICAgICAgICBpZiAoIGpzb24ud2lyZWZyYW1lICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC53aXJlZnJhbWUgPSBqc29uLndpcmVmcmFtZTtcclxuICAgICAgICBpZiAoIGpzb24ud2lyZWZyYW1lTGluZXdpZHRoICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggPSBqc29uLndpcmVmcmFtZUxpbmV3aWR0aDtcclxuXHJcbiAgICAgICAgLy8gZm9yIFBvaW50c01hdGVyaWFsXHJcbiAgICAgICAgaWYgKCBqc29uLnNpemUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNpemUgPSBqc29uLnNpemU7XHJcbiAgICAgICAgaWYgKCBqc29uLnNpemVBdHRlbnVhdGlvbiAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uID0ganNvbi5zaXplQXR0ZW51YXRpb247XHJcblxyXG4gICAgICAgIC8vIG1hcHNcclxuXHJcbiAgICAgICAgaWYgKCBqc29uLm1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubWFwID0gdGhpcy5nZXRUZXh0dXJlKCBqc29uLm1hcCApO1xyXG5cclxuICAgICAgICBpZiAoIGpzb24uYWxwaGFNYXAgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIG1hdGVyaWFsLmFscGhhTWFwID0gdGhpcy5nZXRUZXh0dXJlKCBqc29uLmFscGhhTWFwICk7XHJcbiAgICAgICAgICAgIG1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIGpzb24uYnVtcE1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYnVtcE1hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5idW1wTWFwICk7XHJcbiAgICAgICAgaWYgKCBqc29uLmJ1bXBTY2FsZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYnVtcFNjYWxlID0ganNvbi5idW1wU2NhbGU7XHJcblxyXG4gICAgICAgIGlmICgganNvbi5ub3JtYWxNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm5vcm1hbE1hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5ub3JtYWxNYXAgKTtcclxuICAgICAgICBpZiAoIGpzb24ubm9ybWFsU2NhbGUgKVx0bWF0ZXJpYWwubm9ybWFsU2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMigganNvbi5ub3JtYWxTY2FsZSwganNvbi5ub3JtYWxTY2FsZSApO1xyXG5cclxuICAgICAgICBpZiAoIGpzb24uZGlzcGxhY2VtZW50TWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgPSB0aGlzLmdldFRleHR1cmUoIGpzb24uZGlzcGxhY2VtZW50TWFwICk7XHJcbiAgICAgICAgaWYgKCBqc29uLmRpc3BsYWNlbWVudFNjYWxlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZSA9IGpzb24uZGlzcGxhY2VtZW50U2NhbGU7XHJcbiAgICAgICAgaWYgKCBqc29uLmRpc3BsYWNlbWVudEJpYXMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXMgPSBqc29uLmRpc3BsYWNlbWVudEJpYXM7XHJcblxyXG4gICAgICAgIGlmICgganNvbi5zcGVjdWxhck1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc3BlY3VsYXJNYXAgPSB0aGlzLmdldFRleHR1cmUoIGpzb24uc3BlY3VsYXJNYXAgKTtcclxuXHJcbiAgICAgICAgaWYgKCBqc29uLmVudk1hcCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgbWF0ZXJpYWwuZW52TWFwID0gdGhpcy5nZXRUZXh0dXJlKCBqc29uLmVudk1hcCApO1xyXG4gICAgICAgICAgICBtYXRlcmlhbC5jb21iaW5lID0gVEhSRUUuTXVsdGlwbHlPcGVyYXRpb247XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBqc29uLnJlZmxlY3Rpdml0eSApIG1hdGVyaWFsLnJlZmxlY3Rpdml0eSA9IGpzb24ucmVmbGVjdGl2aXR5O1xyXG5cclxuICAgICAgICBpZiAoIGpzb24ubGlnaHRNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmxpZ2h0TWFwID0gdGhpcy5nZXRUZXh0dXJlKCBqc29uLmxpZ2h0TWFwICk7XHJcbiAgICAgICAgaWYgKCBqc29uLmxpZ2h0TWFwSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5saWdodE1hcEludGVuc2l0eSA9IGpzb24ubGlnaHRNYXBJbnRlbnNpdHk7XHJcblxyXG4gICAgICAgIGlmICgganNvbi5hb01hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYW9NYXAgPSB0aGlzLmdldFRleHR1cmUoIGpzb24uYW9NYXAgKTtcclxuICAgICAgICBpZiAoIGpzb24uYW9NYXBJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmFvTWFwSW50ZW5zaXR5ID0ganNvbi5hb01hcEludGVuc2l0eTtcclxuXHJcbiAgICAgICAgLy8gTWVzaEZhY2VNYXRlcmlhbFxyXG5cclxuICAgICAgICBpZiAoIGpzb24ubWF0ZXJpYWxzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLm1hdGVyaWFscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIG1hdGVyaWFsLm1hdGVyaWFscy5wdXNoKCB0aGlzLnBhcnNlKCBqc29uLm1hdGVyaWFsc1sgaSBdICkgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbWF0ZXJpYWw7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2xvYWRlcnMvT2JqZWN0TG9hZGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5PYmplY3RMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XHJcblxyXG4gICAgdGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XHJcbiAgICB0aGlzLnRleHR1cmVQYXRoID0gJyc7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuT2JqZWN0TG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuT2JqZWN0TG9hZGVyLFxyXG5cclxuICAgIGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy50ZXh0dXJlUGF0aCA9PT0gJycgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnRleHR1cmVQYXRoID0gdXJsLnN1YnN0cmluZyggMCwgdXJsLmxhc3RJbmRleE9mKCAnLycgKSArIDEgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuICAgICAgICB2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlciggc2NvcGUubWFuYWdlciApO1xyXG4gICAgICAgIGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xyXG4gICAgICAgIGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcclxuXHJcbiAgICAgICAgICAgIHNjb3BlLnBhcnNlKCBKU09OLnBhcnNlKCB0ZXh0ICksIG9uTG9hZCApO1xyXG5cclxuICAgICAgICB9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRUZXh0dXJlUGF0aDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgdGhpcy50ZXh0dXJlUGF0aCA9IHZhbHVlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHBhcnNlOiBmdW5jdGlvbiAoIGpzb24sIG9uTG9hZCApIHtcclxuXHJcbiAgICAgICAgdmFyIGdlb21ldHJpZXMgPSB0aGlzLnBhcnNlR2VvbWV0cmllcygganNvbi5nZW9tZXRyaWVzICk7XHJcblxyXG4gICAgICAgIHZhciBpbWFnZXMgPSB0aGlzLnBhcnNlSW1hZ2VzKCBqc29uLmltYWdlcywgZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBvbkxvYWQgIT09IHVuZGVmaW5lZCApIG9uTG9hZCggb2JqZWN0ICk7XHJcblxyXG4gICAgICAgIH0gKTtcclxuXHJcbiAgICAgICAgdmFyIHRleHR1cmVzICA9IHRoaXMucGFyc2VUZXh0dXJlcygganNvbi50ZXh0dXJlcywgaW1hZ2VzICk7XHJcbiAgICAgICAgdmFyIG1hdGVyaWFscyA9IHRoaXMucGFyc2VNYXRlcmlhbHMoIGpzb24ubWF0ZXJpYWxzLCB0ZXh0dXJlcyApO1xyXG5cclxuICAgICAgICB2YXIgb2JqZWN0ID0gdGhpcy5wYXJzZU9iamVjdCgganNvbi5vYmplY3QsIGdlb21ldHJpZXMsIG1hdGVyaWFscyApO1xyXG5cclxuICAgICAgICBpZiAoIGpzb24uYW5pbWF0aW9ucyApIHtcclxuXHJcbiAgICAgICAgICAgIG9iamVjdC5hbmltYXRpb25zID0gdGhpcy5wYXJzZUFuaW1hdGlvbnMoIGpzb24uYW5pbWF0aW9ucyApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgganNvbi5pbWFnZXMgPT09IHVuZGVmaW5lZCB8fCBqc29uLmltYWdlcy5sZW5ndGggPT09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkgb25Mb2FkKCBvYmplY3QgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gb2JqZWN0O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcGFyc2VHZW9tZXRyaWVzOiBmdW5jdGlvbiAoIGpzb24gKSB7XHJcblxyXG4gICAgICAgIHZhciBnZW9tZXRyaWVzID0ge307XHJcblxyXG4gICAgICAgIGlmICgganNvbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGdlb21ldHJ5TG9hZGVyID0gbmV3IFRIUkVFLkpTT05Mb2FkZXIoKTtcclxuICAgICAgICAgICAgdmFyIGJ1ZmZlckdlb21ldHJ5TG9hZGVyID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5TG9hZGVyKCk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGdlb21ldHJ5O1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBqc29uWyBpIF07XHJcblxyXG4gICAgICAgICAgICAgICAgc3dpdGNoICggZGF0YS50eXBlICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdQbGFuZUdlb21ldHJ5JzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdQbGFuZUJ1ZmZlckdlb21ldHJ5JzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFWyBkYXRhLnR5cGUgXShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEud2lkdGhTZWdtZW50cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuaGVpZ2h0U2VnbWVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdCb3hHZW9tZXRyeSc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQ3ViZUdlb21ldHJ5JzogLy8gYmFja3dhcmRzIGNvbXBhdGlibGVcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJveEdlb21ldHJ5KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5kZXB0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEud2lkdGhTZWdtZW50cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuaGVpZ2h0U2VnbWVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmRlcHRoU2VnbWVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdDaXJjbGVCdWZmZXJHZW9tZXRyeSc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5DaXJjbGVCdWZmZXJHZW9tZXRyeShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucmFkaXVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5zZWdtZW50cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudGhldGFTdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudGhldGFMZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdDaXJjbGVHZW9tZXRyeSc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5DaXJjbGVHZW9tZXRyeShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucmFkaXVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5zZWdtZW50cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudGhldGFTdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudGhldGFMZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdDeWxpbmRlckdlb21ldHJ5JzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJhZGl1c1RvcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucmFkaXVzQm90dG9tLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJhZGlhbFNlZ21lbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5oZWlnaHRTZWdtZW50cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEub3BlbkVuZGVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50aGV0YVN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50aGV0YUxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1NwaGVyZUdlb21ldHJ5JzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yYWRpdXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLndpZHRoU2VnbWVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmhlaWdodFNlZ21lbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5waGlTdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucGhpTGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50aGV0YVN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50aGV0YUxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1NwaGVyZUJ1ZmZlckdlb21ldHJ5JzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yYWRpdXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLndpZHRoU2VnbWVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmhlaWdodFNlZ21lbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5waGlTdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucGhpTGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50aGV0YVN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50aGV0YUxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0RvZGVjYWhlZHJvbkdlb21ldHJ5JzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkRvZGVjYWhlZHJvbkdlb21ldHJ5KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yYWRpdXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmRldGFpbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0ljb3NhaGVkcm9uR2VvbWV0cnknOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucmFkaXVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5kZXRhaWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdPY3RhaGVkcm9uR2VvbWV0cnknOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yYWRpdXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmRldGFpbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1RldHJhaGVkcm9uR2VvbWV0cnknOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucmFkaXVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5kZXRhaWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdSaW5nR2VvbWV0cnknOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuUmluZ0dlb21ldHJ5KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5pbm5lclJhZGl1cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEub3V0ZXJSYWRpdXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnRoZXRhU2VnbWVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnBoaVNlZ21lbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50aGV0YVN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50aGV0YUxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1RvcnVzR2VvbWV0cnknOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuVG9ydXNHZW9tZXRyeShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucmFkaXVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50dWJlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yYWRpYWxTZWdtZW50cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudHVidWxhclNlZ21lbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5hcmNcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdUb3J1c0tub3RHZW9tZXRyeSc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5Ub3J1c0tub3RHZW9tZXRyeShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucmFkaXVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50dWJlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yYWRpYWxTZWdtZW50cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudHVidWxhclNlZ21lbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5xLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5oZWlnaHRTY2FsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0J1ZmZlckdlb21ldHJ5JzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0gYnVmZmVyR2VvbWV0cnlMb2FkZXIucGFyc2UoIGRhdGEgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdHZW9tZXRyeSc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeSA9IGdlb21ldHJ5TG9hZGVyLnBhcnNlKCBkYXRhLmRhdGEsIHRoaXMudGV4dHVyZVBhdGggKS5nZW9tZXRyeTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbnN1cHBvcnRlZCBnZW9tZXRyeSB0eXBlIFwiJyArIGRhdGEudHlwZSArICdcIicgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS51dWlkID0gZGF0YS51dWlkO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSBnZW9tZXRyeS5uYW1lID0gZGF0YS5uYW1lO1xyXG5cclxuICAgICAgICAgICAgICAgIGdlb21ldHJpZXNbIGRhdGEudXVpZCBdID0gZ2VvbWV0cnk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGdlb21ldHJpZXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBwYXJzZU1hdGVyaWFsczogZnVuY3Rpb24gKCBqc29uLCB0ZXh0dXJlcyApIHtcclxuXHJcbiAgICAgICAgdmFyIG1hdGVyaWFscyA9IHt9O1xyXG5cclxuICAgICAgICBpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuTWF0ZXJpYWxMb2FkZXIoKTtcclxuICAgICAgICAgICAgbG9hZGVyLnNldFRleHR1cmVzKCB0ZXh0dXJlcyApO1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBtYXRlcmlhbCA9IGxvYWRlci5wYXJzZSgganNvblsgaSBdICk7XHJcbiAgICAgICAgICAgICAgICBtYXRlcmlhbHNbIG1hdGVyaWFsLnV1aWQgXSA9IG1hdGVyaWFsO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBtYXRlcmlhbHM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBwYXJzZUFuaW1hdGlvbnM6IGZ1bmN0aW9uICgganNvbiApIHtcclxuXHJcbiAgICAgICAgdmFyIGFuaW1hdGlvbnMgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwganNvbi5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgY2xpcCA9IFRIUkVFLkFuaW1hdGlvbkNsaXAucGFyc2UoIGpzb25baV0gKTtcclxuXHJcbiAgICAgICAgICAgIGFuaW1hdGlvbnMucHVzaCggY2xpcCApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhbmltYXRpb25zO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcGFyc2VJbWFnZXM6IGZ1bmN0aW9uICgganNvbiwgb25Mb2FkICkge1xyXG5cclxuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xyXG4gICAgICAgIHZhciBpbWFnZXMgPSB7fTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbG9hZEltYWdlKCB1cmwgKSB7XHJcblxyXG4gICAgICAgICAgICBzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAgICAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XHJcblxyXG4gICAgICAgICAgICB9ICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBqc29uICE9PSB1bmRlZmluZWQgJiYganNvbi5sZW5ndGggPiAwICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIG1hbmFnZXIgPSBuZXcgVEhSRUUuTG9hZGluZ01hbmFnZXIoIG9uTG9hZCApO1xyXG5cclxuICAgICAgICAgICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5JbWFnZUxvYWRlciggbWFuYWdlciApO1xyXG4gICAgICAgICAgICBsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgaW1hZ2UgPSBqc29uWyBpIF07XHJcbiAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IC9eKFxcL1xcLyl8KFthLXpdKzooXFwvXFwvKT8pL2kudGVzdCggaW1hZ2UudXJsICkgPyBpbWFnZS51cmwgOiBzY29wZS50ZXh0dXJlUGF0aCArIGltYWdlLnVybDtcclxuXHJcbiAgICAgICAgICAgICAgICBpbWFnZXNbIGltYWdlLnV1aWQgXSA9IGxvYWRJbWFnZSggcGF0aCApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBpbWFnZXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBwYXJzZVRleHR1cmVzOiBmdW5jdGlvbiAoIGpzb24sIGltYWdlcyApIHtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcGFyc2VDb25zdGFudCggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiggdmFsdWUgKSA9PT0gJ251bWJlcicgKSByZXR1cm4gdmFsdWU7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXIucGFyc2VUZXh0dXJlOiBDb25zdGFudCBzaG91bGQgYmUgaW4gbnVtZXJpYyBmb3JtLicsIHZhbHVlICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gVEhSRUVbIHZhbHVlIF07XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHRleHR1cmVzID0ge307XHJcblxyXG4gICAgICAgIGlmICgganNvbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0ganNvblsgaSBdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggZGF0YS5pbWFnZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IE5vIFwiaW1hZ2VcIiBzcGVjaWZpZWQgZm9yJywgZGF0YS51dWlkICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICggaW1hZ2VzWyBkYXRhLmltYWdlIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgaW1hZ2UnLCBkYXRhLmltYWdlICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoIGltYWdlc1sgZGF0YS5pbWFnZSBdICk7XHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLnV1aWQgPSBkYXRhLnV1aWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhLm5hbWUgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubmFtZSA9IGRhdGEubmFtZTtcclxuICAgICAgICAgICAgICAgIGlmICggZGF0YS5tYXBwaW5nICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm1hcHBpbmcgPSBwYXJzZUNvbnN0YW50KCBkYXRhLm1hcHBpbmcgKTtcclxuICAgICAgICAgICAgICAgIGlmICggZGF0YS5vZmZzZXQgIT09IHVuZGVmaW5lZCApIHRleHR1cmUub2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIGRhdGEub2Zmc2V0WyAwIF0sIGRhdGEub2Zmc2V0WyAxIF0gKTtcclxuICAgICAgICAgICAgICAgIGlmICggZGF0YS5yZXBlYXQgIT09IHVuZGVmaW5lZCApIHRleHR1cmUucmVwZWF0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIGRhdGEucmVwZWF0WyAwIF0sIGRhdGEucmVwZWF0WyAxIF0gKTtcclxuICAgICAgICAgICAgICAgIGlmICggZGF0YS5taW5GaWx0ZXIgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubWluRmlsdGVyID0gcGFyc2VDb25zdGFudCggZGF0YS5taW5GaWx0ZXIgKTtcclxuICAgICAgICAgICAgICAgIGlmICggZGF0YS5tYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubWFnRmlsdGVyID0gcGFyc2VDb25zdGFudCggZGF0YS5tYWdGaWx0ZXIgKTtcclxuICAgICAgICAgICAgICAgIGlmICggZGF0YS5hbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLmFuaXNvdHJvcHkgPSBkYXRhLmFuaXNvdHJvcHk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIEFycmF5LmlzQXJyYXkoIGRhdGEud3JhcCApICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLndyYXBTID0gcGFyc2VDb25zdGFudCggZGF0YS53cmFwWyAwIF0gKTtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLndyYXBUID0gcGFyc2VDb25zdGFudCggZGF0YS53cmFwWyAxIF0gKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGV4dHVyZXNbIGRhdGEudXVpZCBdID0gdGV4dHVyZTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGV4dHVyZXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBwYXJzZU9iamVjdDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggZGF0YSwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIG9iamVjdDtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldEdlb21ldHJ5KCBuYW1lICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggZ2VvbWV0cmllc1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIGdlb21ldHJ5JywgbmFtZSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VvbWV0cmllc1sgbmFtZSBdO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0TWF0ZXJpYWwoIG5hbWUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBuYW1lID09PSB1bmRlZmluZWQgKSByZXR1cm4gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggbWF0ZXJpYWxzWyBuYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgbWF0ZXJpYWwnLCBuYW1lICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRlcmlhbHNbIG5hbWUgXTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHN3aXRjaCAoIGRhdGEudHlwZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdTY2VuZSc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5TY2VuZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdQZXJzcGVjdGl2ZUNhbWVyYSc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZGF0YS5mb3YsIGRhdGEuYXNwZWN0LCBkYXRhLm5lYXIsIGRhdGEuZmFyICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ09ydGhvZ3JhcGhpY0NhbWVyYSc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoIGRhdGEubGVmdCwgZGF0YS5yaWdodCwgZGF0YS50b3AsIGRhdGEuYm90dG9tLCBkYXRhLm5lYXIsIGRhdGEuZmFyICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ0FtYmllbnRMaWdodCc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5BbWJpZW50TGlnaHQoIGRhdGEuY29sb3IgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnRGlyZWN0aW9uYWxMaWdodCc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdQb2ludExpZ2h0JzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLlBvaW50TGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5LCBkYXRhLmRpc3RhbmNlLCBkYXRhLmRlY2F5ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ1Nwb3RMaWdodCc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5TcG90TGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5LCBkYXRhLmRpc3RhbmNlLCBkYXRhLmFuZ2xlLCBkYXRhLmV4cG9uZW50LCBkYXRhLmRlY2F5ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ0hlbWlzcGhlcmVMaWdodCc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5IZW1pc3BoZXJlTGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuZ3JvdW5kQ29sb3IsIGRhdGEuaW50ZW5zaXR5ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ01lc2gnOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSBuZXcgVEhSRUUuTWVzaCggZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKSwgZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdMT0QnOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSBuZXcgVEhSRUUuTE9EKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ0xpbmUnOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSBuZXcgVEhSRUUuTGluZSggZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKSwgZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSwgZGF0YS5tb2RlICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ1BvaW50Q2xvdWQnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAnUG9pbnRzJzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLlBvaW50cyggZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKSwgZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdTcHJpdGUnOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSBuZXcgVEhSRUUuU3ByaXRlKCBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ0dyb3VwJzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLkdyb3VwKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgb2JqZWN0LnV1aWQgPSBkYXRhLnV1aWQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGRhdGEubmFtZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0Lm5hbWUgPSBkYXRhLm5hbWU7XHJcbiAgICAgICAgICAgIGlmICggZGF0YS5tYXRyaXggIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBtYXRyaXguZnJvbUFycmF5KCBkYXRhLm1hdHJpeCApO1xyXG4gICAgICAgICAgICAgICAgbWF0cml4LmRlY29tcG9zZSggb2JqZWN0LnBvc2l0aW9uLCBvYmplY3QucXVhdGVybmlvbiwgb2JqZWN0LnNjYWxlICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggZGF0YS5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnBvc2l0aW9uLmZyb21BcnJheSggZGF0YS5wb3NpdGlvbiApO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSBvYmplY3Qucm90YXRpb24uZnJvbUFycmF5KCBkYXRhLnJvdGF0aW9uICk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIGRhdGEuc2NhbGUgIT09IHVuZGVmaW5lZCApIG9iamVjdC5zY2FsZS5mcm9tQXJyYXkoIGRhdGEuc2NhbGUgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggZGF0YS5jYXN0U2hhZG93ICE9PSB1bmRlZmluZWQgKSBvYmplY3QuY2FzdFNoYWRvdyA9IGRhdGEuY2FzdFNoYWRvdztcclxuICAgICAgICAgICAgaWYgKCBkYXRhLnJlY2VpdmVTaGFkb3cgIT09IHVuZGVmaW5lZCApIG9iamVjdC5yZWNlaXZlU2hhZG93ID0gZGF0YS5yZWNlaXZlU2hhZG93O1xyXG5cclxuICAgICAgICAgICAgaWYgKCBkYXRhLnZpc2libGUgIT09IHVuZGVmaW5lZCApIG9iamVjdC52aXNpYmxlID0gZGF0YS52aXNpYmxlO1xyXG4gICAgICAgICAgICBpZiAoIGRhdGEudXNlckRhdGEgIT09IHVuZGVmaW5lZCApIG9iamVjdC51c2VyRGF0YSA9IGRhdGEudXNlckRhdGE7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGRhdGEuY2hpbGRyZW4gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgY2hpbGQgaW4gZGF0YS5jaGlsZHJlbiApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmFkZCggdGhpcy5wYXJzZU9iamVjdCggZGF0YS5jaGlsZHJlblsgY2hpbGQgXSwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzICkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIGRhdGEudHlwZSA9PT0gJ0xPRCcgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGxldmVscyA9IGRhdGEubGV2ZWxzO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBsID0gMDsgbCA8IGxldmVscy5sZW5ndGg7IGwgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsZXZlbCA9IGxldmVsc1sgbCBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IG9iamVjdC5nZXRPYmplY3RCeVByb3BlcnR5KCAndXVpZCcsIGxldmVsLm9iamVjdCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGNoaWxkICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuYWRkTGV2ZWwoIGNoaWxkLCBsZXZlbC5kaXN0YW5jZSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0oKVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2xvYWRlcnMvVGV4dHVyZUxvYWRlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuVGV4dHVyZUxvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcclxuXHJcbiAgICB0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5UZXh0dXJlTG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuVGV4dHVyZUxvYWRlcixcclxuXHJcbiAgICBsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xyXG5cclxuICAgICAgICB2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5UZXh0dXJlKCk7XHJcblxyXG4gICAgICAgIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuSW1hZ2VMb2FkZXIoIHRoaXMubWFuYWdlciApO1xyXG4gICAgICAgIGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xyXG4gICAgICAgIGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggaW1hZ2UgKSB7XHJcblxyXG4gICAgICAgICAgICB0ZXh0dXJlLmltYWdlID0gaW1hZ2U7XHJcbiAgICAgICAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBvbkxvYWQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBvbkxvYWQoIHRleHR1cmUgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2xvYWRlcnMvQ3ViZVRleHR1cmVMb2FkZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkN1YmVUZXh0dXJlTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xyXG5cclxuICAgIHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkN1YmVUZXh0dXJlTG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuQ3ViZVRleHR1cmVMb2FkZXIsXHJcblxyXG4gICAgbG9hZDogZnVuY3Rpb24gKCB1cmxzLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XHJcblxyXG4gICAgICAgIHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLkN1YmVUZXh0dXJlKCBbXSApO1xyXG5cclxuICAgICAgICB2YXIgbG9hZGVyID0gbmV3IFRIUkVFLkltYWdlTG9hZGVyKCk7XHJcbiAgICAgICAgbG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XHJcblxyXG4gICAgICAgIHZhciBsb2FkZWQgPSAwO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBsb2FkVGV4dHVyZSggaSApIHtcclxuXHJcbiAgICAgICAgICAgIGxvYWRlci5sb2FkKCB1cmxzWyBpIF0sIGZ1bmN0aW9uICggaW1hZ2UgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGV4dHVyZS5pbWFnZXNbIGkgXSA9IGltYWdlO1xyXG5cclxuICAgICAgICAgICAgICAgIGxvYWRlZCArKztcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGxvYWRlZCA9PT0gNiApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggb25Mb2FkICkgb25Mb2FkKCB0ZXh0dXJlICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSwgdW5kZWZpbmVkLCBvbkVycm9yICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdXJscy5sZW5ndGg7ICsrIGkgKSB7XHJcblxyXG4gICAgICAgICAgICBsb2FkVGV4dHVyZSggaSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbG9hZGVycy9CaW5hcnlUZXh0dXJlTG9hZGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBOaWtvcyBNLiAvIGh0dHBzOi8vZ2l0aHViLmNvbS9mb28xMjMvXHJcbiAqXHJcbiAqIEFic3RyYWN0IEJhc2UgY2xhc3MgdG8gbG9hZCBnZW5lcmljIGJpbmFyeSB0ZXh0dXJlcyBmb3JtYXRzIChyZ2JlLCBoZHIsIC4uLilcclxuICovXHJcblxyXG5USFJFRS5EYXRhVGV4dHVyZUxvYWRlciA9IFRIUkVFLkJpbmFyeVRleHR1cmVMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XHJcblxyXG4gICAgdGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XHJcblxyXG4gICAgLy8gb3ZlcnJpZGUgaW4gc3ViIGNsYXNzZXNcclxuICAgIHRoaXMuX3BhcnNlciA9IG51bGw7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQmluYXJ5VGV4dHVyZUxvYWRlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkJpbmFyeVRleHR1cmVMb2FkZXIsXHJcblxyXG4gICAgbG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcclxuXHJcbiAgICAgICAgdmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuRGF0YVRleHR1cmUoKTtcclxuXHJcbiAgICAgICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoIHRoaXMubWFuYWdlciApO1xyXG4gICAgICAgIGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xyXG4gICAgICAgIGxvYWRlci5zZXRSZXNwb25zZVR5cGUoICdhcnJheWJ1ZmZlcicgKTtcclxuXHJcbiAgICAgICAgbG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgdGV4RGF0YSA9IHNjb3BlLl9wYXJzZXIoIGJ1ZmZlciApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCAhIHRleERhdGEgKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBpZiAoIHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5pbWFnZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLmltYWdlID0gdGV4RGF0YS5pbWFnZTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5kYXRhICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHRleHR1cmUuaW1hZ2Uud2lkdGggPSB0ZXhEYXRhLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgdGV4dHVyZS5pbWFnZS5oZWlnaHQgPSB0ZXhEYXRhLmhlaWdodDtcclxuICAgICAgICAgICAgICAgIHRleHR1cmUuaW1hZ2UuZGF0YSA9IHRleERhdGEuZGF0YTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRleHR1cmUud3JhcFMgPSB1bmRlZmluZWQgIT09IHRleERhdGEud3JhcFMgPyB0ZXhEYXRhLndyYXBTIDogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcclxuICAgICAgICAgICAgdGV4dHVyZS53cmFwVCA9IHVuZGVmaW5lZCAhPT0gdGV4RGF0YS53cmFwVCA/IHRleERhdGEud3JhcFQgOiBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nO1xyXG5cclxuICAgICAgICAgICAgdGV4dHVyZS5tYWdGaWx0ZXIgPSB1bmRlZmluZWQgIT09IHRleERhdGEubWFnRmlsdGVyID8gdGV4RGF0YS5tYWdGaWx0ZXIgOiBUSFJFRS5MaW5lYXJGaWx0ZXI7XHJcbiAgICAgICAgICAgIHRleHR1cmUubWluRmlsdGVyID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLm1pbkZpbHRlciA/IHRleERhdGEubWluRmlsdGVyIDogVEhSRUUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyO1xyXG5cclxuICAgICAgICAgICAgdGV4dHVyZS5hbmlzb3Ryb3B5ID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLmFuaXNvdHJvcHkgPyB0ZXhEYXRhLmFuaXNvdHJvcHkgOiAxO1xyXG5cclxuICAgICAgICAgICAgaWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEuZm9ybWF0ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHRleHR1cmUuZm9ybWF0ID0gdGV4RGF0YS5mb3JtYXQ7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICggdW5kZWZpbmVkICE9PSB0ZXhEYXRhLnR5cGUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGV4dHVyZS50eXBlID0gdGV4RGF0YS50eXBlO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEubWlwbWFwcyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLm1pcG1hcHMgPSB0ZXhEYXRhLm1pcG1hcHM7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIDEgPT09IHRleERhdGEubWlwbWFwQ291bnQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGV4dHVyZS5taW5GaWx0ZXIgPSBUSFJFRS5MaW5lYXJGaWx0ZXI7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIGlmICggb25Mb2FkICkgb25Mb2FkKCB0ZXh0dXJlLCB0ZXhEYXRhICk7XHJcblxyXG4gICAgICAgIH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcclxuXHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbG9hZGVycy9Db21wcmVzc2VkVGV4dHVyZUxvYWRlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqXHJcbiAqIEFic3RyYWN0IEJhc2UgY2xhc3MgdG8gYmxvY2sgYmFzZWQgdGV4dHVyZXMgbG9hZGVyIChkZHMsIHB2ciwgLi4uKVxyXG4gKi9cclxuXHJcblRIUkVFLkNvbXByZXNzZWRUZXh0dXJlTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xyXG5cclxuICAgIHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xyXG5cclxuICAgIC8vIG92ZXJyaWRlIGluIHN1YiBjbGFzc2VzXHJcbiAgICB0aGlzLl9wYXJzZXIgPSBudWxsO1xyXG5cclxufTtcclxuXHJcblxyXG5USFJFRS5Db21wcmVzc2VkVGV4dHVyZUxvYWRlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLkNvbXByZXNzZWRUZXh0dXJlTG9hZGVyLFxyXG5cclxuICAgIGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XHJcblxyXG4gICAgICAgIHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG4gICAgICAgIHZhciBpbWFnZXMgPSBbXTtcclxuXHJcbiAgICAgICAgdmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUoKTtcclxuICAgICAgICB0ZXh0dXJlLmltYWdlID0gaW1hZ2VzO1xyXG5cclxuICAgICAgICB2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlciggdGhpcy5tYW5hZ2VyICk7XHJcbiAgICAgICAgbG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XHJcbiAgICAgICAgbG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2FycmF5YnVmZmVyJyApO1xyXG5cclxuICAgICAgICBpZiAoIEFycmF5LmlzQXJyYXkoIHVybCApICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGxvYWRlZCA9IDA7XHJcblxyXG4gICAgICAgICAgICB2YXIgbG9hZFRleHR1cmUgPSBmdW5jdGlvbiAoIGkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgbG9hZGVyLmxvYWQoIHVybFsgaSBdLCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleERhdGFzID0gc2NvcGUuX3BhcnNlciggYnVmZmVyLCB0cnVlICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlc1sgaSBdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGV4RGF0YXMud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGV4RGF0YXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IHRleERhdGFzLmZvcm1hdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWlwbWFwczogdGV4RGF0YXMubWlwbWFwc1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxvYWRlZCArPSAxO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGxvYWRlZCA9PT0gNiApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdGV4RGF0YXMubWlwbWFwQ291bnQgPT09IDEgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5taW5GaWx0ZXIgPSBUSFJFRS5MaW5lYXJGaWx0ZXI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLmZvcm1hdCA9IHRleERhdGFzLmZvcm1hdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xyXG5cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB1cmwubGVuZ3RoOyBpIDwgaWw7ICsrIGkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgbG9hZFRleHR1cmUoIGkgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGNvbXByZXNzZWQgY3ViZW1hcCB0ZXh0dXJlIHN0b3JlZCBpbiBhIHNpbmdsZSBERFMgZmlsZVxyXG5cclxuICAgICAgICAgICAgbG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHRleERhdGFzID0gc2NvcGUuX3BhcnNlciggYnVmZmVyLCB0cnVlICk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCB0ZXhEYXRhcy5pc0N1YmVtYXAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmYWNlcyA9IHRleERhdGFzLm1pcG1hcHMubGVuZ3RoIC8gdGV4RGF0YXMubWlwbWFwQ291bnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBmID0gMDsgZiA8IGZhY2VzOyBmICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyBmIF0gPSB7IG1pcG1hcHMgOiBbXSB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGV4RGF0YXMubWlwbWFwQ291bnQ7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyBmIF0ubWlwbWFwcy5wdXNoKCB0ZXhEYXRhcy5taXBtYXBzWyBmICogdGV4RGF0YXMubWlwbWFwQ291bnQgKyBpIF0gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlc1sgZiBdLmZvcm1hdCA9IHRleERhdGFzLmZvcm1hdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlc1sgZiBdLndpZHRoID0gdGV4RGF0YXMud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZXNbIGYgXS5oZWlnaHQgPSB0ZXhEYXRhcy5oZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLmltYWdlLndpZHRoID0gdGV4RGF0YXMud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5pbWFnZS5oZWlnaHQgPSB0ZXhEYXRhcy5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5taXBtYXBzID0gdGV4RGF0YXMubWlwbWFwcztcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCB0ZXhEYXRhcy5taXBtYXBDb3VudCA9PT0gMSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5taW5GaWx0ZXIgPSBUSFJFRS5MaW5lYXJGaWx0ZXI7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRleHR1cmUuZm9ybWF0ID0gdGV4RGF0YXMuZm9ybWF0O1xyXG4gICAgICAgICAgICAgICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcclxuXHJcbiAgICAgICAgICAgIH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGVyaWFscy9NYXRlcmlhbC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTWF0ZXJpYWwgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBUSFJFRS5NYXRlcmlhbElkQ291bnQgKysgfSApO1xyXG5cclxuICAgIHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XHJcblxyXG4gICAgdGhpcy5uYW1lID0gJyc7XHJcbiAgICB0aGlzLnR5cGUgPSAnTWF0ZXJpYWwnO1xyXG5cclxuICAgIHRoaXMuc2lkZSA9IFRIUkVFLkZyb250U2lkZTtcclxuXHJcbiAgICB0aGlzLm9wYWNpdHkgPSAxO1xyXG4gICAgdGhpcy50cmFuc3BhcmVudCA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuYmxlbmRpbmcgPSBUSFJFRS5Ob3JtYWxCbGVuZGluZztcclxuXHJcbiAgICB0aGlzLmJsZW5kU3JjID0gVEhSRUUuU3JjQWxwaGFGYWN0b3I7XHJcbiAgICB0aGlzLmJsZW5kRHN0ID0gVEhSRUUuT25lTWludXNTcmNBbHBoYUZhY3RvcjtcclxuICAgIHRoaXMuYmxlbmRFcXVhdGlvbiA9IFRIUkVFLkFkZEVxdWF0aW9uO1xyXG4gICAgdGhpcy5ibGVuZFNyY0FscGhhID0gbnVsbDtcclxuICAgIHRoaXMuYmxlbmREc3RBbHBoYSA9IG51bGw7XHJcbiAgICB0aGlzLmJsZW5kRXF1YXRpb25BbHBoYSA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5kZXB0aEZ1bmMgPSBUSFJFRS5MZXNzRXF1YWxEZXB0aDtcclxuICAgIHRoaXMuZGVwdGhUZXN0ID0gdHJ1ZTtcclxuICAgIHRoaXMuZGVwdGhXcml0ZSA9IHRydWU7XHJcblxyXG4gICAgdGhpcy5jb2xvcldyaXRlID0gdHJ1ZTtcclxuXHJcbiAgICB0aGlzLnByZWNpc2lvbiA9IG51bGw7IC8vIG92ZXJyaWRlIHRoZSByZW5kZXJlcidzIGRlZmF1bHQgcHJlY2lzaW9uIGZvciB0aGlzIG1hdGVyaWFsXHJcblxyXG4gICAgdGhpcy5wb2x5Z29uT2Zmc2V0ID0gZmFsc2U7XHJcbiAgICB0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3IgPSAwO1xyXG4gICAgdGhpcy5wb2x5Z29uT2Zmc2V0VW5pdHMgPSAwO1xyXG5cclxuICAgIHRoaXMuYWxwaGFUZXN0ID0gMDtcclxuXHJcbiAgICB0aGlzLm92ZXJkcmF3ID0gMDsgLy8gT3ZlcmRyYXduIHBpeGVscyAodHlwaWNhbGx5IGJldHdlZW4gMCBhbmQgMSkgZm9yIGZpeGluZyBhbnRpYWxpYXNpbmcgZ2FwcyBpbiBDYW52YXNSZW5kZXJlclxyXG5cclxuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XHJcblxyXG4gICAgdGhpcy5fbmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuTWF0ZXJpYWwsXHJcblxyXG4gICAgZ2V0IG5lZWRzVXBkYXRlICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25lZWRzVXBkYXRlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0IG5lZWRzVXBkYXRlICggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnVwZGF0ZSgpO1xyXG5cclxuICAgICAgICB0aGlzLl9uZWVkc1VwZGF0ZSA9IHZhbHVlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0VmFsdWVzOiBmdW5jdGlvbiAoIHZhbHVlcyApIHtcclxuXHJcbiAgICAgICAgaWYgKCB2YWx1ZXMgPT09IHVuZGVmaW5lZCApIHJldHVybjtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGtleSBpbiB2YWx1ZXMgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSB2YWx1ZXNbIGtleSBdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggXCJUSFJFRS5NYXRlcmlhbDogJ1wiICsga2V5ICsgXCInIHBhcmFtZXRlciBpcyB1bmRlZmluZWQuXCIgKTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IHRoaXNbIGtleSBdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBjdXJyZW50VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oIFwiVEhSRUUuXCIgKyB0aGlzLnR5cGUgKyBcIjogJ1wiICsga2V5ICsgXCInIGlzIG5vdCBhIHByb3BlcnR5IG9mIHRoaXMgbWF0ZXJpYWwuXCIgKTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBjdXJyZW50VmFsdWUgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUuc2V0KCBuZXdWYWx1ZSApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIGlmICggY3VycmVudFZhbHVlIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyAmJiBuZXdWYWx1ZSBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY3VycmVudFZhbHVlLmNvcHkoIG5ld1ZhbHVlICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBrZXkgPT09ICdvdmVyZHJhdycgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlIG92ZXJkcmF3IGlzIGJhY2t3YXJkcy1jb21wYXRpYmxlIHdpdGggbGVnYWN5IGJvb2xlYW4gdHlwZVxyXG4gICAgICAgICAgICAgICAgdGhpc1sga2V5IF0gPSBOdW1iZXIoIG5ld1ZhbHVlICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXNbIGtleSBdID0gbmV3VmFsdWU7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xyXG5cclxuICAgICAgICB2YXIgZGF0YSA9IHtcclxuICAgICAgICAgICAgbWV0YWRhdGE6IHtcclxuICAgICAgICAgICAgICAgIHZlcnNpb246IDQuNCxcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdNYXRlcmlhbCcsXHJcbiAgICAgICAgICAgICAgICBnZW5lcmF0b3I6ICdNYXRlcmlhbC50b0pTT04nXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBzdGFuZGFyZCBNYXRlcmlhbCBzZXJpYWxpemF0aW9uXHJcbiAgICAgICAgZGF0YS51dWlkID0gdGhpcy51dWlkO1xyXG4gICAgICAgIGRhdGEudHlwZSA9IHRoaXMudHlwZTtcclxuICAgICAgICBpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBkYXRhLm5hbWUgPSB0aGlzLm5hbWU7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5jb2xvciBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yICkgZGF0YS5jb2xvciA9IHRoaXMuY29sb3IuZ2V0SGV4KCk7XHJcbiAgICAgICAgaWYgKCB0aGlzLmVtaXNzaXZlIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgKSBkYXRhLmVtaXNzaXZlID0gdGhpcy5lbWlzc2l2ZS5nZXRIZXgoKTtcclxuICAgICAgICBpZiAoIHRoaXMuc3BlY3VsYXIgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciApIGRhdGEuc3BlY3VsYXIgPSB0aGlzLnNwZWN1bGFyLmdldEhleCgpO1xyXG4gICAgICAgIGlmICggdGhpcy5zaGluaW5lc3MgIT09IHVuZGVmaW5lZCApIGRhdGEuc2hpbmluZXNzID0gdGhpcy5zaGluaW5lc3M7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5tYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkgZGF0YS5tYXAgPSB0aGlzLm1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xyXG4gICAgICAgIGlmICggdGhpcy5hbHBoYU1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSBkYXRhLmFscGhhTWFwID0gdGhpcy5hbHBoYU1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xyXG4gICAgICAgIGlmICggdGhpcy5saWdodE1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSBkYXRhLmxpZ2h0TWFwID0gdGhpcy5saWdodE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xyXG4gICAgICAgIGlmICggdGhpcy5idW1wTWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIHtcclxuXHJcbiAgICAgICAgICAgIGRhdGEuYnVtcE1hcCA9IHRoaXMuYnVtcE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xyXG4gICAgICAgICAgICBkYXRhLmJ1bXBTY2FsZSA9IHRoaXMuYnVtcFNjYWxlO1xyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCB0aGlzLm5vcm1hbE1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSB7XHJcblxyXG4gICAgICAgICAgICBkYXRhLm5vcm1hbE1hcCA9IHRoaXMubm9ybWFsTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XHJcbiAgICAgICAgICAgIGRhdGEubm9ybWFsU2NhbGUgPSB0aGlzLm5vcm1hbFNjYWxlOyAvLyBSZW1vdmVkIGZvciBub3csIGNhdXNlcyBpc3N1ZSBpbiBlZGl0b3IgdWkuanNcclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICggdGhpcy5kaXNwbGFjZW1lbnRNYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkge1xyXG5cclxuICAgICAgICAgICAgZGF0YS5kaXNwbGFjZW1lbnRNYXAgPSB0aGlzLmRpc3BsYWNlbWVudE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xyXG4gICAgICAgICAgICBkYXRhLmRpc3BsYWNlbWVudFNjYWxlID0gdGhpcy5kaXNwbGFjZW1lbnRTY2FsZTtcclxuICAgICAgICAgICAgZGF0YS5kaXNwbGFjZW1lbnRCaWFzID0gdGhpcy5kaXNwbGFjZW1lbnRCaWFzO1xyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCB0aGlzLnNwZWN1bGFyTWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIGRhdGEuc3BlY3VsYXJNYXAgPSB0aGlzLnNwZWN1bGFyTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XHJcbiAgICAgICAgaWYgKCB0aGlzLmVudk1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSB7XHJcblxyXG4gICAgICAgICAgICBkYXRhLmVudk1hcCA9IHRoaXMuZW52TWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XHJcbiAgICAgICAgICAgIGRhdGEucmVmbGVjdGl2aXR5ID0gdGhpcy5yZWZsZWN0aXZpdHk7IC8vIFNjYWxlIGJlaGluZCBlbnZNYXBcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIHRoaXMuc2l6ZSAhPT0gdW5kZWZpbmVkICkgZGF0YS5zaXplID0gdGhpcy5zaXplO1xyXG4gICAgICAgIGlmICggdGhpcy5zaXplQXR0ZW51YXRpb24gIT09IHVuZGVmaW5lZCApIGRhdGEuc2l6ZUF0dGVudWF0aW9uID0gdGhpcy5zaXplQXR0ZW51YXRpb247XHJcblxyXG4gICAgICAgIGlmICggdGhpcy52ZXJ0ZXhDb2xvcnMgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnZlcnRleENvbG9ycyAhPT0gVEhSRUUuTm9Db2xvcnMgKSBkYXRhLnZlcnRleENvbG9ycyA9IHRoaXMudmVydGV4Q29sb3JzO1xyXG4gICAgICAgIGlmICggdGhpcy5zaGFkaW5nICE9PSB1bmRlZmluZWQgJiYgdGhpcy5zaGFkaW5nICE9PSBUSFJFRS5TbW9vdGhTaGFkaW5nICkgZGF0YS5zaGFkaW5nID0gdGhpcy5zaGFkaW5nO1xyXG4gICAgICAgIGlmICggdGhpcy5ibGVuZGluZyAhPT0gdW5kZWZpbmVkICYmIHRoaXMuYmxlbmRpbmcgIT09IFRIUkVFLk5vcm1hbEJsZW5kaW5nICkgZGF0YS5ibGVuZGluZyA9IHRoaXMuYmxlbmRpbmc7XHJcbiAgICAgICAgaWYgKCB0aGlzLnNpZGUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnNpZGUgIT09IFRIUkVFLkZyb250U2lkZSApIGRhdGEuc2lkZSA9IHRoaXMuc2lkZTtcclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLm9wYWNpdHkgPCAxICkgZGF0YS5vcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xyXG4gICAgICAgIGlmICggdGhpcy50cmFuc3BhcmVudCA9PT0gdHJ1ZSApIGRhdGEudHJhbnNwYXJlbnQgPSB0aGlzLnRyYW5zcGFyZW50O1xyXG4gICAgICAgIGlmICggdGhpcy5hbHBoYVRlc3QgPiAwICkgZGF0YS5hbHBoYVRlc3QgPSB0aGlzLmFscGhhVGVzdDtcclxuICAgICAgICBpZiAoIHRoaXMud2lyZWZyYW1lID09PSB0cnVlICkgZGF0YS53aXJlZnJhbWUgPSB0aGlzLndpcmVmcmFtZTtcclxuICAgICAgICBpZiAoIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID4gMSApIGRhdGEud2lyZWZyYW1lTGluZXdpZHRoID0gdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg7XHJcblxyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG4gICAgICAgIHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xyXG5cclxuICAgICAgICB0aGlzLnNpZGUgPSBzb3VyY2Uuc2lkZTtcclxuXHJcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gc291cmNlLm9wYWNpdHk7XHJcbiAgICAgICAgdGhpcy50cmFuc3BhcmVudCA9IHNvdXJjZS50cmFuc3BhcmVudDtcclxuXHJcbiAgICAgICAgdGhpcy5ibGVuZGluZyA9IHNvdXJjZS5ibGVuZGluZztcclxuXHJcbiAgICAgICAgdGhpcy5ibGVuZFNyYyA9IHNvdXJjZS5ibGVuZFNyYztcclxuICAgICAgICB0aGlzLmJsZW5kRHN0ID0gc291cmNlLmJsZW5kRHN0O1xyXG4gICAgICAgIHRoaXMuYmxlbmRFcXVhdGlvbiA9IHNvdXJjZS5ibGVuZEVxdWF0aW9uO1xyXG4gICAgICAgIHRoaXMuYmxlbmRTcmNBbHBoYSA9IHNvdXJjZS5ibGVuZFNyY0FscGhhO1xyXG4gICAgICAgIHRoaXMuYmxlbmREc3RBbHBoYSA9IHNvdXJjZS5ibGVuZERzdEFscGhhO1xyXG4gICAgICAgIHRoaXMuYmxlbmRFcXVhdGlvbkFscGhhID0gc291cmNlLmJsZW5kRXF1YXRpb25BbHBoYTtcclxuXHJcbiAgICAgICAgdGhpcy5kZXB0aEZ1bmMgPSBzb3VyY2UuZGVwdGhGdW5jO1xyXG4gICAgICAgIHRoaXMuZGVwdGhUZXN0ID0gc291cmNlLmRlcHRoVGVzdDtcclxuICAgICAgICB0aGlzLmRlcHRoV3JpdGUgPSBzb3VyY2UuZGVwdGhXcml0ZTtcclxuXHJcbiAgICAgICAgdGhpcy5wcmVjaXNpb24gPSBzb3VyY2UucHJlY2lzaW9uO1xyXG5cclxuICAgICAgICB0aGlzLnBvbHlnb25PZmZzZXQgPSBzb3VyY2UucG9seWdvbk9mZnNldDtcclxuICAgICAgICB0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3IgPSBzb3VyY2UucG9seWdvbk9mZnNldEZhY3RvcjtcclxuICAgICAgICB0aGlzLnBvbHlnb25PZmZzZXRVbml0cyA9IHNvdXJjZS5wb2x5Z29uT2Zmc2V0VW5pdHM7XHJcblxyXG4gICAgICAgIHRoaXMuYWxwaGFUZXN0ID0gc291cmNlLmFscGhhVGVzdDtcclxuXHJcbiAgICAgICAgdGhpcy5vdmVyZHJhdyA9IHNvdXJjZS5vdmVyZHJhdztcclxuXHJcbiAgICAgICAgdGhpcy52aXNpYmxlID0gc291cmNlLnZpc2libGU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAndXBkYXRlJyB9ICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLy8gRGVwcmVjYXRlZFxyXG5cclxuICAgIGdldCB3cmFwQXJvdW5kICgpIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuJyArIHRoaXMudHlwZSArICc6IC53cmFwQXJvdW5kIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0IHdyYXBBcm91bmQgKCBib29sZWFuICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS4nICsgdGhpcy50eXBlICsgJzogLndyYXBBcm91bmQgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXQgd3JhcFJHQiAoKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLicgKyB0aGlzLnR5cGUgKyAnOiAud3JhcFJHQiBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuICAgICAgICByZXR1cm4gbmV3IFRIUkVFLkNvbG9yKCk7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuTWF0ZXJpYWxJZENvdW50ID0gMDtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGVyaWFscy9MaW5lQmFzaWNNYXRlcmlhbC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqICBjb2xvcjogPGhleD4sXHJcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxyXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXHJcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICBsaW5ld2lkdGg6IDxmbG9hdD4sXHJcbiAqICBsaW5lY2FwOiBcInJvdW5kXCIsXHJcbiAqICBsaW5lam9pbjogXCJyb3VuZFwiLFxyXG4gKlxyXG4gKiAgdmVydGV4Q29sb3JzOiA8Ym9vbD5cclxuICpcclxuICogIGZvZzogPGJvb2w+XHJcbiAqIH1cclxuICovXHJcblxyXG5USFJFRS5MaW5lQmFzaWNNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcclxuXHJcbiAgICBUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ0xpbmVCYXNpY01hdGVyaWFsJztcclxuXHJcbiAgICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApO1xyXG5cclxuICAgIHRoaXMubGluZXdpZHRoID0gMTtcclxuICAgIHRoaXMubGluZWNhcCA9ICdyb3VuZCc7XHJcbiAgICB0aGlzLmxpbmVqb2luID0gJ3JvdW5kJztcclxuXHJcbiAgICB0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xyXG5cclxuICAgIHRoaXMuZm9nID0gdHJ1ZTtcclxuXHJcbiAgICB0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5USFJFRS5MaW5lQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbDtcclxuXHJcblRIUkVFLkxpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG4gICAgVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG4gICAgdGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcclxuXHJcbiAgICB0aGlzLmxpbmV3aWR0aCA9IHNvdXJjZS5saW5ld2lkdGg7XHJcbiAgICB0aGlzLmxpbmVjYXAgPSBzb3VyY2UubGluZWNhcDtcclxuICAgIHRoaXMubGluZWpvaW4gPSBzb3VyY2UubGluZWpvaW47XHJcblxyXG4gICAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xyXG5cclxuICAgIHRoaXMuZm9nID0gc291cmNlLmZvZztcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTGluZURhc2hlZE1hdGVyaWFsLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICogIGNvbG9yOiA8aGV4PixcclxuICogIG9wYWNpdHk6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXHJcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcclxuICogIGRlcHRoV3JpdGU6IDxib29sPixcclxuICpcclxuICogIGxpbmV3aWR0aDogPGZsb2F0PixcclxuICpcclxuICogIHNjYWxlOiA8ZmxvYXQ+LFxyXG4gKiAgZGFzaFNpemU6IDxmbG9hdD4sXHJcbiAqICBnYXBTaXplOiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgdmVydGV4Q29sb3JzOiA8Ym9vbD5cclxuICpcclxuICogIGZvZzogPGJvb2w+XHJcbiAqIH1cclxuICovXHJcblxyXG5USFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG4gICAgVEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdMaW5lRGFzaGVkTWF0ZXJpYWwnO1xyXG5cclxuICAgIHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XHJcblxyXG4gICAgdGhpcy5saW5ld2lkdGggPSAxO1xyXG5cclxuICAgIHRoaXMuc2NhbGUgPSAxO1xyXG4gICAgdGhpcy5kYXNoU2l6ZSA9IDM7XHJcbiAgICB0aGlzLmdhcFNpemUgPSAxO1xyXG5cclxuICAgIHRoaXMudmVydGV4Q29sb3JzID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5mb2cgPSB0cnVlO1xyXG5cclxuICAgIHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5USFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsO1xyXG5cclxuVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG4gICAgVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG4gICAgdGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcclxuXHJcbiAgICB0aGlzLmxpbmV3aWR0aCA9IHNvdXJjZS5saW5ld2lkdGg7XHJcblxyXG4gICAgdGhpcy5zY2FsZSA9IHNvdXJjZS5zY2FsZTtcclxuICAgIHRoaXMuZGFzaFNpemUgPSBzb3VyY2UuZGFzaFNpemU7XHJcbiAgICB0aGlzLmdhcFNpemUgPSBzb3VyY2UuZ2FwU2l6ZTtcclxuXHJcbiAgICB0aGlzLnZlcnRleENvbG9ycyA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnM7XHJcblxyXG4gICAgdGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGVyaWFscy9NZXNoQmFzaWNNYXRlcmlhbC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqICBjb2xvcjogPGhleD4sXHJcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxyXG4gKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKlxyXG4gKiAgYW9NYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqICBhb01hcEludGVuc2l0eTogPGZsb2F0PlxyXG4gKlxyXG4gKiAgc3BlY3VsYXJNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIGVudk1hcDogbmV3IFRIUkVFLlRleHR1cmVDdWJlKCBbcG9zeCwgbmVneCwgcG9zeSwgbmVneSwgcG9zeiwgbmVnel0gKSxcclxuICogIGNvbWJpbmU6IFRIUkVFLk11bHRpcGx5LFxyXG4gKiAgcmVmbGVjdGl2aXR5OiA8ZmxvYXQ+LFxyXG4gKiAgcmVmcmFjdGlvblJhdGlvOiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgc2hhZGluZzogVEhSRUUuU21vb3RoU2hhZGluZyxcclxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcclxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxyXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxyXG4gKlxyXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXHJcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLk5vQ29sb3JzIC8gVEhSRUUuVmVydGV4Q29sb3JzIC8gVEhSRUUuRmFjZUNvbG9ycyxcclxuICpcclxuICogIHNraW5uaW5nOiA8Ym9vbD4sXHJcbiAqICBtb3JwaFRhcmdldHM6IDxib29sPixcclxuICpcclxuICogIGZvZzogPGJvb2w+XHJcbiAqIH1cclxuICovXHJcblxyXG5USFJFRS5NZXNoQmFzaWNNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcclxuXHJcbiAgICBUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ01lc2hCYXNpY01hdGVyaWFsJztcclxuXHJcbiAgICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApOyAvLyBlbWlzc2l2ZVxyXG5cclxuICAgIHRoaXMubWFwID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLmFvTWFwID0gbnVsbDtcclxuICAgIHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XHJcblxyXG4gICAgdGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5hbHBoYU1hcCA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5lbnZNYXAgPSBudWxsO1xyXG4gICAgdGhpcy5jb21iaW5lID0gVEhSRUUuTXVsdGlwbHlPcGVyYXRpb247XHJcbiAgICB0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XHJcbiAgICB0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XHJcblxyXG4gICAgdGhpcy5mb2cgPSB0cnVlO1xyXG5cclxuICAgIHRoaXMuc2hhZGluZyA9IFRIUkVFLlNtb290aFNoYWRpbmc7XHJcblxyXG4gICAgdGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcclxuICAgIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcclxuICAgIHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XHJcbiAgICB0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcclxuXHJcbiAgICB0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xyXG5cclxuICAgIHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcclxuICAgIHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5NZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWw7XHJcblxyXG5USFJFRS5NZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuICAgIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuICAgIHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XHJcblxyXG4gICAgdGhpcy5tYXAgPSBzb3VyY2UubWFwO1xyXG5cclxuICAgIHRoaXMuYW9NYXAgPSBzb3VyY2UuYW9NYXA7XHJcbiAgICB0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xyXG5cclxuICAgIHRoaXMuc3BlY3VsYXJNYXAgPSBzb3VyY2Uuc3BlY3VsYXJNYXA7XHJcblxyXG4gICAgdGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcclxuXHJcbiAgICB0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XHJcbiAgICB0aGlzLmNvbWJpbmUgPSBzb3VyY2UuY29tYmluZTtcclxuICAgIHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcclxuICAgIHRoaXMucmVmcmFjdGlvblJhdGlvID0gc291cmNlLnJlZnJhY3Rpb25SYXRpbztcclxuXHJcbiAgICB0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XHJcblxyXG4gICAgdGhpcy5zaGFkaW5nID0gc291cmNlLnNoYWRpbmc7XHJcblxyXG4gICAgdGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xyXG4gICAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xyXG4gICAgdGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XHJcbiAgICB0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xyXG5cclxuICAgIHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcclxuXHJcbiAgICB0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xyXG4gICAgdGhpcy5tb3JwaFRhcmdldHMgPSBzb3VyY2UubW9ycGhUYXJnZXRzO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGVyaWFscy9NZXNoTGFtYmVydE1hdGVyaWFsLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICogIGNvbG9yOiA8aGV4PixcclxuICogIGVtaXNzaXZlOiA8aGV4PixcclxuICogIG9wYWNpdHk6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKlxyXG4gKiAgZW52TWFwOiBuZXcgVEhSRUUuVGV4dHVyZUN1YmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxyXG4gKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXHJcbiAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXHJcbiAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXHJcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcclxuICogIGRlcHRoV3JpdGU6IDxib29sPixcclxuICpcclxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxyXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgdmVydGV4Q29sb3JzOiBUSFJFRS5Ob0NvbG9ycyAvIFRIUkVFLlZlcnRleENvbG9ycyAvIFRIUkVFLkZhY2VDb2xvcnMsXHJcbiAqXHJcbiAqICBza2lubmluZzogPGJvb2w+LFxyXG4gKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXHJcbiAqICBtb3JwaE5vcm1hbHM6IDxib29sPixcclxuICpcclxuICpcdGZvZzogPGJvb2w+XHJcbiAqIH1cclxuICovXHJcblxyXG5USFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuICAgIFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnTWVzaExhbWJlcnRNYXRlcmlhbCc7XHJcblxyXG4gICAgdGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTsgLy8gZGlmZnVzZVxyXG4gICAgdGhpcy5lbWlzc2l2ZSA9IG5ldyBUSFJFRS5Db2xvciggMHgwMDAwMDAgKTtcclxuXHJcbiAgICB0aGlzLm1hcCA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5hbHBoYU1hcCA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5lbnZNYXAgPSBudWxsO1xyXG4gICAgdGhpcy5jb21iaW5lID0gVEhSRUUuTXVsdGlwbHlPcGVyYXRpb247XHJcbiAgICB0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XHJcbiAgICB0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XHJcblxyXG4gICAgdGhpcy5mb2cgPSB0cnVlO1xyXG5cclxuICAgIHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XHJcbiAgICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XHJcbiAgICB0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xyXG4gICAgdGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XHJcblxyXG4gICAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5Ob0NvbG9ycztcclxuXHJcbiAgICB0aGlzLnNraW5uaW5nID0gZmFsc2U7XHJcbiAgICB0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xyXG4gICAgdGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbDtcclxuXHJcblRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcbiAgICBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcbiAgICB0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xyXG4gICAgdGhpcy5lbWlzc2l2ZS5jb3B5KCBzb3VyY2UuZW1pc3NpdmUgKTtcclxuXHJcbiAgICB0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XHJcblxyXG4gICAgdGhpcy5zcGVjdWxhck1hcCA9IHNvdXJjZS5zcGVjdWxhck1hcDtcclxuXHJcbiAgICB0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xyXG5cclxuICAgIHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcclxuICAgIHRoaXMuY29tYmluZSA9IHNvdXJjZS5jb21iaW5lO1xyXG4gICAgdGhpcy5yZWZsZWN0aXZpdHkgPSBzb3VyY2UucmVmbGVjdGl2aXR5O1xyXG4gICAgdGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xyXG5cclxuICAgIHRoaXMuZm9nID0gc291cmNlLmZvZztcclxuXHJcbiAgICB0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XHJcbiAgICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XHJcbiAgICB0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBzb3VyY2Uud2lyZWZyYW1lTGluZWNhcDtcclxuICAgIHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XHJcblxyXG4gICAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xyXG5cclxuICAgIHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XHJcbiAgICB0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XHJcbiAgICB0aGlzLm1vcnBoTm9ybWFscyA9IHNvdXJjZS5tb3JwaE5vcm1hbHM7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL01lc2hQaG9uZ01hdGVyaWFsLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICogIGNvbG9yOiA8aGV4PixcclxuICogIGVtaXNzaXZlOiA8aGV4PixcclxuICogIHNwZWN1bGFyOiA8aGV4PixcclxuICogIHNoaW5pbmVzczogPGZsb2F0PixcclxuICogIG9wYWNpdHk6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBsaWdodE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICogIGxpZ2h0TWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XHJcbiAqXHJcbiAqICBhb01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICogIGFvTWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XHJcbiAqXHJcbiAqICBlbWlzc2l2ZU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIGJ1bXBNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqICBidW1wU2NhbGU6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBub3JtYWxNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqICBub3JtYWxTY2FsZTogPFZlY3RvcjI+LFxyXG4gKlxyXG4gKiAgZGlzcGxhY2VtZW50TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKiAgZGlzcGxhY2VtZW50U2NhbGU6IDxmbG9hdD4sXHJcbiAqICBkaXNwbGFjZW1lbnRCaWFzOiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgc3BlY3VsYXJNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIGVudk1hcDogbmV3IFRIUkVFLlRleHR1cmVDdWJlKCBbcG9zeCwgbmVneCwgcG9zeSwgbmVneSwgcG9zeiwgbmVnel0gKSxcclxuICogIGNvbWJpbmU6IFRIUkVFLk11bHRpcGx5LFxyXG4gKiAgcmVmbGVjdGl2aXR5OiA8ZmxvYXQ+LFxyXG4gKiAgcmVmcmFjdGlvblJhdGlvOiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgc2hhZGluZzogVEhSRUUuU21vb3RoU2hhZGluZyxcclxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcclxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxyXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxyXG4gKlxyXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXHJcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLk5vQ29sb3JzIC8gVEhSRUUuVmVydGV4Q29sb3JzIC8gVEhSRUUuRmFjZUNvbG9ycyxcclxuICpcclxuICogIHNraW5uaW5nOiA8Ym9vbD4sXHJcbiAqICBtb3JwaFRhcmdldHM6IDxib29sPixcclxuICogIG1vcnBoTm9ybWFsczogPGJvb2w+LFxyXG4gKlxyXG4gKlx0Zm9nOiA8Ym9vbD5cclxuICogfVxyXG4gKi9cclxuXHJcblRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuICAgIFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnTWVzaFBob25nTWF0ZXJpYWwnO1xyXG5cclxuICAgIHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGRpZmZ1c2VcclxuICAgIHRoaXMuZW1pc3NpdmUgPSBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICk7XHJcbiAgICB0aGlzLnNwZWN1bGFyID0gbmV3IFRIUkVFLkNvbG9yKCAweDExMTExMSApO1xyXG4gICAgdGhpcy5zaGluaW5lc3MgPSAzMDtcclxuXHJcbiAgICB0aGlzLm1ldGFsID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5tYXAgPSBudWxsO1xyXG5cclxuICAgIHRoaXMubGlnaHRNYXAgPSBudWxsO1xyXG4gICAgdGhpcy5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcclxuXHJcbiAgICB0aGlzLmFvTWFwID0gbnVsbDtcclxuICAgIHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XHJcblxyXG4gICAgdGhpcy5lbWlzc2l2ZU1hcCA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5idW1wTWFwID0gbnVsbDtcclxuICAgIHRoaXMuYnVtcFNjYWxlID0gMTtcclxuXHJcbiAgICB0aGlzLm5vcm1hbE1hcCA9IG51bGw7XHJcbiAgICB0aGlzLm5vcm1hbFNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKTtcclxuXHJcbiAgICB0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XHJcbiAgICB0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcclxuICAgIHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XHJcblxyXG4gICAgdGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5hbHBoYU1hcCA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5lbnZNYXAgPSBudWxsO1xyXG4gICAgdGhpcy5jb21iaW5lID0gVEhSRUUuTXVsdGlwbHlPcGVyYXRpb247XHJcbiAgICB0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XHJcbiAgICB0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XHJcblxyXG4gICAgdGhpcy5mb2cgPSB0cnVlO1xyXG5cclxuICAgIHRoaXMuc2hhZGluZyA9IFRIUkVFLlNtb290aFNoYWRpbmc7XHJcblxyXG4gICAgdGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcclxuICAgIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcclxuICAgIHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XHJcbiAgICB0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcclxuXHJcbiAgICB0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xyXG5cclxuICAgIHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcclxuICAgIHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XHJcbiAgICB0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsO1xyXG5cclxuVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcbiAgICBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcbiAgICB0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xyXG4gICAgdGhpcy5lbWlzc2l2ZS5jb3B5KCBzb3VyY2UuZW1pc3NpdmUgKTtcclxuICAgIHRoaXMuc3BlY3VsYXIuY29weSggc291cmNlLnNwZWN1bGFyICk7XHJcbiAgICB0aGlzLnNoaW5pbmVzcyA9IHNvdXJjZS5zaGluaW5lc3M7XHJcblxyXG4gICAgdGhpcy5tZXRhbCA9IHNvdXJjZS5tZXRhbDtcclxuXHJcbiAgICB0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XHJcblxyXG4gICAgdGhpcy5saWdodE1hcCA9IHNvdXJjZS5saWdodE1hcDtcclxuICAgIHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSBzb3VyY2UubGlnaHRNYXBJbnRlbnNpdHk7XHJcblxyXG4gICAgdGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcclxuICAgIHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBzb3VyY2UuYW9NYXBJbnRlbnNpdHk7XHJcblxyXG4gICAgdGhpcy5lbWlzc2l2ZU1hcCA9IHNvdXJjZS5lbWlzc2l2ZU1hcDtcclxuXHJcbiAgICB0aGlzLmJ1bXBNYXAgPSBzb3VyY2UuYnVtcE1hcDtcclxuICAgIHRoaXMuYnVtcFNjYWxlID0gc291cmNlLmJ1bXBTY2FsZTtcclxuXHJcbiAgICB0aGlzLm5vcm1hbE1hcCA9IHNvdXJjZS5ub3JtYWxNYXA7XHJcbiAgICB0aGlzLm5vcm1hbFNjYWxlLmNvcHkoIHNvdXJjZS5ub3JtYWxTY2FsZSApO1xyXG5cclxuICAgIHRoaXMuZGlzcGxhY2VtZW50TWFwID0gc291cmNlLmRpc3BsYWNlbWVudE1hcDtcclxuICAgIHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBzb3VyY2UuZGlzcGxhY2VtZW50U2NhbGU7XHJcbiAgICB0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50QmlhcztcclxuXHJcbiAgICB0aGlzLnNwZWN1bGFyTWFwID0gc291cmNlLnNwZWN1bGFyTWFwO1xyXG5cclxuICAgIHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XHJcblxyXG4gICAgdGhpcy5lbnZNYXAgPSBzb3VyY2UuZW52TWFwO1xyXG4gICAgdGhpcy5jb21iaW5lID0gc291cmNlLmNvbWJpbmU7XHJcbiAgICB0aGlzLnJlZmxlY3Rpdml0eSA9IHNvdXJjZS5yZWZsZWN0aXZpdHk7XHJcbiAgICB0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IHNvdXJjZS5yZWZyYWN0aW9uUmF0aW87XHJcblxyXG4gICAgdGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xyXG5cclxuICAgIHRoaXMuc2hhZGluZyA9IHNvdXJjZS5zaGFkaW5nO1xyXG5cclxuICAgIHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcclxuICAgIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcclxuICAgIHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xyXG4gICAgdGhpcy53aXJlZnJhbWVMaW5lam9pbiA9IHNvdXJjZS53aXJlZnJhbWVMaW5lam9pbjtcclxuXHJcbiAgICB0aGlzLnZlcnRleENvbG9ycyA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnM7XHJcblxyXG4gICAgdGhpcy5za2lubmluZyA9IHNvdXJjZS5za2lubmluZztcclxuICAgIHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcclxuICAgIHRoaXMubW9ycGhOb3JtYWxzID0gc291cmNlLm1vcnBoTm9ybWFscztcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTWVzaERlcHRoTWF0ZXJpYWwuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcclxuICpcclxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcclxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxyXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxyXG4gKlxyXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXHJcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD5cclxuICogfVxyXG4gKi9cclxuXHJcblRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuICAgIFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnTWVzaERlcHRoTWF0ZXJpYWwnO1xyXG5cclxuICAgIHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XHJcbiAgICB0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xyXG4gICAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xyXG5cclxuICAgIHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsO1xyXG5cclxuVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcbiAgICBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcbiAgICB0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XHJcbiAgICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL01lc2hOb3JtYWxNYXRlcmlhbC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgc2hhZGluZzogVEhSRUUuRmxhdFNoYWRpbmcsXHJcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXHJcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcclxuICogIGRlcHRoV3JpdGU6IDxib29sPixcclxuICpcclxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxyXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+XHJcbiAqIH1cclxuICovXHJcblxyXG5USFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG4gICAgVEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcywgcGFyYW1ldGVycyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdNZXNoTm9ybWFsTWF0ZXJpYWwnO1xyXG5cclxuICAgIHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XHJcbiAgICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XHJcblxyXG4gICAgdGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbDtcclxuXHJcblRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuICAgIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuICAgIHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcclxuICAgIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTXVsdGlNYXRlcmlhbC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTXVsdGlNYXRlcmlhbCA9IGZ1bmN0aW9uICggbWF0ZXJpYWxzICkge1xyXG5cclxuICAgIHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ011bHRpTWF0ZXJpYWwnO1xyXG5cclxuICAgIHRoaXMubWF0ZXJpYWxzID0gbWF0ZXJpYWxzIGluc3RhbmNlb2YgQXJyYXkgPyBtYXRlcmlhbHMgOiBbXTtcclxuXHJcbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk11bHRpTWF0ZXJpYWwucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5NdWx0aU1hdGVyaWFsLFxyXG5cclxuICAgIHRvSlNPTjogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgb3V0cHV0ID0ge1xyXG4gICAgICAgICAgICBtZXRhZGF0YToge1xyXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogNC4yLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogJ21hdGVyaWFsJyxcclxuICAgICAgICAgICAgICAgIGdlbmVyYXRvcjogJ01hdGVyaWFsRXhwb3J0ZXInXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHV1aWQ6IHRoaXMudXVpZCxcclxuICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxyXG4gICAgICAgICAgICBtYXRlcmlhbHM6IFtdXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5tYXRlcmlhbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIG91dHB1dC5tYXRlcmlhbHMucHVzaCggdGhpcy5tYXRlcmlhbHNbIGkgXS50b0pTT04oKSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG91dHB1dC52aXNpYmxlID0gdGhpcy52aXNpYmxlO1xyXG5cclxuICAgICAgICByZXR1cm4gb3V0cHV0O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIG1hdGVyaWFsID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKTtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5tYXRlcmlhbHMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgbWF0ZXJpYWwubWF0ZXJpYWxzLnB1c2goIHRoaXMubWF0ZXJpYWxzWyBpIF0uY2xvbmUoKSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG1hdGVyaWFsLnZpc2libGUgPSB0aGlzLnZpc2libGU7XHJcblxyXG4gICAgICAgIHJldHVybiBtYXRlcmlhbDtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcclxuXHJcblRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwgPSBUSFJFRS5NdWx0aU1hdGVyaWFsO1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL1BvaW50c01hdGVyaWFsLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICogIGNvbG9yOiA8aGV4PixcclxuICogIG9wYWNpdHk6IDxmbG9hdD4sXHJcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBzaXplOiA8ZmxvYXQ+LFxyXG4gKiAgc2l6ZUF0dGVudWF0aW9uOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXHJcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcclxuICogIGRlcHRoV3JpdGU6IDxib29sPixcclxuICpcclxuICogIHZlcnRleENvbG9yczogPGJvb2w+LFxyXG4gKlxyXG4gKiAgZm9nOiA8Ym9vbD5cclxuICogfVxyXG4gKi9cclxuXHJcblRIUkVFLlBvaW50c01hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuICAgIFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnUG9pbnRzTWF0ZXJpYWwnO1xyXG5cclxuICAgIHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XHJcblxyXG4gICAgdGhpcy5tYXAgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuc2l6ZSA9IDE7XHJcbiAgICB0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHRydWU7XHJcblxyXG4gICAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5Ob0NvbG9ycztcclxuXHJcbiAgICB0aGlzLmZvZyA9IHRydWU7XHJcblxyXG4gICAgdGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Qb2ludHNNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuVEhSRUUuUG9pbnRzTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUG9pbnRzTWF0ZXJpYWw7XHJcblxyXG5USFJFRS5Qb2ludHNNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuICAgIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuICAgIHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XHJcblxyXG4gICAgdGhpcy5tYXAgPSBzb3VyY2UubWFwO1xyXG5cclxuICAgIHRoaXMuc2l6ZSA9IHNvdXJjZS5zaXplO1xyXG4gICAgdGhpcy5zaXplQXR0ZW51YXRpb24gPSBzb3VyY2Uuc2l6ZUF0dGVudWF0aW9uO1xyXG5cclxuICAgIHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcclxuXHJcbiAgICB0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcclxuXHJcblRIUkVFLlBvaW50Q2xvdWRNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcclxuXHJcbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5Qb2ludENsb3VkTWF0ZXJpYWwgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHNNYXRlcmlhbC4nICk7XHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLlBvaW50c01hdGVyaWFsKCBwYXJhbWV0ZXJzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGFydGljbGVCYXNpY01hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlBhcnRpY2xlQmFzaWNNYXRlcmlhbCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50c01hdGVyaWFsLicgKTtcclxuICAgIHJldHVybiBuZXcgVEhSRUUuUG9pbnRzTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5QYXJ0aWNsZVN5c3RlbU1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlBhcnRpY2xlU3lzdGVtTWF0ZXJpYWwgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHNNYXRlcmlhbC4nICk7XHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLlBvaW50c01hdGVyaWFsKCBwYXJhbWV0ZXJzICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL1NoYWRlck1hdGVyaWFsLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICogIGRlZmluZXM6IHsgXCJsYWJlbFwiIDogXCJ2YWx1ZVwiIH0sXHJcbiAqICB1bmlmb3JtczogeyBcInBhcmFtZXRlcjFcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LCBcInBhcmFtZXRlcjJcIjogeyB0eXBlOiBcImlcIiB2YWx1ZTI6IDIgfSB9LFxyXG4gKlxyXG4gKiAgZnJhZ21lbnRTaGFkZXI6IDxzdHJpbmc+LFxyXG4gKiAgdmVydGV4U2hhZGVyOiA8c3RyaW5nPixcclxuICpcclxuICogIHNoYWRpbmc6IFRIUkVFLlNtb290aFNoYWRpbmcsXHJcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXHJcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcclxuICogIGRlcHRoV3JpdGU6IDxib29sPixcclxuICpcclxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxyXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgbGlnaHRzOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLk5vQ29sb3JzIC8gVEhSRUUuVmVydGV4Q29sb3JzIC8gVEhSRUUuRmFjZUNvbG9ycyxcclxuICpcclxuICogIHNraW5uaW5nOiA8Ym9vbD4sXHJcbiAqICBtb3JwaFRhcmdldHM6IDxib29sPixcclxuICogIG1vcnBoTm9ybWFsczogPGJvb2w+LFxyXG4gKlxyXG4gKlx0Zm9nOiA8Ym9vbD5cclxuICogfVxyXG4gKi9cclxuXHJcblRIUkVFLlNoYWRlck1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuICAgIFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnU2hhZGVyTWF0ZXJpYWwnO1xyXG5cclxuICAgIHRoaXMuZGVmaW5lcyA9IHt9O1xyXG4gICAgdGhpcy51bmlmb3JtcyA9IHt9O1xyXG5cclxuICAgIHRoaXMudmVydGV4U2hhZGVyID0gJ3ZvaWQgbWFpbigpIHtcXG5cXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxufSc7XHJcbiAgICB0aGlzLmZyYWdtZW50U2hhZGVyID0gJ3ZvaWQgbWFpbigpIHtcXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCAxLjAsIDAuMCwgMC4wLCAxLjAgKTtcXG59JztcclxuXHJcbiAgICB0aGlzLnNoYWRpbmcgPSBUSFJFRS5TbW9vdGhTaGFkaW5nO1xyXG5cclxuICAgIHRoaXMubGluZXdpZHRoID0gMTtcclxuXHJcbiAgICB0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xyXG4gICAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xyXG5cclxuICAgIHRoaXMuZm9nID0gZmFsc2U7IC8vIHNldCB0byB1c2Ugc2NlbmUgZm9nXHJcblxyXG4gICAgdGhpcy5saWdodHMgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBzY2VuZSBsaWdodHNcclxuXHJcbiAgICB0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzOyAvLyBzZXQgdG8gdXNlIFwiY29sb3JcIiBhdHRyaWJ1dGUgc3RyZWFtXHJcblxyXG4gICAgdGhpcy5za2lubmluZyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHNraW5uaW5nIGF0dHJpYnV0ZSBzdHJlYW1zXHJcblxyXG4gICAgdGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBtb3JwaCB0YXJnZXRzXHJcbiAgICB0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIG1vcnBoIG5vcm1hbHNcclxuXHJcbiAgICB0aGlzLmRlcml2YXRpdmVzID0gZmFsc2U7IC8vIHNldCB0byB1c2UgZGVyaXZhdGl2ZXNcclxuXHJcbiAgICAvLyBXaGVuIHJlbmRlcmVkIGdlb21ldHJ5IGRvZXNuJ3QgaW5jbHVkZSB0aGVzZSBhdHRyaWJ1dGVzIGJ1dCB0aGUgbWF0ZXJpYWwgZG9lcyxcclxuICAgIC8vIHVzZSB0aGVzZSBkZWZhdWx0IHZhbHVlcyBpbiBXZWJHTC4gVGhpcyBhdm9pZHMgZXJyb3JzIHdoZW4gYnVmZmVyIGRhdGEgaXMgbWlzc2luZy5cclxuICAgIHRoaXMuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyA9IHtcclxuICAgICAgICAnY29sb3InOiBbIDEsIDEsIDEgXSxcclxuICAgICAgICAndXYnOiBbIDAsIDAgXSxcclxuICAgICAgICAndXYyJzogWyAwLCAwIF1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5pbmRleDBBdHRyaWJ1dGVOYW1lID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIGlmICggcGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICBpZiAoIHBhcmFtZXRlcnMuYXR0cmlidXRlcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLlNoYWRlck1hdGVyaWFsOiBhdHRyaWJ1dGVzIHNob3VsZCBub3cgYmUgZGVmaW5lZCBpbiBUSFJFRS5CdWZmZXJHZW9tZXRyeSBpbnN0ZWFkLicgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuVEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU2hhZGVyTWF0ZXJpYWw7XHJcblxyXG5USFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuICAgIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuICAgIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBzb3VyY2UuZnJhZ21lbnRTaGFkZXI7XHJcbiAgICB0aGlzLnZlcnRleFNoYWRlciA9IHNvdXJjZS52ZXJ0ZXhTaGFkZXI7XHJcblxyXG4gICAgdGhpcy51bmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIHNvdXJjZS51bmlmb3JtcyApO1xyXG5cclxuICAgIHRoaXMuYXR0cmlidXRlcyA9IHNvdXJjZS5hdHRyaWJ1dGVzO1xyXG4gICAgdGhpcy5kZWZpbmVzID0gc291cmNlLmRlZmluZXM7XHJcblxyXG4gICAgdGhpcy5zaGFkaW5nID0gc291cmNlLnNoYWRpbmc7XHJcblxyXG4gICAgdGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xyXG4gICAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xyXG5cclxuICAgIHRoaXMuZm9nID0gc291cmNlLmZvZztcclxuXHJcbiAgICB0aGlzLmxpZ2h0cyA9IHNvdXJjZS5saWdodHM7XHJcblxyXG4gICAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xyXG5cclxuICAgIHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XHJcblxyXG4gICAgdGhpcy5tb3JwaFRhcmdldHMgPSBzb3VyY2UubW9ycGhUYXJnZXRzO1xyXG4gICAgdGhpcy5tb3JwaE5vcm1hbHMgPSBzb3VyY2UubW9ycGhOb3JtYWxzO1xyXG5cclxuICAgIHRoaXMuZGVyaXZhdGl2ZXMgPSBzb3VyY2UuZGVyaXZhdGl2ZXM7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcclxuXHJcbiAgICB2YXIgZGF0YSA9IFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xyXG5cclxuICAgIGRhdGEudW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zO1xyXG4gICAgZGF0YS5hdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xyXG4gICAgZGF0YS52ZXJ0ZXhTaGFkZXIgPSB0aGlzLnZlcnRleFNoYWRlcjtcclxuICAgIGRhdGEuZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmZyYWdtZW50U2hhZGVyO1xyXG5cclxuICAgIHJldHVybiBkYXRhO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGVyaWFscy9SYXdTaGFkZXJNYXRlcmlhbC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuUmF3U2hhZGVyTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG4gICAgVEhSRUUuU2hhZGVyTWF0ZXJpYWwuY2FsbCggdGhpcywgcGFyYW1ldGVycyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdSYXdTaGFkZXJNYXRlcmlhbCc7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUmF3U2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblRIUkVFLlJhd1NoYWRlck1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlJhd1NoYWRlck1hdGVyaWFsO1xyXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvU3ByaXRlTWF0ZXJpYWwuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKiAgY29sb3I6IDxoZXg+LFxyXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcclxuICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcclxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxyXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxyXG4gKlxyXG4gKlx0dXZPZmZzZXQ6IG5ldyBUSFJFRS5WZWN0b3IyKCksXHJcbiAqXHR1dlNjYWxlOiBuZXcgVEhSRUUuVmVjdG9yMigpLFxyXG4gKlxyXG4gKiAgZm9nOiA8Ym9vbD5cclxuICogfVxyXG4gKi9cclxuXHJcblRIUkVFLlNwcml0ZU1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuICAgIFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnU3ByaXRlTWF0ZXJpYWwnO1xyXG5cclxuICAgIHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XHJcbiAgICB0aGlzLm1hcCA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5yb3RhdGlvbiA9IDA7XHJcblxyXG4gICAgdGhpcy5mb2cgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBzZXQgcGFyYW1ldGVyc1xyXG5cclxuICAgIHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU3ByaXRlTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblRIUkVFLlNwcml0ZU1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwcml0ZU1hdGVyaWFsO1xyXG5cclxuVEhSRUUuU3ByaXRlTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcbiAgICBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcbiAgICB0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xyXG4gICAgdGhpcy5tYXAgPSBzb3VyY2UubWFwO1xyXG5cclxuICAgIHRoaXMucm90YXRpb24gPSBzb3VyY2Uucm90YXRpb247XHJcblxyXG4gICAgdGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3RleHR1cmVzL1RleHR1cmUuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIHN6aW1layAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zemltZWsvXHJcbiAqL1xyXG5cclxuVEhSRUUuVGV4dHVyZSA9IGZ1bmN0aW9uICggaW1hZ2UsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApIHtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IFRIUkVFLlRleHR1cmVJZENvdW50ICsrIH0gKTtcclxuXHJcbiAgICB0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xyXG5cclxuICAgIHRoaXMubmFtZSA9ICcnO1xyXG4gICAgdGhpcy5zb3VyY2VGaWxlID0gJyc7XHJcblxyXG4gICAgdGhpcy5pbWFnZSA9IGltYWdlICE9PSB1bmRlZmluZWQgPyBpbWFnZSA6IFRIUkVFLlRleHR1cmUuREVGQVVMVF9JTUFHRTtcclxuICAgIHRoaXMubWlwbWFwcyA9IFtdO1xyXG5cclxuICAgIHRoaXMubWFwcGluZyA9IG1hcHBpbmcgIT09IHVuZGVmaW5lZCA/IG1hcHBpbmcgOiBUSFJFRS5UZXh0dXJlLkRFRkFVTFRfTUFQUElORztcclxuXHJcbiAgICB0aGlzLndyYXBTID0gd3JhcFMgIT09IHVuZGVmaW5lZCA/IHdyYXBTIDogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcclxuICAgIHRoaXMud3JhcFQgPSB3cmFwVCAhPT0gdW5kZWZpbmVkID8gd3JhcFQgOiBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nO1xyXG5cclxuICAgIHRoaXMubWFnRmlsdGVyID0gbWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtYWdGaWx0ZXIgOiBUSFJFRS5MaW5lYXJGaWx0ZXI7XHJcbiAgICB0aGlzLm1pbkZpbHRlciA9IG1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWluRmlsdGVyIDogVEhSRUUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyO1xyXG5cclxuICAgIHRoaXMuYW5pc290cm9weSA9IGFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCA/IGFuaXNvdHJvcHkgOiAxO1xyXG5cclxuICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0ICE9PSB1bmRlZmluZWQgPyBmb3JtYXQgOiBUSFJFRS5SR0JBRm9ybWF0O1xyXG4gICAgdGhpcy50eXBlID0gdHlwZSAhPT0gdW5kZWZpbmVkID8gdHlwZSA6IFRIUkVFLlVuc2lnbmVkQnl0ZVR5cGU7XHJcblxyXG4gICAgdGhpcy5vZmZzZXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggMCwgMCApO1xyXG4gICAgdGhpcy5yZXBlYXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApO1xyXG5cclxuICAgIHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gdHJ1ZTtcclxuICAgIHRoaXMucHJlbXVsdGlwbHlBbHBoYSA9IGZhbHNlO1xyXG4gICAgdGhpcy5mbGlwWSA9IHRydWU7XHJcbiAgICB0aGlzLnVucGFja0FsaWdubWVudCA9IDQ7IC8vIHZhbGlkIHZhbHVlczogMSwgMiwgNCwgOCAoc2VlIGh0dHA6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsZXMvc2RrL2RvY3MvbWFuL3hodG1sL2dsUGl4ZWxTdG9yZWkueG1sKVxyXG5cclxuICAgIHRoaXMudmVyc2lvbiA9IDA7XHJcbiAgICB0aGlzLm9uVXBkYXRlID0gbnVsbDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5UZXh0dXJlLkRFRkFVTFRfSU1BR0UgPSB1bmRlZmluZWQ7XHJcblRIUkVFLlRleHR1cmUuREVGQVVMVF9NQVBQSU5HID0gVEhSRUUuVVZNYXBwaW5nO1xyXG5cclxuVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLlRleHR1cmUsXHJcblxyXG4gICAgc2V0IG5lZWRzVXBkYXRlICggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnZlcnNpb24gKys7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5pbWFnZSA9IHNvdXJjZS5pbWFnZTtcclxuICAgICAgICB0aGlzLm1pcG1hcHMgPSBzb3VyY2UubWlwbWFwcy5zbGljZSggMCApO1xyXG5cclxuICAgICAgICB0aGlzLm1hcHBpbmcgPSBzb3VyY2UubWFwcGluZztcclxuXHJcbiAgICAgICAgdGhpcy53cmFwUyA9IHNvdXJjZS53cmFwUztcclxuICAgICAgICB0aGlzLndyYXBUID0gc291cmNlLndyYXBUO1xyXG5cclxuICAgICAgICB0aGlzLm1hZ0ZpbHRlciA9IHNvdXJjZS5tYWdGaWx0ZXI7XHJcbiAgICAgICAgdGhpcy5taW5GaWx0ZXIgPSBzb3VyY2UubWluRmlsdGVyO1xyXG5cclxuICAgICAgICB0aGlzLmFuaXNvdHJvcHkgPSBzb3VyY2UuYW5pc290cm9weTtcclxuXHJcbiAgICAgICAgdGhpcy5mb3JtYXQgPSBzb3VyY2UuZm9ybWF0O1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHNvdXJjZS50eXBlO1xyXG5cclxuICAgICAgICB0aGlzLm9mZnNldC5jb3B5KCBzb3VyY2Uub2Zmc2V0ICk7XHJcbiAgICAgICAgdGhpcy5yZXBlYXQuY29weSggc291cmNlLnJlcGVhdCApO1xyXG5cclxuICAgICAgICB0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IHNvdXJjZS5nZW5lcmF0ZU1pcG1hcHM7XHJcbiAgICAgICAgdGhpcy5wcmVtdWx0aXBseUFscGhhID0gc291cmNlLnByZW11bHRpcGx5QWxwaGE7XHJcbiAgICAgICAgdGhpcy5mbGlwWSA9IHNvdXJjZS5mbGlwWTtcclxuICAgICAgICB0aGlzLnVucGFja0FsaWdubWVudCA9IHNvdXJjZS51bnBhY2tBbGlnbm1lbnQ7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XHJcblxyXG4gICAgICAgIGlmICggbWV0YS50ZXh0dXJlc1sgdGhpcy51dWlkIF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBtZXRhLnRleHR1cmVzWyB0aGlzLnV1aWQgXTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBnZXREYXRhVVJMKCBpbWFnZSApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBjYW52YXM7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGltYWdlLnRvRGF0YVVSTCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNhbnZhcyA9IGltYWdlO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xyXG4gICAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0gaW1hZ2Uud2lkdGg7XHJcbiAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICkuZHJhd0ltYWdlKCBpbWFnZSwgMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBjYW52YXMud2lkdGggPiAyMDQ4IHx8IGNhbnZhcy5oZWlnaHQgPiAyMDQ4ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKCAnaW1hZ2UvanBlZycsIDAuNiApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTCggJ2ltYWdlL3BuZycgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgb3V0cHV0ID0ge1xyXG4gICAgICAgICAgICBtZXRhZGF0YToge1xyXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogNC40LFxyXG4gICAgICAgICAgICAgICAgdHlwZTogJ1RleHR1cmUnLFxyXG4gICAgICAgICAgICAgICAgZ2VuZXJhdG9yOiAnVGV4dHVyZS50b0pTT04nXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICB1dWlkOiB0aGlzLnV1aWQsXHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuXHJcbiAgICAgICAgICAgIG1hcHBpbmc6IHRoaXMubWFwcGluZyxcclxuXHJcbiAgICAgICAgICAgIHJlcGVhdDogWyB0aGlzLnJlcGVhdC54LCB0aGlzLnJlcGVhdC55IF0sXHJcbiAgICAgICAgICAgIG9mZnNldDogWyB0aGlzLm9mZnNldC54LCB0aGlzLm9mZnNldC55IF0sXHJcbiAgICAgICAgICAgIHdyYXA6IFsgdGhpcy53cmFwUywgdGhpcy53cmFwVCBdLFxyXG5cclxuICAgICAgICAgICAgbWluRmlsdGVyOiB0aGlzLm1pbkZpbHRlcixcclxuICAgICAgICAgICAgbWFnRmlsdGVyOiB0aGlzLm1hZ0ZpbHRlcixcclxuICAgICAgICAgICAgYW5pc290cm9weTogdGhpcy5hbmlzb3Ryb3B5XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLmltYWdlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBUT0RPOiBNb3ZlIHRvIFRIUkVFLkltYWdlXHJcblxyXG4gICAgICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLmltYWdlO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBpbWFnZS51dWlkID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaW1hZ2UudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7IC8vIFVHSFxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBtZXRhLmltYWdlc1sgaW1hZ2UudXVpZCBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgbWV0YS5pbWFnZXNbIGltYWdlLnV1aWQgXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICB1dWlkOiBpbWFnZS51dWlkLFxyXG4gICAgICAgICAgICAgICAgICAgIHVybDogZ2V0RGF0YVVSTCggaW1hZ2UgKVxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG91dHB1dC5pbWFnZSA9IGltYWdlLnV1aWQ7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbWV0YS50ZXh0dXJlc1sgdGhpcy51dWlkIF0gPSBvdXRwdXQ7XHJcblxyXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdHJhbnNmb3JtVXY6IGZ1bmN0aW9uICggdXYgKSB7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5tYXBwaW5nICE9PSBUSFJFRS5VVk1hcHBpbmcgKSAgcmV0dXJuO1xyXG5cclxuICAgICAgICB1di5tdWx0aXBseSggdGhpcy5yZXBlYXQgKTtcclxuICAgICAgICB1di5hZGQoIHRoaXMub2Zmc2V0ICk7XHJcblxyXG4gICAgICAgIGlmICggdXYueCA8IDAgfHwgdXYueCA+IDEgKSB7XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKCB0aGlzLndyYXBTICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuUmVwZWF0V3JhcHBpbmc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHV2LnggPSB1di54IC0gTWF0aC5mbG9vciggdXYueCApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdXYueCA9IHV2LnggPCAwID8gMCA6IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIE1hdGguYWJzKCBNYXRoLmZsb29yKCB1di54ICkgJSAyICkgPT09IDEgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1di54ID0gTWF0aC5jZWlsKCB1di54ICkgLSB1di54O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdXYueCA9IHV2LnggLSBNYXRoLmZsb29yKCB1di54ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIHV2LnkgPCAwIHx8IHV2LnkgPiAxICkge1xyXG5cclxuICAgICAgICAgICAgc3dpdGNoICggdGhpcy53cmFwVCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLlJlcGVhdFdyYXBwaW5nOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICB1di55ID0gdXYueSAtIE1hdGguZmxvb3IoIHV2LnkgKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHV2LnkgPSB1di55IDwgMCA/IDAgOiAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBNYXRoLmFicyggTWF0aC5mbG9vciggdXYueSApICUgMiApID09PSAxICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdXYueSA9IE1hdGguY2VpbCggdXYueSApIC0gdXYueTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHV2LnkgPSB1di55IC0gTWF0aC5mbG9vciggdXYueSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLmZsaXBZICkge1xyXG5cclxuICAgICAgICAgICAgdXYueSA9IDEgLSB1di55O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLlRleHR1cmUucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5UZXh0dXJlSWRDb3VudCA9IDA7XHJcblxyXG4vLyBGaWxlOnNyYy90ZXh0dXJlcy9DYW52YXNUZXh0dXJlLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5DYW52YXNUZXh0dXJlID0gZnVuY3Rpb24gKCBjYW52YXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApIHtcclxuXHJcbiAgICBUSFJFRS5UZXh0dXJlLmNhbGwoIHRoaXMsIGNhbnZhcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XHJcblxyXG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ2FudmFzVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xyXG5USFJFRS5DYW52YXNUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkNhbnZhc1RleHR1cmU7XHJcblxyXG4vLyBGaWxlOnNyYy90ZXh0dXJlcy9DdWJlVGV4dHVyZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQ3ViZVRleHR1cmUgPSBmdW5jdGlvbiAoIGltYWdlcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICkge1xyXG5cclxuICAgIG1hcHBpbmcgPSBtYXBwaW5nICE9PSB1bmRlZmluZWQgPyBtYXBwaW5nIDogVEhSRUUuQ3ViZVJlZmxlY3Rpb25NYXBwaW5nO1xyXG5cclxuICAgIFRIUkVFLlRleHR1cmUuY2FsbCggdGhpcywgaW1hZ2VzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcclxuXHJcbiAgICB0aGlzLmltYWdlcyA9IGltYWdlcztcclxuICAgIHRoaXMuZmxpcFkgPSBmYWxzZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DdWJlVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xyXG5USFJFRS5DdWJlVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DdWJlVGV4dHVyZTtcclxuXHJcblRIUkVFLkN1YmVUZXh0dXJlLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG4gICAgVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcbiAgICB0aGlzLmltYWdlcyA9IHNvdXJjZS5pbWFnZXM7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG4vLyBGaWxlOnNyYy90ZXh0dXJlcy9Db21wcmVzc2VkVGV4dHVyZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUgPSBmdW5jdGlvbiAoIG1pcG1hcHMsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgYW5pc290cm9weSApIHtcclxuXHJcbiAgICBUSFJFRS5UZXh0dXJlLmNhbGwoIHRoaXMsIG51bGwsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xyXG5cclxuICAgIHRoaXMuaW1hZ2UgPSB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcclxuICAgIHRoaXMubWlwbWFwcyA9IG1pcG1hcHM7XHJcblxyXG4gICAgLy8gbm8gZmxpcHBpbmcgZm9yIGN1YmUgdGV4dHVyZXNcclxuICAgIC8vIChhbHNvIGZsaXBwaW5nIGRvZXNuJ3Qgd29yayBmb3IgY29tcHJlc3NlZCB0ZXh0dXJlcyApXHJcblxyXG4gICAgdGhpcy5mbGlwWSA9IGZhbHNlO1xyXG5cclxuICAgIC8vIGNhbid0IGdlbmVyYXRlIG1pcG1hcHMgZm9yIGNvbXByZXNzZWQgdGV4dHVyZXNcclxuICAgIC8vIG1pcHMgbXVzdCBiZSBlbWJlZGRlZCBpbiBERFMgZmlsZXNcclxuXHJcbiAgICB0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkNvbXByZXNzZWRUZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlRleHR1cmUucHJvdG90eXBlICk7XHJcblRIUkVFLkNvbXByZXNzZWRUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkNvbXByZXNzZWRUZXh0dXJlO1xyXG5cclxuLy8gRmlsZTpzcmMvdGV4dHVyZXMvRGF0YVRleHR1cmUuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkRhdGFUZXh0dXJlID0gZnVuY3Rpb24gKCBkYXRhLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGFuaXNvdHJvcHkgKSB7XHJcblxyXG4gICAgVEhSRUUuVGV4dHVyZS5jYWxsKCB0aGlzLCBudWxsLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcclxuXHJcbiAgICB0aGlzLmltYWdlID0geyBkYXRhOiBkYXRhLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XHJcblxyXG4gICAgdGhpcy5tYWdGaWx0ZXIgPSBtYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1hZ0ZpbHRlciA6IFRIUkVFLk5lYXJlc3RGaWx0ZXI7XHJcbiAgICB0aGlzLm1pbkZpbHRlciA9IG1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWluRmlsdGVyIDogVEhSRUUuTmVhcmVzdEZpbHRlcjtcclxuXHJcbiAgICB0aGlzLmZsaXBZID0gZmFsc2U7XHJcbiAgICB0aGlzLmdlbmVyYXRlTWlwbWFwcyAgPSBmYWxzZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5EYXRhVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xyXG5USFJFRS5EYXRhVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5EYXRhVGV4dHVyZTtcclxuXHJcbi8vIEZpbGU6c3JjL3RleHR1cmVzL1ZpZGVvVGV4dHVyZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuVmlkZW9UZXh0dXJlID0gZnVuY3Rpb24gKCB2aWRlbywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICkge1xyXG5cclxuICAgIFRIUkVFLlRleHR1cmUuY2FsbCggdGhpcywgdmlkZW8sIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xyXG5cclxuICAgIHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XHJcblxyXG4gICAgdmFyIHNjb3BlID0gdGhpcztcclxuXHJcbiAgICBmdW5jdGlvbiB1cGRhdGUoKSB7XHJcblxyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSggdXBkYXRlICk7XHJcblxyXG4gICAgICAgIGlmICggdmlkZW8ucmVhZHlTdGF0ZSA9PT0gdmlkZW8uSEFWRV9FTk9VR0hfREFUQSApIHtcclxuXHJcbiAgICAgICAgICAgIHNjb3BlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5WaWRlb1RleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgKTtcclxuVEhSRUUuVmlkZW9UZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlZpZGVvVGV4dHVyZTtcclxuXHJcbi8vIEZpbGU6c3JjL29iamVjdHMvR3JvdXAuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkdyb3VwID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnR3JvdXAnO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkdyb3VwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5USFJFRS5Hcm91cC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Hcm91cDtcclxuLy8gRmlsZTpzcmMvb2JqZWN0cy9Qb2ludHMuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlBvaW50cyA9IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xyXG5cclxuICAgIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnUG9pbnRzJztcclxuXHJcbiAgICB0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCA/IGdlb21ldHJ5IDogbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcbiAgICB0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsIDogbmV3IFRIUkVFLlBvaW50c01hdGVyaWFsKCB7IGNvbG9yOiBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYgfSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBvaW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuUG9pbnRzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBvaW50cztcclxuXHJcblRIUkVFLlBvaW50cy5wcm90b3R5cGUucmF5Y2FzdCA9ICggZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBpbnZlcnNlTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuICAgIHZhciByYXkgPSBuZXcgVEhSRUUuUmF5KCk7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcclxuXHJcbiAgICAgICAgdmFyIG9iamVjdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xyXG4gICAgICAgIHZhciB0aHJlc2hvbGQgPSByYXljYXN0ZXIucGFyYW1zLlBvaW50cy50aHJlc2hvbGQ7XHJcblxyXG4gICAgICAgIGludmVyc2VNYXRyaXguZ2V0SW52ZXJzZSggdGhpcy5tYXRyaXhXb3JsZCApO1xyXG4gICAgICAgIHJheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBpbnZlcnNlTWF0cml4ICk7XHJcblxyXG4gICAgICAgIGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHJheS5pc0ludGVyc2VjdGlvbkJveCggZ2VvbWV0cnkuYm91bmRpbmdCb3ggKSA9PT0gZmFsc2UgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBsb2NhbFRocmVzaG9sZCA9IHRocmVzaG9sZCAvICggKCB0aGlzLnNjYWxlLnggKyB0aGlzLnNjYWxlLnkgKyB0aGlzLnNjYWxlLnogKSAvIDMgKTtcclxuICAgICAgICB2YXIgbG9jYWxUaHJlc2hvbGRTcSA9IGxvY2FsVGhyZXNob2xkICogbG9jYWxUaHJlc2hvbGQ7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdGVzdFBvaW50KCBwb2ludCwgaW5kZXggKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmF5UG9pbnREaXN0YW5jZVNxID0gcmF5LmRpc3RhbmNlU3FUb1BvaW50KCBwb2ludCApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCByYXlQb2ludERpc3RhbmNlU3EgPCBsb2NhbFRocmVzaG9sZFNxICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBpbnRlcnNlY3RQb2ludCA9IHJheS5jbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludCApO1xyXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0UG9pbnQuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlcnNlY3RQb2ludCApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0cy5wdXNoKCB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcclxuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZVRvUmF5OiBNYXRoLnNxcnQoIHJheVBvaW50RGlzdGFuY2VTcSApLFxyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50OiBpbnRlcnNlY3RQb2ludC5jbG9uZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcclxuICAgICAgICAgICAgICAgICAgICBmYWNlOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogb2JqZWN0XHJcblxyXG4gICAgICAgICAgICAgICAgfSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xyXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XHJcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xyXG5cclxuICAgICAgICAgICAgaWYgKCBpbmRleCAhPT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kaWNlcyA9IGluZGV4LmFycmF5O1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGluZGljZXNbIGkgXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24uZnJvbUFycmF5KCBwb3NpdGlvbnMsIGEgKiAzICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRlc3RQb2ludCggcG9zaXRpb24sIGEgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHBvc2l0aW9ucy5sZW5ndGggLyAzOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24uZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKiAzICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRlc3RQb2ludCggcG9zaXRpb24sIGkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGVzdFBvaW50KCB2ZXJ0aWNlc1sgaSBdLCBpICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxufSgpICk7XHJcblxyXG5USFJFRS5Qb2ludHMucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApLmNvcHkoIHRoaXMgKTtcclxuXHJcbn07XHJcblxyXG4vLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxyXG5cclxuVEhSRUUuUG9pbnRDbG91ZCA9IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xyXG5cclxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlBvaW50Q2xvdWQgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHMuJyApO1xyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5Qb2ludHMoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBhcnRpY2xlU3lzdGVtID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XHJcblxyXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuUGFydGljbGVTeXN0ZW0gaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHMuJyApO1xyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5Qb2ludHMoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL29iamVjdHMvTGluZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTGluZSA9IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFsLCBtb2RlICkge1xyXG5cclxuICAgIGlmICggbW9kZSA9PT0gMSApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuTGluZTogcGFyYW1ldGVyIFRIUkVFLkxpbmVQaWVjZXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gQ3JlYXRlZCBUSFJFRS5MaW5lU2VnbWVudHMgaW5zdGVhZC4nICk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5MaW5lU2VnbWVudHMoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ0xpbmUnO1xyXG5cclxuICAgIHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkID8gZ2VvbWV0cnkgOiBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuICAgIHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWwgOiBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZiB9ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGluZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuTGluZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MaW5lO1xyXG5cclxuVEhSRUUuTGluZS5wcm90b3R5cGUucmF5Y2FzdCA9ICggZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBpbnZlcnNlTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuICAgIHZhciByYXkgPSBuZXcgVEhSRUUuUmF5KCk7XHJcbiAgICB2YXIgc3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSgpO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiByYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XHJcblxyXG4gICAgICAgIHZhciBwcmVjaXNpb24gPSByYXljYXN0ZXIubGluZVByZWNpc2lvbjtcclxuICAgICAgICB2YXIgcHJlY2lzaW9uU3EgPSBwcmVjaXNpb24gKiBwcmVjaXNpb247XHJcblxyXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XHJcblxyXG4gICAgICAgIGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2tpbmcgYm91bmRpbmdTcGhlcmUgZGlzdGFuY2UgdG8gcmF5XHJcblxyXG4gICAgICAgIHNwaGVyZS5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApO1xyXG4gICAgICAgIHNwaGVyZS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHJcbiAgICAgICAgaWYgKCByYXljYXN0ZXIucmF5LmlzSW50ZXJzZWN0aW9uU3BoZXJlKCBzcGhlcmUgKSA9PT0gZmFsc2UgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW52ZXJzZU1hdHJpeC5nZXRJbnZlcnNlKCB0aGlzLm1hdHJpeFdvcmxkICk7XHJcbiAgICAgICAgcmF5LmNvcHkoIHJheWNhc3Rlci5yYXkgKS5hcHBseU1hdHJpeDQoIGludmVyc2VNYXRyaXggKTtcclxuXHJcbiAgICAgICAgdmFyIHZTdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgdmFyIHZFbmQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgIHZhciBpbnRlclNlZ21lbnQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgIHZhciBpbnRlclJheSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgdmFyIHN0ZXAgPSB0aGlzIGluc3RhbmNlb2YgVEhSRUUuTGluZVNlZ21lbnRzID8gMiA6IDE7XHJcblxyXG4gICAgICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xyXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBpbmRpY2VzID0gaW5kZXguYXJyYXk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbmRpY2VzLmxlbmd0aCAtIDE7IGkgPCBsOyBpICs9IHN0ZXAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gaW5kaWNlc1sgaSBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gaW5kaWNlc1sgaSArIDEgXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdlN0YXJ0LmZyb21BcnJheSggcG9zaXRpb25zLCBhICogMyApO1xyXG4gICAgICAgICAgICAgICAgICAgIHZFbmQuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGIgKiAzICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXN0U3EgPSByYXkuZGlzdGFuY2VTcVRvU2VnbWVudCggdlN0YXJ0LCB2RW5kLCBpbnRlclJheSwgaW50ZXJTZWdtZW50ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggZGlzdFNxID4gcHJlY2lzaW9uU3EgKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJSYXkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7IC8vTW92ZSBiYWNrIHRvIHdvcmxkIHNwYWNlIGZvciBkaXN0YW5jZSBjYWxjdWxhdGlvblxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlclJheSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdHMucHVzaCgge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGF0IGRvIHdlIHdhbnQ/IGludGVyc2VjdGlvbiBwb2ludCBvbiB0aGUgcmF5IG9yIG9uIHRoZSBzZWdtZW50Pz9cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnQ6IHJheWNhc3Rlci5yYXkuYXQoIGRpc3RhbmNlICksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBpbnRlclNlZ21lbnQuY2xvbmUoKS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2U6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2VJbmRleDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHBvc2l0aW9ucy5sZW5ndGggLyAzIC0gMTsgaSA8IGw7IGkgKz0gc3RlcCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdlN0YXJ0LmZyb21BcnJheSggcG9zaXRpb25zLCAzICogaSApO1xyXG4gICAgICAgICAgICAgICAgICAgIHZFbmQuZnJvbUFycmF5KCBwb3NpdGlvbnMsIDMgKiBpICsgMyApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdFNxID0gcmF5LmRpc3RhbmNlU3FUb1NlZ21lbnQoIHZTdGFydCwgdkVuZCwgaW50ZXJSYXksIGludGVyU2VnbWVudCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGRpc3RTcSA+IHByZWNpc2lvblNxICkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGludGVyUmF5LmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApOyAvL01vdmUgYmFjayB0byB3b3JsZCBzcGFjZSBmb3IgZGlzdGFuY2UgY2FsY3VsYXRpb25cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJSYXkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3RzLnB1c2goIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hhdCBkbyB3ZSB3YW50PyBpbnRlcnNlY3Rpb24gcG9pbnQgb24gdGhlIHJheSBvciBvbiB0aGUgc2VnbWVudD8/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBvaW50OiByYXljYXN0ZXIucmF5LmF0KCBkaXN0YW5jZSApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogaW50ZXJTZWdtZW50LmNsb25lKCkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlSW5kZXg6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogdGhpc1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XHJcbiAgICAgICAgICAgIHZhciBuYlZlcnRpY2VzID0gdmVydGljZXMubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbmJWZXJ0aWNlcyAtIDE7IGkgKz0gc3RlcCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZGlzdFNxID0gcmF5LmRpc3RhbmNlU3FUb1NlZ21lbnQoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzWyBpICsgMSBdLCBpbnRlclJheSwgaW50ZXJTZWdtZW50ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBkaXN0U3EgPiBwcmVjaXNpb25TcSApIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGludGVyUmF5LmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApOyAvL01vdmUgYmFjayB0byB3b3JsZCBzcGFjZSBmb3IgZGlzdGFuY2UgY2FsY3VsYXRpb25cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlclJheSApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RzLnB1c2goIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdoYXQgZG8gd2Ugd2FudD8gaW50ZXJzZWN0aW9uIHBvaW50IG9uIHRoZSByYXkgb3Igb24gdGhlIHNlZ21lbnQ/P1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHBvaW50OiByYXljYXN0ZXIucmF5LmF0KCBkaXN0YW5jZSApLFxyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50OiBpbnRlclNlZ21lbnQuY2xvbmUoKS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKSxcclxuICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcclxuICAgICAgICAgICAgICAgICAgICBmYWNlOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIGZhY2VJbmRleDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXNcclxuXHJcbiAgICAgICAgICAgICAgICB9ICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxufSgpICk7XHJcblxyXG5USFJFRS5MaW5lLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwgKS5jb3B5KCB0aGlzICk7XHJcblxyXG59O1xyXG5cclxuLy8gREVQUkVDQVRFRFxyXG5cclxuVEhSRUUuTGluZVN0cmlwID0gMDtcclxuVEhSRUUuTGluZVBpZWNlcyA9IDE7XHJcblxyXG4vLyBGaWxlOnNyYy9vYmplY3RzL0xpbmVTZWdtZW50cy5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTGluZVNlZ21lbnRzID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XHJcblxyXG4gICAgVEhSRUUuTGluZS5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnTGluZVNlZ21lbnRzJztcclxuXHJcbn07XHJcblxyXG5USFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZS5wcm90b3R5cGUgKTtcclxuVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxpbmVTZWdtZW50cztcclxuXHJcbi8vIEZpbGU6c3JjL29iamVjdHMvTWVzaC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3Igam9ub2JyMSAvIGh0dHA6Ly9qb25vYnIxLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5NZXNoID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XHJcblxyXG4gICAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdNZXNoJztcclxuXHJcbiAgICB0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCA/IGdlb21ldHJ5IDogbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcbiAgICB0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsIDogbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYgfSApO1xyXG5cclxuICAgIHRoaXMudXBkYXRlTW9ycGhUYXJnZXRzKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTWVzaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuTWVzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5NZXNoO1xyXG5cclxuVEhSRUUuTWVzaC5wcm90b3R5cGUudXBkYXRlTW9ycGhUYXJnZXRzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIGlmICggdGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHMgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGggPiAwICkge1xyXG5cclxuICAgICAgICB0aGlzLm1vcnBoVGFyZ2V0QmFzZSA9IC0gMTtcclxuICAgICAgICB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5ID0ge307XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBtID0gMCwgbWwgPSB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7IG0gPCBtbDsgbSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzLnB1c2goIDAgKTtcclxuICAgICAgICAgICAgdGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBtIF0ubmFtZSBdID0gbTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5NZXNoLnByb3RvdHlwZS5nZXRNb3JwaFRhcmdldEluZGV4QnlOYW1lID0gZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuICAgIGlmICggdGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIG5hbWUgXSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIG5hbWUgXTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuTWVzaC5nZXRNb3JwaFRhcmdldEluZGV4QnlOYW1lOiBtb3JwaCB0YXJnZXQgJyArIG5hbWUgKyAnIGRvZXMgbm90IGV4aXN0LiBSZXR1cm5pbmcgMC4nICk7XHJcblxyXG4gICAgcmV0dXJuIDA7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLk1lc2gucHJvdG90eXBlLnJheWNhc3QgPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgaW52ZXJzZU1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcbiAgICB2YXIgcmF5ID0gbmV3IFRIUkVFLlJheSgpO1xyXG4gICAgdmFyIHNwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcclxuXHJcbiAgICB2YXIgdkEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgdmFyIHZCID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgIHZhciB2QyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgdmFyIHRlbXBBID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgIHZhciB0ZW1wQiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICB2YXIgdGVtcEMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgIHZhciB1dkEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG4gICAgdmFyIHV2QiA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcbiAgICB2YXIgdXZDID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHJcbiAgICB2YXIgYmFyeWNvb3JkID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICB2YXIgaW50ZXJzZWN0aW9uUG9pbnQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgdmFyIGludGVyc2VjdGlvblBvaW50V29ybGQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgIGZ1bmN0aW9uIHV2SW50ZXJzZWN0aW9uKCBwb2ludCwgcDEsIHAyLCBwMywgdXYxLCB1djIsIHV2MyApIHtcclxuXHJcbiAgICAgICAgVEhSRUUuVHJpYW5nbGUuYmFyeWNvb3JkRnJvbVBvaW50KCBwb2ludCwgcDEsIHAyLCBwMywgYmFyeWNvb3JkICk7XHJcblxyXG4gICAgICAgIHV2MS5tdWx0aXBseVNjYWxhciggYmFyeWNvb3JkLnggKTtcclxuICAgICAgICB1djIubXVsdGlwbHlTY2FsYXIoIGJhcnljb29yZC55ICk7XHJcbiAgICAgICAgdXYzLm11bHRpcGx5U2NhbGFyKCBiYXJ5Y29vcmQueiApO1xyXG5cclxuICAgICAgICB1djEuYWRkKCB1djIgKS5hZGQoIHV2MyApO1xyXG5cclxuICAgICAgICByZXR1cm4gdXYxLmNsb25lKCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNoZWNrSW50ZXJzZWN0aW9uKCBvYmplY3QsIHJheWNhc3RlciwgcmF5LCBwQSwgcEIsIHBDLCBwb2ludCApe1xyXG5cclxuICAgICAgICB2YXIgaW50ZXJzZWN0O1xyXG4gICAgICAgIHZhciBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcclxuXHJcbiAgICAgICAgaWYgKCBtYXRlcmlhbC5zaWRlID09PSBUSFJFRS5CYWNrU2lkZSApIHtcclxuXHJcbiAgICAgICAgICAgIGludGVyc2VjdCA9IHJheS5pbnRlcnNlY3RUcmlhbmdsZSggcEMsIHBCLCBwQSwgdHJ1ZSwgcG9pbnQgKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIGludGVyc2VjdCA9IHJheS5pbnRlcnNlY3RUcmlhbmdsZSggcEEsIHBCLCBwQywgbWF0ZXJpYWwuc2lkZSAhPT0gVEhSRUUuRG91YmxlU2lkZSwgcG9pbnQgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIGludGVyc2VjdCA9PT0gbnVsbCApIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmNvcHkoIHBvaW50ICk7XHJcbiAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRXb3JsZC5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xyXG5cclxuICAgICAgICB2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkICk7XHJcblxyXG4gICAgICAgIGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlLFxyXG4gICAgICAgICAgICBwb2ludDogaW50ZXJzZWN0aW9uUG9pbnRXb3JsZC5jbG9uZSgpLFxyXG4gICAgICAgICAgICBvYmplY3Q6IG9iamVjdFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNoZWNrQnVmZmVyR2VvbWV0cnlJbnRlcnNlY3Rpb24oIG9iamVjdCwgcmF5Y2FzdGVyLCByYXksIHBvc2l0aW9ucywgdXZzLCBhLCBiLCBjICkge1xyXG5cclxuICAgICAgICB2QS5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYSAqIDMgKTtcclxuICAgICAgICB2Qi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYiAqIDMgKTtcclxuICAgICAgICB2Qy5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYyAqIDMgKTtcclxuXHJcbiAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IGNoZWNrSW50ZXJzZWN0aW9uKCBvYmplY3QsIHJheWNhc3RlciwgcmF5LCB2QSwgdkIsIHZDLCBpbnRlcnNlY3Rpb25Qb2ludCApO1xyXG5cclxuICAgICAgICBpZiAoIGludGVyc2VjdGlvbiApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggdXZzICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHV2QS5mcm9tQXJyYXkoIHV2cywgYSAqIDIgKTtcclxuICAgICAgICAgICAgICAgIHV2Qi5mcm9tQXJyYXkoIHV2cywgYiAqIDIgKTtcclxuICAgICAgICAgICAgICAgIHV2Qy5mcm9tQXJyYXkoIHV2cywgYyAqIDIgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb24udXYgPSB1dkludGVyc2VjdGlvbiggaW50ZXJzZWN0aW9uUG9pbnQsICB2QSwgdkIsIHZDLCAgdXZBLCB1dkIsIHV2QyApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaW50ZXJzZWN0aW9uLmZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMsIFRIUkVFLlRyaWFuZ2xlLm5vcm1hbCggdkEsIHZCLCB2QyApICk7XHJcbiAgICAgICAgICAgIGludGVyc2VjdGlvbi5mYWNlSW5kZXggPSBhO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBpbnRlcnNlY3Rpb247XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiByYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XHJcblxyXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XHJcbiAgICAgICAgdmFyIG1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcclxuXHJcbiAgICAgICAgaWYgKCBtYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZSBkaXN0YW5jZSB0byByYXlcclxuXHJcbiAgICAgICAgaWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG5cclxuICAgICAgICB2YXIgbWF0cml4V29ybGQgPSB0aGlzLm1hdHJpeFdvcmxkO1xyXG5cclxuICAgICAgICBzcGhlcmUuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKTtcclxuICAgICAgICBzcGhlcmUuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xyXG5cclxuICAgICAgICBpZiAoIHJheWNhc3Rlci5yYXkuaXNJbnRlcnNlY3Rpb25TcGhlcmUoIHNwaGVyZSApID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgYm91bmRpbmdCb3ggYmVmb3JlIGNvbnRpbnVpbmdcclxuXHJcbiAgICAgICAgaW52ZXJzZU1hdHJpeC5nZXRJbnZlcnNlKCBtYXRyaXhXb3JsZCApO1xyXG4gICAgICAgIHJheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBpbnZlcnNlTWF0cml4ICk7XHJcblxyXG4gICAgICAgIGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHJheS5pc0ludGVyc2VjdGlvbkJveCggZ2VvbWV0cnkuYm91bmRpbmdCb3ggKSA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHV2cywgaW50ZXJzZWN0aW9uO1xyXG5cclxuICAgICAgICBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYSwgYiwgYztcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XHJcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcclxuICAgICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGF0dHJpYnV0ZXMudXYgIT09IHVuZGVmaW5lZCApe1xyXG5cclxuICAgICAgICAgICAgICAgIHV2cyA9IGF0dHJpYnV0ZXMudXYuYXJyYXk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBpbmRpY2VzID0gaW5kZXguYXJyYXk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICs9IDMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGEgPSBpbmRpY2VzWyBpIF07XHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IGluZGljZXNbIGkgKyAxIF07XHJcbiAgICAgICAgICAgICAgICAgICAgYyA9IGluZGljZXNbIGkgKyAyIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbiA9IGNoZWNrQnVmZmVyR2VvbWV0cnlJbnRlcnNlY3Rpb24oIHRoaXMsIHJheWNhc3RlciwgcmF5LCBwb3NpdGlvbnMsIHV2cywgYSwgYiwgYyApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGludGVyc2VjdGlvbiApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbi5mYWNlSW5kZXggPSBNYXRoLmZsb29yKCBpIC8gMyApOyAvLyB0cmlhbmdsZSBudW1iZXIgaW4gaW5kaWNlcyBidWZmZXIgc2VtYW50aWNzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0aW9uICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSArPSA5ICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBhID0gaSAvIDM7XHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IGEgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGMgPSBhICsgMjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uID0gY2hlY2tCdWZmZXJHZW9tZXRyeUludGVyc2VjdGlvbiggdGhpcywgcmF5Y2FzdGVyLCByYXksIHBvc2l0aW9ucywgdXZzLCBhLCBiLCBjICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggaW50ZXJzZWN0aW9uICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uLmluZGV4ID0gYTsgLy8gdHJpYW5nbGUgbnVtYmVyIGluIHBvc2l0aW9ucyBidWZmZXIgc2VtYW50aWNzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0aW9uICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgZnZBLCBmdkIsIGZ2QztcclxuICAgICAgICAgICAgdmFyIGlzRmFjZU1hdGVyaWFsID0gbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsO1xyXG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWxzID0gaXNGYWNlTWF0ZXJpYWwgPT09IHRydWUgPyBtYXRlcmlhbC5tYXRlcmlhbHMgOiBudWxsO1xyXG5cclxuICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XHJcbiAgICAgICAgICAgIHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xyXG4gICAgICAgICAgICB2YXIgZmFjZVZlcnRleFV2cyA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIDAgXTtcclxuICAgICAgICAgICAgaWYgKCBmYWNlVmVydGV4VXZzLmxlbmd0aCA+IDAgKSB1dnMgPSBmYWNlVmVydGV4VXZzO1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGYgPSAwLCBmbCA9IGZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBmYWNlID0gZmFjZXNbIGYgXTtcclxuICAgICAgICAgICAgICAgIHZhciBmYWNlTWF0ZXJpYWwgPSBpc0ZhY2VNYXRlcmlhbCA9PT0gdHJ1ZSA/IG1hdGVyaWFsc1sgZmFjZS5tYXRlcmlhbEluZGV4IF0gOiBtYXRlcmlhbDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGZhY2VNYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgZnZBID0gdmVydGljZXNbIGZhY2UuYSBdO1xyXG4gICAgICAgICAgICAgICAgZnZCID0gdmVydGljZXNbIGZhY2UuYiBdO1xyXG4gICAgICAgICAgICAgICAgZnZDID0gdmVydGljZXNbIGZhY2UuYyBdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggZmFjZU1hdGVyaWFsLm1vcnBoVGFyZ2V0cyA9PT0gdHJ1ZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbW9ycGhJbmZsdWVuY2VzID0gdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZBLnNldCggMCwgMCwgMCApO1xyXG4gICAgICAgICAgICAgICAgICAgIHZCLnNldCggMCwgMCwgMCApO1xyXG4gICAgICAgICAgICAgICAgICAgIHZDLnNldCggMCwgMCwgMCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgdCA9IDAsIHRsID0gbW9ycGhUYXJnZXRzLmxlbmd0aDsgdCA8IHRsOyB0ICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZmx1ZW5jZSA9IG1vcnBoSW5mbHVlbmNlc1sgdCBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpbmZsdWVuY2UgPT09IDAgKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRzID0gbW9ycGhUYXJnZXRzWyB0IF0udmVydGljZXM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2QS5hZGRTY2FsZWRWZWN0b3IoIHRlbXBBLnN1YlZlY3RvcnMoIHRhcmdldHNbIGZhY2UuYSBdLCBmdkEgKSwgaW5mbHVlbmNlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZCLmFkZFNjYWxlZFZlY3RvciggdGVtcEIuc3ViVmVjdG9ycyggdGFyZ2V0c1sgZmFjZS5iIF0sIGZ2QiApLCBpbmZsdWVuY2UgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdkMuYWRkU2NhbGVkVmVjdG9yKCB0ZW1wQy5zdWJWZWN0b3JzKCB0YXJnZXRzWyBmYWNlLmMgXSwgZnZDICksIGluZmx1ZW5jZSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZBLmFkZCggZnZBICk7XHJcbiAgICAgICAgICAgICAgICAgICAgdkIuYWRkKCBmdkIgKTtcclxuICAgICAgICAgICAgICAgICAgICB2Qy5hZGQoIGZ2QyApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmdkEgPSB2QTtcclxuICAgICAgICAgICAgICAgICAgICBmdkIgPSB2QjtcclxuICAgICAgICAgICAgICAgICAgICBmdkMgPSB2QztcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uID0gY2hlY2tJbnRlcnNlY3Rpb24oIHRoaXMsIHJheWNhc3RlciwgcmF5LCBmdkEsIGZ2QiwgZnZDLCBpbnRlcnNlY3Rpb25Qb2ludCApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggaW50ZXJzZWN0aW9uICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHV2cyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1dnNfZiA9IHV2c1sgZiBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1dkEuY29weSggdXZzX2ZbIDAgXSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1dkIuY29weSggdXZzX2ZbIDEgXSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1dkMuY29weSggdXZzX2ZbIDIgXSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uLnV2ID0gdXZJbnRlcnNlY3Rpb24oIGludGVyc2VjdGlvblBvaW50LCBmdkEsIGZ2QiwgZnZDLCB1dkEsIHV2QiwgdXZDICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uLmZhY2UgPSBmYWNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbi5mYWNlSW5kZXggPSBmO1xyXG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0aW9uICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbn0oKSApO1xyXG5cclxuVEhSRUUuTWVzaC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICkuY29weSggdGhpcyApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL29iamVjdHMvQm9uZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgaWtlcnIgLyBodHRwOi8vdmVyb2xkLmNvbVxyXG4gKi9cclxuXHJcblRIUkVFLkJvbmUgPSBmdW5jdGlvbiAoIHNraW4gKSB7XHJcblxyXG4gICAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdCb25lJztcclxuXHJcbiAgICB0aGlzLnNraW4gPSBza2luO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkJvbmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblRIUkVFLkJvbmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQm9uZTtcclxuXHJcblRIUkVFLkJvbmUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcbiAgICBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcbiAgICB0aGlzLnNraW4gPSBzb3VyY2Uuc2tpbjtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9vYmplY3RzL1NrZWxldG9uLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBtaWNoYWVsIGd1ZXJyZXJvIC8gaHR0cDovL3JlYWxpdHltZWx0ZG93bi5jb21cclxuICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXHJcbiAqL1xyXG5cclxuVEhSRUUuU2tlbGV0b24gPSBmdW5jdGlvbiAoIGJvbmVzLCBib25lSW52ZXJzZXMsIHVzZVZlcnRleFRleHR1cmUgKSB7XHJcblxyXG4gICAgdGhpcy51c2VWZXJ0ZXhUZXh0dXJlID0gdXNlVmVydGV4VGV4dHVyZSAhPT0gdW5kZWZpbmVkID8gdXNlVmVydGV4VGV4dHVyZSA6IHRydWU7XHJcblxyXG4gICAgdGhpcy5pZGVudGl0eU1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG4gICAgLy8gY29weSB0aGUgYm9uZSBhcnJheVxyXG5cclxuICAgIGJvbmVzID0gYm9uZXMgfHwgW107XHJcblxyXG4gICAgdGhpcy5ib25lcyA9IGJvbmVzLnNsaWNlKCAwICk7XHJcblxyXG4gICAgLy8gY3JlYXRlIGEgYm9uZSB0ZXh0dXJlIG9yIGFuIGFycmF5IG9mIGZsb2F0c1xyXG5cclxuICAgIGlmICggdGhpcy51c2VWZXJ0ZXhUZXh0dXJlICkge1xyXG5cclxuICAgICAgICAvLyBsYXlvdXQgKDEgbWF0cml4ID0gNCBwaXhlbHMpXHJcbiAgICAgICAgLy8gICAgICBSR0JBIFJHQkEgUkdCQSBSR0JBICg9PiBjb2x1bW4xLCBjb2x1bW4yLCBjb2x1bW4zLCBjb2x1bW40KVxyXG4gICAgICAgIC8vICB3aXRoICA4eDggIHBpeGVsIHRleHR1cmUgbWF4ICAgMTYgYm9uZXMgKiA0IHBpeGVscyA9ICAoOCAqIDgpXHJcbiAgICAgICAgLy8gICAgICAgMTZ4MTYgcGl4ZWwgdGV4dHVyZSBtYXggICA2NCBib25lcyAqIDQgcGl4ZWxzID0gKDE2ICogMTYpXHJcbiAgICAgICAgLy8gICAgICAgMzJ4MzIgcGl4ZWwgdGV4dHVyZSBtYXggIDI1NiBib25lcyAqIDQgcGl4ZWxzID0gKDMyICogMzIpXHJcbiAgICAgICAgLy8gICAgICAgNjR4NjQgcGl4ZWwgdGV4dHVyZSBtYXggMTAyNCBib25lcyAqIDQgcGl4ZWxzID0gKDY0ICogNjQpXHJcblxyXG5cclxuICAgICAgICB2YXIgc2l6ZSA9IE1hdGguc3FydCggdGhpcy5ib25lcy5sZW5ndGggKiA0ICk7IC8vIDQgcGl4ZWxzIG5lZWRlZCBmb3IgMSBtYXRyaXhcclxuICAgICAgICBzaXplID0gVEhSRUUuTWF0aC5uZXh0UG93ZXJPZlR3byggTWF0aC5jZWlsKCBzaXplICkgKTtcclxuICAgICAgICBzaXplID0gTWF0aC5tYXgoIHNpemUsIDQgKTtcclxuXHJcbiAgICAgICAgdGhpcy5ib25lVGV4dHVyZVdpZHRoID0gc2l6ZTtcclxuICAgICAgICB0aGlzLmJvbmVUZXh0dXJlSGVpZ2h0ID0gc2l6ZTtcclxuXHJcbiAgICAgICAgdGhpcy5ib25lTWF0cmljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCB0aGlzLmJvbmVUZXh0dXJlV2lkdGggKiB0aGlzLmJvbmVUZXh0dXJlSGVpZ2h0ICogNCApOyAvLyA0IGZsb2F0cyBwZXIgUkdCQSBwaXhlbFxyXG4gICAgICAgIHRoaXMuYm9uZVRleHR1cmUgPSBuZXcgVEhSRUUuRGF0YVRleHR1cmUoIHRoaXMuYm9uZU1hdHJpY2VzLCB0aGlzLmJvbmVUZXh0dXJlV2lkdGgsIHRoaXMuYm9uZVRleHR1cmVIZWlnaHQsIFRIUkVFLlJHQkFGb3JtYXQsIFRIUkVFLkZsb2F0VHlwZSApO1xyXG5cclxuICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIHRoaXMuYm9uZU1hdHJpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggMTYgKiB0aGlzLmJvbmVzLmxlbmd0aCApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyB1c2UgdGhlIHN1cHBsaWVkIGJvbmUgaW52ZXJzZXMgb3IgY2FsY3VsYXRlIHRoZSBpbnZlcnNlc1xyXG5cclxuICAgIGlmICggYm9uZUludmVyc2VzID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlSW52ZXJzZXMoKTtcclxuXHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMuYm9uZXMubGVuZ3RoID09PSBib25lSW52ZXJzZXMubGVuZ3RoICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5ib25lSW52ZXJzZXMgPSBib25lSW52ZXJzZXMuc2xpY2UoIDAgKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlNrZWxldG9uIGJvbkludmVyc2VzIGlzIHRoZSB3cm9uZyBsZW5ndGguJyApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5ib25lSW52ZXJzZXMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuYm9uZUludmVyc2VzLnB1c2goIG5ldyBUSFJFRS5NYXRyaXg0KCkgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Ta2VsZXRvbi5wcm90b3R5cGUuY2FsY3VsYXRlSW52ZXJzZXMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdGhpcy5ib25lSW52ZXJzZXMgPSBbXTtcclxuXHJcbiAgICBmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5ib25lcy5sZW5ndGg7IGIgPCBibDsgYiArKyApIHtcclxuXHJcbiAgICAgICAgdmFyIGludmVyc2UgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMuYm9uZXNbIGIgXSApIHtcclxuXHJcbiAgICAgICAgICAgIGludmVyc2UuZ2V0SW52ZXJzZSggdGhpcy5ib25lc1sgYiBdLm1hdHJpeFdvcmxkICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5ib25lSW52ZXJzZXMucHVzaCggaW52ZXJzZSApO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Ta2VsZXRvbi5wcm90b3R5cGUucG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgYm9uZTtcclxuXHJcbiAgICAvLyByZWNvdmVyIHRoZSBiaW5kLXRpbWUgd29ybGQgbWF0cmljZXNcclxuXHJcbiAgICBmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5ib25lcy5sZW5ndGg7IGIgPCBibDsgYiArKyApIHtcclxuXHJcbiAgICAgICAgYm9uZSA9IHRoaXMuYm9uZXNbIGIgXTtcclxuXHJcbiAgICAgICAgaWYgKCBib25lICkge1xyXG5cclxuICAgICAgICAgICAgYm9uZS5tYXRyaXhXb3JsZC5nZXRJbnZlcnNlKCB0aGlzLmJvbmVJbnZlcnNlc1sgYiBdICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29tcHV0ZSB0aGUgbG9jYWwgbWF0cmljZXMsIHBvc2l0aW9ucywgcm90YXRpb25zIGFuZCBzY2FsZXNcclxuXHJcbiAgICBmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5ib25lcy5sZW5ndGg7IGIgPCBibDsgYiArKyApIHtcclxuXHJcbiAgICAgICAgYm9uZSA9IHRoaXMuYm9uZXNbIGIgXTtcclxuXHJcbiAgICAgICAgaWYgKCBib25lICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBib25lLnBhcmVudCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBib25lLm1hdHJpeC5nZXRJbnZlcnNlKCBib25lLnBhcmVudC5tYXRyaXhXb3JsZCApO1xyXG4gICAgICAgICAgICAgICAgYm9uZS5tYXRyaXgubXVsdGlwbHkoIGJvbmUubWF0cml4V29ybGQgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgYm9uZS5tYXRyaXguY29weSggYm9uZS5tYXRyaXhXb3JsZCApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYm9uZS5tYXRyaXguZGVjb21wb3NlKCBib25lLnBvc2l0aW9uLCBib25lLnF1YXRlcm5pb24sIGJvbmUuc2NhbGUgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Ta2VsZXRvbi5wcm90b3R5cGUudXBkYXRlID0gKCBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIG9mZnNldE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcclxuXHJcbiAgICAgICAgLy8gZmxhdHRlbiBib25lIG1hdHJpY2VzIHRvIGFycmF5XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xyXG5cclxuICAgICAgICAgICAgLy8gY29tcHV0ZSB0aGUgb2Zmc2V0IGJldHdlZW4gdGhlIGN1cnJlbnQgYW5kIHRoZSBvcmlnaW5hbCB0cmFuc2Zvcm1cclxuXHJcbiAgICAgICAgICAgIHZhciBtYXRyaXggPSB0aGlzLmJvbmVzWyBiIF0gPyB0aGlzLmJvbmVzWyBiIF0ubWF0cml4V29ybGQgOiB0aGlzLmlkZW50aXR5TWF0cml4O1xyXG5cclxuICAgICAgICAgICAgb2Zmc2V0TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeCwgdGhpcy5ib25lSW52ZXJzZXNbIGIgXSApO1xyXG4gICAgICAgICAgICBvZmZzZXRNYXRyaXguZmxhdHRlblRvQXJyYXlPZmZzZXQoIHRoaXMuYm9uZU1hdHJpY2VzLCBiICogMTYgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIHRoaXMudXNlVmVydGV4VGV4dHVyZSApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYm9uZVRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbn0gKSgpO1xyXG5cclxuVEhSRUUuU2tlbGV0b24ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuU2tlbGV0b24oIHRoaXMuYm9uZXMsIHRoaXMuYm9uZUludmVyc2VzLCB0aGlzLnVzZVZlcnRleFRleHR1cmUgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9vYmplY3RzL1NraW5uZWRNZXNoLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXHJcbiAqL1xyXG5cclxuVEhSRUUuU2tpbm5lZE1lc2ggPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCwgdXNlVmVydGV4VGV4dHVyZSApIHtcclxuXHJcbiAgICBUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdTa2lubmVkTWVzaCc7XHJcblxyXG4gICAgdGhpcy5iaW5kTW9kZSA9IFwiYXR0YWNoZWRcIjtcclxuICAgIHRoaXMuYmluZE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcbiAgICB0aGlzLmJpbmRNYXRyaXhJbnZlcnNlID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcbiAgICAvLyBpbml0IGJvbmVzXHJcblxyXG4gICAgLy8gVE9ETzogcmVtb3ZlIGJvbmUgY3JlYXRpb24gYXMgdGhlcmUgaXMgbm8gcmVhc29uIChvdGhlciB0aGFuXHJcbiAgICAvLyBjb252ZW5pZW5jZSkgZm9yIFRIUkVFLlNraW5uZWRNZXNoIHRvIGRvIHRoaXMuXHJcblxyXG4gICAgdmFyIGJvbmVzID0gW107XHJcblxyXG4gICAgaWYgKCB0aGlzLmdlb21ldHJ5ICYmIHRoaXMuZ2VvbWV0cnkuYm9uZXMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgdmFyIGJvbmUsIGdib25lO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5nZW9tZXRyeS5ib25lcy5sZW5ndGg7IGIgPCBibDsgKysgYiApIHtcclxuXHJcbiAgICAgICAgICAgIGdib25lID0gdGhpcy5nZW9tZXRyeS5ib25lc1sgYiBdO1xyXG5cclxuICAgICAgICAgICAgYm9uZSA9IG5ldyBUSFJFRS5Cb25lKCB0aGlzICk7XHJcbiAgICAgICAgICAgIGJvbmVzLnB1c2goIGJvbmUgKTtcclxuXHJcbiAgICAgICAgICAgIGJvbmUubmFtZSA9IGdib25lLm5hbWU7XHJcbiAgICAgICAgICAgIGJvbmUucG9zaXRpb24uZnJvbUFycmF5KCBnYm9uZS5wb3MgKTtcclxuICAgICAgICAgICAgYm9uZS5xdWF0ZXJuaW9uLmZyb21BcnJheSggZ2JvbmUucm90cSApO1xyXG4gICAgICAgICAgICBpZiAoIGdib25lLnNjbCAhPT0gdW5kZWZpbmVkICkgYm9uZS5zY2FsZS5mcm9tQXJyYXkoIGdib25lLnNjbCApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmdlb21ldHJ5LmJvbmVzLmxlbmd0aDsgYiA8IGJsOyArKyBiICkge1xyXG5cclxuICAgICAgICAgICAgZ2JvbmUgPSB0aGlzLmdlb21ldHJ5LmJvbmVzWyBiIF07XHJcblxyXG4gICAgICAgICAgICBpZiAoIGdib25lLnBhcmVudCAhPT0gLSAxICYmIGdib25lLnBhcmVudCAhPT0gbnVsbCkge1xyXG5cclxuICAgICAgICAgICAgICAgIGJvbmVzWyBnYm9uZS5wYXJlbnQgXS5hZGQoIGJvbmVzWyBiIF0gKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoIGJvbmVzWyBiIF0gKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm5vcm1hbGl6ZVNraW5XZWlnaHRzKCk7XHJcblxyXG4gICAgdGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xyXG4gICAgdGhpcy5iaW5kKCBuZXcgVEhSRUUuU2tlbGV0b24oIGJvbmVzLCB1bmRlZmluZWQsIHVzZVZlcnRleFRleHR1cmUgKSwgdGhpcy5tYXRyaXhXb3JsZCApO1xyXG5cclxufTtcclxuXHJcblxyXG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NZXNoLnByb3RvdHlwZSApO1xyXG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Ta2lubmVkTWVzaDtcclxuXHJcblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oIHNrZWxldG9uLCBiaW5kTWF0cml4ICkge1xyXG5cclxuICAgIHRoaXMuc2tlbGV0b24gPSBza2VsZXRvbjtcclxuXHJcbiAgICBpZiAoIGJpbmRNYXRyaXggPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xyXG5cclxuICAgICAgICB0aGlzLnNrZWxldG9uLmNhbGN1bGF0ZUludmVyc2VzKCk7XHJcblxyXG4gICAgICAgIGJpbmRNYXRyaXggPSB0aGlzLm1hdHJpeFdvcmxkO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmJpbmRNYXRyaXguY29weSggYmluZE1hdHJpeCApO1xyXG4gICAgdGhpcy5iaW5kTWF0cml4SW52ZXJzZS5nZXRJbnZlcnNlKCBiaW5kTWF0cml4ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLnBvc2UgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdGhpcy5za2VsZXRvbi5wb3NlKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLm5vcm1hbGl6ZVNraW5XZWlnaHRzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIGlmICggdGhpcy5nZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBzdyA9IHRoaXMuZ2VvbWV0cnkuc2tpbldlaWdodHNbIGkgXTtcclxuXHJcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IDEuMCAvIHN3Lmxlbmd0aE1hbmhhdHRhbigpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBzY2FsZSAhPT0gSW5maW5pdHkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgc3cubXVsdGlwbHlTY2FsYXIoIHNjYWxlICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIHN3LnNldCggMSApOyAvLyB0aGlzIHdpbGwgYmUgbm9ybWFsaXplZCBieSB0aGUgc2hhZGVyIGFueXdheVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gc2tpbm5pbmcgd2VpZ2h0cyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgZm9yIFRIUkVFLkJ1ZmZlckdlb21ldHJ5XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZCA9IGZ1bmN0aW9uKCBmb3JjZSApIHtcclxuXHJcbiAgICBUSFJFRS5NZXNoLnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZC5jYWxsKCB0aGlzLCB0cnVlICk7XHJcblxyXG4gICAgaWYgKCB0aGlzLmJpbmRNb2RlID09PSBcImF0dGFjaGVkXCIgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuYmluZE1hdHJpeEludmVyc2UuZ2V0SW52ZXJzZSggdGhpcy5tYXRyaXhXb3JsZCApO1xyXG5cclxuICAgIH0gZWxzZSBpZiAoIHRoaXMuYmluZE1vZGUgPT09IFwiZGV0YWNoZWRcIiApIHtcclxuXHJcbiAgICAgICAgdGhpcy5iaW5kTWF0cml4SW52ZXJzZS5nZXRJbnZlcnNlKCB0aGlzLmJpbmRNYXRyaXggKTtcclxuXHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5Ta2lubmVkTWVzaCB1bnJlY29nbml6ZWQgYmluZE1vZGU6ICcgKyB0aGlzLmJpbmRNb2RlICk7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCwgdGhpcy51c2VWZXJ0ZXhUZXh0dXJlICkuY29weSggdGhpcyApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL29iamVjdHMvTE9ELmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5MT0QgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdMT0QnO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLCB7XHJcbiAgICAgICAgbGV2ZWxzOiB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBbXVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb2JqZWN0czoge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5MT0Q6IC5vYmplY3RzIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmxldmVscy4nICk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sZXZlbHM7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSApO1xyXG5cclxufTtcclxuXHJcblxyXG5USFJFRS5MT0QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblRIUkVFLkxPRC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MT0Q7XHJcblxyXG5USFJFRS5MT0QucHJvdG90eXBlLmFkZExldmVsID0gZnVuY3Rpb24gKCBvYmplY3QsIGRpc3RhbmNlICkge1xyXG5cclxuICAgIGlmICggZGlzdGFuY2UgPT09IHVuZGVmaW5lZCApIGRpc3RhbmNlID0gMDtcclxuXHJcbiAgICBkaXN0YW5jZSA9IE1hdGguYWJzKCBkaXN0YW5jZSApO1xyXG5cclxuICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcclxuXHJcbiAgICBmb3IgKCB2YXIgbCA9IDA7IGwgPCBsZXZlbHMubGVuZ3RoOyBsICsrICkge1xyXG5cclxuICAgICAgICBpZiAoIGRpc3RhbmNlIDwgbGV2ZWxzWyBsIF0uZGlzdGFuY2UgKSB7XHJcblxyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBsZXZlbHMuc3BsaWNlKCBsLCAwLCB7IGRpc3RhbmNlOiBkaXN0YW5jZSwgb2JqZWN0OiBvYmplY3QgfSApO1xyXG5cclxuICAgIHRoaXMuYWRkKCBvYmplY3QgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5MT0QucHJvdG90eXBlLmdldE9iamVjdEZvckRpc3RhbmNlID0gZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcclxuXHJcbiAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XHJcblxyXG4gICAgZm9yICggdmFyIGkgPSAxLCBsID0gbGV2ZWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIGlmICggZGlzdGFuY2UgPCBsZXZlbHNbIGkgXS5kaXN0YW5jZSApIHtcclxuXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsZXZlbHNbIGkgLSAxIF0ub2JqZWN0O1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxPRC5wcm90b3R5cGUucmF5Y2FzdCA9ICggZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBtYXRyaXhQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcclxuXHJcbiAgICAgICAgbWF0cml4UG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XHJcblxyXG4gICAgICAgIHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIG1hdHJpeFBvc2l0aW9uICk7XHJcblxyXG4gICAgICAgIHRoaXMuZ2V0T2JqZWN0Rm9yRGlzdGFuY2UoIGRpc3RhbmNlICkucmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICk7XHJcblxyXG4gICAgfTtcclxuXHJcbn0oKSApO1xyXG5cclxuVEhSRUUuTE9ELnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgIHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSggY2FtZXJhICkge1xyXG5cclxuICAgICAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XHJcblxyXG4gICAgICAgIGlmICggbGV2ZWxzLmxlbmd0aCA+IDEgKSB7XHJcblxyXG4gICAgICAgICAgICB2MS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xyXG4gICAgICAgICAgICB2Mi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IHYxLmRpc3RhbmNlVG8oIHYyICk7XHJcblxyXG4gICAgICAgICAgICBsZXZlbHNbIDAgXS5vYmplY3QudmlzaWJsZSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDEsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGRpc3RhbmNlID49IGxldmVsc1sgaSBdLmRpc3RhbmNlICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXZlbHNbIGkgLSAxIF0ub2JqZWN0LnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBsZXZlbHNbIGkgXS5vYmplY3QudmlzaWJsZSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yICggOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXZlbHNbIGkgXS5vYmplY3QudmlzaWJsZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbn0oKTtcclxuXHJcblRIUkVFLkxPRC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuICAgIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSwgZmFsc2UgKTtcclxuXHJcbiAgICB2YXIgbGV2ZWxzID0gc291cmNlLmxldmVscztcclxuXHJcbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgdmFyIGxldmVsID0gbGV2ZWxzWyBpIF07XHJcblxyXG4gICAgICAgIHRoaXMuYWRkTGV2ZWwoIGxldmVsLm9iamVjdC5jbG9uZSgpLCBsZXZlbC5kaXN0YW5jZSApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG5USFJFRS5MT0QucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcclxuXHJcbiAgICB2YXIgZGF0YSA9IFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xyXG5cclxuICAgIGRhdGEub2JqZWN0LmxldmVscyA9IFtdO1xyXG5cclxuICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcclxuXHJcbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgdmFyIGxldmVsID0gbGV2ZWxzWyBpIF07XHJcblxyXG4gICAgICAgIGRhdGEub2JqZWN0LmxldmVscy5wdXNoKCB7XHJcbiAgICAgICAgICAgIG9iamVjdDogbGV2ZWwub2JqZWN0LnV1aWQsXHJcbiAgICAgICAgICAgIGRpc3RhbmNlOiBsZXZlbC5kaXN0YW5jZVxyXG4gICAgICAgIH0gKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRhdGE7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvb2JqZWN0cy9TcHJpdGUuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlNwcml0ZSA9ICggZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBpbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbIDAsIDEsIDIsICAwLCAyLCAzIF0gKTtcclxuICAgIHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIFsgLSAwLjUsIC0gMC41LCAwLCAgIDAuNSwgLSAwLjUsIDAsICAgMC41LCAwLjUsIDAsICAgLSAwLjUsIDAuNSwgMCBdICk7XHJcbiAgICB2YXIgdXZzID0gbmV3IEZsb2F0MzJBcnJheSggWyAwLCAwLCAgIDEsIDAsICAgMSwgMSwgICAwLCAxIF0gKTtcclxuXHJcbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcclxuICAgIGdlb21ldHJ5LnNldEluZGV4KCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBpbmRpY2VzLCAxICkgKTtcclxuICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xyXG4gICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiBTcHJpdGUoIG1hdGVyaWFsICkge1xyXG5cclxuICAgICAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgICAgIHRoaXMudHlwZSA9ICdTcHJpdGUnO1xyXG5cclxuICAgICAgICB0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XHJcbiAgICAgICAgdGhpcy5tYXRlcmlhbCA9ICggbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCApID8gbWF0ZXJpYWwgOiBuZXcgVEhSRUUuU3ByaXRlTWF0ZXJpYWwoKTtcclxuXHJcbiAgICB9O1xyXG5cclxufSApKCk7XHJcblxyXG5USFJFRS5TcHJpdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblRIUkVFLlNwcml0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TcHJpdGU7XHJcblxyXG5USFJFRS5TcHJpdGUucHJvdG90eXBlLnJheWNhc3QgPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgbWF0cml4UG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiByYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XHJcblxyXG4gICAgICAgIG1hdHJpeFBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xyXG5cclxuICAgICAgICB2YXIgZGlzdGFuY2VTcSA9IHJheWNhc3Rlci5yYXkuZGlzdGFuY2VTcVRvUG9pbnQoIG1hdHJpeFBvc2l0aW9uICk7XHJcbiAgICAgICAgdmFyIGd1ZXNzU2l6ZVNxID0gdGhpcy5zY2FsZS54ICogdGhpcy5zY2FsZS55O1xyXG5cclxuICAgICAgICBpZiAoIGRpc3RhbmNlU3EgPiBndWVzc1NpemVTcSApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcnNlY3RzLnB1c2goIHtcclxuXHJcbiAgICAgICAgICAgIGRpc3RhbmNlOiBNYXRoLnNxcnQoIGRpc3RhbmNlU3EgKSxcclxuICAgICAgICAgICAgcG9pbnQ6IHRoaXMucG9zaXRpb24sXHJcbiAgICAgICAgICAgIGZhY2U6IG51bGwsXHJcbiAgICAgICAgICAgIG9iamVjdDogdGhpc1xyXG5cclxuICAgICAgICB9ICk7XHJcblxyXG4gICAgfTtcclxuXHJcbn0oKSApO1xyXG5cclxuVEhSRUUuU3ByaXRlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMubWF0ZXJpYWwgKS5jb3B5KCB0aGlzICk7XHJcblxyXG59O1xyXG5cclxuLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcclxuXHJcblRIUkVFLlBhcnRpY2xlID0gVEhSRUUuU3ByaXRlO1xyXG5cclxuLy8gRmlsZTpzcmMvb2JqZWN0cy9MZW5zRmxhcmUuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkxlbnNGbGFyZSA9IGZ1bmN0aW9uICggdGV4dHVyZSwgc2l6ZSwgZGlzdGFuY2UsIGJsZW5kaW5nLCBjb2xvciApIHtcclxuXHJcbiAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy5sZW5zRmxhcmVzID0gW107XHJcblxyXG4gICAgdGhpcy5wb3NpdGlvblNjcmVlbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICB0aGlzLmN1c3RvbVVwZGF0ZUNhbGxiYWNrID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIGlmICggdGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICB0aGlzLmFkZCggdGV4dHVyZSwgc2l6ZSwgZGlzdGFuY2UsIGJsZW5kaW5nLCBjb2xvciApO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5MZW5zRmxhcmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblRIUkVFLkxlbnNGbGFyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MZW5zRmxhcmU7XHJcblxyXG5cclxuLypcclxuICogQWRkOiBhZGRzIGFub3RoZXIgZmxhcmVcclxuICovXHJcblxyXG5USFJFRS5MZW5zRmxhcmUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICggdGV4dHVyZSwgc2l6ZSwgZGlzdGFuY2UsIGJsZW5kaW5nLCBjb2xvciwgb3BhY2l0eSApIHtcclxuXHJcbiAgICBpZiAoIHNpemUgPT09IHVuZGVmaW5lZCApIHNpemUgPSAtIDE7XHJcbiAgICBpZiAoIGRpc3RhbmNlID09PSB1bmRlZmluZWQgKSBkaXN0YW5jZSA9IDA7XHJcbiAgICBpZiAoIG9wYWNpdHkgPT09IHVuZGVmaW5lZCApIG9wYWNpdHkgPSAxO1xyXG4gICAgaWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkICkgY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XHJcbiAgICBpZiAoIGJsZW5kaW5nID09PSB1bmRlZmluZWQgKSBibGVuZGluZyA9IFRIUkVFLk5vcm1hbEJsZW5kaW5nO1xyXG5cclxuICAgIGRpc3RhbmNlID0gTWF0aC5taW4oIGRpc3RhbmNlLCBNYXRoLm1heCggMCwgZGlzdGFuY2UgKSApO1xyXG5cclxuICAgIHRoaXMubGVuc0ZsYXJlcy5wdXNoKCB7XHJcbiAgICAgICAgdGV4dHVyZTogdGV4dHVyZSxcdC8vIFRIUkVFLlRleHR1cmVcclxuICAgICAgICBzaXplOiBzaXplLCBcdFx0Ly8gc2l6ZSBpbiBwaXhlbHMgKC0xID0gdXNlIHRleHR1cmUud2lkdGgpXHJcbiAgICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlLCBcdC8vIGRpc3RhbmNlICgwLTEpIGZyb20gbGlnaHQgc291cmNlICgwPWF0IGxpZ2h0IHNvdXJjZSlcclxuICAgICAgICB4OiAwLCB5OiAwLCB6OiAwLFx0Ly8gc2NyZWVuIHBvc2l0aW9uICgtMSA9PiAxKSB6ID0gMCBpcyBpbiBmcm9udCB6ID0gMSBpcyBiYWNrXHJcbiAgICAgICAgc2NhbGU6IDEsIFx0XHQvLyBzY2FsZVxyXG4gICAgICAgIHJvdGF0aW9uOiAwLCBcdFx0Ly8gcm90YXRpb25cclxuICAgICAgICBvcGFjaXR5OiBvcGFjaXR5LFx0Ly8gb3BhY2l0eVxyXG4gICAgICAgIGNvbG9yOiBjb2xvcixcdFx0Ly8gY29sb3JcclxuICAgICAgICBibGVuZGluZzogYmxlbmRpbmdcdC8vIGJsZW5kaW5nXHJcbiAgICB9ICk7XHJcblxyXG59O1xyXG5cclxuLypcclxuICogVXBkYXRlIGxlbnMgZmxhcmVzIHVwZGF0ZSBwb3NpdGlvbnMgb24gYWxsIGZsYXJlcyBiYXNlZCBvbiB0aGUgc2NyZWVuIHBvc2l0aW9uXHJcbiAqIFNldCBteUxlbnNGbGFyZS5jdXN0b21VcGRhdGVDYWxsYmFjayB0byBhbHRlciB0aGUgZmxhcmVzIGluIHlvdXIgcHJvamVjdCBzcGVjaWZpYyB3YXkuXHJcbiAqL1xyXG5cclxuVEhSRUUuTGVuc0ZsYXJlLnByb3RvdHlwZS51cGRhdGVMZW5zRmxhcmVzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBmLCBmbCA9IHRoaXMubGVuc0ZsYXJlcy5sZW5ndGg7XHJcbiAgICB2YXIgZmxhcmU7XHJcbiAgICB2YXIgdmVjWCA9IC0gdGhpcy5wb3NpdGlvblNjcmVlbi54ICogMjtcclxuICAgIHZhciB2ZWNZID0gLSB0aGlzLnBvc2l0aW9uU2NyZWVuLnkgKiAyO1xyXG5cclxuICAgIGZvciAoIGYgPSAwOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG4gICAgICAgIGZsYXJlID0gdGhpcy5sZW5zRmxhcmVzWyBmIF07XHJcblxyXG4gICAgICAgIGZsYXJlLnggPSB0aGlzLnBvc2l0aW9uU2NyZWVuLnggKyB2ZWNYICogZmxhcmUuZGlzdGFuY2U7XHJcbiAgICAgICAgZmxhcmUueSA9IHRoaXMucG9zaXRpb25TY3JlZW4ueSArIHZlY1kgKiBmbGFyZS5kaXN0YW5jZTtcclxuXHJcbiAgICAgICAgZmxhcmUud2FudGVkUm90YXRpb24gPSBmbGFyZS54ICogTWF0aC5QSSAqIDAuMjU7XHJcbiAgICAgICAgZmxhcmUucm90YXRpb24gKz0gKCBmbGFyZS53YW50ZWRSb3RhdGlvbiAtIGZsYXJlLnJvdGF0aW9uICkgKiAwLjI1O1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5MZW5zRmxhcmUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcbiAgICBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcbiAgICB0aGlzLnBvc2l0aW9uU2NyZWVuLmNvcHkoIHNvdXJjZS5wb3NpdGlvblNjcmVlbiApO1xyXG4gICAgdGhpcy5jdXN0b21VcGRhdGVDYWxsYmFjayA9IHNvdXJjZS5jdXN0b21VcGRhdGVDYWxsYmFjaztcclxuXHJcbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBzb3VyY2UubGVuc0ZsYXJlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICB0aGlzLmxlbnNGbGFyZXMucHVzaCggc291cmNlLmxlbnNGbGFyZXNbIGkgXSApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9zY2VuZXMvU2NlbmUuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlNjZW5lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnU2NlbmUnO1xyXG5cclxuICAgIHRoaXMuZm9nID0gbnVsbDtcclxuICAgIHRoaXMub3ZlcnJpZGVNYXRlcmlhbCA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5hdXRvVXBkYXRlID0gdHJ1ZTsgLy8gY2hlY2tlZCBieSB0aGUgcmVuZGVyZXJcclxuXHJcbn07XHJcblxyXG5USFJFRS5TY2VuZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuU2NlbmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU2NlbmU7XHJcblxyXG5USFJFRS5TY2VuZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuICAgIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuICAgIGlmICggc291cmNlLmZvZyAhPT0gbnVsbCApIHRoaXMuZm9nID0gc291cmNlLmZvZy5jbG9uZSgpO1xyXG4gICAgaWYgKCBzb3VyY2Uub3ZlcnJpZGVNYXRlcmlhbCAhPT0gbnVsbCApIHRoaXMub3ZlcnJpZGVNYXRlcmlhbCA9IHNvdXJjZS5vdmVycmlkZU1hdGVyaWFsLmNsb25lKCk7XHJcblxyXG4gICAgdGhpcy5hdXRvVXBkYXRlID0gc291cmNlLmF1dG9VcGRhdGU7XHJcbiAgICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBzb3VyY2UubWF0cml4QXV0b1VwZGF0ZTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9zY2VuZXMvRm9nLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5Gb2cgPSBmdW5jdGlvbiAoIGNvbG9yLCBuZWFyLCBmYXIgKSB7XHJcblxyXG4gICAgdGhpcy5uYW1lID0gJyc7XHJcblxyXG4gICAgdGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggY29sb3IgKTtcclxuXHJcbiAgICB0aGlzLm5lYXIgPSAoIG5lYXIgIT09IHVuZGVmaW5lZCApID8gbmVhciA6IDE7XHJcbiAgICB0aGlzLmZhciA9ICggZmFyICE9PSB1bmRlZmluZWQgKSA/IGZhciA6IDEwMDA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRm9nLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLkZvZyggdGhpcy5jb2xvci5nZXRIZXgoKSwgdGhpcy5uZWFyLCB0aGlzLmZhciApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3NjZW5lcy9Gb2dFeHAyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5Gb2dFeHAyID0gZnVuY3Rpb24gKCBjb2xvciwgZGVuc2l0eSApIHtcclxuXHJcbiAgICB0aGlzLm5hbWUgPSAnJztcclxuXHJcbiAgICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCBjb2xvciApO1xyXG4gICAgdGhpcy5kZW5zaXR5ID0gKCBkZW5zaXR5ICE9PSB1bmRlZmluZWQgKSA/IGRlbnNpdHkgOiAwLjAwMDI1O1xyXG5cclxufTtcclxuXHJcblRIUkVFLkZvZ0V4cDIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuRm9nRXhwMiggdGhpcy5jb2xvci5nZXRIZXgoKSwgdGhpcy5kZW5zaXR5ICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsuanNcclxuXHJcblRIUkVFLlNoYWRlckNodW5rID0ge307XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9hbHBoYW1hcF9mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2FscGhhbWFwX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfQUxQSEFNQVBcXG5cXG5cdGRpZmZ1c2VDb2xvci5hICo9IHRleHR1cmUyRCggYWxwaGFNYXAsIHZVdiApLmc7XFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9hbHBoYW1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnYWxwaGFtYXBfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0FMUEhBTUFQXFxuXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBhbHBoYU1hcDtcXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2FscGhhdGVzdF9mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2FscGhhdGVzdF9mcmFnbWVudCddID0gXCIjaWZkZWYgQUxQSEFURVNUXFxuXFxuXHRpZiAoIGRpZmZ1c2VDb2xvci5hIDwgQUxQSEFURVNUICkgZGlzY2FyZDtcXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2FvbWFwX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnYW9tYXBfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9BT01BUFxcblxcblx0dG90YWxBbWJpZW50TGlnaHQgKj0gKCB0ZXh0dXJlMkQoIGFvTWFwLCB2VXYyICkuciAtIDEuMCApICogYW9NYXBJbnRlbnNpdHkgKyAxLjA7XFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9hb21hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnYW9tYXBfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0FPTUFQXFxuXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBhb01hcDtcXG5cdHVuaWZvcm0gZmxvYXQgYW9NYXBJbnRlbnNpdHk7XFxuXFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9iZWdpbl92ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdiZWdpbl92ZXJ0ZXgnXSA9IFwiXFxudmVjMyB0cmFuc2Zvcm1lZCA9IHZlYzMoIHBvc2l0aW9uICk7XFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9iZWdpbm5vcm1hbF92ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdiZWdpbm5vcm1hbF92ZXJ0ZXgnXSA9IFwiXFxudmVjMyBvYmplY3ROb3JtYWwgPSB2ZWMzKCBub3JtYWwgKTtcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2J1bXBtYXBfcGFyc19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2J1bXBtYXBfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0JVTVBNQVBcXG5cXG5cdHVuaWZvcm0gc2FtcGxlcjJEIGJ1bXBNYXA7XFxuXHR1bmlmb3JtIGZsb2F0IGJ1bXBTY2FsZTtcXG5cXG5cXG5cXG5cdHZlYzIgZEhkeHlfZndkKCkge1xcblxcblx0XHR2ZWMyIGRTVGR4ID0gZEZkeCggdlV2ICk7XFxuXHRcdHZlYzIgZFNUZHkgPSBkRmR5KCB2VXYgKTtcXG5cXG5cdFx0ZmxvYXQgSGxsID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2VXYgKS54O1xcblx0XHRmbG9hdCBkQnggPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZVdiArIGRTVGR4ICkueCAtIEhsbDtcXG5cdFx0ZmxvYXQgZEJ5ID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2VXYgKyBkU1RkeSApLnggLSBIbGw7XFxuXFxuXHRcdHJldHVybiB2ZWMyKCBkQngsIGRCeSApO1xcblxcblx0fVxcblxcblx0dmVjMyBwZXJ0dXJiTm9ybWFsQXJiKCB2ZWMzIHN1cmZfcG9zLCB2ZWMzIHN1cmZfbm9ybSwgdmVjMiBkSGR4eSApIHtcXG5cXG5cdFx0dmVjMyB2U2lnbWFYID0gZEZkeCggc3VyZl9wb3MgKTtcXG5cdFx0dmVjMyB2U2lnbWFZID0gZEZkeSggc3VyZl9wb3MgKTtcXG5cdFx0dmVjMyB2TiA9IHN1cmZfbm9ybTtcXG5cdFx0dmVjMyBSMSA9IGNyb3NzKCB2U2lnbWFZLCB2TiApO1xcblx0XHR2ZWMzIFIyID0gY3Jvc3MoIHZOLCB2U2lnbWFYICk7XFxuXFxuXHRcdGZsb2F0IGZEZXQgPSBkb3QoIHZTaWdtYVgsIFIxICk7XFxuXFxuXHRcdHZlYzMgdkdyYWQgPSBzaWduKCBmRGV0ICkgKiAoIGRIZHh5LnggKiBSMSArIGRIZHh5LnkgKiBSMiApO1xcblx0XHRyZXR1cm4gbm9ybWFsaXplKCBhYnMoIGZEZXQgKSAqIHN1cmZfbm9ybSAtIHZHcmFkICk7XFxuXFxuXHR9XFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jb2xvcl9mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2NvbG9yX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfQ09MT1JcXG5cXG5cdGRpZmZ1c2VDb2xvci5yZ2IgKj0gdkNvbG9yO1xcblxcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvY29sb3JfcGFyc19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2NvbG9yX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9DT0xPUlxcblxcblx0dmFyeWluZyB2ZWMzIHZDb2xvcjtcXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2NvbG9yX3BhcnNfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnY29sb3JfcGFyc192ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9DT0xPUlxcblxcblx0dmFyeWluZyB2ZWMzIHZDb2xvcjtcXG5cXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2NvbG9yX3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2NvbG9yX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX0NPTE9SXFxuXFxuXHR2Q29sb3IueHl6ID0gY29sb3IueHl6O1xcblxcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvY29tbW9uLmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnY29tbW9uJ10gPSBcIiNkZWZpbmUgUEkgMy4xNDE1OVxcbiNkZWZpbmUgUEkyIDYuMjgzMThcXG4jZGVmaW5lIFJFQ0lQUk9DQUxfUEkyIDAuMTU5MTU0OTRcXG4jZGVmaW5lIExPRzIgMS40NDI2OTVcXG4jZGVmaW5lIEVQU0lMT04gMWUtNlxcblxcbiNkZWZpbmUgc2F0dXJhdGUoYSkgY2xhbXAoIGEsIDAuMCwgMS4wIClcXG4jZGVmaW5lIHdoaXRlQ29tcGxpbWVudChhKSAoIDEuMCAtIHNhdHVyYXRlKCBhICkgKVxcblxcbnZlYzMgdHJhbnNmb3JtRGlyZWN0aW9uKCBpbiB2ZWMzIG5vcm1hbCwgaW4gbWF0NCBtYXRyaXggKSB7XFxuXFxuXHRyZXR1cm4gbm9ybWFsaXplKCAoIG1hdHJpeCAqIHZlYzQoIG5vcm1hbCwgMC4wICkgKS54eXogKTtcXG5cXG59XFxuXFxudmVjMyBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBpbiB2ZWMzIG5vcm1hbCwgaW4gbWF0NCBtYXRyaXggKSB7XFxuXFxuXHRyZXR1cm4gbm9ybWFsaXplKCAoIHZlYzQoIG5vcm1hbCwgMC4wICkgKiBtYXRyaXggKS54eXogKTtcXG5cXG59XFxuXFxudmVjMyBwcm9qZWN0T25QbGFuZShpbiB2ZWMzIHBvaW50LCBpbiB2ZWMzIHBvaW50T25QbGFuZSwgaW4gdmVjMyBwbGFuZU5vcm1hbCApIHtcXG5cXG5cdGZsb2F0IGRpc3RhbmNlID0gZG90KCBwbGFuZU5vcm1hbCwgcG9pbnQgLSBwb2ludE9uUGxhbmUgKTtcXG5cXG5cdHJldHVybiAtIGRpc3RhbmNlICogcGxhbmVOb3JtYWwgKyBwb2ludDtcXG5cXG59XFxuXFxuZmxvYXQgc2lkZU9mUGxhbmUoIGluIHZlYzMgcG9pbnQsIGluIHZlYzMgcG9pbnRPblBsYW5lLCBpbiB2ZWMzIHBsYW5lTm9ybWFsICkge1xcblxcblx0cmV0dXJuIHNpZ24oIGRvdCggcG9pbnQgLSBwb2ludE9uUGxhbmUsIHBsYW5lTm9ybWFsICkgKTtcXG5cXG59XFxuXFxudmVjMyBsaW5lUGxhbmVJbnRlcnNlY3QoIGluIHZlYzMgcG9pbnRPbkxpbmUsIGluIHZlYzMgbGluZURpcmVjdGlvbiwgaW4gdmVjMyBwb2ludE9uUGxhbmUsIGluIHZlYzMgcGxhbmVOb3JtYWwgKSB7XFxuXFxuXHRyZXR1cm4gbGluZURpcmVjdGlvbiAqICggZG90KCBwbGFuZU5vcm1hbCwgcG9pbnRPblBsYW5lIC0gcG9pbnRPbkxpbmUgKSAvIGRvdCggcGxhbmVOb3JtYWwsIGxpbmVEaXJlY3Rpb24gKSApICsgcG9pbnRPbkxpbmU7XFxuXFxufVxcblxcbmZsb2F0IGNhbGNMaWdodEF0dGVudWF0aW9uKCBmbG9hdCBsaWdodERpc3RhbmNlLCBmbG9hdCBjdXRvZmZEaXN0YW5jZSwgZmxvYXQgZGVjYXlFeHBvbmVudCApIHtcXG5cXG5cdGlmICggZGVjYXlFeHBvbmVudCA+IDAuMCApIHtcXG5cXG5cdCAgcmV0dXJuIHBvdyggc2F0dXJhdGUoIC1saWdodERpc3RhbmNlIC8gY3V0b2ZmRGlzdGFuY2UgKyAxLjAgKSwgZGVjYXlFeHBvbmVudCApO1xcblxcblx0fVxcblxcblx0cmV0dXJuIDEuMDtcXG5cXG59XFxuXFxudmVjMyBGX1NjaGxpY2soIGluIHZlYzMgc3BlY3VsYXJDb2xvciwgaW4gZmxvYXQgZG90TEggKSB7XFxuXFxuXFxuXHRmbG9hdCBmcmVzbmVsID0gZXhwMiggKCAtNS41NTQzNyAqIGRvdExIIC0gNi45ODMxNiApICogZG90TEggKTtcXG5cXG5cdHJldHVybiAoIDEuMCAtIHNwZWN1bGFyQ29sb3IgKSAqIGZyZXNuZWwgKyBzcGVjdWxhckNvbG9yO1xcblxcbn1cXG5cXG5mbG9hdCBHX0JsaW5uUGhvbmdfSW1wbGljaXQoIC8qIGluIGZsb2F0IGRvdE5MLCBpbiBmbG9hdCBkb3ROViAqLyApIHtcXG5cXG5cXG5cdHJldHVybiAwLjI1O1xcblxcbn1cXG5cXG5mbG9hdCBEX0JsaW5uUGhvbmcoIGluIGZsb2F0IHNoaW5pbmVzcywgaW4gZmxvYXQgZG90TkggKSB7XFxuXFxuXFxuXHRyZXR1cm4gKCBzaGluaW5lc3MgKiAwLjUgKyAxLjAgKSAqIHBvdyggZG90TkgsIHNoaW5pbmVzcyApO1xcblxcbn1cXG5cXG52ZWMzIEJSREZfQmxpbm5QaG9uZyggaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBpbiBmbG9hdCBzaGluaW5lc3MsIGluIHZlYzMgbm9ybWFsLCBpbiB2ZWMzIGxpZ2h0RGlyLCBpbiB2ZWMzIHZpZXdEaXIgKSB7XFxuXFxuXHR2ZWMzIGhhbGZEaXIgPSBub3JtYWxpemUoIGxpZ2h0RGlyICsgdmlld0RpciApO1xcblxcblx0ZmxvYXQgZG90TkggPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGhhbGZEaXIgKSApO1xcblx0ZmxvYXQgZG90TEggPSBzYXR1cmF0ZSggZG90KCBsaWdodERpciwgaGFsZkRpciApICk7XFxuXFxuXHR2ZWMzIEYgPSBGX1NjaGxpY2soIHNwZWN1bGFyQ29sb3IsIGRvdExIICk7XFxuXFxuXHRmbG9hdCBHID0gR19CbGlublBob25nX0ltcGxpY2l0KCAvKiBkb3ROTCwgZG90TlYgKi8gKTtcXG5cXG5cdGZsb2F0IEQgPSBEX0JsaW5uUGhvbmcoIHNoaW5pbmVzcywgZG90TkggKTtcXG5cXG5cdHJldHVybiBGICogRyAqIEQ7XFxuXFxufVxcblxcbnZlYzMgaW5wdXRUb0xpbmVhciggaW4gdmVjMyBhICkge1xcblxcblx0I2lmZGVmIEdBTU1BX0lOUFVUXFxuXFxuXHRcdHJldHVybiBwb3coIGEsIHZlYzMoIGZsb2F0KCBHQU1NQV9GQUNUT1IgKSApICk7XFxuXFxuXHQjZWxzZVxcblxcblx0XHRyZXR1cm4gYTtcXG5cXG5cdCNlbmRpZlxcblxcbn1cXG5cXG52ZWMzIGxpbmVhclRvT3V0cHV0KCBpbiB2ZWMzIGEgKSB7XFxuXFxuXHQjaWZkZWYgR0FNTUFfT1VUUFVUXFxuXFxuXHRcdHJldHVybiBwb3coIGEsIHZlYzMoIDEuMCAvIGZsb2F0KCBHQU1NQV9GQUNUT1IgKSApICk7XFxuXFxuXHQjZWxzZVxcblxcblx0XHRyZXR1cm4gYTtcXG5cXG5cdCNlbmRpZlxcblxcbn1cXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2RlZmF1bHRub3JtYWxfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnZGVmYXVsdG5vcm1hbF92ZXJ0ZXgnXSA9IFwiI2lmZGVmIEZMSVBfU0lERURcXG5cXG5cdG9iamVjdE5vcm1hbCA9IC1vYmplY3ROb3JtYWw7XFxuXFxuI2VuZGlmXFxuXFxudmVjMyB0cmFuc2Zvcm1lZE5vcm1hbCA9IG5vcm1hbE1hdHJpeCAqIG9iamVjdE5vcm1hbDtcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2Rpc3BsYWNlbWVudG1hcF92ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdkaXNwbGFjZW1lbnRtYXBfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQXFxuXFxuXHR0cmFuc2Zvcm1lZCArPSBub3JtYWwgKiAoIHRleHR1cmUyRCggZGlzcGxhY2VtZW50TWFwLCB1diApLnggKiBkaXNwbGFjZW1lbnRTY2FsZSArIGRpc3BsYWNlbWVudEJpYXMgKTtcXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2Rpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2Rpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUFxcblxcblx0dW5pZm9ybSBzYW1wbGVyMkQgZGlzcGxhY2VtZW50TWFwO1xcblx0dW5pZm9ybSBmbG9hdCBkaXNwbGFjZW1lbnRTY2FsZTtcXG5cdHVuaWZvcm0gZmxvYXQgZGlzcGxhY2VtZW50QmlhcztcXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2VtaXNzaXZlbWFwX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnZW1pc3NpdmVtYXBfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9FTUlTU0lWRU1BUFxcblxcblx0dmVjNCBlbWlzc2l2ZUNvbG9yID0gdGV4dHVyZTJEKCBlbWlzc2l2ZU1hcCwgdlV2ICk7XFxuXFxuXHRlbWlzc2l2ZUNvbG9yLnJnYiA9IGlucHV0VG9MaW5lYXIoIGVtaXNzaXZlQ29sb3IucmdiICk7XFxuXFxuXHR0b3RhbEVtaXNzaXZlTGlnaHQgKj0gZW1pc3NpdmVDb2xvci5yZ2I7XFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9lbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0VNSVNTSVZFTUFQXFxuXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBlbWlzc2l2ZU1hcDtcXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2Vudm1hcF9mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2Vudm1hcF9mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0VOVk1BUFxcblxcblx0I2lmIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HIClcXG5cXG5cdFx0dmVjMyBjYW1lcmFUb1ZlcnRleCA9IG5vcm1hbGl6ZSggdldvcmxkUG9zaXRpb24gLSBjYW1lcmFQb3NpdGlvbiApO1xcblxcblx0XHR2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggbm9ybWFsLCB2aWV3TWF0cml4ICk7XFxuXFxuXHRcdCNpZmRlZiBFTlZNQVBfTU9ERV9SRUZMRUNUSU9OXFxuXFxuXHRcdFx0dmVjMyByZWZsZWN0VmVjID0gcmVmbGVjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsICk7XFxuXFxuXHRcdCNlbHNlXFxuXFxuXHRcdFx0dmVjMyByZWZsZWN0VmVjID0gcmVmcmFjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsLCByZWZyYWN0aW9uUmF0aW8gKTtcXG5cXG5cdFx0I2VuZGlmXFxuXFxuXHQjZWxzZVxcblxcblx0XHR2ZWMzIHJlZmxlY3RWZWMgPSB2UmVmbGVjdDtcXG5cXG5cdCNlbmRpZlxcblxcblx0I2lmZGVmIERPVUJMRV9TSURFRFxcblx0XHRmbG9hdCBmbGlwTm9ybWFsID0gKCBmbG9hdCggZ2xfRnJvbnRGYWNpbmcgKSAqIDIuMCAtIDEuMCApO1xcblx0I2Vsc2VcXG5cdFx0ZmxvYXQgZmxpcE5vcm1hbCA9IDEuMDtcXG5cdCNlbmRpZlxcblxcblx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcXG5cdFx0dmVjNCBlbnZDb2xvciA9IHRleHR1cmVDdWJlKCBlbnZNYXAsIGZsaXBOb3JtYWwgKiB2ZWMzKCBmbGlwRW52TWFwICogcmVmbGVjdFZlYy54LCByZWZsZWN0VmVjLnl6ICkgKTtcXG5cXG5cdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX0VRVUlSRUMgKVxcblx0XHR2ZWMyIHNhbXBsZVVWO1xcblx0XHRzYW1wbGVVVi55ID0gc2F0dXJhdGUoIGZsaXBOb3JtYWwgKiByZWZsZWN0VmVjLnkgKiAwLjUgKyAwLjUgKTtcXG5cdFx0c2FtcGxlVVYueCA9IGF0YW4oIGZsaXBOb3JtYWwgKiByZWZsZWN0VmVjLnosIGZsaXBOb3JtYWwgKiByZWZsZWN0VmVjLnggKSAqIFJFQ0lQUk9DQUxfUEkyICsgMC41O1xcblx0XHR2ZWM0IGVudkNvbG9yID0gdGV4dHVyZTJEKCBlbnZNYXAsIHNhbXBsZVVWICk7XFxuXFxuXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9TUEhFUkUgKVxcblx0XHR2ZWMzIHJlZmxlY3RWaWV3ID0gZmxpcE5vcm1hbCAqIG5vcm1hbGl6ZSgodmlld01hdHJpeCAqIHZlYzQoIHJlZmxlY3RWZWMsIDAuMCApKS54eXogKyB2ZWMzKDAuMCwwLjAsMS4wKSk7XFxuXHRcdHZlYzQgZW52Q29sb3IgPSB0ZXh0dXJlMkQoIGVudk1hcCwgcmVmbGVjdFZpZXcueHkgKiAwLjUgKyAwLjUgKTtcXG5cdCNlbmRpZlxcblxcblx0ZW52Q29sb3IueHl6ID0gaW5wdXRUb0xpbmVhciggZW52Q29sb3IueHl6ICk7XFxuXFxuXHQjaWZkZWYgRU5WTUFQX0JMRU5ESU5HX01VTFRJUExZXFxuXFxuXHRcdG91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIG91dGdvaW5nTGlnaHQgKiBlbnZDb2xvci54eXosIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHkgKTtcXG5cXG5cdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9CTEVORElOR19NSVggKVxcblxcblx0XHRvdXRnb2luZ0xpZ2h0ID0gbWl4KCBvdXRnb2luZ0xpZ2h0LCBlbnZDb2xvci54eXosIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHkgKTtcXG5cXG5cdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9CTEVORElOR19BREQgKVxcblxcblx0XHRvdXRnb2luZ0xpZ2h0ICs9IGVudkNvbG9yLnh5eiAqIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHk7XFxuXFxuXHQjZW5kaWZcXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2Vudm1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnZW52bWFwX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9FTlZNQVBcXG5cXG5cdHVuaWZvcm0gZmxvYXQgcmVmbGVjdGl2aXR5O1xcblx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcXG5cdFx0dW5pZm9ybSBzYW1wbGVyQ3ViZSBlbnZNYXA7XFxuXHQjZWxzZVxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCBlbnZNYXA7XFxuXHQjZW5kaWZcXG5cdHVuaWZvcm0gZmxvYXQgZmxpcEVudk1hcDtcXG5cXG5cdCNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApXFxuXFxuXHRcdHVuaWZvcm0gZmxvYXQgcmVmcmFjdGlvblJhdGlvO1xcblxcblx0I2Vsc2VcXG5cXG5cdFx0dmFyeWluZyB2ZWMzIHZSZWZsZWN0O1xcblxcblx0I2VuZGlmXFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9lbnZtYXBfcGFyc192ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdlbnZtYXBfcGFyc192ZXJ0ZXgnXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiAhIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgJiYgISBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgJiYgISBkZWZpbmVkKCBQSE9ORyApXFxuXFxuXHR2YXJ5aW5nIHZlYzMgdlJlZmxlY3Q7XFxuXFxuXHR1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2Vudm1hcF92ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdlbnZtYXBfdmVydGV4J10gPSBcIiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgISBkZWZpbmVkKCBVU0VfQlVNUE1BUCApICYmICEgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApICYmICEgZGVmaW5lZCggUEhPTkcgKVxcblxcblx0dmVjMyBjYW1lcmFUb1ZlcnRleCA9IG5vcm1hbGl6ZSggd29ybGRQb3NpdGlvbi54eXogLSBjYW1lcmFQb3NpdGlvbiApO1xcblxcblx0dmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIHRyYW5zZm9ybWVkTm9ybWFsLCB2aWV3TWF0cml4ICk7XFxuXFxuXHQjaWZkZWYgRU5WTUFQX01PREVfUkVGTEVDVElPTlxcblxcblx0XHR2UmVmbGVjdCA9IHJlZmxlY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCApO1xcblxcblx0I2Vsc2VcXG5cXG5cdFx0dlJlZmxlY3QgPSByZWZyYWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1xcblxcblx0I2VuZGlmXFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9mb2dfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdmb2dfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9GT0dcXG5cXG5cdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxuXFxuXHRcdGZsb2F0IGRlcHRoID0gZ2xfRnJhZ0RlcHRoRVhUIC8gZ2xfRnJhZ0Nvb3JkLnc7XFxuXFxuXHQjZWxzZVxcblxcblx0XHRmbG9hdCBkZXB0aCA9IGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLnc7XFxuXFxuXHQjZW5kaWZcXG5cXG5cdCNpZmRlZiBGT0dfRVhQMlxcblxcblx0XHRmbG9hdCBmb2dGYWN0b3IgPSB3aGl0ZUNvbXBsaW1lbnQoIGV4cDIoIC0gZm9nRGVuc2l0eSAqIGZvZ0RlbnNpdHkgKiBkZXB0aCAqIGRlcHRoICogTE9HMiApICk7XFxuXFxuXHQjZWxzZVxcblxcblx0XHRmbG9hdCBmb2dGYWN0b3IgPSBzbW9vdGhzdGVwKCBmb2dOZWFyLCBmb2dGYXIsIGRlcHRoICk7XFxuXFxuXHQjZW5kaWZcXG5cdFxcblx0b3V0Z29pbmdMaWdodCA9IG1peCggb3V0Z29pbmdMaWdodCwgZm9nQ29sb3IsIGZvZ0ZhY3RvciApO1xcblxcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZm9nX3BhcnNfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdmb2dfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0ZPR1xcblxcblx0dW5pZm9ybSB2ZWMzIGZvZ0NvbG9yO1xcblxcblx0I2lmZGVmIEZPR19FWFAyXFxuXFxuXHRcdHVuaWZvcm0gZmxvYXQgZm9nRGVuc2l0eTtcXG5cXG5cdCNlbHNlXFxuXFxuXHRcdHVuaWZvcm0gZmxvYXQgZm9nTmVhcjtcXG5cdFx0dW5pZm9ybSBmbG9hdCBmb2dGYXI7XFxuXHQjZW5kaWZcXG5cXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2hlbWlsaWdodF9mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2hlbWlsaWdodF9mcmFnbWVudCddID0gXCIjaWYgTUFYX0hFTUlfTElHSFRTID4gMFxcblxcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTUFYX0hFTUlfTElHSFRTOyBpICsrICkge1xcblxcblx0XHR2ZWMzIGxpZ2h0RGlyID0gaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uWyBpIF07XFxuXFxuXHRcdGZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKTtcXG5cXG5cdFx0ZmxvYXQgaGVtaURpZmZ1c2VXZWlnaHQgPSAwLjUgKiBkb3RQcm9kdWN0ICsgMC41O1xcblxcblx0XHR2ZWMzIGxpZ2h0Q29sb3IgPSBtaXgoIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBpIF0sIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBpIF0sIGhlbWlEaWZmdXNlV2VpZ2h0ICk7XFxuXFxuXHRcdHRvdGFsQW1iaWVudExpZ2h0ICs9IGxpZ2h0Q29sb3I7XFxuXFxuXHR9XFxuXFxuI2VuZGlmXFxuXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodG1hcF9mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0bWFwX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfTElHSFRNQVBcXG5cXG5cdHRvdGFsQW1iaWVudExpZ2h0ICs9IHRleHR1cmUyRCggbGlnaHRNYXAsIHZVdjIgKS54eXogKiBsaWdodE1hcEludGVuc2l0eTtcXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0bWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodG1hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfTElHSFRNQVBcXG5cXG5cdHVuaWZvcm0gc2FtcGxlcjJEIGxpZ2h0TWFwO1xcblx0dW5pZm9ybSBmbG9hdCBsaWdodE1hcEludGVuc2l0eTtcXG5cXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19sYW1iZXJ0X3BhcnNfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX2xhbWJlcnRfcGFyc192ZXJ0ZXgnXSA9IFwiI2lmIE1BWF9ESVJfTElHSFRTID4gMFxcblxcblx0dW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgTUFYX0RJUl9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uWyBNQVhfRElSX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXFxuXFxuXHR1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3JbIE1BWF9IRU1JX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBNQVhfSEVNSV9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25bIE1BWF9IRU1JX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFxcblxcblx0dW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRDb2xvclsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRQb3NpdGlvblsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBwb2ludExpZ2h0RGlzdGFuY2VbIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gZmxvYXQgcG9pbnRMaWdodERlY2F5WyBNQVhfUE9JTlRfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcXG5cXG5cdHVuaWZvcm0gdmVjMyBzcG90TGlnaHRDb2xvclsgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIHZlYzMgc3BvdExpZ2h0UG9zaXRpb25bIE1BWF9TUE9UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIHNwb3RMaWdodERpcmVjdGlvblsgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHNwb3RMaWdodERpc3RhbmNlWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0QW5nbGVDb3NbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBzcG90TGlnaHRFeHBvbmVudFsgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHNwb3RMaWdodERlY2F5WyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19sYW1iZXJ0X3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0c19sYW1iZXJ0X3ZlcnRleCddID0gXCJ2TGlnaHRGcm9udCA9IHZlYzMoIDAuMCApO1xcblxcbiNpZmRlZiBET1VCTEVfU0lERURcXG5cXG5cdHZMaWdodEJhY2sgPSB2ZWMzKCAwLjAgKTtcXG5cXG4jZW5kaWZcXG5cXG52ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcXG5cXG4jaWYgTUFYX1BPSU5UX0xJR0hUUyA+IDBcXG5cXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE1BWF9QT0lOVF9MSUdIVFM7IGkgKysgKSB7XFxuXFxuXHRcdHZlYzMgbGlnaHRDb2xvciA9IHBvaW50TGlnaHRDb2xvclsgaSBdO1xcblxcblx0XHR2ZWMzIGxWZWN0b3IgPSBwb2ludExpZ2h0UG9zaXRpb25bIGkgXSAtIG12UG9zaXRpb24ueHl6O1xcblx0XHR2ZWMzIGxpZ2h0RGlyID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XFxuXFxuXFxuXHRcdGZsb2F0IGF0dGVudWF0aW9uID0gY2FsY0xpZ2h0QXR0ZW51YXRpb24oIGxlbmd0aCggbFZlY3RvciApLCBwb2ludExpZ2h0RGlzdGFuY2VbIGkgXSwgcG9pbnRMaWdodERlY2F5WyBpIF0gKTtcXG5cXG5cXG5cdFx0ZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggbm9ybWFsLCBsaWdodERpciApO1xcblxcblx0XHR2TGlnaHRGcm9udCArPSBsaWdodENvbG9yICogYXR0ZW51YXRpb24gKiBzYXR1cmF0ZSggZG90UHJvZHVjdCApO1xcblxcblx0XHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXHRcdFx0dkxpZ2h0QmFjayArPSBsaWdodENvbG9yICogYXR0ZW51YXRpb24gKiBzYXR1cmF0ZSggLSBkb3RQcm9kdWN0ICk7XFxuXFxuXHRcdCNlbmRpZlxcblxcblx0fVxcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXFxuXFxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxuXFxuXHRcdHZlYzMgbGlnaHRDb2xvciA9IHNwb3RMaWdodENvbG9yWyBpIF07XFxuXFxuXHRcdHZlYzMgbGlnaHRQb3NpdGlvbiA9IHNwb3RMaWdodFBvc2l0aW9uWyBpIF07XFxuXHRcdHZlYzMgbFZlY3RvciA9IGxpZ2h0UG9zaXRpb24gLSBtdlBvc2l0aW9uLnh5ejtcXG5cdFx0dmVjMyBsaWdodERpciA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcblxcblx0XHRmbG9hdCBzcG90RWZmZWN0ID0gZG90KCBzcG90TGlnaHREaXJlY3Rpb25bIGkgXSwgbGlnaHREaXIgKTtcXG5cXG5cdFx0aWYgKCBzcG90RWZmZWN0ID4gc3BvdExpZ2h0QW5nbGVDb3NbIGkgXSApIHtcXG5cXG5cdFx0XHRzcG90RWZmZWN0ID0gc2F0dXJhdGUoIHBvdyggc2F0dXJhdGUoIHNwb3RFZmZlY3QgKSwgc3BvdExpZ2h0RXhwb25lbnRbIGkgXSApICk7XFxuXFxuXFxuXHRcdFx0ZmxvYXQgYXR0ZW51YXRpb24gPSBjYWxjTGlnaHRBdHRlbnVhdGlvbiggbGVuZ3RoKCBsVmVjdG9yICksIHNwb3RMaWdodERpc3RhbmNlWyBpIF0sIHNwb3RMaWdodERlY2F5WyBpIF0gKTtcXG5cXG5cdFx0XHRhdHRlbnVhdGlvbiAqPSBzcG90RWZmZWN0O1xcblxcblxcblx0XHRcdGZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKTtcXG5cXG5cdFx0XHR2TGlnaHRGcm9udCArPSBsaWdodENvbG9yICogYXR0ZW51YXRpb24gKiBzYXR1cmF0ZSggZG90UHJvZHVjdCApO1xcblxcblx0XHRcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXG5cdFx0XHRcdHZMaWdodEJhY2sgKz0gbGlnaHRDb2xvciAqIGF0dGVudWF0aW9uICogc2F0dXJhdGUoIC0gZG90UHJvZHVjdCApO1xcblxcblx0XHRcdCNlbmRpZlxcblxcblx0XHR9XFxuXFxuXHR9XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9ESVJfTElHSFRTID4gMFxcblxcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTUFYX0RJUl9MSUdIVFM7IGkgKysgKSB7XFxuXFxuXHRcdHZlYzMgbGlnaHRDb2xvciA9IGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgaSBdO1xcblxcblx0XHR2ZWMzIGxpZ2h0RGlyID0gZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblsgaSBdO1xcblxcblxcblx0XHRmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCBub3JtYWwsIGxpZ2h0RGlyICk7XFxuXFxuXHRcdHZMaWdodEZyb250ICs9IGxpZ2h0Q29sb3IgKiBzYXR1cmF0ZSggZG90UHJvZHVjdCApO1xcblxcblx0XHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXHRcdFx0dkxpZ2h0QmFjayArPSBsaWdodENvbG9yICogc2F0dXJhdGUoIC0gZG90UHJvZHVjdCApO1xcblxcblx0XHQjZW5kaWZcXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX0hFTUlfTElHSFRTID4gMFxcblxcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTUFYX0hFTUlfTElHSFRTOyBpICsrICkge1xcblxcblx0XHR2ZWMzIGxpZ2h0RGlyID0gaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uWyBpIF07XFxuXFxuXFxuXHRcdGZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKTtcXG5cXG5cdFx0ZmxvYXQgaGVtaURpZmZ1c2VXZWlnaHQgPSAwLjUgKiBkb3RQcm9kdWN0ICsgMC41O1xcblxcblx0XHR2TGlnaHRGcm9udCArPSBtaXgoIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBpIF0sIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBpIF0sIGhlbWlEaWZmdXNlV2VpZ2h0ICk7XFxuXFxuXHRcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXG5cdFx0XHRmbG9hdCBoZW1pRGlmZnVzZVdlaWdodEJhY2sgPSAtIDAuNSAqIGRvdFByb2R1Y3QgKyAwLjU7XFxuXFxuXHRcdFx0dkxpZ2h0QmFjayArPSBtaXgoIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBpIF0sIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBpIF0sIGhlbWlEaWZmdXNlV2VpZ2h0QmFjayApO1xcblxcblx0XHQjZW5kaWZcXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19waG9uZ19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0c19waG9uZ19mcmFnbWVudCddID0gXCJ2ZWMzIHZpZXdEaXIgPSBub3JtYWxpemUoIHZWaWV3UG9zaXRpb24gKTtcXG5cXG52ZWMzIHRvdGFsRGlmZnVzZUxpZ2h0ID0gdmVjMyggMC4wICk7XFxudmVjMyB0b3RhbFNwZWN1bGFyTGlnaHQgPSB2ZWMzKCAwLjAgKTtcXG5cXG4jaWYgTUFYX1BPSU5UX0xJR0hUUyA+IDBcXG5cXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE1BWF9QT0lOVF9MSUdIVFM7IGkgKysgKSB7XFxuXFxuXHRcdHZlYzMgbGlnaHRDb2xvciA9IHBvaW50TGlnaHRDb2xvclsgaSBdO1xcblxcblx0XHR2ZWMzIGxpZ2h0UG9zaXRpb24gPSBwb2ludExpZ2h0UG9zaXRpb25bIGkgXTtcXG5cdFx0dmVjMyBsVmVjdG9yID0gbGlnaHRQb3NpdGlvbiArIHZWaWV3UG9zaXRpb24ueHl6O1xcblx0XHR2ZWMzIGxpZ2h0RGlyID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XFxuXFxuXFxuXHRcdGZsb2F0IGF0dGVudWF0aW9uID0gY2FsY0xpZ2h0QXR0ZW51YXRpb24oIGxlbmd0aCggbFZlY3RvciApLCBwb2ludExpZ2h0RGlzdGFuY2VbIGkgXSwgcG9pbnRMaWdodERlY2F5WyBpIF0gKTtcXG5cXG5cXG5cdFx0ZmxvYXQgY29zaW5lVGVybSA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKSApO1xcblxcblx0XHR0b3RhbERpZmZ1c2VMaWdodCArPSBsaWdodENvbG9yICogYXR0ZW51YXRpb24gKiBjb3NpbmVUZXJtO1xcblxcblxcblx0XHR2ZWMzIGJyZGYgPSBCUkRGX0JsaW5uUGhvbmcoIHNwZWN1bGFyLCBzaGluaW5lc3MsIG5vcm1hbCwgbGlnaHREaXIsIHZpZXdEaXIgKTtcXG5cXG5cdFx0dG90YWxTcGVjdWxhckxpZ2h0ICs9IGJyZGYgKiBzcGVjdWxhclN0cmVuZ3RoICogbGlnaHRDb2xvciAqIGF0dGVudWF0aW9uICogY29zaW5lVGVybTtcXG5cXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX1NQT1RfTElHSFRTID4gMFxcblxcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTUFYX1NQT1RfTElHSFRTOyBpICsrICkge1xcblxcblx0XHR2ZWMzIGxpZ2h0Q29sb3IgPSBzcG90TGlnaHRDb2xvclsgaSBdO1xcblxcblx0XHR2ZWMzIGxpZ2h0UG9zaXRpb24gPSBzcG90TGlnaHRQb3NpdGlvblsgaSBdO1xcblx0XHR2ZWMzIGxWZWN0b3IgPSBsaWdodFBvc2l0aW9uICsgdlZpZXdQb3NpdGlvbi54eXo7XFxuXHRcdHZlYzMgbGlnaHREaXIgPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcXG5cXG5cdFx0ZmxvYXQgc3BvdEVmZmVjdCA9IGRvdCggc3BvdExpZ2h0RGlyZWN0aW9uWyBpIF0sIGxpZ2h0RGlyICk7XFxuXFxuXHRcdGlmICggc3BvdEVmZmVjdCA+IHNwb3RMaWdodEFuZ2xlQ29zWyBpIF0gKSB7XFxuXFxuXHRcdFx0c3BvdEVmZmVjdCA9IHNhdHVyYXRlKCBwb3coIHNhdHVyYXRlKCBzcG90RWZmZWN0ICksIHNwb3RMaWdodEV4cG9uZW50WyBpIF0gKSApO1xcblxcblxcblx0XHRcdGZsb2F0IGF0dGVudWF0aW9uID0gY2FsY0xpZ2h0QXR0ZW51YXRpb24oIGxlbmd0aCggbFZlY3RvciApLCBzcG90TGlnaHREaXN0YW5jZVsgaSBdLCBzcG90TGlnaHREZWNheVsgaSBdICk7XFxuXFxuXHRcdFx0YXR0ZW51YXRpb24gKj0gc3BvdEVmZmVjdDtcXG5cXG5cXG5cdFx0XHRmbG9hdCBjb3NpbmVUZXJtID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBsaWdodERpciApICk7XFxuXFxuXHRcdFx0dG90YWxEaWZmdXNlTGlnaHQgKz0gbGlnaHRDb2xvciAqIGF0dGVudWF0aW9uICogY29zaW5lVGVybTtcXG5cXG5cXG5cdFx0XHR2ZWMzIGJyZGYgPSBCUkRGX0JsaW5uUGhvbmcoIHNwZWN1bGFyLCBzaGluaW5lc3MsIG5vcm1hbCwgbGlnaHREaXIsIHZpZXdEaXIgKTtcXG5cXG5cdFx0XHR0b3RhbFNwZWN1bGFyTGlnaHQgKz0gYnJkZiAqIHNwZWN1bGFyU3RyZW5ndGggKiBsaWdodENvbG9yICogYXR0ZW51YXRpb24gKiBjb3NpbmVUZXJtO1xcblxcblx0XHR9XFxuXFxuXHR9XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9ESVJfTElHSFRTID4gMFxcblxcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTUFYX0RJUl9MSUdIVFM7IGkgKysgKSB7XFxuXFxuXHRcdHZlYzMgbGlnaHRDb2xvciA9IGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgaSBdO1xcblxcblx0XHR2ZWMzIGxpZ2h0RGlyID0gZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblsgaSBdO1xcblxcblxcblx0XHRmbG9hdCBjb3NpbmVUZXJtID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBsaWdodERpciApICk7XFxuXFxuXHRcdHRvdGFsRGlmZnVzZUxpZ2h0ICs9IGxpZ2h0Q29sb3IgKiBjb3NpbmVUZXJtO1xcblxcblxcblx0XHR2ZWMzIGJyZGYgPSBCUkRGX0JsaW5uUGhvbmcoIHNwZWN1bGFyLCBzaGluaW5lc3MsIG5vcm1hbCwgbGlnaHREaXIsIHZpZXdEaXIgKTtcXG5cXG5cdFx0dG90YWxTcGVjdWxhckxpZ2h0ICs9IGJyZGYgKiBzcGVjdWxhclN0cmVuZ3RoICogbGlnaHRDb2xvciAqIGNvc2luZVRlcm07XFxuXFxuXHR9XFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodHNfcGhvbmdfcGFyc19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50J10gPSBcInVuaWZvcm0gdmVjMyBhbWJpZW50TGlnaHRDb2xvcjtcXG5cXG4jaWYgTUFYX0RJUl9MSUdIVFMgPiAwXFxuXFxuXHR1bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodENvbG9yWyBNQVhfRElSX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIE1BWF9ESVJfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9IRU1JX0xJR0hUUyA+IDBcXG5cXG5cdHVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgTUFYX0hFTUlfTElHSFRTIF07XFxuXHR1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JbIE1BWF9IRU1JX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodERpcmVjdGlvblsgTUFYX0hFTUlfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXFxuXFxuXHR1bmlmb3JtIHZlYzMgcG9pbnRMaWdodENvbG9yWyBNQVhfUE9JTlRfTElHSFRTIF07XFxuXFxuXHR1bmlmb3JtIHZlYzMgcG9pbnRMaWdodFBvc2l0aW9uWyBNQVhfUE9JTlRfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHBvaW50TGlnaHREaXN0YW5jZVsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBwb2ludExpZ2h0RGVjYXlbIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX1NQT1RfTElHSFRTID4gMFxcblxcblx0dW5pZm9ybSB2ZWMzIHNwb3RMaWdodENvbG9yWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gdmVjMyBzcG90TGlnaHRQb3NpdGlvblsgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIHZlYzMgc3BvdExpZ2h0RGlyZWN0aW9uWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0QW5nbGVDb3NbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBzcG90TGlnaHRFeHBvbmVudFsgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHNwb3RMaWdodERpc3RhbmNlWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RGVjYXlbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwIHx8IGRlZmluZWQoIFVTRV9FTlZNQVAgKVxcblxcblx0dmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcblxcbiNlbmRpZlxcblxcbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcblxcbiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXG5cdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX3Bob25nX3BhcnNfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX3Bob25nX3BhcnNfdmVydGV4J10gPSBcIiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwIHx8IGRlZmluZWQoIFVTRV9FTlZNQVAgKVxcblxcblx0dmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFxcblxcblx0dW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRQb3NpdGlvblsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX3Bob25nX3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0c19waG9uZ192ZXJ0ZXgnXSA9IFwiI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDAgfHwgZGVmaW5lZCggVVNFX0VOVk1BUCApXFxuXFxuXHR2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6O1xcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50J10gPSBcIlxcblx0b3V0Z29pbmdMaWdodCA9IGxpbmVhclRvT3V0cHV0KCBvdXRnb2luZ0xpZ2h0ICk7XFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9sb2dkZXB0aGJ1Zl9mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xvZ2RlcHRoYnVmX2ZyYWdtZW50J10gPSBcIiNpZiBkZWZpbmVkKFVTRV9MT0dERVBUSEJVRikgJiYgZGVmaW5lZChVU0VfTE9HREVQVEhCVUZfRVhUKVxcblxcblx0Z2xfRnJhZ0RlcHRoRVhUID0gbG9nMih2RnJhZ0RlcHRoKSAqIGxvZ0RlcHRoQnVmRkMgKiAwLjU7XFxuXFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9sb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbG9nZGVwdGhidWZfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxuXFxuXHR1bmlmb3JtIGZsb2F0IGxvZ0RlcHRoQnVmRkM7XFxuXFxuXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFxcblxcblx0XHR2YXJ5aW5nIGZsb2F0IHZGcmFnRGVwdGg7XFxuXFxuXHQjZW5kaWZcXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xvZ2RlcHRoYnVmX3BhcnNfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbG9nZGVwdGhidWZfcGFyc192ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9MT0dERVBUSEJVRlxcblxcblx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cXG5cdFx0dmFyeWluZyBmbG9hdCB2RnJhZ0RlcHRoO1xcblxcblx0I2VuZGlmXFxuXFxuXHR1bmlmb3JtIGZsb2F0IGxvZ0RlcHRoQnVmRkM7XFxuXFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9sb2dkZXB0aGJ1Zl92ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsb2dkZXB0aGJ1Zl92ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9MT0dERVBUSEJVRlxcblxcblx0Z2xfUG9zaXRpb24ueiA9IGxvZzIobWF4KCBFUFNJTE9OLCBnbF9Qb3NpdGlvbi53ICsgMS4wICkpICogbG9nRGVwdGhCdWZGQztcXG5cXG5cdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxuXFxuXHRcdHZGcmFnRGVwdGggPSAxLjAgKyBnbF9Qb3NpdGlvbi53O1xcblxcbiNlbHNlXFxuXFxuXHRcdGdsX1Bvc2l0aW9uLnogPSAoZ2xfUG9zaXRpb24ueiAtIDEuMCkgKiBnbF9Qb3NpdGlvbi53O1xcblxcblx0I2VuZGlmXFxuXFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tYXBfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtYXBfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9NQVBcXG5cXG5cdHZlYzQgdGV4ZWxDb2xvciA9IHRleHR1cmUyRCggbWFwLCB2VXYgKTtcXG5cXG5cdHRleGVsQ29sb3IueHl6ID0gaW5wdXRUb0xpbmVhciggdGV4ZWxDb2xvci54eXogKTtcXG5cXG5cdGRpZmZ1c2VDb2xvciAqPSB0ZXhlbENvbG9yO1xcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtYXBfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX01BUFxcblxcblx0dW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xcblxcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbWFwX3BhcnRpY2xlX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbWFwX3BhcnRpY2xlX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfTUFQXFxuXFxuXHRkaWZmdXNlQ29sb3IgKj0gdGV4dHVyZTJEKCBtYXAsIHZlYzIoIGdsX1BvaW50Q29vcmQueCwgMS4wIC0gZ2xfUG9pbnRDb29yZC55ICkgKiBvZmZzZXRSZXBlYXQuencgKyBvZmZzZXRSZXBlYXQueHkgKTtcXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9NQVBcXG5cXG5cdHVuaWZvcm0gdmVjNCBvZmZzZXRSZXBlYXQ7XFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tb3JwaG5vcm1hbF92ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtb3JwaG5vcm1hbF92ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9NT1JQSE5PUk1BTFNcXG5cXG5cdG9iamVjdE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMCAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAwIF07XFxuXHRvYmplY3ROb3JtYWwgKz0gKCBtb3JwaE5vcm1hbDEgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMSBdO1xcblx0b2JqZWN0Tm9ybWFsICs9ICggbW9ycGhOb3JtYWwyIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDIgXTtcXG5cdG9iamVjdE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMyAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAzIF07XFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tb3JwaHRhcmdldF9wYXJzX3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ21vcnBodGFyZ2V0X3BhcnNfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTXFxuXFxuXHQjaWZuZGVmIFVTRV9NT1JQSE5PUk1BTFNcXG5cXG5cdHVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA4IF07XFxuXFxuXHQjZWxzZVxcblxcblx0dW5pZm9ybSBmbG9hdCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDQgXTtcXG5cXG5cdCNlbmRpZlxcblxcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbW9ycGh0YXJnZXRfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbW9ycGh0YXJnZXRfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTXFxuXFxuXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0MCAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDAgXTtcXG5cdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQxIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMSBdO1xcblx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDIgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAyIF07XFxuXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0MyAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDMgXTtcXG5cXG5cdCNpZm5kZWYgVVNFX01PUlBITk9STUFMU1xcblxcblx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDQgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA0IF07XFxuXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0NSAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDUgXTtcXG5cdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ2IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNiBdO1xcblx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDcgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA3IF07XFxuXFxuXHQjZW5kaWZcXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL25vcm1hbF9waG9uZ19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ25vcm1hbF9waG9uZ19mcmFnbWVudCddID0gXCIjaWZuZGVmIEZMQVRfU0hBREVEXFxuXFxuXHR2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggdk5vcm1hbCApO1xcblxcblx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcblx0XHRub3JtYWwgPSBub3JtYWwgKiAoIC0xLjAgKyAyLjAgKiBmbG9hdCggZ2xfRnJvbnRGYWNpbmcgKSApO1xcblxcblx0I2VuZGlmXFxuXFxuI2Vsc2VcXG5cXG5cdHZlYzMgZmR4ID0gZEZkeCggdlZpZXdQb3NpdGlvbiApO1xcblx0dmVjMyBmZHkgPSBkRmR5KCB2Vmlld1Bvc2l0aW9uICk7XFxuXHR2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggY3Jvc3MoIGZkeCwgZmR5ICkgKTtcXG5cXG4jZW5kaWZcXG5cXG4jaWZkZWYgVVNFX05PUk1BTE1BUFxcblxcblx0bm9ybWFsID0gcGVydHVyYk5vcm1hbDJBcmIoIC12Vmlld1Bvc2l0aW9uLCBub3JtYWwgKTtcXG5cXG4jZWxpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApXFxuXFxuXHRub3JtYWwgPSBwZXJ0dXJiTm9ybWFsQXJiKCAtdlZpZXdQb3NpdGlvbiwgbm9ybWFsLCBkSGR4eV9md2QoKSApO1xcblxcbiNlbmRpZlxcblxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdub3JtYWxtYXBfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX05PUk1BTE1BUFxcblxcblx0dW5pZm9ybSBzYW1wbGVyMkQgbm9ybWFsTWFwO1xcblx0dW5pZm9ybSB2ZWMyIG5vcm1hbFNjYWxlO1xcblxcblxcblx0dmVjMyBwZXJ0dXJiTm9ybWFsMkFyYiggdmVjMyBleWVfcG9zLCB2ZWMzIHN1cmZfbm9ybSApIHtcXG5cXG5cdFx0dmVjMyBxMCA9IGRGZHgoIGV5ZV9wb3MueHl6ICk7XFxuXHRcdHZlYzMgcTEgPSBkRmR5KCBleWVfcG9zLnh5eiApO1xcblx0XHR2ZWMyIHN0MCA9IGRGZHgoIHZVdi5zdCApO1xcblx0XHR2ZWMyIHN0MSA9IGRGZHkoIHZVdi5zdCApO1xcblxcblx0XHR2ZWMzIFMgPSBub3JtYWxpemUoIHEwICogc3QxLnQgLSBxMSAqIHN0MC50ICk7XFxuXHRcdHZlYzMgVCA9IG5vcm1hbGl6ZSggLXEwICogc3QxLnMgKyBxMSAqIHN0MC5zICk7XFxuXHRcdHZlYzMgTiA9IG5vcm1hbGl6ZSggc3VyZl9ub3JtICk7XFxuXFxuXHRcdHZlYzMgbWFwTiA9IHRleHR1cmUyRCggbm9ybWFsTWFwLCB2VXYgKS54eXogKiAyLjAgLSAxLjA7XFxuXHRcdG1hcE4ueHkgPSBub3JtYWxTY2FsZSAqIG1hcE4ueHk7XFxuXHRcdG1hdDMgdHNuID0gbWF0MyggUywgVCwgTiApO1xcblx0XHRyZXR1cm4gbm9ybWFsaXplKCB0c24gKiBtYXBOICk7XFxuXFxuXHR9XFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9wcm9qZWN0X3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ3Byb2plY3RfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXG5cdHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHNraW5uZWQ7XFxuXFxuI2Vsc2VcXG5cXG5cdHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHRyYW5zZm9ybWVkLCAxLjAgKTtcXG5cXG4jZW5kaWZcXG5cXG5nbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1xcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2hhZG93bWFwX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnc2hhZG93bWFwX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfU0hBRE9XUzsgaSArKyApIHtcXG5cXG5cdFx0ZmxvYXQgdGV4ZWxTaXplWSA9ICAxLjAgLyBzaGFkb3dNYXBTaXplWyBpIF0ueTtcXG5cXG5cdFx0ZmxvYXQgc2hhZG93ID0gMC4wO1xcblxcbiNpZiBkZWZpbmVkKCBQT0lOVF9MSUdIVF9TSEFET1dTIClcXG5cXG5cdFx0Ym9vbCBpc1BvaW50TGlnaHQgPSBzaGFkb3dEYXJrbmVzc1sgaSBdIDwgMC4wO1xcblxcblx0XHRpZiAoIGlzUG9pbnRMaWdodCApIHtcXG5cXG5cdFx0XHRmbG9hdCByZWFsU2hhZG93RGFya25lc3MgPSBhYnMoIHNoYWRvd0RhcmtuZXNzWyBpIF0gKTtcXG5cXG5cdFx0XHR2ZWMzIGxpZ2h0VG9Qb3NpdGlvbiA9IHZTaGFkb3dDb29yZFsgaSBdLnh5ejtcXG5cXG5cdCNpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0YgKSB8fCBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVCApXFxuXFxuXHRcdFx0dmVjMyBiZDNEID0gbm9ybWFsaXplKCBsaWdodFRvUG9zaXRpb24gKTtcXG5cdFx0XHRmbG9hdCBkcCA9IGxlbmd0aCggbGlnaHRUb1Bvc2l0aW9uICk7XFxuXFxuXHRcdFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNELCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cXG5cXG5cdCNpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0YgKVxcblx0XHRcdGNvbnN0IGZsb2F0IERyID0gMS4yNTtcXG5cdCNlbGlmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRl9TT0ZUIClcXG5cdFx0XHRjb25zdCBmbG9hdCBEciA9IDIuMjU7XFxuXHQjZW5kaWZcXG5cXG5cdFx0XHRmbG9hdCBvcyA9IERyICogIDIuMCAqIHRleGVsU2l6ZVk7XFxuXFxuXHRcdFx0Y29uc3QgdmVjMyBHc2QgPSB2ZWMzKCAtIDEsIDAsIDEgKTtcXG5cXG5cdFx0XHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QgKyBHc2Quenp6ICogb3MsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblx0XHRcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC56eHogKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXHRcdFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNEICsgR3NkLnh4eiAqIG9zLCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cdFx0XHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QgKyBHc2QueHp6ICogb3MsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblx0XHRcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC56enggKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXHRcdFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNEICsgR3NkLnp4eCAqIG9zLCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cdFx0XHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QgKyBHc2QueHh4ICogb3MsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblx0XHRcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC54enggKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXHRcdFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNEICsgR3NkLnp6eSAqIG9zLCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cdFx0XHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QgKyBHc2Quenh5ICogb3MsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblxcblx0XHRcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC54eHkgKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXHRcdFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNEICsgR3NkLnh6eSAqIG9zLCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cdFx0XHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QgKyBHc2Quenl6ICogb3MsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblx0XHRcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC54eXogKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXHRcdFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNEICsgR3NkLnp5eCAqIG9zLCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cdFx0XHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QgKyBHc2QueHl4ICogb3MsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblx0XHRcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC55enogKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXHRcdFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNEICsgR3NkLnl4eiAqIG9zLCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cdFx0XHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QgKyBHc2QueXh4ICogb3MsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblx0XHRcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC55enggKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXFxuXHRcdFx0c2hhZG93ICo9IHJlYWxTaGFkb3dEYXJrbmVzcyAqICggMS4wIC8gMjEuMCApO1xcblxcblx0I2Vsc2UgXFxuXHRcdFx0dmVjMyBiZDNEID0gbm9ybWFsaXplKCBsaWdodFRvUG9zaXRpb24gKTtcXG5cdFx0XHRmbG9hdCBkcCA9IGxlbmd0aCggbGlnaHRUb1Bvc2l0aW9uICk7XFxuXFxuXHRcdFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNELCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cXG5cdFx0XHRzaGFkb3cgKj0gcmVhbFNoYWRvd0RhcmtuZXNzO1xcblxcblx0I2VuZGlmXFxuXFxuXHRcdH0gZWxzZSB7XFxuXFxuI2VuZGlmIFxcblx0XHRcdGZsb2F0IHRleGVsU2l6ZVggPSAgMS4wIC8gc2hhZG93TWFwU2l6ZVsgaSBdLng7XFxuXFxuXHRcdFx0dmVjMyBzaGFkb3dDb29yZCA9IHZTaGFkb3dDb29yZFsgaSBdLnh5eiAvIHZTaGFkb3dDb29yZFsgaSBdLnc7XFxuXFxuXFxuXHRcdFx0YnZlYzQgaW5GcnVzdHVtVmVjID0gYnZlYzQgKCBzaGFkb3dDb29yZC54ID49IDAuMCwgc2hhZG93Q29vcmQueCA8PSAxLjAsIHNoYWRvd0Nvb3JkLnkgPj0gMC4wLCBzaGFkb3dDb29yZC55IDw9IDEuMCApO1xcblx0XHRcdGJvb2wgaW5GcnVzdHVtID0gYWxsKCBpbkZydXN0dW1WZWMgKTtcXG5cXG5cdFx0XHRidmVjMiBmcnVzdHVtVGVzdFZlYyA9IGJ2ZWMyKCBpbkZydXN0dW0sIHNoYWRvd0Nvb3JkLnogPD0gMS4wICk7XFxuXFxuXHRcdFx0Ym9vbCBmcnVzdHVtVGVzdCA9IGFsbCggZnJ1c3R1bVRlc3RWZWMgKTtcXG5cXG5cdFx0XHRpZiAoIGZydXN0dW1UZXN0ICkge1xcblxcblx0I2lmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRiApXFxuXFxuXFxuXHRcdFx0XHQvKlxcblx0XHRcdFx0XHRmb3IgKCBmbG9hdCB5ID0gLTEuMjU7IHkgPD0gMS4yNTsgeSArPSAxLjI1IClcXG5cdFx0XHRcdFx0XHRmb3IgKCBmbG9hdCB4ID0gLTEuMjU7IHggPD0gMS4yNTsgeCArPSAxLjI1ICkge1xcblx0XHRcdFx0XHRcdFx0dmVjNCByZ2JhRGVwdGggPSB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCB2ZWMyKCB4ICogeFBpeGVsT2Zmc2V0LCB5ICogeVBpeGVsT2Zmc2V0ICkgKyBzaGFkb3dDb29yZC54eSApO1xcblx0XHRcdFx0XHRcdFx0ZmxvYXQgZkRlcHRoID0gdW5wYWNrRGVwdGgoIHJnYmFEZXB0aCApO1xcblx0XHRcdFx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56IClcXG5cdFx0XHRcdFx0XHRcdFx0c2hhZG93ICs9IDEuMDtcXG5cdFx0XHRcdFx0fVxcblx0XHRcdFx0XHRzaGFkb3cgLz0gOS4wO1xcblx0XHRcdFx0Ki9cXG5cXG5cdFx0XHRcdHNoYWRvd0Nvb3JkLnogKz0gc2hhZG93Qmlhc1sgaSBdO1xcblxcblx0XHRcdFx0Y29uc3QgZmxvYXQgU2hhZG93RGVsdGEgPSAxLjAgLyA5LjA7XFxuXFxuXHRcdFx0XHRmbG9hdCB4UGl4ZWxPZmZzZXQgPSB0ZXhlbFNpemVYO1xcblx0XHRcdFx0ZmxvYXQgeVBpeGVsT2Zmc2V0ID0gdGV4ZWxTaXplWTtcXG5cXG5cdFx0XHRcdGZsb2F0IGR4MCA9IC0gMS4yNSAqIHhQaXhlbE9mZnNldDtcXG5cdFx0XHRcdGZsb2F0IGR5MCA9IC0gMS4yNSAqIHlQaXhlbE9mZnNldDtcXG5cdFx0XHRcdGZsb2F0IGR4MSA9IDEuMjUgKiB4UGl4ZWxPZmZzZXQ7XFxuXHRcdFx0XHRmbG9hdCBkeTEgPSAxLjI1ICogeVBpeGVsT2Zmc2V0O1xcblxcblx0XHRcdFx0ZmxvYXQgZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTAgKSApICk7XFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gU2hhZG93RGVsdGE7XFxuXFxuXHRcdFx0XHRmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MCApICkgKTtcXG5cdFx0XHRcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBTaGFkb3dEZWx0YTtcXG5cXG5cdFx0XHRcdGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkwICkgKSApO1xcblx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IFNoYWRvd0RlbHRhO1xcblxcblx0XHRcdFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCAwLjAgKSApICk7XFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gU2hhZG93RGVsdGE7XFxuXFxuXHRcdFx0XHRmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKSApO1xcblx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IFNoYWRvd0RlbHRhO1xcblxcblx0XHRcdFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCAwLjAgKSApICk7XFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gU2hhZG93RGVsdGE7XFxuXFxuXHRcdFx0XHRmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MSApICkgKTtcXG5cdFx0XHRcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBTaGFkb3dEZWx0YTtcXG5cXG5cdFx0XHRcdGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkxICkgKSApO1xcblx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IFNoYWRvd0RlbHRhO1xcblxcblx0XHRcdFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTEgKSApICk7XFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gU2hhZG93RGVsdGE7XFxuXFxuXHRcdFx0XHRzaGFkb3cgKj0gc2hhZG93RGFya25lc3NbIGkgXTtcXG5cXG5cdCNlbGlmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRl9TT0ZUIClcXG5cXG5cXG5cdFx0XHRcdHNoYWRvd0Nvb3JkLnogKz0gc2hhZG93Qmlhc1sgaSBdO1xcblxcblx0XHRcdFx0ZmxvYXQgeFBpeGVsT2Zmc2V0ID0gdGV4ZWxTaXplWDtcXG5cdFx0XHRcdGZsb2F0IHlQaXhlbE9mZnNldCA9IHRleGVsU2l6ZVk7XFxuXFxuXHRcdFx0XHRmbG9hdCBkeDAgPSAtIDEuMCAqIHhQaXhlbE9mZnNldDtcXG5cdFx0XHRcdGZsb2F0IGR5MCA9IC0gMS4wICogeVBpeGVsT2Zmc2V0O1xcblx0XHRcdFx0ZmxvYXQgZHgxID0gMS4wICogeFBpeGVsT2Zmc2V0O1xcblx0XHRcdFx0ZmxvYXQgZHkxID0gMS4wICogeVBpeGVsT2Zmc2V0O1xcblxcblx0XHRcdFx0bWF0MyBzaGFkb3dLZXJuZWw7XFxuXHRcdFx0XHRtYXQzIGRlcHRoS2VybmVsO1xcblxcblx0XHRcdFx0ZGVwdGhLZXJuZWxbIDAgXVsgMCBdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTAgKSApICk7XFxuXHRcdFx0XHRkZXB0aEtlcm5lbFsgMCBdWyAxIF0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIDAuMCApICkgKTtcXG5cdFx0XHRcdGRlcHRoS2VybmVsWyAwIF1bIDIgXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkxICkgKSApO1xcblx0XHRcdFx0ZGVwdGhLZXJuZWxbIDEgXVsgMCBdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTAgKSApICk7XFxuXHRcdFx0XHRkZXB0aEtlcm5lbFsgMSBdWyAxIF0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKSApO1xcblx0XHRcdFx0ZGVwdGhLZXJuZWxbIDEgXVsgMiBdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTEgKSApICk7XFxuXHRcdFx0XHRkZXB0aEtlcm5lbFsgMiBdWyAwIF0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MCApICkgKTtcXG5cdFx0XHRcdGRlcHRoS2VybmVsWyAyIF1bIDEgXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgMC4wICkgKSApO1xcblx0XHRcdFx0ZGVwdGhLZXJuZWxbIDIgXVsgMiBdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTEgKSApICk7XFxuXFxuXHRcdFx0XHR2ZWMzIHNoYWRvd1ogPSB2ZWMzKCBzaGFkb3dDb29yZC56ICk7XFxuXHRcdFx0XHRzaGFkb3dLZXJuZWxbIDAgXSA9IHZlYzMoIGxlc3NUaGFuKCBkZXB0aEtlcm5lbFsgMCBdLCBzaGFkb3daICkgKTtcXG5cdFx0XHRcdHNoYWRvd0tlcm5lbFsgMCBdICo9IHZlYzMoIDAuMjUgKTtcXG5cXG5cdFx0XHRcdHNoYWRvd0tlcm5lbFsgMSBdID0gdmVjMyggbGVzc1RoYW4oIGRlcHRoS2VybmVsWyAxIF0sIHNoYWRvd1ogKSApO1xcblx0XHRcdFx0c2hhZG93S2VybmVsWyAxIF0gKj0gdmVjMyggMC4yNSApO1xcblxcblx0XHRcdFx0c2hhZG93S2VybmVsWyAyIF0gPSB2ZWMzKCBsZXNzVGhhbiggZGVwdGhLZXJuZWxbIDIgXSwgc2hhZG93WiApICk7XFxuXHRcdFx0XHRzaGFkb3dLZXJuZWxbIDIgXSAqPSB2ZWMzKCAwLjI1ICk7XFxuXFxuXHRcdFx0XHR2ZWMyIGZyYWN0aW9uYWxDb29yZCA9IDEuMCAtIGZyYWN0KCBzaGFkb3dDb29yZC54eSAqIHNoYWRvd01hcFNpemVbIGkgXS54eSApO1xcblxcblx0XHRcdFx0c2hhZG93S2VybmVsWyAwIF0gPSBtaXgoIHNoYWRvd0tlcm5lbFsgMSBdLCBzaGFkb3dLZXJuZWxbIDAgXSwgZnJhY3Rpb25hbENvb3JkLnggKTtcXG5cdFx0XHRcdHNoYWRvd0tlcm5lbFsgMSBdID0gbWl4KCBzaGFkb3dLZXJuZWxbIDIgXSwgc2hhZG93S2VybmVsWyAxIF0sIGZyYWN0aW9uYWxDb29yZC54ICk7XFxuXFxuXHRcdFx0XHR2ZWM0IHNoYWRvd1ZhbHVlcztcXG5cdFx0XHRcdHNoYWRvd1ZhbHVlcy54ID0gbWl4KCBzaGFkb3dLZXJuZWxbIDAgXVsgMSBdLCBzaGFkb3dLZXJuZWxbIDAgXVsgMCBdLCBmcmFjdGlvbmFsQ29vcmQueSApO1xcblx0XHRcdFx0c2hhZG93VmFsdWVzLnkgPSBtaXgoIHNoYWRvd0tlcm5lbFsgMCBdWyAyIF0sIHNoYWRvd0tlcm5lbFsgMCBdWyAxIF0sIGZyYWN0aW9uYWxDb29yZC55ICk7XFxuXHRcdFx0XHRzaGFkb3dWYWx1ZXMueiA9IG1peCggc2hhZG93S2VybmVsWyAxIF1bIDEgXSwgc2hhZG93S2VybmVsWyAxIF1bIDAgXSwgZnJhY3Rpb25hbENvb3JkLnkgKTtcXG5cdFx0XHRcdHNoYWRvd1ZhbHVlcy53ID0gbWl4KCBzaGFkb3dLZXJuZWxbIDEgXVsgMiBdLCBzaGFkb3dLZXJuZWxbIDEgXVsgMSBdLCBmcmFjdGlvbmFsQ29vcmQueSApO1xcblxcblx0XHRcdFx0c2hhZG93ID0gZG90KCBzaGFkb3dWYWx1ZXMsIHZlYzQoIDEuMCApICkgKiBzaGFkb3dEYXJrbmVzc1sgaSBdO1xcblxcblx0I2Vsc2UgXFxuXHRcdFx0XHRzaGFkb3dDb29yZC56ICs9IHNoYWRvd0JpYXNbIGkgXTtcXG5cXG5cdFx0XHRcdHZlYzQgcmdiYURlcHRoID0gdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKTtcXG5cdFx0XHRcdGZsb2F0IGZEZXB0aCA9IHVucGFja0RlcHRoKCByZ2JhRGVwdGggKTtcXG5cXG5cdFx0XHRcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApXFxuXHRcdFx0XHRcdHNoYWRvdyA9IHNoYWRvd0RhcmtuZXNzWyBpIF07XFxuXFxuXHQjZW5kaWZcXG5cXG5cdFx0XHR9XFxuXFxuI2lmZGVmIFNIQURPV01BUF9ERUJVR1xcblxcblx0XHRcdGlmICggaW5GcnVzdHVtICkge1xcblxcblx0XHRcdFx0aWYgKCBpID09IDAgKSB7XFxuXFxuXHRcdFx0XHRcdG91dGdvaW5nTGlnaHQgKj0gdmVjMyggMS4wLCAwLjUsIDAuMCApO1xcblxcblx0XHRcdFx0fSBlbHNlIGlmICggaSA9PSAxICkge1xcblxcblx0XHRcdFx0XHRvdXRnb2luZ0xpZ2h0ICo9IHZlYzMoIDAuMCwgMS4wLCAwLjggKTtcXG5cXG5cdFx0XHRcdH0gZWxzZSB7XFxuXFxuXHRcdFx0XHRcdG91dGdvaW5nTGlnaHQgKj0gdmVjMyggMC4wLCAwLjUsIDEuMCApO1xcblxcblx0XHRcdFx0fVxcblxcblx0XHRcdH1cXG5cXG4jZW5kaWZcXG5cXG4jaWYgZGVmaW5lZCggUE9JTlRfTElHSFRfU0hBRE9XUyApXFxuXFxuXHRcdH1cXG5cXG4jZW5kaWZcXG5cXG5cdFx0c2hhZG93TWFzayA9IHNoYWRvd01hc2sgKiB2ZWMzKCAxLjAgLSBzaGFkb3cgKTtcXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NoYWRvd21hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnc2hhZG93bWFwX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXG5cdHVuaWZvcm0gc2FtcGxlcjJEIHNoYWRvd01hcFsgTUFYX1NIQURPV1MgXTtcXG5cdHVuaWZvcm0gdmVjMiBzaGFkb3dNYXBTaXplWyBNQVhfU0hBRE9XUyBdO1xcblxcblx0dW5pZm9ybSBmbG9hdCBzaGFkb3dEYXJrbmVzc1sgTUFYX1NIQURPV1MgXTtcXG5cdHVuaWZvcm0gZmxvYXQgc2hhZG93Qmlhc1sgTUFYX1NIQURPV1MgXTtcXG5cXG5cdHZhcnlpbmcgdmVjNCB2U2hhZG93Q29vcmRbIE1BWF9TSEFET1dTIF07XFxuXFxuXHRmbG9hdCB1bnBhY2tEZXB0aCggY29uc3QgaW4gdmVjNCByZ2JhX2RlcHRoICkge1xcblxcblx0XHRjb25zdCB2ZWM0IGJpdF9zaGlmdCA9IHZlYzQoIDEuMCAvICggMjU2LjAgKiAyNTYuMCAqIDI1Ni4wICksIDEuMCAvICggMjU2LjAgKiAyNTYuMCApLCAxLjAgLyAyNTYuMCwgMS4wICk7XFxuXHRcdGZsb2F0IGRlcHRoID0gZG90KCByZ2JhX2RlcHRoLCBiaXRfc2hpZnQgKTtcXG5cdFx0cmV0dXJuIGRlcHRoO1xcblxcblx0fVxcblxcblx0I2lmIGRlZmluZWQoUE9JTlRfTElHSFRfU0hBRE9XUylcXG5cXG5cXG5cdFx0dm9pZCBhZGp1c3RTaGFkb3dWYWx1ZTFLKCBjb25zdCBmbG9hdCB0ZXN0RGVwdGgsIGNvbnN0IHZlYzQgdGV4dHVyZURhdGEsIGNvbnN0IGZsb2F0IGJpYXMsIGlub3V0IGZsb2F0IHNoYWRvd1ZhbHVlICkge1xcblxcblx0XHRcdGNvbnN0IHZlYzQgYml0U2ggPSB2ZWM0KCAxLjAgLyAoIDI1Ni4wICogMjU2LjAgKiAyNTYuMCApLCAxLjAgLyAoIDI1Ni4wICogMjU2LjAgKSwgMS4wIC8gMjU2LjAsIDEuMCApO1xcblx0XHRcdGlmICggdGVzdERlcHRoID49IGRvdCggdGV4dHVyZURhdGEsIGJpdFNoICkgKiAxMDAwLjAgKyBiaWFzIClcXG5cdFx0XHRcdHNoYWRvd1ZhbHVlICs9IDEuMDtcXG5cXG5cdFx0fVxcblxcblxcblx0XHR2ZWMyIGN1YmVUb1VWKCB2ZWMzIHYsIGZsb2F0IHRleGVsU2l6ZVkgKSB7XFxuXFxuXFxuXHRcdFx0dmVjMyBhYnNWID0gYWJzKCB2ICk7XFxuXFxuXFxuXHRcdFx0ZmxvYXQgc2NhbGVUb0N1YmUgPSAxLjAgLyBtYXgoIGFic1YueCwgbWF4KCBhYnNWLnksIGFic1YueiApICk7XFxuXHRcdFx0YWJzViAqPSBzY2FsZVRvQ3ViZTtcXG5cXG5cXG5cdFx0XHR2ICo9IHNjYWxlVG9DdWJlICogKCAxLjAgLSAyLjAgKiB0ZXhlbFNpemVZICk7XFxuXFxuXFxuXFxuXHRcdFx0dmVjMiBwbGFuYXIgPSB2Lnh5O1xcblxcblx0XHRcdGZsb2F0IGFsbW9zdEFUZXhlbCA9IDEuNSAqIHRleGVsU2l6ZVk7XFxuXHRcdFx0ZmxvYXQgYWxtb3N0T25lID0gMS4wIC0gYWxtb3N0QVRleGVsO1xcblxcblx0XHRcdGlmICggYWJzVi56ID49IGFsbW9zdE9uZSApIHtcXG5cXG5cdFx0XHRcdGlmICggdi56ID4gMC4wIClcXG5cdFx0XHRcdFx0cGxhbmFyLnggPSA0LjAgLSB2Lng7XFxuXFxuXHRcdFx0fSBlbHNlIGlmICggYWJzVi54ID49IGFsbW9zdE9uZSApIHtcXG5cXG5cdFx0XHRcdGZsb2F0IHNpZ25YID0gc2lnbiggdi54ICk7XFxuXHRcdFx0XHRwbGFuYXIueCA9IHYueiAqIHNpZ25YICsgMi4wICogc2lnblg7XFxuXFxuXHRcdFx0fSBlbHNlIGlmICggYWJzVi55ID49IGFsbW9zdE9uZSApIHtcXG5cXG5cdFx0XHRcdGZsb2F0IHNpZ25ZID0gc2lnbiggdi55ICk7XFxuXHRcdFx0XHRwbGFuYXIueCA9IHYueCArIDIuMCAqIHNpZ25ZICsgMi4wO1xcblx0XHRcdFx0cGxhbmFyLnkgPSB2LnogKiBzaWduWSAtIDIuMDtcXG5cXG5cdFx0XHR9XFxuXFxuXFxuXHRcdFx0cmV0dXJuIHZlYzIoIDAuMTI1LCAwLjI1ICkgKiBwbGFuYXIgKyB2ZWMyKCAwLjM3NSwgMC43NSApO1xcblxcblx0XHR9XFxuXFxuXHQjZW5kaWZcXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NoYWRvd21hcF9wYXJzX3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NoYWRvd21hcF9wYXJzX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcblx0dW5pZm9ybSBmbG9hdCBzaGFkb3dEYXJrbmVzc1sgTUFYX1NIQURPV1MgXTtcXG5cdHVuaWZvcm0gbWF0NCBzaGFkb3dNYXRyaXhbIE1BWF9TSEFET1dTIF07XFxuXHR2YXJ5aW5nIHZlYzQgdlNoYWRvd0Nvb3JkWyBNQVhfU0hBRE9XUyBdO1xcblxcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2hhZG93bWFwX3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NoYWRvd21hcF92ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE1BWF9TSEFET1dTOyBpICsrICkge1xcblxcblx0XHRcdHZTaGFkb3dDb29yZFsgaSBdID0gc2hhZG93TWF0cml4WyBpIF0gKiB3b3JsZFBvc2l0aW9uO1xcblxcblx0fVxcblxcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2tpbmJhc2VfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnc2tpbmJhc2VfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXG5cdG1hdDQgYm9uZU1hdFggPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueCApO1xcblx0bWF0NCBib25lTWF0WSA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC55ICk7XFxuXHRtYXQ0IGJvbmVNYXRaID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnogKTtcXG5cdG1hdDQgYm9uZU1hdFcgPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgudyApO1xcblxcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2tpbm5pbmdfcGFyc192ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdza2lubmluZ19wYXJzX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuXHR1bmlmb3JtIG1hdDQgYmluZE1hdHJpeDtcXG5cdHVuaWZvcm0gbWF0NCBiaW5kTWF0cml4SW52ZXJzZTtcXG5cXG5cdCNpZmRlZiBCT05FX1RFWFRVUkVcXG5cXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgYm9uZVRleHR1cmU7XFxuXHRcdHVuaWZvcm0gaW50IGJvbmVUZXh0dXJlV2lkdGg7XFxuXHRcdHVuaWZvcm0gaW50IGJvbmVUZXh0dXJlSGVpZ2h0O1xcblxcblx0XHRtYXQ0IGdldEJvbmVNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7XFxuXFxuXHRcdFx0ZmxvYXQgaiA9IGkgKiA0LjA7XFxuXHRcdFx0ZmxvYXQgeCA9IG1vZCggaiwgZmxvYXQoIGJvbmVUZXh0dXJlV2lkdGggKSApO1xcblx0XHRcdGZsb2F0IHkgPSBmbG9vciggaiAvIGZsb2F0KCBib25lVGV4dHVyZVdpZHRoICkgKTtcXG5cXG5cdFx0XHRmbG9hdCBkeCA9IDEuMCAvIGZsb2F0KCBib25lVGV4dHVyZVdpZHRoICk7XFxuXHRcdFx0ZmxvYXQgZHkgPSAxLjAgLyBmbG9hdCggYm9uZVRleHR1cmVIZWlnaHQgKTtcXG5cXG5cdFx0XHR5ID0gZHkgKiAoIHkgKyAwLjUgKTtcXG5cXG5cdFx0XHR2ZWM0IHYxID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAwLjUgKSwgeSApICk7XFxuXHRcdFx0dmVjNCB2MiA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMS41ICksIHkgKSApO1xcblx0XHRcdHZlYzQgdjMgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDIuNSApLCB5ICkgKTtcXG5cdFx0XHR2ZWM0IHY0ID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAzLjUgKSwgeSApICk7XFxuXFxuXHRcdFx0bWF0NCBib25lID0gbWF0NCggdjEsIHYyLCB2MywgdjQgKTtcXG5cXG5cdFx0XHRyZXR1cm4gYm9uZTtcXG5cXG5cdFx0fVxcblxcblx0I2Vsc2VcXG5cXG5cdFx0dW5pZm9ybSBtYXQ0IGJvbmVHbG9iYWxNYXRyaWNlc1sgTUFYX0JPTkVTIF07XFxuXFxuXHRcdG1hdDQgZ2V0Qm9uZU1hdHJpeCggY29uc3QgaW4gZmxvYXQgaSApIHtcXG5cXG5cdFx0XHRtYXQ0IGJvbmUgPSBib25lR2xvYmFsTWF0cmljZXNbIGludChpKSBdO1xcblx0XHRcdHJldHVybiBib25lO1xcblxcblx0XHR9XFxuXFxuXHQjZW5kaWZcXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NraW5uaW5nX3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NraW5uaW5nX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuXHR2ZWM0IHNraW5WZXJ0ZXggPSBiaW5kTWF0cml4ICogdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApO1xcblxcblx0dmVjNCBza2lubmVkID0gdmVjNCggMC4wICk7XFxuXHRza2lubmVkICs9IGJvbmVNYXRYICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueDtcXG5cdHNraW5uZWQgKz0gYm9uZU1hdFkgKiBza2luVmVydGV4ICogc2tpbldlaWdodC55O1xcblx0c2tpbm5lZCArPSBib25lTWF0WiAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lno7XFxuXHRza2lubmVkICs9IGJvbmVNYXRXICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQudztcXG5cdHNraW5uZWQgID0gYmluZE1hdHJpeEludmVyc2UgKiBza2lubmVkO1xcblxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2tpbm5vcm1hbF92ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdza2lubm9ybWFsX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuXHRtYXQ0IHNraW5NYXRyaXggPSBtYXQ0KCAwLjAgKTtcXG5cdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC54ICogYm9uZU1hdFg7XFxuXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQueSAqIGJvbmVNYXRZO1xcblx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnogKiBib25lTWF0WjtcXG5cdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC53ICogYm9uZU1hdFc7XFxuXHRza2luTWF0cml4ICA9IGJpbmRNYXRyaXhJbnZlcnNlICogc2tpbk1hdHJpeCAqIGJpbmRNYXRyaXg7XFxuXFxuXHRvYmplY3ROb3JtYWwgPSB2ZWM0KCBza2luTWF0cml4ICogdmVjNCggb2JqZWN0Tm9ybWFsLCAwLjAgKSApLnh5ejtcXG5cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NwZWN1bGFybWFwX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnc3BlY3VsYXJtYXBfZnJhZ21lbnQnXSA9IFwiZmxvYXQgc3BlY3VsYXJTdHJlbmd0aDtcXG5cXG4jaWZkZWYgVVNFX1NQRUNVTEFSTUFQXFxuXFxuXHR2ZWM0IHRleGVsU3BlY3VsYXIgPSB0ZXh0dXJlMkQoIHNwZWN1bGFyTWFwLCB2VXYgKTtcXG5cdHNwZWN1bGFyU3RyZW5ndGggPSB0ZXhlbFNwZWN1bGFyLnI7XFxuXFxuI2Vsc2VcXG5cXG5cdHNwZWN1bGFyU3RyZW5ndGggPSAxLjA7XFxuXFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnc3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX1NQRUNVTEFSTUFQXFxuXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBzcGVjdWxhck1hcDtcXG5cXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3V2Ml9wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAndXYyX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9MSUdIVE1BUCApIHx8IGRlZmluZWQoIFVTRV9BT01BUCApXFxuXFxuXHR2YXJ5aW5nIHZlYzIgdlV2MjtcXG5cXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3V2Ml9wYXJzX3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ3V2Ml9wYXJzX3ZlcnRleCddID0gXCIjaWYgZGVmaW5lZCggVVNFX0xJR0hUTUFQICkgfHwgZGVmaW5lZCggVVNFX0FPTUFQIClcXG5cXG5cdGF0dHJpYnV0ZSB2ZWMyIHV2MjtcXG5cdHZhcnlpbmcgdmVjMiB2VXYyO1xcblxcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvdXYyX3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ3V2Ml92ZXJ0ZXgnXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9MSUdIVE1BUCApIHx8IGRlZmluZWQoIFVTRV9BT01BUCApXFxuXFxuXHR2VXYyID0gdXYyO1xcblxcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvdXZfcGFyc19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ3V2X3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9NQVAgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfU1BFQ1VMQVJNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQUxQSEFNQVAgKSB8fCBkZWZpbmVkKCBVU0VfRU1JU1NJVkVNQVAgKVxcblxcblx0dmFyeWluZyB2ZWMyIHZVdjtcXG5cXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3V2X3BhcnNfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAndXZfcGFyc192ZXJ0ZXgnXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9NQVAgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfU1BFQ1VMQVJNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQUxQSEFNQVAgKSB8fCBkZWZpbmVkKCBVU0VfRU1JU1NJVkVNQVAgKVxcblxcblx0dmFyeWluZyB2ZWMyIHZVdjtcXG5cdHVuaWZvcm0gdmVjNCBvZmZzZXRSZXBlYXQ7XFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay91dl92ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICd1dl92ZXJ0ZXgnXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9NQVAgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfU1BFQ1VMQVJNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQUxQSEFNQVAgKSB8fCBkZWZpbmVkKCBVU0VfRU1JU1NJVkVNQVAgKVxcblxcblx0dlV2ID0gdXYgKiBvZmZzZXRSZXBlYXQuencgKyBvZmZzZXRSZXBlYXQueHk7XFxuXFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay93b3JsZHBvc192ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICd3b3JsZHBvc192ZXJ0ZXgnXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApIHx8IGRlZmluZWQoIExBTUJFUlQgKSB8fCBkZWZpbmVkICggVVNFX1NIQURPV01BUCApXFxuXFxuXHQjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuXHRcdHZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogc2tpbm5lZDtcXG5cXG5cdCNlbHNlXFxuXFxuXHRcdHZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApO1xcblxcblx0I2VuZGlmXFxuXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9Vbmlmb3Jtc1V0aWxzLmpzXHJcblxyXG4vKipcclxuICogVW5pZm9ybSBVdGlsaXRpZXNcclxuICovXHJcblxyXG5USFJFRS5Vbmlmb3Jtc1V0aWxzID0ge1xyXG5cclxuICAgIG1lcmdlOiBmdW5jdGlvbiAoIHVuaWZvcm1zICkge1xyXG5cclxuICAgICAgICB2YXIgbWVyZ2VkID0ge307XHJcblxyXG4gICAgICAgIGZvciAoIHZhciB1ID0gMDsgdSA8IHVuaWZvcm1zLmxlbmd0aDsgdSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciB0bXAgPSB0aGlzLmNsb25lKCB1bmlmb3Jtc1sgdSBdICk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgcCBpbiB0bXAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgbWVyZ2VkWyBwIF0gPSB0bXBbIHAgXTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbWVyZ2VkO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2xvbmU6IGZ1bmN0aW9uICggdW5pZm9ybXNfc3JjICkge1xyXG5cclxuICAgICAgICB2YXIgdW5pZm9ybXNfZHN0ID0ge307XHJcblxyXG4gICAgICAgIGZvciAoIHZhciB1IGluIHVuaWZvcm1zX3NyYyApIHtcclxuXHJcbiAgICAgICAgICAgIHVuaWZvcm1zX2RzdFsgdSBdID0ge307XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgcCBpbiB1bmlmb3Jtc19zcmNbIHUgXSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1ldGVyX3NyYyA9IHVuaWZvcm1zX3NyY1sgdSBdWyBwIF07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgfHxcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMiB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjQgfHxcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuTWF0cml4MyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5NYXRyaXg0IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm1zX2RzdFsgdSBdWyBwIF0gPSBwYXJhbWV0ZXJfc3JjLmNsb25lKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggQXJyYXkuaXNBcnJheSggcGFyYW1ldGVyX3NyYyApICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB1bmlmb3Jtc19kc3RbIHUgXVsgcCBdID0gcGFyYW1ldGVyX3NyYy5zbGljZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm1zX2RzdFsgdSBdWyBwIF0gPSBwYXJhbWV0ZXJfc3JjO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdW5pZm9ybXNfZHN0O1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9Vbmlmb3Jtc0xpYi5qc1xyXG5cclxuLyoqXHJcbiAqIFVuaWZvcm1zIGxpYnJhcnkgZm9yIHNoYXJlZCB3ZWJnbCBzaGFkZXJzXHJcbiAqL1xyXG5cclxuVEhSRUUuVW5pZm9ybXNMaWIgPSB7XHJcblxyXG4gICAgY29tbW9uOiB7XHJcblxyXG4gICAgICAgIFwiZGlmZnVzZVwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHhlZWVlZWUgKSB9LFxyXG4gICAgICAgIFwib3BhY2l0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LFxyXG5cclxuICAgICAgICBcIm1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcclxuICAgICAgICBcIm9mZnNldFJlcGVhdFwiIDogeyB0eXBlOiBcInY0XCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yNCggMCwgMCwgMSwgMSApIH0sXHJcblxyXG4gICAgICAgIFwic3BlY3VsYXJNYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcbiAgICAgICAgXCJhbHBoYU1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcclxuXHJcbiAgICAgICAgXCJlbnZNYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcbiAgICAgICAgXCJmbGlwRW52TWFwXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogLSAxIH0sXHJcbiAgICAgICAgXCJyZWZsZWN0aXZpdHlcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSxcclxuICAgICAgICBcInJlZnJhY3Rpb25SYXRpb1wiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuOTggfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYW9tYXA6IHtcclxuXHJcbiAgICAgICAgXCJhb01hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcclxuICAgICAgICBcImFvTWFwSW50ZW5zaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbGlnaHRtYXA6IHtcclxuXHJcbiAgICAgICAgXCJsaWdodE1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcclxuICAgICAgICBcImxpZ2h0TWFwSW50ZW5zaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZW1pc3NpdmVtYXA6IHtcclxuXHJcbiAgICAgICAgXCJlbWlzc2l2ZU1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGJ1bXBtYXA6IHtcclxuXHJcbiAgICAgICAgXCJidW1wTWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG4gICAgICAgIFwiYnVtcFNjYWxlXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBub3JtYWxtYXA6IHtcclxuXHJcbiAgICAgICAgXCJub3JtYWxNYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcbiAgICAgICAgXCJub3JtYWxTY2FsZVwiIDogeyB0eXBlOiBcInYyXCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRpc3BsYWNlbWVudG1hcDoge1xyXG5cclxuICAgICAgICBcImRpc3BsYWNlbWVudE1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcclxuICAgICAgICBcImRpc3BsYWNlbWVudFNjYWxlXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxyXG4gICAgICAgIFwiZGlzcGxhY2VtZW50Qmlhc1wiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZm9nIDoge1xyXG5cclxuICAgICAgICBcImZvZ0RlbnNpdHlcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjAwMDI1IH0sXHJcbiAgICAgICAgXCJmb2dOZWFyXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxyXG4gICAgICAgIFwiZm9nRmFyXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMjAwMCB9LFxyXG4gICAgICAgIFwiZm9nQ29sb3JcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICkgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbGlnaHRzOiB7XHJcblxyXG4gICAgICAgIFwiYW1iaWVudExpZ2h0Q29sb3JcIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcclxuXHJcbiAgICAgICAgXCJkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXHJcbiAgICAgICAgXCJkaXJlY3Rpb25hbExpZ2h0Q29sb3JcIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcclxuXHJcbiAgICAgICAgXCJoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25cIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcclxuICAgICAgICBcImhlbWlzcGhlcmVMaWdodFNreUNvbG9yXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXHJcbiAgICAgICAgXCJoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxyXG5cclxuICAgICAgICBcInBvaW50TGlnaHRDb2xvclwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxyXG4gICAgICAgIFwicG9pbnRMaWdodFBvc2l0aW9uXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXHJcbiAgICAgICAgXCJwb2ludExpZ2h0RGlzdGFuY2VcIiA6IHsgdHlwZTogXCJmdjFcIiwgdmFsdWU6IFtdIH0sXHJcbiAgICAgICAgXCJwb2ludExpZ2h0RGVjYXlcIiA6IHsgdHlwZTogXCJmdjFcIiwgdmFsdWU6IFtdIH0sXHJcblxyXG4gICAgICAgIFwic3BvdExpZ2h0Q29sb3JcIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcclxuICAgICAgICBcInNwb3RMaWdodFBvc2l0aW9uXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXHJcbiAgICAgICAgXCJzcG90TGlnaHREaXJlY3Rpb25cIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcclxuICAgICAgICBcInNwb3RMaWdodERpc3RhbmNlXCIgOiB7IHR5cGU6IFwiZnYxXCIsIHZhbHVlOiBbXSB9LFxyXG4gICAgICAgIFwic3BvdExpZ2h0QW5nbGVDb3NcIiA6IHsgdHlwZTogXCJmdjFcIiwgdmFsdWU6IFtdIH0sXHJcbiAgICAgICAgXCJzcG90TGlnaHRFeHBvbmVudFwiIDogeyB0eXBlOiBcImZ2MVwiLCB2YWx1ZTogW10gfSxcclxuICAgICAgICBcInNwb3RMaWdodERlY2F5XCIgOiB7IHR5cGU6IFwiZnYxXCIsIHZhbHVlOiBbXSB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBwb2ludHM6IHtcclxuXHJcbiAgICAgICAgXCJwc0NvbG9yXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGVlZWVlZSApIH0sXHJcbiAgICAgICAgXCJvcGFjaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXHJcbiAgICAgICAgXCJzaXplXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXHJcbiAgICAgICAgXCJzY2FsZVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LFxyXG4gICAgICAgIFwibWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG4gICAgICAgIFwib2Zmc2V0UmVwZWF0XCIgOiB7IHR5cGU6IFwidjRcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3I0KCAwLCAwLCAxLCAxICkgfSxcclxuXHJcbiAgICAgICAgXCJmb2dEZW5zaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC4wMDAyNSB9LFxyXG4gICAgICAgIFwiZm9nTmVhclwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfSxcclxuICAgICAgICBcImZvZ0ZhclwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDIwMDAgfSxcclxuICAgICAgICBcImZvZ0NvbG9yXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNoYWRvd21hcDoge1xyXG5cclxuICAgICAgICBcInNoYWRvd01hcFwiOiB7IHR5cGU6IFwidHZcIiwgdmFsdWU6IFtdIH0sXHJcbiAgICAgICAgXCJzaGFkb3dNYXBTaXplXCI6IHsgdHlwZTogXCJ2MnZcIiwgdmFsdWU6IFtdIH0sXHJcblxyXG4gICAgICAgIFwic2hhZG93Qmlhc1wiIDogeyB0eXBlOiBcImZ2MVwiLCB2YWx1ZTogW10gfSxcclxuICAgICAgICBcInNoYWRvd0RhcmtuZXNzXCI6IHsgdHlwZTogXCJmdjFcIiwgdmFsdWU6IFtdIH0sXHJcblxyXG4gICAgICAgIFwic2hhZG93TWF0cml4XCIgOiB7IHR5cGU6IFwibTR2XCIsIHZhbHVlOiBbXSB9XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckxpYi5qc1xyXG5cclxuLyoqXHJcbiAqIFdlYmdsIFNoYWRlciBMaWJyYXJ5IGZvciB0aHJlZS5qc1xyXG4gKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKi9cclxuXHJcblxyXG5USFJFRS5TaGFkZXJMaWIgPSB7XHJcblxyXG4gICAgJ2Jhc2ljJzoge1xyXG5cclxuICAgICAgICB1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xyXG5cclxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwiY29tbW9uXCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwiYW9tYXBcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJmb2dcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJzaGFkb3dtYXBcIiBdXHJcblxyXG4gICAgICAgIF0gKSxcclxuXHJcbiAgICAgICAgdmVydGV4U2hhZGVyOiBbXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml9wYXJzX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXZfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcIlx0I2lmZGVmIFVTRV9FTlZNQVBcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2lubm9ybWFsX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBobm9ybWFsX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5ub3JtYWxfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGVmYXVsdG5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJcdCNlbmRpZlwiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5fdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwicHJvamVjdF92ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwid29ybGRwb3NfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF92ZXJ0ZXhcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJ9XCJcclxuXHJcbiAgICAgICAgXS5qb2luKCBcIlxcblwiICksXHJcblxyXG4gICAgICAgIGZyYWdtZW50U2hhZGVyOiBbXHJcblxyXG4gICAgICAgICAgICBcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1wiLFxyXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhb21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG4gICAgICAgICAgICBcIlx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XCIsXHJcbiAgICAgICAgICAgIFwiXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcIixcclxuICAgICAgICAgICAgXCJcdHZlYzMgdG90YWxBbWJpZW50TGlnaHQgPSB2ZWMzKCAxLjAgKTtcIiwgLy8gaGFyZHdpcmVkXHJcbiAgICAgICAgICAgIFwiXHR2ZWMzIHNoYWRvd01hc2sgPSB2ZWMzKCAxLjAgKTtcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYW1hcF9mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhdGVzdF9mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYW9tYXBfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfZnJhZ21lbnRcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJcdG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiICogdG90YWxBbWJpZW50TGlnaHQgKiBzaGFkb3dNYXNrO1wiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX2ZyYWdtZW50XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxpbmVhcl90b19nYW1tYV9mcmFnbWVudFwiIF0sXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfZnJhZ21lbnRcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XCIsXHJcblxyXG4gICAgICAgICAgICBcIn1cIlxyXG5cclxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgJ2xhbWJlcnQnOiB7XHJcblxyXG4gICAgICAgIHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJjb21tb25cIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJmb2dcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJsaWdodHNcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJzaGFkb3dtYXBcIiBdLFxyXG5cclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJlbWlzc2l2ZVwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHgwMDAwMDAgKSB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgXSApLFxyXG5cclxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcbiAgICAgICAgICAgIFwiI2RlZmluZSBMQU1CRVJUXCIsXHJcblxyXG4gICAgICAgICAgICBcInZhcnlpbmcgdmVjMyB2TGlnaHRGcm9udDtcIixcclxuXHJcbiAgICAgICAgICAgIFwiI2lmZGVmIERPVUJMRV9TSURFRFwiLFxyXG5cclxuICAgICAgICAgICAgXCJcdHZhcnlpbmcgdmVjMyB2TGlnaHRCYWNrO1wiLFxyXG5cclxuICAgICAgICAgICAgXCIjZW5kaWZcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3BhcnNfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3BhcnNfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX2xhbWJlcnRfcGFyc192ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfcGFyc192ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc192ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml92ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5ub3JtYWxfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGhub3JtYWxfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbmJhc2VfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJkZWZhdWx0bm9ybWFsX3ZlcnRleFwiIF0sXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJiZWdpbl92ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ192ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJwcm9qZWN0X3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ3b3JsZHBvc192ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX2xhbWJlcnRfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3ZlcnRleFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcIn1cIlxyXG5cclxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKSxcclxuXHJcbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcbiAgICAgICAgICAgIFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XCIsXHJcbiAgICAgICAgICAgIFwidW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1wiLFxyXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuXHJcbiAgICAgICAgICAgIFwidW5pZm9ybSB2ZWMzIGFtYmllbnRMaWdodENvbG9yO1wiLFxyXG5cclxuICAgICAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgdkxpZ2h0RnJvbnQ7XCIsXHJcblxyXG4gICAgICAgICAgICBcIiNpZmRlZiBET1VCTEVfU0lERURcIixcclxuXHJcbiAgICAgICAgICAgIFwiXHR2YXJ5aW5nIHZlYzMgdkxpZ2h0QmFjaztcIixcclxuXHJcbiAgICAgICAgICAgIFwiI2VuZGlmXCIsXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXZfcGFyc19mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml9wYXJzX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYW1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG4gICAgICAgICAgICBcIlx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XCIsXHQvLyBvdXRnb2luZyBsaWdodCBkb2VzIG5vdCBoYXZlIGFuIGFscGhhLCB0aGUgc3VyZmFjZSBkb2VzXHJcbiAgICAgICAgICAgIFwiXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcIixcclxuICAgICAgICAgICAgXCJcdHZlYzMgdG90YWxBbWJpZW50TGlnaHQgPSBhbWJpZW50TGlnaHRDb2xvcjtcIixcclxuICAgICAgICAgICAgXCJcdHZlYzMgc2hhZG93TWFzayA9IHZlYzMoIDEuMCApO1wiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGF0ZXN0X2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfZnJhZ21lbnRcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJcdCNpZmRlZiBET1VCTEVfU0lERURcIixcclxuXHJcbiAgICAgICAgICAgIFwiXHRcdGlmICggZ2xfRnJvbnRGYWNpbmcgKVwiLFxyXG4gICAgICAgICAgICBcIlx0XHRcdG91dGdvaW5nTGlnaHQgKz0gZGlmZnVzZUNvbG9yLnJnYiAqICggdkxpZ2h0RnJvbnQgKiBzaGFkb3dNYXNrICsgdG90YWxBbWJpZW50TGlnaHQgKSArIGVtaXNzaXZlO1wiLFxyXG4gICAgICAgICAgICBcIlx0XHRlbHNlXCIsXHJcbiAgICAgICAgICAgIFwiXHRcdFx0b3V0Z29pbmdMaWdodCArPSBkaWZmdXNlQ29sb3IucmdiICogKCB2TGlnaHRCYWNrICogc2hhZG93TWFzayArIHRvdGFsQW1iaWVudExpZ2h0ICkgKyBlbWlzc2l2ZTtcIixcclxuXHJcbiAgICAgICAgICAgIFwiXHQjZWxzZVwiLFxyXG5cclxuICAgICAgICAgICAgXCJcdFx0b3V0Z29pbmdMaWdodCArPSBkaWZmdXNlQ29sb3IucmdiICogKCB2TGlnaHRGcm9udCAqIHNoYWRvd01hc2sgKyB0b3RhbEFtYmllbnRMaWdodCApICsgZW1pc3NpdmU7XCIsXHJcblxyXG4gICAgICAgICAgICBcIlx0I2VuZGlmXCIsXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfZnJhZ21lbnRcIiBdLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19mcmFnbWVudFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcIlx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcIixcclxuXHJcbiAgICAgICAgICAgIFwifVwiXHJcblxyXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApXHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAncGhvbmcnOiB7XHJcblxyXG4gICAgICAgIHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJjb21tb25cIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJhb21hcFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImxpZ2h0bWFwXCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwiZW1pc3NpdmVtYXBcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJidW1wbWFwXCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwibm9ybWFsbWFwXCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwiZGlzcGxhY2VtZW50bWFwXCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwiZm9nXCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwibGlnaHRzXCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwic2hhZG93bWFwXCIgXSxcclxuXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwiZW1pc3NpdmVcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICkgfSxcclxuICAgICAgICAgICAgICAgIFwic3BlY3VsYXJcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4MTExMTExICkgfSxcclxuICAgICAgICAgICAgICAgIFwic2hpbmluZXNzXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAzMCB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgXSApLFxyXG5cclxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcbiAgICAgICAgICAgIFwiI2RlZmluZSBQSE9OR1wiLFxyXG5cclxuICAgICAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcIixcclxuXHJcbiAgICAgICAgICAgIFwiI2lmbmRlZiBGTEFUX1NIQURFRFwiLFxyXG5cclxuICAgICAgICAgICAgXCJcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1wiLFxyXG5cclxuICAgICAgICAgICAgXCIjZW5kaWZcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3BhcnNfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3BhcnNfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3Bob25nX3BhcnNfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc192ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl92ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2lubm9ybWFsX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBobm9ybWFsX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5ub3JtYWxfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGVmYXVsdG5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCIjaWZuZGVmIEZMQVRfU0hBREVEXCIsIC8vIE5vcm1hbCBjb21wdXRlZCB3aXRoIGRlcml2YXRpdmVzIHdoZW4gRkxBVF9TSEFERURcclxuXHJcbiAgICAgICAgICAgIFwiXHR2Tm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1wiLFxyXG5cclxuICAgICAgICAgICAgXCIjZW5kaWZcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2luX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImRpc3BsYWNlbWVudG1hcF92ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ192ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJwcm9qZWN0X3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcIlx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XCIsXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ3b3JsZHBvc192ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3Bob25nX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF92ZXJ0ZXhcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJ9XCJcclxuXHJcbiAgICAgICAgXS5qb2luKCBcIlxcblwiICksXHJcblxyXG4gICAgICAgIGZyYWdtZW50U2hhZGVyOiBbXHJcblxyXG4gICAgICAgICAgICBcIiNkZWZpbmUgUEhPTkdcIixcclxuXHJcbiAgICAgICAgICAgIFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XCIsXHJcbiAgICAgICAgICAgIFwidW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1wiLFxyXG4gICAgICAgICAgICBcInVuaWZvcm0gdmVjMyBzcGVjdWxhcjtcIixcclxuICAgICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IHNoaW5pbmVzcztcIixcclxuICAgICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXZfcGFyc19mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml9wYXJzX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYW1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYW9tYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJidW1wbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJub3JtYWxtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuICAgICAgICAgICAgXCJcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1wiLFxyXG4gICAgICAgICAgICBcIlx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XCIsXHJcbiAgICAgICAgICAgIFwiXHR2ZWMzIHRvdGFsQW1iaWVudExpZ2h0ID0gYW1iaWVudExpZ2h0Q29sb3I7XCIsXHJcbiAgICAgICAgICAgIFwiXHR2ZWMzIHRvdGFsRW1pc3NpdmVMaWdodCA9IGVtaXNzaXZlO1wiLFxyXG4gICAgICAgICAgICBcIlx0dmVjMyBzaGFkb3dNYXNrID0gdmVjMyggMS4wICk7XCIsXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGFtYXBfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYXRlc3RfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm5vcm1hbF9waG9uZ19mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiaGVtaWxpZ2h0X2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYW9tYXBfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbWlzc2l2ZW1hcF9mcmFnbWVudFwiIF0sXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfcGhvbmdfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfZnJhZ21lbnRcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJ0b3RhbERpZmZ1c2VMaWdodCAqPSBzaGFkb3dNYXNrO1wiLFxyXG4gICAgICAgICAgICBcInRvdGFsU3BlY3VsYXJMaWdodCAqPSBzaGFkb3dNYXNrO1wiLFxyXG5cclxuICAgICAgICAgICAgXCIjaWZkZWYgTUVUQUxcIixcclxuXHJcbiAgICAgICAgICAgIFwiXHRvdXRnb2luZ0xpZ2h0ICs9IGRpZmZ1c2VDb2xvci5yZ2IgKiAoIHRvdGFsRGlmZnVzZUxpZ2h0ICsgdG90YWxBbWJpZW50TGlnaHQgKSAqIHNwZWN1bGFyICsgdG90YWxTcGVjdWxhckxpZ2h0ICsgdG90YWxFbWlzc2l2ZUxpZ2h0O1wiLFxyXG5cclxuICAgICAgICAgICAgXCIjZWxzZVwiLFxyXG5cclxuICAgICAgICAgICAgXCJcdG91dGdvaW5nTGlnaHQgKz0gZGlmZnVzZUNvbG9yLnJnYiAqICggdG90YWxEaWZmdXNlTGlnaHQgKyB0b3RhbEFtYmllbnRMaWdodCApICsgdG90YWxTcGVjdWxhckxpZ2h0ICsgdG90YWxFbWlzc2l2ZUxpZ2h0O1wiLFxyXG5cclxuICAgICAgICAgICAgXCIjZW5kaWZcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9mcmFnbWVudFwiIF0sXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsaW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnRcIiBdLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFwiXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1wiLFxyXG5cclxuICAgICAgICAgICAgXCJ9XCJcclxuXHJcbiAgICAgICAgXS5qb2luKCBcIlxcblwiIClcclxuXHJcbiAgICB9LFxyXG5cclxuICAgICdwb2ludHMnOiB7XHJcblxyXG4gICAgICAgIHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJwb2ludHNcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJzaGFkb3dtYXBcIiBdXHJcblxyXG4gICAgICAgIF0gKSxcclxuXHJcbiAgICAgICAgdmVydGV4U2hhZGVyOiBbXHJcblxyXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgc2l6ZTtcIixcclxuICAgICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IHNjYWxlO1wiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc192ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc192ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3ZlcnRleFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcIlx0dmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxyXG5cclxuICAgICAgICAgICAgXCJcdCNpZmRlZiBVU0VfU0laRUFUVEVOVUFUSU9OXCIsXHJcbiAgICAgICAgICAgIFwiXHRcdGdsX1BvaW50U2l6ZSA9IHNpemUgKiAoIHNjYWxlIC8gbGVuZ3RoKCBtdlBvc2l0aW9uLnh5eiApICk7XCIsXHJcbiAgICAgICAgICAgIFwiXHQjZWxzZVwiLFxyXG4gICAgICAgICAgICBcIlx0XHRnbF9Qb2ludFNpemUgPSBzaXplO1wiLFxyXG4gICAgICAgICAgICBcIlx0I2VuZGlmXCIsXHJcblxyXG4gICAgICAgICAgICBcIlx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIndvcmxkcG9zX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF92ZXJ0ZXhcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJ9XCJcclxuXHJcbiAgICAgICAgXS5qb2luKCBcIlxcblwiICksXHJcblxyXG4gICAgICAgIGZyYWdtZW50U2hhZGVyOiBbXHJcblxyXG4gICAgICAgICAgICBcInVuaWZvcm0gdmVjMyBwc0NvbG9yO1wiLFxyXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuICAgICAgICAgICAgXCJcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1wiLFxyXG4gICAgICAgICAgICBcIlx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBwc0NvbG9yLCBvcGFjaXR5ICk7XCIsXHJcbiAgICAgICAgICAgIFwiXHR2ZWMzIHNoYWRvd01hc2sgPSB2ZWMzKCAxLjAgKTtcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnRpY2xlX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYXRlc3RfZnJhZ21lbnRcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfZnJhZ21lbnRcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJcdG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiICogc2hhZG93TWFzaztcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19mcmFnbWVudFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcIlx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcIixcclxuXHJcbiAgICAgICAgICAgIFwifVwiXHJcblxyXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApXHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAnZGFzaGVkJzoge1xyXG5cclxuICAgICAgICB1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xyXG5cclxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwiY29tbW9uXCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwiZm9nXCIgXSxcclxuXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwic2NhbGVcIiAgICA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXHJcbiAgICAgICAgICAgICAgICBcImRhc2hTaXplXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxyXG4gICAgICAgICAgICAgICAgXCJ0b3RhbFNpemVcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDIgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIF0gKSxcclxuXHJcbiAgICAgICAgdmVydGV4U2hhZGVyOiBbXHJcblxyXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgc2NhbGU7XCIsXHJcbiAgICAgICAgICAgIFwiYXR0cmlidXRlIGZsb2F0IGxpbmVEaXN0YW5jZTtcIixcclxuXHJcbiAgICAgICAgICAgIFwidmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlO1wiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc192ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3ZlcnRleFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcIlx0dkxpbmVEaXN0YW5jZSA9IHNjYWxlICogbGluZURpc3RhbmNlO1wiLFxyXG5cclxuICAgICAgICAgICAgXCJcdHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcclxuICAgICAgICAgICAgXCJcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XCIsXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJ9XCJcclxuXHJcbiAgICAgICAgXS5qb2luKCBcIlxcblwiICksXHJcblxyXG4gICAgICAgIGZyYWdtZW50U2hhZGVyOiBbXHJcblxyXG4gICAgICAgICAgICBcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1wiLFxyXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuXHJcbiAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCBkYXNoU2l6ZTtcIixcclxuICAgICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IHRvdGFsU2l6ZTtcIixcclxuXHJcbiAgICAgICAgICAgIFwidmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlO1wiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcclxuXHJcbiAgICAgICAgICAgIFwiXHRpZiAoIG1vZCggdkxpbmVEaXN0YW5jZSwgdG90YWxTaXplICkgPiBkYXNoU2l6ZSApIHtcIixcclxuXHJcbiAgICAgICAgICAgIFwiXHRcdGRpc2NhcmQ7XCIsXHJcblxyXG4gICAgICAgICAgICBcIlx0fVwiLFxyXG5cclxuICAgICAgICAgICAgXCJcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1wiLFxyXG4gICAgICAgICAgICBcIlx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XCIsXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFwiXHRvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYjtcIiwgLy8gc2ltcGxlIHNoYWRlclxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFwiXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1wiLFxyXG5cclxuICAgICAgICAgICAgXCJ9XCJcclxuXHJcbiAgICAgICAgXS5qb2luKCBcIlxcblwiIClcclxuXHJcbiAgICB9LFxyXG5cclxuICAgICdkZXB0aCc6IHtcclxuXHJcbiAgICAgICAgdW5pZm9ybXM6IHtcclxuXHJcbiAgICAgICAgICAgIFwibU5lYXJcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LFxyXG4gICAgICAgICAgICBcIm1GYXJcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAyMDAwLjAgfSxcclxuICAgICAgICAgICAgXCJvcGFjaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH1cclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdmVydGV4U2hhZGVyOiBbXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5fdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwicHJvamVjdF92ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJ9XCJcclxuXHJcbiAgICAgICAgXS5qb2luKCBcIlxcblwiICksXHJcblxyXG4gICAgICAgIGZyYWdtZW50U2hhZGVyOiBbXHJcblxyXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgbU5lYXI7XCIsXHJcbiAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCBtRmFyO1wiLFxyXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcIlx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcIixcclxuXHJcbiAgICAgICAgICAgIFwiXHRcdGZsb2F0IGRlcHRoID0gZ2xfRnJhZ0RlcHRoRVhUIC8gZ2xfRnJhZ0Nvb3JkLnc7XCIsXHJcblxyXG4gICAgICAgICAgICBcIlx0I2Vsc2VcIixcclxuXHJcbiAgICAgICAgICAgIFwiXHRcdGZsb2F0IGRlcHRoID0gZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudztcIixcclxuXHJcbiAgICAgICAgICAgIFwiXHQjZW5kaWZcIixcclxuXHJcbiAgICAgICAgICAgIFwiXHRmbG9hdCBjb2xvciA9IDEuMCAtIHNtb290aHN0ZXAoIG1OZWFyLCBtRmFyLCBkZXB0aCApO1wiLFxyXG4gICAgICAgICAgICBcIlx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggdmVjMyggY29sb3IgKSwgb3BhY2l0eSApO1wiLFxyXG5cclxuICAgICAgICAgICAgXCJ9XCJcclxuXHJcbiAgICAgICAgXS5qb2luKCBcIlxcblwiIClcclxuXHJcbiAgICB9LFxyXG5cclxuICAgICdub3JtYWwnOiB7XHJcblxyXG4gICAgICAgIHVuaWZvcm1zOiB7XHJcblxyXG4gICAgICAgICAgICBcIm9wYWNpdHlcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfVxyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcbiAgICAgICAgICAgIFwidmFyeWluZyB2ZWMzIHZOb3JtYWw7XCIsXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuICAgICAgICAgICAgXCJcdHZOb3JtYWwgPSBub3JtYWxpemUoIG5vcm1hbE1hdHJpeCAqIG5vcm1hbCApO1wiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5fdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwicHJvamVjdF92ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJ9XCJcclxuXHJcbiAgICAgICAgXS5qb2luKCBcIlxcblwiICksXHJcblxyXG4gICAgICAgIGZyYWdtZW50U2hhZGVyOiBbXHJcblxyXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuICAgICAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG4gICAgICAgICAgICBcIlx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggMC41ICogbm9ybWFsaXplKCB2Tm9ybWFsICkgKyAwLjUsIG9wYWNpdHkgKTtcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFwifVwiXHJcblxyXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApXHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgLy9cdEN1YmUgbWFwIHNoYWRlclxyXG4gICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcbiAgICAnY3ViZSc6IHtcclxuXHJcbiAgICAgICAgdW5pZm9ybXM6IHsgXCJ0Q3ViZVwiOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG4gICAgICAgICAgICBcInRGbGlwXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAtIDEgfSB9LFxyXG5cclxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcbiAgICAgICAgICAgIFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1wiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG4gICAgICAgICAgICBcIlx0dldvcmxkUG9zaXRpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApO1wiLFxyXG5cclxuICAgICAgICAgICAgXCJcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcIn1cIlxyXG5cclxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKSxcclxuXHJcbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcbiAgICAgICAgICAgIFwidW5pZm9ybSBzYW1wbGVyQ3ViZSB0Q3ViZTtcIixcclxuICAgICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IHRGbGlwO1wiLFxyXG5cclxuICAgICAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XCIsXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuICAgICAgICAgICAgXCJcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmVDdWJlKCB0Q3ViZSwgdmVjMyggdEZsaXAgKiB2V29ybGRQb3NpdGlvbi54LCB2V29ybGRQb3NpdGlvbi55eiApICk7XCIsXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcIn1cIlxyXG5cclxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgIC8vXHRDdWJlIG1hcCBzaGFkZXJcclxuICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcblxyXG4gICAgJ2VxdWlyZWN0Jzoge1xyXG5cclxuICAgICAgICB1bmlmb3JtczogeyBcInRFcXVpcmVjdFwiOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG4gICAgICAgICAgICBcInRGbGlwXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAtIDEgfSB9LFxyXG5cclxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcbiAgICAgICAgICAgIFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1wiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG4gICAgICAgICAgICBcIlx0dldvcmxkUG9zaXRpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApO1wiLFxyXG5cclxuICAgICAgICAgICAgXCJcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXHJcblxyXG4gICAgICAgICAgICBcIn1cIlxyXG5cclxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKSxcclxuXHJcbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcbiAgICAgICAgICAgIFwidW5pZm9ybSBzYW1wbGVyMkQgdEVxdWlyZWN0O1wiLFxyXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgdEZsaXA7XCIsXHJcblxyXG4gICAgICAgICAgICBcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG4gICAgICAgICAgICAvLyBcIlx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZUN1YmUoIHRDdWJlLCB2ZWMzKCB0RmxpcCAqIHZXb3JsZFBvc2l0aW9uLngsIHZXb3JsZFBvc2l0aW9uLnl6ICkgKTtcIixcclxuICAgICAgICAgICAgXCJ2ZWMzIGRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggdldvcmxkUG9zaXRpb24gKTtcIixcclxuICAgICAgICAgICAgXCJ2ZWMyIHNhbXBsZVVWO1wiLFxyXG4gICAgICAgICAgICBcInNhbXBsZVVWLnkgPSBzYXR1cmF0ZSggdEZsaXAgKiBkaXJlY3Rpb24ueSAqIC0wLjUgKyAwLjUgKTtcIixcclxuICAgICAgICAgICAgXCJzYW1wbGVVVi54ID0gYXRhbiggZGlyZWN0aW9uLnosIGRpcmVjdGlvbi54ICkgKiBSRUNJUFJPQ0FMX1BJMiArIDAuNTtcIixcclxuICAgICAgICAgICAgXCJnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIHRFcXVpcmVjdCwgc2FtcGxlVVYgKTtcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFwifVwiXHJcblxyXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApXHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKiBEZXB0aCBlbmNvZGluZyBpbnRvIFJHQkEgdGV4dHVyZVxyXG4gICAgICpcclxuICAgICAqIGJhc2VkIG9uIFNwaWRlckdMIHNoYWRvdyBtYXAgZXhhbXBsZVxyXG4gICAgICogaHR0cDovL3NwaWRlcmdsLm9yZy9leGFtcGxlLnBocD9pZD02XHJcbiAgICAgKlxyXG4gICAgICogb3JpZ2luYWxseSBmcm9tXHJcbiAgICAgKiBodHRwOi8vd3d3LmdhbWVkZXYubmV0L3RvcGljLzQ0MjEzOC1wYWNraW5nLWEtZmxvYXQtaW50by1hLWE4cjhnOGI4LXRleHR1cmUtc2hhZGVyL3BhZ2VfX3doaWNocGFnZV9fMSUyNUVGJTI1QkYlMjVCRFxyXG4gICAgICpcclxuICAgICAqIHNlZSBhbHNvXHJcbiAgICAgKiBodHRwOi8vYXJhcy1wLmluZm8vYmxvZy8yMDA5LzA3LzMwL2VuY29kaW5nLWZsb2F0cy10by1yZ2JhLXRoZS1maW5hbC9cclxuICAgICAqL1xyXG5cclxuICAgICdkZXB0aFJHQkEnOiB7XHJcblxyXG4gICAgICAgIHVuaWZvcm1zOiB7fSxcclxuXHJcbiAgICAgICAgdmVydGV4U2hhZGVyOiBbXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2luYmFzZV92ZXJ0ZXhcIiBdLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5fdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwicHJvamVjdF92ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJ9XCJcclxuXHJcbiAgICAgICAgXS5qb2luKCBcIlxcblwiICksXHJcblxyXG4gICAgICAgIGZyYWdtZW50U2hhZGVyOiBbXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFwidmVjNCBwYWNrX2RlcHRoKCBjb25zdCBpbiBmbG9hdCBkZXB0aCApIHtcIixcclxuXHJcbiAgICAgICAgICAgIFwiXHRjb25zdCB2ZWM0IGJpdF9zaGlmdCA9IHZlYzQoIDI1Ni4wICogMjU2LjAgKiAyNTYuMCwgMjU2LjAgKiAyNTYuMCwgMjU2LjAsIDEuMCApO1wiLFxyXG4gICAgICAgICAgICBcIlx0Y29uc3QgdmVjNCBiaXRfbWFzayA9IHZlYzQoIDAuMCwgMS4wIC8gMjU2LjAsIDEuMCAvIDI1Ni4wLCAxLjAgLyAyNTYuMCApO1wiLFxyXG4gICAgICAgICAgICBcIlx0dmVjNCByZXMgPSBtb2QoIGRlcHRoICogYml0X3NoaWZ0ICogdmVjNCggMjU1ICksIHZlYzQoIDI1NiApICkgLyB2ZWM0KCAyNTUgKTtcIiwgLy8gXCJcdHZlYzQgcmVzID0gZnJhY3QoIGRlcHRoICogYml0X3NoaWZ0ICk7XCIsXHJcbiAgICAgICAgICAgIFwiXHRyZXMgLT0gcmVzLnh4eXogKiBiaXRfbWFzaztcIixcclxuICAgICAgICAgICAgXCJcdHJldHVybiByZXM7XCIsXHJcblxyXG4gICAgICAgICAgICBcIn1cIixcclxuXHJcbiAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJcdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXCIsXHJcblxyXG4gICAgICAgICAgICBcIlx0XHRnbF9GcmFnRGF0YVsgMCBdID0gcGFja19kZXB0aCggZ2xfRnJhZ0RlcHRoRVhUICk7XCIsXHJcblxyXG4gICAgICAgICAgICBcIlx0I2Vsc2VcIixcclxuXHJcbiAgICAgICAgICAgIFwiXHRcdGdsX0ZyYWdEYXRhWyAwIF0gPSBwYWNrX2RlcHRoKCBnbF9GcmFnQ29vcmQueiApO1wiLFxyXG5cclxuICAgICAgICAgICAgXCJcdCNlbmRpZlwiLFxyXG5cclxuICAgICAgICAgICAgLy9cImdsX0ZyYWdEYXRhWyAwIF0gPSBwYWNrX2RlcHRoKCBnbF9GcmFnQ29vcmQueiAvIGdsX0ZyYWdDb29yZC53ICk7XCIsXHJcbiAgICAgICAgICAgIC8vXCJmbG9hdCB6ID0gKCAoIGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLncgKSAtIDMuMCApIC8gKCA0MDAwLjAgLSAzLjAgKTtcIixcclxuICAgICAgICAgICAgLy9cImdsX0ZyYWdEYXRhWyAwIF0gPSBwYWNrX2RlcHRoKCB6ICk7XCIsXHJcbiAgICAgICAgICAgIC8vXCJnbF9GcmFnRGF0YVsgMCBdID0gdmVjNCggeiwgeiwgeiwgMS4wICk7XCIsXHJcblxyXG4gICAgICAgICAgICBcIn1cIlxyXG5cclxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKVxyXG5cclxuICAgIH0sXHJcblxyXG5cclxuICAgICdkaXN0YW5jZVJHQkEnOiB7XHJcblxyXG4gICAgICAgIHVuaWZvcm1zOiB7XHJcblxyXG4gICAgICAgICAgICBcImxpZ2h0UG9zXCI6IHsgdHlwZTogXCJ2M1wiLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDAgKSB9XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHZlcnRleFNoYWRlcjogW1xyXG5cclxuICAgICAgICAgICAgXCJ2YXJ5aW5nIHZlYzQgdldvcmxkUG9zaXRpb247XCIsXHJcblxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcclxuXHJcbiAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbmJhc2VfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5fdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfdmVydGV4XCIgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwicHJvamVjdF92ZXJ0ZXhcIiBdLFxyXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ3b3JsZHBvc192ZXJ0ZXhcIiBdLFxyXG5cclxuICAgICAgICAgICAgXCJ2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb247XCIsXHJcblxyXG4gICAgICAgICAgICBcIn1cIlxyXG5cclxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKSxcclxuXHJcbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcbiAgICAgICAgICAgIFwidW5pZm9ybSB2ZWMzIGxpZ2h0UG9zO1wiLFxyXG4gICAgICAgICAgICBcInZhcnlpbmcgdmVjNCB2V29ybGRQb3NpdGlvbjtcIixcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblxyXG4gICAgICAgICAgICBcInZlYzQgcGFjazFLICggZmxvYXQgZGVwdGggKSB7XCIsXHJcblxyXG4gICAgICAgICAgICBcIiAgIGRlcHRoIC89IDEwMDAuMDtcIixcclxuICAgICAgICAgICAgXCIgICBjb25zdCB2ZWM0IGJpdFNoID0gdmVjNCggMjU2LjAgKiAyNTYuMCAqIDI1Ni4wLCAyNTYuMCAqIDI1Ni4wLCAyNTYuMCwgMS4wICk7XCIsXHJcbiAgICAgICAgICAgIFwiXHRjb25zdCB2ZWM0IGJpdE1zayA9IHZlYzQoIDAuMCwgMS4wIC8gMjU2LjAsIDEuMCAvIDI1Ni4wLCAxLjAgLyAyNTYuMCApO1wiLFxyXG4gICAgICAgICAgICBcIlx0dmVjNCByZXMgPSBmcmFjdCggZGVwdGggKiBiaXRTaCApO1wiLFxyXG4gICAgICAgICAgICBcIlx0cmVzIC09IHJlcy54eHl6ICogYml0TXNrO1wiLFxyXG4gICAgICAgICAgICBcIlx0cmV0dXJuIHJlczsgXCIsXHJcblxyXG4gICAgICAgICAgICBcIn1cIixcclxuXHJcbiAgICAgICAgICAgIFwiZmxvYXQgdW5wYWNrMUsgKCB2ZWM0IGNvbG9yICkge1wiLFxyXG5cclxuICAgICAgICAgICAgXCJcdGNvbnN0IHZlYzQgYml0U2ggPSB2ZWM0KCAxLjAgLyAoIDI1Ni4wICogMjU2LjAgKiAyNTYuMCApLCAxLjAgLyAoIDI1Ni4wICogMjU2LjAgKSwgMS4wIC8gMjU2LjAsIDEuMCApO1wiLFxyXG4gICAgICAgICAgICBcIlx0cmV0dXJuIGRvdCggY29sb3IsIGJpdFNoICkgKiAxMDAwLjA7XCIsXHJcblxyXG4gICAgICAgICAgICBcIn1cIixcclxuXHJcbiAgICAgICAgICAgIFwidm9pZCBtYWluICgpIHtcIixcclxuXHJcbiAgICAgICAgICAgIFwiXHRnbF9GcmFnQ29sb3IgPSBwYWNrMUsoIGxlbmd0aCggdldvcmxkUG9zaXRpb24ueHl6IC0gbGlnaHRQb3MueHl6ICkgKTtcIixcclxuXHJcbiAgICAgICAgICAgIFwifVwiXHJcblxyXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApXHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9XZWJHTFJlbmRlcmVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBzdXBlcmVnZ2JlcnQgLyBodHRwOi8vd3d3LnBhdWxicnVudC5jby51ay9cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBzemltZWsgLyBodHRwczovL2dpdGh1Yi5jb20vc3ppbWVrL1xyXG4gKi9cclxuXHJcblRIUkVFLldlYkdMUmVuZGVyZXIgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG4gICAgY29uc29sZS5sb2coICdUSFJFRS5XZWJHTFJlbmRlcmVyJywgVEhSRUUuUkVWSVNJT04gKTtcclxuXHJcbiAgICBwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCB7fTtcclxuXHJcbiAgICB2YXIgX2NhbnZhcyA9IHBhcmFtZXRlcnMuY2FudmFzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmNhbnZhcyA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICksXHJcbiAgICAgICAgX2NvbnRleHQgPSBwYXJhbWV0ZXJzLmNvbnRleHQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY29udGV4dCA6IG51bGwsXHJcblxyXG4gICAgICAgIF93aWR0aCA9IF9jYW52YXMud2lkdGgsXHJcbiAgICAgICAgX2hlaWdodCA9IF9jYW52YXMuaGVpZ2h0LFxyXG5cclxuICAgICAgICBwaXhlbFJhdGlvID0gMSxcclxuXHJcbiAgICAgICAgX2FscGhhID0gcGFyYW1ldGVycy5hbHBoYSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5hbHBoYSA6IGZhbHNlLFxyXG4gICAgICAgIF9kZXB0aCA9IHBhcmFtZXRlcnMuZGVwdGggIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuZGVwdGggOiB0cnVlLFxyXG4gICAgICAgIF9zdGVuY2lsID0gcGFyYW1ldGVycy5zdGVuY2lsICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnN0ZW5jaWwgOiB0cnVlLFxyXG4gICAgICAgIF9hbnRpYWxpYXMgPSBwYXJhbWV0ZXJzLmFudGlhbGlhcyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5hbnRpYWxpYXMgOiBmYWxzZSxcclxuICAgICAgICBfcHJlbXVsdGlwbGllZEFscGhhID0gcGFyYW1ldGVycy5wcmVtdWx0aXBsaWVkQWxwaGEgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucHJlbXVsdGlwbGllZEFscGhhIDogdHJ1ZSxcclxuICAgICAgICBfcHJlc2VydmVEcmF3aW5nQnVmZmVyID0gcGFyYW1ldGVycy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucHJlc2VydmVEcmF3aW5nQnVmZmVyIDogZmFsc2UsXHJcblxyXG4gICAgICAgIF9jbGVhckNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweDAwMDAwMCApLFxyXG4gICAgICAgIF9jbGVhckFscGhhID0gMDtcclxuXHJcbiAgICB2YXIgbGlnaHRzID0gW107XHJcblxyXG4gICAgdmFyIG9wYXF1ZU9iamVjdHMgPSBbXTtcclxuICAgIHZhciBvcGFxdWVPYmplY3RzTGFzdEluZGV4ID0gLSAxO1xyXG4gICAgdmFyIHRyYW5zcGFyZW50T2JqZWN0cyA9IFtdO1xyXG4gICAgdmFyIHRyYW5zcGFyZW50T2JqZWN0c0xhc3RJbmRleCA9IC0gMTtcclxuXHJcbiAgICB2YXIgbW9ycGhJbmZsdWVuY2VzID0gbmV3IEZsb2F0MzJBcnJheSggOCApO1xyXG5cclxuXHJcbiAgICB2YXIgc3ByaXRlcyA9IFtdO1xyXG4gICAgdmFyIGxlbnNGbGFyZXMgPSBbXTtcclxuXHJcbiAgICAvLyBwdWJsaWMgcHJvcGVydGllc1xyXG5cclxuICAgIHRoaXMuZG9tRWxlbWVudCA9IF9jYW52YXM7XHJcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xyXG5cclxuICAgIC8vIGNsZWFyaW5nXHJcblxyXG4gICAgdGhpcy5hdXRvQ2xlYXIgPSB0cnVlO1xyXG4gICAgdGhpcy5hdXRvQ2xlYXJDb2xvciA9IHRydWU7XHJcbiAgICB0aGlzLmF1dG9DbGVhckRlcHRoID0gdHJ1ZTtcclxuICAgIHRoaXMuYXV0b0NsZWFyU3RlbmNpbCA9IHRydWU7XHJcblxyXG4gICAgLy8gc2NlbmUgZ3JhcGhcclxuXHJcbiAgICB0aGlzLnNvcnRPYmplY3RzID0gdHJ1ZTtcclxuXHJcbiAgICAvLyBwaHlzaWNhbGx5IGJhc2VkIHNoYWRpbmdcclxuXHJcbiAgICB0aGlzLmdhbW1hRmFjdG9yID0gMi4wO1x0Ly8gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcbiAgICB0aGlzLmdhbW1hSW5wdXQgPSBmYWxzZTtcclxuICAgIHRoaXMuZ2FtbWFPdXRwdXQgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBtb3JwaHNcclxuXHJcbiAgICB0aGlzLm1heE1vcnBoVGFyZ2V0cyA9IDg7XHJcbiAgICB0aGlzLm1heE1vcnBoTm9ybWFscyA9IDQ7XHJcblxyXG4gICAgLy8gZmxhZ3NcclxuXHJcbiAgICB0aGlzLmF1dG9TY2FsZUN1YmVtYXBzID0gdHJ1ZTtcclxuXHJcbiAgICAvLyBpbnRlcm5hbCBwcm9wZXJ0aWVzXHJcblxyXG4gICAgdmFyIF90aGlzID0gdGhpcyxcclxuXHJcbiAgICAvLyBpbnRlcm5hbCBzdGF0ZSBjYWNoZVxyXG5cclxuICAgICAgICBfY3VycmVudFByb2dyYW0gPSBudWxsLFxyXG4gICAgICAgIF9jdXJyZW50RnJhbWVidWZmZXIgPSBudWxsLFxyXG4gICAgICAgIF9jdXJyZW50TWF0ZXJpYWxJZCA9IC0gMSxcclxuICAgICAgICBfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9ICcnLFxyXG4gICAgICAgIF9jdXJyZW50Q2FtZXJhID0gbnVsbCxcclxuXHJcbiAgICAgICAgX3VzZWRUZXh0dXJlVW5pdHMgPSAwLFxyXG5cclxuICAgICAgICBfdmlld3BvcnRYID0gMCxcclxuICAgICAgICBfdmlld3BvcnRZID0gMCxcclxuICAgICAgICBfdmlld3BvcnRXaWR0aCA9IF9jYW52YXMud2lkdGgsXHJcbiAgICAgICAgX3ZpZXdwb3J0SGVpZ2h0ID0gX2NhbnZhcy5oZWlnaHQsXHJcbiAgICAgICAgX2N1cnJlbnRXaWR0aCA9IDAsXHJcbiAgICAgICAgX2N1cnJlbnRIZWlnaHQgPSAwLFxyXG5cclxuICAgIC8vIGZydXN0dW1cclxuXHJcbiAgICAgICAgX2ZydXN0dW0gPSBuZXcgVEhSRUUuRnJ1c3R1bSgpLFxyXG5cclxuICAgIC8vIGNhbWVyYSBtYXRyaWNlcyBjYWNoZVxyXG5cclxuICAgICAgICBfcHJvalNjcmVlbk1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCksXHJcblxyXG4gICAgICAgIF92ZWN0b3IzID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHJcbiAgICAvLyBsaWdodCBhcnJheXMgY2FjaGVcclxuXHJcbiAgICAgICAgX2RpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblxyXG4gICAgICAgIF9saWdodHNOZWVkVXBkYXRlID0gdHJ1ZSxcclxuXHJcbiAgICAgICAgX2xpZ2h0cyA9IHtcclxuXHJcbiAgICAgICAgICAgIGFtYmllbnQ6IFsgMCwgMCwgMCBdLFxyXG4gICAgICAgICAgICBkaXJlY3Rpb25hbDogeyBsZW5ndGg6IDAsIGNvbG9yczogW10sIHBvc2l0aW9uczogW10gfSxcclxuICAgICAgICAgICAgcG9pbnQ6IHsgbGVuZ3RoOiAwLCBjb2xvcnM6IFtdLCBwb3NpdGlvbnM6IFtdLCBkaXN0YW5jZXM6IFtdLCBkZWNheXM6IFtdIH0sXHJcbiAgICAgICAgICAgIHNwb3Q6IHsgbGVuZ3RoOiAwLCBjb2xvcnM6IFtdLCBwb3NpdGlvbnM6IFtdLCBkaXN0YW5jZXM6IFtdLCBkaXJlY3Rpb25zOiBbXSwgYW5nbGVzQ29zOiBbXSwgZXhwb25lbnRzOiBbXSwgZGVjYXlzOiBbXSB9LFxyXG4gICAgICAgICAgICBoZW1pOiB7IGxlbmd0aDogMCwgc2t5Q29sb3JzOiBbXSwgZ3JvdW5kQ29sb3JzOiBbXSwgcG9zaXRpb25zOiBbXSB9XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgLy8gaW5mb1xyXG5cclxuICAgICAgICBfaW5mb01lbW9yeSA9IHtcclxuXHJcbiAgICAgICAgICAgIGdlb21ldHJpZXM6IDAsXHJcbiAgICAgICAgICAgIHRleHR1cmVzOiAwXHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9pbmZvUmVuZGVyID0ge1xyXG5cclxuICAgICAgICAgICAgY2FsbHM6IDAsXHJcbiAgICAgICAgICAgIHZlcnRpY2VzOiAwLFxyXG4gICAgICAgICAgICBmYWNlczogMCxcclxuICAgICAgICAgICAgcG9pbnRzOiAwXHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgdGhpcy5pbmZvID0ge1xyXG5cclxuICAgICAgICByZW5kZXI6IF9pbmZvUmVuZGVyLFxyXG4gICAgICAgIG1lbW9yeTogX2luZm9NZW1vcnksXHJcbiAgICAgICAgcHJvZ3JhbXM6IG51bGxcclxuXHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvLyBpbml0aWFsaXplXHJcblxyXG4gICAgdmFyIF9nbDtcclxuXHJcbiAgICB0cnkge1xyXG5cclxuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHtcclxuICAgICAgICAgICAgYWxwaGE6IF9hbHBoYSxcclxuICAgICAgICAgICAgZGVwdGg6IF9kZXB0aCxcclxuICAgICAgICAgICAgc3RlbmNpbDogX3N0ZW5jaWwsXHJcbiAgICAgICAgICAgIGFudGlhbGlhczogX2FudGlhbGlhcyxcclxuICAgICAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiBfcHJlbXVsdGlwbGllZEFscGhhLFxyXG4gICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IF9wcmVzZXJ2ZURyYXdpbmdCdWZmZXJcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBfZ2wgPSBfY29udGV4dCB8fCBfY2FudmFzLmdldENvbnRleHQoICd3ZWJnbCcsIGF0dHJpYnV0ZXMgKSB8fCBfY2FudmFzLmdldENvbnRleHQoICdleHBlcmltZW50YWwtd2ViZ2wnLCBhdHRyaWJ1dGVzICk7XHJcblxyXG4gICAgICAgIGlmICggX2dsID09PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBfY2FudmFzLmdldENvbnRleHQoICd3ZWJnbCcgKSAhPT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0aHJvdyAnRXJyb3IgY3JlYXRpbmcgV2ViR0wgY29udGV4dCB3aXRoIHlvdXIgc2VsZWN0ZWQgYXR0cmlidXRlcy4nO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0aHJvdyAnRXJyb3IgY3JlYXRpbmcgV2ViR0wgY29udGV4dC4nO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lciggJ3dlYmdsY29udGV4dGxvc3QnLCBvbkNvbnRleHRMb3N0LCBmYWxzZSApO1xyXG5cclxuICAgIH0gY2F0Y2ggKCBlcnJvciApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXI6ICcgKyBlcnJvciApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB2YXIgZXh0ZW5zaW9ucyA9IG5ldyBUSFJFRS5XZWJHTEV4dGVuc2lvbnMoIF9nbCApO1xyXG5cclxuICAgIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXQnICk7XHJcbiAgICBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicgKTtcclxuICAgIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcgKTtcclxuICAgIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXInICk7XHJcbiAgICBleHRlbnNpb25zLmdldCggJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcycgKTtcclxuICAgIGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcclxuXHJcbiAgICBpZiAoIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX2VsZW1lbnRfaW5kZXhfdWludCcgKSApIHtcclxuXHJcbiAgICAgICAgVEhSRUUuQnVmZmVyR2VvbWV0cnkuTWF4SW5kZXggPSA0Mjk0OTY3Mjk2O1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB2YXIgY2FwYWJpbGl0aWVzID0gbmV3IFRIUkVFLldlYkdMQ2FwYWJpbGl0aWVzKCBfZ2wsIGV4dGVuc2lvbnMsIHBhcmFtZXRlcnMgKTtcclxuXHJcbiAgICB2YXIgc3RhdGUgPSBuZXcgVEhSRUUuV2ViR0xTdGF0ZSggX2dsLCBleHRlbnNpb25zLCBwYXJhbVRocmVlVG9HTCApO1xyXG4gICAgdmFyIHByb3BlcnRpZXMgPSBuZXcgVEhSRUUuV2ViR0xQcm9wZXJ0aWVzKCk7XHJcbiAgICB2YXIgb2JqZWN0cyA9IG5ldyBUSFJFRS5XZWJHTE9iamVjdHMoIF9nbCwgcHJvcGVydGllcywgdGhpcy5pbmZvICk7XHJcbiAgICB2YXIgcHJvZ3JhbUNhY2hlID0gbmV3IFRIUkVFLldlYkdMUHJvZ3JhbXMoIHRoaXMsIGNhcGFiaWxpdGllcyApO1xyXG5cclxuICAgIHRoaXMuaW5mby5wcm9ncmFtcyA9IHByb2dyYW1DYWNoZS5wcm9ncmFtcztcclxuXHJcbiAgICB2YXIgYnVmZmVyUmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xCdWZmZXJSZW5kZXJlciggX2dsLCBleHRlbnNpb25zLCBfaW5mb1JlbmRlciApO1xyXG4gICAgdmFyIGluZGV4ZWRCdWZmZXJSZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTEluZGV4ZWRCdWZmZXJSZW5kZXJlciggX2dsLCBleHRlbnNpb25zLCBfaW5mb1JlbmRlciApO1xyXG5cclxuICAgIC8vXHJcblxyXG4gICAgZnVuY3Rpb24gZ2xDbGVhckNvbG9yKCByLCBnLCBiLCBhICkge1xyXG5cclxuICAgICAgICBpZiAoIF9wcmVtdWx0aXBsaWVkQWxwaGEgPT09IHRydWUgKSB7XHJcblxyXG4gICAgICAgICAgICByICo9IGE7IGcgKj0gYTsgYiAqPSBhO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF9nbC5jbGVhckNvbG9yKCByLCBnLCBiLCBhICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldERlZmF1bHRHTFN0YXRlKCkge1xyXG5cclxuICAgICAgICBzdGF0ZS5pbml0KCk7XHJcblxyXG4gICAgICAgIF9nbC52aWV3cG9ydCggX3ZpZXdwb3J0WCwgX3ZpZXdwb3J0WSwgX3ZpZXdwb3J0V2lkdGgsIF92aWV3cG9ydEhlaWdodCApO1xyXG5cclxuICAgICAgICBnbENsZWFyQ29sb3IoIF9jbGVhckNvbG9yLnIsIF9jbGVhckNvbG9yLmcsIF9jbGVhckNvbG9yLmIsIF9jbGVhckFscGhhICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlc2V0R0xTdGF0ZSgpIHtcclxuXHJcbiAgICAgICAgX2N1cnJlbnRQcm9ncmFtID0gbnVsbDtcclxuICAgICAgICBfY3VycmVudENhbWVyYSA9IG51bGw7XHJcblxyXG4gICAgICAgIF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtID0gJyc7XHJcbiAgICAgICAgX2N1cnJlbnRNYXRlcmlhbElkID0gLSAxO1xyXG5cclxuICAgICAgICBfbGlnaHRzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG4gICAgICAgIHN0YXRlLnJlc2V0KCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHNldERlZmF1bHRHTFN0YXRlKCk7XHJcblxyXG4gICAgdGhpcy5jb250ZXh0ID0gX2dsO1xyXG4gICAgdGhpcy5jYXBhYmlsaXRpZXMgPSBjYXBhYmlsaXRpZXM7XHJcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xyXG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xyXG5cclxuICAgIC8vIHNoYWRvdyBtYXBcclxuXHJcbiAgICB2YXIgc2hhZG93TWFwID0gbmV3IFRIUkVFLldlYkdMU2hhZG93TWFwKCB0aGlzLCBsaWdodHMsIG9iamVjdHMgKTtcclxuXHJcbiAgICB0aGlzLnNoYWRvd01hcCA9IHNoYWRvd01hcDtcclxuXHJcblxyXG4gICAgLy8gUGx1Z2luc1xyXG5cclxuICAgIHZhciBzcHJpdGVQbHVnaW4gPSBuZXcgVEhSRUUuU3ByaXRlUGx1Z2luKCB0aGlzLCBzcHJpdGVzICk7XHJcbiAgICB2YXIgbGVuc0ZsYXJlUGx1Z2luID0gbmV3IFRIUkVFLkxlbnNGbGFyZVBsdWdpbiggdGhpcywgbGVuc0ZsYXJlcyApO1xyXG5cclxuICAgIC8vIEFQSVxyXG5cclxuICAgIHRoaXMuZ2V0Q29udGV4dCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIF9nbDtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZ2V0Q29udGV4dEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBfZ2wuZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZm9yY2VDb250ZXh0TG9zcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9sb3NlX2NvbnRleHQnICkubG9zZUNvbnRleHQoKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZ2V0TWF4QW5pc290cm9weSA9ICggZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgdmFsdWU7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBnZXRNYXhBbmlzb3Ryb3B5KCkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkgcmV0dXJuIHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgdmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBfZ2wuZ2V0UGFyYW1ldGVyKCBleHRlbnNpb24uTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhbHVlID0gMDtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0gKSgpO1xyXG5cclxuICAgIHRoaXMuZ2V0UHJlY2lzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gY2FwYWJpbGl0aWVzLnByZWNpc2lvbjtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZ2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHBpeGVsUmF0aW87XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnNldFBpeGVsUmF0aW8gPSBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuICAgICAgICBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSBwaXhlbFJhdGlvID0gdmFsdWU7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmdldFNpemUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHdpZHRoOiBfd2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogX2hlaWdodFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnNldFNpemUgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIHVwZGF0ZVN0eWxlICkge1xyXG5cclxuICAgICAgICBfd2lkdGggPSB3aWR0aDtcclxuICAgICAgICBfaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgICAgICBfY2FudmFzLndpZHRoID0gd2lkdGggKiBwaXhlbFJhdGlvO1xyXG4gICAgICAgIF9jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogcGl4ZWxSYXRpbztcclxuXHJcbiAgICAgICAgaWYgKCB1cGRhdGVTdHlsZSAhPT0gZmFsc2UgKSB7XHJcblxyXG4gICAgICAgICAgICBfY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xyXG4gICAgICAgICAgICBfY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zZXRWaWV3cG9ydCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zZXRWaWV3cG9ydCA9IGZ1bmN0aW9uICggeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcclxuXHJcbiAgICAgICAgX3ZpZXdwb3J0WCA9IHggKiBwaXhlbFJhdGlvO1xyXG4gICAgICAgIF92aWV3cG9ydFkgPSB5ICogcGl4ZWxSYXRpbztcclxuXHJcbiAgICAgICAgX3ZpZXdwb3J0V2lkdGggPSB3aWR0aCAqIHBpeGVsUmF0aW87XHJcbiAgICAgICAgX3ZpZXdwb3J0SGVpZ2h0ID0gaGVpZ2h0ICogcGl4ZWxSYXRpbztcclxuXHJcbiAgICAgICAgX2dsLnZpZXdwb3J0KCBfdmlld3BvcnRYLCBfdmlld3BvcnRZLCBfdmlld3BvcnRXaWR0aCwgX3ZpZXdwb3J0SGVpZ2h0ICk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmdldFZpZXdwb3J0ID0gZnVuY3Rpb24gKCBkaW1lbnNpb25zICkge1xyXG5cclxuICAgICAgICBkaW1lbnNpb25zLnggPSBfdmlld3BvcnRYIC8gcGl4ZWxSYXRpbztcclxuICAgICAgICBkaW1lbnNpb25zLnkgPSBfdmlld3BvcnRZIC8gcGl4ZWxSYXRpbztcclxuXHJcbiAgICAgICAgZGltZW5zaW9ucy56ID0gX3ZpZXdwb3J0V2lkdGggLyBwaXhlbFJhdGlvO1xyXG4gICAgICAgIGRpbWVuc2lvbnMudyA9IF92aWV3cG9ydEhlaWdodCAvIHBpeGVsUmF0aW87XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnNldFNjaXNzb3IgPSBmdW5jdGlvbiAoIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XHJcblxyXG4gICAgICAgIF9nbC5zY2lzc29yKFxyXG4gICAgICAgICAgICB4ICogcGl4ZWxSYXRpbyxcclxuICAgICAgICAgICAgeSAqIHBpeGVsUmF0aW8sXHJcbiAgICAgICAgICAgIHdpZHRoICogcGl4ZWxSYXRpbyxcclxuICAgICAgICAgICAgaGVpZ2h0ICogcGl4ZWxSYXRpb1xyXG4gICAgICAgICk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmVuYWJsZVNjaXNzb3JUZXN0ID0gZnVuY3Rpb24gKCBib29sZWFuICkge1xyXG5cclxuICAgICAgICBzdGF0ZS5zZXRTY2lzc29yVGVzdCggYm9vbGVhbiApO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLy8gQ2xlYXJpbmdcclxuXHJcbiAgICB0aGlzLmdldENsZWFyQ29sb3IgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBfY2xlYXJDb2xvcjtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc2V0Q2xlYXJDb2xvciA9IGZ1bmN0aW9uICggY29sb3IsIGFscGhhICkge1xyXG5cclxuICAgICAgICBfY2xlYXJDb2xvci5zZXQoIGNvbG9yICk7XHJcblxyXG4gICAgICAgIF9jbGVhckFscGhhID0gYWxwaGEgIT09IHVuZGVmaW5lZCA/IGFscGhhIDogMTtcclxuXHJcbiAgICAgICAgZ2xDbGVhckNvbG9yKCBfY2xlYXJDb2xvci5yLCBfY2xlYXJDb2xvci5nLCBfY2xlYXJDb2xvci5iLCBfY2xlYXJBbHBoYSApO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5nZXRDbGVhckFscGhhID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gX2NsZWFyQWxwaGE7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnNldENsZWFyQWxwaGEgPSBmdW5jdGlvbiAoIGFscGhhICkge1xyXG5cclxuICAgICAgICBfY2xlYXJBbHBoYSA9IGFscGhhO1xyXG5cclxuICAgICAgICBnbENsZWFyQ29sb3IoIF9jbGVhckNvbG9yLnIsIF9jbGVhckNvbG9yLmcsIF9jbGVhckNvbG9yLmIsIF9jbGVhckFscGhhICk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmNsZWFyID0gZnVuY3Rpb24gKCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKSB7XHJcblxyXG4gICAgICAgIHZhciBiaXRzID0gMDtcclxuXHJcbiAgICAgICAgaWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkIHx8IGNvbG9yICkgYml0cyB8PSBfZ2wuQ09MT1JfQlVGRkVSX0JJVDtcclxuICAgICAgICBpZiAoIGRlcHRoID09PSB1bmRlZmluZWQgfHwgZGVwdGggKSBiaXRzIHw9IF9nbC5ERVBUSF9CVUZGRVJfQklUO1xyXG4gICAgICAgIGlmICggc3RlbmNpbCA9PT0gdW5kZWZpbmVkIHx8IHN0ZW5jaWwgKSBiaXRzIHw9IF9nbC5TVEVOQ0lMX0JVRkZFUl9CSVQ7XHJcblxyXG4gICAgICAgIF9nbC5jbGVhciggYml0cyApO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5jbGVhckNvbG9yID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICBfZ2wuY2xlYXIoIF9nbC5DT0xPUl9CVUZGRVJfQklUICk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmNsZWFyRGVwdGggPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIF9nbC5jbGVhciggX2dsLkRFUFRIX0JVRkZFUl9CSVQgKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuY2xlYXJTdGVuY2lsID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICBfZ2wuY2xlYXIoIF9nbC5TVEVOQ0lMX0JVRkZFUl9CSVQgKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuY2xlYXJUYXJnZXQgPSBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCwgY29sb3IsIGRlcHRoLCBzdGVuY2lsICkge1xyXG5cclxuICAgICAgICB0aGlzLnNldFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XHJcbiAgICAgICAgdGhpcy5jbGVhciggY29sb3IsIGRlcHRoLCBzdGVuY2lsICk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBSZXNldFxyXG5cclxuICAgIHRoaXMucmVzZXRHTFN0YXRlID0gcmVzZXRHTFN0YXRlO1xyXG5cclxuICAgIHRoaXMuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICBfY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoICd3ZWJnbGNvbnRleHRsb3N0Jywgb25Db250ZXh0TG9zdCwgZmFsc2UgKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEV2ZW50c1xyXG5cclxuICAgIGZ1bmN0aW9uIG9uQ29udGV4dExvc3QoIGV2ZW50ICkge1xyXG5cclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICByZXNldEdMU3RhdGUoKTtcclxuICAgICAgICBzZXREZWZhdWx0R0xTdGF0ZSgpO1xyXG5cclxuICAgICAgICBwcm9wZXJ0aWVzLmNsZWFyKCk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBvblRleHR1cmVEaXNwb3NlKCBldmVudCApIHtcclxuXHJcbiAgICAgICAgdmFyIHRleHR1cmUgPSBldmVudC50YXJnZXQ7XHJcblxyXG4gICAgICAgIHRleHR1cmUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XHJcblxyXG4gICAgICAgIGRlYWxsb2NhdGVUZXh0dXJlKCB0ZXh0dXJlICk7XHJcblxyXG4gICAgICAgIF9pbmZvTWVtb3J5LnRleHR1cmVzIC0tO1xyXG5cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gb25SZW5kZXJUYXJnZXREaXNwb3NlKCBldmVudCApIHtcclxuXHJcbiAgICAgICAgdmFyIHJlbmRlclRhcmdldCA9IGV2ZW50LnRhcmdldDtcclxuXHJcbiAgICAgICAgcmVuZGVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25SZW5kZXJUYXJnZXREaXNwb3NlICk7XHJcblxyXG4gICAgICAgIGRlYWxsb2NhdGVSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApO1xyXG5cclxuICAgICAgICBfaW5mb01lbW9yeS50ZXh0dXJlcyAtLTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gb25NYXRlcmlhbERpc3Bvc2UoIGV2ZW50ICkge1xyXG5cclxuICAgICAgICB2YXIgbWF0ZXJpYWwgPSBldmVudC50YXJnZXQ7XHJcblxyXG4gICAgICAgIG1hdGVyaWFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25NYXRlcmlhbERpc3Bvc2UgKTtcclxuXHJcbiAgICAgICAgZGVhbGxvY2F0ZU1hdGVyaWFsKCBtYXRlcmlhbCApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBCdWZmZXIgZGVhbGxvY2F0aW9uXHJcblxyXG4gICAgZnVuY3Rpb24gZGVhbGxvY2F0ZVRleHR1cmUoIHRleHR1cmUgKSB7XHJcblxyXG4gICAgICAgIHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICk7XHJcblxyXG4gICAgICAgIGlmICggdGV4dHVyZS5pbWFnZSAmJiB0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlICkge1xyXG5cclxuICAgICAgICAgICAgLy8gY3ViZSB0ZXh0dXJlXHJcblxyXG4gICAgICAgICAgICBfZ2wuZGVsZXRlVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSApO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgLy8gMkQgdGV4dHVyZVxyXG5cclxuICAgICAgICAgICAgaWYgKCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsSW5pdCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgX2dsLmRlbGV0ZVRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcmVtb3ZlIGFsbCB3ZWJnbCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgcHJvcGVydGllcy5kZWxldGUoIHRleHR1cmUgKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGVhbGxvY2F0ZVJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuICAgICAgICB2YXIgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcclxuICAgICAgICB2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKTtcclxuXHJcbiAgICAgICAgaWYgKCAhIHJlbmRlclRhcmdldCB8fCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xyXG5cclxuICAgICAgICBfZ2wuZGVsZXRlVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcclxuXHJcbiAgICAgICAgaWYgKCByZW5kZXJUYXJnZXQgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIF9nbC5kZWxldGVGcmFtZWJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSApO1xyXG4gICAgICAgICAgICAgICAgX2dsLmRlbGV0ZVJlbmRlcmJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsUmVuZGVyYnVmZmVyWyBpIF0gKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIF9nbC5kZWxldGVGcmFtZWJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgKTtcclxuICAgICAgICAgICAgX2dsLmRlbGV0ZVJlbmRlcmJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsUmVuZGVyYnVmZmVyICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJvcGVydGllcy5kZWxldGUoIHJlbmRlclRhcmdldC50ZXh0dXJlICk7XHJcbiAgICAgICAgcHJvcGVydGllcy5kZWxldGUoIHJlbmRlclRhcmdldCApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkZWFsbG9jYXRlTWF0ZXJpYWwoIG1hdGVyaWFsICkge1xyXG5cclxuICAgICAgICByZWxlYXNlTWF0ZXJpYWxQcm9ncmFtUmVmZXJlbmNlKCBtYXRlcmlhbCApO1xyXG5cclxuICAgICAgICBwcm9wZXJ0aWVzLmRlbGV0ZSggbWF0ZXJpYWwgKTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIHJlbGVhc2VNYXRlcmlhbFByb2dyYW1SZWZlcmVuY2UoIG1hdGVyaWFsICkge1xyXG5cclxuICAgICAgICB2YXIgcHJvZ3JhbUluZm8gPSBwcm9wZXJ0aWVzLmdldCggbWF0ZXJpYWwgKS5wcm9ncmFtO1xyXG5cclxuICAgICAgICBtYXRlcmlhbC5wcm9ncmFtID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICBpZiAoIHByb2dyYW1JbmZvICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBwcm9ncmFtQ2FjaGUucmVsZWFzZVByb2dyYW0oIHByb2dyYW1JbmZvICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gQnVmZmVyIHJlbmRlcmluZ1xyXG5cclxuICAgIHRoaXMucmVuZGVyQnVmZmVySW1tZWRpYXRlID0gZnVuY3Rpb24gKCBvYmplY3QsIHByb2dyYW0sIG1hdGVyaWFsICkge1xyXG5cclxuICAgICAgICBzdGF0ZS5pbml0QXR0cmlidXRlcygpO1xyXG5cclxuICAgICAgICB2YXIgYnVmZmVycyA9IHByb3BlcnRpZXMuZ2V0KCBvYmplY3QgKTtcclxuXHJcbiAgICAgICAgaWYgKCBvYmplY3QuaGFzUG9zaXRpb25zICYmICEgYnVmZmVycy5wb3NpdGlvbiApIGJ1ZmZlcnMucG9zaXRpb24gPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgICAgaWYgKCBvYmplY3QuaGFzTm9ybWFscyAmJiAhIGJ1ZmZlcnMubm9ybWFsICkgYnVmZmVycy5ub3JtYWwgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgICAgaWYgKCBvYmplY3QuaGFzVXZzICYmICEgYnVmZmVycy51diApIGJ1ZmZlcnMudXYgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgICAgaWYgKCBvYmplY3QuaGFzQ29sb3JzICYmICEgYnVmZmVycy5jb2xvciApIGJ1ZmZlcnMuY29sb3IgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblxyXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gcHJvZ3JhbS5nZXRBdHRyaWJ1dGVzKCk7XHJcblxyXG4gICAgICAgIGlmICggb2JqZWN0Lmhhc1Bvc2l0aW9ucyApIHtcclxuXHJcbiAgICAgICAgICAgIF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJzLnBvc2l0aW9uICk7XHJcbiAgICAgICAgICAgIF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QucG9zaXRpb25BcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xyXG5cclxuICAgICAgICAgICAgc3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICk7XHJcbiAgICAgICAgICAgIF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnBvc2l0aW9uLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBvYmplY3QuaGFzTm9ybWFscyApIHtcclxuXHJcbiAgICAgICAgICAgIF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJzLm5vcm1hbCApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBtYXRlcmlhbC50eXBlICE9PSAnTWVzaFBob25nTWF0ZXJpYWwnICYmIG1hdGVyaWFsLnNoYWRpbmcgPT09IFRIUkVFLkZsYXRTaGFkaW5nICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IG9iamVjdC5jb3VudCAqIDM7IGkgPCBsOyBpICs9IDkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJheSA9IG9iamVjdC5ub3JtYWxBcnJheTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG54ID0gKCBhcnJheVsgaSArIDAgXSArIGFycmF5WyBpICsgMyBdICsgYXJyYXlbIGkgKyA2IF0gKSAvIDM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG55ID0gKCBhcnJheVsgaSArIDEgXSArIGFycmF5WyBpICsgNCBdICsgYXJyYXlbIGkgKyA3IF0gKSAvIDM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG56ID0gKCBhcnJheVsgaSArIDIgXSArIGFycmF5WyBpICsgNSBdICsgYXJyYXlbIGkgKyA4IF0gKSAvIDM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5WyBpICsgMCBdID0gbng7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbIGkgKyAxIF0gPSBueTtcclxuICAgICAgICAgICAgICAgICAgICBhcnJheVsgaSArIDIgXSA9IG56O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBhcnJheVsgaSArIDMgXSA9IG54O1xyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5WyBpICsgNCBdID0gbnk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbIGkgKyA1IF0gPSBuejtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbIGkgKyA2IF0gPSBueDtcclxuICAgICAgICAgICAgICAgICAgICBhcnJheVsgaSArIDcgXSA9IG55O1xyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5WyBpICsgOCBdID0gbno7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgX2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5ub3JtYWxBcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xyXG5cclxuICAgICAgICAgICAgc3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLm5vcm1hbCApO1xyXG5cclxuICAgICAgICAgICAgX2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMubm9ybWFsLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBvYmplY3QuaGFzVXZzICYmIG1hdGVyaWFsLm1hcCApIHtcclxuXHJcbiAgICAgICAgICAgIF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJzLnV2ICk7XHJcbiAgICAgICAgICAgIF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QudXZBcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xyXG5cclxuICAgICAgICAgICAgc3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnV2ICk7XHJcblxyXG4gICAgICAgICAgICBfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy51diwgMiwgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggb2JqZWN0Lmhhc0NvbG9ycyAmJiBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgIT09IFRIUkVFLk5vQ29sb3JzICkge1xyXG5cclxuICAgICAgICAgICAgX2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcnMuY29sb3IgKTtcclxuICAgICAgICAgICAgX2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5jb2xvckFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XHJcblxyXG4gICAgICAgICAgICBzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMuY29sb3IgKTtcclxuXHJcbiAgICAgICAgICAgIF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLmNvbG9yLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhdGUuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcclxuXHJcbiAgICAgICAgX2dsLmRyYXdBcnJheXMoIF9nbC5UUklBTkdMRVMsIDAsIG9iamVjdC5jb3VudCApO1xyXG5cclxuICAgICAgICBvYmplY3QuY291bnQgPSAwO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5yZW5kZXJCdWZmZXJEaXJlY3QgPSBmdW5jdGlvbiAoIGNhbWVyYSwgbGlnaHRzLCBmb2csIGdlb21ldHJ5LCBtYXRlcmlhbCwgb2JqZWN0LCBncm91cCApIHtcclxuXHJcbiAgICAgICAgc2V0TWF0ZXJpYWwoIG1hdGVyaWFsICk7XHJcblxyXG4gICAgICAgIHZhciBwcm9ncmFtID0gc2V0UHJvZ3JhbSggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApO1xyXG5cclxuICAgICAgICB2YXIgdXBkYXRlQnVmZmVycyA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBnZW9tZXRyeVByb2dyYW0gPSBnZW9tZXRyeS5pZCArICdfJyArIHByb2dyYW0uaWQgKyAnXycgKyBtYXRlcmlhbC53aXJlZnJhbWU7XHJcblxyXG4gICAgICAgIGlmICggZ2VvbWV0cnlQcm9ncmFtICE9PSBfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSApIHtcclxuXHJcbiAgICAgICAgICAgIF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtID0gZ2VvbWV0cnlQcm9ncmFtO1xyXG4gICAgICAgICAgICB1cGRhdGVCdWZmZXJzID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBtb3JwaCB0YXJnZXRzXHJcblxyXG4gICAgICAgIHZhciBtb3JwaFRhcmdldEluZmx1ZW5jZXMgPSBvYmplY3QubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xyXG5cclxuICAgICAgICBpZiAoIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGFjdGl2ZUluZmx1ZW5jZXMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IG1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBpbmZsdWVuY2UgPSBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXTtcclxuICAgICAgICAgICAgICAgIGFjdGl2ZUluZmx1ZW5jZXMucHVzaCggWyBpbmZsdWVuY2UsIGkgXSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYWN0aXZlSW5mbHVlbmNlcy5zb3J0KCBudW1lcmljYWxTb3J0ICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGFjdGl2ZUluZmx1ZW5jZXMubGVuZ3RoID4gOCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBhY3RpdmVJbmZsdWVuY2VzLmxlbmd0aCA9IDg7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgbW9ycGhBdHRyaWJ1dGVzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzO1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gYWN0aXZlSW5mbHVlbmNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBpbmZsdWVuY2UgPSBhY3RpdmVJbmZsdWVuY2VzWyBpIF07XHJcbiAgICAgICAgICAgICAgICBtb3JwaEluZmx1ZW5jZXNbIGkgXSA9IGluZmx1ZW5jZVsgMCBdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggaW5mbHVlbmNlWyAwIF0gIT09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGluZmx1ZW5jZVsgMSBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyA9PT0gdHJ1ZSAmJiBtb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gKSBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdtb3JwaFRhcmdldCcgKyBpLCBtb3JwaEF0dHJpYnV0ZXMucG9zaXRpb25bIGluZGV4IF0gKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGVyaWFsLm1vcnBoTm9ybWFscyA9PT0gdHJ1ZSAmJiBtb3JwaEF0dHJpYnV0ZXMubm9ybWFsICkgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnbW9ycGhOb3JtYWwnICsgaSwgbW9ycGhBdHRyaWJ1dGVzLm5vcm1hbFsgaW5kZXggXSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggbWF0ZXJpYWwubW9ycGhUYXJnZXRzID09PSB0cnVlICkgZ2VvbWV0cnkucmVtb3ZlQXR0cmlidXRlKCAnbW9ycGhUYXJnZXQnICsgaSApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggbWF0ZXJpYWwubW9ycGhOb3JtYWxzID09PSB0cnVlICkgZ2VvbWV0cnkucmVtb3ZlQXR0cmlidXRlKCAnbW9ycGhOb3JtYWwnICsgaSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB1bmlmb3JtcyA9IHByb2dyYW0uZ2V0VW5pZm9ybXMoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggdW5pZm9ybXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzICE9PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtMWZ2KCB1bmlmb3Jtcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMsIG1vcnBoSW5mbHVlbmNlcyApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdXBkYXRlQnVmZmVycyA9IHRydWU7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9cclxuXHJcbiAgICAgICAgdmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuXHJcbiAgICAgICAgaWYgKCBtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWUgKSB7XHJcblxyXG4gICAgICAgICAgICBpbmRleCA9IG9iamVjdHMuZ2V0V2lyZWZyYW1lQXR0cmlidXRlKCBnZW9tZXRyeSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciByZW5kZXJlcjtcclxuXHJcbiAgICAgICAgaWYgKCBpbmRleCAhPT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgIHJlbmRlcmVyID0gaW5kZXhlZEJ1ZmZlclJlbmRlcmVyO1xyXG4gICAgICAgICAgICByZW5kZXJlci5zZXRJbmRleCggaW5kZXggKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIHJlbmRlcmVyID0gYnVmZmVyUmVuZGVyZXI7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCB1cGRhdGVCdWZmZXJzICkge1xyXG5cclxuICAgICAgICAgICAgc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnkgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggaW5kZXggIT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgX2dsLmJpbmRCdWZmZXIoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgb2JqZWN0cy5nZXRBdHRyaWJ1dGVCdWZmZXIoIGluZGV4ICkgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL1xyXG5cclxuICAgICAgICB2YXIgZGF0YVN0YXJ0ID0gMDtcclxuICAgICAgICB2YXIgZGF0YUNvdW50ID0gSW5maW5pdHk7XHJcblxyXG4gICAgICAgIGlmICggaW5kZXggIT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICBkYXRhQ291bnQgPSBpbmRleC5jb3VudFxyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCBwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgZGF0YUNvdW50ID0gcG9zaXRpb24uY291bnQ7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHJhbmdlU3RhcnQgPSBnZW9tZXRyeS5kcmF3UmFuZ2Uuc3RhcnQ7XHJcbiAgICAgICAgdmFyIHJhbmdlQ291bnQgPSBnZW9tZXRyeS5kcmF3UmFuZ2UuY291bnQ7XHJcblxyXG4gICAgICAgIHZhciBncm91cFN0YXJ0ID0gZ3JvdXAgIT09IG51bGwgPyBncm91cC5zdGFydCA6IDA7XHJcbiAgICAgICAgdmFyIGdyb3VwQ291bnQgPSBncm91cCAhPT0gbnVsbCA/IGdyb3VwLmNvdW50IDogSW5maW5pdHk7XHJcblxyXG4gICAgICAgIHZhciBkcmF3U3RhcnQgPSBNYXRoLm1heCggZGF0YVN0YXJ0LCByYW5nZVN0YXJ0LCBncm91cFN0YXJ0ICk7XHJcbiAgICAgICAgdmFyIGRyYXdFbmQgPSBNYXRoLm1pbiggZGF0YVN0YXJ0ICsgZGF0YUNvdW50LCByYW5nZVN0YXJ0ICsgcmFuZ2VDb3VudCwgZ3JvdXBTdGFydCArIGdyb3VwQ291bnQgKSAtIDE7XHJcblxyXG4gICAgICAgIHZhciBkcmF3Q291bnQgPSBNYXRoLm1heCggMCwgZHJhd0VuZCAtIGRyYXdTdGFydCArIDEgKTtcclxuXHJcbiAgICAgICAgLy9cclxuXHJcbiAgICAgICAgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgc3RhdGUuc2V0TGluZVdpZHRoKCBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggKiBwaXhlbFJhdGlvICk7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlci5zZXRNb2RlKCBfZ2wuTElORVMgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuc2V0TW9kZSggX2dsLlRSSUFOR0xFUyApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ICYmIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID4gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZW5kZXJlci5yZW5kZXJJbnN0YW5jZXMoIGdlb21ldHJ5ICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlciggZHJhd1N0YXJ0LCBkcmF3Q291bnQgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZSApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSBtYXRlcmlhbC5saW5ld2lkdGg7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGxpbmVXaWR0aCA9PT0gdW5kZWZpbmVkICkgbGluZVdpZHRoID0gMTsgLy8gTm90IHVzaW5nIExpbmUqTWF0ZXJpYWxcclxuXHJcbiAgICAgICAgICAgIHN0YXRlLnNldExpbmVXaWR0aCggbGluZVdpZHRoICogcGl4ZWxSYXRpbyApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lU2VnbWVudHMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuc2V0TW9kZSggX2dsLkxJTkVTICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnNldE1vZGUoIF9nbC5MSU5FX1NUUklQICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZW5kZXJlci5yZW5kZXIoIGRyYXdTdGFydCwgZHJhd0NvdW50ICk7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50cyApIHtcclxuXHJcbiAgICAgICAgICAgIHJlbmRlcmVyLnNldE1vZGUoIF9nbC5QT0lOVFMgKTtcclxuICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyKCBkcmF3U3RhcnQsIGRyYXdDb3VudCApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBzZXR1cFZlcnRleEF0dHJpYnV0ZXMoIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSwgc3RhcnRJbmRleCApIHtcclxuXHJcbiAgICAgICAgdmFyIGV4dGVuc2lvbjtcclxuXHJcbiAgICAgICAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ICkge1xyXG5cclxuICAgICAgICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBleHRlbnNpb24gPT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIuc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nICk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBzdGFydEluZGV4ID09PSB1bmRlZmluZWQgKSBzdGFydEluZGV4ID0gMDtcclxuXHJcbiAgICAgICAgc3RhdGUuaW5pdEF0dHJpYnV0ZXMoKTtcclxuXHJcbiAgICAgICAgdmFyIGdlb21ldHJ5QXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XHJcblxyXG4gICAgICAgIHZhciBwcm9ncmFtQXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xyXG5cclxuICAgICAgICB2YXIgbWF0ZXJpYWxEZWZhdWx0QXR0cmlidXRlVmFsdWVzID0gbWF0ZXJpYWwuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcztcclxuXHJcbiAgICAgICAgZm9yICggdmFyIG5hbWUgaW4gcHJvZ3JhbUF0dHJpYnV0ZXMgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgcHJvZ3JhbUF0dHJpYnV0ZSA9IHByb2dyYW1BdHRyaWJ1dGVzWyBuYW1lIF07XHJcblxyXG4gICAgICAgICAgICBpZiAoIHByb2dyYW1BdHRyaWJ1dGUgPj0gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZ2VvbWV0cnlBdHRyaWJ1dGUgPSBnZW9tZXRyeUF0dHJpYnV0ZXNbIG5hbWUgXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGdlb21ldHJ5QXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaXplID0gZ2VvbWV0cnlBdHRyaWJ1dGUuaXRlbVNpemU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IG9iamVjdHMuZ2V0QXR0cmlidXRlQnVmZmVyKCBnZW9tZXRyeUF0dHJpYnV0ZSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGdlb21ldHJ5QXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGdlb21ldHJ5QXR0cmlidXRlLmRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHJpZGUgPSBkYXRhLnN0cmlkZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IGdlb21ldHJ5QXR0cmlidXRlLm9mZnNldDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZGF0YSBpbnN0YW5jZW9mIFRIUkVFLkluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IoIHByb2dyYW1BdHRyaWJ1dGUsIGRhdGEubWVzaFBlckF0dHJpYnV0ZSwgZXh0ZW5zaW9uICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA9IGRhdGEubWVzaFBlckF0dHJpYnV0ZSAqIGRhdGEuY291bnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIHByb2dyYW1BdHRyaWJ1dGUgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIHByb2dyYW1BdHRyaWJ1dGUsIHNpemUsIF9nbC5GTE9BVCwgZmFsc2UsIHN0cmlkZSAqIGRhdGEuYXJyYXkuQllURVNfUEVSX0VMRU1FTlQsICggc3RhcnRJbmRleCAqIHN0cmlkZSArIG9mZnNldCApICogZGF0YS5hcnJheS5CWVRFU19QRVJfRUxFTUVOVCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBnZW9tZXRyeUF0dHJpYnV0ZSBpbnN0YW5jZW9mIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5lbmFibGVBdHRyaWJ1dGVBbmREaXZpc29yKCBwcm9ncmFtQXR0cmlidXRlLCBnZW9tZXRyeUF0dHJpYnV0ZS5tZXNoUGVyQXR0cmlidXRlLCBleHRlbnNpb24gKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID0gZ2VvbWV0cnlBdHRyaWJ1dGUubWVzaFBlckF0dHJpYnV0ZSAqIGdlb21ldHJ5QXR0cmlidXRlLmNvdW50O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuZW5hYmxlQXR0cmlidXRlKCBwcm9ncmFtQXR0cmlidXRlICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgYnVmZmVyICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBwcm9ncmFtQXR0cmlidXRlLCBzaXplLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCBzdGFydEluZGV4ICogc2l6ZSAqIDQgKTsgLy8gNCBieXRlcyBwZXIgRmxvYXQzMlxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggbWF0ZXJpYWxEZWZhdWx0QXR0cmlidXRlVmFsdWVzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlc1sgbmFtZSBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKCB2YWx1ZS5sZW5ndGggKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9nbC52ZXJ0ZXhBdHRyaWIyZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9nbC52ZXJ0ZXhBdHRyaWIzZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9nbC52ZXJ0ZXhBdHRyaWI0ZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZ2wudmVydGV4QXR0cmliMWZ2KCBwcm9ncmFtQXR0cmlidXRlLCB2YWx1ZSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXRlLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vIFNvcnRpbmdcclxuXHJcbiAgICBmdW5jdGlvbiBudW1lcmljYWxTb3J0ICggYSwgYiApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIGJbIDAgXSAtIGFbIDAgXTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGFpbnRlclNvcnRTdGFibGUgKCBhLCBiICkge1xyXG5cclxuICAgICAgICBpZiAoIGEub2JqZWN0LnJlbmRlck9yZGVyICE9PSBiLm9iamVjdC5yZW5kZXJPcmRlciApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBhLm9iamVjdC5yZW5kZXJPcmRlciAtIGIub2JqZWN0LnJlbmRlck9yZGVyO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCBhLm1hdGVyaWFsLmlkICE9PSBiLm1hdGVyaWFsLmlkICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGEubWF0ZXJpYWwuaWQgLSBiLm1hdGVyaWFsLmlkO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCBhLnogIT09IGIueiApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBhLnogLSBiLno7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYS5pZCAtIGIuaWQ7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmV2ZXJzZVBhaW50ZXJTb3J0U3RhYmxlICggYSwgYiApIHtcclxuXHJcbiAgICAgICAgaWYgKCBhLm9iamVjdC5yZW5kZXJPcmRlciAhPT0gYi5vYmplY3QucmVuZGVyT3JkZXIgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYS5vYmplY3QucmVuZGVyT3JkZXIgLSBiLm9iamVjdC5yZW5kZXJPcmRlcjtcclxuXHJcbiAgICAgICAgfSBpZiAoIGEueiAhPT0gYi56ICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGIueiAtIGEuejtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBhLmlkIC0gYi5pZDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW5kZXJpbmdcclxuXHJcbiAgICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSwgcmVuZGVyVGFyZ2V0LCBmb3JjZUNsZWFyICkge1xyXG5cclxuICAgICAgICBpZiAoIGNhbWVyYSBpbnN0YW5jZW9mIFRIUkVFLkNhbWVyYSA9PT0gZmFsc2UgKSB7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZW5kZXI6IGNhbWVyYSBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuQ2FtZXJhLicgKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBmb2cgPSBzY2VuZS5mb2c7XHJcblxyXG4gICAgICAgIC8vIHJlc2V0IGNhY2hpbmcgZm9yIHRoaXMgZnJhbWVcclxuXHJcbiAgICAgICAgX2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSAnJztcclxuICAgICAgICBfY3VycmVudE1hdGVyaWFsSWQgPSAtIDE7XHJcbiAgICAgICAgX2N1cnJlbnRDYW1lcmEgPSBudWxsO1xyXG4gICAgICAgIF9saWdodHNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIHNjZW5lIGdyYXBoXHJcblxyXG4gICAgICAgIGlmICggc2NlbmUuYXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHNjZW5lLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSBjYW1lcmEgbWF0cmljZXMgYW5kIGZydXN0dW1cclxuXHJcbiAgICAgICAgaWYgKCBjYW1lcmEucGFyZW50ID09PSBudWxsICkgY2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblxyXG4gICAgICAgIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UuZ2V0SW52ZXJzZSggY2FtZXJhLm1hdHJpeFdvcmxkICk7XHJcblxyXG4gICAgICAgIF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XHJcbiAgICAgICAgX2ZydXN0dW0uc2V0RnJvbU1hdHJpeCggX3Byb2pTY3JlZW5NYXRyaXggKTtcclxuXHJcbiAgICAgICAgbGlnaHRzLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgIG9wYXF1ZU9iamVjdHNMYXN0SW5kZXggPSAtIDE7XHJcbiAgICAgICAgdHJhbnNwYXJlbnRPYmplY3RzTGFzdEluZGV4ID0gLSAxO1xyXG5cclxuICAgICAgICBzcHJpdGVzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgbGVuc0ZsYXJlcy5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICBwcm9qZWN0T2JqZWN0KCBzY2VuZSwgY2FtZXJhICk7XHJcblxyXG4gICAgICAgIG9wYXF1ZU9iamVjdHMubGVuZ3RoID0gb3BhcXVlT2JqZWN0c0xhc3RJbmRleCArIDE7XHJcbiAgICAgICAgdHJhbnNwYXJlbnRPYmplY3RzLmxlbmd0aCA9IHRyYW5zcGFyZW50T2JqZWN0c0xhc3RJbmRleCArIDE7XHJcblxyXG4gICAgICAgIGlmICggX3RoaXMuc29ydE9iamVjdHMgPT09IHRydWUgKSB7XHJcblxyXG4gICAgICAgICAgICBvcGFxdWVPYmplY3RzLnNvcnQoIHBhaW50ZXJTb3J0U3RhYmxlICk7XHJcbiAgICAgICAgICAgIHRyYW5zcGFyZW50T2JqZWN0cy5zb3J0KCByZXZlcnNlUGFpbnRlclNvcnRTdGFibGUgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL1xyXG5cclxuICAgICAgICBzaGFkb3dNYXAucmVuZGVyKCBzY2VuZSApO1xyXG5cclxuICAgICAgICAvL1xyXG5cclxuICAgICAgICBfaW5mb1JlbmRlci5jYWxscyA9IDA7XHJcbiAgICAgICAgX2luZm9SZW5kZXIudmVydGljZXMgPSAwO1xyXG4gICAgICAgIF9pbmZvUmVuZGVyLmZhY2VzID0gMDtcclxuICAgICAgICBfaW5mb1JlbmRlci5wb2ludHMgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLnNldFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5hdXRvQ2xlYXIgfHwgZm9yY2VDbGVhciApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY2xlYXIoIHRoaXMuYXV0b0NsZWFyQ29sb3IsIHRoaXMuYXV0b0NsZWFyRGVwdGgsIHRoaXMuYXV0b0NsZWFyU3RlbmNpbCApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vXHJcblxyXG4gICAgICAgIGlmICggc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBvdmVycmlkZU1hdGVyaWFsID0gc2NlbmUub3ZlcnJpZGVNYXRlcmlhbDtcclxuXHJcbiAgICAgICAgICAgIHJlbmRlck9iamVjdHMoIG9wYXF1ZU9iamVjdHMsIGNhbWVyYSwgbGlnaHRzLCBmb2csIG92ZXJyaWRlTWF0ZXJpYWwgKTtcclxuICAgICAgICAgICAgcmVuZGVyT2JqZWN0cyggdHJhbnNwYXJlbnRPYmplY3RzLCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBvdmVycmlkZU1hdGVyaWFsICk7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAvLyBvcGFxdWUgcGFzcyAoZnJvbnQtdG8tYmFjayBvcmRlcilcclxuXHJcbiAgICAgICAgICAgIHN0YXRlLnNldEJsZW5kaW5nKCBUSFJFRS5Ob0JsZW5kaW5nICk7XHJcbiAgICAgICAgICAgIHJlbmRlck9iamVjdHMoIG9wYXF1ZU9iamVjdHMsIGNhbWVyYSwgbGlnaHRzLCBmb2cgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHRyYW5zcGFyZW50IHBhc3MgKGJhY2stdG8tZnJvbnQgb3JkZXIpXHJcblxyXG4gICAgICAgICAgICByZW5kZXJPYmplY3RzKCB0cmFuc3BhcmVudE9iamVjdHMsIGNhbWVyYSwgbGlnaHRzLCBmb2cgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjdXN0b20gcmVuZGVyIHBsdWdpbnMgKHBvc3QgcGFzcylcclxuXHJcbiAgICAgICAgc3ByaXRlUGx1Z2luLnJlbmRlciggc2NlbmUsIGNhbWVyYSApO1xyXG4gICAgICAgIGxlbnNGbGFyZVBsdWdpbi5yZW5kZXIoIHNjZW5lLCBjYW1lcmEsIF9jdXJyZW50V2lkdGgsIF9jdXJyZW50SGVpZ2h0ICk7XHJcblxyXG4gICAgICAgIC8vIEdlbmVyYXRlIG1pcG1hcCBpZiB3ZSdyZSB1c2luZyBhbnkga2luZCBvZiBtaXBtYXAgZmlsdGVyaW5nXHJcblxyXG4gICAgICAgIGlmICggcmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHRleHR1cmUgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcclxuICAgICAgICAgICAgdmFyIGlzVGFyZ2V0UG93ZXJPZlR3byA9IGlzUG93ZXJPZlR3byggcmVuZGVyVGFyZ2V0ICk7XHJcbiAgICAgICAgICAgIGlmICggdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgJiYgaXNUYXJnZXRQb3dlck9mVHdvICYmIHRleHR1cmUubWluRmlsdGVyICE9PSBUSFJFRS5OZWFyZXN0RmlsdGVyICYmIHRleHR1cmUubWluRmlsdGVyICE9PSBUSFJFRS5MaW5lYXJGaWx0ZXIgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwKCByZW5kZXJUYXJnZXQgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFbnN1cmUgZGVwdGggYnVmZmVyIHdyaXRpbmcgaXMgZW5hYmxlZCBzbyBpdCBjYW4gYmUgY2xlYXJlZCBvbiBuZXh0IHJlbmRlclxyXG5cclxuICAgICAgICBzdGF0ZS5zZXREZXB0aFRlc3QoIHRydWUgKTtcclxuICAgICAgICBzdGF0ZS5zZXREZXB0aFdyaXRlKCB0cnVlICk7XHJcbiAgICAgICAgc3RhdGUuc2V0Q29sb3JXcml0ZSggdHJ1ZSApO1xyXG5cclxuICAgICAgICAvLyBfZ2wuZmluaXNoKCk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBwdXNoUmVuZGVySXRlbSggb2JqZWN0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHosIGdyb3VwICkge1xyXG5cclxuICAgICAgICB2YXIgYXJyYXksIGluZGV4O1xyXG5cclxuICAgICAgICAvLyBhbGxvY2F0ZSB0aGUgbmV4dCBwb3NpdGlvbiBpbiB0aGUgYXBwcm9wcmlhdGUgYXJyYXlcclxuXHJcbiAgICAgICAgaWYgKCBtYXRlcmlhbC50cmFuc3BhcmVudCApIHtcclxuXHJcbiAgICAgICAgICAgIGFycmF5ID0gdHJhbnNwYXJlbnRPYmplY3RzO1xyXG4gICAgICAgICAgICBpbmRleCA9ICsrIHRyYW5zcGFyZW50T2JqZWN0c0xhc3RJbmRleDtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIGFycmF5ID0gb3BhcXVlT2JqZWN0cztcclxuICAgICAgICAgICAgaW5kZXggPSArKyBvcGFxdWVPYmplY3RzTGFzdEluZGV4O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJlY3ljbGUgZXhpc3RpbmcgcmVuZGVyIGl0ZW0gb3IgZ3JvdyB0aGUgYXJyYXlcclxuXHJcbiAgICAgICAgdmFyIHJlbmRlckl0ZW0gPSBhcnJheVsgaW5kZXggXTtcclxuXHJcbiAgICAgICAgaWYgKCByZW5kZXJJdGVtICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICByZW5kZXJJdGVtLmlkID0gb2JqZWN0LmlkO1xyXG4gICAgICAgICAgICByZW5kZXJJdGVtLm9iamVjdCA9IG9iamVjdDtcclxuICAgICAgICAgICAgcmVuZGVySXRlbS5nZW9tZXRyeSA9IGdlb21ldHJ5O1xyXG4gICAgICAgICAgICByZW5kZXJJdGVtLm1hdGVyaWFsID0gbWF0ZXJpYWw7XHJcbiAgICAgICAgICAgIHJlbmRlckl0ZW0ueiA9IF92ZWN0b3IzLno7XHJcbiAgICAgICAgICAgIHJlbmRlckl0ZW0uZ3JvdXAgPSBncm91cDtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIHJlbmRlckl0ZW0gPSB7XHJcbiAgICAgICAgICAgICAgICBpZDogb2JqZWN0LmlkLFxyXG4gICAgICAgICAgICAgICAgb2JqZWN0OiBvYmplY3QsXHJcbiAgICAgICAgICAgICAgICBnZW9tZXRyeTogZ2VvbWV0cnksXHJcbiAgICAgICAgICAgICAgICBtYXRlcmlhbDogbWF0ZXJpYWwsXHJcbiAgICAgICAgICAgICAgICB6OiBfdmVjdG9yMy56LFxyXG4gICAgICAgICAgICAgICAgZ3JvdXA6IGdyb3VwXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvLyBhc3NlcnQoIGluZGV4ID09PSBhcnJheS5sZW5ndGggKTtcclxuICAgICAgICAgICAgYXJyYXkucHVzaCggcmVuZGVySXRlbSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHByb2plY3RPYmplY3QoIG9iamVjdCwgY2FtZXJhICkge1xyXG5cclxuICAgICAgICBpZiAoIG9iamVjdC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKCAoIG9iamVjdC5jaGFubmVscy5tYXNrICYgY2FtZXJhLmNoYW5uZWxzLm1hc2sgKSAhPT0gMCApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGlnaHQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgbGlnaHRzLnB1c2goIG9iamVjdCApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU3ByaXRlICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHNwcml0ZXMucHVzaCggb2JqZWN0ICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MZW5zRmxhcmUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgbGVuc0ZsYXJlcy5wdXNoKCBvYmplY3QgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkltbWVkaWF0ZVJlbmRlck9iamVjdCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIF90aGlzLnNvcnRPYmplY3RzID09PSB0cnVlICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG9iamVjdC5tYXRyaXhXb3JsZCApO1xyXG4gICAgICAgICAgICAgICAgICAgIF92ZWN0b3IzLmFwcGx5UHJvamVjdGlvbiggX3Byb2pTY3JlZW5NYXRyaXggKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcHVzaFJlbmRlckl0ZW0oIG9iamVjdCwgbnVsbCwgb2JqZWN0Lm1hdGVyaWFsLCBfdmVjdG9yMy56LCBudWxsICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoIHx8IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmUgfHwgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRzICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU2tpbm5lZE1lc2ggKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5za2VsZXRvbi51cGRhdGUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBvYmplY3QuZnJ1c3R1bUN1bGxlZCA9PT0gZmFsc2UgfHwgX2ZydXN0dW0uaW50ZXJzZWN0c09iamVjdCggb2JqZWN0ICkgPT09IHRydWUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRlcmlhbC52aXNpYmxlID09PSB0cnVlICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBfdGhpcy5zb3J0T2JqZWN0cyA9PT0gdHJ1ZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG9iamVjdC5tYXRyaXhXb3JsZCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZlY3RvcjMuYXBwbHlQcm9qZWN0aW9uKCBfcHJvalNjcmVlbk1hdHJpeCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdlb21ldHJ5ID0gb2JqZWN0cy51cGRhdGUoIG9iamVjdCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRlcmlhbHMgPSBtYXRlcmlhbC5tYXRlcmlhbHM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBncm91cE1hdGVyaWFsID0gbWF0ZXJpYWxzWyBncm91cC5tYXRlcmlhbEluZGV4IF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZ3JvdXBNYXRlcmlhbC52aXNpYmxlID09PSB0cnVlICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaFJlbmRlckl0ZW0oIG9iamVjdCwgZ2VvbWV0cnksIGdyb3VwTWF0ZXJpYWwsIF92ZWN0b3IzLnosIGdyb3VwICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hSZW5kZXJJdGVtKCBvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgX3ZlY3RvcjMueiwgbnVsbCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IG9iamVjdC5jaGlsZHJlbjtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHByb2plY3RPYmplY3QoIGNoaWxkcmVuWyBpIF0sIGNhbWVyYSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlbmRlck9iamVjdHMoIHJlbmRlckxpc3QsIGNhbWVyYSwgbGlnaHRzLCBmb2csIG92ZXJyaWRlTWF0ZXJpYWwgKSB7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHJlbmRlckxpc3QubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciByZW5kZXJJdGVtID0gcmVuZGVyTGlzdFsgaSBdO1xyXG5cclxuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHJlbmRlckl0ZW0ub2JqZWN0O1xyXG4gICAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSByZW5kZXJJdGVtLmdlb21ldHJ5O1xyXG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWwgPSBvdmVycmlkZU1hdGVyaWFsID09PSB1bmRlZmluZWQgPyByZW5kZXJJdGVtLm1hdGVyaWFsIDogb3ZlcnJpZGVNYXRlcmlhbDtcclxuICAgICAgICAgICAgdmFyIGdyb3VwID0gcmVuZGVySXRlbS5ncm91cDtcclxuXHJcbiAgICAgICAgICAgIG9iamVjdC5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcbiAgICAgICAgICAgIG9iamVjdC5ub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCBvYmplY3QubW9kZWxWaWV3TWF0cml4ICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkltbWVkaWF0ZVJlbmRlck9iamVjdCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBzZXRNYXRlcmlhbCggbWF0ZXJpYWwgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvZ3JhbSA9IHNldFByb2dyYW0oIGNhbWVyYSwgbGlnaHRzLCBmb2csIG1hdGVyaWFsLCBvYmplY3QgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9ICcnO1xyXG5cclxuICAgICAgICAgICAgICAgIG9iamVjdC5yZW5kZXIoIGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW5kZXJCdWZmZXJJbW1lZGlhdGUoIG9iamVjdCwgcHJvZ3JhbSwgbWF0ZXJpYWwgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9ICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlckJ1ZmZlckRpcmVjdCggY2FtZXJhLCBsaWdodHMsIGZvZywgZ2VvbWV0cnksIG1hdGVyaWFsLCBvYmplY3QsIGdyb3VwICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaW5pdE1hdGVyaWFsKCBtYXRlcmlhbCwgbGlnaHRzLCBmb2csIG9iamVjdCApIHtcclxuXHJcbiAgICAgICAgdmFyIG1hdGVyaWFsUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCBtYXRlcmlhbCApO1xyXG5cclxuICAgICAgICB2YXIgcGFyYW1ldGVycyA9IHByb2dyYW1DYWNoZS5nZXRQYXJhbWV0ZXJzKCBtYXRlcmlhbCwgbGlnaHRzLCBmb2csIG9iamVjdCApO1xyXG4gICAgICAgIHZhciBjb2RlID0gcHJvZ3JhbUNhY2hlLmdldFByb2dyYW1Db2RlKCBtYXRlcmlhbCwgcGFyYW1ldGVycyApO1xyXG5cclxuICAgICAgICB2YXIgcHJvZ3JhbSA9IG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtO1xyXG4gICAgICAgIHZhciBwcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgaWYgKCBwcm9ncmFtID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBuZXcgbWF0ZXJpYWxcclxuICAgICAgICAgICAgbWF0ZXJpYWwuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbk1hdGVyaWFsRGlzcG9zZSApO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCBwcm9ncmFtLmNvZGUgIT09IGNvZGUgKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBjaGFuZ2VkIGdsc2wgb3IgcGFyYW1ldGVyc1xyXG4gICAgICAgICAgICByZWxlYXNlTWF0ZXJpYWxQcm9ncmFtUmVmZXJlbmNlKCBtYXRlcmlhbCApO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCBwYXJhbWV0ZXJzLnNoYWRlcklEICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBzYW1lIGdsc2wgYW5kIHVuaWZvcm0gbGlzdFxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAvLyBvbmx5IHJlYnVpbGQgdW5pZm9ybSBsaXN0XHJcbiAgICAgICAgICAgIHByb2dyYW1DaGFuZ2UgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIHByb2dyYW1DaGFuZ2UgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHBhcmFtZXRlcnMuc2hhZGVySUQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHNoYWRlciA9IFRIUkVFLlNoYWRlckxpYlsgcGFyYW1ldGVycy5zaGFkZXJJRCBdO1xyXG5cclxuICAgICAgICAgICAgICAgIG1hdGVyaWFsUHJvcGVydGllcy5fX3dlYmdsU2hhZGVyID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG1hdGVyaWFsLnR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIHNoYWRlci51bmlmb3JtcyApLFxyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRleFNoYWRlcjogc2hhZGVyLnZlcnRleFNoYWRlcixcclxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudFNoYWRlcjogc2hhZGVyLmZyYWdtZW50U2hhZGVyXHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICBtYXRlcmlhbFByb3BlcnRpZXMuX193ZWJnbFNoYWRlciA9IHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBtYXRlcmlhbC50eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm1zOiBtYXRlcmlhbC51bmlmb3JtcyxcclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhTaGFkZXI6IG1hdGVyaWFsLnZlcnRleFNoYWRlcixcclxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudFNoYWRlcjogbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXJcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLl9fd2ViZ2xTaGFkZXI7XHJcblxyXG4gICAgICAgICAgICBwcm9ncmFtID0gcHJvZ3JhbUNhY2hlLmFjcXVpcmVQcm9ncmFtKCBtYXRlcmlhbCwgcGFyYW1ldGVycywgY29kZSApO1xyXG5cclxuICAgICAgICAgICAgbWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW0gPSBwcm9ncmFtO1xyXG4gICAgICAgICAgICBtYXRlcmlhbC5wcm9ncmFtID0gcHJvZ3JhbTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xyXG5cclxuICAgICAgICBpZiAoIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyApIHtcclxuXHJcbiAgICAgICAgICAgIG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoVGFyZ2V0cyA9IDA7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBfdGhpcy5tYXhNb3JwaFRhcmdldHM7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBhdHRyaWJ1dGVzWyAnbW9ycGhUYXJnZXQnICsgaSBdID49IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoVGFyZ2V0cyArKztcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBtYXRlcmlhbC5tb3JwaE5vcm1hbHMgKSB7XHJcblxyXG4gICAgICAgICAgICBtYXRlcmlhbC5udW1TdXBwb3J0ZWRNb3JwaE5vcm1hbHMgPSAwO1xyXG5cclxuICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBfdGhpcy5tYXhNb3JwaE5vcm1hbHM7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBhdHRyaWJ1dGVzWyAnbW9ycGhOb3JtYWwnICsgaSBdID49IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoTm9ybWFscyArKztcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbWF0ZXJpYWxQcm9wZXJ0aWVzLnVuaWZvcm1zTGlzdCA9IFtdO1xyXG5cclxuICAgICAgICB2YXIgdW5pZm9ybUxvY2F0aW9ucyA9IG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtLmdldFVuaWZvcm1zKCk7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciB1IGluIG1hdGVyaWFsUHJvcGVydGllcy5fX3dlYmdsU2hhZGVyLnVuaWZvcm1zICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gdW5pZm9ybUxvY2F0aW9uc1sgdSBdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBsb2NhdGlvbiApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXNMaXN0LnB1c2goIFsgbWF0ZXJpYWxQcm9wZXJ0aWVzLl9fd2ViZ2xTaGFkZXIudW5pZm9ybXNbIHUgXSwgbG9jYXRpb24gXSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldE1hdGVyaWFsKCBtYXRlcmlhbCApIHtcclxuXHJcbiAgICAgICAgc2V0TWF0ZXJpYWxGYWNlcyggbWF0ZXJpYWwgKTtcclxuXHJcbiAgICAgICAgaWYgKCBtYXRlcmlhbC50cmFuc3BhcmVudCA9PT0gdHJ1ZSApIHtcclxuXHJcbiAgICAgICAgICAgIHN0YXRlLnNldEJsZW5kaW5nKCBtYXRlcmlhbC5ibGVuZGluZywgbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbiwgbWF0ZXJpYWwuYmxlbmRTcmMsIG1hdGVyaWFsLmJsZW5kRHN0LCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uQWxwaGEsIG1hdGVyaWFsLmJsZW5kU3JjQWxwaGEsIG1hdGVyaWFsLmJsZW5kRHN0QWxwaGEgKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIHN0YXRlLnNldEJsZW5kaW5nKCBUSFJFRS5Ob0JsZW5kaW5nICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhdGUuc2V0RGVwdGhGdW5jKCBtYXRlcmlhbC5kZXB0aEZ1bmMgKTtcclxuICAgICAgICBzdGF0ZS5zZXREZXB0aFRlc3QoIG1hdGVyaWFsLmRlcHRoVGVzdCApO1xyXG4gICAgICAgIHN0YXRlLnNldERlcHRoV3JpdGUoIG1hdGVyaWFsLmRlcHRoV3JpdGUgKTtcclxuICAgICAgICBzdGF0ZS5zZXRDb2xvcldyaXRlKCBtYXRlcmlhbC5jb2xvcldyaXRlICk7XHJcbiAgICAgICAgc3RhdGUuc2V0UG9seWdvbk9mZnNldCggbWF0ZXJpYWwucG9seWdvbk9mZnNldCwgbWF0ZXJpYWwucG9seWdvbk9mZnNldEZhY3RvciwgbWF0ZXJpYWwucG9seWdvbk9mZnNldFVuaXRzICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldE1hdGVyaWFsRmFjZXMoIG1hdGVyaWFsICkge1xyXG5cclxuICAgICAgICBtYXRlcmlhbC5zaWRlICE9PSBUSFJFRS5Eb3VibGVTaWRlID8gc3RhdGUuZW5hYmxlKCBfZ2wuQ1VMTF9GQUNFICkgOiBzdGF0ZS5kaXNhYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XHJcbiAgICAgICAgc3RhdGUuc2V0RmxpcFNpZGVkKCBtYXRlcmlhbC5zaWRlID09PSBUSFJFRS5CYWNrU2lkZSApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXRQcm9ncmFtKCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBtYXRlcmlhbCwgb2JqZWN0ICkge1xyXG5cclxuICAgICAgICBfdXNlZFRleHR1cmVVbml0cyA9IDA7XHJcblxyXG4gICAgICAgIHZhciBtYXRlcmlhbFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggbWF0ZXJpYWwgKTtcclxuXHJcbiAgICAgICAgaWYgKCBtYXRlcmlhbC5uZWVkc1VwZGF0ZSB8fCAhIG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtICkge1xyXG5cclxuICAgICAgICAgICAgaW5pdE1hdGVyaWFsKCBtYXRlcmlhbCwgbGlnaHRzLCBmb2csIG9iamVjdCApO1xyXG4gICAgICAgICAgICBtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciByZWZyZXNoUHJvZ3JhbSA9IGZhbHNlO1xyXG4gICAgICAgIHZhciByZWZyZXNoTWF0ZXJpYWwgPSBmYWxzZTtcclxuICAgICAgICB2YXIgcmVmcmVzaExpZ2h0cyA9IGZhbHNlO1xyXG5cclxuICAgICAgICB2YXIgcHJvZ3JhbSA9IG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtLFxyXG4gICAgICAgICAgICBwX3VuaWZvcm1zID0gcHJvZ3JhbS5nZXRVbmlmb3JtcygpLFxyXG4gICAgICAgICAgICBtX3VuaWZvcm1zID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLl9fd2ViZ2xTaGFkZXIudW5pZm9ybXM7XHJcblxyXG4gICAgICAgIGlmICggcHJvZ3JhbS5pZCAhPT0gX2N1cnJlbnRQcm9ncmFtICkge1xyXG5cclxuICAgICAgICAgICAgX2dsLnVzZVByb2dyYW0oIHByb2dyYW0ucHJvZ3JhbSApO1xyXG4gICAgICAgICAgICBfY3VycmVudFByb2dyYW0gPSBwcm9ncmFtLmlkO1xyXG5cclxuICAgICAgICAgICAgcmVmcmVzaFByb2dyYW0gPSB0cnVlO1xyXG4gICAgICAgICAgICByZWZyZXNoTWF0ZXJpYWwgPSB0cnVlO1xyXG4gICAgICAgICAgICByZWZyZXNoTGlnaHRzID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIG1hdGVyaWFsLmlkICE9PSBfY3VycmVudE1hdGVyaWFsSWQgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIF9jdXJyZW50TWF0ZXJpYWxJZCA9PT0gLSAxICkgcmVmcmVzaExpZ2h0cyA9IHRydWU7XHJcbiAgICAgICAgICAgIF9jdXJyZW50TWF0ZXJpYWxJZCA9IG1hdGVyaWFsLmlkO1xyXG5cclxuICAgICAgICAgICAgcmVmcmVzaE1hdGVyaWFsID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIHJlZnJlc2hQcm9ncmFtIHx8IGNhbWVyYSAhPT0gX2N1cnJlbnRDYW1lcmEgKSB7XHJcblxyXG4gICAgICAgICAgICBfZ2wudW5pZm9ybU1hdHJpeDRmdiggcF91bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4LCBmYWxzZSwgY2FtZXJhLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHMgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggY2FwYWJpbGl0aWVzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0xZiggcF91bmlmb3Jtcy5sb2dEZXB0aEJ1ZkZDLCAyLjAgLyAoIE1hdGgubG9nKCBjYW1lcmEuZmFyICsgMS4wICkgLyBNYXRoLkxOMiApICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgaWYgKCBjYW1lcmEgIT09IF9jdXJyZW50Q2FtZXJhICkgX2N1cnJlbnRDYW1lcmEgPSBjYW1lcmE7XHJcblxyXG4gICAgICAgICAgICAvLyBsb2FkIG1hdGVyaWFsIHNwZWNpZmljIHVuaWZvcm1zXHJcbiAgICAgICAgICAgIC8vIChzaGFkZXIgbWF0ZXJpYWwgYWxzbyBnZXRzIHRoZW0gZm9yIHRoZSBzYWtlIG9mIGdlbmVyaWNpdHkpXHJcblxyXG4gICAgICAgICAgICBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuU2hhZGVyTWF0ZXJpYWwgfHxcclxuICAgICAgICAgICAgICAgIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgfHxcclxuICAgICAgICAgICAgICAgIG1hdGVyaWFsLmVudk1hcCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHBfdW5pZm9ybXMuY2FtZXJhUG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcclxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTNmKCBwX3VuaWZvcm1zLmNhbWVyYVBvc2l0aW9uLCBfdmVjdG9yMy54LCBfdmVjdG9yMy55LCBfdmVjdG9yMy56ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsIHx8XHJcbiAgICAgICAgICAgICAgICBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcclxuICAgICAgICAgICAgICAgIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwgfHxcclxuICAgICAgICAgICAgICAgIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuU2hhZGVyTWF0ZXJpYWwgfHxcclxuICAgICAgICAgICAgICAgIG1hdGVyaWFsLnNraW5uaW5nICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggcF91bmlmb3Jtcy52aWV3TWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLnZpZXdNYXRyaXgsIGZhbHNlLCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmVsZW1lbnRzICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHNraW5uaW5nIHVuaWZvcm1zIG11c3QgYmUgc2V0IGV2ZW4gaWYgbWF0ZXJpYWwgZGlkbid0IGNoYW5nZVxyXG4gICAgICAgIC8vIGF1dG8tc2V0dGluZyBvZiB0ZXh0dXJlIHVuaXQgZm9yIGJvbmUgdGV4dHVyZSBtdXN0IGdvIGJlZm9yZSBvdGhlciB0ZXh0dXJlc1xyXG4gICAgICAgIC8vIG5vdCBzdXJlIHdoeSwgYnV0IG90aGVyd2lzZSB3ZWlyZCB0aGluZ3MgaGFwcGVuXHJcblxyXG4gICAgICAgIGlmICggbWF0ZXJpYWwuc2tpbm5pbmcgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG9iamVjdC5iaW5kTWF0cml4ICYmIHBfdW5pZm9ybXMuYmluZE1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLmJpbmRNYXRyaXgsIGZhbHNlLCBvYmplY3QuYmluZE1hdHJpeC5lbGVtZW50cyApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBvYmplY3QuYmluZE1hdHJpeEludmVyc2UgJiYgcF91bmlmb3Jtcy5iaW5kTWF0cml4SW52ZXJzZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLmJpbmRNYXRyaXhJbnZlcnNlLCBmYWxzZSwgb2JqZWN0LmJpbmRNYXRyaXhJbnZlcnNlLmVsZW1lbnRzICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIGNhcGFiaWxpdGllcy5mbG9hdFZlcnRleFRleHR1cmVzICYmIG9iamVjdC5za2VsZXRvbiAmJiBvYmplY3Quc2tlbGV0b24udXNlVmVydGV4VGV4dHVyZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHBfdW5pZm9ybXMuYm9uZVRleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHR1cmVVbml0ID0gZ2V0VGV4dHVyZVVuaXQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0xaSggcF91bmlmb3Jtcy5ib25lVGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRUZXh0dXJlKCBvYmplY3Quc2tlbGV0b24uYm9uZVRleHR1cmUsIHRleHR1cmVVbml0ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICggcF91bmlmb3Jtcy5ib25lVGV4dHVyZVdpZHRoICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtMWkoIHBfdW5pZm9ybXMuYm9uZVRleHR1cmVXaWR0aCwgb2JqZWN0LnNrZWxldG9uLmJvbmVUZXh0dXJlV2lkdGggKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlSGVpZ2h0ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtMWkoIHBfdW5pZm9ybXMuYm9uZVRleHR1cmVIZWlnaHQsIG9iamVjdC5za2VsZXRvbi5ib25lVGV4dHVyZUhlaWdodCApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIG9iamVjdC5za2VsZXRvbiAmJiBvYmplY3Quc2tlbGV0b24uYm9uZU1hdHJpY2VzICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggcF91bmlmb3Jtcy5ib25lR2xvYmFsTWF0cmljZXMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMuYm9uZUdsb2JhbE1hdHJpY2VzLCBmYWxzZSwgb2JqZWN0LnNrZWxldG9uLmJvbmVNYXRyaWNlcyApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIHJlZnJlc2hNYXRlcmlhbCApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIHJlZnJlc2ggdW5pZm9ybXMgY29tbW9uIHRvIHNldmVyYWwgbWF0ZXJpYWxzXHJcblxyXG4gICAgICAgICAgICBpZiAoIGZvZyAmJiBtYXRlcmlhbC5mb2cgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcmVmcmVzaFVuaWZvcm1zRm9nKCBtX3VuaWZvcm1zLCBmb2cgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCB8fFxyXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsIHx8XHJcbiAgICAgICAgICAgICAgICBtYXRlcmlhbC5saWdodHMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBfbGlnaHRzTmVlZFVwZGF0ZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaExpZ2h0cyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBMaWdodHMoIGxpZ2h0cywgY2FtZXJhICk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2xpZ2h0c05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCByZWZyZXNoTGlnaHRzICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoVW5pZm9ybXNMaWdodHMoIG1fdW5pZm9ybXMsIF9saWdodHMgKTtcclxuICAgICAgICAgICAgICAgICAgICBtYXJrVW5pZm9ybXNMaWdodHNOZWVkc1VwZGF0ZSggbV91bmlmb3JtcywgdHJ1ZSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG1hcmtVbmlmb3Jtc0xpZ2h0c05lZWRzVXBkYXRlKCBtX3VuaWZvcm1zLCBmYWxzZSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCB8fFxyXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsIHx8XHJcbiAgICAgICAgICAgICAgICBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHJlZnJlc2ggc2luZ2xlIG1hdGVyaWFsIHNwZWNpZmljIHVuaWZvcm1zXHJcblxyXG4gICAgICAgICAgICBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcmVmcmVzaFVuaWZvcm1zTGluZSggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHJlZnJlc2hVbmlmb3Jtc0xpbmUoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XHJcbiAgICAgICAgICAgICAgICByZWZyZXNoVW5pZm9ybXNEYXNoKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludHNNYXRlcmlhbCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZWZyZXNoVW5pZm9ybXNQYXJ0aWNsZSggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcmVmcmVzaFVuaWZvcm1zUGhvbmcoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsICkge1xyXG5cclxuICAgICAgICAgICAgICAgIG1fdW5pZm9ybXMubU5lYXIudmFsdWUgPSBjYW1lcmEubmVhcjtcclxuICAgICAgICAgICAgICAgIG1fdW5pZm9ybXMubUZhci52YWx1ZSA9IGNhbWVyYS5mYXI7XHJcbiAgICAgICAgICAgICAgICBtX3VuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgbV91bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggb2JqZWN0LnJlY2VpdmVTaGFkb3cgJiYgISBtYXRlcmlhbC5fc2hhZG93UGFzcyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZWZyZXNoVW5pZm9ybXNTaGFkb3coIG1fdW5pZm9ybXMsIGxpZ2h0cywgY2FtZXJhICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBsb2FkIGNvbW1vbiB1bmlmb3Jtc1xyXG5cclxuICAgICAgICAgICAgbG9hZFVuaWZvcm1zR2VuZXJpYyggbWF0ZXJpYWxQcm9wZXJ0aWVzLnVuaWZvcm1zTGlzdCApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxvYWRVbmlmb3Jtc01hdHJpY2VzKCBwX3VuaWZvcm1zLCBvYmplY3QgKTtcclxuXHJcbiAgICAgICAgaWYgKCBwX3VuaWZvcm1zLm1vZGVsTWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBfZ2wudW5pZm9ybU1hdHJpeDRmdiggcF91bmlmb3Jtcy5tb2RlbE1hdHJpeCwgZmFsc2UsIG9iamVjdC5tYXRyaXhXb3JsZC5lbGVtZW50cyApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwcm9ncmFtO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBVbmlmb3JtcyAocmVmcmVzaCB1bmlmb3JtcyBvYmplY3RzKVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcclxuXHJcbiAgICAgICAgdW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XHJcblxyXG4gICAgICAgIHVuaWZvcm1zLmRpZmZ1c2UudmFsdWUgPSBtYXRlcmlhbC5jb2xvcjtcclxuXHJcbiAgICAgICAgaWYgKCBtYXRlcmlhbC5lbWlzc2l2ZSApIHtcclxuXHJcbiAgICAgICAgICAgIHVuaWZvcm1zLmVtaXNzaXZlLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmU7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdW5pZm9ybXMubWFwLnZhbHVlID0gbWF0ZXJpYWwubWFwO1xyXG4gICAgICAgIHVuaWZvcm1zLnNwZWN1bGFyTWFwLnZhbHVlID0gbWF0ZXJpYWwuc3BlY3VsYXJNYXA7XHJcbiAgICAgICAgdW5pZm9ybXMuYWxwaGFNYXAudmFsdWUgPSBtYXRlcmlhbC5hbHBoYU1hcDtcclxuXHJcbiAgICAgICAgaWYgKCBtYXRlcmlhbC5hb01hcCApIHtcclxuXHJcbiAgICAgICAgICAgIHVuaWZvcm1zLmFvTWFwLnZhbHVlID0gbWF0ZXJpYWwuYW9NYXA7XHJcbiAgICAgICAgICAgIHVuaWZvcm1zLmFvTWFwSW50ZW5zaXR5LnZhbHVlID0gbWF0ZXJpYWwuYW9NYXBJbnRlbnNpdHk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdXYgcmVwZWF0IGFuZCBvZmZzZXQgc2V0dGluZyBwcmlvcml0aWVzXHJcbiAgICAgICAgLy8gMS4gY29sb3IgbWFwXHJcbiAgICAgICAgLy8gMi4gc3BlY3VsYXIgbWFwXHJcbiAgICAgICAgLy8gMy4gbm9ybWFsIG1hcFxyXG4gICAgICAgIC8vIDQuIGJ1bXAgbWFwXHJcbiAgICAgICAgLy8gNS4gYWxwaGEgbWFwXHJcbiAgICAgICAgLy8gNi4gZW1pc3NpdmUgbWFwXHJcblxyXG4gICAgICAgIHZhciB1dlNjYWxlTWFwO1xyXG5cclxuICAgICAgICBpZiAoIG1hdGVyaWFsLm1hcCApIHtcclxuXHJcbiAgICAgICAgICAgIHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5tYXA7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIG1hdGVyaWFsLnNwZWN1bGFyTWFwICkge1xyXG5cclxuICAgICAgICAgICAgdXZTY2FsZU1hcCA9IG1hdGVyaWFsLnNwZWN1bGFyTWFwO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgKSB7XHJcblxyXG4gICAgICAgICAgICB1dlNjYWxlTWFwID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCBtYXRlcmlhbC5ub3JtYWxNYXAgKSB7XHJcblxyXG4gICAgICAgICAgICB1dlNjYWxlTWFwID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCBtYXRlcmlhbC5idW1wTWFwICkge1xyXG5cclxuICAgICAgICAgICAgdXZTY2FsZU1hcCA9IG1hdGVyaWFsLmJ1bXBNYXA7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIG1hdGVyaWFsLmFscGhhTWFwICkge1xyXG5cclxuICAgICAgICAgICAgdXZTY2FsZU1hcCA9IG1hdGVyaWFsLmFscGhhTWFwO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCBtYXRlcmlhbC5lbWlzc2l2ZU1hcCApIHtcclxuXHJcbiAgICAgICAgICAgIHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5lbWlzc2l2ZU1hcDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIHV2U2NhbGVNYXAgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggdXZTY2FsZU1hcCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0ICkgdXZTY2FsZU1hcCA9IHV2U2NhbGVNYXAudGV4dHVyZTtcclxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHV2U2NhbGVNYXAub2Zmc2V0O1xyXG4gICAgICAgICAgICB2YXIgcmVwZWF0ID0gdXZTY2FsZU1hcC5yZXBlYXQ7XHJcblxyXG4gICAgICAgICAgICB1bmlmb3Jtcy5vZmZzZXRSZXBlYXQudmFsdWUuc2V0KCBvZmZzZXQueCwgb2Zmc2V0LnksIHJlcGVhdC54LCByZXBlYXQueSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHVuaWZvcm1zLmVudk1hcC52YWx1ZSA9IG1hdGVyaWFsLmVudk1hcDtcclxuICAgICAgICB1bmlmb3Jtcy5mbGlwRW52TWFwLnZhbHVlID0gKCBtYXRlcmlhbC5lbnZNYXAgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgKSA/IDEgOiAtIDE7XHJcblxyXG4gICAgICAgIHVuaWZvcm1zLnJlZmxlY3Rpdml0eS52YWx1ZSA9IG1hdGVyaWFsLnJlZmxlY3Rpdml0eTtcclxuICAgICAgICB1bmlmb3Jtcy5yZWZyYWN0aW9uUmF0aW8udmFsdWUgPSBtYXRlcmlhbC5yZWZyYWN0aW9uUmF0aW87XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0xpbmUgKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XHJcblxyXG4gICAgICAgIHVuaWZvcm1zLmRpZmZ1c2UudmFsdWUgPSBtYXRlcmlhbC5jb2xvcjtcclxuICAgICAgICB1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zRGFzaCAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcclxuXHJcbiAgICAgICAgdW5pZm9ybXMuZGFzaFNpemUudmFsdWUgPSBtYXRlcmlhbC5kYXNoU2l6ZTtcclxuICAgICAgICB1bmlmb3Jtcy50b3RhbFNpemUudmFsdWUgPSBtYXRlcmlhbC5kYXNoU2l6ZSArIG1hdGVyaWFsLmdhcFNpemU7XHJcbiAgICAgICAgdW5pZm9ybXMuc2NhbGUudmFsdWUgPSBtYXRlcmlhbC5zY2FsZTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zUGFydGljbGUgKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XHJcblxyXG4gICAgICAgIHVuaWZvcm1zLnBzQ29sb3IudmFsdWUgPSBtYXRlcmlhbC5jb2xvcjtcclxuICAgICAgICB1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcclxuICAgICAgICB1bmlmb3Jtcy5zaXplLnZhbHVlID0gbWF0ZXJpYWwuc2l6ZTtcclxuICAgICAgICB1bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IF9jYW52YXMuaGVpZ2h0IC8gMi4wOyAvLyBUT0RPOiBDYWNoZSB0aGlzLlxyXG5cclxuICAgICAgICB1bmlmb3Jtcy5tYXAudmFsdWUgPSBtYXRlcmlhbC5tYXA7XHJcblxyXG4gICAgICAgIGlmICggbWF0ZXJpYWwubWFwICE9PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IG1hdGVyaWFsLm1hcC5vZmZzZXQ7XHJcbiAgICAgICAgICAgIHZhciByZXBlYXQgPSBtYXRlcmlhbC5tYXAucmVwZWF0O1xyXG5cclxuICAgICAgICAgICAgdW5pZm9ybXMub2Zmc2V0UmVwZWF0LnZhbHVlLnNldCggb2Zmc2V0LngsIG9mZnNldC55LCByZXBlYXQueCwgcmVwZWF0LnkgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNGb2cgKCB1bmlmb3JtcywgZm9nICkge1xyXG5cclxuICAgICAgICB1bmlmb3Jtcy5mb2dDb2xvci52YWx1ZSA9IGZvZy5jb2xvcjtcclxuXHJcbiAgICAgICAgaWYgKCBmb2cgaW5zdGFuY2VvZiBUSFJFRS5Gb2cgKSB7XHJcblxyXG4gICAgICAgICAgICB1bmlmb3Jtcy5mb2dOZWFyLnZhbHVlID0gZm9nLm5lYXI7XHJcbiAgICAgICAgICAgIHVuaWZvcm1zLmZvZ0Zhci52YWx1ZSA9IGZvZy5mYXI7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZ0V4cDIgKSB7XHJcblxyXG4gICAgICAgICAgICB1bmlmb3Jtcy5mb2dEZW5zaXR5LnZhbHVlID0gZm9nLmRlbnNpdHk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zUGhvbmcgKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XHJcblxyXG4gICAgICAgIHVuaWZvcm1zLnNwZWN1bGFyLnZhbHVlID0gbWF0ZXJpYWwuc3BlY3VsYXI7XHJcbiAgICAgICAgdW5pZm9ybXMuc2hpbmluZXNzLnZhbHVlID0gTWF0aC5tYXgoIG1hdGVyaWFsLnNoaW5pbmVzcywgMWUtNCApOyAvLyB0byBwcmV2ZW50IHBvdyggMC4wLCAwLjAgKVxyXG5cclxuICAgICAgICBpZiAoIG1hdGVyaWFsLmxpZ2h0TWFwICkge1xyXG5cclxuICAgICAgICAgICAgdW5pZm9ybXMubGlnaHRNYXAudmFsdWUgPSBtYXRlcmlhbC5saWdodE1hcDtcclxuICAgICAgICAgICAgdW5pZm9ybXMubGlnaHRNYXBJbnRlbnNpdHkudmFsdWUgPSBtYXRlcmlhbC5saWdodE1hcEludGVuc2l0eTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIG1hdGVyaWFsLmVtaXNzaXZlTWFwICkge1xyXG5cclxuICAgICAgICAgICAgdW5pZm9ybXMuZW1pc3NpdmVNYXAudmFsdWUgPSBtYXRlcmlhbC5lbWlzc2l2ZU1hcDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIG1hdGVyaWFsLmJ1bXBNYXAgKSB7XHJcblxyXG4gICAgICAgICAgICB1bmlmb3Jtcy5idW1wTWFwLnZhbHVlID0gbWF0ZXJpYWwuYnVtcE1hcDtcclxuICAgICAgICAgICAgdW5pZm9ybXMuYnVtcFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuYnVtcFNjYWxlO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggbWF0ZXJpYWwubm9ybWFsTWFwICkge1xyXG5cclxuICAgICAgICAgICAgdW5pZm9ybXMubm9ybWFsTWFwLnZhbHVlID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xyXG4gICAgICAgICAgICB1bmlmb3Jtcy5ub3JtYWxTY2FsZS52YWx1ZS5jb3B5KCBtYXRlcmlhbC5ub3JtYWxTY2FsZSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwICkge1xyXG5cclxuICAgICAgICAgICAgdW5pZm9ybXMuZGlzcGxhY2VtZW50TWFwLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwO1xyXG4gICAgICAgICAgICB1bmlmb3Jtcy5kaXNwbGFjZW1lbnRTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlO1xyXG4gICAgICAgICAgICB1bmlmb3Jtcy5kaXNwbGFjZW1lbnRCaWFzLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50QmlhcztcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNMaWdodHMgKCB1bmlmb3JtcywgbGlnaHRzICkge1xyXG5cclxuICAgICAgICB1bmlmb3Jtcy5hbWJpZW50TGlnaHRDb2xvci52YWx1ZSA9IGxpZ2h0cy5hbWJpZW50O1xyXG5cclxuICAgICAgICB1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0Q29sb3IudmFsdWUgPSBsaWdodHMuZGlyZWN0aW9uYWwuY29sb3JzO1xyXG4gICAgICAgIHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb24udmFsdWUgPSBsaWdodHMuZGlyZWN0aW9uYWwucG9zaXRpb25zO1xyXG5cclxuICAgICAgICB1bmlmb3Jtcy5wb2ludExpZ2h0Q29sb3IudmFsdWUgPSBsaWdodHMucG9pbnQuY29sb3JzO1xyXG4gICAgICAgIHVuaWZvcm1zLnBvaW50TGlnaHRQb3NpdGlvbi52YWx1ZSA9IGxpZ2h0cy5wb2ludC5wb3NpdGlvbnM7XHJcbiAgICAgICAgdW5pZm9ybXMucG9pbnRMaWdodERpc3RhbmNlLnZhbHVlID0gbGlnaHRzLnBvaW50LmRpc3RhbmNlcztcclxuICAgICAgICB1bmlmb3Jtcy5wb2ludExpZ2h0RGVjYXkudmFsdWUgPSBsaWdodHMucG9pbnQuZGVjYXlzO1xyXG5cclxuICAgICAgICB1bmlmb3Jtcy5zcG90TGlnaHRDb2xvci52YWx1ZSA9IGxpZ2h0cy5zcG90LmNvbG9ycztcclxuICAgICAgICB1bmlmb3Jtcy5zcG90TGlnaHRQb3NpdGlvbi52YWx1ZSA9IGxpZ2h0cy5zcG90LnBvc2l0aW9ucztcclxuICAgICAgICB1bmlmb3Jtcy5zcG90TGlnaHREaXN0YW5jZS52YWx1ZSA9IGxpZ2h0cy5zcG90LmRpc3RhbmNlcztcclxuICAgICAgICB1bmlmb3Jtcy5zcG90TGlnaHREaXJlY3Rpb24udmFsdWUgPSBsaWdodHMuc3BvdC5kaXJlY3Rpb25zO1xyXG4gICAgICAgIHVuaWZvcm1zLnNwb3RMaWdodEFuZ2xlQ29zLnZhbHVlID0gbGlnaHRzLnNwb3QuYW5nbGVzQ29zO1xyXG4gICAgICAgIHVuaWZvcm1zLnNwb3RMaWdodEV4cG9uZW50LnZhbHVlID0gbGlnaHRzLnNwb3QuZXhwb25lbnRzO1xyXG4gICAgICAgIHVuaWZvcm1zLnNwb3RMaWdodERlY2F5LnZhbHVlID0gbGlnaHRzLnNwb3QuZGVjYXlzO1xyXG5cclxuICAgICAgICB1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHRTa3lDb2xvci52YWx1ZSA9IGxpZ2h0cy5oZW1pLnNreUNvbG9ycztcclxuICAgICAgICB1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvci52YWx1ZSA9IGxpZ2h0cy5oZW1pLmdyb3VuZENvbG9ycztcclxuICAgICAgICB1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHREaXJlY3Rpb24udmFsdWUgPSBsaWdodHMuaGVtaS5wb3NpdGlvbnM7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHVuaWZvcm1zIGFyZSBtYXJrZWQgYXMgY2xlYW4sIHRoZXkgZG9uJ3QgbmVlZCB0byBiZSBsb2FkZWQgdG8gdGhlIEdQVS5cclxuXHJcbiAgICBmdW5jdGlvbiBtYXJrVW5pZm9ybXNMaWdodHNOZWVkc1VwZGF0ZSAoIHVuaWZvcm1zLCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgdW5pZm9ybXMuYW1iaWVudExpZ2h0Q29sb3IubmVlZHNVcGRhdGUgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgdW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodENvbG9yLm5lZWRzVXBkYXRlID0gdmFsdWU7XHJcbiAgICAgICAgdW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvbi5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xyXG5cclxuICAgICAgICB1bmlmb3Jtcy5wb2ludExpZ2h0Q29sb3IubmVlZHNVcGRhdGUgPSB2YWx1ZTtcclxuICAgICAgICB1bmlmb3Jtcy5wb2ludExpZ2h0UG9zaXRpb24ubmVlZHNVcGRhdGUgPSB2YWx1ZTtcclxuICAgICAgICB1bmlmb3Jtcy5wb2ludExpZ2h0RGlzdGFuY2UubmVlZHNVcGRhdGUgPSB2YWx1ZTtcclxuICAgICAgICB1bmlmb3Jtcy5wb2ludExpZ2h0RGVjYXkubmVlZHNVcGRhdGUgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgdW5pZm9ybXMuc3BvdExpZ2h0Q29sb3IubmVlZHNVcGRhdGUgPSB2YWx1ZTtcclxuICAgICAgICB1bmlmb3Jtcy5zcG90TGlnaHRQb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xyXG4gICAgICAgIHVuaWZvcm1zLnNwb3RMaWdodERpc3RhbmNlLm5lZWRzVXBkYXRlID0gdmFsdWU7XHJcbiAgICAgICAgdW5pZm9ybXMuc3BvdExpZ2h0RGlyZWN0aW9uLm5lZWRzVXBkYXRlID0gdmFsdWU7XHJcbiAgICAgICAgdW5pZm9ybXMuc3BvdExpZ2h0QW5nbGVDb3MubmVlZHNVcGRhdGUgPSB2YWx1ZTtcclxuICAgICAgICB1bmlmb3Jtcy5zcG90TGlnaHRFeHBvbmVudC5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xyXG4gICAgICAgIHVuaWZvcm1zLnNwb3RMaWdodERlY2F5Lm5lZWRzVXBkYXRlID0gdmFsdWU7XHJcblxyXG4gICAgICAgIHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodFNreUNvbG9yLm5lZWRzVXBkYXRlID0gdmFsdWU7XHJcbiAgICAgICAgdW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3IubmVlZHNVcGRhdGUgPSB2YWx1ZTtcclxuICAgICAgICB1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHREaXJlY3Rpb24ubmVlZHNVcGRhdGUgPSB2YWx1ZTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zU2hhZG93ICggdW5pZm9ybXMsIGxpZ2h0cywgY2FtZXJhICkge1xyXG5cclxuICAgICAgICBpZiAoIHVuaWZvcm1zLnNoYWRvd01hdHJpeCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBqID0gMDtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBsaWdodHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGxpZ2h0ID0gbGlnaHRzWyBpIF07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBsaWdodC5jYXN0U2hhZG93ID09PSB0cnVlICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodCB8fCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCB8fCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2hhZG93ID0gbGlnaHQuc2hhZG93O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50TGlnaHQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHBvaW50IGxpZ2h0cyB3ZSBzZXQgdGhlIHNoYWRvdyBtYXRyaXggdG8gYmUgYSB0cmFuc2xhdGlvbi1vbmx5IG1hdHJpeFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXF1YWwgdG8gaW52ZXJzZSBvZiB0aGUgbGlnaHQncyBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93Lm1hdHJpeC5pZGVudGl0eSgpLnNldFBvc2l0aW9uKCBfdmVjdG9yMyApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBwb2ludCBsaWdodHMgd2Ugc2V0IHRoZSBzaWduIG9mIHRoZSBzaGFkb3dEYXJrbmVzcyB1bmlmb3JtIHRvIGJlIG5lZ2F0aXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3Jtcy5zaGFkb3dEYXJrbmVzcy52YWx1ZVsgaiBdID0gLSBzaGFkb3cuZGFya25lc3M7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm1zLnNoYWRvd0RhcmtuZXNzLnZhbHVlWyBqIF0gPSBzaGFkb3cuZGFya25lc3M7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3Jtcy5zaGFkb3dNYXRyaXgudmFsdWVbIGogXSA9IHNoYWRvdy5tYXRyaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm1zLnNoYWRvd01hcC52YWx1ZVsgaiBdID0gc2hhZG93Lm1hcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXMuc2hhZG93TWFwU2l6ZS52YWx1ZVsgaiBdID0gc2hhZG93Lm1hcFNpemU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm1zLnNoYWRvd0JpYXMudmFsdWVbIGogXSA9IHNoYWRvdy5iaWFzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaiArKztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBVbmlmb3JtcyAobG9hZCB0byBHUFUpXHJcblxyXG4gICAgZnVuY3Rpb24gbG9hZFVuaWZvcm1zTWF0cmljZXMgKCB1bmlmb3Jtcywgb2JqZWN0ICkge1xyXG5cclxuICAgICAgICBfZ2wudW5pZm9ybU1hdHJpeDRmdiggdW5pZm9ybXMubW9kZWxWaWV3TWF0cml4LCBmYWxzZSwgb2JqZWN0Lm1vZGVsVmlld01hdHJpeC5lbGVtZW50cyApO1xyXG5cclxuICAgICAgICBpZiAoIHVuaWZvcm1zLm5vcm1hbE1hdHJpeCApIHtcclxuXHJcbiAgICAgICAgICAgIF9nbC51bmlmb3JtTWF0cml4M2Z2KCB1bmlmb3Jtcy5ub3JtYWxNYXRyaXgsIGZhbHNlLCBvYmplY3Qubm9ybWFsTWF0cml4LmVsZW1lbnRzICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0VGV4dHVyZVVuaXQoKSB7XHJcblxyXG4gICAgICAgIHZhciB0ZXh0dXJlVW5pdCA9IF91c2VkVGV4dHVyZVVuaXRzO1xyXG5cclxuICAgICAgICBpZiAoIHRleHR1cmVVbml0ID49IGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlcyApIHtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1dlYkdMUmVuZGVyZXI6IHRyeWluZyB0byB1c2UgJyArIHRleHR1cmVVbml0ICsgJyB0ZXh0dXJlIHVuaXRzIHdoaWxlIHRoaXMgR1BVIHN1cHBvcnRzIG9ubHkgJyArIGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlcyApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF91c2VkVGV4dHVyZVVuaXRzICs9IDE7XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0dXJlVW5pdDtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbG9hZFVuaWZvcm1zR2VuZXJpYyAoIHVuaWZvcm1zICkge1xyXG5cclxuICAgICAgICB2YXIgdGV4dHVyZSwgdGV4dHVyZVVuaXQ7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSB1bmlmb3Jtcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciB1bmlmb3JtID0gdW5pZm9ybXNbIGogXVsgMCBdO1xyXG5cclxuICAgICAgICAgICAgLy8gbmVlZHNVcGRhdGUgcHJvcGVydHkgaXMgbm90IGFkZGVkIHRvIGFsbCB1bmlmb3Jtcy5cclxuICAgICAgICAgICAgaWYgKCB1bmlmb3JtLm5lZWRzVXBkYXRlID09PSBmYWxzZSApIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgdmFyIHR5cGUgPSB1bmlmb3JtLnR5cGU7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHVuaWZvcm0udmFsdWU7XHJcbiAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IHVuaWZvcm1zWyBqIF1bIDEgXTtcclxuXHJcbiAgICAgICAgICAgIHN3aXRjaCAoIHR5cGUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnMWknOlxyXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtMWkoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJzFmJzpcclxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTFmKCBsb2NhdGlvbiwgdmFsdWUgKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICcyZic6XHJcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0yZiggbG9jYXRpb24sIHZhbHVlWyAwIF0sIHZhbHVlWyAxIF0gKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICczZic6XHJcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0zZiggbG9jYXRpb24sIHZhbHVlWyAwIF0sIHZhbHVlWyAxIF0sIHZhbHVlWyAyIF0gKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICc0Zic6XHJcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm00ZiggbG9jYXRpb24sIHZhbHVlWyAwIF0sIHZhbHVlWyAxIF0sIHZhbHVlWyAyIF0sIHZhbHVlWyAzIF0gKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICcxaXYnOlxyXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtMWl2KCBsb2NhdGlvbiwgdmFsdWUgKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICczaXYnOlxyXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtM2l2KCBsb2NhdGlvbiwgdmFsdWUgKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICcxZnYnOlxyXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtMWZ2KCBsb2NhdGlvbiwgdmFsdWUgKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICcyZnYnOlxyXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtMmZ2KCBsb2NhdGlvbiwgdmFsdWUgKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICczZnYnOlxyXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtM2Z2KCBsb2NhdGlvbiwgdmFsdWUgKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICc0ZnYnOlxyXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtNGZ2KCBsb2NhdGlvbiwgdmFsdWUgKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdNYXRyaXgzZnYnOlxyXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtTWF0cml4M2Z2KCBsb2NhdGlvbiwgZmFsc2UsIHZhbHVlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnTWF0cml4NGZ2JzpcclxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybU1hdHJpeDRmdiggbG9jYXRpb24sIGZhbHNlLCB2YWx1ZSApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vXHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnaSc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBpbnRlZ2VyXHJcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0xaSggbG9jYXRpb24sIHZhbHVlICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBzaW5nbGUgZmxvYXRcclxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTFmKCBsb2NhdGlvbiwgdmFsdWUgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAndjInOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBzaW5nbGUgVEhSRUUuVmVjdG9yMlxyXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtMmYoIGxvY2F0aW9uLCB2YWx1ZS54LCB2YWx1ZS55ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ3YzJzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIFRIUkVFLlZlY3RvcjNcclxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTNmKCBsb2NhdGlvbiwgdmFsdWUueCwgdmFsdWUueSwgdmFsdWUueiApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICd2NCc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBUSFJFRS5WZWN0b3I0XHJcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm00ZiggbG9jYXRpb24sIHZhbHVlLngsIHZhbHVlLnksIHZhbHVlLnosIHZhbHVlLncgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnYyc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBUSFJFRS5Db2xvclxyXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtM2YoIGxvY2F0aW9uLCB2YWx1ZS5yLCB2YWx1ZS5nLCB2YWx1ZS5iICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ2l2MSc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZsYXQgYXJyYXkgb2YgaW50ZWdlcnMgKEpTIG9yIHR5cGVkIGFycmF5KVxyXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtMWl2KCBsb2NhdGlvbiwgdmFsdWUgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnaXYnOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBmbGF0IGFycmF5IG9mIGludGVnZXJzIHdpdGggMyB4IE4gc2l6ZSAoSlMgb3IgdHlwZWQgYXJyYXkpXHJcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0zaXYoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdmdjEnOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBmbGF0IGFycmF5IG9mIGZsb2F0cyAoSlMgb3IgdHlwZWQgYXJyYXkpXHJcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0xZnYoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdmdic6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZsYXQgYXJyYXkgb2YgZmxvYXRzIHdpdGggMyB4IE4gc2l6ZSAoSlMgb3IgdHlwZWQgYXJyYXkpXHJcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0zZnYoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICd2MnYnOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBhcnJheSBvZiBUSFJFRS5WZWN0b3IyXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggdW5pZm9ybS5fYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggMiAqIHZhbHVlLmxlbmd0aCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaTIgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpICsrLCBpMiArPSAyICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbIGkyICsgMCBdID0gdmFsdWVbIGkgXS54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheVsgaTIgKyAxIF0gPSB2YWx1ZVsgaSBdLnk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0yZnYoIGxvY2F0aW9uLCB1bmlmb3JtLl9hcnJheSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICd2M3YnOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBhcnJheSBvZiBUSFJFRS5WZWN0b3IzXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggdW5pZm9ybS5fYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggMyAqIHZhbHVlLmxlbmd0aCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaTMgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpICsrLCBpMyArPSAzICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbIGkzICsgMCBdID0gdmFsdWVbIGkgXS54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheVsgaTMgKyAxIF0gPSB2YWx1ZVsgaSBdLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5WyBpMyArIDIgXSA9IHZhbHVlWyBpIF0uejtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTNmdiggbG9jYXRpb24sIHVuaWZvcm0uX2FycmF5ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ3Y0dic6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFycmF5IG9mIFRIUkVFLlZlY3RvcjRcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB1bmlmb3JtLl9hcnJheSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCA0ICogdmFsdWUubGVuZ3RoICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpNCA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKyssIGk0ICs9IDQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheVsgaTQgKyAwIF0gPSB2YWx1ZVsgaSBdLng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5WyBpNCArIDEgXSA9IHZhbHVlWyBpIF0ueTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbIGk0ICsgMiBdID0gdmFsdWVbIGkgXS56O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheVsgaTQgKyAzIF0gPSB2YWx1ZVsgaSBdLnc7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm00ZnYoIGxvY2F0aW9uLCB1bmlmb3JtLl9hcnJheSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdtMyc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBUSFJFRS5NYXRyaXgzXHJcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXgzZnYoIGxvY2F0aW9uLCBmYWxzZSwgdmFsdWUuZWxlbWVudHMgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnbTN2JzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXJyYXkgb2YgVEhSRUUuTWF0cml4M1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDkgKiB2YWx1ZS5sZW5ndGggKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVsgaSBdLmZsYXR0ZW5Ub0FycmF5T2Zmc2V0KCB1bmlmb3JtLl9hcnJheSwgaSAqIDkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybU1hdHJpeDNmdiggbG9jYXRpb24sIGZhbHNlLCB1bmlmb3JtLl9hcnJheSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdtNCc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBUSFJFRS5NYXRyaXg0XHJcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXg0ZnYoIGxvY2F0aW9uLCBmYWxzZSwgdmFsdWUuZWxlbWVudHMgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnbTR2JzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXJyYXkgb2YgVEhSRUUuTWF0cml4NFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDE2ICogdmFsdWUubGVuZ3RoICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbIGkgXS5mbGF0dGVuVG9BcnJheU9mZnNldCggdW5pZm9ybS5fYXJyYXksIGkgKiAxNiApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9nbC51bmlmb3JtTWF0cml4NGZ2KCBsb2NhdGlvbiwgZmFsc2UsIHVuaWZvcm0uX2FycmF5ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBzaW5nbGUgVEhSRUUuVGV4dHVyZSAoMmQgb3IgY3ViZSlcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmVVbml0ID0gZ2V0VGV4dHVyZVVuaXQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX2dsLnVuaWZvcm0xaSggbG9jYXRpb24sIHRleHR1cmVVbml0ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggISB0ZXh0dXJlICkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLkN1YmVUZXh0dXJlIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICggQXJyYXkuaXNBcnJheSggdGV4dHVyZS5pbWFnZSApICYmIHRleHR1cmUuaW1hZ2UubGVuZ3RoID09PSA2ICkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21wcmVzc2VkVGV4dHVyZSBjYW4gaGF2ZSBBcnJheSBpbiBpbWFnZSA6L1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q3ViZVRleHR1cmUoIHRleHR1cmUsIHRleHR1cmVVbml0ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHRleHR1cmUgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDdWJlVGV4dHVyZUR5bmFtaWMoIHRleHR1cmUudGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0VGV4dHVyZSggdGV4dHVyZS50ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0VGV4dHVyZSggdGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICd0dic6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFycmF5IG9mIFRIUkVFLlRleHR1cmUgKDJkIG9yIGN1YmUpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggdW5pZm9ybS5fYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5ID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHVuaWZvcm0udmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheVsgaSBdID0gZ2V0VGV4dHVyZVVuaXQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBfZ2wudW5pZm9ybTFpdiggbG9jYXRpb24sIHVuaWZvcm0uX2FycmF5ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB1bmlmb3JtLnZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZSA9IHVuaWZvcm0udmFsdWVbIGkgXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZVVuaXQgPSB1bmlmb3JtLl9hcnJheVsgaSBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhIHRleHR1cmUgKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLkN1YmVUZXh0dXJlIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIHRleHR1cmUuaW1hZ2UgaW5zdGFuY2VvZiBBcnJheSAmJiB0ZXh0dXJlLmltYWdlLmxlbmd0aCA9PT0gNiApICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXByZXNzZWRUZXh0dXJlIGNhbiBoYXZlIEFycmF5IGluIGltYWdlIDovXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q3ViZVRleHR1cmUoIHRleHR1cmUsIHRleHR1cmVVbml0ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0VGV4dHVyZSggdGV4dHVyZS50ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRDdWJlVGV4dHVyZUR5bmFtaWMoIHRleHR1cmUudGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0VGV4dHVyZSggdGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBVbmtub3duIHVuaWZvcm0gdHlwZTogJyArIHR5cGUgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXRDb2xvckxpbmVhciggYXJyYXksIG9mZnNldCwgY29sb3IsIGludGVuc2l0eSApIHtcclxuXHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDAgXSA9IGNvbG9yLnIgKiBpbnRlbnNpdHk7XHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDEgXSA9IGNvbG9yLmcgKiBpbnRlbnNpdHk7XHJcbiAgICAgICAgYXJyYXlbIG9mZnNldCArIDIgXSA9IGNvbG9yLmIgKiBpbnRlbnNpdHk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldHVwTGlnaHRzICggbGlnaHRzLCBjYW1lcmEgKSB7XHJcblxyXG4gICAgICAgIHZhciBsLCBsbCwgbGlnaHQsXHJcbiAgICAgICAgICAgIHIgPSAwLCBnID0gMCwgYiA9IDAsXHJcbiAgICAgICAgICAgIGNvbG9yLCBza3lDb2xvciwgZ3JvdW5kQ29sb3IsXHJcbiAgICAgICAgICAgIGludGVuc2l0eSxcclxuICAgICAgICAgICAgZGlzdGFuY2UsXHJcblxyXG4gICAgICAgICAgICB6bGlnaHRzID0gX2xpZ2h0cyxcclxuXHJcbiAgICAgICAgICAgIHZpZXdNYXRyaXggPSBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLFxyXG5cclxuICAgICAgICAgICAgZGlyQ29sb3JzID0gemxpZ2h0cy5kaXJlY3Rpb25hbC5jb2xvcnMsXHJcbiAgICAgICAgICAgIGRpclBvc2l0aW9ucyA9IHpsaWdodHMuZGlyZWN0aW9uYWwucG9zaXRpb25zLFxyXG5cclxuICAgICAgICAgICAgcG9pbnRDb2xvcnMgPSB6bGlnaHRzLnBvaW50LmNvbG9ycyxcclxuICAgICAgICAgICAgcG9pbnRQb3NpdGlvbnMgPSB6bGlnaHRzLnBvaW50LnBvc2l0aW9ucyxcclxuICAgICAgICAgICAgcG9pbnREaXN0YW5jZXMgPSB6bGlnaHRzLnBvaW50LmRpc3RhbmNlcyxcclxuICAgICAgICAgICAgcG9pbnREZWNheXMgPSB6bGlnaHRzLnBvaW50LmRlY2F5cyxcclxuXHJcbiAgICAgICAgICAgIHNwb3RDb2xvcnMgPSB6bGlnaHRzLnNwb3QuY29sb3JzLFxyXG4gICAgICAgICAgICBzcG90UG9zaXRpb25zID0gemxpZ2h0cy5zcG90LnBvc2l0aW9ucyxcclxuICAgICAgICAgICAgc3BvdERpc3RhbmNlcyA9IHpsaWdodHMuc3BvdC5kaXN0YW5jZXMsXHJcbiAgICAgICAgICAgIHNwb3REaXJlY3Rpb25zID0gemxpZ2h0cy5zcG90LmRpcmVjdGlvbnMsXHJcbiAgICAgICAgICAgIHNwb3RBbmdsZXNDb3MgPSB6bGlnaHRzLnNwb3QuYW5nbGVzQ29zLFxyXG4gICAgICAgICAgICBzcG90RXhwb25lbnRzID0gemxpZ2h0cy5zcG90LmV4cG9uZW50cyxcclxuICAgICAgICAgICAgc3BvdERlY2F5cyA9IHpsaWdodHMuc3BvdC5kZWNheXMsXHJcblxyXG4gICAgICAgICAgICBoZW1pU2t5Q29sb3JzID0gemxpZ2h0cy5oZW1pLnNreUNvbG9ycyxcclxuICAgICAgICAgICAgaGVtaUdyb3VuZENvbG9ycyA9IHpsaWdodHMuaGVtaS5ncm91bmRDb2xvcnMsXHJcbiAgICAgICAgICAgIGhlbWlQb3NpdGlvbnMgPSB6bGlnaHRzLmhlbWkucG9zaXRpb25zLFxyXG5cclxuICAgICAgICAgICAgZGlyTGVuZ3RoID0gMCxcclxuICAgICAgICAgICAgcG9pbnRMZW5ndGggPSAwLFxyXG4gICAgICAgICAgICBzcG90TGVuZ3RoID0gMCxcclxuICAgICAgICAgICAgaGVtaUxlbmd0aCA9IDAsXHJcblxyXG4gICAgICAgICAgICBkaXJDb3VudCA9IDAsXHJcbiAgICAgICAgICAgIHBvaW50Q291bnQgPSAwLFxyXG4gICAgICAgICAgICBzcG90Q291bnQgPSAwLFxyXG4gICAgICAgICAgICBoZW1pQ291bnQgPSAwLFxyXG5cclxuICAgICAgICAgICAgZGlyT2Zmc2V0ID0gMCxcclxuICAgICAgICAgICAgcG9pbnRPZmZzZXQgPSAwLFxyXG4gICAgICAgICAgICBzcG90T2Zmc2V0ID0gMCxcclxuICAgICAgICAgICAgaGVtaU9mZnNldCA9IDA7XHJcblxyXG4gICAgICAgIGZvciAoIGwgPSAwLCBsbCA9IGxpZ2h0cy5sZW5ndGg7IGwgPCBsbDsgbCArKyApIHtcclxuXHJcbiAgICAgICAgICAgIGxpZ2h0ID0gbGlnaHRzWyBsIF07XHJcblxyXG4gICAgICAgICAgICBjb2xvciA9IGxpZ2h0LmNvbG9yO1xyXG4gICAgICAgICAgICBpbnRlbnNpdHkgPSBsaWdodC5pbnRlbnNpdHk7XHJcbiAgICAgICAgICAgIGRpc3RhbmNlID0gbGlnaHQuZGlzdGFuY2U7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuQW1iaWVudExpZ2h0ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggISBsaWdodC52aXNpYmxlICkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgciArPSBjb2xvci5yO1xyXG4gICAgICAgICAgICAgICAgZyArPSBjb2xvci5nO1xyXG4gICAgICAgICAgICAgICAgYiArPSBjb2xvci5iO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGRpckNvdW50ICs9IDE7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCAhIGxpZ2h0LnZpc2libGUgKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBfZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcclxuICAgICAgICAgICAgICAgIF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XHJcbiAgICAgICAgICAgICAgICBfZGlyZWN0aW9uLnN1YiggX3ZlY3RvcjMgKTtcclxuICAgICAgICAgICAgICAgIF9kaXJlY3Rpb24udHJhbnNmb3JtRGlyZWN0aW9uKCB2aWV3TWF0cml4ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgZGlyT2Zmc2V0ID0gZGlyTGVuZ3RoICogMztcclxuXHJcbiAgICAgICAgICAgICAgICBkaXJQb3NpdGlvbnNbIGRpck9mZnNldCArIDAgXSA9IF9kaXJlY3Rpb24ueDtcclxuICAgICAgICAgICAgICAgIGRpclBvc2l0aW9uc1sgZGlyT2Zmc2V0ICsgMSBdID0gX2RpcmVjdGlvbi55O1xyXG4gICAgICAgICAgICAgICAgZGlyUG9zaXRpb25zWyBkaXJPZmZzZXQgKyAyIF0gPSBfZGlyZWN0aW9uLno7XHJcblxyXG4gICAgICAgICAgICAgICAgc2V0Q29sb3JMaW5lYXIoIGRpckNvbG9ycywgZGlyT2Zmc2V0LCBjb2xvciwgaW50ZW5zaXR5ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgZGlyTGVuZ3RoICs9IDE7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50TGlnaHQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcG9pbnRDb3VudCArPSAxO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggISBsaWdodC52aXNpYmxlICkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgcG9pbnRPZmZzZXQgPSBwb2ludExlbmd0aCAqIDM7XHJcblxyXG4gICAgICAgICAgICAgICAgc2V0Q29sb3JMaW5lYXIoIHBvaW50Q29sb3JzLCBwb2ludE9mZnNldCwgY29sb3IsIGludGVuc2l0eSApO1xyXG5cclxuICAgICAgICAgICAgICAgIF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcclxuICAgICAgICAgICAgICAgIF92ZWN0b3IzLmFwcGx5TWF0cml4NCggdmlld01hdHJpeCApO1xyXG5cclxuICAgICAgICAgICAgICAgIHBvaW50UG9zaXRpb25zWyBwb2ludE9mZnNldCArIDAgXSA9IF92ZWN0b3IzLng7XHJcbiAgICAgICAgICAgICAgICBwb2ludFBvc2l0aW9uc1sgcG9pbnRPZmZzZXQgKyAxIF0gPSBfdmVjdG9yMy55O1xyXG4gICAgICAgICAgICAgICAgcG9pbnRQb3NpdGlvbnNbIHBvaW50T2Zmc2V0ICsgMiBdID0gX3ZlY3RvcjMuejtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBkaXN0YW5jZSBpcyAwIGlmIGRlY2F5IGlzIDAsIGJlY2F1c2UgdGhlcmUgaXMgbm8gYXR0ZW51YXRpb24gYXQgYWxsLlxyXG4gICAgICAgICAgICAgICAgcG9pbnREaXN0YW5jZXNbIHBvaW50TGVuZ3RoIF0gPSBkaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgIHBvaW50RGVjYXlzWyBwb2ludExlbmd0aCBdID0gKCBsaWdodC5kaXN0YW5jZSA9PT0gMCApID8gMC4wIDogbGlnaHQuZGVjYXk7XHJcblxyXG4gICAgICAgICAgICAgICAgcG9pbnRMZW5ndGggKz0gMTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuU3BvdExpZ2h0ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHNwb3RDb3VudCArPSAxO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggISBsaWdodC52aXNpYmxlICkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgc3BvdE9mZnNldCA9IHNwb3RMZW5ndGggKiAzO1xyXG5cclxuICAgICAgICAgICAgICAgIHNldENvbG9yTGluZWFyKCBzcG90Q29sb3JzLCBzcG90T2Zmc2V0LCBjb2xvciwgaW50ZW5zaXR5ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgX2RpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XHJcbiAgICAgICAgICAgICAgICBfdmVjdG9yMy5jb3B5KCBfZGlyZWN0aW9uICkuYXBwbHlNYXRyaXg0KCB2aWV3TWF0cml4ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgc3BvdFBvc2l0aW9uc1sgc3BvdE9mZnNldCArIDAgXSA9IF92ZWN0b3IzLng7XHJcbiAgICAgICAgICAgICAgICBzcG90UG9zaXRpb25zWyBzcG90T2Zmc2V0ICsgMSBdID0gX3ZlY3RvcjMueTtcclxuICAgICAgICAgICAgICAgIHNwb3RQb3NpdGlvbnNbIHNwb3RPZmZzZXQgKyAyIF0gPSBfdmVjdG9yMy56O1xyXG5cclxuICAgICAgICAgICAgICAgIHNwb3REaXN0YW5jZXNbIHNwb3RMZW5ndGggXSA9IGRpc3RhbmNlO1xyXG5cclxuICAgICAgICAgICAgICAgIF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XHJcbiAgICAgICAgICAgICAgICBfZGlyZWN0aW9uLnN1YiggX3ZlY3RvcjMgKTtcclxuICAgICAgICAgICAgICAgIF9kaXJlY3Rpb24udHJhbnNmb3JtRGlyZWN0aW9uKCB2aWV3TWF0cml4ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgc3BvdERpcmVjdGlvbnNbIHNwb3RPZmZzZXQgKyAwIF0gPSBfZGlyZWN0aW9uLng7XHJcbiAgICAgICAgICAgICAgICBzcG90RGlyZWN0aW9uc1sgc3BvdE9mZnNldCArIDEgXSA9IF9kaXJlY3Rpb24ueTtcclxuICAgICAgICAgICAgICAgIHNwb3REaXJlY3Rpb25zWyBzcG90T2Zmc2V0ICsgMiBdID0gX2RpcmVjdGlvbi56O1xyXG5cclxuICAgICAgICAgICAgICAgIHNwb3RBbmdsZXNDb3NbIHNwb3RMZW5ndGggXSA9IE1hdGguY29zKCBsaWdodC5hbmdsZSApO1xyXG4gICAgICAgICAgICAgICAgc3BvdEV4cG9uZW50c1sgc3BvdExlbmd0aCBdID0gbGlnaHQuZXhwb25lbnQ7XHJcbiAgICAgICAgICAgICAgICBzcG90RGVjYXlzWyBzcG90TGVuZ3RoIF0gPSAoIGxpZ2h0LmRpc3RhbmNlID09PSAwICkgPyAwLjAgOiBsaWdodC5kZWNheTtcclxuXHJcbiAgICAgICAgICAgICAgICBzcG90TGVuZ3RoICs9IDE7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkhlbWlzcGhlcmVMaWdodCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBoZW1pQ291bnQgKz0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoICEgbGlnaHQudmlzaWJsZSApIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIF9kaXJlY3Rpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xyXG4gICAgICAgICAgICAgICAgX2RpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24oIHZpZXdNYXRyaXggKTtcclxuXHJcbiAgICAgICAgICAgICAgICBoZW1pT2Zmc2V0ID0gaGVtaUxlbmd0aCAqIDM7XHJcblxyXG4gICAgICAgICAgICAgICAgaGVtaVBvc2l0aW9uc1sgaGVtaU9mZnNldCArIDAgXSA9IF9kaXJlY3Rpb24ueDtcclxuICAgICAgICAgICAgICAgIGhlbWlQb3NpdGlvbnNbIGhlbWlPZmZzZXQgKyAxIF0gPSBfZGlyZWN0aW9uLnk7XHJcbiAgICAgICAgICAgICAgICBoZW1pUG9zaXRpb25zWyBoZW1pT2Zmc2V0ICsgMiBdID0gX2RpcmVjdGlvbi56O1xyXG5cclxuICAgICAgICAgICAgICAgIHNreUNvbG9yID0gbGlnaHQuY29sb3I7XHJcbiAgICAgICAgICAgICAgICBncm91bmRDb2xvciA9IGxpZ2h0Lmdyb3VuZENvbG9yO1xyXG5cclxuICAgICAgICAgICAgICAgIHNldENvbG9yTGluZWFyKCBoZW1pU2t5Q29sb3JzLCBoZW1pT2Zmc2V0LCBza3lDb2xvciwgaW50ZW5zaXR5ICk7XHJcbiAgICAgICAgICAgICAgICBzZXRDb2xvckxpbmVhciggaGVtaUdyb3VuZENvbG9ycywgaGVtaU9mZnNldCwgZ3JvdW5kQ29sb3IsIGludGVuc2l0eSApO1xyXG5cclxuICAgICAgICAgICAgICAgIGhlbWlMZW5ndGggKz0gMTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBudWxsIGV2ZW50dWFsIHJlbWFpbnMgZnJvbSByZW1vdmVkIGxpZ2h0c1xyXG4gICAgICAgIC8vICh0aGlzIGlzIHRvIGF2b2lkIGlmIGluIHNoYWRlcilcclxuXHJcbiAgICAgICAgZm9yICggbCA9IGRpckxlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIGRpckNvbG9ycy5sZW5ndGgsIGRpckNvdW50ICogMyApOyBsIDwgbGw7IGwgKysgKSBkaXJDb2xvcnNbIGwgXSA9IDAuMDtcclxuICAgICAgICBmb3IgKCBsID0gcG9pbnRMZW5ndGggKiAzLCBsbCA9IE1hdGgubWF4KCBwb2ludENvbG9ycy5sZW5ndGgsIHBvaW50Q291bnQgKiAzICk7IGwgPCBsbDsgbCArKyApIHBvaW50Q29sb3JzWyBsIF0gPSAwLjA7XHJcbiAgICAgICAgZm9yICggbCA9IHNwb3RMZW5ndGggKiAzLCBsbCA9IE1hdGgubWF4KCBzcG90Q29sb3JzLmxlbmd0aCwgc3BvdENvdW50ICogMyApOyBsIDwgbGw7IGwgKysgKSBzcG90Q29sb3JzWyBsIF0gPSAwLjA7XHJcbiAgICAgICAgZm9yICggbCA9IGhlbWlMZW5ndGggKiAzLCBsbCA9IE1hdGgubWF4KCBoZW1pU2t5Q29sb3JzLmxlbmd0aCwgaGVtaUNvdW50ICogMyApOyBsIDwgbGw7IGwgKysgKSBoZW1pU2t5Q29sb3JzWyBsIF0gPSAwLjA7XHJcbiAgICAgICAgZm9yICggbCA9IGhlbWlMZW5ndGggKiAzLCBsbCA9IE1hdGgubWF4KCBoZW1pR3JvdW5kQ29sb3JzLmxlbmd0aCwgaGVtaUNvdW50ICogMyApOyBsIDwgbGw7IGwgKysgKSBoZW1pR3JvdW5kQ29sb3JzWyBsIF0gPSAwLjA7XHJcblxyXG4gICAgICAgIHpsaWdodHMuZGlyZWN0aW9uYWwubGVuZ3RoID0gZGlyTGVuZ3RoO1xyXG4gICAgICAgIHpsaWdodHMucG9pbnQubGVuZ3RoID0gcG9pbnRMZW5ndGg7XHJcbiAgICAgICAgemxpZ2h0cy5zcG90Lmxlbmd0aCA9IHNwb3RMZW5ndGg7XHJcbiAgICAgICAgemxpZ2h0cy5oZW1pLmxlbmd0aCA9IGhlbWlMZW5ndGg7XHJcblxyXG4gICAgICAgIHpsaWdodHMuYW1iaWVudFsgMCBdID0gcjtcclxuICAgICAgICB6bGlnaHRzLmFtYmllbnRbIDEgXSA9IGc7XHJcbiAgICAgICAgemxpZ2h0cy5hbWJpZW50WyAyIF0gPSBiO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBHTCBzdGF0ZSBzZXR0aW5nXHJcblxyXG4gICAgdGhpcy5zZXRGYWNlQ3VsbGluZyA9IGZ1bmN0aW9uICggY3VsbEZhY2UsIGZyb250RmFjZURpcmVjdGlvbiApIHtcclxuXHJcbiAgICAgICAgaWYgKCBjdWxsRmFjZSA9PT0gVEhSRUUuQ3VsbEZhY2VOb25lICkge1xyXG5cclxuICAgICAgICAgICAgc3RhdGUuZGlzYWJsZSggX2dsLkNVTExfRkFDRSApO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBmcm9udEZhY2VEaXJlY3Rpb24gPT09IFRIUkVFLkZyb250RmFjZURpcmVjdGlvbkNXICkge1xyXG5cclxuICAgICAgICAgICAgICAgIF9nbC5mcm9udEZhY2UoIF9nbC5DVyApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICBfZ2wuZnJvbnRGYWNlKCBfZ2wuQ0NXICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIGN1bGxGYWNlID09PSBUSFJFRS5DdWxsRmFjZUJhY2sgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgX2dsLmN1bGxGYWNlKCBfZ2wuQkFDSyApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIGlmICggY3VsbEZhY2UgPT09IFRIUkVFLkN1bGxGYWNlRnJvbnQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgX2dsLmN1bGxGYWNlKCBfZ2wuRlJPTlQgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgX2dsLmN1bGxGYWNlKCBfZ2wuRlJPTlRfQU5EX0JBQ0sgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHN0YXRlLmVuYWJsZSggX2dsLkNVTExfRkFDRSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBUZXh0dXJlc1xyXG5cclxuICAgIGZ1bmN0aW9uIHNldFRleHR1cmVQYXJhbWV0ZXJzICggdGV4dHVyZVR5cGUsIHRleHR1cmUsIGlzSW1hZ2VQb3dlck9mVHdvICkge1xyXG5cclxuICAgICAgICB2YXIgZXh0ZW5zaW9uO1xyXG5cclxuICAgICAgICBpZiAoIGlzSW1hZ2VQb3dlck9mVHdvICkge1xyXG5cclxuICAgICAgICAgICAgX2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1MsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLndyYXBTICkgKTtcclxuICAgICAgICAgICAgX2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1QsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLndyYXBUICkgKTtcclxuXHJcbiAgICAgICAgICAgIF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUubWFnRmlsdGVyICkgKTtcclxuICAgICAgICAgICAgX2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5taW5GaWx0ZXIgKSApO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgX2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1MsIF9nbC5DTEFNUF9UT19FREdFICk7XHJcbiAgICAgICAgICAgIF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9ULCBfZ2wuQ0xBTVBfVE9fRURHRSApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCB0ZXh0dXJlLndyYXBTICE9PSBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nIHx8IHRleHR1cmUud3JhcFQgIT09IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBpcyBub3QgcG93ZXIgb2YgdHdvLiBUZXh0dXJlLndyYXBTIGFuZCBUZXh0dXJlLndyYXBUIHNob3VsZCBiZSBzZXQgdG8gVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZy4nLCB0ZXh0dXJlICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01BR19GSUxURVIsIGZpbHRlckZhbGxiYWNrKCB0ZXh0dXJlLm1hZ0ZpbHRlciApICk7XHJcbiAgICAgICAgICAgIF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZmlsdGVyRmFsbGJhY2soIHRleHR1cmUubWluRmlsdGVyICkgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggdGV4dHVyZS5taW5GaWx0ZXIgIT09IFRIUkVFLk5lYXJlc3RGaWx0ZXIgJiYgdGV4dHVyZS5taW5GaWx0ZXIgIT09IFRIUkVFLkxpbmVhckZpbHRlciApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIGlzIG5vdCBwb3dlciBvZiB0d28uIFRleHR1cmUubWluRmlsdGVyIHNob3VsZCBiZSBzZXQgdG8gVEhSRUUuTmVhcmVzdEZpbHRlciBvciBUSFJFRS5MaW5lYXJGaWx0ZXIuJywgdGV4dHVyZSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApO1xyXG5cclxuICAgICAgICBpZiAoIGV4dGVuc2lvbiApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggdGV4dHVyZS50eXBlID09PSBUSFJFRS5GbG9hdFR5cGUgJiYgZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInICkgPT09IG51bGwgKSByZXR1cm47XHJcbiAgICAgICAgICAgIGlmICggdGV4dHVyZS50eXBlID09PSBUSFJFRS5IYWxmRmxvYXRUeXBlICYmIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXInICkgPT09IG51bGwgKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBpZiAoIHRleHR1cmUuYW5pc290cm9weSA+IDEgfHwgcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKS5fX2N1cnJlbnRBbmlzb3Ryb3B5ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIF9nbC50ZXhQYXJhbWV0ZXJmKCB0ZXh0dXJlVHlwZSwgZXh0ZW5zaW9uLlRFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhULCBNYXRoLm1pbiggdGV4dHVyZS5hbmlzb3Ryb3B5LCBfdGhpcy5nZXRNYXhBbmlzb3Ryb3B5KCkgKSApO1xyXG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKS5fX2N1cnJlbnRBbmlzb3Ryb3B5ID0gdGV4dHVyZS5hbmlzb3Ryb3B5O1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVwbG9hZFRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlLCBzbG90ICkge1xyXG5cclxuICAgICAgICBpZiAoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xJbml0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsSW5pdCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICB0ZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSApO1xyXG5cclxuICAgICAgICAgICAgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgPSBfZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG5cclxuICAgICAgICAgICAgX2luZm9NZW1vcnkudGV4dHVyZXMgKys7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xyXG4gICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcclxuXHJcbiAgICAgICAgX2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdGV4dHVyZS5mbGlwWSApO1xyXG4gICAgICAgIF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdGV4dHVyZS5wcmVtdWx0aXBseUFscGhhICk7XHJcbiAgICAgICAgX2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0FMSUdOTUVOVCwgdGV4dHVyZS51bnBhY2tBbGlnbm1lbnQgKTtcclxuXHJcbiAgICAgICAgdGV4dHVyZS5pbWFnZSA9IGNsYW1wVG9NYXhTaXplKCB0ZXh0dXJlLmltYWdlLCBjYXBhYmlsaXRpZXMubWF4VGV4dHVyZVNpemUgKTtcclxuXHJcbiAgICAgICAgaWYgKCB0ZXh0dXJlTmVlZHNQb3dlck9mVHdvKCB0ZXh0dXJlICkgJiYgaXNQb3dlck9mVHdvKCB0ZXh0dXJlLmltYWdlICkgPT09IGZhbHNlICkge1xyXG5cclxuICAgICAgICAgICAgdGV4dHVyZS5pbWFnZSA9IG1ha2VQb3dlck9mVHdvKCB0ZXh0dXJlLmltYWdlICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGltYWdlID0gdGV4dHVyZS5pbWFnZSxcclxuICAgICAgICAgICAgaXNJbWFnZVBvd2VyT2ZUd28gPSBpc1Bvd2VyT2ZUd28oIGltYWdlICksXHJcbiAgICAgICAgICAgIGdsRm9ybWF0ID0gcGFyYW1UaHJlZVRvR0woIHRleHR1cmUuZm9ybWF0ICksXHJcbiAgICAgICAgICAgIGdsVHlwZSA9IHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLnR5cGUgKTtcclxuXHJcbiAgICAgICAgc2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFXzJELCB0ZXh0dXJlLCBpc0ltYWdlUG93ZXJPZlR3byApO1xyXG5cclxuICAgICAgICB2YXIgbWlwbWFwLCBtaXBtYXBzID0gdGV4dHVyZS5taXBtYXBzO1xyXG5cclxuICAgICAgICBpZiAoIHRleHR1cmUgaW5zdGFuY2VvZiBUSFJFRS5EYXRhVGV4dHVyZSApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIHVzZSBtYW51YWxseSBjcmVhdGVkIG1pcG1hcHMgaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyBtYW51YWwgbWlwbWFwc1xyXG4gICAgICAgICAgICAvLyBzZXQgMCBsZXZlbCBtaXBtYXAgYW5kIHRoZW4gdXNlIEdMIHRvIGdlbmVyYXRlIG90aGVyIG1pcG1hcCBsZXZlbHNcclxuXHJcbiAgICAgICAgICAgIGlmICggbWlwbWFwcy5sZW5ndGggPiAwICYmIGlzSW1hZ2VQb3dlck9mVHdvICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBtaXBtYXAgPSBtaXBtYXBzWyBpIF07XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcC5kYXRhICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBnbEZvcm1hdCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UuZGF0YSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUgKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBtaXBtYXAgPSBtaXBtYXBzWyBpIF07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCB0ZXh0dXJlLmZvcm1hdCAhPT0gVEhSRUUuUkdCQUZvcm1hdCAmJiB0ZXh0dXJlLmZvcm1hdCAhPT0gVEhSRUUuUkdCRm9ybWF0ICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHN0YXRlLmdldENvbXByZXNzZWRUZXh0dXJlRm9ybWF0cygpLmluZGV4T2YoIGdsRm9ybWF0ICkgPiAtIDEgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jb21wcmVzc2VkVGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIG1pcG1hcC5kYXRhICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oIFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byBsb2FkIHVuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXQgaW4gLnVwbG9hZFRleHR1cmUoKVwiICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAvLyByZWd1bGFyIFRleHR1cmUgKGltYWdlLCB2aWRlbywgY2FudmFzKVxyXG5cclxuICAgICAgICAgICAgLy8gdXNlIG1hbnVhbGx5IGNyZWF0ZWQgbWlwbWFwcyBpZiBhdmFpbGFibGVcclxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1hbnVhbCBtaXBtYXBzXHJcbiAgICAgICAgICAgIC8vIHNldCAwIGxldmVsIG1pcG1hcCBhbmQgdGhlbiB1c2UgR0wgdG8gZ2VuZXJhdGUgb3RoZXIgbWlwbWFwIGxldmVsc1xyXG5cclxuICAgICAgICAgICAgaWYgKCBtaXBtYXBzLmxlbmd0aCA+IDAgJiYgaXNJbWFnZVBvd2VyT2ZUd28gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IG1pcG1hcHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG1pcG1hcCA9IG1pcG1hcHNbIGkgXTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcCApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgZ2xGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIHRleHR1cmUuaW1hZ2UgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzICYmIGlzSW1hZ2VQb3dlck9mVHdvICkgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV8yRCApO1xyXG5cclxuICAgICAgICB0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gPSB0ZXh0dXJlLnZlcnNpb247XHJcblxyXG4gICAgICAgIGlmICggdGV4dHVyZS5vblVwZGF0ZSApIHRleHR1cmUub25VcGRhdGUoIHRleHR1cmUgKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zZXRUZXh0dXJlID0gZnVuY3Rpb24gKCB0ZXh0dXJlLCBzbG90ICkge1xyXG5cclxuICAgICAgICB2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApO1xyXG5cclxuICAgICAgICBpZiAoIHRleHR1cmUudmVyc2lvbiA+IDAgJiYgdGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uICE9PSB0ZXh0dXJlLnZlcnNpb24gKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgaW1hZ2UgPSB0ZXh0dXJlLmltYWdlO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBpbWFnZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgbWFya2VkIGZvciB1cGRhdGUgYnV0IGltYWdlIGlzIHVuZGVmaW5lZCcsIHRleHR1cmUgKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggaW1hZ2UuY29tcGxldGUgPT09IGZhbHNlICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgbWFya2VkIGZvciB1cGRhdGUgYnV0IGltYWdlIGlzIGluY29tcGxldGUnLCB0ZXh0dXJlICk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB1cGxvYWRUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcywgdGV4dHVyZSwgc2xvdCApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcclxuICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBjbGFtcFRvTWF4U2l6ZSAoIGltYWdlLCBtYXhTaXplICkge1xyXG5cclxuICAgICAgICBpZiAoIGltYWdlLndpZHRoID4gbWF4U2l6ZSB8fCBpbWFnZS5oZWlnaHQgPiBtYXhTaXplICkge1xyXG5cclxuICAgICAgICAgICAgLy8gV2FybmluZzogU2NhbGluZyB0aHJvdWdoIHRoZSBjYW52YXMgd2lsbCBvbmx5IHdvcmsgd2l0aCBpbWFnZXMgdGhhdCB1c2VcclxuICAgICAgICAgICAgLy8gcHJlbXVsdGlwbGllZCBhbHBoYS5cclxuXHJcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IG1heFNpemUgLyBNYXRoLm1heCggaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCApO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XHJcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IE1hdGguZmxvb3IoIGltYWdlLndpZHRoICogc2NhbGUgKTtcclxuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IE1hdGguZmxvb3IoIGltYWdlLmhlaWdodCAqIHNjYWxlICk7XHJcblxyXG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKCBpbWFnZSwgMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0ICk7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBpbWFnZSBpcyB0b28gYmlnICgnICsgaW1hZ2Uud2lkdGggKyAneCcgKyBpbWFnZS5oZWlnaHQgKyAnKS4gUmVzaXplZCB0byAnICsgY2FudmFzLndpZHRoICsgJ3gnICsgY2FudmFzLmhlaWdodCwgaW1hZ2UgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBjYW52YXM7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGltYWdlO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc1Bvd2VyT2ZUd28oIGltYWdlICkge1xyXG5cclxuICAgICAgICByZXR1cm4gVEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oIGltYWdlLndpZHRoICkgJiYgVEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oIGltYWdlLmhlaWdodCApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0ZXh0dXJlTmVlZHNQb3dlck9mVHdvKCB0ZXh0dXJlICkge1xyXG5cclxuICAgICAgICBpZiAoIHRleHR1cmUud3JhcFMgIT09IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcgfHwgdGV4dHVyZS53cmFwVCAhPT0gVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZyApIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGlmICggdGV4dHVyZS5taW5GaWx0ZXIgIT09IFRIUkVFLk5lYXJlc3RGaWx0ZXIgJiYgdGV4dHVyZS5taW5GaWx0ZXIgIT09IFRIUkVFLkxpbmVhckZpbHRlciApIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1ha2VQb3dlck9mVHdvKCBpbWFnZSApIHtcclxuXHJcbiAgICAgICAgaWYgKCBpbWFnZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgfHwgaW1hZ2UgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xyXG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSBUSFJFRS5NYXRoLm5lYXJlc3RQb3dlck9mVHdvKCBpbWFnZS53aWR0aCApO1xyXG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gVEhSRUUuTWF0aC5uZWFyZXN0UG93ZXJPZlR3byggaW1hZ2UuaGVpZ2h0ICk7XHJcblxyXG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKCBpbWFnZSwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0ICk7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBpbWFnZSBpcyBub3QgcG93ZXIgb2YgdHdvICgnICsgaW1hZ2Uud2lkdGggKyAneCcgKyBpbWFnZS5oZWlnaHQgKyAnKS4gUmVzaXplZCB0byAnICsgY2FudmFzLndpZHRoICsgJ3gnICsgY2FudmFzLmhlaWdodCwgaW1hZ2UgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBjYW52YXM7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGltYWdlO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXRDdWJlVGV4dHVyZSAoIHRleHR1cmUsIHNsb3QgKSB7XHJcblxyXG4gICAgICAgIHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICk7XHJcblxyXG4gICAgICAgIGlmICggdGV4dHVyZS5pbWFnZS5sZW5ndGggPT09IDYgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHRleHR1cmUudmVyc2lvbiA+IDAgJiYgdGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uICE9PSB0ZXh0dXJlLnZlcnNpb24gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCAhIHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgPSBfZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBfaW5mb01lbW9yeS50ZXh0dXJlcyArKztcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xyXG4gICAgICAgICAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlICk7XHJcblxyXG4gICAgICAgICAgICAgICAgX2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdGV4dHVyZS5mbGlwWSApO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBpc0NvbXByZXNzZWQgPSB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuQ29tcHJlc3NlZFRleHR1cmU7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNEYXRhVGV4dHVyZSA9IHRleHR1cmUuaW1hZ2VbIDAgXSBpbnN0YW5jZW9mIFRIUkVFLkRhdGFUZXh0dXJlO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBjdWJlSW1hZ2UgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIF90aGlzLmF1dG9TY2FsZUN1YmVtYXBzICYmICEgaXNDb21wcmVzc2VkICYmICEgaXNEYXRhVGV4dHVyZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1YmVJbWFnZVsgaSBdID0gY2xhbXBUb01heFNpemUoIHRleHR1cmUuaW1hZ2VbIGkgXSwgY2FwYWJpbGl0aWVzLm1heEN1YmVtYXBTaXplICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdWJlSW1hZ2VbIGkgXSA9IGlzRGF0YVRleHR1cmUgPyB0ZXh0dXJlLmltYWdlWyBpIF0uaW1hZ2UgOiB0ZXh0dXJlLmltYWdlWyBpIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGltYWdlID0gY3ViZUltYWdlWyAwIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgaXNJbWFnZVBvd2VyT2ZUd28gPSBpc1Bvd2VyT2ZUd28oIGltYWdlICksXHJcbiAgICAgICAgICAgICAgICAgICAgZ2xGb3JtYXQgPSBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5mb3JtYXQgKSxcclxuICAgICAgICAgICAgICAgICAgICBnbFR5cGUgPSBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS50eXBlICk7XHJcblxyXG4gICAgICAgICAgICAgICAgc2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlLCBpc0ltYWdlUG93ZXJPZlR3byApO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggISBpc0NvbXByZXNzZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGlzRGF0YVRleHR1cmUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIGdsRm9ybWF0LCBjdWJlSW1hZ2VbIGkgXS53aWR0aCwgY3ViZUltYWdlWyBpIF0uaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBjdWJlSW1hZ2VbIGkgXS5kYXRhICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCBnbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgY3ViZUltYWdlWyBpIF0gKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaXBtYXAsIG1pcG1hcHMgPSBjdWJlSW1hZ2VbIGkgXS5taXBtYXBzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IG1pcG1hcHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlwbWFwID0gbWlwbWFwc1sgaiBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdGV4dHVyZS5mb3JtYXQgIT09IFRIUkVFLlJHQkFGb3JtYXQgJiYgdGV4dHVyZS5mb3JtYXQgIT09IFRIUkVFLlJHQkZvcm1hdCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzdGF0ZS5nZXRDb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMoKS5pbmRleE9mKCBnbEZvcm1hdCApID4gLSAxICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuY29tcHJlc3NlZFRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCBqLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBtaXBtYXAuZGF0YSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCBcIlRIUkVFLldlYkdMUmVuZGVyZXI6IEF0dGVtcHQgdG8gbG9hZCB1bnN1cHBvcnRlZCBjb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0IGluIC5zZXRDdWJlVGV4dHVyZSgpXCIgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCBqLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzICYmIGlzSW1hZ2VQb3dlck9mVHdvICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFX0NVQkVfTUFQICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiA9IHRleHR1cmUudmVyc2lvbjtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHRleHR1cmUub25VcGRhdGUgKSB0ZXh0dXJlLm9uVXBkYXRlKCB0ZXh0dXJlICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcclxuICAgICAgICAgICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldEN1YmVUZXh0dXJlRHluYW1pYyAoIHRleHR1cmUsIHNsb3QgKSB7XHJcblxyXG4gICAgICAgIHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcclxuICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICkuX193ZWJnbFRleHR1cmUgKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVuZGVyIHRhcmdldHNcclxuXHJcbiAgICBmdW5jdGlvbiBzZXR1cEZyYW1lQnVmZmVyICggZnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgdGV4dHVyZVRhcmdldCApIHtcclxuXHJcbiAgICAgICAgX2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciApO1xyXG4gICAgICAgIF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAsIHRleHR1cmVUYXJnZXQsIHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApLl9fd2ViZ2xUZXh0dXJlLCAwICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldHVwUmVuZGVyQnVmZmVyICggcmVuZGVyYnVmZmVyLCByZW5kZXJUYXJnZXQgKSB7XHJcblxyXG4gICAgICAgIF9nbC5iaW5kUmVuZGVyYnVmZmVyKCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIgKTtcclxuXHJcbiAgICAgICAgaWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgISByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcclxuXHJcbiAgICAgICAgICAgIF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBfZ2wuUkVOREVSQlVGRkVSLCBfZ2wuREVQVEhfQ09NUE9ORU5UMTYsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCApO1xyXG4gICAgICAgICAgICBfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xyXG5cclxuICAgICAgICAgICAgLyogRm9yIHNvbWUgcmVhc29uIHRoaXMgaXMgbm90IHdvcmtpbmcuIERlZmF1bHRpbmcgdG8gUkdCQTQuXHJcbiAgICAgICAgICAgICB9IGVsc2UgaWYgKCAhIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciAmJiByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcclxuXHJcbiAgICAgICAgICAgICBfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLlNURU5DSUxfSU5ERVg4LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcclxuICAgICAgICAgICAgIF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuU1RFTkNJTF9BVFRBQ0hNRU5ULCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIgKTtcclxuICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciAmJiByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcclxuXHJcbiAgICAgICAgICAgIF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBfZ2wuUkVOREVSQlVGRkVSLCBfZ2wuREVQVEhfU1RFTkNJTCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XHJcbiAgICAgICAgICAgIF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIgKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBfZ2wuUkVOREVSQlVGRkVSLCBfZ2wuUkdCQTQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc2V0UmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gKCByZW5kZXJUYXJnZXQgKSB7XHJcblxyXG4gICAgICAgIHZhciBpc0N1YmUgPSAoIHJlbmRlclRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApO1xyXG5cclxuICAgICAgICBpZiAoIHJlbmRlclRhcmdldCAmJiBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICkuX193ZWJnbEZyYW1lYnVmZmVyID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcclxuICAgICAgICAgICAgdmFyIHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldC50ZXh0dXJlICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciA9PT0gdW5kZWZpbmVkICkgcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKCByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciA9PT0gdW5kZWZpbmVkICkgcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgcmVuZGVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25SZW5kZXJUYXJnZXREaXNwb3NlICk7XHJcblxyXG4gICAgICAgICAgICB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XHJcblxyXG4gICAgICAgICAgICBfaW5mb01lbW9yeS50ZXh0dXJlcyArKztcclxuXHJcbiAgICAgICAgICAgIC8vIFNldHVwIHRleHR1cmUsIGNyZWF0ZSByZW5kZXIgYW5kIGZyYW1lIGJ1ZmZlcnNcclxuXHJcbiAgICAgICAgICAgIHZhciBpc1RhcmdldFBvd2VyT2ZUd28gPSBpc1Bvd2VyT2ZUd28oIHJlbmRlclRhcmdldCApLFxyXG4gICAgICAgICAgICAgICAgZ2xGb3JtYXQgPSBwYXJhbVRocmVlVG9HTCggcmVuZGVyVGFyZ2V0LnRleHR1cmUuZm9ybWF0ICksXHJcbiAgICAgICAgICAgICAgICBnbFR5cGUgPSBwYXJhbVRocmVlVG9HTCggcmVuZGVyVGFyZ2V0LnRleHR1cmUudHlwZSApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBpc0N1YmUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgPSBbXTtcclxuICAgICAgICAgICAgICAgIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbFJlbmRlcmJ1ZmZlciA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHJlbmRlclRhcmdldC50ZXh0dXJlLCBpc1RhcmdldFBvd2VyT2ZUd28gKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdID0gX2dsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsUmVuZGVyYnVmZmVyWyBpIF0gPSBfZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIGdsRm9ybWF0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG51bGwgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBGcmFtZUJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSwgcmVuZGVyVGFyZ2V0LCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSApO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwUmVuZGVyQnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXJbIGkgXSwgcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICggcmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzICYmIGlzVGFyZ2V0UG93ZXJPZlR3byApIF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfQ1VCRV9NQVAgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgPSBfZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHJlbmRlclRhcmdldC5zaGFyZURlcHRoRnJvbSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsUmVuZGVyYnVmZmVyID0gcmVuZGVyVGFyZ2V0LnNoYXJlRGVwdGhGcm9tLl9fd2ViZ2xSZW5kZXJidWZmZXI7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsUmVuZGVyYnVmZmVyID0gX2dsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XHJcbiAgICAgICAgICAgICAgICBzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfMkQsIHJlbmRlclRhcmdldC50ZXh0dXJlLCBpc1RhcmdldFBvd2VyT2ZUd28gKTtcclxuXHJcbiAgICAgICAgICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgZ2xGb3JtYXQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbnVsbCApO1xyXG5cclxuICAgICAgICAgICAgICAgIHNldHVwRnJhbWVCdWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQsIF9nbC5URVhUVVJFXzJEICk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCByZW5kZXJUYXJnZXQuc2hhcmVEZXB0aEZyb20gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmICEgcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbFJlbmRlcmJ1ZmZlciApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsUmVuZGVyYnVmZmVyICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzZXR1cFJlbmRlckJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsUmVuZGVyYnVmZmVyLCByZW5kZXJUYXJnZXQgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCByZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgJiYgaXNUYXJnZXRQb3dlck9mVHdvICkgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV8yRCApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUmVsZWFzZSBldmVyeXRoaW5nXHJcblxyXG4gICAgICAgICAgICBpZiAoIGlzQ3ViZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCBudWxsICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfZ2wuYmluZFJlbmRlcmJ1ZmZlciggX2dsLlJFTkRFUkJVRkZFUiwgbnVsbCApO1xyXG4gICAgICAgICAgICBfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIG51bGwgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZnJhbWVidWZmZXIsIHdpZHRoLCBoZWlnaHQsIHZ4LCB2eTtcclxuXHJcbiAgICAgICAgaWYgKCByZW5kZXJUYXJnZXQgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggaXNDdWJlICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGZyYW1lYnVmZmVyID0gcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSBdO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICBmcmFtZWJ1ZmZlciA9IHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgd2lkdGggPSByZW5kZXJUYXJnZXQud2lkdGg7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IHJlbmRlclRhcmdldC5oZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICB2eCA9IDA7XHJcbiAgICAgICAgICAgIHZ5ID0gMDtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIGZyYW1lYnVmZmVyID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIHdpZHRoID0gX3ZpZXdwb3J0V2lkdGg7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IF92aWV3cG9ydEhlaWdodDtcclxuXHJcbiAgICAgICAgICAgIHZ4ID0gX3ZpZXdwb3J0WDtcclxuICAgICAgICAgICAgdnkgPSBfdmlld3BvcnRZO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggZnJhbWVidWZmZXIgIT09IF9jdXJyZW50RnJhbWVidWZmZXIgKSB7XHJcblxyXG4gICAgICAgICAgICBfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyICk7XHJcbiAgICAgICAgICAgIF9nbC52aWV3cG9ydCggdngsIHZ5LCB3aWR0aCwgaGVpZ2h0ICk7XHJcblxyXG4gICAgICAgICAgICBfY3VycmVudEZyYW1lYnVmZmVyID0gZnJhbWVidWZmZXI7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBpc0N1YmUgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKTtcclxuICAgICAgICAgICAgX2dsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUsIDAgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBfY3VycmVudFdpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgX2N1cnJlbnRIZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHMgPSBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgYnVmZmVyICkge1xyXG5cclxuICAgICAgICBpZiAoIHJlbmRlclRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0ID09PSBmYWxzZSApIHtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQuJyApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGZyYW1lYnVmZmVyID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApLl9fd2ViZ2xGcmFtZWJ1ZmZlcjtcclxuXHJcbiAgICAgICAgaWYgKCBmcmFtZWJ1ZmZlciApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciByZXN0b3JlID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGZyYW1lYnVmZmVyICE9PSBfY3VycmVudEZyYW1lYnVmZmVyICkge1xyXG5cclxuICAgICAgICAgICAgICAgIF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXN0b3JlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRyeSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHRleHR1cmUgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHRleHR1cmUuZm9ybWF0ICE9PSBUSFJFRS5SR0JBRm9ybWF0XHJcbiAgICAgICAgICAgICAgICAgICAgJiYgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUuZm9ybWF0ICkgIT09IF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5JTVBMRU1FTlRBVElPTl9DT0xPUl9SRUFEX0ZPUk1BVCApICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZW5kZXJUYXJnZXQgaXMgbm90IGluIFJHQkEgb3IgaW1wbGVtZW50YXRpb24gZGVmaW5lZCBmb3JtYXQuJyApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCB0ZXh0dXJlLnR5cGUgIT09IFRIUkVFLlVuc2lnbmVkQnl0ZVR5cGVcclxuICAgICAgICAgICAgICAgICAgICAmJiBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS50eXBlICkgIT09IF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5JTVBMRU1FTlRBVElPTl9DT0xPUl9SRUFEX1RZUEUgKVxyXG4gICAgICAgICAgICAgICAgICAgICYmICEgKCB0ZXh0dXJlLnR5cGUgPT09IFRIUkVFLkZsb2F0VHlwZSAmJiBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdCcgKSApXHJcbiAgICAgICAgICAgICAgICAgICAgJiYgISAoIHRleHR1cmUudHlwZSA9PT0gVEhSRUUuSGFsZkZsb2F0VHlwZSAmJiBleHRlbnNpb25zLmdldCggJ0VYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdCcgKSApICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZW5kZXJUYXJnZXQgaXMgbm90IGluIFVuc2lnbmVkQnl0ZVR5cGUgb3IgaW1wbGVtZW50YXRpb24gZGVmaW5lZCB0eXBlLicgKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICggX2dsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoIF9nbC5GUkFNRUJVRkZFUiApID09PSBfZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9nbC5yZWFkUGl4ZWxzKCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5mb3JtYXQgKSwgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUudHlwZSApLCBidWZmZXIgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZWFkUGl4ZWxzIGZyb20gcmVuZGVyVGFyZ2V0IGZhaWxlZC4gRnJhbWVidWZmZXIgbm90IGNvbXBsZXRlLicgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9IGZpbmFsbHkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggcmVzdG9yZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfY3VycmVudEZyYW1lYnVmZmVyICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXAoIHJlbmRlclRhcmdldCApIHtcclxuXHJcbiAgICAgICAgdmFyIHRhcmdldCA9IHJlbmRlclRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSA/IF9nbC5URVhUVVJFX0NVQkVfTUFQIDogX2dsLlRFWFRVUkVfMkQ7XHJcbiAgICAgICAgdmFyIHRleHR1cmUgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKS5fX3dlYmdsVGV4dHVyZTtcclxuXHJcbiAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIHRhcmdldCwgdGV4dHVyZSApO1xyXG4gICAgICAgIF9nbC5nZW5lcmF0ZU1pcG1hcCggdGFyZ2V0ICk7XHJcbiAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIHRhcmdldCwgbnVsbCApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBGYWxsYmFjayBmaWx0ZXJzIGZvciBub24tcG93ZXItb2YtMiB0ZXh0dXJlc1xyXG5cclxuICAgIGZ1bmN0aW9uIGZpbHRlckZhbGxiYWNrICggZiApIHtcclxuXHJcbiAgICAgICAgaWYgKCBmID09PSBUSFJFRS5OZWFyZXN0RmlsdGVyIHx8IGYgPT09IFRIUkVFLk5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyIHx8IGYgPT09IFRIUkVFLk5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gX2dsLk5FQVJFU1Q7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIF9nbC5MSU5FQVI7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vIE1hcCB0aHJlZS5qcyBjb25zdGFudHMgdG8gV2ViR0wgY29uc3RhbnRzXHJcblxyXG4gICAgZnVuY3Rpb24gcGFyYW1UaHJlZVRvR0wgKCBwICkge1xyXG5cclxuICAgICAgICB2YXIgZXh0ZW5zaW9uO1xyXG5cclxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlJlcGVhdFdyYXBwaW5nICkgcmV0dXJuIF9nbC5SRVBFQVQ7XHJcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nICkgcmV0dXJuIF9nbC5DTEFNUF9UT19FREdFO1xyXG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZyApIHJldHVybiBfZ2wuTUlSUk9SRURfUkVQRUFUO1xyXG5cclxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLk5lYXJlc3RGaWx0ZXIgKSByZXR1cm4gX2dsLk5FQVJFU1Q7XHJcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5OZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciApIHJldHVybiBfZ2wuTkVBUkVTVF9NSVBNQVBfTkVBUkVTVDtcclxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLk5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIgKSByZXR1cm4gX2dsLk5FQVJFU1RfTUlQTUFQX0xJTkVBUjtcclxuXHJcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5MaW5lYXJGaWx0ZXIgKSByZXR1cm4gX2dsLkxJTkVBUjtcclxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLkxpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXIgKSByZXR1cm4gX2dsLkxJTkVBUl9NSVBNQVBfTkVBUkVTVDtcclxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLkxpbmVhck1pcE1hcExpbmVhckZpbHRlciApIHJldHVybiBfZ2wuTElORUFSX01JUE1BUF9MSU5FQVI7XHJcblxyXG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuVW5zaWduZWRCeXRlVHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfQllURTtcclxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkU2hvcnQ0NDQ0VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfU0hPUlRfNF80XzRfNDtcclxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkU2hvcnQ1NTUxVHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfU0hPUlRfNV81XzVfMTtcclxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkU2hvcnQ1NjVUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9TSE9SVF81XzZfNTtcclxuXHJcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5CeXRlVHlwZSApIHJldHVybiBfZ2wuQllURTtcclxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlNob3J0VHlwZSApIHJldHVybiBfZ2wuU0hPUlQ7XHJcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZFNob3J0VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfU0hPUlQ7XHJcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5JbnRUeXBlICkgcmV0dXJuIF9nbC5JTlQ7XHJcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZEludFR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX0lOVDtcclxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLkZsb2F0VHlwZSApIHJldHVybiBfZ2wuRkxPQVQ7XHJcblxyXG4gICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcgKTtcclxuXHJcbiAgICAgICAgaWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHAgPT09IFRIUkVFLkhhbGZGbG9hdFR5cGUgKSByZXR1cm4gZXh0ZW5zaW9uLkhBTEZfRkxPQVRfT0VTO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuQWxwaGFGb3JtYXQgKSByZXR1cm4gX2dsLkFMUEhBO1xyXG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuUkdCRm9ybWF0ICkgcmV0dXJuIF9nbC5SR0I7XHJcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5SR0JBRm9ybWF0ICkgcmV0dXJuIF9nbC5SR0JBO1xyXG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuTHVtaW5hbmNlRm9ybWF0ICkgcmV0dXJuIF9nbC5MVU1JTkFOQ0U7XHJcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5MdW1pbmFuY2VBbHBoYUZvcm1hdCApIHJldHVybiBfZ2wuTFVNSU5BTkNFX0FMUEhBO1xyXG5cclxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLkFkZEVxdWF0aW9uICkgcmV0dXJuIF9nbC5GVU5DX0FERDtcclxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlN1YnRyYWN0RXF1YXRpb24gKSByZXR1cm4gX2dsLkZVTkNfU1VCVFJBQ1Q7XHJcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5SZXZlcnNlU3VidHJhY3RFcXVhdGlvbiApIHJldHVybiBfZ2wuRlVOQ19SRVZFUlNFX1NVQlRSQUNUO1xyXG5cclxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlplcm9GYWN0b3IgKSByZXR1cm4gX2dsLlpFUk87XHJcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5PbmVGYWN0b3IgKSByZXR1cm4gX2dsLk9ORTtcclxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlNyY0NvbG9yRmFjdG9yICkgcmV0dXJuIF9nbC5TUkNfQ09MT1I7XHJcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5PbmVNaW51c1NyY0NvbG9yRmFjdG9yICkgcmV0dXJuIF9nbC5PTkVfTUlOVVNfU1JDX0NPTE9SO1xyXG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuU3JjQWxwaGFGYWN0b3IgKSByZXR1cm4gX2dsLlNSQ19BTFBIQTtcclxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgKSByZXR1cm4gX2dsLk9ORV9NSU5VU19TUkNfQUxQSEE7XHJcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5Ec3RBbHBoYUZhY3RvciApIHJldHVybiBfZ2wuRFNUX0FMUEhBO1xyXG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuT25lTWludXNEc3RBbHBoYUZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX0RTVF9BTFBIQTtcclxuXHJcbiAgICAgICAgaWYgKCBwID09PSBUSFJFRS5Ec3RDb2xvckZhY3RvciApIHJldHVybiBfZ2wuRFNUX0NPTE9SO1xyXG4gICAgICAgIGlmICggcCA9PT0gVEhSRUUuT25lTWludXNEc3RDb2xvckZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX0RTVF9DT0xPUjtcclxuICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlNyY0FscGhhU2F0dXJhdGVGYWN0b3IgKSByZXR1cm4gX2dsLlNSQ19BTFBIQV9TQVRVUkFURTtcclxuXHJcbiAgICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKTtcclxuXHJcbiAgICAgICAgaWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlJHQl9TM1RDX0RYVDFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9TM1RDX0RYVDFfRVhUO1xyXG4gICAgICAgICAgICBpZiAoIHAgPT09IFRIUkVFLlJHQkFfUzNUQ19EWFQxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFQ7XHJcbiAgICAgICAgICAgIGlmICggcCA9PT0gVEhSRUUuUkdCQV9TM1RDX0RYVDNfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVDtcclxuICAgICAgICAgICAgaWYgKCBwID09PSBUSFJFRS5SR0JBX1MzVENfRFhUNV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDVfRVhUO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApO1xyXG5cclxuICAgICAgICBpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggcCA9PT0gVEhSRUUuUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX1BWUlRDXzRCUFBWMV9JTUc7XHJcbiAgICAgICAgICAgIGlmICggcCA9PT0gVEhSRUUuUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX1BWUlRDXzJCUFBWMV9JTUc7XHJcbiAgICAgICAgICAgIGlmICggcCA9PT0gVEhSRUUuUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUFZSVENfNEJQUFYxX0lNRztcclxuICAgICAgICAgICAgaWYgKCBwID09PSBUSFJFRS5SR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9QVlJUQ18yQlBQVjFfSU1HO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnRVhUX2JsZW5kX21pbm1heCcgKTtcclxuXHJcbiAgICAgICAgaWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHAgPT09IFRIUkVFLk1pbkVxdWF0aW9uICkgcmV0dXJuIGV4dGVuc2lvbi5NSU5fRVhUO1xyXG4gICAgICAgICAgICBpZiAoIHAgPT09IFRIUkVFLk1heEVxdWF0aW9uICkgcmV0dXJuIGV4dGVuc2lvbi5NQVhfRVhUO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAwO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBERVBSRUNBVEVEXHJcblxyXG4gICAgdGhpcy5zdXBwb3J0c0Zsb2F0VGV4dHVyZXMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0Zsb2F0VGV4dHVyZXMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdPRVNfdGV4dHVyZV9mbG9hdFxcJyApLicgKTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdCcgKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc3VwcG9ydHNIYWxmRmxvYXRUZXh0dXJlcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzSGFsZkZsb2F0VGV4dHVyZXMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0XFwnICkuJyApO1xyXG4gICAgICAgIHJldHVybiBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnICk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnN1cHBvcnRzU3RhbmRhcmREZXJpdmF0aXZlcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzU3RhbmRhcmREZXJpdmF0aXZlcygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlc1xcJyApLicgKTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5zaW9ucy5nZXQoICdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnICk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVTM1RDID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVMzVEMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1xcJyApLicgKTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVBWUlRDID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVBWUlRDKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjXFwnICkuJyApO1xyXG4gICAgICAgIHJldHVybiBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc3VwcG9ydHNCbGVuZE1pbk1heCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzQmxlbmRNaW5NYXgoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdFWFRfYmxlbmRfbWlubWF4XFwnICkuJyApO1xyXG4gICAgICAgIHJldHVybiBleHRlbnNpb25zLmdldCggJ0VYVF9ibGVuZF9taW5tYXgnICk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnN1cHBvcnRzVmVydGV4VGV4dHVyZXMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBjYXBhYmlsaXRpZXMudmVydGV4VGV4dHVyZXM7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnN1cHBvcnRzSW5zdGFuY2VkQXJyYXlzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNJbnN0YW5jZWRBcnJheXMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzXFwnICkuJyApO1xyXG4gICAgICAgIHJldHVybiBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvL1xyXG5cclxuICAgIHRoaXMuaW5pdE1hdGVyaWFsID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuaW5pdE1hdGVyaWFsKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmFkZFByZVBsdWdpbiA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLmFkZFByZVBsdWdpbigpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5hZGRQb3N0UGx1Z2luID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuYWRkUG9zdFBsdWdpbigpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy51cGRhdGVTaGFkb3dNYXAgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC51cGRhdGVTaGFkb3dNYXAoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLCB7XHJcbiAgICAgICAgc2hhZG93TWFwRW5hYmxlZDoge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hhZG93TWFwLmVuYWJsZWQ7XHJcblxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcEVuYWJsZWQgaXMgbm93IC5zaGFkb3dNYXAuZW5hYmxlZC4nICk7XHJcbiAgICAgICAgICAgICAgICBzaGFkb3dNYXAuZW5hYmxlZCA9IHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2hhZG93TWFwVHlwZToge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hhZG93TWFwLnR5cGU7XHJcblxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcFR5cGUgaXMgbm93IC5zaGFkb3dNYXAudHlwZS4nICk7XHJcbiAgICAgICAgICAgICAgICBzaGFkb3dNYXAudHlwZSA9IHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2hhZG93TWFwQ3VsbEZhY2U6IHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNoYWRvd01hcC5jdWxsRmFjZTtcclxuXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwQ3VsbEZhY2UgaXMgbm93IC5zaGFkb3dNYXAuY3VsbEZhY2UuJyApO1xyXG4gICAgICAgICAgICAgICAgc2hhZG93TWFwLmN1bGxGYWNlID0gdmFsdWU7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaGFkb3dNYXBEZWJ1Zzoge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hhZG93TWFwLmRlYnVnO1xyXG5cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXBEZWJ1ZyBpcyBub3cgLnNoYWRvd01hcC5kZWJ1Zy4nICk7XHJcbiAgICAgICAgICAgICAgICBzaGFkb3dNYXAuZGVidWcgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9ICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL1dlYkdMUmVuZGVyVGFyZ2V0LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBzemltZWsgLyBodHRwczovL2dpdGh1Yi5jb20vc3ppbWVrL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zICkge1xyXG5cclxuICAgIHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XHJcblxyXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgaWYgKCBvcHRpb25zLm1pbkZpbHRlciA9PT0gdW5kZWZpbmVkICkgb3B0aW9ucy5taW5GaWx0ZXIgPSBUSFJFRS5MaW5lYXJGaWx0ZXI7XHJcblxyXG4gICAgdGhpcy50ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvcHRpb25zLndyYXBTLCBvcHRpb25zLndyYXBULCBvcHRpb25zLm1hZ0ZpbHRlciwgb3B0aW9ucy5taW5GaWx0ZXIsIG9wdGlvbnMuZm9ybWF0LCBvcHRpb25zLnR5cGUsIG9wdGlvbnMuYW5pc290cm9weSApO1xyXG5cclxuICAgIHRoaXMuZGVwdGhCdWZmZXIgPSBvcHRpb25zLmRlcHRoQnVmZmVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlcHRoQnVmZmVyIDogdHJ1ZTtcclxuICAgIHRoaXMuc3RlbmNpbEJ1ZmZlciA9IG9wdGlvbnMuc3RlbmNpbEJ1ZmZlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdGVuY2lsQnVmZmVyIDogdHJ1ZTtcclxuXHJcbiAgICB0aGlzLnNoYXJlRGVwdGhGcm9tID0gb3B0aW9ucy5zaGFyZURlcHRoRnJvbSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zaGFyZURlcHRoRnJvbSA6IG51bGw7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldCxcclxuXHJcbiAgICBnZXQgd3JhcFMoKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFMgaXMgbm93IC50ZXh0dXJlLndyYXBTLicgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZS53cmFwUztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldCB3cmFwUyggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFMgaXMgbm93IC50ZXh0dXJlLndyYXBTLicgKTtcclxuXHJcbiAgICAgICAgdGhpcy50ZXh0dXJlLndyYXBTID0gdmFsdWU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXQgd3JhcFQoKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFQgaXMgbm93IC50ZXh0dXJlLndyYXBULicgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZS53cmFwVDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldCB3cmFwVCggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFQgaXMgbm93IC50ZXh0dXJlLndyYXBULicgKTtcclxuXHJcbiAgICAgICAgdGhpcy50ZXh0dXJlLndyYXBUID0gdmFsdWU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXQgbWFnRmlsdGVyKCkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm1hZ0ZpbHRlciBpcyBub3cgLnRleHR1cmUubWFnRmlsdGVyLicgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZS5tYWdGaWx0ZXI7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXQgbWFnRmlsdGVyKCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5tYWdGaWx0ZXIgaXMgbm93IC50ZXh0dXJlLm1hZ0ZpbHRlci4nICk7XHJcblxyXG4gICAgICAgIHRoaXMudGV4dHVyZS5tYWdGaWx0ZXIgPSB2YWx1ZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldCBtaW5GaWx0ZXIoKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAubWluRmlsdGVyIGlzIG5vdyAudGV4dHVyZS5taW5GaWx0ZXIuJyApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlLm1pbkZpbHRlcjtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldCBtaW5GaWx0ZXIoIHZhbHVlICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm1pbkZpbHRlciBpcyBub3cgLnRleHR1cmUubWluRmlsdGVyLicgKTtcclxuXHJcbiAgICAgICAgdGhpcy50ZXh0dXJlLm1pbkZpbHRlciA9IHZhbHVlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0IGFuaXNvdHJvcHkoKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuYW5pc290cm9weSBpcyBub3cgLnRleHR1cmUuYW5pc290cm9weS4nICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnRleHR1cmUuYW5pc290cm9weTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldCBhbmlzb3Ryb3B5KCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5hbmlzb3Ryb3B5IGlzIG5vdyAudGV4dHVyZS5hbmlzb3Ryb3B5LicgKTtcclxuXHJcbiAgICAgICAgdGhpcy50ZXh0dXJlLmFuaXNvdHJvcHkgPSB2YWx1ZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldCBvZmZzZXQoKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAub2Zmc2V0IGlzIG5vdyAudGV4dHVyZS5vZmZzZXQuJyApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlLm9mZnNldDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldCBvZmZzZXQoIHZhbHVlICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm9mZnNldCBpcyBub3cgLnRleHR1cmUub2Zmc2V0LicgKTtcclxuXHJcbiAgICAgICAgdGhpcy50ZXh0dXJlLm9mZnNldCA9IHZhbHVlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0IHJlcGVhdCgpIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5yZXBlYXQgaXMgbm93IC50ZXh0dXJlLnJlcGVhdC4nICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnRleHR1cmUucmVwZWF0O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0IHJlcGVhdCggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAucmVwZWF0IGlzIG5vdyAudGV4dHVyZS5yZXBlYXQuJyApO1xyXG5cclxuICAgICAgICB0aGlzLnRleHR1cmUucmVwZWF0ID0gdmFsdWU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXQgZm9ybWF0KCkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmZvcm1hdCBpcyBub3cgLnRleHR1cmUuZm9ybWF0LicgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZS5mb3JtYXQ7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXQgZm9ybWF0KCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5mb3JtYXQgaXMgbm93IC50ZXh0dXJlLmZvcm1hdC4nICk7XHJcblxyXG4gICAgICAgIHRoaXMudGV4dHVyZS5mb3JtYXQgPSB2YWx1ZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldCB0eXBlKCkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLnR5cGUgaXMgbm93IC50ZXh0dXJlLnR5cGUuJyApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlLnR5cGU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXQgdHlwZSggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAudHlwZSBpcyBub3cgLnRleHR1cmUudHlwZS4nICk7XHJcblxyXG4gICAgICAgIHRoaXMudGV4dHVyZS50eXBlID0gdmFsdWU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXQgZ2VuZXJhdGVNaXBtYXBzKCkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmdlbmVyYXRlTWlwbWFwcyBpcyBub3cgLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzLicgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXQgZ2VuZXJhdGVNaXBtYXBzKCB2YWx1ZSApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5nZW5lcmF0ZU1pcG1hcHMgaXMgbm93IC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcy4nICk7XHJcblxyXG4gICAgICAgIHRoaXMudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSB2YWx1ZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8vXHJcblxyXG4gICAgc2V0U2l6ZTogZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0ICkge1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMud2lkdGggIT09IHdpZHRoIHx8IHRoaXMuaGVpZ2h0ICE9PSBoZWlnaHQgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuICAgICAgICB0aGlzLndpZHRoID0gc291cmNlLndpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gc291cmNlLmhlaWdodDtcclxuXHJcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gc291cmNlLnRleHR1cmUuY2xvbmUoKTtcclxuXHJcbiAgICAgICAgdGhpcy5kZXB0aEJ1ZmZlciA9IHNvdXJjZS5kZXB0aEJ1ZmZlcjtcclxuICAgICAgICB0aGlzLnN0ZW5jaWxCdWZmZXIgPSBzb3VyY2Uuc3RlbmNpbEJ1ZmZlcjtcclxuXHJcbiAgICAgICAgdGhpcy5zaGFyZURlcHRoRnJvbSA9IHNvdXJjZS5zaGFyZURlcHRoRnJvbTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5XZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUgKTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9XZWJHTFJlbmRlclRhcmdldEN1YmUuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tXHJcbiAqL1xyXG5cclxuVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zICkge1xyXG5cclxuICAgIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LmNhbGwoIHRoaXMsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKTtcclxuXHJcbiAgICB0aGlzLmFjdGl2ZUN1YmVGYWNlID0gMDsgLy8gUFggMCwgTlggMSwgUFkgMiwgTlkgMywgUFogNCwgTlogNVxyXG5cclxufTtcclxuXHJcblRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5XZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUgKTtcclxuVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTEJ1ZmZlclJlbmRlcmVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5XZWJHTEJ1ZmZlclJlbmRlcmVyID0gZnVuY3Rpb24gKCBfZ2wsIGV4dGVuc2lvbnMsIF9pbmZvUmVuZGVyICkge1xyXG5cclxuICAgIHZhciBtb2RlO1xyXG5cclxuICAgIGZ1bmN0aW9uIHNldE1vZGUoIHZhbHVlICkge1xyXG5cclxuICAgICAgICBtb2RlID0gdmFsdWU7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlbmRlciggc3RhcnQsIGNvdW50ICkge1xyXG5cclxuICAgICAgICBfZ2wuZHJhd0FycmF5cyggbW9kZSwgc3RhcnQsIGNvdW50ICk7XHJcblxyXG4gICAgICAgIF9pbmZvUmVuZGVyLmNhbGxzICsrO1xyXG4gICAgICAgIF9pbmZvUmVuZGVyLnZlcnRpY2VzICs9IGNvdW50O1xyXG4gICAgICAgIGlmICggbW9kZSA9PT0gX2dsLlRSSUFOR0xFUyApIF9pbmZvUmVuZGVyLmZhY2VzICs9IGNvdW50IC8gMztcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVuZGVySW5zdGFuY2VzKCBnZW9tZXRyeSApIHtcclxuXHJcbiAgICAgICAgdmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcclxuXHJcbiAgICAgICAgaWYgKCBleHRlbnNpb24gPT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xCdWZmZXJSZW5kZXJlcjogdXNpbmcgVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgYnV0IGhhcmR3YXJlIGRvZXMgbm90IHN1cHBvcnQgZXh0ZW5zaW9uIEFOR0xFX2luc3RhbmNlZF9hcnJheXMuJyApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuXHJcbiAgICAgICAgaWYgKCBwb3NpdGlvbiBpbnN0YW5jZW9mIFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xyXG5cclxuICAgICAgICAgICAgZXh0ZW5zaW9uLmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRSggbW9kZSwgMCwgcG9zaXRpb24uZGF0YS5jb3VudCwgZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIGV4dGVuc2lvbi5kcmF3QXJyYXlzSW5zdGFuY2VkQU5HTEUoIG1vZGUsIDAsIHBvc2l0aW9uLmNvdW50LCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc2V0TW9kZSA9IHNldE1vZGU7XHJcbiAgICB0aGlzLnJlbmRlciA9IHJlbmRlcjtcclxuICAgIHRoaXMucmVuZGVySW5zdGFuY2VzID0gcmVuZGVySW5zdGFuY2VzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTEluZGV4ZWRCdWZmZXJSZW5kZXJlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuV2ViR0xJbmRleGVkQnVmZmVyUmVuZGVyZXIgPSBmdW5jdGlvbiAoIF9nbCwgZXh0ZW5zaW9ucywgX2luZm9SZW5kZXIgKSB7XHJcblxyXG4gICAgdmFyIG1vZGU7XHJcblxyXG4gICAgZnVuY3Rpb24gc2V0TW9kZSggdmFsdWUgKSB7XHJcblxyXG4gICAgICAgIG1vZGUgPSB2YWx1ZTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHR5cGUsIHNpemU7XHJcblxyXG4gICAgZnVuY3Rpb24gc2V0SW5kZXgoIGluZGV4ICkge1xyXG5cclxuICAgICAgICBpZiAoIGluZGV4LmFycmF5IGluc3RhbmNlb2YgVWludDMyQXJyYXkgJiYgZXh0ZW5zaW9ucy5nZXQoICdPRVNfZWxlbWVudF9pbmRleF91aW50JyApICkge1xyXG5cclxuICAgICAgICAgICAgdHlwZSA9IF9nbC5VTlNJR05FRF9JTlQ7XHJcbiAgICAgICAgICAgIHNpemUgPSA0O1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgdHlwZSA9IF9nbC5VTlNJR05FRF9TSE9SVDtcclxuICAgICAgICAgICAgc2l6ZSA9IDI7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVuZGVyKCBzdGFydCwgY291bnQgKSB7XHJcblxyXG4gICAgICAgIF9nbC5kcmF3RWxlbWVudHMoIG1vZGUsIGNvdW50LCB0eXBlLCBzdGFydCAqIHNpemUgKTtcclxuXHJcbiAgICAgICAgX2luZm9SZW5kZXIuY2FsbHMgKys7XHJcbiAgICAgICAgX2luZm9SZW5kZXIudmVydGljZXMgKz0gY291bnQ7XHJcbiAgICAgICAgaWYgKCBtb2RlID09PSBfZ2wuVFJJQU5HTEVTICkgX2luZm9SZW5kZXIuZmFjZXMgKz0gY291bnQgLyAzO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZW5kZXJJbnN0YW5jZXMoIGdlb21ldHJ5ICkge1xyXG5cclxuICAgICAgICB2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xyXG5cclxuICAgICAgICBpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTEJ1ZmZlclJlbmRlcmVyOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nICk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcclxuXHJcbiAgICAgICAgZXh0ZW5zaW9uLmRyYXdFbGVtZW50c0luc3RhbmNlZEFOR0xFKCBtb2RlLCBpbmRleC5hcnJheS5sZW5ndGgsIHR5cGUsIDAsIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc2V0TW9kZSA9IHNldE1vZGU7XHJcbiAgICB0aGlzLnNldEluZGV4ID0gc2V0SW5kZXg7XHJcbiAgICB0aGlzLnJlbmRlciA9IHJlbmRlcjtcclxuICAgIHRoaXMucmVuZGVySW5zdGFuY2VzID0gcmVuZGVySW5zdGFuY2VzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTEV4dGVuc2lvbnMuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLldlYkdMRXh0ZW5zaW9ucyA9IGZ1bmN0aW9uICggZ2wgKSB7XHJcblxyXG4gICAgdmFyIGV4dGVuc2lvbnMgPSB7fTtcclxuXHJcbiAgICB0aGlzLmdldCA9IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcbiAgICAgICAgaWYgKCBleHRlbnNpb25zWyBuYW1lIF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBleHRlbnNpb25zWyBuYW1lIF07XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGV4dGVuc2lvbjtcclxuXHJcbiAgICAgICAgc3dpdGNoICggbmFtZSApIHtcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYyc6XHJcbiAgICAgICAgICAgICAgICBleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnTU9aX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdXRUJLSVRfRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Yyc6XHJcbiAgICAgICAgICAgICAgICBleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdNT1pfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnOlxyXG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ1dFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oIG5hbWUgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6ICcgKyBuYW1lICsgJyBleHRlbnNpb24gbm90IHN1cHBvcnRlZC4nICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXh0ZW5zaW9uc1sgbmFtZSBdID0gZXh0ZW5zaW9uO1xyXG5cclxuICAgICAgICByZXR1cm4gZXh0ZW5zaW9uO1xyXG5cclxuICAgIH07XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMQ2FwYWJpbGl0aWVzLmpzXHJcblxyXG5USFJFRS5XZWJHTENhcGFiaWxpdGllcyA9IGZ1bmN0aW9uICggZ2wsIGV4dGVuc2lvbnMsIHBhcmFtZXRlcnMgKSB7XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0TWF4UHJlY2lzaW9uKCBwcmVjaXNpb24gKSB7XHJcblxyXG4gICAgICAgIGlmICggcHJlY2lzaW9uID09PSAnaGlnaHAnICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIGdsLlZFUlRFWF9TSEFERVIsIGdsLkhJR0hfRkxPQVQgKS5wcmVjaXNpb24gPiAwICYmXHJcbiAgICAgICAgICAgICAgICBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuSElHSF9GTE9BVCApLnByZWNpc2lvbiA+IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWdocCc7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwcmVjaXNpb24gPSAnbWVkaXVtcCc7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBwcmVjaXNpb24gPT09ICdtZWRpdW1wJyApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBnbC5WRVJURVhfU0hBREVSLCBnbC5NRURJVU1fRkxPQVQgKS5wcmVjaXNpb24gPiAwICYmXHJcbiAgICAgICAgICAgICAgICBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuTUVESVVNX0ZMT0FUICkucHJlY2lzaW9uID4gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ21lZGl1bXAnO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAnbG93cCc7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZ2V0TWF4UHJlY2lzaW9uID0gZ2V0TWF4UHJlY2lzaW9uO1xyXG5cclxuICAgIHRoaXMucHJlY2lzaW9uID0gcGFyYW1ldGVycy5wcmVjaXNpb24gIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucHJlY2lzaW9uIDogJ2hpZ2hwJyxcclxuICAgICAgICB0aGlzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPSBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA6IGZhbHNlO1xyXG5cclxuICAgIHRoaXMubWF4VGV4dHVyZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTICk7XHJcbiAgICB0aGlzLm1heFZlcnRleFRleHR1cmVzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcclxuICAgIHRoaXMubWF4VGV4dHVyZVNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9URVhUVVJFX1NJWkUgKTtcclxuICAgIHRoaXMubWF4Q3ViZW1hcFNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9DVUJFX01BUF9URVhUVVJFX1NJWkUgKTtcclxuXHJcbiAgICB0aGlzLm1heEF0dHJpYnV0ZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9WRVJURVhfQVRUUklCUyApO1xyXG4gICAgdGhpcy5tYXhWZXJ0ZXhVbmlmb3JtcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9VTklGT1JNX1ZFQ1RPUlMgKTtcclxuICAgIHRoaXMubWF4VmFyeWluZ3MgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9WQVJZSU5HX1ZFQ1RPUlMgKTtcclxuICAgIHRoaXMubWF4RnJhZ21lbnRVbmlmb3JtcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX0ZSQUdNRU5UX1VOSUZPUk1fVkVDVE9SUyApO1xyXG5cclxuICAgIHRoaXMudmVydGV4VGV4dHVyZXMgPSB0aGlzLm1heFZlcnRleFRleHR1cmVzID4gMDtcclxuICAgIHRoaXMuZmxvYXRGcmFnbWVudFRleHR1cmVzID0gISEgZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdCcgKTtcclxuICAgIHRoaXMuZmxvYXRWZXJ0ZXhUZXh0dXJlcyA9IHRoaXMudmVydGV4VGV4dHVyZXMgJiYgdGhpcy5mbG9hdEZyYWdtZW50VGV4dHVyZXM7XHJcblxyXG4gICAgdmFyIF9tYXhQcmVjaXNpb24gPSBnZXRNYXhQcmVjaXNpb24oIHRoaXMucHJlY2lzaW9uICk7XHJcblxyXG4gICAgaWYgKCBfbWF4UHJlY2lzaW9uICE9PSB0aGlzLnByZWNpc2lvbiApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjonLCB0aGlzLnByZWNpc2lvbiwgJ25vdCBzdXBwb3J0ZWQsIHVzaW5nJywgX21heFByZWNpc2lvbiwgJ2luc3RlYWQuJyApO1xyXG4gICAgICAgIHRoaXMucHJlY2lzaW9uID0gX21heFByZWNpc2lvbjtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCB0aGlzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgKSB7XHJcblxyXG4gICAgICAgIHRoaXMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA9ICEhIGV4dGVuc2lvbnMuZ2V0KCAnRVhUX2ZyYWdfZGVwdGgnICk7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTEdlb21ldHJpZXMuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLldlYkdMR2VvbWV0cmllcyA9IGZ1bmN0aW9uICggZ2wsIHByb3BlcnRpZXMsIGluZm8gKSB7XHJcblxyXG4gICAgdmFyIGdlb21ldHJpZXMgPSB7fTtcclxuXHJcbiAgICBmdW5jdGlvbiBnZXQoIG9iamVjdCApIHtcclxuXHJcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuICAgICAgICBpZiAoIGdlb21ldHJpZXNbIGdlb21ldHJ5LmlkIF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdlb21ldHJ5LmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25HZW9tZXRyeURpc3Bvc2UgKTtcclxuXHJcbiAgICAgICAgdmFyIGJ1ZmZlcmdlb21ldHJ5O1xyXG5cclxuICAgICAgICBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XHJcblxyXG4gICAgICAgICAgICBidWZmZXJnZW9tZXRyeSA9IGdlb21ldHJ5O1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBnZW9tZXRyeS5fYnVmZmVyR2VvbWV0cnkgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS5fYnVmZmVyR2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKS5zZXRGcm9tT2JqZWN0KCBvYmplY3QgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJ1ZmZlcmdlb21ldHJ5ID0gZ2VvbWV0cnkuX2J1ZmZlckdlb21ldHJ5O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdlb21ldHJpZXNbIGdlb21ldHJ5LmlkIF0gPSBidWZmZXJnZW9tZXRyeTtcclxuXHJcbiAgICAgICAgaW5mby5tZW1vcnkuZ2VvbWV0cmllcyArKztcclxuXHJcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcmdlb21ldHJ5O1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBvbkdlb21ldHJ5RGlzcG9zZSggZXZlbnQgKSB7XHJcblxyXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IGV2ZW50LnRhcmdldDtcclxuICAgICAgICB2YXIgYnVmZmVyZ2VvbWV0cnkgPSBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdO1xyXG5cclxuICAgICAgICBkZWxldGVBdHRyaWJ1dGVzKCBidWZmZXJnZW9tZXRyeS5hdHRyaWJ1dGVzICk7XHJcblxyXG4gICAgICAgIGdlb21ldHJ5LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25HZW9tZXRyeURpc3Bvc2UgKTtcclxuXHJcbiAgICAgICAgZGVsZXRlIGdlb21ldHJpZXNbIGdlb21ldHJ5LmlkIF07XHJcblxyXG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IHByb3BlcnRpZXMuZ2V0KCBnZW9tZXRyeSApO1xyXG4gICAgICAgIGlmICggcHJvcGVydHkud2lyZWZyYW1lICkgZGVsZXRlQXR0cmlidXRlKCBwcm9wZXJ0eS53aXJlZnJhbWUgKTtcclxuXHJcbiAgICAgICAgaW5mby5tZW1vcnkuZ2VvbWV0cmllcyAtLTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0QXR0cmlidXRlQnVmZmVyKCBhdHRyaWJ1dGUgKSB7XHJcblxyXG4gICAgICAgIGlmICggYXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcHJvcGVydGllcy5nZXQoIGF0dHJpYnV0ZS5kYXRhICkuX193ZWJnbEJ1ZmZlcjtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcHJvcGVydGllcy5nZXQoIGF0dHJpYnV0ZSApLl9fd2ViZ2xCdWZmZXI7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRlbGV0ZUF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xyXG5cclxuICAgICAgICB2YXIgYnVmZmVyID0gZ2V0QXR0cmlidXRlQnVmZmVyKCBhdHRyaWJ1dGUgKTtcclxuXHJcbiAgICAgICAgaWYgKCBidWZmZXIgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIGdsLmRlbGV0ZUJ1ZmZlciggYnVmZmVyICk7XHJcbiAgICAgICAgICAgIHJlbW92ZUF0dHJpYnV0ZUJ1ZmZlciggYXR0cmlidXRlICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGVsZXRlQXR0cmlidXRlcyggYXR0cmlidXRlcyApIHtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIG5hbWUgaW4gYXR0cmlidXRlcyApIHtcclxuXHJcbiAgICAgICAgICAgIGRlbGV0ZUF0dHJpYnV0ZSggYXR0cmlidXRlc1sgbmFtZSBdICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVtb3ZlQXR0cmlidXRlQnVmZmVyKCBhdHRyaWJ1dGUgKSB7XHJcblxyXG4gICAgICAgIGlmICggYXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XHJcblxyXG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmRlbGV0ZSggYXR0cmlidXRlLmRhdGEgKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIHByb3BlcnRpZXMuZGVsZXRlKCBhdHRyaWJ1dGUgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmdldCA9IGdldDtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xPYmplY3RzLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5XZWJHTE9iamVjdHMgPSBmdW5jdGlvbiAoIGdsLCBwcm9wZXJ0aWVzLCBpbmZvICkge1xyXG5cclxuICAgIHZhciBnZW9tZXRyaWVzID0gbmV3IFRIUkVFLldlYkdMR2VvbWV0cmllcyggZ2wsIHByb3BlcnRpZXMsIGluZm8gKTtcclxuXHJcbiAgICAvL1xyXG5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZSggb2JqZWN0ICkge1xyXG5cclxuICAgICAgICAvLyBUT0RPOiBBdm9pZCB1cGRhdGluZyB0d2ljZSAod2hlbiB1c2luZyBzaGFkb3dNYXApLiBNYXliZSBhZGQgZnJhbWUgY291bnRlci5cclxuXHJcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gZ2VvbWV0cmllcy5nZXQoIG9iamVjdCApO1xyXG5cclxuICAgICAgICBpZiAoIG9iamVjdC5nZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xyXG5cclxuICAgICAgICAgICAgZ2VvbWV0cnkudXBkYXRlRnJvbU9iamVjdCggb2JqZWN0ICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XHJcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xyXG5cclxuICAgICAgICBpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgdXBkYXRlQXR0cmlidXRlKCBpbmRleCwgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKCB2YXIgbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xyXG5cclxuICAgICAgICAgICAgdXBkYXRlQXR0cmlidXRlKCBhdHRyaWJ1dGVzWyBuYW1lIF0sIGdsLkFSUkFZX0JVRkZFUiApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIG1vcnBoIHRhcmdldHNcclxuXHJcbiAgICAgICAgdmFyIG1vcnBoQXR0cmlidXRlcyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcztcclxuXHJcbiAgICAgICAgZm9yICggdmFyIG5hbWUgaW4gbW9ycGhBdHRyaWJ1dGVzICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGFycmF5ID0gbW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF07XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHVwZGF0ZUF0dHJpYnV0ZSggYXJyYXlbIGkgXSwgZ2wuQVJSQVlfQlVGRkVSICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGdlb21ldHJ5O1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgYnVmZmVyVHlwZSApIHtcclxuXHJcbiAgICAgICAgdmFyIGRhdGEgPSAoIGF0dHJpYnV0ZSBpbnN0YW5jZW9mIFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkgPyBhdHRyaWJ1dGUuZGF0YSA6IGF0dHJpYnV0ZTtcclxuXHJcbiAgICAgICAgdmFyIGF0dHJpYnV0ZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggZGF0YSApO1xyXG5cclxuICAgICAgICBpZiAoIGF0dHJpYnV0ZVByb3BlcnRpZXMuX193ZWJnbEJ1ZmZlciA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgY3JlYXRlQnVmZmVyKCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLCBkYXRhLCBidWZmZXJUeXBlICk7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIGF0dHJpYnV0ZVByb3BlcnRpZXMudmVyc2lvbiAhPT0gZGF0YS52ZXJzaW9uICkge1xyXG5cclxuICAgICAgICAgICAgdXBkYXRlQnVmZmVyKCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLCBkYXRhLCBidWZmZXJUeXBlICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlQnVmZmVyKCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLCBkYXRhLCBidWZmZXJUeXBlICkge1xyXG5cclxuICAgICAgICBhdHRyaWJ1dGVQcm9wZXJ0aWVzLl9fd2ViZ2xCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKCBidWZmZXJUeXBlLCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLl9fd2ViZ2xCdWZmZXIgKTtcclxuXHJcbiAgICAgICAgdmFyIHVzYWdlID0gZGF0YS5keW5hbWljID8gZ2wuRFlOQU1JQ19EUkFXIDogZ2wuU1RBVElDX0RSQVc7XHJcblxyXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoIGJ1ZmZlclR5cGUsIGRhdGEuYXJyYXksIHVzYWdlICk7XHJcblxyXG4gICAgICAgIGF0dHJpYnV0ZVByb3BlcnRpZXMudmVyc2lvbiA9IGRhdGEudmVyc2lvbjtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdXBkYXRlQnVmZmVyKCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLCBkYXRhLCBidWZmZXJUeXBlICkge1xyXG5cclxuICAgICAgICBnbC5iaW5kQnVmZmVyKCBidWZmZXJUeXBlLCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLl9fd2ViZ2xCdWZmZXIgKTtcclxuXHJcbiAgICAgICAgaWYgKCBkYXRhLmR5bmFtaWMgPT09IGZhbHNlIHx8IGRhdGEudXBkYXRlUmFuZ2UuY291bnQgPT09IC0gMSApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIE5vdCB1c2luZyB1cGRhdGUgcmFuZ2VzXHJcblxyXG4gICAgICAgICAgICBnbC5idWZmZXJTdWJEYXRhKCBidWZmZXJUeXBlLCAwLCBkYXRhLmFycmF5ICk7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIGRhdGEudXBkYXRlUmFuZ2UuY291bnQgPT09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xPYmplY3RzLnVwZGF0ZUJ1ZmZlcjogZHluYW1pYyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUgbWFya2VkIGFzIG5lZWRzVXBkYXRlIGJ1dCB1cGRhdGVSYW5nZS5jb3VudCBpcyAwLCBlbnN1cmUgeW91IGFyZSB1c2luZyBzZXQgbWV0aG9kcyBvciB1cGRhdGluZyBtYW51YWxseS4nICk7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICBnbC5idWZmZXJTdWJEYXRhKCBidWZmZXJUeXBlLCBkYXRhLnVwZGF0ZVJhbmdlLm9mZnNldCAqIGRhdGEuYXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXHJcbiAgICAgICAgICAgICAgICBkYXRhLmFycmF5LnN1YmFycmF5KCBkYXRhLnVwZGF0ZVJhbmdlLm9mZnNldCwgZGF0YS51cGRhdGVSYW5nZS5vZmZzZXQgKyBkYXRhLnVwZGF0ZVJhbmdlLmNvdW50ICkgKTtcclxuXHJcbiAgICAgICAgICAgIGRhdGEudXBkYXRlUmFuZ2UuY291bnQgPSAwOyAvLyByZXNldCByYW5nZVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGF0dHJpYnV0ZVByb3BlcnRpZXMudmVyc2lvbiA9IGRhdGEudmVyc2lvbjtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0QXR0cmlidXRlQnVmZmVyKCBhdHRyaWJ1dGUgKSB7XHJcblxyXG4gICAgICAgIGlmICggYXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcHJvcGVydGllcy5nZXQoIGF0dHJpYnV0ZS5kYXRhICkuX193ZWJnbEJ1ZmZlcjtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcHJvcGVydGllcy5nZXQoIGF0dHJpYnV0ZSApLl9fd2ViZ2xCdWZmZXI7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFdpcmVmcmFtZUF0dHJpYnV0ZSggZ2VvbWV0cnkgKSB7XHJcblxyXG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IHByb3BlcnRpZXMuZ2V0KCBnZW9tZXRyeSApO1xyXG5cclxuICAgICAgICBpZiAoIHByb3BlcnR5LndpcmVmcmFtZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5LndpcmVmcmFtZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaW5kaWNlcyA9IFtdO1xyXG5cclxuICAgICAgICB2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcclxuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuXHJcbiAgICAgICAgLy8gY29uc29sZS50aW1lKCAnd2lyZWZyYW1lJyApO1xyXG5cclxuICAgICAgICBpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGVkZ2VzID0ge307XHJcbiAgICAgICAgICAgIHZhciBhcnJheSA9IGluZGV4LmFycmF5O1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArPSAzICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBhID0gYXJyYXlbIGkgKyAwIF07XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IGFycmF5WyBpICsgMSBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBhcnJheVsgaSArIDIgXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGNoZWNrRWRnZSggZWRnZXMsIGEsIGIgKSApIGluZGljZXMucHVzaCggYSwgYiApO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBjaGVja0VkZ2UoIGVkZ2VzLCBiLCBjICkgKSBpbmRpY2VzLnB1c2goIGIsIGMgKTtcclxuICAgICAgICAgICAgICAgIGlmICggY2hlY2tFZGdlKCBlZGdlcywgYywgYSApICkgaW5kaWNlcy5wdXNoKCBjLCBhICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gKCBhcnJheS5sZW5ndGggLyAzICkgLSAxOyBpIDwgbDsgaSArPSAzICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBhID0gaSArIDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IGkgKyAxO1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBpICsgMjtcclxuXHJcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goIGEsIGIsIGIsIGMsIGMsIGEgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjb25zb2xlLnRpbWVFbmQoICd3aXJlZnJhbWUnICk7XHJcblxyXG4gICAgICAgIHZhciBUeXBlQXJyYXkgPSBwb3NpdGlvbi5jb3VudCA+IDY1NTM1ID8gVWludDMyQXJyYXkgOiBVaW50MTZBcnJheTtcclxuICAgICAgICB2YXIgYXR0cmlidXRlID0gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IFR5cGVBcnJheSggaW5kaWNlcyApLCAxICk7XHJcblxyXG4gICAgICAgIHVwZGF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlLCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiApO1xyXG5cclxuICAgICAgICBwcm9wZXJ0eS53aXJlZnJhbWUgPSBhdHRyaWJ1dGU7XHJcblxyXG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGU7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNoZWNrRWRnZSggZWRnZXMsIGEsIGIgKSB7XHJcblxyXG4gICAgICAgIGlmICggYSA+IGIgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgdG1wID0gYTtcclxuICAgICAgICAgICAgYSA9IGI7XHJcbiAgICAgICAgICAgIGIgPSB0bXA7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGxpc3QgPSBlZGdlc1sgYSBdO1xyXG5cclxuICAgICAgICBpZiAoIGxpc3QgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIGVkZ2VzWyBhIF0gPSBbIGIgXTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIGxpc3QuaW5kZXhPZiggYiApID09PSAtMSApIHtcclxuXHJcbiAgICAgICAgICAgIGxpc3QucHVzaCggYiApO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZ2V0QXR0cmlidXRlQnVmZmVyID0gZ2V0QXR0cmlidXRlQnVmZmVyO1xyXG4gICAgdGhpcy5nZXRXaXJlZnJhbWVBdHRyaWJ1dGUgPSBnZXRXaXJlZnJhbWVBdHRyaWJ1dGU7XHJcblxyXG4gICAgdGhpcy51cGRhdGUgPSB1cGRhdGU7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMUHJvZ3JhbS5qc1xyXG5cclxuVEhSRUUuV2ViR0xQcm9ncmFtID0gKCBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIHByb2dyYW1JZENvdW50ID0gMDtcclxuXHJcbiAgICBmdW5jdGlvbiBnZW5lcmF0ZURlZmluZXMoIGRlZmluZXMgKSB7XHJcblxyXG4gICAgICAgIHZhciBjaHVua3MgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIG5hbWUgaW4gZGVmaW5lcyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRlZmluZXNbIG5hbWUgXTtcclxuXHJcbiAgICAgICAgICAgIGlmICggdmFsdWUgPT09IGZhbHNlICkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICBjaHVua3MucHVzaCggJyNkZWZpbmUgJyArIG5hbWUgKyAnICcgKyB2YWx1ZSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjaHVua3Muam9pbiggJ1xcbicgKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZmV0Y2hVbmlmb3JtTG9jYXRpb25zKCBnbCwgcHJvZ3JhbSwgaWRlbnRpZmllcnMgKSB7XHJcblxyXG4gICAgICAgIHZhciB1bmlmb3JtcyA9IHt9O1xyXG5cclxuICAgICAgICB2YXIgbiA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLkFDVElWRV9VTklGT1JNUyApO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBuOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGluZm8gPSBnbC5nZXRBY3RpdmVVbmlmb3JtKCBwcm9ncmFtLCBpICk7XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gaW5mby5uYW1lO1xyXG4gICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIG5hbWUgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiVEhSRUUuV2ViR0xQcm9ncmFtOiBBQ1RJVkUgVU5JRk9STTpcIiwgbmFtZSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgc3VmZml4UG9zID0gbmFtZS5sYXN0SW5kZXhPZiggJ1swXScgKTtcclxuICAgICAgICAgICAgaWYgKCBzdWZmaXhQb3MgIT09IC0gMSAmJiBzdWZmaXhQb3MgPT09IG5hbWUubGVuZ3RoIC0gMyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB1bmlmb3Jtc1sgbmFtZS5zdWJzdHIoIDAsIHN1ZmZpeFBvcyApIF0gPSBsb2NhdGlvbjtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHVuaWZvcm1zWyBuYW1lIF0gPSBsb2NhdGlvbjtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdW5pZm9ybXM7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGZldGNoQXR0cmlidXRlTG9jYXRpb25zKCBnbCwgcHJvZ3JhbSwgaWRlbnRpZmllcnMgKSB7XHJcblxyXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0ge307XHJcblxyXG4gICAgICAgIHZhciBuID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuQUNUSVZFX0FUVFJJQlVURVMgKTtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbjsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBpbmZvID0gZ2wuZ2V0QWN0aXZlQXR0cmliKCBwcm9ncmFtLCBpICk7XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gaW5mby5uYW1lO1xyXG5cclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJUSFJFRS5XZWJHTFByb2dyYW06IEFDVElWRSBWRVJURVggQVRUUklCVVRFOlwiLCBuYW1lLCBpICk7XHJcblxyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzWyBuYW1lIF0gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgbmFtZSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBmaWx0ZXJFbXB0eUxpbmUoIHN0cmluZyApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHN0cmluZyAhPT0gJyc7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiBXZWJHTFByb2dyYW0oIHJlbmRlcmVyLCBjb2RlLCBtYXRlcmlhbCwgcGFyYW1ldGVycyApIHtcclxuXHJcbiAgICAgICAgdmFyIGdsID0gcmVuZGVyZXIuY29udGV4dDtcclxuXHJcbiAgICAgICAgdmFyIGRlZmluZXMgPSBtYXRlcmlhbC5kZWZpbmVzO1xyXG5cclxuICAgICAgICB2YXIgdmVydGV4U2hhZGVyID0gbWF0ZXJpYWwuX193ZWJnbFNoYWRlci52ZXJ0ZXhTaGFkZXI7XHJcbiAgICAgICAgdmFyIGZyYWdtZW50U2hhZGVyID0gbWF0ZXJpYWwuX193ZWJnbFNoYWRlci5mcmFnbWVudFNoYWRlcjtcclxuXHJcbiAgICAgICAgdmFyIHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfQkFTSUMnO1xyXG5cclxuICAgICAgICBpZiAoIHBhcmFtZXRlcnMuc2hhZG93TWFwVHlwZSA9PT0gVEhSRUUuUENGU2hhZG93TWFwICkge1xyXG5cclxuICAgICAgICAgICAgc2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9QQ0YnO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCBwYXJhbWV0ZXJzLnNoYWRvd01hcFR5cGUgPT09IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXAgKSB7XHJcblxyXG4gICAgICAgICAgICBzaGFkb3dNYXBUeXBlRGVmaW5lID0gJ1NIQURPV01BUF9UWVBFX1BDRl9TT0ZUJztcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9DVUJFJztcclxuICAgICAgICB2YXIgZW52TWFwTW9kZURlZmluZSA9ICdFTlZNQVBfTU9ERV9SRUZMRUNUSU9OJztcclxuICAgICAgICB2YXIgZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX01VTFRJUExZJztcclxuXHJcbiAgICAgICAgaWYgKCBwYXJhbWV0ZXJzLmVudk1hcCApIHtcclxuXHJcbiAgICAgICAgICAgIHN3aXRjaCAoIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuQ3ViZVJlZmxlY3Rpb25NYXBwaW5nOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5DdWJlUmVmcmFjdGlvbk1hcHBpbmc6XHJcbiAgICAgICAgICAgICAgICAgICAgZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9DVUJFJztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLkVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5FcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZzpcclxuICAgICAgICAgICAgICAgICAgICBlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0VRVUlSRUMnO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuU3BoZXJpY2FsUmVmbGVjdGlvbk1hcHBpbmc6XHJcbiAgICAgICAgICAgICAgICAgICAgZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9TUEhFUkUnO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc3dpdGNoICggbWF0ZXJpYWwuZW52TWFwLm1hcHBpbmcgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5DdWJlUmVmcmFjdGlvbk1hcHBpbmc6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLkVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nOlxyXG4gICAgICAgICAgICAgICAgICAgIGVudk1hcE1vZGVEZWZpbmUgPSAnRU5WTUFQX01PREVfUkVGUkFDVElPTic7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKCBtYXRlcmlhbC5jb21iaW5lICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuTXVsdGlwbHlPcGVyYXRpb246XHJcbiAgICAgICAgICAgICAgICAgICAgZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX01VTFRJUExZJztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLk1peE9wZXJhdGlvbjpcclxuICAgICAgICAgICAgICAgICAgICBlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfTUlYJztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLkFkZE9wZXJhdGlvbjpcclxuICAgICAgICAgICAgICAgICAgICBlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfQUREJztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZ2FtbWFGYWN0b3JEZWZpbmUgPSAoIHJlbmRlcmVyLmdhbW1hRmFjdG9yID4gMCApID8gcmVuZGVyZXIuZ2FtbWFGYWN0b3IgOiAxLjA7XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCAnYnVpbGRpbmcgbmV3IHByb2dyYW0gJyApO1xyXG5cclxuICAgICAgICAvL1xyXG5cclxuICAgICAgICB2YXIgY3VzdG9tRGVmaW5lcyA9IGdlbmVyYXRlRGVmaW5lcyggZGVmaW5lcyApO1xyXG5cclxuICAgICAgICAvL1xyXG5cclxuICAgICAgICB2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcclxuXHJcbiAgICAgICAgdmFyIHByZWZpeFZlcnRleCwgcHJlZml4RnJhZ21lbnQ7XHJcblxyXG4gICAgICAgIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5SYXdTaGFkZXJNYXRlcmlhbCApIHtcclxuXHJcbiAgICAgICAgICAgIHByZWZpeFZlcnRleCA9ICcnO1xyXG4gICAgICAgICAgICBwcmVmaXhGcmFnbWVudCA9ICcnO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgcHJlZml4VmVydGV4ID0gW1xyXG5cclxuICAgICAgICAgICAgICAgICdwcmVjaXNpb24gJyArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgJyBmbG9hdDsnLFxyXG4gICAgICAgICAgICAgICAgJ3ByZWNpc2lvbiAnICsgcGFyYW1ldGVycy5wcmVjaXNpb24gKyAnIGludDsnLFxyXG5cclxuICAgICAgICAgICAgICAgICcjZGVmaW5lIFNIQURFUl9OQU1FICcgKyBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLm5hbWUsXHJcblxyXG4gICAgICAgICAgICAgICAgY3VzdG9tRGVmaW5lcyxcclxuXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLnN1cHBvcnRzVmVydGV4VGV4dHVyZXMgPyAnI2RlZmluZSBWRVJURVhfVEVYVFVSRVMnIDogJycsXHJcblxyXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuZ2FtbWFJbnB1dCA/ICcjZGVmaW5lIEdBTU1BX0lOUFVUJyA6ICcnLFxyXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuZ2FtbWFPdXRwdXQgPyAnI2RlZmluZSBHQU1NQV9PVVRQVVQnIDogJycsXHJcbiAgICAgICAgICAgICAgICAnI2RlZmluZSBHQU1NQV9GQUNUT1IgJyArIGdhbW1hRmFjdG9yRGVmaW5lLFxyXG5cclxuICAgICAgICAgICAgICAgICcjZGVmaW5lIE1BWF9ESVJfTElHSFRTICcgKyBwYXJhbWV0ZXJzLm1heERpckxpZ2h0cyxcclxuICAgICAgICAgICAgICAgICcjZGVmaW5lIE1BWF9QT0lOVF9MSUdIVFMgJyArIHBhcmFtZXRlcnMubWF4UG9pbnRMaWdodHMsXHJcbiAgICAgICAgICAgICAgICAnI2RlZmluZSBNQVhfU1BPVF9MSUdIVFMgJyArIHBhcmFtZXRlcnMubWF4U3BvdExpZ2h0cyxcclxuICAgICAgICAgICAgICAgICcjZGVmaW5lIE1BWF9IRU1JX0xJR0hUUyAnICsgcGFyYW1ldGVycy5tYXhIZW1pTGlnaHRzLFxyXG5cclxuICAgICAgICAgICAgICAgICcjZGVmaW5lIE1BWF9TSEFET1dTICcgKyBwYXJhbWV0ZXJzLm1heFNoYWRvd3MsXHJcblxyXG4gICAgICAgICAgICAgICAgJyNkZWZpbmUgTUFYX0JPTkVTICcgKyBwYXJhbWV0ZXJzLm1heEJvbmVzLFxyXG5cclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMubWFwID8gJyNkZWZpbmUgVVNFX01BUCcgOiAnJyxcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgVVNFX0VOVk1BUCcgOiAnJyxcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcE1vZGVEZWZpbmUgOiAnJyxcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMubGlnaHRNYXAgPyAnI2RlZmluZSBVU0VfTElHSFRNQVAnIDogJycsXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmFvTWFwID8gJyNkZWZpbmUgVVNFX0FPTUFQJyA6ICcnLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5lbWlzc2l2ZU1hcCA/ICcjZGVmaW5lIFVTRV9FTUlTU0lWRU1BUCcgOiAnJyxcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuYnVtcE1hcCA/ICcjZGVmaW5lIFVTRV9CVU1QTUFQJyA6ICcnLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5ub3JtYWxNYXAgPyAnI2RlZmluZSBVU0VfTk9STUFMTUFQJyA6ICcnLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5kaXNwbGFjZW1lbnRNYXAgJiYgcGFyYW1ldGVycy5zdXBwb3J0c1ZlcnRleFRleHR1cmVzID8gJyNkZWZpbmUgVVNFX0RJU1BMQUNFTUVOVE1BUCcgOiAnJyxcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuc3BlY3VsYXJNYXAgPyAnI2RlZmluZSBVU0VfU1BFQ1VMQVJNQVAnIDogJycsXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmFscGhhTWFwID8gJyNkZWZpbmUgVVNFX0FMUEhBTUFQJyA6ICcnLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy52ZXJ0ZXhDb2xvcnMgPyAnI2RlZmluZSBVU0VfQ09MT1InIDogJycsXHJcblxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5mbGF0U2hhZGluZyA/ICcjZGVmaW5lIEZMQVRfU0hBREVEJyA6ICcnLFxyXG5cclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuc2tpbm5pbmcgPyAnI2RlZmluZSBVU0VfU0tJTk5JTkcnIDogJycsXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLnVzZVZlcnRleFRleHR1cmUgPyAnI2RlZmluZSBCT05FX1RFWFRVUkUnIDogJycsXHJcblxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5tb3JwaFRhcmdldHMgPyAnI2RlZmluZSBVU0VfTU9SUEhUQVJHRVRTJyA6ICcnLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5tb3JwaE5vcm1hbHMgJiYgcGFyYW1ldGVycy5mbGF0U2hhZGluZyA9PT0gZmFsc2UgPyAnI2RlZmluZSBVU0VfTU9SUEhOT1JNQUxTJyA6ICcnLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5kb3VibGVTaWRlZCA/ICcjZGVmaW5lIERPVUJMRV9TSURFRCcgOiAnJyxcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuZmxpcFNpZGVkID8gJyNkZWZpbmUgRkxJUF9TSURFRCcgOiAnJyxcclxuXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSBVU0VfU0hBRE9XTUFQJyA6ICcnLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkID8gJyNkZWZpbmUgJyArIHNoYWRvd01hcFR5cGVEZWZpbmUgOiAnJyxcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuc2hhZG93TWFwRGVidWcgPyAnI2RlZmluZSBTSEFET1dNQVBfREVCVUcnIDogJycsXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLnBvaW50TGlnaHRTaGFkb3dzID4gMCA/ICcjZGVmaW5lIFBPSU5UX0xJR0hUX1NIQURPV1MnIDogJycsXHJcblxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5zaXplQXR0ZW51YXRpb24gPyAnI2RlZmluZSBVU0VfU0laRUFUVEVOVUFUSU9OJyA6ICcnLFxyXG5cclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA/ICcjZGVmaW5lIFVTRV9MT0dERVBUSEJVRicgOiAnJyxcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAmJiByZW5kZXJlci5leHRlbnNpb25zLmdldCggJ0VYVF9mcmFnX2RlcHRoJyApID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGX0VYVCcgOiAnJyxcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgJ3VuaWZvcm0gbWF0NCBtb2RlbE1hdHJpeDsnLFxyXG4gICAgICAgICAgICAgICAgJ3VuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7JyxcclxuICAgICAgICAgICAgICAgICd1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDsnLFxyXG4gICAgICAgICAgICAgICAgJ3VuaWZvcm0gbWF0NCB2aWV3TWF0cml4OycsXHJcbiAgICAgICAgICAgICAgICAndW5pZm9ybSBtYXQzIG5vcm1hbE1hdHJpeDsnLFxyXG4gICAgICAgICAgICAgICAgJ3VuaWZvcm0gdmVjMyBjYW1lcmFQb3NpdGlvbjsnLFxyXG5cclxuICAgICAgICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjsnLFxyXG4gICAgICAgICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMzIG5vcm1hbDsnLFxyXG4gICAgICAgICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIHV2OycsXHJcblxyXG4gICAgICAgICAgICAgICAgJyNpZmRlZiBVU0VfQ09MT1InLFxyXG5cclxuICAgICAgICAgICAgICAgICdcdGF0dHJpYnV0ZSB2ZWMzIGNvbG9yOycsXHJcblxyXG4gICAgICAgICAgICAgICAgJyNlbmRpZicsXHJcblxyXG4gICAgICAgICAgICAgICAgJyNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTJyxcclxuXHJcbiAgICAgICAgICAgICAgICAnXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDA7JyxcclxuICAgICAgICAgICAgICAgICdcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MTsnLFxyXG4gICAgICAgICAgICAgICAgJ1x0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQyOycsXHJcbiAgICAgICAgICAgICAgICAnXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDM7JyxcclxuXHJcbiAgICAgICAgICAgICAgICAnXHQjaWZkZWYgVVNFX01PUlBITk9STUFMUycsXHJcblxyXG4gICAgICAgICAgICAgICAgJ1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDA7JyxcclxuICAgICAgICAgICAgICAgICdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwxOycsXHJcbiAgICAgICAgICAgICAgICAnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMjsnLFxyXG4gICAgICAgICAgICAgICAgJ1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDM7JyxcclxuXHJcbiAgICAgICAgICAgICAgICAnXHQjZWxzZScsXHJcblxyXG4gICAgICAgICAgICAgICAgJ1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDQ7JyxcclxuICAgICAgICAgICAgICAgICdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ1OycsXHJcbiAgICAgICAgICAgICAgICAnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NjsnLFxyXG4gICAgICAgICAgICAgICAgJ1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDc7JyxcclxuXHJcbiAgICAgICAgICAgICAgICAnXHQjZW5kaWYnLFxyXG5cclxuICAgICAgICAgICAgICAgICcjZW5kaWYnLFxyXG5cclxuICAgICAgICAgICAgICAgICcjaWZkZWYgVVNFX1NLSU5OSU5HJyxcclxuXHJcbiAgICAgICAgICAgICAgICAnXHRhdHRyaWJ1dGUgdmVjNCBza2luSW5kZXg7JyxcclxuICAgICAgICAgICAgICAgICdcdGF0dHJpYnV0ZSB2ZWM0IHNraW5XZWlnaHQ7JyxcclxuXHJcbiAgICAgICAgICAgICAgICAnI2VuZGlmJyxcclxuXHJcbiAgICAgICAgICAgICAgICAnXFxuJ1xyXG5cclxuICAgICAgICAgICAgXS5maWx0ZXIoIGZpbHRlckVtcHR5TGluZSApLmpvaW4oICdcXG4nICk7XHJcblxyXG4gICAgICAgICAgICBwcmVmaXhGcmFnbWVudCA9IFtcclxuXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmJ1bXBNYXAgfHwgcGFyYW1ldGVycy5ub3JtYWxNYXAgfHwgcGFyYW1ldGVycy5mbGF0U2hhZGluZyB8fCBtYXRlcmlhbC5kZXJpdmF0aXZlcyA/ICcjZXh0ZW5zaW9uIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyA6IGVuYWJsZScgOiAnJyxcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAmJiByZW5kZXJlci5leHRlbnNpb25zLmdldCggJ0VYVF9mcmFnX2RlcHRoJyApID8gJyNleHRlbnNpb24gR0xfRVhUX2ZyYWdfZGVwdGggOiBlbmFibGUnIDogJycsXHJcblxyXG4gICAgICAgICAgICAgICAgJ3ByZWNpc2lvbiAnICsgcGFyYW1ldGVycy5wcmVjaXNpb24gKyAnIGZsb2F0OycsXHJcbiAgICAgICAgICAgICAgICAncHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgaW50OycsXHJcblxyXG4gICAgICAgICAgICAgICAgJyNkZWZpbmUgU0hBREVSX05BTUUgJyArIG1hdGVyaWFsLl9fd2ViZ2xTaGFkZXIubmFtZSxcclxuXHJcbiAgICAgICAgICAgICAgICBjdXN0b21EZWZpbmVzLFxyXG5cclxuICAgICAgICAgICAgICAgICcjZGVmaW5lIE1BWF9ESVJfTElHSFRTICcgKyBwYXJhbWV0ZXJzLm1heERpckxpZ2h0cyxcclxuICAgICAgICAgICAgICAgICcjZGVmaW5lIE1BWF9QT0lOVF9MSUdIVFMgJyArIHBhcmFtZXRlcnMubWF4UG9pbnRMaWdodHMsXHJcbiAgICAgICAgICAgICAgICAnI2RlZmluZSBNQVhfU1BPVF9MSUdIVFMgJyArIHBhcmFtZXRlcnMubWF4U3BvdExpZ2h0cyxcclxuICAgICAgICAgICAgICAgICcjZGVmaW5lIE1BWF9IRU1JX0xJR0hUUyAnICsgcGFyYW1ldGVycy5tYXhIZW1pTGlnaHRzLFxyXG5cclxuICAgICAgICAgICAgICAgICcjZGVmaW5lIE1BWF9TSEFET1dTICcgKyBwYXJhbWV0ZXJzLm1heFNoYWRvd3MsXHJcblxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5hbHBoYVRlc3QgPyAnI2RlZmluZSBBTFBIQVRFU1QgJyArIHBhcmFtZXRlcnMuYWxwaGFUZXN0IDogJycsXHJcblxyXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuZ2FtbWFJbnB1dCA/ICcjZGVmaW5lIEdBTU1BX0lOUFVUJyA6ICcnLFxyXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuZ2FtbWFPdXRwdXQgPyAnI2RlZmluZSBHQU1NQV9PVVRQVVQnIDogJycsXHJcbiAgICAgICAgICAgICAgICAnI2RlZmluZSBHQU1NQV9GQUNUT1IgJyArIGdhbW1hRmFjdG9yRGVmaW5lLFxyXG5cclxuICAgICAgICAgICAgICAgICggcGFyYW1ldGVycy51c2VGb2cgJiYgcGFyYW1ldGVycy5mb2cgKSA/ICcjZGVmaW5lIFVTRV9GT0cnIDogJycsXHJcbiAgICAgICAgICAgICAgICAoIHBhcmFtZXRlcnMudXNlRm9nICYmIHBhcmFtZXRlcnMuZm9nRXhwICkgPyAnI2RlZmluZSBGT0dfRVhQMicgOiAnJyxcclxuXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLm1hcCA/ICcjZGVmaW5lIFVTRV9NQVAnIDogJycsXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lIFVTRV9FTlZNQVAnIDogJycsXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBUeXBlRGVmaW5lIDogJycsXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBNb2RlRGVmaW5lIDogJycsXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBCbGVuZGluZ0RlZmluZSA6ICcnLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5saWdodE1hcCA/ICcjZGVmaW5lIFVTRV9MSUdIVE1BUCcgOiAnJyxcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuYW9NYXAgPyAnI2RlZmluZSBVU0VfQU9NQVAnIDogJycsXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmVtaXNzaXZlTWFwID8gJyNkZWZpbmUgVVNFX0VNSVNTSVZFTUFQJyA6ICcnLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5idW1wTWFwID8gJyNkZWZpbmUgVVNFX0JVTVBNQVAnIDogJycsXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLm5vcm1hbE1hcCA/ICcjZGVmaW5lIFVTRV9OT1JNQUxNQVAnIDogJycsXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLnNwZWN1bGFyTWFwID8gJyNkZWZpbmUgVVNFX1NQRUNVTEFSTUFQJyA6ICcnLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5hbHBoYU1hcCA/ICcjZGVmaW5lIFVTRV9BTFBIQU1BUCcgOiAnJyxcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMudmVydGV4Q29sb3JzID8gJyNkZWZpbmUgVVNFX0NPTE9SJyA6ICcnLFxyXG5cclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgPyAnI2RlZmluZSBGTEFUX1NIQURFRCcgOiAnJyxcclxuXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLm1ldGFsID8gJyNkZWZpbmUgTUVUQUwnIDogJycsXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmRvdWJsZVNpZGVkID8gJyNkZWZpbmUgRE9VQkxFX1NJREVEJyA6ICcnLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5mbGlwU2lkZWQgPyAnI2RlZmluZSBGTElQX1NJREVEJyA6ICcnLFxyXG5cclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lIFVTRV9TSEFET1dNQVAnIDogJycsXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSAnICsgc2hhZG93TWFwVHlwZURlZmluZSA6ICcnLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5zaGFkb3dNYXBEZWJ1ZyA/ICcjZGVmaW5lIFNIQURPV01BUF9ERUJVRycgOiAnJyxcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMucG9pbnRMaWdodFNoYWRvd3MgPiAwID8gJyNkZWZpbmUgUE9JTlRfTElHSFRfU0hBRE9XUycgOiAnJyxcclxuXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUYnIDogJycsXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgJiYgcmVuZGVyZXIuZXh0ZW5zaW9ucy5nZXQoICdFWFRfZnJhZ19kZXB0aCcgKSA/ICcjZGVmaW5lIFVTRV9MT0dERVBUSEJVRl9FWFQnIDogJycsXHJcblxyXG4gICAgICAgICAgICAgICAgJ3VuaWZvcm0gbWF0NCB2aWV3TWF0cml4OycsXHJcbiAgICAgICAgICAgICAgICAndW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uOycsXHJcblxyXG4gICAgICAgICAgICAgICAgJ1xcbidcclxuXHJcbiAgICAgICAgICAgIF0uZmlsdGVyKCBmaWx0ZXJFbXB0eUxpbmUgKS5qb2luKCAnXFxuJyApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB2ZXJ0ZXhHbHNsID0gcHJlZml4VmVydGV4ICsgdmVydGV4U2hhZGVyO1xyXG4gICAgICAgIHZhciBmcmFnbWVudEdsc2wgPSBwcmVmaXhGcmFnbWVudCArIGZyYWdtZW50U2hhZGVyO1xyXG5cclxuICAgICAgICB2YXIgZ2xWZXJ0ZXhTaGFkZXIgPSBUSFJFRS5XZWJHTFNoYWRlciggZ2wsIGdsLlZFUlRFWF9TSEFERVIsIHZlcnRleEdsc2wgKTtcclxuICAgICAgICB2YXIgZ2xGcmFnbWVudFNoYWRlciA9IFRIUkVFLldlYkdMU2hhZGVyKCBnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnbWVudEdsc2wgKTtcclxuXHJcbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBnbFZlcnRleFNoYWRlciApO1xyXG4gICAgICAgIGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZ2xGcmFnbWVudFNoYWRlciApO1xyXG5cclxuICAgICAgICAvLyBGb3JjZSBhIHBhcnRpY3VsYXIgYXR0cmlidXRlIHRvIGluZGV4IDAuXHJcblxyXG4gICAgICAgIGlmICggbWF0ZXJpYWwuaW5kZXgwQXR0cmlidXRlTmFtZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgZ2wuYmluZEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCAwLCBtYXRlcmlhbC5pbmRleDBBdHRyaWJ1dGVOYW1lICk7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzID09PSB0cnVlICkge1xyXG5cclxuICAgICAgICAgICAgLy8gcHJvZ3JhbXMgd2l0aCBtb3JwaFRhcmdldHMgZGlzcGxhY2UgcG9zaXRpb24gb3V0IG9mIGF0dHJpYnV0ZSAwXHJcbiAgICAgICAgICAgIGdsLmJpbmRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgMCwgJ3Bvc2l0aW9uJyApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdsLmxpbmtQcm9ncmFtKCBwcm9ncmFtICk7XHJcblxyXG4gICAgICAgIHZhciBwcm9ncmFtTG9nID0gZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coIHByb2dyYW0gKTtcclxuICAgICAgICB2YXIgdmVydGV4TG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyggZ2xWZXJ0ZXhTaGFkZXIgKTtcclxuICAgICAgICB2YXIgZnJhZ21lbnRMb2cgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKCBnbEZyYWdtZW50U2hhZGVyICk7XHJcblxyXG4gICAgICAgIHZhciBydW5uYWJsZSA9IHRydWU7XHJcbiAgICAgICAgdmFyIGhhdmVEaWFnbm9zdGljcyA9IHRydWU7XHJcblxyXG4gICAgICAgIGlmICggZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMgKSA9PT0gZmFsc2UgKSB7XHJcblxyXG4gICAgICAgICAgICBydW5uYWJsZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUHJvZ3JhbTogc2hhZGVyIGVycm9yOiAnLCBnbC5nZXRFcnJvcigpLCAnZ2wuVkFMSURBVEVfU1RBVFVTJywgZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuVkFMSURBVEVfU1RBVFVTICksICdnbC5nZXRQcm9ncmFtSW5mb0xvZycsIHByb2dyYW1Mb2csIHZlcnRleExvZywgZnJhZ21lbnRMb2cgKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICggcHJvZ3JhbUxvZyAhPT0gJycgKSB7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW06IGdsLmdldFByb2dyYW1JbmZvTG9nKCknLCBwcm9ncmFtTG9nICk7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoIHZlcnRleExvZyA9PT0gJycgfHwgZnJhZ21lbnRMb2cgPT09ICcnICkge1xyXG5cclxuICAgICAgICAgICAgaGF2ZURpYWdub3N0aWNzID0gZmFsc2U7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBoYXZlRGlhZ25vc3RpY3MgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRpYWdub3N0aWNzID0ge1xyXG5cclxuICAgICAgICAgICAgICAgIHJ1bm5hYmxlOiBydW5uYWJsZSxcclxuICAgICAgICAgICAgICAgIG1hdGVyaWFsOiBtYXRlcmlhbCxcclxuXHJcbiAgICAgICAgICAgICAgICBwcm9ncmFtTG9nOiBwcm9ncmFtTG9nLFxyXG5cclxuICAgICAgICAgICAgICAgIHZlcnRleFNoYWRlcjoge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsb2c6IHZlcnRleExvZyxcclxuICAgICAgICAgICAgICAgICAgICBwcmVmaXg6IHByZWZpeFZlcnRleFxyXG5cclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbG9nOiBmcmFnbWVudExvZyxcclxuICAgICAgICAgICAgICAgICAgICBwcmVmaXg6IHByZWZpeEZyYWdtZW50XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjbGVhbiB1cFxyXG5cclxuICAgICAgICBnbC5kZWxldGVTaGFkZXIoIGdsVmVydGV4U2hhZGVyICk7XHJcbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKCBnbEZyYWdtZW50U2hhZGVyICk7XHJcblxyXG4gICAgICAgIC8vIHNldCB1cCBjYWNoaW5nIGZvciB1bmlmb3JtIGxvY2F0aW9uc1xyXG5cclxuICAgICAgICB2YXIgY2FjaGVkVW5pZm9ybXM7XHJcblxyXG4gICAgICAgIHRoaXMuZ2V0VW5pZm9ybXMgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggY2FjaGVkVW5pZm9ybXMgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjYWNoZWRVbmlmb3JtcyA9IGZldGNoVW5pZm9ybUxvY2F0aW9ucyggZ2wsIHByb2dyYW0gKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRVbmlmb3JtcztcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gc2V0IHVwIGNhY2hpbmcgZm9yIGF0dHJpYnV0ZSBsb2NhdGlvbnNcclxuXHJcbiAgICAgICAgdmFyIGNhY2hlZEF0dHJpYnV0ZXM7XHJcblxyXG4gICAgICAgIHRoaXMuZ2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBjYWNoZWRBdHRyaWJ1dGVzID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FjaGVkQXR0cmlidXRlcyA9IGZldGNoQXR0cmlidXRlTG9jYXRpb25zKCBnbCwgcHJvZ3JhbSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZEF0dHJpYnV0ZXM7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIGZyZWUgcmVzb3VyY2VcclxuXHJcbiAgICAgICAgdGhpcy5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgICAgICBnbC5kZWxldGVQcm9ncmFtKCBwcm9ncmFtICk7XHJcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gREVQUkVDQVRFRFxyXG5cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xyXG5cclxuICAgICAgICAgICAgdW5pZm9ybXM6IHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUHJvZ3JhbTogLnVuaWZvcm1zIGlzIG5vdyAuZ2V0VW5pZm9ybXMoKS4nICk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VW5pZm9ybXMoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW06IC5hdHRyaWJ1dGVzIGlzIG5vdyAuZ2V0QXR0cmlidXRlcygpLicgKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGVzKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gKTtcclxuXHJcblxyXG4gICAgICAgIC8vXHJcblxyXG4gICAgICAgIHRoaXMuaWQgPSBwcm9ncmFtSWRDb3VudCArKztcclxuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xyXG4gICAgICAgIHRoaXMudXNlZFRpbWVzID0gMTtcclxuICAgICAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xyXG4gICAgICAgIHRoaXMudmVydGV4U2hhZGVyID0gZ2xWZXJ0ZXhTaGFkZXI7XHJcbiAgICAgICAgdGhpcy5mcmFnbWVudFNoYWRlciA9IGdsRnJhZ21lbnRTaGFkZXI7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH07XHJcblxyXG59ICkoKTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTFByb2dyYW1zLmpzXHJcblxyXG5USFJFRS5XZWJHTFByb2dyYW1zID0gZnVuY3Rpb24gKCByZW5kZXJlciwgY2FwYWJpbGl0aWVzICkge1xyXG5cclxuICAgIHZhciBwcm9ncmFtcyA9IFtdO1xyXG5cclxuICAgIHZhciBzaGFkZXJJRHMgPSB7XHJcbiAgICAgICAgTWVzaERlcHRoTWF0ZXJpYWw6ICdkZXB0aCcsXHJcbiAgICAgICAgTWVzaE5vcm1hbE1hdGVyaWFsOiAnbm9ybWFsJyxcclxuICAgICAgICBNZXNoQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcclxuICAgICAgICBNZXNoTGFtYmVydE1hdGVyaWFsOiAnbGFtYmVydCcsXHJcbiAgICAgICAgTWVzaFBob25nTWF0ZXJpYWw6ICdwaG9uZycsXHJcbiAgICAgICAgTGluZUJhc2ljTWF0ZXJpYWw6ICdiYXNpYycsXHJcbiAgICAgICAgTGluZURhc2hlZE1hdGVyaWFsOiAnZGFzaGVkJyxcclxuICAgICAgICBQb2ludHNNYXRlcmlhbDogJ3BvaW50cydcclxuICAgIH07XHJcblxyXG4gICAgdmFyIHBhcmFtZXRlck5hbWVzID0gW1xyXG4gICAgICAgIFwicHJlY2lzaW9uXCIsIFwic3VwcG9ydHNWZXJ0ZXhUZXh0dXJlc1wiLCBcIm1hcFwiLCBcImVudk1hcFwiLCBcImVudk1hcE1vZGVcIixcclxuICAgICAgICBcImxpZ2h0TWFwXCIsIFwiYW9NYXBcIiwgXCJlbWlzc2l2ZU1hcFwiLCBcImJ1bXBNYXBcIiwgXCJub3JtYWxNYXBcIiwgXCJkaXNwbGFjZW1lbnRNYXBcIiwgXCJzcGVjdWxhck1hcFwiLFxyXG4gICAgICAgIFwiYWxwaGFNYXBcIiwgXCJjb21iaW5lXCIsIFwidmVydGV4Q29sb3JzXCIsIFwiZm9nXCIsIFwidXNlRm9nXCIsIFwiZm9nRXhwXCIsXHJcbiAgICAgICAgXCJmbGF0U2hhZGluZ1wiLCBcInNpemVBdHRlbnVhdGlvblwiLCBcImxvZ2FyaXRobWljRGVwdGhCdWZmZXJcIiwgXCJza2lubmluZ1wiLFxyXG4gICAgICAgIFwibWF4Qm9uZXNcIiwgXCJ1c2VWZXJ0ZXhUZXh0dXJlXCIsIFwibW9ycGhUYXJnZXRzXCIsIFwibW9ycGhOb3JtYWxzXCIsXHJcbiAgICAgICAgXCJtYXhNb3JwaFRhcmdldHNcIiwgXCJtYXhNb3JwaE5vcm1hbHNcIiwgXCJtYXhEaXJMaWdodHNcIiwgXCJtYXhQb2ludExpZ2h0c1wiLFxyXG4gICAgICAgIFwibWF4U3BvdExpZ2h0c1wiLCBcIm1heEhlbWlMaWdodHNcIiwgXCJtYXhTaGFkb3dzXCIsIFwic2hhZG93TWFwRW5hYmxlZFwiLCBcInBvaW50TGlnaHRTaGFkb3dzXCIsXHJcbiAgICAgICAgXCJzaGFkb3dNYXBUeXBlXCIsIFwic2hhZG93TWFwRGVidWdcIiwgXCJhbHBoYVRlc3RcIiwgXCJtZXRhbFwiLCBcImRvdWJsZVNpZGVkXCIsXHJcbiAgICAgICAgXCJmbGlwU2lkZWRcIlxyXG4gICAgXTtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gYWxsb2NhdGVCb25lcyAoIG9iamVjdCApIHtcclxuXHJcbiAgICAgICAgaWYgKCBjYXBhYmlsaXRpZXMuZmxvYXRWZXJ0ZXhUZXh0dXJlcyAmJiBvYmplY3QgJiYgb2JqZWN0LnNrZWxldG9uICYmIG9iamVjdC5za2VsZXRvbi51c2VWZXJ0ZXhUZXh0dXJlICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIDEwMjQ7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAvLyBkZWZhdWx0IGZvciB3aGVuIG9iamVjdCBpcyBub3Qgc3BlY2lmaWVkXHJcbiAgICAgICAgICAgIC8vICggZm9yIGV4YW1wbGUgd2hlbiBwcmVidWlsZGluZyBzaGFkZXIgdG8gYmUgdXNlZCB3aXRoIG11bHRpcGxlIG9iamVjdHMgKVxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyAgLSBsZWF2ZSBzb21lIGV4dHJhIHNwYWNlIGZvciBvdGhlciB1bmlmb3Jtc1xyXG4gICAgICAgICAgICAvLyAgLSBsaW1pdCBoZXJlIGlzIEFOR0xFJ3MgMjU0IG1heCB1bmlmb3JtIHZlY3RvcnNcclxuICAgICAgICAgICAgLy8gICAgKHVwIHRvIDU0IHNob3VsZCBiZSBzYWZlKVxyXG5cclxuICAgICAgICAgICAgdmFyIG5WZXJ0ZXhVbmlmb3JtcyA9IGNhcGFiaWxpdGllcy5tYXhWZXJ0ZXhVbmlmb3JtcztcclxuICAgICAgICAgICAgdmFyIG5WZXJ0ZXhNYXRyaWNlcyA9IE1hdGguZmxvb3IoICggblZlcnRleFVuaWZvcm1zIC0gMjAgKSAvIDQgKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBtYXhCb25lcyA9IG5WZXJ0ZXhNYXRyaWNlcztcclxuXHJcbiAgICAgICAgICAgIGlmICggb2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU2tpbm5lZE1lc2ggKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgbWF4Qm9uZXMgPSBNYXRoLm1pbiggb2JqZWN0LnNrZWxldG9uLmJvbmVzLmxlbmd0aCwgbWF4Qm9uZXMgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIG1heEJvbmVzIDwgb2JqZWN0LnNrZWxldG9uLmJvbmVzLmxlbmd0aCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnV2ViR0xSZW5kZXJlcjogdG9vIG1hbnkgYm9uZXMgLSAnICsgb2JqZWN0LnNrZWxldG9uLmJvbmVzLmxlbmd0aCArICcsIHRoaXMgR1BVIHN1cHBvcnRzIGp1c3QgJyArIG1heEJvbmVzICsgJyAodHJ5IE9wZW5HTCBpbnN0ZWFkIG9mIEFOR0xFKScgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbWF4Qm9uZXM7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWxsb2NhdGVMaWdodHMoIGxpZ2h0cyApIHtcclxuXHJcbiAgICAgICAgdmFyIGRpckxpZ2h0cyA9IDA7XHJcbiAgICAgICAgdmFyIHBvaW50TGlnaHRzID0gMDtcclxuICAgICAgICB2YXIgc3BvdExpZ2h0cyA9IDA7XHJcbiAgICAgICAgdmFyIGhlbWlMaWdodHMgPSAwO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgbCA9IDAsIGxsID0gbGlnaHRzLmxlbmd0aDsgbCA8IGxsOyBsICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGxpZ2h0ID0gbGlnaHRzWyBsIF07XHJcblxyXG4gICAgICAgICAgICBpZiAoIGxpZ2h0LnZpc2libGUgPT09IGZhbHNlICkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCApIGRpckxpZ2h0cyArKztcclxuICAgICAgICAgICAgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50TGlnaHQgKSBwb2ludExpZ2h0cyArKztcclxuICAgICAgICAgICAgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCApIHNwb3RMaWdodHMgKys7XHJcbiAgICAgICAgICAgIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5IZW1pc3BoZXJlTGlnaHQgKSBoZW1pTGlnaHRzICsrO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7ICdkaXJlY3Rpb25hbCc6IGRpckxpZ2h0cywgJ3BvaW50JzogcG9pbnRMaWdodHMsICdzcG90Jzogc3BvdExpZ2h0cywgJ2hlbWknOiBoZW1pTGlnaHRzIH07XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFsbG9jYXRlU2hhZG93cyggbGlnaHRzICkge1xyXG5cclxuICAgICAgICB2YXIgbWF4U2hhZG93cyA9IDA7XHJcbiAgICAgICAgdmFyIHBvaW50TGlnaHRTaGFkb3dzID0gMDtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGwgPSAwLCBsbCA9IGxpZ2h0cy5sZW5ndGg7IGwgPCBsbDsgbCArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBsaWdodCA9IGxpZ2h0c1sgbCBdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCAhIGxpZ2h0LmNhc3RTaGFkb3cgKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5TcG90TGlnaHQgfHwgbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICkgbWF4U2hhZG93cyArKztcclxuICAgICAgICAgICAgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50TGlnaHQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgbWF4U2hhZG93cyArKztcclxuICAgICAgICAgICAgICAgIHBvaW50TGlnaHRTaGFkb3dzICsrO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7ICdtYXhTaGFkb3dzJzogbWF4U2hhZG93cywgJ3BvaW50TGlnaHRTaGFkb3dzJzogcG9pbnRMaWdodFNoYWRvd3MgfTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5nZXRQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCBtYXRlcmlhbCwgbGlnaHRzLCBmb2csIG9iamVjdCApIHtcclxuXHJcbiAgICAgICAgdmFyIHNoYWRlcklEID0gc2hhZGVySURzWyBtYXRlcmlhbC50eXBlIF07XHJcbiAgICAgICAgLy8gaGV1cmlzdGljcyB0byBjcmVhdGUgc2hhZGVyIHBhcmFtZXRlcnMgYWNjb3JkaW5nIHRvIGxpZ2h0cyBpbiB0aGUgc2NlbmVcclxuICAgICAgICAvLyAobm90IHRvIGJsb3cgb3ZlciBtYXhMaWdodHMgYnVkZ2V0KVxyXG5cclxuICAgICAgICB2YXIgbWF4TGlnaHRDb3VudCA9IGFsbG9jYXRlTGlnaHRzKCBsaWdodHMgKTtcclxuICAgICAgICB2YXIgYWxsb2NhdGVkU2hhZG93cyA9IGFsbG9jYXRlU2hhZG93cyggbGlnaHRzICk7XHJcbiAgICAgICAgdmFyIG1heEJvbmVzID0gYWxsb2NhdGVCb25lcyggb2JqZWN0ICk7XHJcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IHJlbmRlcmVyLmdldFByZWNpc2lvbigpO1xyXG5cclxuICAgICAgICBpZiAoIG1hdGVyaWFsLnByZWNpc2lvbiAhPT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgIHByZWNpc2lvbiA9IGNhcGFiaWxpdGllcy5nZXRNYXhQcmVjaXNpb24oIG1hdGVyaWFsLnByZWNpc2lvbiApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBwcmVjaXNpb24gIT09IG1hdGVyaWFsLnByZWNpc2lvbiApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyLmluaXRNYXRlcmlhbDonLCBtYXRlcmlhbC5wcmVjaXNpb24sICdub3Qgc3VwcG9ydGVkLCB1c2luZycsIHByZWNpc2lvbiwgJ2luc3RlYWQuJyApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBwYXJhbWV0ZXJzID0ge1xyXG5cclxuICAgICAgICAgICAgc2hhZGVySUQ6IHNoYWRlcklELFxyXG5cclxuICAgICAgICAgICAgcHJlY2lzaW9uOiBwcmVjaXNpb24sXHJcbiAgICAgICAgICAgIHN1cHBvcnRzVmVydGV4VGV4dHVyZXM6IGNhcGFiaWxpdGllcy52ZXJ0ZXhUZXh0dXJlcyxcclxuXHJcbiAgICAgICAgICAgIG1hcDogISEgbWF0ZXJpYWwubWFwLFxyXG4gICAgICAgICAgICBlbnZNYXA6ICEhIG1hdGVyaWFsLmVudk1hcCxcclxuICAgICAgICAgICAgZW52TWFwTW9kZTogbWF0ZXJpYWwuZW52TWFwICYmIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nLFxyXG4gICAgICAgICAgICBsaWdodE1hcDogISEgbWF0ZXJpYWwubGlnaHRNYXAsXHJcbiAgICAgICAgICAgIGFvTWFwOiAhISBtYXRlcmlhbC5hb01hcCxcclxuICAgICAgICAgICAgZW1pc3NpdmVNYXA6ICEhIG1hdGVyaWFsLmVtaXNzaXZlTWFwLFxyXG4gICAgICAgICAgICBidW1wTWFwOiAhISBtYXRlcmlhbC5idW1wTWFwLFxyXG4gICAgICAgICAgICBub3JtYWxNYXA6ICEhIG1hdGVyaWFsLm5vcm1hbE1hcCxcclxuICAgICAgICAgICAgZGlzcGxhY2VtZW50TWFwOiAhISBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAsXHJcbiAgICAgICAgICAgIHNwZWN1bGFyTWFwOiAhISBtYXRlcmlhbC5zcGVjdWxhck1hcCxcclxuICAgICAgICAgICAgYWxwaGFNYXA6ICEhIG1hdGVyaWFsLmFscGhhTWFwLFxyXG5cclxuICAgICAgICAgICAgY29tYmluZTogbWF0ZXJpYWwuY29tYmluZSxcclxuXHJcbiAgICAgICAgICAgIHZlcnRleENvbG9yczogbWF0ZXJpYWwudmVydGV4Q29sb3JzLFxyXG5cclxuICAgICAgICAgICAgZm9nOiBmb2csXHJcbiAgICAgICAgICAgIHVzZUZvZzogbWF0ZXJpYWwuZm9nLFxyXG4gICAgICAgICAgICBmb2dFeHA6IGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZ0V4cDIsXHJcblxyXG4gICAgICAgICAgICBmbGF0U2hhZGluZzogbWF0ZXJpYWwuc2hhZGluZyA9PT0gVEhSRUUuRmxhdFNoYWRpbmcsXHJcblxyXG4gICAgICAgICAgICBzaXplQXR0ZW51YXRpb246IG1hdGVyaWFsLnNpemVBdHRlbnVhdGlvbixcclxuICAgICAgICAgICAgbG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcjogY2FwYWJpbGl0aWVzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIsXHJcblxyXG4gICAgICAgICAgICBza2lubmluZzogbWF0ZXJpYWwuc2tpbm5pbmcsXHJcbiAgICAgICAgICAgIG1heEJvbmVzOiBtYXhCb25lcyxcclxuICAgICAgICAgICAgdXNlVmVydGV4VGV4dHVyZTogY2FwYWJpbGl0aWVzLmZsb2F0VmVydGV4VGV4dHVyZXMgJiYgb2JqZWN0ICYmIG9iamVjdC5za2VsZXRvbiAmJiBvYmplY3Quc2tlbGV0b24udXNlVmVydGV4VGV4dHVyZSxcclxuXHJcbiAgICAgICAgICAgIG1vcnBoVGFyZ2V0czogbWF0ZXJpYWwubW9ycGhUYXJnZXRzLFxyXG4gICAgICAgICAgICBtb3JwaE5vcm1hbHM6IG1hdGVyaWFsLm1vcnBoTm9ybWFscyxcclxuICAgICAgICAgICAgbWF4TW9ycGhUYXJnZXRzOiByZW5kZXJlci5tYXhNb3JwaFRhcmdldHMsXHJcbiAgICAgICAgICAgIG1heE1vcnBoTm9ybWFsczogcmVuZGVyZXIubWF4TW9ycGhOb3JtYWxzLFxyXG5cclxuICAgICAgICAgICAgbWF4RGlyTGlnaHRzOiBtYXhMaWdodENvdW50LmRpcmVjdGlvbmFsLFxyXG4gICAgICAgICAgICBtYXhQb2ludExpZ2h0czogbWF4TGlnaHRDb3VudC5wb2ludCxcclxuICAgICAgICAgICAgbWF4U3BvdExpZ2h0czogbWF4TGlnaHRDb3VudC5zcG90LFxyXG4gICAgICAgICAgICBtYXhIZW1pTGlnaHRzOiBtYXhMaWdodENvdW50LmhlbWksXHJcblxyXG4gICAgICAgICAgICBtYXhTaGFkb3dzOiBhbGxvY2F0ZWRTaGFkb3dzLm1heFNoYWRvd3MsXHJcbiAgICAgICAgICAgIHBvaW50TGlnaHRTaGFkb3dzOiBhbGxvY2F0ZWRTaGFkb3dzLnBvaW50TGlnaHRTaGFkb3dzLFxyXG4gICAgICAgICAgICBzaGFkb3dNYXBFbmFibGVkOiByZW5kZXJlci5zaGFkb3dNYXAuZW5hYmxlZCAmJiBvYmplY3QucmVjZWl2ZVNoYWRvdyAmJiBhbGxvY2F0ZWRTaGFkb3dzLm1heFNoYWRvd3MgPiAwLFxyXG4gICAgICAgICAgICBzaGFkb3dNYXBUeXBlOiByZW5kZXJlci5zaGFkb3dNYXAudHlwZSxcclxuICAgICAgICAgICAgc2hhZG93TWFwRGVidWc6IHJlbmRlcmVyLnNoYWRvd01hcC5kZWJ1ZyxcclxuXHJcbiAgICAgICAgICAgIGFscGhhVGVzdDogbWF0ZXJpYWwuYWxwaGFUZXN0LFxyXG4gICAgICAgICAgICBtZXRhbDogbWF0ZXJpYWwubWV0YWwsXHJcbiAgICAgICAgICAgIGRvdWJsZVNpZGVkOiBtYXRlcmlhbC5zaWRlID09PSBUSFJFRS5Eb3VibGVTaWRlLFxyXG4gICAgICAgICAgICBmbGlwU2lkZWQ6IG1hdGVyaWFsLnNpZGUgPT09IFRIUkVFLkJhY2tTaWRlXHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5nZXRQcm9ncmFtQ29kZSA9IGZ1bmN0aW9uICggbWF0ZXJpYWwsIHBhcmFtZXRlcnMgKSB7XHJcblxyXG4gICAgICAgIHZhciBjaHVua3MgPSBbXTtcclxuXHJcbiAgICAgICAgaWYgKCBwYXJhbWV0ZXJzLnNoYWRlcklEICkge1xyXG5cclxuICAgICAgICAgICAgY2h1bmtzLnB1c2goIHBhcmFtZXRlcnMuc2hhZGVySUQgKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKCBtYXRlcmlhbC5mcmFnbWVudFNoYWRlciApO1xyXG4gICAgICAgICAgICBjaHVua3MucHVzaCggbWF0ZXJpYWwudmVydGV4U2hhZGVyICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBtYXRlcmlhbC5kZWZpbmVzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgbmFtZSBpbiBtYXRlcmlhbC5kZWZpbmVzICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKCBuYW1lICk7XHJcbiAgICAgICAgICAgICAgICBjaHVua3MucHVzaCggbWF0ZXJpYWwuZGVmaW5lc1sgbmFtZSBdICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgcGFyYW1ldGVyTmFtZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHBhcmFtZXRlck5hbWUgPSBwYXJhbWV0ZXJOYW1lc1sgaSBdO1xyXG4gICAgICAgICAgICBjaHVua3MucHVzaCggcGFyYW1ldGVyTmFtZSApO1xyXG4gICAgICAgICAgICBjaHVua3MucHVzaCggcGFyYW1ldGVyc1sgcGFyYW1ldGVyTmFtZSBdICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNodW5rcy5qb2luKCk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmFjcXVpcmVQcm9ncmFtID0gZnVuY3Rpb24gKCBtYXRlcmlhbCwgcGFyYW1ldGVycywgY29kZSApIHtcclxuXHJcbiAgICAgICAgdmFyIHByb2dyYW07XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGlmIGNvZGUgaGFzIGJlZW4gYWxyZWFkeSBjb21waWxlZFxyXG4gICAgICAgIGZvciAoIHZhciBwID0gMCwgcGwgPSBwcm9ncmFtcy5sZW5ndGg7IHAgPCBwbDsgcCArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBwcm9ncmFtSW5mbyA9IHByb2dyYW1zWyBwIF07XHJcblxyXG4gICAgICAgICAgICBpZiAoIHByb2dyYW1JbmZvLmNvZGUgPT09IGNvZGUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcHJvZ3JhbSA9IHByb2dyYW1JbmZvO1xyXG4gICAgICAgICAgICAgICAgKysgcHJvZ3JhbS51c2VkVGltZXM7XHJcblxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBwcm9ncmFtID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICBwcm9ncmFtID0gbmV3IFRIUkVFLldlYkdMUHJvZ3JhbSggcmVuZGVyZXIsIGNvZGUsIG1hdGVyaWFsLCBwYXJhbWV0ZXJzICk7XHJcbiAgICAgICAgICAgIHByb2dyYW1zLnB1c2goIHByb2dyYW0gKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcHJvZ3JhbTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMucmVsZWFzZVByb2dyYW0gPSBmdW5jdGlvbiggcHJvZ3JhbSApIHtcclxuXHJcbiAgICAgICAgaWYgKCAtLSBwcm9ncmFtLnVzZWRUaW1lcyA9PT0gMCApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIHVub3JkZXJlZCBzZXRcclxuICAgICAgICAgICAgdmFyIGkgPSBwcm9ncmFtcy5pbmRleE9mKCBwcm9ncmFtICk7XHJcbiAgICAgICAgICAgIHByb2dyYW1zWyBpIF0gPSBwcm9ncmFtc1sgcHJvZ3JhbXMubGVuZ3RoIC0gMSBdO1xyXG4gICAgICAgICAgICBwcm9ncmFtcy5wb3AoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZyZWUgV2ViR0wgcmVzb3VyY2VzXHJcbiAgICAgICAgICAgIHByb2dyYW0uZGVzdHJveSgpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBFeHBvc2VkIGZvciByZXNvdXJjZSBtb25pdG9yaW5nICYgZXJyb3IgZmVlZGJhY2sgdmlhIHJlbmRlcmVyLmluZm86XHJcbiAgICB0aGlzLnByb2dyYW1zID0gcHJvZ3JhbXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMUHJvcGVydGllcy5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgZm9yZGFjaW91cyAvIGZvcmRhY2lvdXMuZ2l0aHViLmlvXHJcbiAqL1xyXG5cclxuVEhSRUUuV2ViR0xQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBwcm9wZXJ0aWVzID0ge307XHJcblxyXG4gICAgdGhpcy5nZXQgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcbiAgICAgICAgdmFyIHV1aWQgPSBvYmplY3QudXVpZDtcclxuICAgICAgICB2YXIgbWFwID0gcHJvcGVydGllc1sgdXVpZCBdO1xyXG5cclxuICAgICAgICBpZiAoIG1hcCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgbWFwID0ge307XHJcbiAgICAgICAgICAgIHByb3BlcnRpZXNbIHV1aWQgXSA9IG1hcDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbWFwO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5kZWxldGUgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcbiAgICAgICAgZGVsZXRlIHByb3BlcnRpZXNbIG9iamVjdC51dWlkIF07XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICBwcm9wZXJ0aWVzID0ge307XHJcblxyXG4gICAgfTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xTaGFkZXIuanNcclxuXHJcblRIUkVFLldlYkdMU2hhZGVyID0gKCBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkTGluZU51bWJlcnMoIHN0cmluZyApIHtcclxuXHJcbiAgICAgICAgdmFyIGxpbmVzID0gc3RyaW5nLnNwbGl0KCAnXFxuJyApO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICBsaW5lc1sgaSBdID0gKCBpICsgMSApICsgJzogJyArIGxpbmVzWyBpIF07XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGxpbmVzLmpvaW4oICdcXG4nICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiBXZWJHTFNoYWRlciggZ2wsIHR5cGUsIHN0cmluZyApIHtcclxuXHJcbiAgICAgICAgdmFyIHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggdHlwZSApO1xyXG5cclxuICAgICAgICBnbC5zaGFkZXJTb3VyY2UoIHNoYWRlciwgc3RyaW5nICk7XHJcbiAgICAgICAgZ2wuY29tcGlsZVNoYWRlciggc2hhZGVyICk7XHJcblxyXG4gICAgICAgIGlmICggZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKCBzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTICkgPT09IGZhbHNlICkge1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMU2hhZGVyOiBTaGFkZXIgY291bGRuXFwndCBjb21waWxlLicgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIGdsLmdldFNoYWRlckluZm9Mb2coIHNoYWRlciApICE9PSAnJyApIHtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMU2hhZGVyOiBnbC5nZXRTaGFkZXJJbmZvTG9nKCknLCB0eXBlID09PSBnbC5WRVJURVhfU0hBREVSID8gJ3ZlcnRleCcgOiAnZnJhZ21lbnQnLCBnbC5nZXRTaGFkZXJJbmZvTG9nKCBzaGFkZXIgKSwgYWRkTGluZU51bWJlcnMoIHN0cmluZyApICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gLS1lbmFibGUtcHJpdmlsZWdlZC13ZWJnbC1leHRlbnNpb25cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyggdHlwZSwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfZGVidWdfc2hhZGVycycgKS5nZXRUcmFuc2xhdGVkU2hhZGVyU291cmNlKCBzaGFkZXIgKSApO1xyXG5cclxuICAgICAgICByZXR1cm4gc2hhZGVyO1xyXG5cclxuICAgIH07XHJcblxyXG59ICkoKTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTFNoYWRvd01hcC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuV2ViR0xTaGFkb3dNYXAgPSBmdW5jdGlvbiAoIF9yZW5kZXJlciwgX2xpZ2h0cywgX29iamVjdHMgKSB7XHJcblxyXG4gICAgdmFyIF9nbCA9IF9yZW5kZXJlci5jb250ZXh0LFxyXG4gICAgICAgIF9zdGF0ZSA9IF9yZW5kZXJlci5zdGF0ZSxcclxuICAgICAgICBfZnJ1c3R1bSA9IG5ldyBUSFJFRS5GcnVzdHVtKCksXHJcbiAgICAgICAgX3Byb2pTY3JlZW5NYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpLFxyXG5cclxuICAgICAgICBfbWluID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuICAgICAgICBfbWF4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHJcbiAgICAgICAgX2xvb2tUYXJnZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG4gICAgICAgIF9saWdodFBvc2l0aW9uV29ybGQgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cclxuICAgICAgICBfcmVuZGVyTGlzdCA9IFtdLFxyXG5cclxuICAgICAgICBfTW9ycGhpbmdGbGFnID0gMSxcclxuICAgICAgICBfU2tpbm5pbmdGbGFnID0gMixcclxuXHJcbiAgICAgICAgX051bWJlck9mTWF0ZXJpYWxWYXJpYW50cyA9ICggX01vcnBoaW5nRmxhZyB8IF9Ta2lubmluZ0ZsYWcgKSArIDEsXHJcblxyXG4gICAgICAgIF9kZXB0aE1hdGVyaWFscyA9IG5ldyBBcnJheSggX051bWJlck9mTWF0ZXJpYWxWYXJpYW50cyApLFxyXG4gICAgICAgIF9kaXN0YW5jZU1hdGVyaWFscyA9IG5ldyBBcnJheSggX051bWJlck9mTWF0ZXJpYWxWYXJpYW50cyApO1xyXG5cclxuICAgIHZhciBjdWJlRGlyZWN0aW9ucyA9IFtcclxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMCwgMCApLCBuZXcgVEhSRUUuVmVjdG9yMyggLSAxLCAwLCAwICksIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICksXHJcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIC0gMSApLCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLSAxLCAwIClcclxuICAgIF07XHJcblxyXG4gICAgdmFyIGN1YmVVcHMgPSBbXHJcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKSwgbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKSwgbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKSxcclxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApLFx0bmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIC0gMSApXHJcbiAgICBdO1xyXG5cclxuICAgIHZhciBjdWJlMkRWaWV3UG9ydHMgPSBbXHJcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjQoKSwgbmV3IFRIUkVFLlZlY3RvcjQoKSwgbmV3IFRIUkVFLlZlY3RvcjQoKSxcclxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yNCgpLCBuZXcgVEhSRUUuVmVjdG9yNCgpLCBuZXcgVEhSRUUuVmVjdG9yNCgpXHJcbiAgICBdO1xyXG5cclxuICAgIHZhciBfdmVjdG9yNCA9IG5ldyBUSFJFRS5WZWN0b3I0KCk7XHJcblxyXG4gICAgLy8gaW5pdFxyXG5cclxuICAgIHZhciBkZXB0aFNoYWRlciA9IFRIUkVFLlNoYWRlckxpYlsgXCJkZXB0aFJHQkFcIiBdO1xyXG4gICAgdmFyIGRlcHRoVW5pZm9ybXMgPSBUSFJFRS5Vbmlmb3Jtc1V0aWxzLmNsb25lKCBkZXB0aFNoYWRlci51bmlmb3JtcyApO1xyXG5cclxuICAgIHZhciBkaXN0YW5jZVNoYWRlciA9IFRIUkVFLlNoYWRlckxpYlsgXCJkaXN0YW5jZVJHQkFcIiBdO1xyXG4gICAgdmFyIGRpc3RhbmNlVW5pZm9ybXMgPSBUSFJFRS5Vbmlmb3Jtc1V0aWxzLmNsb25lKCBkaXN0YW5jZVNoYWRlci51bmlmb3JtcyApO1xyXG5cclxuICAgIGZvciAoIHZhciBpID0gMDsgaSAhPT0gX051bWJlck9mTWF0ZXJpYWxWYXJpYW50czsgKysgaSApIHtcclxuXHJcbiAgICAgICAgdmFyIHVzZU1vcnBoaW5nID0gKCBpICYgX01vcnBoaW5nRmxhZyApICE9PSAwO1xyXG4gICAgICAgIHZhciB1c2VTa2lubmluZyA9ICggaSAmIF9Ta2lubmluZ0ZsYWcgKSAhPT0gMDtcclxuXHJcbiAgICAgICAgdmFyIGRlcHRoTWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHtcclxuICAgICAgICAgICAgdW5pZm9ybXM6IGRlcHRoVW5pZm9ybXMsXHJcbiAgICAgICAgICAgIHZlcnRleFNoYWRlcjogZGVwdGhTaGFkZXIudmVydGV4U2hhZGVyLFxyXG4gICAgICAgICAgICBmcmFnbWVudFNoYWRlcjogZGVwdGhTaGFkZXIuZnJhZ21lbnRTaGFkZXIsXHJcbiAgICAgICAgICAgIG1vcnBoVGFyZ2V0czogdXNlTW9ycGhpbmcsXHJcbiAgICAgICAgICAgIHNraW5uaW5nOiB1c2VTa2lubmluZ1xyXG4gICAgICAgIH0gKTtcclxuXHJcbiAgICAgICAgZGVwdGhNYXRlcmlhbC5fc2hhZG93UGFzcyA9IHRydWU7XHJcblxyXG4gICAgICAgIF9kZXB0aE1hdGVyaWFsc1sgaSBdID0gZGVwdGhNYXRlcmlhbDtcclxuXHJcbiAgICAgICAgdmFyIGRpc3RhbmNlTWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHtcclxuICAgICAgICAgICAgdW5pZm9ybXM6IGRpc3RhbmNlVW5pZm9ybXMsXHJcbiAgICAgICAgICAgIHZlcnRleFNoYWRlcjogZGlzdGFuY2VTaGFkZXIudmVydGV4U2hhZGVyLFxyXG4gICAgICAgICAgICBmcmFnbWVudFNoYWRlcjogZGlzdGFuY2VTaGFkZXIuZnJhZ21lbnRTaGFkZXIsXHJcbiAgICAgICAgICAgIG1vcnBoVGFyZ2V0czogdXNlTW9ycGhpbmcsXHJcbiAgICAgICAgICAgIHNraW5uaW5nOiB1c2VTa2lubmluZ1xyXG4gICAgICAgIH0gKTtcclxuXHJcbiAgICAgICAgZGlzdGFuY2VNYXRlcmlhbC5fc2hhZG93UGFzcyA9IHRydWU7XHJcblxyXG4gICAgICAgIF9kaXN0YW5jZU1hdGVyaWFsc1sgaSBdID0gZGlzdGFuY2VNYXRlcmlhbDtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy9cclxuXHJcbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuYXV0b1VwZGF0ZSA9IHRydWU7XHJcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy50eXBlID0gVEhSRUUuUENGU2hhZG93TWFwO1xyXG4gICAgdGhpcy5jdWxsRmFjZSA9IFRIUkVFLkN1bGxGYWNlRnJvbnQ7XHJcblxyXG4gICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lICkge1xyXG5cclxuICAgICAgICB2YXIgZmFjZUNvdW50LCBpc1BvaW50TGlnaHQ7XHJcblxyXG4gICAgICAgIGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XHJcbiAgICAgICAgaWYgKCBzY29wZS5hdXRvVXBkYXRlID09PSBmYWxzZSAmJiBzY29wZS5uZWVkc1VwZGF0ZSA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG4gICAgICAgIC8vIFNldCBHTCBzdGF0ZSBmb3IgZGVwdGggbWFwLlxyXG4gICAgICAgIF9nbC5jbGVhckNvbG9yKCAxLCAxLCAxLCAxICk7XHJcbiAgICAgICAgX3N0YXRlLmRpc2FibGUoIF9nbC5CTEVORCApO1xyXG4gICAgICAgIF9zdGF0ZS5lbmFibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcclxuICAgICAgICBfZ2wuZnJvbnRGYWNlKCBfZ2wuQ0NXICk7XHJcbiAgICAgICAgX2dsLmN1bGxGYWNlKCBzY29wZS5jdWxsRmFjZSA9PT0gVEhSRUUuQ3VsbEZhY2VGcm9udCA/IF9nbC5GUk9OVCA6IF9nbC5CQUNLICk7XHJcbiAgICAgICAgX3N0YXRlLnNldERlcHRoVGVzdCggdHJ1ZSApO1xyXG5cclxuICAgICAgICAvLyBzYXZlIHRoZSBleGlzdGluZyB2aWV3cG9ydCBzbyBpdCBjYW4gYmUgcmVzdG9yZWQgbGF0ZXJcclxuICAgICAgICBfcmVuZGVyZXIuZ2V0Vmlld3BvcnQoIF92ZWN0b3I0ICk7XHJcblxyXG4gICAgICAgIC8vIHJlbmRlciBkZXB0aCBtYXBcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IF9saWdodHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbGlnaHQgPSBfbGlnaHRzWyBpIF07XHJcblxyXG4gICAgICAgICAgICBpZiAoIGxpZ2h0LmNhc3RTaGFkb3cgPT09IHRydWUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHNoYWRvdyA9IGxpZ2h0LnNoYWRvdztcclxuICAgICAgICAgICAgICAgIHZhciBzaGFkb3dDYW1lcmEgPSBzaGFkb3cuY2FtZXJhO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNoYWRvd01hcFNpemUgPSBzaGFkb3cubWFwU2l6ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZmFjZUNvdW50ID0gNjtcclxuICAgICAgICAgICAgICAgICAgICBpc1BvaW50TGlnaHQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdnBXaWR0aCA9IHNoYWRvd01hcFNpemUueCAvIDQuMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdnBIZWlnaHQgPSBzaGFkb3dNYXBTaXplLnkgLyAyLjA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIHZpZXdwb3J0cyBtYXAgYSBjdWJlLW1hcCBvbnRvIGEgMkQgdGV4dHVyZSB3aXRoIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvbGxvd2luZyBvcmllbnRhdGlvbjpcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICB4elhaXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICB5IFlcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFggLSBQb3NpdGl2ZSB4IGRpcmVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHggLSBOZWdhdGl2ZSB4IGRpcmVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFkgLSBQb3NpdGl2ZSB5IGRpcmVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHkgLSBOZWdhdGl2ZSB5IGRpcmVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFogLSBQb3NpdGl2ZSB6IGRpcmVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHogLSBOZWdhdGl2ZSB6IGRpcmVjdGlvblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBwb3NpdGl2ZSBYXHJcbiAgICAgICAgICAgICAgICAgICAgY3ViZTJEVmlld1BvcnRzWyAwIF0uc2V0KCB2cFdpZHRoICogMiwgdnBIZWlnaHQsIHZwV2lkdGgsIHZwSGVpZ2h0ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVnYXRpdmUgWFxyXG4gICAgICAgICAgICAgICAgICAgIGN1YmUyRFZpZXdQb3J0c1sgMSBdLnNldCggMCwgdnBIZWlnaHQsIHZwV2lkdGgsIHZwSGVpZ2h0ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcG9zaXRpdmUgWlxyXG4gICAgICAgICAgICAgICAgICAgIGN1YmUyRFZpZXdQb3J0c1sgMiBdLnNldCggdnBXaWR0aCAqIDMsIHZwSGVpZ2h0LCB2cFdpZHRoLCB2cEhlaWdodCApO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZ2F0aXZlIFpcclxuICAgICAgICAgICAgICAgICAgICBjdWJlMkRWaWV3UG9ydHNbIDMgXS5zZXQoIHZwV2lkdGgsIHZwSGVpZ2h0LCB2cFdpZHRoLCB2cEhlaWdodCApO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHBvc2l0aXZlIFlcclxuICAgICAgICAgICAgICAgICAgICBjdWJlMkRWaWV3UG9ydHNbIDQgXS5zZXQoIHZwV2lkdGggKiAzLCAwLCB2cFdpZHRoLCB2cEhlaWdodCApO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZ2F0aXZlIFlcclxuICAgICAgICAgICAgICAgICAgICBjdWJlMkRWaWV3UG9ydHNbIDUgXS5zZXQoIHZwV2lkdGgsIDAsIHZwV2lkdGgsIHZwSGVpZ2h0ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZmFjZUNvdW50ID0gMTtcclxuICAgICAgICAgICAgICAgICAgICBpc1BvaW50TGlnaHQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBzaGFkb3cubWFwID09PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2hhZG93RmlsdGVyID0gVEhSRUUuTGluZWFyRmlsdGVyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHNjb3BlLnR5cGUgPT09IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFkb3dGaWx0ZXIgPSBUSFJFRS5OZWFyZXN0RmlsdGVyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJzID0geyBtaW5GaWx0ZXI6IHNoYWRvd0ZpbHRlciwgbWFnRmlsdGVyOiBzaGFkb3dGaWx0ZXIsIGZvcm1hdDogVEhSRUUuUkdCQUZvcm1hdCB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzaGFkb3cubWFwID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0KCBzaGFkb3dNYXBTaXplLngsIHNoYWRvd01hcFNpemUueSwgcGFycyApO1xyXG4gICAgICAgICAgICAgICAgICAgIHNoYWRvdy5tYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuU3BvdExpZ2h0ICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93Q2FtZXJhLmFzcGVjdCA9IHNoYWRvd01hcFNpemUueCAvIHNoYWRvd01hcFNpemUueTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBzaGFkb3dDYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2hhZG93TWFwID0gc2hhZG93Lm1hcDtcclxuICAgICAgICAgICAgICAgIHZhciBzaGFkb3dNYXRyaXggPSBzaGFkb3cubWF0cml4O1xyXG5cclxuICAgICAgICAgICAgICAgIF9saWdodFBvc2l0aW9uV29ybGQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xyXG4gICAgICAgICAgICAgICAgc2hhZG93Q2FtZXJhLnBvc2l0aW9uLmNvcHkoIF9saWdodFBvc2l0aW9uV29ybGQgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBfcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBzaGFkb3dNYXAgKTtcclxuICAgICAgICAgICAgICAgIF9yZW5kZXJlci5jbGVhcigpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHJlbmRlciBzaGFkb3cgbWFwIGZvciBlYWNoIGN1YmUgZmFjZSAoaWYgb21uaS1kaXJlY3Rpb25hbCkgb3JcclxuICAgICAgICAgICAgICAgIC8vIHJ1biBhIHNpbmdsZSBwYXNzIGlmIG5vdFxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBmYWNlID0gMDsgZmFjZSA8IGZhY2VDb3VudDsgZmFjZSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpc1BvaW50TGlnaHQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbG9va1RhcmdldC5jb3B5KCBzaGFkb3dDYW1lcmEucG9zaXRpb24gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xvb2tUYXJnZXQuYWRkKCBjdWJlRGlyZWN0aW9uc1sgZmFjZSBdICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRvd0NhbWVyYS51cC5jb3B5KCBjdWJlVXBzWyBmYWNlIF0gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93Q2FtZXJhLmxvb2tBdCggX2xvb2tUYXJnZXQgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZwRGltZW5zaW9ucyA9IGN1YmUyRFZpZXdQb3J0c1sgZmFjZSBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVuZGVyZXIuc2V0Vmlld3BvcnQoIHZwRGltZW5zaW9ucy54LCB2cERpbWVuc2lvbnMueSwgdnBEaW1lbnNpb25zLnosIHZwRGltZW5zaW9ucy53ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbG9va1RhcmdldC5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFkb3dDYW1lcmEubG9va0F0KCBfbG9va1RhcmdldCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNoYWRvd0NhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UuZ2V0SW52ZXJzZSggc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXB1dGUgc2hhZG93IG1hdHJpeFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBzaGFkb3dNYXRyaXguc2V0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAwLjUsIDAuMCwgMC4wLCAwLjUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDAuMCwgMC41LCAwLjAsIDAuNSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgMC4wLCAwLjAsIDAuNSwgMC41LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAwLjAsIDAuMCwgMC4wLCAxLjBcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzaGFkb3dNYXRyaXgubXVsdGlwbHkoIHNoYWRvd0NhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hhZG93TWF0cml4Lm11bHRpcGx5KCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBjYW1lcmEgbWF0cmljZXMgYW5kIGZydXN0dW1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX3Byb2pTY3JlZW5NYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggc2hhZG93Q2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcclxuICAgICAgICAgICAgICAgICAgICBfZnJ1c3R1bS5zZXRGcm9tTWF0cml4KCBfcHJvalNjcmVlbk1hdHJpeCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgb2JqZWN0IG1hdHJpY2VzICYgZnJ1c3R1bSBjdWxsaW5nXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9yZW5kZXJMaXN0Lmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHByb2plY3RPYmplY3QoIHNjZW5lLCBzaGFkb3dDYW1lcmEgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVuZGVyIHNoYWRvdyBtYXBcclxuICAgICAgICAgICAgICAgICAgICAvLyByZW5kZXIgcmVndWxhciBvYmplY3RzXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBfcmVuZGVyTGlzdC5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmplY3QgPSBfcmVuZGVyTGlzdFsgaiBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSBfb2JqZWN0cy51cGRhdGUoIG9iamVjdCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaEZhY2VNYXRlcmlhbCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGVyaWFscyA9IG1hdGVyaWFsLm1hdGVyaWFscztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgayA9IDAsIGtsID0gZ3JvdXBzLmxlbmd0aDsgayA8IGtsOyBrICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNbIGsgXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsc1sgZ3JvdXAubWF0ZXJpYWxJbmRleCBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGdyb3VwTWF0ZXJpYWwudmlzaWJsZSA9PT0gdHJ1ZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZXB0aE1hdGVyaWFsID0gZ2V0RGVwdGhNYXRlcmlhbCggb2JqZWN0LCBncm91cE1hdGVyaWFsLCBpc1BvaW50TGlnaHQsIF9saWdodFBvc2l0aW9uV29ybGQgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlbmRlcmVyLnJlbmRlckJ1ZmZlckRpcmVjdCggc2hhZG93Q2FtZXJhLCBfbGlnaHRzLCBudWxsLCBnZW9tZXRyeSwgZGVwdGhNYXRlcmlhbCwgb2JqZWN0LCBncm91cCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVwdGhNYXRlcmlhbCA9IGdldERlcHRoTWF0ZXJpYWwoIG9iamVjdCwgbWF0ZXJpYWwsIGlzUG9pbnRMaWdodCwgX2xpZ2h0UG9zaXRpb25Xb3JsZCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlbmRlcmVyLnJlbmRlckJ1ZmZlckRpcmVjdCggc2hhZG93Q2FtZXJhLCBfbGlnaHRzLCBudWxsLCBnZW9tZXRyeSwgZGVwdGhNYXRlcmlhbCwgb2JqZWN0LCBudWxsICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gV2UgbXVzdCBjYWxsIF9yZW5kZXJlci5yZXNldEdMU3RhdGUoKSBhdCB0aGUgZW5kIG9mIGVhY2ggaXRlcmF0aW9uIG9mXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgbGlnaHQgbG9vcCBpbiBvcmRlciB0byBmb3JjZSBtYXRlcmlhbCB1cGRhdGVzIGZvciBlYWNoIGxpZ2h0LlxyXG4gICAgICAgICAgICAgICAgX3JlbmRlcmVyLnJlc2V0R0xTdGF0ZSgpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF9yZW5kZXJlci5zZXRWaWV3cG9ydCggX3ZlY3RvcjQueCwgX3ZlY3RvcjQueSwgX3ZlY3RvcjQueiwgX3ZlY3RvcjQudyApO1xyXG5cclxuICAgICAgICAvLyBSZXN0b3JlIEdMIHN0YXRlLlxyXG4gICAgICAgIHZhciBjbGVhckNvbG9yID0gX3JlbmRlcmVyLmdldENsZWFyQ29sb3IoKSxcclxuICAgICAgICAgICAgY2xlYXJBbHBoYSA9IF9yZW5kZXJlci5nZXRDbGVhckFscGhhKCk7XHJcbiAgICAgICAgX3JlbmRlcmVyLnNldENsZWFyQ29sb3IoIGNsZWFyQ29sb3IsIGNsZWFyQWxwaGEgKTtcclxuICAgICAgICBfc3RhdGUuZW5hYmxlKCBfZ2wuQkxFTkQgKTtcclxuXHJcbiAgICAgICAgaWYgKCBzY29wZS5jdWxsRmFjZSA9PT0gVEhSRUUuQ3VsbEZhY2VGcm9udCApIHtcclxuXHJcbiAgICAgICAgICAgIF9nbC5jdWxsRmFjZSggX2dsLkJBQ0sgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBfcmVuZGVyZXIucmVzZXRHTFN0YXRlKCk7XHJcblxyXG4gICAgICAgIHNjb3BlLm5lZWRzVXBkYXRlID0gZmFsc2U7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBnZXREZXB0aE1hdGVyaWFsKCBvYmplY3QsIG1hdGVyaWFsLCBpc1BvaW50TGlnaHQsIGxpZ2h0UG9zaXRpb25Xb3JsZCApIHtcclxuXHJcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuICAgICAgICB2YXIgbmV3TWF0ZXJpYWwgPSBudWxsO1xyXG5cclxuICAgICAgICB2YXIgbWF0ZXJpYWxWYXJpYW50cyA9IF9kZXB0aE1hdGVyaWFscztcclxuICAgICAgICB2YXIgY3VzdG9tTWF0ZXJpYWwgPSBvYmplY3QuY3VzdG9tRGVwdGhNYXRlcmlhbDtcclxuXHJcbiAgICAgICAgaWYgKCBpc1BvaW50TGlnaHQgKSB7XHJcblxyXG4gICAgICAgICAgICBtYXRlcmlhbFZhcmlhbnRzID0gX2Rpc3RhbmNlTWF0ZXJpYWxzO1xyXG4gICAgICAgICAgICBjdXN0b21NYXRlcmlhbCA9IG9iamVjdC5jdXN0b21EaXN0YW5jZU1hdGVyaWFsO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggISBjdXN0b21NYXRlcmlhbCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciB1c2VNb3JwaGluZyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoID4gMCAmJiBtYXRlcmlhbC5tb3JwaFRhcmdldHM7XHJcblxyXG4gICAgICAgICAgICB2YXIgdXNlU2tpbm5pbmcgPSBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Ta2lubmVkTWVzaCAmJiBtYXRlcmlhbC5za2lubmluZztcclxuXHJcbiAgICAgICAgICAgIHZhciB2YXJpYW50SW5kZXggPSAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKCB1c2VNb3JwaGluZyApIHZhcmlhbnRJbmRleCB8PSBfTW9ycGhpbmdGbGFnO1xyXG4gICAgICAgICAgICBpZiAoIHVzZVNraW5uaW5nICkgdmFyaWFudEluZGV4IHw9IF9Ta2lubmluZ0ZsYWc7XHJcblxyXG4gICAgICAgICAgICBuZXdNYXRlcmlhbCA9IG1hdGVyaWFsVmFyaWFudHNbIHZhcmlhbnRJbmRleCBdO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgbmV3TWF0ZXJpYWwgPSBjdXN0b21NYXRlcmlhbDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBuZXdNYXRlcmlhbC52aXNpYmxlID0gbWF0ZXJpYWwudmlzaWJsZTtcclxuICAgICAgICBuZXdNYXRlcmlhbC53aXJlZnJhbWUgPSBtYXRlcmlhbC53aXJlZnJhbWU7XHJcbiAgICAgICAgbmV3TWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoID0gbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoO1xyXG5cclxuICAgICAgICBpZiAoIGlzUG9pbnRMaWdodCAmJiBuZXdNYXRlcmlhbC51bmlmb3Jtcy5saWdodFBvcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgbmV3TWF0ZXJpYWwudW5pZm9ybXMubGlnaHRQb3MudmFsdWUuY29weSggbGlnaHRQb3NpdGlvbldvcmxkICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5ld01hdGVyaWFsO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwcm9qZWN0T2JqZWN0KCBvYmplY3QsIGNhbWVyYSApIHtcclxuXHJcbiAgICAgICAgaWYgKCBvYmplY3QudmlzaWJsZSA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG4gICAgICAgIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCB8fCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lIHx8IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50cyApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggb2JqZWN0LmNhc3RTaGFkb3cgJiYgKCBvYmplY3QuZnJ1c3R1bUN1bGxlZCA9PT0gZmFsc2UgfHwgX2ZydXN0dW0uaW50ZXJzZWN0c09iamVjdCggb2JqZWN0ICkgPT09IHRydWUgKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBtYXRlcmlhbC52aXNpYmxlID09PSB0cnVlICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBvYmplY3QubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIG9iamVjdC5tYXRyaXhXb3JsZCApO1xyXG4gICAgICAgICAgICAgICAgICAgIF9yZW5kZXJMaXN0LnB1c2goIG9iamVjdCApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICBwcm9qZWN0T2JqZWN0KCBjaGlsZHJlblsgaSBdLCBjYW1lcmEgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xTdGF0ZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuV2ViR0xTdGF0ZSA9IGZ1bmN0aW9uICggZ2wsIGV4dGVuc2lvbnMsIHBhcmFtVGhyZWVUb0dMICkge1xyXG5cclxuICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblxyXG4gICAgdmFyIG5ld0F0dHJpYnV0ZXMgPSBuZXcgVWludDhBcnJheSggMTYgKTtcclxuICAgIHZhciBlbmFibGVkQXR0cmlidXRlcyA9IG5ldyBVaW50OEFycmF5KCAxNiApO1xyXG4gICAgdmFyIGF0dHJpYnV0ZURpdmlzb3JzID0gbmV3IFVpbnQ4QXJyYXkoIDE2ICk7XHJcblxyXG4gICAgdmFyIGNhcGFiaWxpdGllcyA9IHt9O1xyXG5cclxuICAgIHZhciBjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgPSBudWxsO1xyXG5cclxuICAgIHZhciBjdXJyZW50QmxlbmRpbmcgPSBudWxsO1xyXG4gICAgdmFyIGN1cnJlbnRCbGVuZEVxdWF0aW9uID0gbnVsbDtcclxuICAgIHZhciBjdXJyZW50QmxlbmRTcmMgPSBudWxsO1xyXG4gICAgdmFyIGN1cnJlbnRCbGVuZERzdCA9IG51bGw7XHJcbiAgICB2YXIgY3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSA9IG51bGw7XHJcbiAgICB2YXIgY3VycmVudEJsZW5kU3JjQWxwaGEgPSBudWxsO1xyXG4gICAgdmFyIGN1cnJlbnRCbGVuZERzdEFscGhhID0gbnVsbDtcclxuXHJcbiAgICB2YXIgY3VycmVudERlcHRoRnVuYyA9IG51bGw7XHJcbiAgICB2YXIgY3VycmVudERlcHRoV3JpdGUgPSBudWxsO1xyXG5cclxuICAgIHZhciBjdXJyZW50Q29sb3JXcml0ZSA9IG51bGw7XHJcblxyXG4gICAgdmFyIGN1cnJlbnRGbGlwU2lkZWQgPSBudWxsO1xyXG5cclxuICAgIHZhciBjdXJyZW50TGluZVdpZHRoID0gbnVsbDtcclxuXHJcbiAgICB2YXIgY3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgPSBudWxsO1xyXG4gICAgdmFyIGN1cnJlbnRQb2x5Z29uT2Zmc2V0VW5pdHMgPSBudWxsO1xyXG5cclxuICAgIHZhciBtYXhUZXh0dXJlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcclxuXHJcbiAgICB2YXIgY3VycmVudFRleHR1cmVTbG90ID0gdW5kZWZpbmVkO1xyXG4gICAgdmFyIGN1cnJlbnRCb3VuZFRleHR1cmVzID0ge307XHJcblxyXG4gICAgdGhpcy5pbml0ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICBnbC5jbGVhckNvbG9yKCAwLCAwLCAwLCAxICk7XHJcbiAgICAgICAgZ2wuY2xlYXJEZXB0aCggMSApO1xyXG4gICAgICAgIGdsLmNsZWFyU3RlbmNpbCggMCApO1xyXG5cclxuICAgICAgICB0aGlzLmVuYWJsZSggZ2wuREVQVEhfVEVTVCApO1xyXG4gICAgICAgIGdsLmRlcHRoRnVuYyggZ2wuTEVRVUFMICk7XHJcblxyXG4gICAgICAgIGdsLmZyb250RmFjZSggZ2wuQ0NXICk7XHJcbiAgICAgICAgZ2wuY3VsbEZhY2UoIGdsLkJBQ0sgKTtcclxuICAgICAgICB0aGlzLmVuYWJsZSggZ2wuQ1VMTF9GQUNFICk7XHJcblxyXG4gICAgICAgIHRoaXMuZW5hYmxlKCBnbC5CTEVORCApO1xyXG4gICAgICAgIGdsLmJsZW5kRXF1YXRpb24oIGdsLkZVTkNfQUREICk7XHJcbiAgICAgICAgZ2wuYmxlbmRGdW5jKCBnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuaW5pdEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IG5ld0F0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIG5ld0F0dHJpYnV0ZXNbIGkgXSA9IDA7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZW5hYmxlQXR0cmlidXRlID0gZnVuY3Rpb24gKCBhdHRyaWJ1dGUgKSB7XHJcblxyXG4gICAgICAgIG5ld0F0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID0gMTtcclxuXHJcbiAgICAgICAgaWYgKCBlbmFibGVkQXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPT09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSggYXR0cmlidXRlICk7XHJcbiAgICAgICAgICAgIGVuYWJsZWRBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9IDE7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBhdHRyaWJ1dGVEaXZpc29yc1sgYXR0cmlidXRlIF0gIT09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xyXG5cclxuICAgICAgICAgICAgZXh0ZW5zaW9uLnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRSggYXR0cmlidXRlLCAwICk7XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZURpdmlzb3JzWyBhdHRyaWJ1dGUgXSA9IDA7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvciA9IGZ1bmN0aW9uICggYXR0cmlidXRlLCBtZXNoUGVyQXR0cmlidXRlLCBleHRlbnNpb24gKSB7XHJcblxyXG4gICAgICAgIG5ld0F0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID0gMTtcclxuXHJcbiAgICAgICAgaWYgKCBlbmFibGVkQXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPT09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSggYXR0cmlidXRlICk7XHJcbiAgICAgICAgICAgIGVuYWJsZWRBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9IDE7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBhdHRyaWJ1dGVEaXZpc29yc1sgYXR0cmlidXRlIF0gIT09IG1lc2hQZXJBdHRyaWJ1dGUgKSB7XHJcblxyXG4gICAgICAgICAgICBleHRlbnNpb24udmVydGV4QXR0cmliRGl2aXNvckFOR0xFKCBhdHRyaWJ1dGUsIG1lc2hQZXJBdHRyaWJ1dGUgKTtcclxuICAgICAgICAgICAgYXR0cmlidXRlRGl2aXNvcnNbIGF0dHJpYnV0ZSBdID0gbWVzaFBlckF0dHJpYnV0ZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5kaXNhYmxlVW51c2VkQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gZW5hYmxlZEF0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggZW5hYmxlZEF0dHJpYnV0ZXNbIGkgXSAhPT0gbmV3QXR0cmlidXRlc1sgaSBdICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSggaSApO1xyXG4gICAgICAgICAgICAgICAgZW5hYmxlZEF0dHJpYnV0ZXNbIGkgXSA9IDA7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZW5hYmxlID0gZnVuY3Rpb24gKCBpZCApIHtcclxuXHJcbiAgICAgICAgaWYgKCBjYXBhYmlsaXRpZXNbIGlkIF0gIT09IHRydWUgKSB7XHJcblxyXG4gICAgICAgICAgICBnbC5lbmFibGUoIGlkICk7XHJcbiAgICAgICAgICAgIGNhcGFiaWxpdGllc1sgaWQgXSA9IHRydWU7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZGlzYWJsZSA9IGZ1bmN0aW9uICggaWQgKSB7XHJcblxyXG4gICAgICAgIGlmICggY2FwYWJpbGl0aWVzWyBpZCBdICE9PSBmYWxzZSApIHtcclxuXHJcbiAgICAgICAgICAgIGdsLmRpc2FibGUoIGlkICk7XHJcbiAgICAgICAgICAgIGNhcGFiaWxpdGllc1sgaWQgXSA9IGZhbHNlO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmdldENvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgaWYgKCBjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgPT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICBjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGlmICggZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICkgfHxcclxuICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGZvcm1hdHMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLkNPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTICk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZm9ybWF0cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cy5wdXNoKCBmb3JtYXRzWyBpIF0gKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cztcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc2V0QmxlbmRpbmcgPSBmdW5jdGlvbiAoIGJsZW5kaW5nLCBibGVuZEVxdWF0aW9uLCBibGVuZFNyYywgYmxlbmREc3QsIGJsZW5kRXF1YXRpb25BbHBoYSwgYmxlbmRTcmNBbHBoYSwgYmxlbmREc3RBbHBoYSApIHtcclxuXHJcbiAgICAgICAgaWYgKCBibGVuZGluZyAhPT0gY3VycmVudEJsZW5kaW5nICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBibGVuZGluZyA9PT0gVEhSRUUuTm9CbGVuZGluZyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2FibGUoIGdsLkJMRU5EICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBibGVuZGluZyA9PT0gVEhSRUUuQWRkaXRpdmVCbGVuZGluZyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZSggZ2wuQkxFTkQgKTtcclxuICAgICAgICAgICAgICAgIGdsLmJsZW5kRXF1YXRpb24oIGdsLkZVTkNfQUREICk7XHJcbiAgICAgICAgICAgICAgICBnbC5ibGVuZEZ1bmMoIGdsLlNSQ19BTFBIQSwgZ2wuT05FICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBibGVuZGluZyA9PT0gVEhSRUUuU3VidHJhY3RpdmVCbGVuZGluZyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBGaW5kIGJsZW5kRnVuY1NlcGFyYXRlKCkgY29tYmluYXRpb25cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZSggZ2wuQkxFTkQgKTtcclxuICAgICAgICAgICAgICAgIGdsLmJsZW5kRXF1YXRpb24oIGdsLkZVTkNfQUREICk7XHJcbiAgICAgICAgICAgICAgICBnbC5ibGVuZEZ1bmMoIGdsLlpFUk8sIGdsLk9ORV9NSU5VU19TUkNfQ09MT1IgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGJsZW5kaW5nID09PSBUSFJFRS5NdWx0aXBseUJsZW5kaW5nICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IEZpbmQgYmxlbmRGdW5jU2VwYXJhdGUoKSBjb21iaW5hdGlvblxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlKCBnbC5CTEVORCApO1xyXG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRFcXVhdGlvbiggZ2wuRlVOQ19BREQgKTtcclxuICAgICAgICAgICAgICAgIGdsLmJsZW5kRnVuYyggZ2wuWkVSTywgZ2wuU1JDX0NPTE9SICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBibGVuZGluZyA9PT0gVEhSRUUuQ3VzdG9tQmxlbmRpbmcgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGUoIGdsLkJMRU5EICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlKCBnbC5CTEVORCApO1xyXG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKCBnbC5GVU5DX0FERCwgZ2wuRlVOQ19BREQgKTtcclxuICAgICAgICAgICAgICAgIGdsLmJsZW5kRnVuY1NlcGFyYXRlKCBnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY3VycmVudEJsZW5kaW5nID0gYmxlbmRpbmc7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBibGVuZGluZyA9PT0gVEhSRUUuQ3VzdG9tQmxlbmRpbmcgKSB7XHJcblxyXG4gICAgICAgICAgICBibGVuZEVxdWF0aW9uQWxwaGEgPSBibGVuZEVxdWF0aW9uQWxwaGEgfHwgYmxlbmRFcXVhdGlvbjtcclxuICAgICAgICAgICAgYmxlbmRTcmNBbHBoYSA9IGJsZW5kU3JjQWxwaGEgfHwgYmxlbmRTcmM7XHJcbiAgICAgICAgICAgIGJsZW5kRHN0QWxwaGEgPSBibGVuZERzdEFscGhhIHx8IGJsZW5kRHN0O1xyXG5cclxuICAgICAgICAgICAgaWYgKCBibGVuZEVxdWF0aW9uICE9PSBjdXJyZW50QmxlbmRFcXVhdGlvbiB8fCBibGVuZEVxdWF0aW9uQWxwaGEgIT09IGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKCBwYXJhbVRocmVlVG9HTCggYmxlbmRFcXVhdGlvbiApLCBwYXJhbVRocmVlVG9HTCggYmxlbmRFcXVhdGlvbkFscGhhICkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50QmxlbmRFcXVhdGlvbiA9IGJsZW5kRXF1YXRpb247XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhID0gYmxlbmRFcXVhdGlvbkFscGhhO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBibGVuZFNyYyAhPT0gY3VycmVudEJsZW5kU3JjIHx8IGJsZW5kRHN0ICE9PSBjdXJyZW50QmxlbmREc3QgfHwgYmxlbmRTcmNBbHBoYSAhPT0gY3VycmVudEJsZW5kU3JjQWxwaGEgfHwgYmxlbmREc3RBbHBoYSAhPT0gY3VycmVudEJsZW5kRHN0QWxwaGEgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUoIHBhcmFtVGhyZWVUb0dMKCBibGVuZFNyYyApLCBwYXJhbVRocmVlVG9HTCggYmxlbmREc3QgKSwgcGFyYW1UaHJlZVRvR0woIGJsZW5kU3JjQWxwaGEgKSwgcGFyYW1UaHJlZVRvR0woIGJsZW5kRHN0QWxwaGEgKSApO1xyXG5cclxuICAgICAgICAgICAgICAgIGN1cnJlbnRCbGVuZFNyYyA9IGJsZW5kU3JjO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEJsZW5kRHN0ID0gYmxlbmREc3Q7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50QmxlbmRTcmNBbHBoYSA9IGJsZW5kU3JjQWxwaGE7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50QmxlbmREc3RBbHBoYSA9IGJsZW5kRHN0QWxwaGE7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICBjdXJyZW50QmxlbmRFcXVhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgIGN1cnJlbnRCbGVuZFNyYyA9IG51bGw7XHJcbiAgICAgICAgICAgIGN1cnJlbnRCbGVuZERzdCA9IG51bGw7XHJcbiAgICAgICAgICAgIGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBudWxsO1xyXG4gICAgICAgICAgICBjdXJyZW50QmxlbmRTcmNBbHBoYSA9IG51bGw7XHJcbiAgICAgICAgICAgIGN1cnJlbnRCbGVuZERzdEFscGhhID0gbnVsbDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zZXREZXB0aEZ1bmMgPSBmdW5jdGlvbiAoIGRlcHRoRnVuYyApIHtcclxuXHJcbiAgICAgICAgaWYgKCBjdXJyZW50RGVwdGhGdW5jICE9PSBkZXB0aEZ1bmMgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGRlcHRoRnVuYyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKCBkZXB0aEZ1bmMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuTmV2ZXJEZXB0aDpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmRlcHRoRnVuYyggZ2wuTkVWRVIgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuQWx3YXlzRGVwdGg6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5kZXB0aEZ1bmMoIGdsLkFMV0FZUyApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5MZXNzRGVwdGg6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5kZXB0aEZ1bmMoIGdsLkxFU1MgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuTGVzc0VxdWFsRGVwdGg6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5kZXB0aEZ1bmMoIGdsLkxFUVVBTCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5FcXVhbERlcHRoOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKCBnbC5FUVVBTCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5HcmVhdGVyRXF1YWxEZXB0aDpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmRlcHRoRnVuYyggZ2wuR0VRVUFMICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLkdyZWF0ZXJEZXB0aDpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmRlcHRoRnVuYyggZ2wuR1JFQVRFUiApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5Ob3RFcXVhbERlcHRoOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKCBnbC5OT1RFUVVBTCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmRlcHRoRnVuYyggZ2wuTEVRVUFMICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC5kZXB0aEZ1bmMoIGdsLkxFUVVBTCApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY3VycmVudERlcHRoRnVuYyA9IGRlcHRoRnVuYztcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zZXREZXB0aFRlc3QgPSBmdW5jdGlvbiAoIGRlcHRoVGVzdCApIHtcclxuXHJcbiAgICAgICAgaWYgKCBkZXB0aFRlc3QgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmVuYWJsZSggZ2wuREVQVEhfVEVTVCApO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5kaXNhYmxlKCBnbC5ERVBUSF9URVNUICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc2V0RGVwdGhXcml0ZSA9IGZ1bmN0aW9uICggZGVwdGhXcml0ZSApIHtcclxuXHJcbiAgICAgICAgaWYgKCBjdXJyZW50RGVwdGhXcml0ZSAhPT0gZGVwdGhXcml0ZSApIHtcclxuXHJcbiAgICAgICAgICAgIGdsLmRlcHRoTWFzayggZGVwdGhXcml0ZSApO1xyXG4gICAgICAgICAgICBjdXJyZW50RGVwdGhXcml0ZSA9IGRlcHRoV3JpdGU7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc2V0Q29sb3JXcml0ZSA9IGZ1bmN0aW9uICggY29sb3JXcml0ZSApIHtcclxuXHJcbiAgICAgICAgaWYgKCBjdXJyZW50Q29sb3JXcml0ZSAhPT0gY29sb3JXcml0ZSApIHtcclxuXHJcbiAgICAgICAgICAgIGdsLmNvbG9yTWFzayggY29sb3JXcml0ZSwgY29sb3JXcml0ZSwgY29sb3JXcml0ZSwgY29sb3JXcml0ZSApO1xyXG4gICAgICAgICAgICBjdXJyZW50Q29sb3JXcml0ZSA9IGNvbG9yV3JpdGU7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc2V0RmxpcFNpZGVkID0gZnVuY3Rpb24gKCBmbGlwU2lkZWQgKSB7XHJcblxyXG4gICAgICAgIGlmICggY3VycmVudEZsaXBTaWRlZCAhPT0gZmxpcFNpZGVkICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBmbGlwU2lkZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZ2wuZnJvbnRGYWNlKCBnbC5DVyApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC5mcm9udEZhY2UoIGdsLkNDVyApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY3VycmVudEZsaXBTaWRlZCA9IGZsaXBTaWRlZDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zZXRMaW5lV2lkdGggPSBmdW5jdGlvbiAoIHdpZHRoICkge1xyXG5cclxuICAgICAgICBpZiAoIHdpZHRoICE9PSBjdXJyZW50TGluZVdpZHRoICkge1xyXG5cclxuICAgICAgICAgICAgZ2wubGluZVdpZHRoKCB3aWR0aCApO1xyXG5cclxuICAgICAgICAgICAgY3VycmVudExpbmVXaWR0aCA9IHdpZHRoO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnNldFBvbHlnb25PZmZzZXQgPSBmdW5jdGlvbiAoIHBvbHlnb25PZmZzZXQsIGZhY3RvciwgdW5pdHMgKSB7XHJcblxyXG4gICAgICAgIGlmICggcG9seWdvbk9mZnNldCApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlKCBnbC5QT0xZR09OX09GRlNFVF9GSUxMICk7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRpc2FibGUoIGdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIHBvbHlnb25PZmZzZXQgJiYgKCBjdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciAhPT0gZmFjdG9yIHx8IGN1cnJlbnRQb2x5Z29uT2Zmc2V0VW5pdHMgIT09IHVuaXRzICkgKSB7XHJcblxyXG4gICAgICAgICAgICBnbC5wb2x5Z29uT2Zmc2V0KCBmYWN0b3IsIHVuaXRzICk7XHJcblxyXG4gICAgICAgICAgICBjdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciA9IGZhY3RvcjtcclxuICAgICAgICAgICAgY3VycmVudFBvbHlnb25PZmZzZXRVbml0cyA9IHVuaXRzO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnNldFNjaXNzb3JUZXN0ID0gZnVuY3Rpb24gKCBzY2lzc29yVGVzdCApIHtcclxuXHJcbiAgICAgICAgaWYgKCBzY2lzc29yVGVzdCApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlKCBnbC5TQ0lTU09SX1RFU1QgKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZSggZ2wuU0NJU1NPUl9URVNUICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIHRleHR1cmVcclxuXHJcbiAgICB0aGlzLmFjdGl2ZVRleHR1cmUgPSBmdW5jdGlvbiAoIHdlYmdsU2xvdCApIHtcclxuXHJcbiAgICAgICAgaWYgKCB3ZWJnbFNsb3QgPT09IHVuZGVmaW5lZCApIHdlYmdsU2xvdCA9IGdsLlRFWFRVUkUwICsgbWF4VGV4dHVyZXMgLSAxO1xyXG5cclxuICAgICAgICBpZiAoIGN1cnJlbnRUZXh0dXJlU2xvdCAhPT0gd2ViZ2xTbG90ICkge1xyXG5cclxuICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZSggd2ViZ2xTbG90ICk7XHJcbiAgICAgICAgICAgIGN1cnJlbnRUZXh0dXJlU2xvdCA9IHdlYmdsU2xvdDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmJpbmRUZXh0dXJlID0gZnVuY3Rpb24gKCB3ZWJnbFR5cGUsIHdlYmdsVGV4dHVyZSApIHtcclxuXHJcbiAgICAgICAgaWYgKCBjdXJyZW50VGV4dHVyZVNsb3QgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIF90aGlzLmFjdGl2ZVRleHR1cmUoKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYm91bmRUZXh0dXJlID0gY3VycmVudEJvdW5kVGV4dHVyZXNbIGN1cnJlbnRUZXh0dXJlU2xvdCBdO1xyXG5cclxuICAgICAgICBpZiAoIGJvdW5kVGV4dHVyZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgYm91bmRUZXh0dXJlID0geyB0eXBlOiB1bmRlZmluZWQsIHRleHR1cmU6IHVuZGVmaW5lZCB9O1xyXG4gICAgICAgICAgICBjdXJyZW50Qm91bmRUZXh0dXJlc1sgY3VycmVudFRleHR1cmVTbG90IF0gPSBib3VuZFRleHR1cmU7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBib3VuZFRleHR1cmUudHlwZSAhPT0gd2ViZ2xUeXBlIHx8IGJvdW5kVGV4dHVyZS50ZXh0dXJlICE9PSB3ZWJnbFRleHR1cmUgKSB7XHJcblxyXG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZSggd2ViZ2xUeXBlLCB3ZWJnbFRleHR1cmUgKTtcclxuXHJcbiAgICAgICAgICAgIGJvdW5kVGV4dHVyZS50eXBlID0gd2ViZ2xUeXBlO1xyXG4gICAgICAgICAgICBib3VuZFRleHR1cmUudGV4dHVyZSA9IHdlYmdsVGV4dHVyZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5jb21wcmVzc2VkVGV4SW1hZ2UyRCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuXHJcbiAgICAgICAgICAgIGdsLmNvbXByZXNzZWRUZXhJbWFnZTJELmFwcGx5KCBnbCwgYXJndW1lbnRzICk7XHJcblxyXG4gICAgICAgIH0gY2F0Y2ggKCBlcnJvciApIHtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoIGVycm9yICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMudGV4SW1hZ2UyRCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuXHJcbiAgICAgICAgICAgIGdsLnRleEltYWdlMkQuYXBwbHkoIGdsLCBhcmd1bWVudHMgKTtcclxuXHJcbiAgICAgICAgfSBjYXRjaCAoIGVycm9yICkge1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggZXJyb3IgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLy9cclxuXHJcbiAgICB0aGlzLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbmFibGVkQXR0cmlidXRlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPT09IDEgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KCBpICk7XHJcbiAgICAgICAgICAgICAgICBlbmFibGVkQXR0cmlidXRlc1sgaSBdID0gMDtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjYXBhYmlsaXRpZXMgPSB7fTtcclxuXHJcbiAgICAgICAgY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID0gbnVsbDtcclxuXHJcbiAgICAgICAgY3VycmVudEJsZW5kaW5nID0gbnVsbDtcclxuXHJcbiAgICAgICAgY3VycmVudERlcHRoV3JpdGUgPSBudWxsO1xyXG4gICAgICAgIGN1cnJlbnRDb2xvcldyaXRlID0gbnVsbDtcclxuXHJcbiAgICAgICAgY3VycmVudEZsaXBTaWRlZCA9IG51bGw7XHJcblxyXG4gICAgfTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvcGx1Z2lucy9MZW5zRmxhcmVQbHVnaW4uanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkxlbnNGbGFyZVBsdWdpbiA9IGZ1bmN0aW9uICggcmVuZGVyZXIsIGZsYXJlcyApIHtcclxuXHJcbiAgICB2YXIgZ2wgPSByZW5kZXJlci5jb250ZXh0O1xyXG4gICAgdmFyIHN0YXRlID0gcmVuZGVyZXIuc3RhdGU7XHJcblxyXG4gICAgdmFyIHZlcnRleEJ1ZmZlciwgZWxlbWVudEJ1ZmZlcjtcclxuICAgIHZhciBwcm9ncmFtLCBhdHRyaWJ1dGVzLCB1bmlmb3JtcztcclxuICAgIHZhciBoYXNWZXJ0ZXhUZXh0dXJlO1xyXG5cclxuICAgIHZhciB0ZW1wVGV4dHVyZSwgb2NjbHVzaW9uVGV4dHVyZTtcclxuXHJcbiAgICBmdW5jdGlvbiBpbml0KCkge1xyXG5cclxuICAgICAgICB2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXHJcbiAgICAgICAgICAgIC0gMSwgLSAxLCAgMCwgMCxcclxuICAgICAgICAgICAgMSwgLSAxLCAgMSwgMCxcclxuICAgICAgICAgICAgMSwgIDEsICAxLCAxLFxyXG4gICAgICAgICAgICAtIDEsICAxLCAgMCwgMVxyXG4gICAgICAgIF0gKTtcclxuXHJcbiAgICAgICAgdmFyIGZhY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbXHJcbiAgICAgICAgICAgIDAsIDEsIDIsXHJcbiAgICAgICAgICAgIDAsIDIsIDNcclxuICAgICAgICBdICk7XHJcblxyXG4gICAgICAgIC8vIGJ1ZmZlcnNcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyICAgICA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgICAgIGVsZW1lbnRCdWZmZXIgICAgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuXHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIgKTtcclxuICAgICAgICBnbC5idWZmZXJEYXRhKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRpY2VzLCBnbC5TVEFUSUNfRFJBVyApO1xyXG5cclxuICAgICAgICBnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZWxlbWVudEJ1ZmZlciApO1xyXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBmYWNlcywgZ2wuU1RBVElDX0RSQVcgKTtcclxuXHJcbiAgICAgICAgLy8gdGV4dHVyZXNcclxuXHJcbiAgICAgICAgdGVtcFRleHR1cmUgICAgICA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcclxuICAgICAgICBvY2NsdXNpb25UZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG5cclxuICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgdGVtcFRleHR1cmUgKTtcclxuICAgICAgICBnbC50ZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0IsIDE2LCAxNiwgMCwgZ2wuUkdCLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsICk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UgKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSApO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xyXG5cclxuICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgb2NjbHVzaW9uVGV4dHVyZSApO1xyXG4gICAgICAgIGdsLnRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIDE2LCAxNiwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCApO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFICk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UgKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QgKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QgKTtcclxuXHJcbiAgICAgICAgaGFzVmVydGV4VGV4dHVyZSA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9URVhUVVJFX0lNQUdFX1VOSVRTICkgPiAwO1xyXG5cclxuICAgICAgICB2YXIgc2hhZGVyO1xyXG5cclxuICAgICAgICBpZiAoIGhhc1ZlcnRleFRleHR1cmUgKSB7XHJcblxyXG4gICAgICAgICAgICBzaGFkZXIgPSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmVydGV4U2hhZGVyOiBbXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSBsb3dwIGludCByZW5kZXJUeXBlO1wiLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcInVuaWZvcm0gdmVjMyBzY3JlZW5Qb3NpdGlvbjtcIixcclxuICAgICAgICAgICAgICAgICAgICBcInVuaWZvcm0gdmVjMiBzY2FsZTtcIixcclxuICAgICAgICAgICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgcm90YXRpb247XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSBzYW1wbGVyMkQgb2NjbHVzaW9uTWFwO1wiLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcImF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiYXR0cmlidXRlIHZlYzIgdXY7XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwidmFyeWluZyB2ZWMyIHZVVjtcIixcclxuICAgICAgICAgICAgICAgICAgICBcInZhcnlpbmcgZmxvYXQgdlZpc2liaWxpdHk7XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcInZVViA9IHV2O1wiLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcInZlYzIgcG9zID0gcG9zaXRpb247XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwiaWYgKCByZW5kZXJUeXBlID09IDIgKSB7XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwidmVjNCB2aXNpYmlsaXR5ID0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC4xICkgKTtcIixcclxuICAgICAgICAgICAgICAgICAgICBcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC4xICkgKTtcIixcclxuICAgICAgICAgICAgICAgICAgICBcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC4xICkgKTtcIixcclxuICAgICAgICAgICAgICAgICAgICBcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC41ICkgKTtcIixcclxuICAgICAgICAgICAgICAgICAgICBcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC45ICkgKTtcIixcclxuICAgICAgICAgICAgICAgICAgICBcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC45ICkgKTtcIixcclxuICAgICAgICAgICAgICAgICAgICBcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC45ICkgKTtcIixcclxuICAgICAgICAgICAgICAgICAgICBcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC41ICkgKTtcIixcclxuICAgICAgICAgICAgICAgICAgICBcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC41ICkgKTtcIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ2VmlzaWJpbGl0eSA9ICAgICAgICB2aXNpYmlsaXR5LnIgLyA5LjA7XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ2VmlzaWJpbGl0eSAqPSAxLjAgLSB2aXNpYmlsaXR5LmcgLyA5LjA7XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ2VmlzaWJpbGl0eSAqPSAgICAgICB2aXNpYmlsaXR5LmIgLyA5LjA7XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ2VmlzaWJpbGl0eSAqPSAxLjAgLSB2aXNpYmlsaXR5LmEgLyA5LjA7XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwicG9zLnggPSBjb3MoIHJvdGF0aW9uICkgKiBwb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogcG9zaXRpb24ueTtcIixcclxuICAgICAgICAgICAgICAgICAgICBcInBvcy55ID0gc2luKCByb3RhdGlvbiApICogcG9zaXRpb24ueCArIGNvcyggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwifVwiLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcImdsX1Bvc2l0aW9uID0gdmVjNCggKCBwb3MgKiBzY2FsZSArIHNjcmVlblBvc2l0aW9uLnh5ICkueHksIHNjcmVlblBvc2l0aW9uLnosIDEuMCApO1wiLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcIn1cIlxyXG5cclxuICAgICAgICAgICAgICAgIF0uam9pbiggXCJcXG5cIiApLFxyXG5cclxuICAgICAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyOiBbXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSBsb3dwIGludCByZW5kZXJUeXBlO1wiLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcInVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcIixcclxuICAgICAgICAgICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuICAgICAgICAgICAgICAgICAgICBcInVuaWZvcm0gdmVjMyBjb2xvcjtcIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ2YXJ5aW5nIHZlYzIgdlVWO1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidmFyeWluZyBmbG9hdCB2VmlzaWJpbGl0eTtcIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHBpbmsgc3F1YXJlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwiaWYgKCByZW5kZXJUeXBlID09IDAgKSB7XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwiZ2xfRnJhZ0NvbG9yID0gdmVjNCggMS4wLCAwLjAsIDEuMCwgMC4wICk7XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc3RvcmVcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ9IGVsc2UgaWYgKCByZW5kZXJUeXBlID09IDEgKSB7XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1wiLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBmbGFyZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcIn0gZWxzZSB7XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwidmVjNCB0ZXh0dXJlID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dHVyZS5hICo9IG9wYWNpdHkgKiB2VmlzaWJpbGl0eTtcIixcclxuICAgICAgICAgICAgICAgICAgICBcImdsX0ZyYWdDb2xvciA9IHRleHR1cmU7XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJnbF9GcmFnQ29sb3IucmdiICo9IGNvbG9yO1wiLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcIn1cIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ9XCJcclxuXHJcbiAgICAgICAgICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKVxyXG5cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIHNoYWRlciA9IHtcclxuXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSB2ZWMzIHNjcmVlblBvc2l0aW9uO1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSB2ZWMyIHNjYWxlO1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCByb3RhdGlvbjtcIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjtcIixcclxuICAgICAgICAgICAgICAgICAgICBcImF0dHJpYnV0ZSB2ZWMyIHV2O1wiLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcInZhcnlpbmcgdmVjMiB2VVY7XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcInZVViA9IHV2O1wiLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcInZlYzIgcG9zID0gcG9zaXRpb247XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwiaWYgKCByZW5kZXJUeXBlID09IDIgKSB7XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwicG9zLnggPSBjb3MoIHJvdGF0aW9uICkgKiBwb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogcG9zaXRpb24ueTtcIixcclxuICAgICAgICAgICAgICAgICAgICBcInBvcy55ID0gc2luKCByb3RhdGlvbiApICogcG9zaXRpb24ueCArIGNvcyggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwifVwiLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcImdsX1Bvc2l0aW9uID0gdmVjNCggKCBwb3MgKiBzY2FsZSArIHNjcmVlblBvc2l0aW9uLnh5ICkueHksIHNjcmVlblBvc2l0aW9uLnosIDEuMCApO1wiLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcIn1cIlxyXG5cclxuICAgICAgICAgICAgICAgIF0uam9pbiggXCJcXG5cIiApLFxyXG5cclxuICAgICAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyOiBbXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwidW5pZm9ybSBsb3dwIGludCByZW5kZXJUeXBlO1wiLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcInVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcIixcclxuICAgICAgICAgICAgICAgICAgICBcInVuaWZvcm0gc2FtcGxlcjJEIG9jY2x1c2lvbk1hcDtcIixcclxuICAgICAgICAgICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuICAgICAgICAgICAgICAgICAgICBcInVuaWZvcm0gdmVjMyBjb2xvcjtcIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ2YXJ5aW5nIHZlYzIgdlVWO1wiLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcGluayBzcXVhcmVcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJpZiAoIHJlbmRlclR5cGUgPT0gMCApIHtcIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJnbF9GcmFnQ29sb3IgPSB2ZWM0KCB0ZXh0dXJlMkQoIG1hcCwgdlVWICkucmdiLCAwLjAgKTtcIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcIn0gZWxzZSBpZiAoIHJlbmRlclR5cGUgPT0gMSApIHtcIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7XCIsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZsYXJlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwifSBlbHNlIHtcIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJmbG9hdCB2aXNpYmlsaXR5ID0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC4xICkgKS5hO1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC45LCAwLjUgKSApLmE7XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuOSApICkuYTtcIixcclxuICAgICAgICAgICAgICAgICAgICBcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC41ICkgKS5hO1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidmlzaWJpbGl0eSA9ICggMS4wIC0gdmlzaWJpbGl0eSAvIDQuMCApO1wiLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcInZlYzQgdGV4dHVyZSA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTtcIixcclxuICAgICAgICAgICAgICAgICAgICBcInRleHR1cmUuYSAqPSBvcGFjaXR5ICogdmlzaWJpbGl0eTtcIixcclxuICAgICAgICAgICAgICAgICAgICBcImdsX0ZyYWdDb2xvciA9IHRleHR1cmU7XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJnbF9GcmFnQ29sb3IucmdiICo9IGNvbG9yO1wiLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcIn1cIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ9XCJcclxuXHJcbiAgICAgICAgICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKVxyXG5cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSggc2hhZGVyICk7XHJcblxyXG4gICAgICAgIGF0dHJpYnV0ZXMgPSB7XHJcbiAgICAgICAgICAgIHZlcnRleDogZ2wuZ2V0QXR0cmliTG9jYXRpb24gKCBwcm9ncmFtLCBcInBvc2l0aW9uXCIgKSxcclxuICAgICAgICAgICAgdXY6ICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbiAoIHByb2dyYW0sIFwidXZcIiApXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdW5pZm9ybXMgPSB7XHJcbiAgICAgICAgICAgIHJlbmRlclR5cGU6ICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwicmVuZGVyVHlwZVwiICksXHJcbiAgICAgICAgICAgIG1hcDogICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwibWFwXCIgKSxcclxuICAgICAgICAgICAgb2NjbHVzaW9uTWFwOiAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJvY2NsdXNpb25NYXBcIiApLFxyXG4gICAgICAgICAgICBvcGFjaXR5OiAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcIm9wYWNpdHlcIiApLFxyXG4gICAgICAgICAgICBjb2xvcjogICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcImNvbG9yXCIgKSxcclxuICAgICAgICAgICAgc2NhbGU6ICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJzY2FsZVwiICksXHJcbiAgICAgICAgICAgIHJvdGF0aW9uOiAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwicm90YXRpb25cIiApLFxyXG4gICAgICAgICAgICBzY3JlZW5Qb3NpdGlvbjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcInNjcmVlblBvc2l0aW9uXCIgKVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZW5kZXIgbGVucyBmbGFyZXNcclxuICAgICAqIE1ldGhvZDogcmVuZGVycyAxNngxNiAweGZmMDBmZi1jb2xvcmVkIHBvaW50cyBzY2F0dGVyZWQgb3ZlciB0aGUgbGlnaHQgc291cmNlIGFyZWEsXHJcbiAgICAgKiAgICAgICAgIHJlYWRzIHRoZXNlIGJhY2sgYW5kIGNhbGN1bGF0ZXMgb2NjbHVzaW9uLlxyXG4gICAgICovXHJcblxyXG4gICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEsIHZpZXdwb3J0V2lkdGgsIHZpZXdwb3J0SGVpZ2h0ICkge1xyXG5cclxuICAgICAgICBpZiAoIGZsYXJlcy5sZW5ndGggPT09IDAgKSByZXR1cm47XHJcblxyXG4gICAgICAgIHZhciB0ZW1wUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICB2YXIgaW52QXNwZWN0ID0gdmlld3BvcnRIZWlnaHQgLyB2aWV3cG9ydFdpZHRoLFxyXG4gICAgICAgICAgICBoYWxmVmlld3BvcnRXaWR0aCA9IHZpZXdwb3J0V2lkdGggKiAwLjUsXHJcbiAgICAgICAgICAgIGhhbGZWaWV3cG9ydEhlaWdodCA9IHZpZXdwb3J0SGVpZ2h0ICogMC41O1xyXG5cclxuICAgICAgICB2YXIgc2l6ZSA9IDE2IC8gdmlld3BvcnRIZWlnaHQsXHJcbiAgICAgICAgICAgIHNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjIoIHNpemUgKiBpbnZBc3BlY3QsIHNpemUgKTtcclxuXHJcbiAgICAgICAgdmFyIHNjcmVlblBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDEsIDAgKSxcclxuICAgICAgICAgICAgc2NyZWVuUG9zaXRpb25QaXhlbHMgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApO1xyXG5cclxuICAgICAgICBpZiAoIHByb2dyYW0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIGluaXQoKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBnbC51c2VQcm9ncmFtKCBwcm9ncmFtICk7XHJcblxyXG4gICAgICAgIHN0YXRlLmluaXRBdHRyaWJ1dGVzKCk7XHJcbiAgICAgICAgc3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnZlcnRleCApO1xyXG4gICAgICAgIHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy51diApO1xyXG4gICAgICAgIHN0YXRlLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XHJcblxyXG4gICAgICAgIC8vIGxvb3AgdGhyb3VnaCBhbGwgbGVucyBmbGFyZXMgdG8gdXBkYXRlIHRoZWlyIG9jY2x1c2lvbiBhbmQgcG9zaXRpb25zXHJcbiAgICAgICAgLy8gc2V0dXAgZ2wgYW5kIGNvbW1vbiB1c2VkIGF0dHJpYnMvdW5pZm9ybXNcclxuXHJcbiAgICAgICAgZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5vY2NsdXNpb25NYXAsIDAgKTtcclxuICAgICAgICBnbC51bmlmb3JtMWkoIHVuaWZvcm1zLm1hcCwgMSApO1xyXG5cclxuICAgICAgICBnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudmVydGV4LCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCAwICk7XHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy51diwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogOCwgOCApO1xyXG5cclxuICAgICAgICBnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZWxlbWVudEJ1ZmZlciApO1xyXG5cclxuICAgICAgICBzdGF0ZS5kaXNhYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcclxuICAgICAgICBnbC5kZXB0aE1hc2soIGZhbHNlICk7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGZsYXJlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgc2l6ZSA9IDE2IC8gdmlld3BvcnRIZWlnaHQ7XHJcbiAgICAgICAgICAgIHNjYWxlLnNldCggc2l6ZSAqIGludkFzcGVjdCwgc2l6ZSApO1xyXG5cclxuICAgICAgICAgICAgLy8gY2FsYyBvYmplY3Qgc2NyZWVuIHBvc2l0aW9uXHJcblxyXG4gICAgICAgICAgICB2YXIgZmxhcmUgPSBmbGFyZXNbIGkgXTtcclxuXHJcbiAgICAgICAgICAgIHRlbXBQb3NpdGlvbi5zZXQoIGZsYXJlLm1hdHJpeFdvcmxkLmVsZW1lbnRzWyAxMiBdLCBmbGFyZS5tYXRyaXhXb3JsZC5lbGVtZW50c1sgMTMgXSwgZmxhcmUubWF0cml4V29ybGQuZWxlbWVudHNbIDE0IF0gKTtcclxuXHJcbiAgICAgICAgICAgIHRlbXBQb3NpdGlvbi5hcHBseU1hdHJpeDQoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcclxuICAgICAgICAgICAgdGVtcFBvc2l0aW9uLmFwcGx5UHJvamVjdGlvbiggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHNldHVwIGFycmF5cyBmb3IgZ2wgcHJvZ3JhbXNcclxuXHJcbiAgICAgICAgICAgIHNjcmVlblBvc2l0aW9uLmNvcHkoIHRlbXBQb3NpdGlvbiApO1xyXG5cclxuICAgICAgICAgICAgc2NyZWVuUG9zaXRpb25QaXhlbHMueCA9IHNjcmVlblBvc2l0aW9uLnggKiBoYWxmVmlld3BvcnRXaWR0aCArIGhhbGZWaWV3cG9ydFdpZHRoO1xyXG4gICAgICAgICAgICBzY3JlZW5Qb3NpdGlvblBpeGVscy55ID0gc2NyZWVuUG9zaXRpb24ueSAqIGhhbGZWaWV3cG9ydEhlaWdodCArIGhhbGZWaWV3cG9ydEhlaWdodDtcclxuXHJcbiAgICAgICAgICAgIC8vIHNjcmVlbiBjdWxsXHJcblxyXG4gICAgICAgICAgICBpZiAoIGhhc1ZlcnRleFRleHR1cmUgfHwgKFxyXG4gICAgICAgICAgICAgICAgc2NyZWVuUG9zaXRpb25QaXhlbHMueCA+IDAgJiZcclxuICAgICAgICAgICAgICAgIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnggPCB2aWV3cG9ydFdpZHRoICYmXHJcbiAgICAgICAgICAgICAgICBzY3JlZW5Qb3NpdGlvblBpeGVscy55ID4gMCAmJlxyXG4gICAgICAgICAgICAgICAgc2NyZWVuUG9zaXRpb25QaXhlbHMueSA8IHZpZXdwb3J0SGVpZ2h0ICkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gc2F2ZSBjdXJyZW50IFJHQiB0byB0ZW1wIHRleHR1cmVcclxuXHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMCApO1xyXG4gICAgICAgICAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG51bGwgKTtcclxuICAgICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUxICk7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgdGVtcFRleHR1cmUgKTtcclxuICAgICAgICAgICAgICAgIGdsLmNvcHlUZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0IsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnggLSA4LCBzY3JlZW5Qb3NpdGlvblBpeGVscy55IC0gOCwgMTYsIDE2LCAwICk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHJlbmRlciBwaW5rIHF1YWRcclxuXHJcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWkoIHVuaWZvcm1zLnJlbmRlclR5cGUsIDAgKTtcclxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0yZiggdW5pZm9ybXMuc2NhbGUsIHNjYWxlLngsIHNjYWxlLnkgKTtcclxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuc2NyZWVuUG9zaXRpb24sIHNjcmVlblBvc2l0aW9uLngsIHNjcmVlblBvc2l0aW9uLnksIHNjcmVlblBvc2l0aW9uLnogKTtcclxuXHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5kaXNhYmxlKCBnbC5CTEVORCApO1xyXG4gICAgICAgICAgICAgICAgc3RhdGUuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XHJcblxyXG4gICAgICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKCBnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vIGNvcHkgcmVzdWx0IHRvIG9jY2x1c2lvbk1hcFxyXG5cclxuICAgICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUwICk7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgb2NjbHVzaW9uVGV4dHVyZSApO1xyXG4gICAgICAgICAgICAgICAgZ2wuY29weVRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnggLSA4LCBzY3JlZW5Qb3NpdGlvblBpeGVscy55IC0gOCwgMTYsIDE2LCAwICk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgZ3JhcGhpY3NcclxuXHJcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWkoIHVuaWZvcm1zLnJlbmRlclR5cGUsIDEgKTtcclxuICAgICAgICAgICAgICAgIHN0YXRlLmRpc2FibGUoIGdsLkRFUFRIX1RFU1QgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMSApO1xyXG4gICAgICAgICAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIHRlbXBUZXh0dXJlICk7XHJcbiAgICAgICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoIGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIG9iamVjdCBwb3NpdGlvbnNcclxuXHJcbiAgICAgICAgICAgICAgICBmbGFyZS5wb3NpdGlvblNjcmVlbi5jb3B5KCBzY3JlZW5Qb3NpdGlvbiApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggZmxhcmUuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZsYXJlLmN1c3RvbVVwZGF0ZUNhbGxiYWNrKCBmbGFyZSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZsYXJlLnVwZGF0ZUxlbnNGbGFyZXMoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyIGZsYXJlc1xyXG5cclxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xaSggdW5pZm9ybXMucmVuZGVyVHlwZSwgMiApO1xyXG4gICAgICAgICAgICAgICAgc3RhdGUuZW5hYmxlKCBnbC5CTEVORCApO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBmbGFyZS5sZW5zRmxhcmVzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3ByaXRlID0gZmxhcmUubGVuc0ZsYXJlc1sgaiBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHNwcml0ZS5vcGFjaXR5ID4gMC4wMDEgJiYgc3ByaXRlLnNjYWxlID4gMC4wMDEgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JlZW5Qb3NpdGlvbi54ID0gc3ByaXRlLng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmVlblBvc2l0aW9uLnkgPSBzcHJpdGUueTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NyZWVuUG9zaXRpb24ueiA9IHNwcml0ZS56O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IHNwcml0ZS5zaXplICogc3ByaXRlLnNjYWxlIC8gdmlld3BvcnRIZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZS54ID0gc2l6ZSAqIGludkFzcGVjdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGUueSA9IHNpemU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtM2YoIHVuaWZvcm1zLnNjcmVlblBvc2l0aW9uLCBzY3JlZW5Qb3NpdGlvbi54LCBzY3JlZW5Qb3NpdGlvbi55LCBzY3JlZW5Qb3NpdGlvbi56ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0yZiggdW5pZm9ybXMuc2NhbGUsIHNjYWxlLngsIHNjYWxlLnkgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5yb3RhdGlvbiwgc3ByaXRlLnJvdGF0aW9uICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWYoIHVuaWZvcm1zLm9wYWNpdHksIHNwcml0ZS5vcGFjaXR5ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuY29sb3IsIHNwcml0ZS5jb2xvci5yLCBzcHJpdGUuY29sb3IuZywgc3ByaXRlLmNvbG9yLmIgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnNldEJsZW5kaW5nKCBzcHJpdGUuYmxlbmRpbmcsIHNwcml0ZS5ibGVuZEVxdWF0aW9uLCBzcHJpdGUuYmxlbmRTcmMsIHNwcml0ZS5ibGVuZERzdCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlci5zZXRUZXh0dXJlKCBzcHJpdGUudGV4dHVyZSwgMSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKCBnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcmVzdG9yZSBnbFxyXG5cclxuICAgICAgICBzdGF0ZS5lbmFibGUoIGdsLkNVTExfRkFDRSApO1xyXG4gICAgICAgIHN0YXRlLmVuYWJsZSggZ2wuREVQVEhfVEVTVCApO1xyXG4gICAgICAgIGdsLmRlcHRoTWFzayggdHJ1ZSApO1xyXG5cclxuICAgICAgICByZW5kZXJlci5yZXNldEdMU3RhdGUoKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0gKCBzaGFkZXIgKSB7XHJcblxyXG4gICAgICAgIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG5cclxuICAgICAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIGdsLkZSQUdNRU5UX1NIQURFUiApO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIGdsLlZFUlRFWF9TSEFERVIgKTtcclxuXHJcbiAgICAgICAgdmFyIHByZWZpeCA9IFwicHJlY2lzaW9uIFwiICsgcmVuZGVyZXIuZ2V0UHJlY2lzaW9uKCkgKyBcIiBmbG9hdDtcXG5cIjtcclxuXHJcbiAgICAgICAgZ2wuc2hhZGVyU291cmNlKCBmcmFnbWVudFNoYWRlciwgcHJlZml4ICsgc2hhZGVyLmZyYWdtZW50U2hhZGVyICk7XHJcbiAgICAgICAgZ2wuc2hhZGVyU291cmNlKCB2ZXJ0ZXhTaGFkZXIsIHByZWZpeCArIHNoYWRlci52ZXJ0ZXhTaGFkZXIgKTtcclxuXHJcbiAgICAgICAgZ2wuY29tcGlsZVNoYWRlciggZnJhZ21lbnRTaGFkZXIgKTtcclxuICAgICAgICBnbC5jb21waWxlU2hhZGVyKCB2ZXJ0ZXhTaGFkZXIgKTtcclxuXHJcbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBmcmFnbWVudFNoYWRlciApO1xyXG4gICAgICAgIGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgdmVydGV4U2hhZGVyICk7XHJcblxyXG4gICAgICAgIGdsLmxpbmtQcm9ncmFtKCBwcm9ncmFtICk7XHJcblxyXG4gICAgICAgIHJldHVybiBwcm9ncmFtO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvcGx1Z2lucy9TcHJpdGVQbHVnaW4uanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlNwcml0ZVBsdWdpbiA9IGZ1bmN0aW9uICggcmVuZGVyZXIsIHNwcml0ZXMgKSB7XHJcblxyXG4gICAgdmFyIGdsID0gcmVuZGVyZXIuY29udGV4dDtcclxuICAgIHZhciBzdGF0ZSA9IHJlbmRlcmVyLnN0YXRlO1xyXG5cclxuICAgIHZhciB2ZXJ0ZXhCdWZmZXIsIGVsZW1lbnRCdWZmZXI7XHJcbiAgICB2YXIgcHJvZ3JhbSwgYXR0cmlidXRlcywgdW5pZm9ybXM7XHJcblxyXG4gICAgdmFyIHRleHR1cmU7XHJcblxyXG4gICAgLy8gZGVjb21wb3NlIG1hdHJpeFdvcmxkXHJcblxyXG4gICAgdmFyIHNwcml0ZVBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgIHZhciBzcHJpdGVSb3RhdGlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcbiAgICB2YXIgc3ByaXRlU2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGluaXQoKSB7XHJcblxyXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcclxuICAgICAgICAgICAgLSAwLjUsIC0gMC41LCAgMCwgMCxcclxuICAgICAgICAgICAgMC41LCAtIDAuNSwgIDEsIDAsXHJcbiAgICAgICAgICAgIDAuNSwgICAwLjUsICAxLCAxLFxyXG4gICAgICAgICAgICAtIDAuNSwgICAwLjUsICAwLCAxXHJcbiAgICAgICAgXSApO1xyXG5cclxuICAgICAgICB2YXIgZmFjZXMgPSBuZXcgVWludDE2QXJyYXkoIFtcclxuICAgICAgICAgICAgMCwgMSwgMixcclxuICAgICAgICAgICAgMCwgMiwgM1xyXG4gICAgICAgIF0gKTtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyICA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgICAgIGVsZW1lbnRCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuXHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIgKTtcclxuICAgICAgICBnbC5idWZmZXJEYXRhKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRpY2VzLCBnbC5TVEFUSUNfRFJBVyApO1xyXG5cclxuICAgICAgICBnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZWxlbWVudEJ1ZmZlciApO1xyXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBmYWNlcywgZ2wuU1RBVElDX0RSQVcgKTtcclxuXHJcbiAgICAgICAgcHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0oKTtcclxuXHJcbiAgICAgICAgYXR0cmlidXRlcyA9IHtcclxuICAgICAgICAgICAgcG9zaXRpb246XHRcdFx0Z2wuZ2V0QXR0cmliTG9jYXRpb24gKCBwcm9ncmFtLCAncG9zaXRpb24nICksXHJcbiAgICAgICAgICAgIHV2Olx0XHRcdFx0XHRnbC5nZXRBdHRyaWJMb2NhdGlvbiAoIHByb2dyYW0sICd1dicgKVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHVuaWZvcm1zID0ge1xyXG4gICAgICAgICAgICB1dk9mZnNldDpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICd1dk9mZnNldCcgKSxcclxuICAgICAgICAgICAgdXZTY2FsZTpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICd1dlNjYWxlJyApLFxyXG5cclxuICAgICAgICAgICAgcm90YXRpb246XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAncm90YXRpb24nICksXHJcbiAgICAgICAgICAgIHNjYWxlOlx0XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnc2NhbGUnICksXHJcblxyXG4gICAgICAgICAgICBjb2xvcjpcdFx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2NvbG9yJyApLFxyXG4gICAgICAgICAgICBtYXA6XHRcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdtYXAnICksXHJcbiAgICAgICAgICAgIG9wYWNpdHk6XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnb3BhY2l0eScgKSxcclxuXHJcbiAgICAgICAgICAgIG1vZGVsVmlld01hdHJpeDogXHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdtb2RlbFZpZXdNYXRyaXgnICksXHJcbiAgICAgICAgICAgIHByb2plY3Rpb25NYXRyaXg6XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdwcm9qZWN0aW9uTWF0cml4JyApLFxyXG5cclxuICAgICAgICAgICAgZm9nVHlwZTpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dUeXBlJyApLFxyXG4gICAgICAgICAgICBmb2dEZW5zaXR5Olx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ0RlbnNpdHknICksXHJcbiAgICAgICAgICAgIGZvZ05lYXI6XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nTmVhcicgKSxcclxuICAgICAgICAgICAgZm9nRmFyOlx0XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nRmFyJyApLFxyXG4gICAgICAgICAgICBmb2dDb2xvcjpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dDb2xvcicgKSxcclxuXHJcbiAgICAgICAgICAgIGFscGhhVGVzdDpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdhbHBoYVRlc3QnIClcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcclxuICAgICAgICBjYW52YXMud2lkdGggPSA4O1xyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSA4O1xyXG5cclxuICAgICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XHJcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAnd2hpdGUnO1xyXG4gICAgICAgIGNvbnRleHQuZmlsbFJlY3QoIDAsIDAsIDgsIDggKTtcclxuXHJcbiAgICAgICAgdGV4dHVyZSA9IG5ldyBUSFJFRS5UZXh0dXJlKCBjYW52YXMgKTtcclxuICAgICAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEgKSB7XHJcblxyXG4gICAgICAgIGlmICggc3ByaXRlcy5sZW5ndGggPT09IDAgKSByZXR1cm47XHJcblxyXG4gICAgICAgIC8vIHNldHVwIGdsXHJcblxyXG4gICAgICAgIGlmICggcHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgaW5pdCgpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdsLnVzZVByb2dyYW0oIHByb2dyYW0gKTtcclxuXHJcbiAgICAgICAgc3RhdGUuaW5pdEF0dHJpYnV0ZXMoKTtcclxuICAgICAgICBzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMucG9zaXRpb24gKTtcclxuICAgICAgICBzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMudXYgKTtcclxuICAgICAgICBzdGF0ZS5kaXNhYmxlVW51c2VkQXR0cmlidXRlcygpO1xyXG5cclxuICAgICAgICBzdGF0ZS5kaXNhYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcclxuICAgICAgICBzdGF0ZS5lbmFibGUoIGdsLkJMRU5EICk7XHJcblxyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyICk7XHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5wb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogOCwgMCApO1xyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudXYsIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDggKTtcclxuXHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGVsZW1lbnRCdWZmZXIgKTtcclxuXHJcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdiggdW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeCwgZmFsc2UsIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzICk7XHJcblxyXG4gICAgICAgIHN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUwICk7XHJcbiAgICAgICAgZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5tYXAsIDAgKTtcclxuXHJcbiAgICAgICAgdmFyIG9sZEZvZ1R5cGUgPSAwO1xyXG4gICAgICAgIHZhciBzY2VuZUZvZ1R5cGUgPSAwO1xyXG4gICAgICAgIHZhciBmb2cgPSBzY2VuZS5mb2c7XHJcblxyXG4gICAgICAgIGlmICggZm9nICkge1xyXG5cclxuICAgICAgICAgICAgZ2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5mb2dDb2xvciwgZm9nLmNvbG9yLnIsIGZvZy5jb2xvci5nLCBmb2cuY29sb3IuYiApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBmb2cgaW5zdGFuY2VvZiBUSFJFRS5Gb2cgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dOZWFyLCBmb2cubmVhciApO1xyXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dGYXIsIGZvZy5mYXIgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIDEgKTtcclxuICAgICAgICAgICAgICAgIG9sZEZvZ1R5cGUgPSAxO1xyXG4gICAgICAgICAgICAgICAgc2NlbmVGb2dUeXBlID0gMTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZ0V4cDIgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dEZW5zaXR5LCBmb2cuZGVuc2l0eSApO1xyXG5cclxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgMiApO1xyXG4gICAgICAgICAgICAgICAgb2xkRm9nVHlwZSA9IDI7XHJcbiAgICAgICAgICAgICAgICBzY2VuZUZvZ1R5cGUgPSAyO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5mb2dUeXBlLCAwICk7XHJcbiAgICAgICAgICAgIG9sZEZvZ1R5cGUgPSAwO1xyXG4gICAgICAgICAgICBzY2VuZUZvZ1R5cGUgPSAwO1xyXG5cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLyB1cGRhdGUgcG9zaXRpb25zIGFuZCBzb3J0XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHNwcml0ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBzcHJpdGUgPSBzcHJpdGVzWyBpIF07XHJcblxyXG4gICAgICAgICAgICBzcHJpdGUubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIHNwcml0ZS5tYXRyaXhXb3JsZCApO1xyXG4gICAgICAgICAgICBzcHJpdGUueiA9IC0gc3ByaXRlLm1vZGVsVmlld01hdHJpeC5lbGVtZW50c1sgMTQgXTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzcHJpdGVzLnNvcnQoIHBhaW50ZXJTb3J0U3RhYmxlICk7XHJcblxyXG4gICAgICAgIC8vIHJlbmRlciBhbGwgc3ByaXRlc1xyXG5cclxuICAgICAgICB2YXIgc2NhbGUgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gc3ByaXRlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHNwcml0ZSA9IHNwcml0ZXNbIGkgXTtcclxuICAgICAgICAgICAgdmFyIG1hdGVyaWFsID0gc3ByaXRlLm1hdGVyaWFsO1xyXG5cclxuICAgICAgICAgICAgZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5hbHBoYVRlc3QsIG1hdGVyaWFsLmFscGhhVGVzdCApO1xyXG4gICAgICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KCB1bmlmb3Jtcy5tb2RlbFZpZXdNYXRyaXgsIGZhbHNlLCBzcHJpdGUubW9kZWxWaWV3TWF0cml4LmVsZW1lbnRzICk7XHJcblxyXG4gICAgICAgICAgICBzcHJpdGUubWF0cml4V29ybGQuZGVjb21wb3NlKCBzcHJpdGVQb3NpdGlvbiwgc3ByaXRlUm90YXRpb24sIHNwcml0ZVNjYWxlICk7XHJcblxyXG4gICAgICAgICAgICBzY2FsZVsgMCBdID0gc3ByaXRlU2NhbGUueDtcclxuICAgICAgICAgICAgc2NhbGVbIDEgXSA9IHNwcml0ZVNjYWxlLnk7XHJcblxyXG4gICAgICAgICAgICB2YXIgZm9nVHlwZSA9IDA7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHNjZW5lLmZvZyAmJiBtYXRlcmlhbC5mb2cgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9nVHlwZSA9IHNjZW5lRm9nVHlwZTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggb2xkRm9nVHlwZSAhPT0gZm9nVHlwZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIGZvZ1R5cGUgKTtcclxuICAgICAgICAgICAgICAgIG9sZEZvZ1R5cGUgPSBmb2dUeXBlO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBtYXRlcmlhbC5tYXAgIT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dk9mZnNldCwgbWF0ZXJpYWwubWFwLm9mZnNldC54LCBtYXRlcmlhbC5tYXAub2Zmc2V0LnkgKTtcclxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0yZiggdW5pZm9ybXMudXZTY2FsZSwgbWF0ZXJpYWwubWFwLnJlcGVhdC54LCBtYXRlcmlhbC5tYXAucmVwZWF0LnkgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dk9mZnNldCwgMCwgMCApO1xyXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dlNjYWxlLCAxLCAxICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBnbC51bmlmb3JtMWYoIHVuaWZvcm1zLm9wYWNpdHksIG1hdGVyaWFsLm9wYWNpdHkgKTtcclxuICAgICAgICAgICAgZ2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5jb2xvciwgbWF0ZXJpYWwuY29sb3IuciwgbWF0ZXJpYWwuY29sb3IuZywgbWF0ZXJpYWwuY29sb3IuYiApO1xyXG5cclxuICAgICAgICAgICAgZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5yb3RhdGlvbiwgbWF0ZXJpYWwucm90YXRpb24gKTtcclxuICAgICAgICAgICAgZ2wudW5pZm9ybTJmdiggdW5pZm9ybXMuc2NhbGUsIHNjYWxlICk7XHJcblxyXG4gICAgICAgICAgICBzdGF0ZS5zZXRCbGVuZGluZyggbWF0ZXJpYWwuYmxlbmRpbmcsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb24sIG1hdGVyaWFsLmJsZW5kU3JjLCBtYXRlcmlhbC5ibGVuZERzdCApO1xyXG4gICAgICAgICAgICBzdGF0ZS5zZXREZXB0aFRlc3QoIG1hdGVyaWFsLmRlcHRoVGVzdCApO1xyXG4gICAgICAgICAgICBzdGF0ZS5zZXREZXB0aFdyaXRlKCBtYXRlcmlhbC5kZXB0aFdyaXRlICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG1hdGVyaWFsLm1hcCAmJiBtYXRlcmlhbC5tYXAuaW1hZ2UgJiYgbWF0ZXJpYWwubWFwLmltYWdlLndpZHRoICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnNldFRleHR1cmUoIG1hdGVyaWFsLm1hcCwgMCApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZW5kZXJlci5zZXRUZXh0dXJlKCB0ZXh0dXJlLCAwICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoIGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyByZXN0b3JlIGdsXHJcblxyXG4gICAgICAgIHN0YXRlLmVuYWJsZSggZ2wuQ1VMTF9GQUNFICk7XHJcblxyXG4gICAgICAgIHJlbmRlcmVyLnJlc2V0R0xTdGF0ZSgpO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbSAoKSB7XHJcblxyXG4gICAgICAgIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG5cclxuICAgICAgICB2YXIgdmVydGV4U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5WRVJURVhfU0hBREVSICk7XHJcbiAgICAgICAgdmFyIGZyYWdtZW50U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5GUkFHTUVOVF9TSEFERVIgKTtcclxuXHJcbiAgICAgICAgZ2wuc2hhZGVyU291cmNlKCB2ZXJ0ZXhTaGFkZXIsIFtcclxuXHJcbiAgICAgICAgICAgICdwcmVjaXNpb24gJyArIHJlbmRlcmVyLmdldFByZWNpc2lvbigpICsgJyBmbG9hdDsnLFxyXG5cclxuICAgICAgICAgICAgJ3VuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7JyxcclxuICAgICAgICAgICAgJ3VuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4OycsXHJcbiAgICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHJvdGF0aW9uOycsXHJcbiAgICAgICAgICAgICd1bmlmb3JtIHZlYzIgc2NhbGU7JyxcclxuICAgICAgICAgICAgJ3VuaWZvcm0gdmVjMiB1dk9mZnNldDsnLFxyXG4gICAgICAgICAgICAndW5pZm9ybSB2ZWMyIHV2U2NhbGU7JyxcclxuXHJcbiAgICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjsnLFxyXG4gICAgICAgICAgICAnYXR0cmlidXRlIHZlYzIgdXY7JyxcclxuXHJcbiAgICAgICAgICAgICd2YXJ5aW5nIHZlYzIgdlVWOycsXHJcblxyXG4gICAgICAgICAgICAndm9pZCBtYWluKCkgeycsXHJcblxyXG4gICAgICAgICAgICAndlVWID0gdXZPZmZzZXQgKyB1diAqIHV2U2NhbGU7JyxcclxuXHJcbiAgICAgICAgICAgICd2ZWMyIGFsaWduZWRQb3NpdGlvbiA9IHBvc2l0aW9uICogc2NhbGU7JyxcclxuXHJcbiAgICAgICAgICAgICd2ZWMyIHJvdGF0ZWRQb3NpdGlvbjsnLFxyXG4gICAgICAgICAgICAncm90YXRlZFBvc2l0aW9uLnggPSBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi55OycsXHJcbiAgICAgICAgICAgICdyb3RhdGVkUG9zaXRpb24ueSA9IHNpbiggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54ICsgY29zKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7JyxcclxuXHJcbiAgICAgICAgICAgICd2ZWM0IGZpbmFsUG9zaXRpb247JyxcclxuXHJcbiAgICAgICAgICAgICdmaW5hbFBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggMC4wLCAwLjAsIDAuMCwgMS4wICk7JyxcclxuICAgICAgICAgICAgJ2ZpbmFsUG9zaXRpb24ueHkgKz0gcm90YXRlZFBvc2l0aW9uOycsXHJcbiAgICAgICAgICAgICdmaW5hbFBvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIGZpbmFsUG9zaXRpb247JyxcclxuXHJcbiAgICAgICAgICAgICdnbF9Qb3NpdGlvbiA9IGZpbmFsUG9zaXRpb247JyxcclxuXHJcbiAgICAgICAgICAgICd9J1xyXG5cclxuICAgICAgICBdLmpvaW4oICdcXG4nICkgKTtcclxuXHJcbiAgICAgICAgZ2wuc2hhZGVyU291cmNlKCBmcmFnbWVudFNoYWRlciwgW1xyXG5cclxuICAgICAgICAgICAgJ3ByZWNpc2lvbiAnICsgcmVuZGVyZXIuZ2V0UHJlY2lzaW9uKCkgKyAnIGZsb2F0OycsXHJcblxyXG4gICAgICAgICAgICAndW5pZm9ybSB2ZWMzIGNvbG9yOycsXHJcbiAgICAgICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCBtYXA7JyxcclxuICAgICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgb3BhY2l0eTsnLFxyXG5cclxuICAgICAgICAgICAgJ3VuaWZvcm0gaW50IGZvZ1R5cGU7JyxcclxuICAgICAgICAgICAgJ3VuaWZvcm0gdmVjMyBmb2dDb2xvcjsnLFxyXG4gICAgICAgICAgICAndW5pZm9ybSBmbG9hdCBmb2dEZW5zaXR5OycsXHJcbiAgICAgICAgICAgICd1bmlmb3JtIGZsb2F0IGZvZ05lYXI7JyxcclxuICAgICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgZm9nRmFyOycsXHJcbiAgICAgICAgICAgICd1bmlmb3JtIGZsb2F0IGFscGhhVGVzdDsnLFxyXG5cclxuICAgICAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VVY7JyxcclxuXHJcbiAgICAgICAgICAgICd2b2lkIG1haW4oKSB7JyxcclxuXHJcbiAgICAgICAgICAgICd2ZWM0IHRleHR1cmUgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7JyxcclxuXHJcbiAgICAgICAgICAgICdpZiAoIHRleHR1cmUuYSA8IGFscGhhVGVzdCApIGRpc2NhcmQ7JyxcclxuXHJcbiAgICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSB2ZWM0KCBjb2xvciAqIHRleHR1cmUueHl6LCB0ZXh0dXJlLmEgKiBvcGFjaXR5ICk7JyxcclxuXHJcbiAgICAgICAgICAgICdpZiAoIGZvZ1R5cGUgPiAwICkgeycsXHJcblxyXG4gICAgICAgICAgICAnZmxvYXQgZGVwdGggPSBnbF9GcmFnQ29vcmQueiAvIGdsX0ZyYWdDb29yZC53OycsXHJcbiAgICAgICAgICAgICdmbG9hdCBmb2dGYWN0b3IgPSAwLjA7JyxcclxuXHJcbiAgICAgICAgICAgICdpZiAoIGZvZ1R5cGUgPT0gMSApIHsnLFxyXG5cclxuICAgICAgICAgICAgJ2ZvZ0ZhY3RvciA9IHNtb290aHN0ZXAoIGZvZ05lYXIsIGZvZ0ZhciwgZGVwdGggKTsnLFxyXG5cclxuICAgICAgICAgICAgJ30gZWxzZSB7JyxcclxuXHJcbiAgICAgICAgICAgICdjb25zdCBmbG9hdCBMT0cyID0gMS40NDI2OTU7JyxcclxuICAgICAgICAgICAgJ2ZvZ0ZhY3RvciA9IGV4cDIoIC0gZm9nRGVuc2l0eSAqIGZvZ0RlbnNpdHkgKiBkZXB0aCAqIGRlcHRoICogTE9HMiApOycsXHJcbiAgICAgICAgICAgICdmb2dGYWN0b3IgPSAxLjAgLSBjbGFtcCggZm9nRmFjdG9yLCAwLjAsIDEuMCApOycsXHJcblxyXG4gICAgICAgICAgICAnfScsXHJcblxyXG4gICAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gbWl4KCBnbF9GcmFnQ29sb3IsIHZlYzQoIGZvZ0NvbG9yLCBnbF9GcmFnQ29sb3IudyApLCBmb2dGYWN0b3IgKTsnLFxyXG5cclxuICAgICAgICAgICAgJ30nLFxyXG5cclxuICAgICAgICAgICAgJ30nXHJcblxyXG4gICAgICAgIF0uam9pbiggJ1xcbicgKSApO1xyXG5cclxuICAgICAgICBnbC5jb21waWxlU2hhZGVyKCB2ZXJ0ZXhTaGFkZXIgKTtcclxuICAgICAgICBnbC5jb21waWxlU2hhZGVyKCBmcmFnbWVudFNoYWRlciApO1xyXG5cclxuICAgICAgICBnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIHZlcnRleFNoYWRlciApO1xyXG4gICAgICAgIGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIgKTtcclxuXHJcbiAgICAgICAgZ2wubGlua1Byb2dyYW0oIHByb2dyYW0gKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHByb2dyYW07XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBhaW50ZXJTb3J0U3RhYmxlICggYSwgYiApIHtcclxuXHJcbiAgICAgICAgaWYgKCBhLnogIT09IGIueiApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBiLnogLSBhLno7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYi5pZCAtIGEuaWQ7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL0N1cnZlVXRpbHMuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqL1xyXG5cclxuVEhSRUUuQ3VydmVVdGlscyA9IHtcclxuXHJcbiAgICB0YW5nZW50UXVhZHJhdGljQmV6aWVyOiBmdW5jdGlvbiAoIHQsIHAwLCBwMSwgcDIgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiAyICogKCAxIC0gdCApICogKCBwMSAtIHAwICkgKyAyICogdCAqICggcDIgLSBwMSApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLy8gUHVheSBCaW5nLCB0aGFua3MgZm9yIGhlbHBpbmcgd2l0aCB0aGlzIGRlcml2YXRpdmUhXHJcblxyXG4gICAgdGFuZ2VudEN1YmljQmV6aWVyOiBmdW5jdGlvbiAoIHQsIHAwLCBwMSwgcDIsIHAzICkge1xyXG5cclxuICAgICAgICByZXR1cm4gLSAzICogcDAgKiAoIDEgLSB0ICkgKiAoIDEgLSB0ICkgICtcclxuICAgICAgICAgICAgMyAqIHAxICogKCAxIC0gdCApICogKCAxIC0gdCApIC0gNiAqIHQgKiBwMSAqICggMSAtIHQgKSArXHJcbiAgICAgICAgICAgIDYgKiB0ICogIHAyICogKCAxIC0gdCApIC0gMyAqIHQgKiB0ICogcDIgK1xyXG4gICAgICAgICAgICAzICogdCAqIHQgKiBwMztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRhbmdlbnRTcGxpbmU6IGZ1bmN0aW9uICggdCwgcDAsIHAxLCBwMiwgcDMgKSB7XHJcblxyXG4gICAgICAgIC8vIFRvIGNoZWNrIGlmIG15IGZvcm11bGFzIGFyZSBjb3JyZWN0XHJcblxyXG4gICAgICAgIHZhciBoMDAgPSA2ICogdCAqIHQgLSA2ICogdDsgXHQvLyBkZXJpdmVkIGZyb20gMnReMyA/IDN0XjIgKyAxXHJcbiAgICAgICAgdmFyIGgxMCA9IDMgKiB0ICogdCAtIDQgKiB0ICsgMTsgLy8gdF4zID8gMnReMiArIHRcclxuICAgICAgICB2YXIgaDAxID0gLSA2ICogdCAqIHQgKyA2ICogdDsgXHQvLyA/IDJ0MyArIDN0MlxyXG4gICAgICAgIHZhciBoMTEgPSAzICogdCAqIHQgLSAyICogdDtcdC8vIHQzID8gdDJcclxuXHJcbiAgICAgICAgcmV0dXJuIGgwMCArIGgxMCArIGgwMSArIGgxMTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIENhdG11bGwtUm9tXHJcblxyXG4gICAgaW50ZXJwb2xhdGU6IGZ1bmN0aW9uKCBwMCwgcDEsIHAyLCBwMywgdCApIHtcclxuXHJcbiAgICAgICAgdmFyIHYwID0gKCBwMiAtIHAwICkgKiAwLjU7XHJcbiAgICAgICAgdmFyIHYxID0gKCBwMyAtIHAxICkgKiAwLjU7XHJcbiAgICAgICAgdmFyIHQyID0gdCAqIHQ7XHJcbiAgICAgICAgdmFyIHQzID0gdCAqIHQyO1xyXG4gICAgICAgIHJldHVybiAoIDIgKiBwMSAtIDIgKiBwMiArIHYwICsgdjEgKSAqIHQzICsgKCAtIDMgKiBwMSArIDMgKiBwMiAtIDIgKiB2MCAtIHYxICkgKiB0MiArIHYwICogdCArIHAxO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvR2VvbWV0cnlVdGlscy5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuR2VvbWV0cnlVdGlscyA9IHtcclxuXHJcbiAgICBtZXJnZTogZnVuY3Rpb24gKCBnZW9tZXRyeTEsIGdlb21ldHJ5MiwgbWF0ZXJpYWxJbmRleE9mZnNldCApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuR2VvbWV0cnlVdGlsczogLm1lcmdlKCkgaGFzIGJlZW4gbW92ZWQgdG8gR2VvbWV0cnkuIFVzZSBnZW9tZXRyeS5tZXJnZSggZ2VvbWV0cnkyLCBtYXRyaXgsIG1hdGVyaWFsSW5kZXhPZmZzZXQgKSBpbnN0ZWFkLicgKTtcclxuXHJcbiAgICAgICAgdmFyIG1hdHJpeDtcclxuXHJcbiAgICAgICAgaWYgKCBnZW9tZXRyeTIgaW5zdGFuY2VvZiBUSFJFRS5NZXNoICkge1xyXG5cclxuICAgICAgICAgICAgZ2VvbWV0cnkyLm1hdHJpeEF1dG9VcGRhdGUgJiYgZ2VvbWV0cnkyLnVwZGF0ZU1hdHJpeCgpO1xyXG5cclxuICAgICAgICAgICAgbWF0cml4ID0gZ2VvbWV0cnkyLm1hdHJpeDtcclxuICAgICAgICAgICAgZ2VvbWV0cnkyID0gZ2VvbWV0cnkyLmdlb21ldHJ5O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdlb21ldHJ5MS5tZXJnZSggZ2VvbWV0cnkyLCBtYXRyaXgsIG1hdGVyaWFsSW5kZXhPZmZzZXQgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNlbnRlcjogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuR2VvbWV0cnlVdGlsczogLmNlbnRlcigpIGhhcyBiZWVuIG1vdmVkIHRvIEdlb21ldHJ5LiBVc2UgZ2VvbWV0cnkuY2VudGVyKCkgaW5zdGVhZC4nICk7XHJcbiAgICAgICAgcmV0dXJuIGdlb21ldHJ5LmNlbnRlcigpO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvSW1hZ2VVdGlscy5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgRGFvc2hlbmcgTXUgLyBodHRwczovL2dpdGh1Yi5jb20vRGFvc2hlbmdNdS9cclxuICovXHJcblxyXG5USFJFRS5JbWFnZVV0aWxzID0ge1xyXG5cclxuICAgIGNyb3NzT3JpZ2luOiB1bmRlZmluZWQsXHJcblxyXG4gICAgbG9hZFRleHR1cmU6IGZ1bmN0aW9uICggdXJsLCBtYXBwaW5nLCBvbkxvYWQsIG9uRXJyb3IgKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkltYWdlVXRpbHMubG9hZFRleHR1cmUgaXMgYmVpbmcgZGVwcmVjYXRlZC4gVXNlIFRIUkVFLlRleHR1cmVMb2FkZXIoKSBpbnN0ZWFkLicgKTtcclxuXHJcbiAgICAgICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCk7XHJcbiAgICAgICAgbG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XHJcblxyXG4gICAgICAgIHZhciB0ZXh0dXJlID0gbG9hZGVyLmxvYWQoIHVybCwgb25Mb2FkLCB1bmRlZmluZWQsIG9uRXJyb3IgKTtcclxuXHJcbiAgICAgICAgaWYgKCBtYXBwaW5nICkgdGV4dHVyZS5tYXBwaW5nID0gbWFwcGluZztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBsb2FkVGV4dHVyZUN1YmU6IGZ1bmN0aW9uICggdXJscywgbWFwcGluZywgb25Mb2FkLCBvbkVycm9yICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5JbWFnZVV0aWxzLmxvYWRUZXh0dXJlQ3ViZSBpcyBiZWluZyBkZXByZWNhdGVkLiBVc2UgVEhSRUUuQ3ViZVRleHR1cmVMb2FkZXIoKSBpbnN0ZWFkLicgKTtcclxuXHJcbiAgICAgICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5DdWJlVGV4dHVyZUxvYWRlcigpO1xyXG4gICAgICAgIGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xyXG5cclxuICAgICAgICB2YXIgdGV4dHVyZSA9IGxvYWRlci5sb2FkKCB1cmxzLCBvbkxvYWQsIHVuZGVmaW5lZCwgb25FcnJvciApO1xyXG5cclxuICAgICAgICBpZiAoIG1hcHBpbmcgKSB0ZXh0dXJlLm1hcHBpbmcgPSBtYXBwaW5nO1xyXG5cclxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGxvYWRDb21wcmVzc2VkVGV4dHVyZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuSW1hZ2VVdGlscy5sb2FkQ29tcHJlc3NlZFRleHR1cmUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkREU0xvYWRlciBpbnN0ZWFkLicgKVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbG9hZENvbXByZXNzZWRUZXh0dXJlQ3ViZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuSW1hZ2VVdGlscy5sb2FkQ29tcHJlc3NlZFRleHR1cmVDdWJlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5ERFNMb2FkZXIgaW5zdGVhZC4nIClcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL1NjZW5lVXRpbHMuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlNjZW5lVXRpbHMgPSB7XHJcblxyXG4gICAgY3JlYXRlTXVsdGlNYXRlcmlhbE9iamVjdDogZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWxzICkge1xyXG5cclxuICAgICAgICB2YXIgZ3JvdXAgPSBuZXcgVEhSRUUuR3JvdXAoKTtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gbWF0ZXJpYWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICBncm91cC5hZGQoIG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWxzWyBpIF0gKSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBncm91cDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRldGFjaDogZnVuY3Rpb24gKCBjaGlsZCwgcGFyZW50LCBzY2VuZSApIHtcclxuXHJcbiAgICAgICAgY2hpbGQuYXBwbHlNYXRyaXgoIHBhcmVudC5tYXRyaXhXb3JsZCApO1xyXG4gICAgICAgIHBhcmVudC5yZW1vdmUoIGNoaWxkICk7XHJcbiAgICAgICAgc2NlbmUuYWRkKCBjaGlsZCApO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYXR0YWNoOiBmdW5jdGlvbiAoIGNoaWxkLCBzY2VuZSwgcGFyZW50ICkge1xyXG5cclxuICAgICAgICB2YXIgbWF0cml4V29ybGRJbnZlcnNlID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuICAgICAgICBtYXRyaXhXb3JsZEludmVyc2UuZ2V0SW52ZXJzZSggcGFyZW50Lm1hdHJpeFdvcmxkICk7XHJcbiAgICAgICAgY2hpbGQuYXBwbHlNYXRyaXgoIG1hdHJpeFdvcmxkSW52ZXJzZSApO1xyXG5cclxuICAgICAgICBzY2VuZS5yZW1vdmUoIGNoaWxkICk7XHJcbiAgICAgICAgcGFyZW50LmFkZCggY2hpbGQgKTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL1NoYXBlVXRpbHMuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqL1xyXG5cclxuVEhSRUUuU2hhcGVVdGlscyA9IHtcclxuXHJcbiAgICAvLyBjYWxjdWxhdGUgYXJlYSBvZiB0aGUgY29udG91ciBwb2x5Z29uXHJcblxyXG4gICAgYXJlYTogZnVuY3Rpb24gKCBjb250b3VyICkge1xyXG5cclxuICAgICAgICB2YXIgbiA9IGNvbnRvdXIubGVuZ3RoO1xyXG4gICAgICAgIHZhciBhID0gMC4wO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgcCA9IG4gLSAxLCBxID0gMDsgcSA8IG47IHAgPSBxICsrICkge1xyXG5cclxuICAgICAgICAgICAgYSArPSBjb250b3VyWyBwIF0ueCAqIGNvbnRvdXJbIHEgXS55IC0gY29udG91clsgcSBdLnggKiBjb250b3VyWyBwIF0ueTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYSAqIDAuNTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRyaWFuZ3VsYXRlOiAoIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBjb2RlIGlzIGEgcXVpY2sgcG9ydCBvZiBjb2RlIHdyaXR0ZW4gaW4gQysrIHdoaWNoIHdhcyBzdWJtaXR0ZWQgdG9cclxuICAgICAgICAgKiBmbGlwY29kZS5jb20gYnkgSm9obiBXLiBSYXRjbGlmZiAgLy8gSnVseSAyMiwgMjAwMFxyXG4gICAgICAgICAqIFNlZSBvcmlnaW5hbCBjb2RlIGFuZCBtb3JlIGluZm9ybWF0aW9uIGhlcmU6XHJcbiAgICAgICAgICogaHR0cDovL3d3dy5mbGlwY29kZS5jb20vYXJjaGl2ZXMvRWZmaWNpZW50X1BvbHlnb25fVHJpYW5ndWxhdGlvbi5zaHRtbFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogcG9ydGVkIHRvIGFjdGlvbnNjcmlwdCBieSBaZXZhbiBSb3NzZXJcclxuICAgICAgICAgKiB3d3cuYWN0aW9uc25pcHBldC5jb21cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIHBvcnRlZCB0byBqYXZhc2NyaXB0IGJ5IEpvc2h1YSBLb29cclxuICAgICAgICAgKiBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gc25pcCggY29udG91ciwgdSwgdiwgdywgbiwgdmVydHMgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgcDtcclxuICAgICAgICAgICAgdmFyIGF4LCBheSwgYngsIGJ5O1xyXG4gICAgICAgICAgICB2YXIgY3gsIGN5LCBweCwgcHk7XHJcblxyXG4gICAgICAgICAgICBheCA9IGNvbnRvdXJbIHZlcnRzWyB1IF0gXS54O1xyXG4gICAgICAgICAgICBheSA9IGNvbnRvdXJbIHZlcnRzWyB1IF0gXS55O1xyXG5cclxuICAgICAgICAgICAgYnggPSBjb250b3VyWyB2ZXJ0c1sgdiBdIF0ueDtcclxuICAgICAgICAgICAgYnkgPSBjb250b3VyWyB2ZXJ0c1sgdiBdIF0ueTtcclxuXHJcbiAgICAgICAgICAgIGN4ID0gY29udG91clsgdmVydHNbIHcgXSBdLng7XHJcbiAgICAgICAgICAgIGN5ID0gY29udG91clsgdmVydHNbIHcgXSBdLnk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIE51bWJlci5FUFNJTE9OID4gKCAoICggYnggLSBheCApICogKCBjeSAtIGF5ICkgKSAtICggKCBieSAtIGF5ICkgKiAoIGN4IC0gYXggKSApICkgKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICB2YXIgYVgsIGFZLCBiWCwgYlksIGNYLCBjWTtcclxuICAgICAgICAgICAgdmFyIGFweCwgYXB5LCBicHgsIGJweSwgY3B4LCBjcHk7XHJcbiAgICAgICAgICAgIHZhciBjQ1JPU1NhcCwgYkNST1NTY3AsIGFDUk9TU2JwO1xyXG5cclxuICAgICAgICAgICAgYVggPSBjeCAtIGJ4OyAgYVkgPSBjeSAtIGJ5O1xyXG4gICAgICAgICAgICBiWCA9IGF4IC0gY3g7ICBiWSA9IGF5IC0gY3k7XHJcbiAgICAgICAgICAgIGNYID0gYnggLSBheDsgIGNZID0gYnkgLSBheTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHAgPSAwOyBwIDwgbjsgcCArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBweCA9IGNvbnRvdXJbIHZlcnRzWyBwIF0gXS54O1xyXG4gICAgICAgICAgICAgICAgcHkgPSBjb250b3VyWyB2ZXJ0c1sgcCBdIF0ueTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoICggKCBweCA9PT0gYXggKSAmJiAoIHB5ID09PSBheSApICkgfHxcclxuICAgICAgICAgICAgICAgICAgICAoICggcHggPT09IGJ4ICkgJiYgKCBweSA9PT0gYnkgKSApIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKCAoIHB4ID09PSBjeCApICYmICggcHkgPT09IGN5ICkgKSApXHRjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBhcHggPSBweCAtIGF4OyAgYXB5ID0gcHkgLSBheTtcclxuICAgICAgICAgICAgICAgIGJweCA9IHB4IC0gYng7ICBicHkgPSBweSAtIGJ5O1xyXG4gICAgICAgICAgICAgICAgY3B4ID0gcHggLSBjeDsgIGNweSA9IHB5IC0gY3k7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gc2VlIGlmIHAgaXMgaW5zaWRlIHRyaWFuZ2xlIGFiY1xyXG5cclxuICAgICAgICAgICAgICAgIGFDUk9TU2JwID0gYVggKiBicHkgLSBhWSAqIGJweDtcclxuICAgICAgICAgICAgICAgIGNDUk9TU2FwID0gY1ggKiBhcHkgLSBjWSAqIGFweDtcclxuICAgICAgICAgICAgICAgIGJDUk9TU2NwID0gYlggKiBjcHkgLSBiWSAqIGNweDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoICggYUNST1NTYnAgPj0gLSBOdW1iZXIuRVBTSUxPTiApICYmICggYkNST1NTY3AgPj0gLSBOdW1iZXIuRVBTSUxPTiApICYmICggY0NST1NTYXAgPj0gLSBOdW1iZXIuRVBTSUxPTiApICkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdGFrZXMgaW4gYW4gY29udG91ciBhcnJheSBhbmQgcmV0dXJuc1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCBjb250b3VyLCBpbmRpY2VzICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIG4gPSBjb250b3VyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIGlmICggbiA8IDMgKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXSxcclxuICAgICAgICAgICAgICAgIHZlcnRzID0gW10sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0SW5kaWNlcyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgLyogd2Ugd2FudCBhIGNvdW50ZXItY2xvY2t3aXNlIHBvbHlnb24gaW4gdmVydHMgKi9cclxuXHJcbiAgICAgICAgICAgIHZhciB1LCB2LCB3O1xyXG5cclxuICAgICAgICAgICAgaWYgKCBUSFJFRS5TaGFwZVV0aWxzLmFyZWEoIGNvbnRvdXIgKSA+IDAuMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCB2ID0gMDsgdiA8IG47IHYgKysgKSB2ZXJ0c1sgdiBdID0gdjtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggdiA9IDA7IHYgPCBuOyB2ICsrICkgdmVydHNbIHYgXSA9ICggbiAtIDEgKSAtIHY7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgbnYgPSBuO1xyXG5cclxuICAgICAgICAgICAgLyogIHJlbW92ZSBudiAtIDIgdmVydGljZXMsIGNyZWF0aW5nIDEgdHJpYW5nbGUgZXZlcnkgdGltZSAqL1xyXG5cclxuICAgICAgICAgICAgdmFyIGNvdW50ID0gMiAqIG52OyAgIC8qIGVycm9yIGRldGVjdGlvbiAqL1xyXG5cclxuICAgICAgICAgICAgZm9yICggdiA9IG52IC0gMTsgbnYgPiAyOyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvKiBpZiB3ZSBsb29wLCBpdCBpcyBwcm9iYWJseSBhIG5vbi1zaW1wbGUgcG9seWdvbiAqL1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggKCBjb3VudCAtLSApIDw9IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vKiogVHJpYW5ndWxhdGU6IEVSUk9SIC0gcHJvYmFibGUgYmFkIHBvbHlnb24hXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vdGhyb3cgKCBcIldhcm5pbmcsIHVuYWJsZSB0byB0cmlhbmd1bGF0ZSBwb2x5Z29uIVwiICk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTb21ldGltZXMgd2FybmluZyBpcyBmaW5lLCBlc3BlY2lhbGx5IHBvbHlnb25zIGFyZSB0cmlhbmd1bGF0ZWQgaW4gcmV2ZXJzZS5cclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5TaGFwZVV0aWxzOiBVbmFibGUgdG8gdHJpYW5ndWxhdGUgcG9seWdvbiEgaW4gdHJpYW5ndWxhdGUoKScgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpbmRpY2VzICkgcmV0dXJuIHZlcnRJbmRpY2VzO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qIHRocmVlIGNvbnNlY3V0aXZlIHZlcnRpY2VzIGluIGN1cnJlbnQgcG9seWdvbiwgPHUsdix3PiAqL1xyXG5cclxuICAgICAgICAgICAgICAgIHUgPSB2OyBcdCBcdGlmICggbnYgPD0gdSApIHUgPSAwOyAgICAgLyogcHJldmlvdXMgKi9cclxuICAgICAgICAgICAgICAgIHYgPSB1ICsgMTsgIGlmICggbnYgPD0gdiApIHYgPSAwOyAgICAgLyogbmV3IHYgICAgKi9cclxuICAgICAgICAgICAgICAgIHcgPSB2ICsgMTsgIGlmICggbnYgPD0gdyApIHcgPSAwOyAgICAgLyogbmV4dCAgICAgKi9cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHNuaXAoIGNvbnRvdXIsIHUsIHYsIHcsIG52LCB2ZXJ0cyApICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYSwgYiwgYywgcywgdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyogdHJ1ZSBuYW1lcyBvZiB0aGUgdmVydGljZXMgKi9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IHZlcnRzWyB1IF07XHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IHZlcnRzWyB2IF07XHJcbiAgICAgICAgICAgICAgICAgICAgYyA9IHZlcnRzWyB3IF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qIG91dHB1dCBUcmlhbmdsZSAqL1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCggWyBjb250b3VyWyBhIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRvdXJbIGIgXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udG91clsgYyBdIF0gKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRJbmRpY2VzLnB1c2goIFsgdmVydHNbIHUgXSwgdmVydHNbIHYgXSwgdmVydHNbIHcgXSBdICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qIHJlbW92ZSB2IGZyb20gdGhlIHJlbWFpbmluZyBwb2x5Z29uICovXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHMgPSB2LCB0ID0gdiArIDE7IHQgPCBudjsgcyArKywgdCArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRzWyBzIF0gPSB2ZXJ0c1sgdCBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG52IC0tO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKiByZXNldCBlcnJvciBkZXRlY3Rpb24gY291bnRlciAqL1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb3VudCA9IDIgKiBudjtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIGluZGljZXMgKSByZXR1cm4gdmVydEluZGljZXM7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9ICkoKSxcclxuXHJcbiAgICB0cmlhbmd1bGF0ZVNoYXBlOiBmdW5jdGlvbiAoIGNvbnRvdXIsIGhvbGVzICkge1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBwb2ludF9pbl9zZWdtZW50XzJEX2NvbGluKCBpblNlZ1B0MSwgaW5TZWdQdDIsIGluT3RoZXJQdCApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGluT3RoZXJQdCBuZWVkcyB0byBiZSBjb2xsaW5lYXIgdG8gdGhlIGluU2VnbWVudFxyXG4gICAgICAgICAgICBpZiAoIGluU2VnUHQxLnggIT09IGluU2VnUHQyLnggKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBpblNlZ1B0MS54IDwgaW5TZWdQdDIueCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXHQoICggaW5TZWdQdDEueCA8PSBpbk90aGVyUHQueCApICYmICggaW5PdGhlclB0LnggPD0gaW5TZWdQdDIueCApICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXHQoICggaW5TZWdQdDIueCA8PSBpbk90aGVyUHQueCApICYmICggaW5PdGhlclB0LnggPD0gaW5TZWdQdDEueCApICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGluU2VnUHQxLnkgPCBpblNlZ1B0Mi55ICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cdCggKCBpblNlZ1B0MS55IDw9IGluT3RoZXJQdC55ICkgJiYgKCBpbk90aGVyUHQueSA8PSBpblNlZ1B0Mi55ICkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cdCggKCBpblNlZ1B0Mi55IDw9IGluT3RoZXJQdC55ICkgJiYgKCBpbk90aGVyUHQueSA8PSBpblNlZ1B0MS55ICkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaW50ZXJzZWN0X3NlZ21lbnRzXzJEKCBpblNlZzFQdDEsIGluU2VnMVB0MiwgaW5TZWcyUHQxLCBpblNlZzJQdDIsIGluRXhjbHVkZUFkamFjZW50U2VncyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBzZWcxZHggPSBpblNlZzFQdDIueCAtIGluU2VnMVB0MS54LCAgIHNlZzFkeSA9IGluU2VnMVB0Mi55IC0gaW5TZWcxUHQxLnk7XHJcbiAgICAgICAgICAgIHZhciBzZWcyZHggPSBpblNlZzJQdDIueCAtIGluU2VnMlB0MS54LCAgIHNlZzJkeSA9IGluU2VnMlB0Mi55IC0gaW5TZWcyUHQxLnk7XHJcblxyXG4gICAgICAgICAgICB2YXIgc2VnMXNlZzJkeCA9IGluU2VnMVB0MS54IC0gaW5TZWcyUHQxLng7XHJcbiAgICAgICAgICAgIHZhciBzZWcxc2VnMmR5ID0gaW5TZWcxUHQxLnkgLSBpblNlZzJQdDEueTtcclxuXHJcbiAgICAgICAgICAgIHZhciBsaW1pdFx0XHQ9IHNlZzFkeSAqIHNlZzJkeCAtIHNlZzFkeCAqIHNlZzJkeTtcclxuICAgICAgICAgICAgdmFyIHBlcnBTZWcxXHQ9IHNlZzFkeSAqIHNlZzFzZWcyZHggLSBzZWcxZHggKiBzZWcxc2VnMmR5O1xyXG5cclxuICAgICAgICAgICAgaWYgKCBNYXRoLmFicyggbGltaXQgKSA+IE51bWJlci5FUFNJTE9OICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG5vdCBwYXJhbGxlbFxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBwZXJwU2VnMjtcclxuICAgICAgICAgICAgICAgIGlmICggbGltaXQgPiAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoICggcGVycFNlZzEgPCAwICkgfHwgKCBwZXJwU2VnMSA+IGxpbWl0ICkgKSBcdFx0cmV0dXJuIFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHBlcnBTZWcyID0gc2VnMmR5ICogc2VnMXNlZzJkeCAtIHNlZzJkeCAqIHNlZzFzZWcyZHk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAoIHBlcnBTZWcyIDwgMCApIHx8ICggcGVycFNlZzIgPiBsaW1pdCApICkgXHRcdHJldHVybiBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoICggcGVycFNlZzEgPiAwICkgfHwgKCBwZXJwU2VnMSA8IGxpbWl0ICkgKSBcdFx0cmV0dXJuIFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHBlcnBTZWcyID0gc2VnMmR5ICogc2VnMXNlZzJkeCAtIHNlZzJkeCAqIHNlZzFzZWcyZHk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAoIHBlcnBTZWcyID4gMCApIHx8ICggcGVycFNlZzIgPCBsaW1pdCApICkgXHRcdHJldHVybiBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaS5lLiB0byByZWR1Y2Ugcm91bmRpbmcgZXJyb3JzXHJcbiAgICAgICAgICAgICAgICAvLyBpbnRlcnNlY3Rpb24gYXQgZW5kcG9pbnQgb2Ygc2VnbWVudCMxP1xyXG4gICAgICAgICAgICAgICAgaWYgKCBwZXJwU2VnMiA9PT0gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAoIGluRXhjbHVkZUFkamFjZW50U2VncyApICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICggKCBwZXJwU2VnMSA9PT0gMCApIHx8ICggcGVycFNlZzEgPT09IGxpbWl0ICkgKSApXHRcdHJldHVybiBbXTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBpblNlZzFQdDEgXTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIHBlcnBTZWcyID09PSBsaW1pdCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAoIGluRXhjbHVkZUFkamFjZW50U2VncyApICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICggKCBwZXJwU2VnMSA9PT0gMCApIHx8ICggcGVycFNlZzEgPT09IGxpbWl0ICkgKSApXHRcdHJldHVybiBbXTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBpblNlZzFQdDIgXTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBpbnRlcnNlY3Rpb24gYXQgZW5kcG9pbnQgb2Ygc2VnbWVudCMyP1xyXG4gICAgICAgICAgICAgICAgaWYgKCBwZXJwU2VnMSA9PT0gMCApXHRcdHJldHVybiBbIGluU2VnMlB0MSBdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBwZXJwU2VnMSA9PT0gbGltaXQgKVx0cmV0dXJuIFsgaW5TZWcyUHQyIF07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHJlYWwgaW50ZXJzZWN0aW9uIHBvaW50XHJcbiAgICAgICAgICAgICAgICB2YXIgZmFjdG9yU2VnMSA9IHBlcnBTZWcyIC8gbGltaXQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5cdFsgeyB4OiBpblNlZzFQdDEueCArIGZhY3RvclNlZzEgKiBzZWcxZHgsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogaW5TZWcxUHQxLnkgKyBmYWN0b3JTZWcxICogc2VnMWR5IH0gXTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcGFyYWxsZWwgb3IgY29sbGluZWFyXHJcbiAgICAgICAgICAgICAgICBpZiAoICggcGVycFNlZzEgIT09IDAgKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICggc2VnMmR5ICogc2VnMXNlZzJkeCAhPT0gc2VnMmR4ICogc2VnMXNlZzJkeSApICkgXHRcdFx0cmV0dXJuIFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHRoZXkgYXJlIGNvbGxpbmVhciBvciBkZWdlbmVyYXRlXHJcbiAgICAgICAgICAgICAgICB2YXIgc2VnMVB0ID0gKCAoIHNlZzFkeCA9PT0gMCApICYmICggc2VnMWR5ID09PSAwICkgKTtcdC8vIHNlZ21lbnQxIGlzIGp1c3QgYSBwb2ludD9cclxuICAgICAgICAgICAgICAgIHZhciBzZWcyUHQgPSAoICggc2VnMmR4ID09PSAwICkgJiYgKCBzZWcyZHkgPT09IDAgKSApO1x0Ly8gc2VnbWVudDIgaXMganVzdCBhIHBvaW50P1xyXG4gICAgICAgICAgICAgICAgLy8gYm90aCBzZWdtZW50cyBhcmUgcG9pbnRzXHJcbiAgICAgICAgICAgICAgICBpZiAoIHNlZzFQdCAmJiBzZWcyUHQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggKCBpblNlZzFQdDEueCAhPT0gaW5TZWcyUHQxLnggKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoIGluU2VnMVB0MS55ICE9PSBpblNlZzJQdDEueSApIClcdFx0cmV0dXJuIFtdO1x0Ly8gdGhleSBhcmUgZGlzdGluY3QgIHBvaW50c1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbIGluU2VnMVB0MSBdOyAgICAgICAgICAgICAgICAgXHRcdFx0XHRcdFx0Ly8gdGhleSBhcmUgdGhlIHNhbWUgcG9pbnRcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBzZWdtZW50IzEgIGlzIGEgc2luZ2xlIHBvaW50XHJcbiAgICAgICAgICAgICAgICBpZiAoIHNlZzFQdCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhIHBvaW50X2luX3NlZ21lbnRfMkRfY29saW4oIGluU2VnMlB0MSwgaW5TZWcyUHQyLCBpblNlZzFQdDEgKSApXHRcdHJldHVybiBbXTtcdFx0Ly8gYnV0IG5vdCBpbiBzZWdtZW50IzJcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBpblNlZzFQdDEgXTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBzZWdtZW50IzIgIGlzIGEgc2luZ2xlIHBvaW50XHJcbiAgICAgICAgICAgICAgICBpZiAoIHNlZzJQdCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhIHBvaW50X2luX3NlZ21lbnRfMkRfY29saW4oIGluU2VnMVB0MSwgaW5TZWcxUHQyLCBpblNlZzJQdDEgKSApXHRcdHJldHVybiBbXTtcdFx0Ly8gYnV0IG5vdCBpbiBzZWdtZW50IzFcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBpblNlZzJQdDEgXTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gdGhleSBhcmUgY29sbGluZWFyIHNlZ21lbnRzLCB3aGljaCBtaWdodCBvdmVybGFwXHJcbiAgICAgICAgICAgICAgICB2YXIgc2VnMW1pbiwgc2VnMW1heCwgc2VnMW1pblZhbCwgc2VnMW1heFZhbDtcclxuICAgICAgICAgICAgICAgIHZhciBzZWcybWluLCBzZWcybWF4LCBzZWcybWluVmFsLCBzZWcybWF4VmFsO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBzZWcxZHggIT09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBzZWdtZW50cyBhcmUgTk9UIG9uIGEgdmVydGljYWwgbGluZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggaW5TZWcxUHQxLnggPCBpblNlZzFQdDIueCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzFtaW4gPSBpblNlZzFQdDE7IHNlZzFtaW5WYWwgPSBpblNlZzFQdDEueDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMW1heCA9IGluU2VnMVB0Mjsgc2VnMW1heFZhbCA9IGluU2VnMVB0Mi54O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMW1pbiA9IGluU2VnMVB0Mjsgc2VnMW1pblZhbCA9IGluU2VnMVB0Mi54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcxbWF4ID0gaW5TZWcxUHQxOyBzZWcxbWF4VmFsID0gaW5TZWcxUHQxLng7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGluU2VnMlB0MS54IDwgaW5TZWcyUHQyLnggKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcybWluID0gaW5TZWcyUHQxOyBzZWcybWluVmFsID0gaW5TZWcyUHQxLng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzJtYXggPSBpblNlZzJQdDI7IHNlZzJtYXhWYWwgPSBpblNlZzJQdDIueDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzJtaW4gPSBpblNlZzJQdDI7IHNlZzJtaW5WYWwgPSBpblNlZzJQdDIueDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMm1heCA9IGluU2VnMlB0MTsgc2VnMm1heFZhbCA9IGluU2VnMlB0MS54O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHNlZ21lbnRzIGFyZSBvbiBhIHZlcnRpY2FsIGxpbmVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGluU2VnMVB0MS55IDwgaW5TZWcxUHQyLnkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcxbWluID0gaW5TZWcxUHQxOyBzZWcxbWluVmFsID0gaW5TZWcxUHQxLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzFtYXggPSBpblNlZzFQdDI7IHNlZzFtYXhWYWwgPSBpblNlZzFQdDIueTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzFtaW4gPSBpblNlZzFQdDI7IHNlZzFtaW5WYWwgPSBpblNlZzFQdDIueTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMW1heCA9IGluU2VnMVB0MTsgc2VnMW1heFZhbCA9IGluU2VnMVB0MS55O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpblNlZzJQdDEueSA8IGluU2VnMlB0Mi55ICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnMm1pbiA9IGluU2VnMlB0MTsgc2VnMm1pblZhbCA9IGluU2VnMlB0MS55O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcybWF4ID0gaW5TZWcyUHQyOyBzZWcybWF4VmFsID0gaW5TZWcyUHQyLnk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcybWluID0gaW5TZWcyUHQyOyBzZWcybWluVmFsID0gaW5TZWcyUHQyLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzJtYXggPSBpblNlZzJQdDE7IHNlZzJtYXhWYWwgPSBpblNlZzJQdDEueTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICggc2VnMW1pblZhbCA8PSBzZWcybWluVmFsICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHNlZzFtYXhWYWwgPCAgc2VnMm1pblZhbCApXHRyZXR1cm4gW107XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzZWcxbWF4VmFsID09PSBzZWcybWluVmFsIClcdHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaW5FeGNsdWRlQWRqYWNlbnRTZWdzIClcdFx0cmV0dXJuIFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBzZWcybWluIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHNlZzFtYXhWYWwgPD0gc2VnMm1heFZhbCApXHRyZXR1cm4gWyBzZWcybWluLCBzZWcxbWF4IF07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXHRbIHNlZzJtaW4sIHNlZzJtYXggXTtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHNlZzFtaW5WYWwgPiAgc2VnMm1heFZhbCApXHRyZXR1cm4gW107XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzZWcxbWluVmFsID09PSBzZWcybWF4VmFsIClcdHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaW5FeGNsdWRlQWRqYWNlbnRTZWdzIClcdFx0cmV0dXJuIFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBzZWcxbWluIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHNlZzFtYXhWYWwgPD0gc2VnMm1heFZhbCApXHRyZXR1cm4gWyBzZWcxbWluLCBzZWcxbWF4IF07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXHRbIHNlZzFtaW4sIHNlZzJtYXggXTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaXNQb2ludEluc2lkZUFuZ2xlKCBpblZlcnRleCwgaW5MZWdGcm9tUHQsIGluTGVnVG9QdCwgaW5PdGhlclB0ICkge1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIG9yZGVyIG9mIGxlZ3MgaXMgaW1wb3J0YW50XHJcblxyXG4gICAgICAgICAgICAvLyB0cmFuc2xhdGlvbiBvZiBhbGwgcG9pbnRzLCBzbyB0aGF0IFZlcnRleCBpcyBhdCAoMCwwKVxyXG4gICAgICAgICAgICB2YXIgbGVnRnJvbVB0WFx0PSBpbkxlZ0Zyb21QdC54IC0gaW5WZXJ0ZXgueCwgIGxlZ0Zyb21QdFlcdD0gaW5MZWdGcm9tUHQueSAtIGluVmVydGV4Lnk7XHJcbiAgICAgICAgICAgIHZhciBsZWdUb1B0WFx0PSBpbkxlZ1RvUHQueFx0LSBpblZlcnRleC54LCAgbGVnVG9QdFlcdFx0PSBpbkxlZ1RvUHQueVx0LSBpblZlcnRleC55O1xyXG4gICAgICAgICAgICB2YXIgb3RoZXJQdFhcdD0gaW5PdGhlclB0LnhcdC0gaW5WZXJ0ZXgueCwgIG90aGVyUHRZXHRcdD0gaW5PdGhlclB0LnlcdC0gaW5WZXJ0ZXgueTtcclxuXHJcbiAgICAgICAgICAgIC8vIG1haW4gYW5nbGUgPjA6IDwgMTgwIGRlZy47IDA6IDE4MCBkZWcuOyA8MDogPiAxODAgZGVnLlxyXG4gICAgICAgICAgICB2YXIgZnJvbTJ0b0FuZ2xlXHQ9IGxlZ0Zyb21QdFggKiBsZWdUb1B0WSAtIGxlZ0Zyb21QdFkgKiBsZWdUb1B0WDtcclxuICAgICAgICAgICAgdmFyIGZyb20yb3RoZXJBbmdsZVx0PSBsZWdGcm9tUHRYICogb3RoZXJQdFkgLSBsZWdGcm9tUHRZICogb3RoZXJQdFg7XHJcblxyXG4gICAgICAgICAgICBpZiAoIE1hdGguYWJzKCBmcm9tMnRvQW5nbGUgKSA+IE51bWJlci5FUFNJTE9OICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGFuZ2xlICE9IDE4MCBkZWcuXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG90aGVyMnRvQW5nbGVcdFx0PSBvdGhlclB0WCAqIGxlZ1RvUHRZIC0gb3RoZXJQdFkgKiBsZWdUb1B0WDtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCBcImZyb20ydG86IFwiICsgZnJvbTJ0b0FuZ2xlICsgXCIsIGZyb20yb3RoZXI6IFwiICsgZnJvbTJvdGhlckFuZ2xlICsgXCIsIG90aGVyMnRvOiBcIiArIG90aGVyMnRvQW5nbGUgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGZyb20ydG9BbmdsZSA+IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1haW4gYW5nbGUgPCAxODAgZGVnLlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblx0KCAoIGZyb20yb3RoZXJBbmdsZSA+PSAwICkgJiYgKCBvdGhlcjJ0b0FuZ2xlID49IDAgKSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1haW4gYW5nbGUgPiAxODAgZGVnLlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblx0KCAoIGZyb20yb3RoZXJBbmdsZSA+PSAwICkgfHwgKCBvdGhlcjJ0b0FuZ2xlID49IDAgKSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gYW5nbGUgPT0gMTgwIGRlZy5cclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCBcImZyb20ydG86IDE4MCBkZWcuLCBmcm9tMm90aGVyOiBcIiArIGZyb20yb3RoZXJBbmdsZSAgKTtcclxuICAgICAgICAgICAgICAgIHJldHVyblx0KCBmcm9tMm90aGVyQW5nbGUgPiAwICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZUhvbGVzKCBjb250b3VyLCBob2xlcyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IGNvbnRvdXIuY29uY2F0KCk7IC8vIHdvcmsgb24gdGhpcyBzaGFwZVxyXG4gICAgICAgICAgICB2YXIgaG9sZTtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzQ3V0TGluZUluc2lkZUFuZ2xlcyggaW5TaGFwZUlkeCwgaW5Ib2xlSWR4ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGhvbGUgcG9pbnQgbGllcyB3aXRoaW4gYW5nbGUgYXJvdW5kIHNoYXBlIHBvaW50XHJcbiAgICAgICAgICAgICAgICB2YXIgbGFzdFNoYXBlSWR4ID0gc2hhcGUubGVuZ3RoIC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcHJldlNoYXBlSWR4ID0gaW5TaGFwZUlkeCAtIDE7XHJcbiAgICAgICAgICAgICAgICBpZiAoIHByZXZTaGFwZUlkeCA8IDAgKVx0XHRcdHByZXZTaGFwZUlkeCA9IGxhc3RTaGFwZUlkeDtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFNoYXBlSWR4ID0gaW5TaGFwZUlkeCArIDE7XHJcbiAgICAgICAgICAgICAgICBpZiAoIG5leHRTaGFwZUlkeCA+IGxhc3RTaGFwZUlkeCApXHRuZXh0U2hhcGVJZHggPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBpbnNpZGVBbmdsZSA9IGlzUG9pbnRJbnNpZGVBbmdsZSggc2hhcGVbIGluU2hhcGVJZHggXSwgc2hhcGVbIHByZXZTaGFwZUlkeCBdLCBzaGFwZVsgbmV4dFNoYXBlSWR4IF0sIGhvbGVbIGluSG9sZUlkeCBdICk7XHJcbiAgICAgICAgICAgICAgICBpZiAoICEgaW5zaWRlQW5nbGUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCBcIlZlcnRleCAoU2hhcGUpOiBcIiArIGluU2hhcGVJZHggKyBcIiwgUG9pbnQ6IFwiICsgaG9sZVtpbkhvbGVJZHhdLnggKyBcIi9cIiArIGhvbGVbaW5Ib2xlSWR4XS55ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXHRmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgc2hhcGUgcG9pbnQgbGllcyB3aXRoaW4gYW5nbGUgYXJvdW5kIGhvbGUgcG9pbnRcclxuICAgICAgICAgICAgICAgIHZhciBsYXN0SG9sZUlkeCA9IGhvbGUubGVuZ3RoIC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcHJldkhvbGVJZHggPSBpbkhvbGVJZHggLSAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBwcmV2SG9sZUlkeCA8IDAgKVx0XHRcdHByZXZIb2xlSWR4ID0gbGFzdEhvbGVJZHg7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG5leHRIb2xlSWR4ID0gaW5Ib2xlSWR4ICsgMTtcclxuICAgICAgICAgICAgICAgIGlmICggbmV4dEhvbGVJZHggPiBsYXN0SG9sZUlkeCApXHRuZXh0SG9sZUlkeCA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgaW5zaWRlQW5nbGUgPSBpc1BvaW50SW5zaWRlQW5nbGUoIGhvbGVbIGluSG9sZUlkeCBdLCBob2xlWyBwcmV2SG9sZUlkeCBdLCBob2xlWyBuZXh0SG9sZUlkeCBdLCBzaGFwZVsgaW5TaGFwZUlkeCBdICk7XHJcbiAgICAgICAgICAgICAgICBpZiAoICEgaW5zaWRlQW5nbGUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCBcIlZlcnRleCAoSG9sZSk6IFwiICsgaW5Ib2xlSWR4ICsgXCIsIFBvaW50OiBcIiArIHNoYXBlW2luU2hhcGVJZHhdLnggKyBcIi9cIiArIHNoYXBlW2luU2hhcGVJZHhdLnkgKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cdGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm5cdHRydWU7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBpbnRlcnNlY3RzU2hhcGVFZGdlKCBpblNoYXBlUHQsIGluSG9sZVB0ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrcyBmb3IgaW50ZXJzZWN0aW9ucyB3aXRoIHNoYXBlIGVkZ2VzXHJcbiAgICAgICAgICAgICAgICB2YXIgc0lkeCwgbmV4dElkeCwgaW50ZXJzZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgZm9yICggc0lkeCA9IDA7IHNJZHggPCBzaGFwZS5sZW5ndGg7IHNJZHggKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG5leHRJZHggPSBzSWR4ICsgMTsgbmV4dElkeCAlPSBzaGFwZS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0X3NlZ21lbnRzXzJEKCBpblNoYXBlUHQsIGluSG9sZVB0LCBzaGFwZVsgc0lkeCBdLCBzaGFwZVsgbmV4dElkeCBdLCB0cnVlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCApXHRcdHJldHVyblx0dHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuXHRmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBpbmRlcEhvbGVzID0gW107XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBpbnRlcnNlY3RzSG9sZUVkZ2UoIGluU2hhcGVQdCwgaW5Ib2xlUHQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2tzIGZvciBpbnRlcnNlY3Rpb25zIHdpdGggaG9sZSBlZGdlc1xyXG4gICAgICAgICAgICAgICAgdmFyIGloSWR4LCBjaGtIb2xlLFxyXG4gICAgICAgICAgICAgICAgICAgIGhJZHgsIG5leHRJZHgsIGludGVyc2VjdGlvbjtcclxuICAgICAgICAgICAgICAgIGZvciAoIGloSWR4ID0gMDsgaWhJZHggPCBpbmRlcEhvbGVzLmxlbmd0aDsgaWhJZHggKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNoa0hvbGUgPSBob2xlc1sgaW5kZXBIb2xlc1sgaWhJZHggXV07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggaElkeCA9IDA7IGhJZHggPCBjaGtIb2xlLmxlbmd0aDsgaElkeCArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRJZHggPSBoSWR4ICsgMTsgbmV4dElkeCAlPSBjaGtIb2xlLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0X3NlZ21lbnRzXzJEKCBpblNoYXBlUHQsIGluSG9sZVB0LCBjaGtIb2xlWyBoSWR4IF0sIGNoa0hvbGVbIG5leHRJZHggXSwgdHJ1ZSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGludGVyc2VjdGlvbi5sZW5ndGggPiAwIClcdFx0cmV0dXJuXHR0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuXHRmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBob2xlSW5kZXgsIHNoYXBlSW5kZXgsXHJcbiAgICAgICAgICAgICAgICBzaGFwZVB0LCBob2xlUHQsXHJcbiAgICAgICAgICAgICAgICBob2xlSWR4LCBjdXRLZXksIGZhaWxlZEN1dHMgPSBbXSxcclxuICAgICAgICAgICAgICAgIHRtcFNoYXBlMSwgdG1wU2hhcGUyLFxyXG4gICAgICAgICAgICAgICAgdG1wSG9sZTEsIHRtcEhvbGUyO1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGluZGVwSG9sZXMucHVzaCggaCApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIG1pblNoYXBlSW5kZXggPSAwO1xyXG4gICAgICAgICAgICB2YXIgY291bnRlciA9IGluZGVwSG9sZXMubGVuZ3RoICogMjtcclxuICAgICAgICAgICAgd2hpbGUgKCBpbmRlcEhvbGVzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY291bnRlciAtLTtcclxuICAgICAgICAgICAgICAgIGlmICggY291bnRlciA8IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCBcIkluZmluaXRlIExvb3AhIEhvbGVzIGxlZnQ6XCIgKyBpbmRlcEhvbGVzLmxlbmd0aCArIFwiLCBQcm9iYWJseSBIb2xlIG91dHNpZGUgU2hhcGUhXCIgKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gc2VhcmNoIGZvciBzaGFwZS12ZXJ0ZXggYW5kIGhvbGUtdmVydGV4LFxyXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggY2FuIGJlIGNvbm5lY3RlZCB3aXRob3V0IGludGVyc2VjdGlvbnNcclxuICAgICAgICAgICAgICAgIGZvciAoIHNoYXBlSW5kZXggPSBtaW5TaGFwZUluZGV4OyBzaGFwZUluZGV4IDwgc2hhcGUubGVuZ3RoOyBzaGFwZUluZGV4ICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzaGFwZVB0ID0gc2hhcGVbIHNoYXBlSW5kZXggXTtcclxuICAgICAgICAgICAgICAgICAgICBob2xlSW5kZXhcdD0gLSAxO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBzZWFyY2ggZm9yIGhvbGUgd2hpY2ggY2FuIGJlIHJlYWNoZWQgd2l0aG91dCBpbnRlcnNlY3Rpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGggPSAwOyBoIDwgaW5kZXBIb2xlcy5sZW5ndGg7IGggKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBob2xlSWR4ID0gaW5kZXBIb2xlc1sgaCBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJldmVudCBtdWx0aXBsZSBjaGVja3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3V0S2V5ID0gc2hhcGVQdC54ICsgXCI6XCIgKyBzaGFwZVB0LnkgKyBcIjpcIiArIGhvbGVJZHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZmFpbGVkQ3V0c1sgY3V0S2V5IF0gIT09IHVuZGVmaW5lZCApXHRcdFx0Y29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBob2xlID0gaG9sZXNbIGhvbGVJZHggXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGgyID0gMDsgaDIgPCBob2xlLmxlbmd0aDsgaDIgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZVB0ID0gaG9sZVsgaDIgXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggISBpc0N1dExpbmVJbnNpZGVBbmdsZXMoIHNoYXBlSW5kZXgsIGgyICkgKVx0XHRjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaW50ZXJzZWN0c1NoYXBlRWRnZSggc2hhcGVQdCwgaG9sZVB0ICkgKVx0XHRjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaW50ZXJzZWN0c0hvbGVFZGdlKCBzaGFwZVB0LCBob2xlUHQgKSApXHRcdGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGVJbmRleCA9IGgyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXBIb2xlcy5zcGxpY2UoIGgsIDEgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBTaGFwZTEgPSBzaGFwZS5zbGljZSggMCwgc2hhcGVJbmRleCArIDEgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcFNoYXBlMiA9IHNoYXBlLnNsaWNlKCBzaGFwZUluZGV4ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBIb2xlMSA9IGhvbGUuc2xpY2UoIGhvbGVJbmRleCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wSG9sZTIgPSBob2xlLnNsaWNlKCAwLCBob2xlSW5kZXggKyAxICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGUgPSB0bXBTaGFwZTEuY29uY2F0KCB0bXBIb2xlMSApLmNvbmNhdCggdG1wSG9sZTIgKS5jb25jYXQoIHRtcFNoYXBlMiApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pblNoYXBlSW5kZXggPSBzaGFwZUluZGV4O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlYnVnIG9ubHksIHRvIHNob3cgdGhlIHNlbGVjdGVkIGN1dHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdsb2JfQ3V0TGluZXMucHVzaCggWyBzaGFwZVB0LCBob2xlUHQgXSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGhvbGVJbmRleCA+PSAwIClcdGJyZWFrO1x0XHQvLyBob2xlLXZlcnRleCBmb3VuZFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbGVkQ3V0c1sgY3V0S2V5IF0gPSB0cnVlO1x0XHRcdC8vIHJlbWVtYmVyIGZhaWx1cmVcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggaG9sZUluZGV4ID49IDAgKVx0YnJlYWs7XHRcdC8vIGhvbGUtdmVydGV4IGZvdW5kXHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHNoYXBlOyBcdFx0XHQvKiBzaGFwZSB3aXRoIG5vIGhvbGVzICovXHJcblxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIHZhciBpLCBpbCwgZiwgZmFjZSxcclxuICAgICAgICAgICAga2V5LCBpbmRleCxcclxuICAgICAgICAgICAgYWxsUG9pbnRzTWFwID0ge307XHJcblxyXG4gICAgICAgIC8vIFRvIG1haW50YWluIHJlZmVyZW5jZSB0byBvbGQgc2hhcGUsIG9uZSBtdXN0IG1hdGNoIGNvb3JkaW5hdGVzLCBvciBvZmZzZXQgdGhlIGluZGljZXMgZnJvbSBvcmlnaW5hbCBhcnJheXMuIEl0J3MgcHJvYmFibHkgZWFzaWVyIHRvIGRvIHRoZSBmaXJzdC5cclxuXHJcbiAgICAgICAgdmFyIGFsbHBvaW50cyA9IGNvbnRvdXIuY29uY2F0KCk7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcclxuXHJcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KCBhbGxwb2ludHMsIGhvbGVzWyBoIF0gKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCBcImFsbHBvaW50c1wiLGFsbHBvaW50cywgYWxscG9pbnRzLmxlbmd0aCApO1xyXG5cclxuICAgICAgICAvLyBwcmVwYXJlIGFsbCBwb2ludHMgbWFwXHJcblxyXG4gICAgICAgIGZvciAoIGkgPSAwLCBpbCA9IGFsbHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIGtleSA9IGFsbHBvaW50c1sgaSBdLnggKyBcIjpcIiArIGFsbHBvaW50c1sgaSBdLnk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGFsbFBvaW50c01hcFsga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oIFwiVEhSRUUuU2hhcGU6IER1cGxpY2F0ZSBwb2ludFwiLCBrZXkgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGFsbFBvaW50c01hcFsga2V5IF0gPSBpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJlbW92ZSBob2xlcyBieSBjdXR0aW5nIHBhdGhzIHRvIGhvbGVzIGFuZCBhZGRpbmcgdGhlbSB0byB0aGUgc2hhcGVcclxuICAgICAgICB2YXIgc2hhcGVXaXRob3V0SG9sZXMgPSByZW1vdmVIb2xlcyggY29udG91ciwgaG9sZXMgKTtcclxuXHJcbiAgICAgICAgdmFyIHRyaWFuZ2xlcyA9IFRIUkVFLlNoYXBlVXRpbHMudHJpYW5ndWxhdGUoIHNoYXBlV2l0aG91dEhvbGVzLCBmYWxzZSApOyAvLyBUcnVlIHJldHVybnMgaW5kaWNlcyBmb3IgcG9pbnRzIG9mIHNwb29sZWQgc2hhcGVcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCBcInRyaWFuZ2xlc1wiLHRyaWFuZ2xlcywgdHJpYW5nbGVzLmxlbmd0aCApO1xyXG5cclxuICAgICAgICAvLyBjaGVjayBhbGwgZmFjZSB2ZXJ0aWNlcyBhZ2FpbnN0IGFsbCBwb2ludHMgbWFwXHJcblxyXG4gICAgICAgIGZvciAoIGkgPSAwLCBpbCA9IHRyaWFuZ2xlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIGZhY2UgPSB0cmlhbmdsZXNbIGkgXTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIGYgPSAwOyBmIDwgMzsgZiArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBrZXkgPSBmYWNlWyBmIF0ueCArIFwiOlwiICsgZmFjZVsgZiBdLnk7XHJcblxyXG4gICAgICAgICAgICAgICAgaW5kZXggPSBhbGxQb2ludHNNYXBbIGtleSBdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggaW5kZXggIT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZmFjZVsgZiBdID0gaW5kZXg7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cmlhbmdsZXMuY29uY2F0KCk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBpc0Nsb2NrV2lzZTogZnVuY3Rpb24gKCBwdHMgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBUSFJFRS5TaGFwZVV0aWxzLmFyZWEoIHB0cyApIDwgMDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEJlemllciBDdXJ2ZXMgZm9ybXVsYXMgb2J0YWluZWQgZnJvbVxyXG4gICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CJUMzJUE5emllcl9jdXJ2ZVxyXG5cclxuICAgIC8vIFF1YWQgQmV6aWVyIEZ1bmN0aW9uc1xyXG5cclxuICAgIGIyOiAoIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gYjJwMCggdCwgcCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBrID0gMSAtIHQ7XHJcbiAgICAgICAgICAgIHJldHVybiBrICogayAqIHA7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gYjJwMSggdCwgcCApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAyICogKCAxIC0gdCApICogdCAqIHA7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gYjJwMiggdCwgcCApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0ICogdCAqIHA7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggdCwgcDAsIHAxLCBwMiApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBiMnAwKCB0LCBwMCApICsgYjJwMSggdCwgcDEgKSArIGIycDIoIHQsIHAyICk7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSApKCksXHJcblxyXG4gICAgLy8gQ3ViaWMgQmV6aWVyIEZ1bmN0aW9uc1xyXG5cclxuICAgIGIzOiAoIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gYjNwMCggdCwgcCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBrID0gMSAtIHQ7XHJcbiAgICAgICAgICAgIHJldHVybiBrICogayAqIGsgKiBwO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGIzcDEoIHQsIHAgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgayA9IDEgLSB0O1xyXG4gICAgICAgICAgICByZXR1cm4gMyAqIGsgKiBrICogdCAqIHA7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gYjNwMiggdCwgcCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBrID0gMSAtIHQ7XHJcbiAgICAgICAgICAgIHJldHVybiAzICogayAqIHQgKiB0ICogcDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBiM3AzKCB0LCBwICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHQgKiB0ICogdCAqIHA7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggdCwgcDAsIHAxLCBwMiwgcDMgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYjNwMCggdCwgcDAgKSArIGIzcDEoIHQsIHAxICkgKyBiM3AyKCB0LCBwMiApICsgYjNwMyggdCwgcDMgKTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9ICkoKVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9hdWRpby9BdWRpby5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQXVkaW8gPSBmdW5jdGlvbiAoIGxpc3RlbmVyICkge1xyXG5cclxuICAgIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnQXVkaW8nO1xyXG5cclxuICAgIHRoaXMuY29udGV4dCA9IGxpc3RlbmVyLmNvbnRleHQ7XHJcbiAgICB0aGlzLnNvdXJjZSA9IHRoaXMuY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcclxuICAgIHRoaXMuc291cmNlLm9uZW5kZWQgPSB0aGlzLm9uRW5kZWQuYmluZCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMuZ2FpbiA9IHRoaXMuY29udGV4dC5jcmVhdGVHYWluKCk7XHJcbiAgICB0aGlzLmdhaW4uY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XHJcblxyXG4gICAgdGhpcy5wYW5uZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlUGFubmVyKCk7XHJcbiAgICB0aGlzLnBhbm5lci5jb25uZWN0KCB0aGlzLmdhaW4gKTtcclxuXHJcbiAgICB0aGlzLmF1dG9wbGF5ID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5zdGFydFRpbWUgPSAwO1xyXG4gICAgdGhpcy5wbGF5YmFja1JhdGUgPSAxO1xyXG4gICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpby5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQXVkaW87XHJcblxyXG5USFJFRS5BdWRpby5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICggZmlsZSApIHtcclxuXHJcbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICByZXF1ZXN0Lm9wZW4oICdHRVQnLCBmaWxlLCB0cnVlICk7XHJcbiAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XHJcbiAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uICggZSApIHtcclxuXHJcbiAgICAgICAgc2NvcGUuY29udGV4dC5kZWNvZGVBdWRpb0RhdGEoIHRoaXMucmVzcG9uc2UsIGZ1bmN0aW9uICggYnVmZmVyICkge1xyXG5cclxuICAgICAgICAgICAgc2NvcGUuc291cmNlLmJ1ZmZlciA9IGJ1ZmZlcjtcclxuXHJcbiAgICAgICAgICAgIGlmICggc2NvcGUuYXV0b3BsYXkgKSBzY29wZS5wbGF5KCk7XHJcblxyXG4gICAgICAgIH0gKTtcclxuXHJcbiAgICB9O1xyXG4gICAgcmVxdWVzdC5zZW5kKCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgaWYgKCB0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSApIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IEF1ZGlvIGlzIGFscmVhZHkgcGxheWluZy4nICk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB2YXIgc291cmNlID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xyXG5cclxuICAgIHNvdXJjZS5idWZmZXIgPSB0aGlzLnNvdXJjZS5idWZmZXI7XHJcbiAgICBzb3VyY2UubG9vcCA9IHRoaXMuc291cmNlLmxvb3A7XHJcbiAgICBzb3VyY2Uub25lbmRlZCA9IHRoaXMuc291cmNlLm9uZW5kZWQ7XHJcbiAgICBzb3VyY2Uuc3RhcnQoIDAsIHRoaXMuc3RhcnRUaW1lICk7XHJcbiAgICBzb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlID0gdGhpcy5wbGF5YmFja1JhdGU7XHJcblxyXG4gICAgdGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xyXG5cclxuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG5cclxuICAgIHRoaXMuY29ubmVjdCgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB0aGlzLnNvdXJjZS5zdG9wKCk7XHJcbiAgICB0aGlzLnN0YXJ0VGltZSA9IHRoaXMuY29udGV4dC5jdXJyZW50VGltZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpby5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB0aGlzLnNvdXJjZS5zdG9wKCk7XHJcbiAgICB0aGlzLnN0YXJ0VGltZSA9IDA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgaWYgKCB0aGlzLmZpbHRlciAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICB0aGlzLnNvdXJjZS5jb25uZWN0KCB0aGlzLmZpbHRlciApO1xyXG4gICAgICAgIHRoaXMuZmlsdGVyLmNvbm5lY3QoIHRoaXMucGFubmVyICk7XHJcblxyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgdGhpcy5zb3VyY2UuY29ubmVjdCggdGhpcy5wYW5uZXIgKTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgaWYgKCB0aGlzLmZpbHRlciAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICB0aGlzLnNvdXJjZS5kaXNjb25uZWN0KCB0aGlzLmZpbHRlciApO1xyXG4gICAgICAgIHRoaXMuZmlsdGVyLmRpc2Nvbm5lY3QoIHRoaXMucGFubmVyICk7XHJcblxyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgdGhpcy5zb3VyY2UuZGlzY29ubmVjdCggdGhpcy5wYW5uZXIgKTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnNldEZpbHRlciA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG4gICAgaWYgKCB0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgdGhpcy5maWx0ZXIgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmNvbm5lY3QoKTtcclxuXHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICB0aGlzLmZpbHRlciA9IHZhbHVlO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpby5wcm90b3R5cGUuZ2V0RmlsdGVyID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHJldHVybiB0aGlzLmZpbHRlcjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpby5wcm90b3R5cGUuc2V0UGxheWJhY2tSYXRlID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcbiAgICB0aGlzLnBsYXliYWNrUmF0ZSA9IHZhbHVlO1xyXG5cclxuICAgIGlmICggdGhpcy5pc1BsYXlpbmcgPT09IHRydWUgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuc291cmNlLnBsYXliYWNrUmF0ZS52YWx1ZSA9IHRoaXMucGxheWJhY2tSYXRlO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpby5wcm90b3R5cGUuZ2V0UGxheWJhY2tSYXRlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHJldHVybiB0aGlzLnBsYXliYWNrUmF0ZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpby5wcm90b3R5cGUub25FbmRlZCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnNldExvb3AgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuICAgIHRoaXMuc291cmNlLmxvb3AgPSB2YWx1ZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpby5wcm90b3R5cGUuZ2V0TG9vcCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5zb3VyY2UubG9vcDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpby5wcm90b3R5cGUuc2V0UmVmRGlzdGFuY2UgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuICAgIHRoaXMucGFubmVyLnJlZkRpc3RhbmNlID0gdmFsdWU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLmdldFJlZkRpc3RhbmNlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHJldHVybiB0aGlzLnBhbm5lci5yZWZEaXN0YW5jZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpby5wcm90b3R5cGUuc2V0Um9sbG9mZkZhY3RvciA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG4gICAgdGhpcy5wYW5uZXIucm9sbG9mZkZhY3RvciA9IHZhbHVlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5nZXRSb2xsb2ZmRmFjdG9yID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHJldHVybiB0aGlzLnBhbm5lci5yb2xsb2ZmRmFjdG9yO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zZXRWb2x1bWUgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuICAgIHRoaXMuZ2Fpbi5nYWluLnZhbHVlID0gdmFsdWU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLmdldFZvbHVtZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5nYWluLmdhaW4udmFsdWU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkID0gKCBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICkge1xyXG5cclxuICAgICAgICBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgZm9yY2UgKTtcclxuXHJcbiAgICAgICAgcG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XHJcblxyXG4gICAgICAgIHRoaXMucGFubmVyLnNldFBvc2l0aW9uKCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56ICk7XHJcblxyXG4gICAgfTtcclxuXHJcbn0gKSgpO1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2F1ZGlvL0F1ZGlvTGlzdGVuZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkF1ZGlvTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdBdWRpb0xpc3RlbmVyJztcclxuXHJcbiAgICB0aGlzLmNvbnRleHQgPSBuZXcgKCB3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQgKSgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvTGlzdGVuZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblRIUkVFLkF1ZGlvTGlzdGVuZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQXVkaW9MaXN0ZW5lcjtcclxuXHJcblRIUkVFLkF1ZGlvTGlzdGVuZXIucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkID0gKCBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgIHZhciBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcclxuICAgIHZhciBzY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgdmFyIG9yaWVudGF0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICkge1xyXG5cclxuICAgICAgICBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgZm9yY2UgKTtcclxuXHJcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gdGhpcy5jb250ZXh0Lmxpc3RlbmVyO1xyXG4gICAgICAgIHZhciB1cCA9IHRoaXMudXA7XHJcblxyXG4gICAgICAgIHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKTtcclxuXHJcbiAgICAgICAgb3JpZW50YXRpb24uc2V0KCAwLCAwLCAtIDEgKS5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcclxuXHJcbiAgICAgICAgbGlzdGVuZXIuc2V0UG9zaXRpb24oIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnogKTtcclxuICAgICAgICBsaXN0ZW5lci5zZXRPcmllbnRhdGlvbiggb3JpZW50YXRpb24ueCwgb3JpZW50YXRpb24ueSwgb3JpZW50YXRpb24ueiwgdXAueCwgdXAueSwgdXAueiApO1xyXG5cclxuICAgIH07XHJcblxyXG59ICkoKTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9jb3JlL0N1cnZlLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKiBFeHRlbnNpYmxlIGN1cnZlIG9iamVjdFxyXG4gKlxyXG4gKiBTb21lIGNvbW1vbiBvZiBDdXJ2ZSBtZXRob2RzXHJcbiAqIC5nZXRQb2ludCh0KSwgZ2V0VGFuZ2VudCh0KVxyXG4gKiAuZ2V0UG9pbnRBdCh1KSwgZ2V0VGFnZW50QXQodSlcclxuICogLmdldFBvaW50cygpLCAuZ2V0U3BhY2VkUG9pbnRzKClcclxuICogLmdldExlbmd0aCgpXHJcbiAqIC51cGRhdGVBcmNMZW5ndGhzKClcclxuICpcclxuICogVGhpcyBmb2xsb3dpbmcgY2xhc3NlcyBzdWJjbGFzc2VzIFRIUkVFLkN1cnZlOlxyXG4gKlxyXG4gKiAtLSAyZCBjbGFzc2VzIC0tXHJcbiAqIFRIUkVFLkxpbmVDdXJ2ZVxyXG4gKiBUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZVxyXG4gKiBUSFJFRS5DdWJpY0JlemllckN1cnZlXHJcbiAqIFRIUkVFLlNwbGluZUN1cnZlXHJcbiAqIFRIUkVFLkFyY0N1cnZlXHJcbiAqIFRIUkVFLkVsbGlwc2VDdXJ2ZVxyXG4gKlxyXG4gKiAtLSAzZCBjbGFzc2VzIC0tXHJcbiAqIFRIUkVFLkxpbmVDdXJ2ZTNcclxuICogVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUzXHJcbiAqIFRIUkVFLkN1YmljQmV6aWVyQ3VydmUzXHJcbiAqIFRIUkVFLlNwbGluZUN1cnZlM1xyXG4gKiBUSFJFRS5DbG9zZWRTcGxpbmVDdXJ2ZTNcclxuICpcclxuICogQSBzZXJpZXMgb2YgY3VydmVzIGNhbiBiZSByZXByZXNlbnRlZCBhcyBhIFRIUkVFLkN1cnZlUGF0aFxyXG4gKlxyXG4gKiovXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdEFic3RyYWN0IEN1cnZlIGJhc2UgY2xhc3NcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuVEhSRUUuQ3VydmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ3VydmUucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBUSFJFRS5DdXJ2ZSxcclxuXHJcbiAgICAvLyBWaXJ0dWFsIGJhc2UgY2xhc3MgbWV0aG9kIHRvIG92ZXJ3cml0ZSBhbmQgaW1wbGVtZW50IGluIHN1YmNsYXNzZXNcclxuICAgIC8vXHQtIHQgWzAgLi4gMV1cclxuXHJcbiAgICBnZXRQb2ludDogZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oIFwiVEhSRUUuQ3VydmU6IFdhcm5pbmcsIGdldFBvaW50KCkgbm90IGltcGxlbWVudGVkIVwiICk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBHZXQgcG9pbnQgYXQgcmVsYXRpdmUgcG9zaXRpb24gaW4gY3VydmUgYWNjb3JkaW5nIHRvIGFyYyBsZW5ndGhcclxuICAgIC8vIC0gdSBbMCAuLiAxXVxyXG5cclxuICAgIGdldFBvaW50QXQ6IGZ1bmN0aW9uICggdSApIHtcclxuXHJcbiAgICAgICAgdmFyIHQgPSB0aGlzLmdldFV0b1RtYXBwaW5nKCB1ICk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnQoIHQgKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEdldCBzZXF1ZW5jZSBvZiBwb2ludHMgdXNpbmcgZ2V0UG9pbnQoIHQgKVxyXG5cclxuICAgIGdldFBvaW50czogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XHJcblxyXG4gICAgICAgIGlmICggISBkaXZpc2lvbnMgKSBkaXZpc2lvbnMgPSA1O1xyXG5cclxuICAgICAgICB2YXIgZCwgcHRzID0gW107XHJcblxyXG4gICAgICAgIGZvciAoIGQgPSAwOyBkIDw9IGRpdmlzaW9uczsgZCArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCB0aGlzLmdldFBvaW50KCBkIC8gZGl2aXNpb25zICkgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcHRzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLy8gR2V0IHNlcXVlbmNlIG9mIHBvaW50cyB1c2luZyBnZXRQb2ludEF0KCB1IClcclxuXHJcbiAgICBnZXRTcGFjZWRQb2ludHM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xyXG5cclxuICAgICAgICBpZiAoICEgZGl2aXNpb25zICkgZGl2aXNpb25zID0gNTtcclxuXHJcbiAgICAgICAgdmFyIGQsIHB0cyA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKCBkID0gMDsgZCA8PSBkaXZpc2lvbnM7IGQgKysgKSB7XHJcblxyXG4gICAgICAgICAgICBwdHMucHVzaCggdGhpcy5nZXRQb2ludEF0KCBkIC8gZGl2aXNpb25zICkgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcHRzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLy8gR2V0IHRvdGFsIGN1cnZlIGFyYyBsZW5ndGhcclxuXHJcbiAgICBnZXRMZW5ndGg6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIGxlbmd0aHMgPSB0aGlzLmdldExlbmd0aHMoKTtcclxuICAgICAgICByZXR1cm4gbGVuZ3Roc1sgbGVuZ3Rocy5sZW5ndGggLSAxIF07XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBHZXQgbGlzdCBvZiBjdW11bGF0aXZlIHNlZ21lbnQgbGVuZ3Roc1xyXG5cclxuICAgIGdldExlbmd0aHM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xyXG5cclxuICAgICAgICBpZiAoICEgZGl2aXNpb25zICkgZGl2aXNpb25zID0gKCB0aGlzLl9fYXJjTGVuZ3RoRGl2aXNpb25zICkgPyAoIHRoaXMuX19hcmNMZW5ndGhEaXZpc2lvbnMgKSA6IDIwMDtcclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLmNhY2hlQXJjTGVuZ3Roc1xyXG4gICAgICAgICAgICAmJiAoIHRoaXMuY2FjaGVBcmNMZW5ndGhzLmxlbmd0aCA9PT0gZGl2aXNpb25zICsgMSApXHJcbiAgICAgICAgICAgICYmICEgdGhpcy5uZWVkc1VwZGF0ZSApIHtcclxuXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coIFwiY2FjaGVkXCIsIHRoaXMuY2FjaGVBcmNMZW5ndGhzICk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlQXJjTGVuZ3RocztcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHZhciBjYWNoZSA9IFtdO1xyXG4gICAgICAgIHZhciBjdXJyZW50LCBsYXN0ID0gdGhpcy5nZXRQb2ludCggMCApO1xyXG4gICAgICAgIHZhciBwLCBzdW0gPSAwO1xyXG5cclxuICAgICAgICBjYWNoZS5wdXNoKCAwICk7XHJcblxyXG4gICAgICAgIGZvciAoIHAgPSAxOyBwIDw9IGRpdmlzaW9uczsgcCArKyApIHtcclxuXHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLmdldFBvaW50ICggcCAvIGRpdmlzaW9ucyApO1xyXG4gICAgICAgICAgICBzdW0gKz0gY3VycmVudC5kaXN0YW5jZVRvKCBsYXN0ICk7XHJcbiAgICAgICAgICAgIGNhY2hlLnB1c2goIHN1bSApO1xyXG4gICAgICAgICAgICBsYXN0ID0gY3VycmVudDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmNhY2hlQXJjTGVuZ3RocyA9IGNhY2hlO1xyXG5cclxuICAgICAgICByZXR1cm4gY2FjaGU7IC8vIHsgc3VtczogY2FjaGUsIHN1bTpzdW0gfTsgU3VtIGlzIGluIHRoZSBsYXN0IGVsZW1lbnQuXHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVBcmNMZW5ndGhzOiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5nZXRMZW5ndGhzKCk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBHaXZlbiB1ICggMCAuLiAxICksIGdldCBhIHQgdG8gZmluZCBwLiBUaGlzIGdpdmVzIHlvdSBwb2ludHMgd2hpY2ggYXJlIGVxdWlkaXN0YW50XHJcblxyXG4gICAgZ2V0VXRvVG1hcHBpbmc6IGZ1bmN0aW9uICggdSwgZGlzdGFuY2UgKSB7XHJcblxyXG4gICAgICAgIHZhciBhcmNMZW5ndGhzID0gdGhpcy5nZXRMZW5ndGhzKCk7XHJcblxyXG4gICAgICAgIHZhciBpID0gMCwgaWwgPSBhcmNMZW5ndGhzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgdmFyIHRhcmdldEFyY0xlbmd0aDsgLy8gVGhlIHRhcmdldGVkIHUgZGlzdGFuY2UgdmFsdWUgdG8gZ2V0XHJcblxyXG4gICAgICAgIGlmICggZGlzdGFuY2UgKSB7XHJcblxyXG4gICAgICAgICAgICB0YXJnZXRBcmNMZW5ndGggPSBkaXN0YW5jZTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIHRhcmdldEFyY0xlbmd0aCA9IHUgKiBhcmNMZW5ndGhzWyBpbCAtIDEgXTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3ZhciB0aW1lID0gRGF0ZS5ub3coKTtcclxuXHJcbiAgICAgICAgLy8gYmluYXJ5IHNlYXJjaCBmb3IgdGhlIGluZGV4IHdpdGggbGFyZ2VzdCB2YWx1ZSBzbWFsbGVyIHRoYW4gdGFyZ2V0IHUgZGlzdGFuY2VcclxuXHJcbiAgICAgICAgdmFyIGxvdyA9IDAsIGhpZ2ggPSBpbCAtIDEsIGNvbXBhcmlzb247XHJcblxyXG4gICAgICAgIHdoaWxlICggbG93IDw9IGhpZ2ggKSB7XHJcblxyXG4gICAgICAgICAgICBpID0gTWF0aC5mbG9vciggbG93ICsgKCBoaWdoIC0gbG93ICkgLyAyICk7IC8vIGxlc3MgbGlrZWx5IHRvIG92ZXJmbG93LCB0aG91Z2ggcHJvYmFibHkgbm90IGlzc3VlIGhlcmUsIEpTIGRvZXNuJ3QgcmVhbGx5IGhhdmUgaW50ZWdlcnMsIGFsbCBudW1iZXJzIGFyZSBmbG9hdHNcclxuXHJcbiAgICAgICAgICAgIGNvbXBhcmlzb24gPSBhcmNMZW5ndGhzWyBpIF0gLSB0YXJnZXRBcmNMZW5ndGg7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGNvbXBhcmlzb24gPCAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGxvdyA9IGkgKyAxO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIGlmICggY29tcGFyaXNvbiA+IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaGlnaCA9IGkgLSAxO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICBoaWdoID0gaTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIERPTkVcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpID0gaGlnaDtcclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnYicgLCBpLCBsb3csIGhpZ2gsIERhdGUubm93KCktIHRpbWUpO1xyXG5cclxuICAgICAgICBpZiAoIGFyY0xlbmd0aHNbIGkgXSA9PT0gdGFyZ2V0QXJjTGVuZ3RoICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHQgPSBpIC8gKCBpbCAtIDEgKTtcclxuICAgICAgICAgICAgcmV0dXJuIHQ7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gd2UgY291bGQgZ2V0IGZpbmVyIGdyYWluIGF0IGxlbmd0aHMsIG9yIHVzZSBzaW1wbGUgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcclxuXHJcbiAgICAgICAgdmFyIGxlbmd0aEJlZm9yZSA9IGFyY0xlbmd0aHNbIGkgXTtcclxuICAgICAgICB2YXIgbGVuZ3RoQWZ0ZXIgPSBhcmNMZW5ndGhzWyBpICsgMSBdO1xyXG5cclxuICAgICAgICB2YXIgc2VnbWVudExlbmd0aCA9IGxlbmd0aEFmdGVyIC0gbGVuZ3RoQmVmb3JlO1xyXG5cclxuICAgICAgICAvLyBkZXRlcm1pbmUgd2hlcmUgd2UgYXJlIGJldHdlZW4gdGhlICdiZWZvcmUnIGFuZCAnYWZ0ZXInIHBvaW50c1xyXG5cclxuICAgICAgICB2YXIgc2VnbWVudEZyYWN0aW9uID0gKCB0YXJnZXRBcmNMZW5ndGggLSBsZW5ndGhCZWZvcmUgKSAvIHNlZ21lbnRMZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIGFkZCB0aGF0IGZyYWN0aW9uYWwgYW1vdW50IHRvIHRcclxuXHJcbiAgICAgICAgdmFyIHQgPSAoIGkgKyBzZWdtZW50RnJhY3Rpb24gKSAvICggaWwgLSAxICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLy8gUmV0dXJucyBhIHVuaXQgdmVjdG9yIHRhbmdlbnQgYXQgdFxyXG4gICAgLy8gSW4gY2FzZSBhbnkgc3ViIGN1cnZlIGRvZXMgbm90IGltcGxlbWVudCBpdHMgdGFuZ2VudCBkZXJpdmF0aW9uLFxyXG4gICAgLy8gMiBwb2ludHMgYSBzbWFsbCBkZWx0YSBhcGFydCB3aWxsIGJlIHVzZWQgdG8gZmluZCBpdHMgZ3JhZGllbnRcclxuICAgIC8vIHdoaWNoIHNlZW1zIHRvIGdpdmUgYSByZWFzb25hYmxlIGFwcHJveGltYXRpb25cclxuXHJcbiAgICBnZXRUYW5nZW50OiBmdW5jdGlvbiggdCApIHtcclxuXHJcbiAgICAgICAgdmFyIGRlbHRhID0gMC4wMDAxO1xyXG4gICAgICAgIHZhciB0MSA9IHQgLSBkZWx0YTtcclxuICAgICAgICB2YXIgdDIgPSB0ICsgZGVsdGE7XHJcblxyXG4gICAgICAgIC8vIENhcHBpbmcgaW4gY2FzZSBvZiBkYW5nZXJcclxuXHJcbiAgICAgICAgaWYgKCB0MSA8IDAgKSB0MSA9IDA7XHJcbiAgICAgICAgaWYgKCB0MiA+IDEgKSB0MiA9IDE7XHJcblxyXG4gICAgICAgIHZhciBwdDEgPSB0aGlzLmdldFBvaW50KCB0MSApO1xyXG4gICAgICAgIHZhciBwdDIgPSB0aGlzLmdldFBvaW50KCB0MiApO1xyXG5cclxuICAgICAgICB2YXIgdmVjID0gcHQyLmNsb25lKCkuc3ViKCBwdDEgKTtcclxuICAgICAgICByZXR1cm4gdmVjLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VGFuZ2VudEF0OiBmdW5jdGlvbiAoIHUgKSB7XHJcblxyXG4gICAgICAgIHZhciB0ID0gdGhpcy5nZXRVdG9UbWFwcGluZyggdSApO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFRhbmdlbnQoIHQgKTtcclxuXHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5USFJFRS5DdXJ2ZS5VdGlscyA9IFRIUkVFLkN1cnZlVXRpbHM7IC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcblxyXG4vLyBUT0RPOiBUcmFuc2Zvcm1hdGlvbiBmb3IgQ3VydmVzP1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHQzRCBDdXJ2ZXNcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuLy8gQSBGYWN0b3J5IG1ldGhvZCBmb3IgY3JlYXRpbmcgbmV3IGN1cnZlIHN1YmNsYXNzZXNcclxuXHJcblRIUkVFLkN1cnZlLmNyZWF0ZSA9IGZ1bmN0aW9uICggY29uc3RydWN0b3IsIGdldFBvaW50RnVuYyApIHtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcclxuICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yO1xyXG4gICAgY29uc3RydWN0b3IucHJvdG90eXBlLmdldFBvaW50ID0gZ2V0UG9pbnRGdW5jO1xyXG5cclxuICAgIHJldHVybiBjb25zdHJ1Y3RvcjtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvY29yZS9DdXJ2ZVBhdGguanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqXHJcbiAqKi9cclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0Q3VydmVkIFBhdGggLSBhIGN1cnZlIHBhdGggaXMgc2ltcGx5IGEgYXJyYXkgb2YgY29ubmVjdGVkXHJcbiAqICBjdXJ2ZXMsIGJ1dCByZXRhaW5zIHRoZSBhcGkgb2YgYSBjdXJ2ZVxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5USFJFRS5DdXJ2ZVBhdGggPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdGhpcy5jdXJ2ZXMgPSBbXTtcclxuXHJcbiAgICB0aGlzLmF1dG9DbG9zZSA9IGZhbHNlOyAvLyBBdXRvbWF0aWNhbGx5IGNsb3NlcyB0aGUgcGF0aFxyXG5cclxufTtcclxuXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkN1cnZlUGF0aDtcclxuXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKCBjdXJ2ZSApIHtcclxuXHJcbiAgICB0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xyXG5cclxufTtcclxuXHJcbi8qXHJcbiBUSFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNoZWNrQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gLy8gVE9ET1xyXG4gLy8gSWYgdGhlIGVuZGluZyBvZiBjdXJ2ZSBpcyBub3QgY29ubmVjdGVkIHRvIHRoZSBzdGFydGluZ1xyXG4gLy8gb3IgdGhlIG5leHQgY3VydmUsIHRoZW4sIHRoaXMgaXMgbm90IGEgcmVhbCBwYXRoXHJcbiB9O1xyXG4gKi9cclxuXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY2xvc2VQYXRoID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgLy8gVE9ETyBUZXN0XHJcbiAgICAvLyBhbmQgdmVyaWZ5IGZvciB2ZWN0b3IzIChuZWVkcyB0byBpbXBsZW1lbnQgZXF1YWxzKVxyXG4gICAgLy8gQWRkIGEgbGluZSBjdXJ2ZSBpZiBzdGFydCBhbmQgZW5kIG9mIGxpbmVzIGFyZSBub3QgY29ubmVjdGVkXHJcbiAgICB2YXIgc3RhcnRQb2ludCA9IHRoaXMuY3VydmVzWyAwIF0uZ2V0UG9pbnQoIDAgKTtcclxuICAgIHZhciBlbmRQb2ludCA9IHRoaXMuY3VydmVzWyB0aGlzLmN1cnZlcy5sZW5ndGggLSAxIF0uZ2V0UG9pbnQoIDEgKTtcclxuXHJcbiAgICBpZiAoICEgc3RhcnRQb2ludC5lcXVhbHMoIGVuZFBvaW50ICkgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY3VydmVzLnB1c2goIG5ldyBUSFJFRS5MaW5lQ3VydmUoIGVuZFBvaW50LCBzdGFydFBvaW50ICkgKTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gVG8gZ2V0IGFjY3VyYXRlIHBvaW50IHdpdGggcmVmZXJlbmNlIHRvXHJcbi8vIGVudGlyZSBwYXRoIGRpc3RhbmNlIGF0IHRpbWUgdCxcclxuLy8gZm9sbG93aW5nIGhhcyB0byBiZSBkb25lOlxyXG5cclxuLy8gMS4gTGVuZ3RoIG9mIGVhY2ggc3ViIHBhdGggaGF2ZSB0byBiZSBrbm93blxyXG4vLyAyLiBMb2NhdGUgYW5kIGlkZW50aWZ5IHR5cGUgb2YgY3VydmVcclxuLy8gMy4gR2V0IHQgZm9yIHRoZSBjdXJ2ZVxyXG4vLyA0LiBSZXR1cm4gY3VydmUuZ2V0UG9pbnRBdCh0JylcclxuXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiggdCApIHtcclxuXHJcbiAgICB2YXIgZCA9IHQgKiB0aGlzLmdldExlbmd0aCgpO1xyXG4gICAgdmFyIGN1cnZlTGVuZ3RocyA9IHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCk7XHJcbiAgICB2YXIgaSA9IDA7XHJcblxyXG4gICAgLy8gVG8gdGhpbmsgYWJvdXQgYm91bmRhcmllcyBwb2ludHMuXHJcblxyXG4gICAgd2hpbGUgKCBpIDwgY3VydmVMZW5ndGhzLmxlbmd0aCApIHtcclxuXHJcbiAgICAgICAgaWYgKCBjdXJ2ZUxlbmd0aHNbIGkgXSA+PSBkICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGRpZmYgPSBjdXJ2ZUxlbmd0aHNbIGkgXSAtIGQ7XHJcbiAgICAgICAgICAgIHZhciBjdXJ2ZSA9IHRoaXMuY3VydmVzWyBpIF07XHJcblxyXG4gICAgICAgICAgICB2YXIgdSA9IDEgLSBkaWZmIC8gY3VydmUuZ2V0TGVuZ3RoKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY3VydmUuZ2V0UG9pbnRBdCggdSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGkgKys7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgIC8vIGxvb3Agd2hlcmUgc3VtICE9IDAsIHN1bSA+IGQgLCBzdW0rMSA8ZFxyXG5cclxufTtcclxuXHJcbi8qXHJcbiBUSFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbiggdCApIHtcclxuIH07XHJcbiAqL1xyXG5cclxuLy8gV2UgY2Fubm90IHVzZSB0aGUgZGVmYXVsdCBUSFJFRS5DdXJ2ZSBnZXRQb2ludCgpIHdpdGggZ2V0TGVuZ3RoKCkgYmVjYXVzZSBpblxyXG4vLyBUSFJFRS5DdXJ2ZSwgZ2V0TGVuZ3RoKCkgZGVwZW5kcyBvbiBnZXRQb2ludCgpIGJ1dCBpbiBUSFJFRS5DdXJ2ZVBhdGhcclxuLy8gZ2V0UG9pbnQoKSBkZXBlbmRzIG9uIGdldExlbmd0aFxyXG5cclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbGVucyA9IHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCk7XHJcbiAgICByZXR1cm4gbGVuc1sgbGVucy5sZW5ndGggLSAxIF07XHJcblxyXG59O1xyXG5cclxuLy8gQ29tcHV0ZSBsZW5ndGhzIGFuZCBjYWNoZSB0aGVtXHJcbi8vIFdlIGNhbm5vdCBvdmVyd3JpdGUgZ2V0TGVuZ3RocygpIGJlY2F1c2UgVXRvVCBtYXBwaW5nIHVzZXMgaXQuXHJcblxyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldEN1cnZlTGVuZ3RocyA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIC8vIFdlIHVzZSBjYWNoZSB2YWx1ZXMgaWYgY3VydmVzIGFuZCBjYWNoZSBhcnJheSBhcmUgc2FtZSBsZW5ndGhcclxuXHJcbiAgICBpZiAoIHRoaXMuY2FjaGVMZW5ndGhzICYmIHRoaXMuY2FjaGVMZW5ndGhzLmxlbmd0aCA9PT0gdGhpcy5jdXJ2ZXMubGVuZ3RoICkge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZUxlbmd0aHM7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldCBsZW5ndGggb2Ygc3ViLWN1cnZlXHJcbiAgICAvLyBQdXNoIHN1bXMgaW50byBjYWNoZWQgYXJyYXlcclxuXHJcbiAgICB2YXIgbGVuZ3RocyA9IFtdLCBzdW1zID0gMDtcclxuXHJcbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICBzdW1zICs9IHRoaXMuY3VydmVzWyBpIF0uZ2V0TGVuZ3RoKCk7XHJcbiAgICAgICAgbGVuZ3Rocy5wdXNoKCBzdW1zICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY2FjaGVMZW5ndGhzID0gbGVuZ3RocztcclxuXHJcbiAgICByZXR1cm4gbGVuZ3RocztcclxuXHJcbn07XHJcblxyXG5cclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0Q3JlYXRlIEdlb21ldHJpZXMgSGVscGVyc1xyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG4vLy8gR2VuZXJhdGUgZ2VvbWV0cnkgZnJvbSBwYXRoIHBvaW50cyAoZm9yIExpbmUgb3IgUG9pbnRzIG9iamVjdHMpXHJcblxyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNyZWF0ZVBvaW50c0dlb21ldHJ5ID0gZnVuY3Rpb24oIGRpdmlzaW9ucyApIHtcclxuXHJcbiAgICB2YXIgcHRzID0gdGhpcy5nZXRQb2ludHMoIGRpdmlzaW9ucywgdHJ1ZSApO1xyXG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnkoIHB0cyApO1xyXG5cclxufTtcclxuXHJcbi8vIEdlbmVyYXRlIGdlb21ldHJ5IGZyb20gZXF1aWRpc3RhbnQgc2FtcGxpbmcgYWxvbmcgdGhlIHBhdGhcclxuXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY3JlYXRlU3BhY2VkUG9pbnRzR2VvbWV0cnkgPSBmdW5jdGlvbiggZGl2aXNpb25zICkge1xyXG5cclxuICAgIHZhciBwdHMgPSB0aGlzLmdldFNwYWNlZFBvaW50cyggZGl2aXNpb25zLCB0cnVlICk7XHJcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeSggcHRzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jcmVhdGVHZW9tZXRyeSA9IGZ1bmN0aW9uKCBwb2ludHMgKSB7XHJcblxyXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcblxyXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIHZhciBwb2ludCA9IHBvaW50c1sgaSBdO1xyXG4gICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCBwb2ludC54LCBwb2ludC55LCBwb2ludC56IHx8IDAgKSApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZ2VvbWV0cnk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2NvcmUvUGF0aC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICogQ3JlYXRlcyBmcmVlIGZvcm0gMmQgcGF0aCB1c2luZyBzZXJpZXMgb2YgcG9pbnRzLCBsaW5lcyBvciBjdXJ2ZXMuXHJcbiAqXHJcbiAqKi9cclxuXHJcblRIUkVFLlBhdGggPSBmdW5jdGlvbiAoIHBvaW50cyApIHtcclxuXHJcbiAgICBUSFJFRS5DdXJ2ZVBhdGguY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMuYWN0aW9ucyA9IFtdO1xyXG5cclxuICAgIGlmICggcG9pbnRzICkge1xyXG5cclxuICAgICAgICB0aGlzLmZyb21Qb2ludHMoIHBvaW50cyApO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5QYXRoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUgKTtcclxuVEhSRUUuUGF0aC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5QYXRoO1xyXG5cclxuLy8gVE9ETyBDbGVhbiB1cCBQQVRIIEFQSVxyXG5cclxuLy8gQ3JlYXRlIHBhdGggdXNpbmcgc3RyYWlnaHQgbGluZXMgdG8gY29ubmVjdCBhbGwgcG9pbnRzXHJcbi8vIC0gdmVjdG9yczogYXJyYXkgb2YgVmVjdG9yMlxyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUuZnJvbVBvaW50cyA9IGZ1bmN0aW9uICggdmVjdG9ycyApIHtcclxuXHJcbiAgICB0aGlzLm1vdmVUbyggdmVjdG9yc1sgMCBdLngsIHZlY3RvcnNbIDAgXS55ICk7XHJcblxyXG4gICAgZm9yICggdmFyIGkgPSAxLCBsID0gdmVjdG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICB0aGlzLmxpbmVUbyggdmVjdG9yc1sgaSBdLngsIHZlY3RvcnNbIGkgXS55ICk7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIHN0YXJ0UGF0aCgpIGVuZFBhdGgoKT9cclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uICggeCwgeSApIHtcclxuXHJcbiAgICB0aGlzLmFjdGlvbnMucHVzaCggeyBhY3Rpb246ICdtb3ZlVG8nLCBhcmdzOiBbIHgsIHkgXSB9ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUubGluZVRvID0gZnVuY3Rpb24gKCB4LCB5ICkge1xyXG5cclxuICAgIHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xyXG5cclxuICAgIHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XHJcbiAgICB2YXIgeTAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMSBdO1xyXG5cclxuICAgIHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5MaW5lQ3VydmUoIG5ldyBUSFJFRS5WZWN0b3IyKCB4MCwgeTAgKSwgbmV3IFRIUkVFLlZlY3RvcjIoIHgsIHkgKSApO1xyXG4gICAgdGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcclxuXHJcbiAgICB0aGlzLmFjdGlvbnMucHVzaCggeyBhY3Rpb246ICdsaW5lVG8nLCBhcmdzOiBbIHgsIHkgXSB9ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUucXVhZHJhdGljQ3VydmVUbyA9IGZ1bmN0aW9uKCBhQ1B4LCBhQ1B5LCBhWCwgYVkgKSB7XHJcblxyXG4gICAgdmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMSBdLmFyZ3M7XHJcblxyXG4gICAgdmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcclxuICAgIHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XHJcblxyXG4gICAgdmFyIGN1cnZlID0gbmV3IFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlKFxyXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCB4MCwgeTAgKSxcclxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYUNQeCwgYUNQeSApLFxyXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBhWCwgYVkgKVxyXG4gICAgKTtcclxuXHJcbiAgICB0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xyXG5cclxuICAgIHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogJ3F1YWRyYXRpY0N1cnZlVG8nLCBhcmdzOiBbIGFDUHgsIGFDUHksIGFYLCBhWSBdIH0gKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5QYXRoLnByb3RvdHlwZS5iZXppZXJDdXJ2ZVRvID0gZnVuY3Rpb24oIGFDUDF4LCBhQ1AxeSwgYUNQMngsIGFDUDJ5LCBhWCwgYVkgKSB7XHJcblxyXG4gICAgdmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMSBdLmFyZ3M7XHJcblxyXG4gICAgdmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcclxuICAgIHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XHJcblxyXG4gICAgdmFyIGN1cnZlID0gbmV3IFRIUkVFLkN1YmljQmV6aWVyQ3VydmUoXHJcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIHgwLCB5MCApLFxyXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBhQ1AxeCwgYUNQMXkgKSxcclxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYUNQMngsIGFDUDJ5ICksXHJcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGFYLCBhWSApXHJcbiAgICApO1xyXG5cclxuICAgIHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XHJcblxyXG4gICAgdGhpcy5hY3Rpb25zLnB1c2goIHsgYWN0aW9uOiAnYmV6aWVyQ3VydmVUbycsIGFyZ3M6IFsgYUNQMXgsIGFDUDF5LCBhQ1AyeCwgYUNQMnksIGFYLCBhWSBdIH0gKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5QYXRoLnByb3RvdHlwZS5zcGxpbmVUaHJ1ID0gZnVuY3Rpb24oIHB0cyAvKkFycmF5IG9mIFZlY3RvciovICkge1xyXG5cclxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xyXG5cclxuICAgIHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xyXG5cclxuICAgIHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XHJcbiAgICB2YXIgeTAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMSBdO1xyXG5cclxuICAgIHZhciBucHRzID0gWyBuZXcgVEhSRUUuVmVjdG9yMiggeDAsIHkwICkgXTtcclxuICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KCBucHRzLCBwdHMgKTtcclxuXHJcbiAgICB2YXIgY3VydmUgPSBuZXcgVEhSRUUuU3BsaW5lQ3VydmUoIG5wdHMgKTtcclxuICAgIHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XHJcblxyXG4gICAgdGhpcy5hY3Rpb25zLnB1c2goIHsgYWN0aW9uOiAnc3BsaW5lVGhydScsIGFyZ3M6IGFyZ3MgfSApO1xyXG5cclxufTtcclxuXHJcbi8vIEZVVFVSRTogQ2hhbmdlIHRoZSBBUEkgb3IgZm9sbG93IGNhbnZhcyBBUEk/XHJcblxyXG5USFJFRS5QYXRoLnByb3RvdHlwZS5hcmMgPSBmdW5jdGlvbiAoIGFYLCBhWSwgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcclxuXHJcbiAgICB2YXIgbGFzdGFyZ3MgPSB0aGlzLmFjdGlvbnNbIHRoaXMuYWN0aW9ucy5sZW5ndGggLSAxIF0uYXJncztcclxuICAgIHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XHJcbiAgICB2YXIgeTAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMSBdO1xyXG5cclxuICAgIHRoaXMuYWJzYXJjKCBhWCArIHgwLCBhWSArIHkwLCBhUmFkaXVzLFxyXG4gICAgICAgIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5QYXRoLnByb3RvdHlwZS5hYnNhcmMgPSBmdW5jdGlvbiAoIGFYLCBhWSwgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcclxuXHJcbiAgICB0aGlzLmFic2VsbGlwc2UoIGFYLCBhWSwgYVJhZGl1cywgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLmVsbGlwc2UgPSBmdW5jdGlvbiAoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICkge1xyXG5cclxuICAgIHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xyXG4gICAgdmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcclxuICAgIHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XHJcblxyXG4gICAgdGhpcy5hYnNlbGxpcHNlKCBhWCArIHgwLCBhWSArIHkwLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKTtcclxuXHJcbn07XHJcblxyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUuYWJzZWxsaXBzZSA9IGZ1bmN0aW9uICggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKSB7XHJcblxyXG4gICAgdmFyIGFyZ3MgPSBbXHJcbiAgICAgICAgYVgsIGFZLFxyXG4gICAgICAgIHhSYWRpdXMsIHlSYWRpdXMsXHJcbiAgICAgICAgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSxcclxuICAgICAgICBhQ2xvY2t3aXNlLFxyXG4gICAgICAgIGFSb3RhdGlvbiB8fCAwIC8vIGFSb3RhdGlvbiBpcyBvcHRpb25hbC5cclxuICAgIF07XHJcblxyXG4gICAgdmFyIGN1cnZlID0gbmV3IFRIUkVFLkVsbGlwc2VDdXJ2ZSggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKTtcclxuICAgIHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XHJcblxyXG4gICAgdmFyIGxhc3RQb2ludCA9IGN1cnZlLmdldFBvaW50KCAxICk7XHJcbiAgICBhcmdzLnB1c2goIGxhc3RQb2ludC54ICk7XHJcbiAgICBhcmdzLnB1c2goIGxhc3RQb2ludC55ICk7XHJcblxyXG4gICAgdGhpcy5hY3Rpb25zLnB1c2goIHsgYWN0aW9uOiAnZWxsaXBzZScsIGFyZ3M6IGFyZ3MgfSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLmdldFNwYWNlZFBvaW50cyA9IGZ1bmN0aW9uICggZGl2aXNpb25zLCBjbG9zZWRQYXRoICkge1xyXG5cclxuICAgIGlmICggISBkaXZpc2lvbnMgKSBkaXZpc2lvbnMgPSA0MDtcclxuXHJcbiAgICB2YXIgcG9pbnRzID0gW107XHJcblxyXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZGl2aXNpb25zOyBpICsrICkge1xyXG5cclxuICAgICAgICBwb2ludHMucHVzaCggdGhpcy5nZXRQb2ludCggaSAvIGRpdmlzaW9ucyApICk7XHJcblxyXG4gICAgICAgIC8vaWYgKCAhdGhpcy5nZXRQb2ludCggaSAvIGRpdmlzaW9ucyApICkgdGhyb3cgXCJESUVcIjtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgKCBjbG9zZWRQYXRoICkge1xyXG4gICAgLy9cclxuICAgIC8vIFx0cG9pbnRzLnB1c2goIHBvaW50c1sgMCBdICk7XHJcbiAgICAvL1xyXG4gICAgLy8gfVxyXG5cclxuICAgIHJldHVybiBwb2ludHM7XHJcblxyXG59O1xyXG5cclxuLyogUmV0dXJuIGFuIGFycmF5IG9mIHZlY3RvcnMgYmFzZWQgb24gY29udG91ciBvZiB0aGUgcGF0aCAqL1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUuZ2V0UG9pbnRzID0gZnVuY3Rpb24oIGRpdmlzaW9ucywgY2xvc2VkUGF0aCApIHtcclxuXHJcbiAgICBkaXZpc2lvbnMgPSBkaXZpc2lvbnMgfHwgMTI7XHJcblxyXG4gICAgdmFyIGIyID0gVEhSRUUuU2hhcGVVdGlscy5iMjtcclxuICAgIHZhciBiMyA9IFRIUkVFLlNoYXBlVXRpbHMuYjM7XHJcblxyXG4gICAgdmFyIHBvaW50cyA9IFtdO1xyXG5cclxuICAgIHZhciBjcHgsIGNweSwgY3B4MiwgY3B5MiwgY3B4MSwgY3B5MSwgY3B4MCwgY3B5MCxcclxuICAgICAgICBsYXN0ZSwgdHgsIHR5O1xyXG5cclxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuYWN0aW9ucy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuYWN0aW9uc1sgaSBdO1xyXG5cclxuICAgICAgICB2YXIgYWN0aW9uID0gaXRlbS5hY3Rpb247XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBpdGVtLmFyZ3M7XHJcblxyXG4gICAgICAgIHN3aXRjaCAoIGFjdGlvbiApIHtcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJ21vdmVUbyc6XHJcblxyXG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCBhcmdzWyAwIF0sIGFyZ3NbIDEgXSApICk7XHJcblxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlICdsaW5lVG8nOlxyXG5cclxuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggYXJnc1sgMCBdLCBhcmdzWyAxIF0gKSApO1xyXG5cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAncXVhZHJhdGljQ3VydmVUbyc6XHJcblxyXG4gICAgICAgICAgICAgICAgY3B4ICA9IGFyZ3NbIDIgXTtcclxuICAgICAgICAgICAgICAgIGNweSAgPSBhcmdzWyAzIF07XHJcblxyXG4gICAgICAgICAgICAgICAgY3B4MSA9IGFyZ3NbIDAgXTtcclxuICAgICAgICAgICAgICAgIGNweTEgPSBhcmdzWyAxIF07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBwb2ludHMubGVuZ3RoID4gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdGUgPSBwb2ludHNbIHBvaW50cy5sZW5ndGggLSAxIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNweDAgPSBsYXN0ZS54O1xyXG4gICAgICAgICAgICAgICAgICAgIGNweTAgPSBsYXN0ZS55O1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RlID0gdGhpcy5hY3Rpb25zWyBpIC0gMSBdLmFyZ3M7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNweDAgPSBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMiBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNweTAgPSBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMSBdO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDE7IGogPD0gZGl2aXNpb25zOyBqICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGogLyBkaXZpc2lvbnM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHR4ID0gYjIoIHQsIGNweDAsIGNweDEsIGNweCApO1xyXG4gICAgICAgICAgICAgICAgICAgIHR5ID0gYjIoIHQsIGNweTAsIGNweTEsIGNweSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnYmV6aWVyQ3VydmVUbyc6XHJcblxyXG4gICAgICAgICAgICAgICAgY3B4ICA9IGFyZ3NbIDQgXTtcclxuICAgICAgICAgICAgICAgIGNweSAgPSBhcmdzWyA1IF07XHJcblxyXG4gICAgICAgICAgICAgICAgY3B4MSA9IGFyZ3NbIDAgXTtcclxuICAgICAgICAgICAgICAgIGNweTEgPSBhcmdzWyAxIF07XHJcblxyXG4gICAgICAgICAgICAgICAgY3B4MiA9IGFyZ3NbIDIgXTtcclxuICAgICAgICAgICAgICAgIGNweTIgPSBhcmdzWyAzIF07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBwb2ludHMubGVuZ3RoID4gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdGUgPSBwb2ludHNbIHBvaW50cy5sZW5ndGggLSAxIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNweDAgPSBsYXN0ZS54O1xyXG4gICAgICAgICAgICAgICAgICAgIGNweTAgPSBsYXN0ZS55O1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RlID0gdGhpcy5hY3Rpb25zWyBpIC0gMSBdLmFyZ3M7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNweDAgPSBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMiBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNweTAgPSBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMSBdO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGogPSAxOyBqIDw9IGRpdmlzaW9uczsgaiArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBqIC8gZGl2aXNpb25zO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0eCA9IGIzKCB0LCBjcHgwLCBjcHgxLCBjcHgyLCBjcHggKTtcclxuICAgICAgICAgICAgICAgICAgICB0eSA9IGIzKCB0LCBjcHkwLCBjcHkxLCBjcHkyLCBjcHkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJ3NwbGluZVRocnUnOlxyXG5cclxuICAgICAgICAgICAgICAgIGxhc3RlID0gdGhpcy5hY3Rpb25zWyBpIC0gMSBdLmFyZ3M7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGxhc3QgPSBuZXcgVEhSRUUuVmVjdG9yMiggbGFzdGVbIGxhc3RlLmxlbmd0aCAtIDIgXSwgbGFzdGVbIGxhc3RlLmxlbmd0aCAtIDEgXSApO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNwdHMgPSBbIGxhc3QgXTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbiA9IGRpdmlzaW9ucyAqIGFyZ3NbIDAgXS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgc3B0cyA9IHNwdHMuY29uY2F0KCBhcmdzWyAwIF0gKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgc3BsaW5lID0gbmV3IFRIUkVFLlNwbGluZUN1cnZlKCBzcHRzICk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGogPSAxOyBqIDw9IG47IGogKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKCBzcGxpbmUuZ2V0UG9pbnRBdCggaiAvIG4gKSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJ2FyYyc6XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGFYID0gYXJnc1sgMCBdLCBhWSA9IGFyZ3NbIDEgXSxcclxuICAgICAgICAgICAgICAgICAgICBhUmFkaXVzID0gYXJnc1sgMiBdLFxyXG4gICAgICAgICAgICAgICAgICAgIGFTdGFydEFuZ2xlID0gYXJnc1sgMyBdLCBhRW5kQW5nbGUgPSBhcmdzWyA0IF0sXHJcbiAgICAgICAgICAgICAgICAgICAgYUNsb2Nrd2lzZSA9ICEhIGFyZ3NbIDUgXTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGFBbmdsZSA9IGFFbmRBbmdsZSAtIGFTdGFydEFuZ2xlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFuZ2xlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRkaXZpc2lvbnMgPSBkaXZpc2lvbnMgKiAyO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBqID0gMTsgaiA8PSB0ZGl2aXNpb25zOyBqICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGogLyB0ZGl2aXNpb25zO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoICEgYUNsb2Nrd2lzZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAxIC0gdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBhbmdsZSA9IGFTdGFydEFuZ2xlICsgdCAqIGRlbHRhQW5nbGU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHR4ID0gYVggKyBhUmFkaXVzICogTWF0aC5jb3MoIGFuZ2xlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHkgPSBhWSArIGFSYWRpdXMgKiBNYXRoLnNpbiggYW5nbGUgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndCcsIHQsICdhbmdsZScsIGFuZ2xlLCAndHgnLCB0eCwgJ3R5JywgdHkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2cocG9pbnRzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJ2VsbGlwc2UnOlxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBhWCA9IGFyZ3NbIDAgXSwgYVkgPSBhcmdzWyAxIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgeFJhZGl1cyA9IGFyZ3NbIDIgXSxcclxuICAgICAgICAgICAgICAgICAgICB5UmFkaXVzID0gYXJnc1sgMyBdLFxyXG4gICAgICAgICAgICAgICAgICAgIGFTdGFydEFuZ2xlID0gYXJnc1sgNCBdLCBhRW5kQW5nbGUgPSBhcmdzWyA1IF0sXHJcbiAgICAgICAgICAgICAgICAgICAgYUNsb2Nrd2lzZSA9ICEhIGFyZ3NbIDYgXSxcclxuICAgICAgICAgICAgICAgICAgICBhUm90YXRpb24gPSBhcmdzWyA3IF07XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBkZWx0YUFuZ2xlID0gYUVuZEFuZ2xlIC0gYVN0YXJ0QW5nbGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgYW5nbGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGRpdmlzaW9ucyA9IGRpdmlzaW9ucyAqIDI7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGNvcywgc2luO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBhUm90YXRpb24gIT09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvcyA9IE1hdGguY29zKCBhUm90YXRpb24gKTtcclxuICAgICAgICAgICAgICAgICAgICBzaW4gPSBNYXRoLnNpbiggYVJvdGF0aW9uICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBqID0gMTsgaiA8PSB0ZGl2aXNpb25zOyBqICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGogLyB0ZGl2aXNpb25zO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoICEgYUNsb2Nrd2lzZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAxIC0gdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBhbmdsZSA9IGFTdGFydEFuZ2xlICsgdCAqIGRlbHRhQW5nbGU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHR4ID0gYVggKyB4UmFkaXVzICogTWF0aC5jb3MoIGFuZ2xlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHkgPSBhWSArIHlSYWRpdXMgKiBNYXRoLnNpbiggYW5nbGUgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBhUm90YXRpb24gIT09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IHR4LCB5ID0gdHk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSb3RhdGUgdGhlIHBvaW50IGFib3V0IHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0gKCB4IC0gYVggKSAqIGNvcyAtICggeSAtIGFZICkgKiBzaW4gKyBhWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHkgPSAoIHggLSBhWCApICogc2luICsgKCB5IC0gYVkgKSAqIGNvcyArIGFZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3QnLCB0LCAnYW5nbGUnLCBhbmdsZSwgJ3R4JywgdHgsICd0eScsIHR5KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKHBvaW50cyk7XHJcblxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIH0gLy8gZW5kIHN3aXRjaFxyXG5cclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIC8vIE5vcm1hbGl6ZSB0byByZW1vdmUgdGhlIGNsb3NpbmcgcG9pbnQgYnkgZGVmYXVsdC5cclxuICAgIHZhciBsYXN0UG9pbnQgPSBwb2ludHNbIHBvaW50cy5sZW5ndGggLSAxIF07XHJcbiAgICBpZiAoIE1hdGguYWJzKCBsYXN0UG9pbnQueCAtIHBvaW50c1sgMCBdLnggKSA8IE51bWJlci5FUFNJTE9OICYmXHJcbiAgICAgICAgTWF0aC5hYnMoIGxhc3RQb2ludC55IC0gcG9pbnRzWyAwIF0ueSApIDwgTnVtYmVyLkVQU0lMT04gKVxyXG4gICAgICAgIHBvaW50cy5zcGxpY2UoIHBvaW50cy5sZW5ndGggLSAxLCAxICk7XHJcbiAgICBpZiAoIGNsb3NlZFBhdGggKSB7XHJcblxyXG4gICAgICAgIHBvaW50cy5wdXNoKCBwb2ludHNbIDAgXSApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcG9pbnRzO1xyXG5cclxufTtcclxuXHJcbi8vXHJcbi8vIEJyZWFrcyBwYXRoIGludG8gc2hhcGVzXHJcbi8vXHJcbi8vXHRBc3N1bXB0aW9ucyAoaWYgcGFyYW1ldGVyIGlzQ0NXPT10cnVlIHRoZSBvcHBvc2l0ZSBob2xkcyk6XHJcbi8vXHQtIHNvbGlkIHNoYXBlcyBhcmUgZGVmaW5lZCBjbG9ja3dpc2UgKENXKVxyXG4vL1x0LSBob2xlcyBhcmUgZGVmaW5lZCBjb3VudGVyY2xvY2t3aXNlIChDQ1cpXHJcbi8vXHJcbi8vXHRJZiBwYXJhbWV0ZXIgbm9Ib2xlcz09dHJ1ZTpcclxuLy8gIC0gYWxsIHN1YlBhdGhzIGFyZSByZWdhcmRlZCBhcyBzb2xpZCBzaGFwZXNcclxuLy8gIC0gZGVmaW5pdGlvbiBvcmRlciBDVy9DQ1cgaGFzIG5vIHJlbGV2YW5jZVxyXG4vL1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUudG9TaGFwZXMgPSBmdW5jdGlvbiggaXNDQ1csIG5vSG9sZXMgKSB7XHJcblxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdFN1YnBhdGhzKCBpbkFjdGlvbnMgKSB7XHJcblxyXG4gICAgICAgIHZhciBzdWJQYXRocyA9IFtdLCBsYXN0UGF0aCA9IG5ldyBUSFJFRS5QYXRoKCk7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGluQWN0aW9ucy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGl0ZW0gPSBpbkFjdGlvbnNbIGkgXTtcclxuXHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gaXRlbS5hcmdzO1xyXG4gICAgICAgICAgICB2YXIgYWN0aW9uID0gaXRlbS5hY3Rpb247XHJcblxyXG4gICAgICAgICAgICBpZiAoIGFjdGlvbiA9PT0gJ21vdmVUbycgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBsYXN0UGF0aC5hY3Rpb25zLmxlbmd0aCAhPT0gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc3ViUGF0aHMucHVzaCggbGFzdFBhdGggKTtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0UGF0aCA9IG5ldyBUSFJFRS5QYXRoKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGFzdFBhdGhbIGFjdGlvbiBdLmFwcGx5KCBsYXN0UGF0aCwgYXJncyApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggbGFzdFBhdGguYWN0aW9ucy5sZW5ndGggIT09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICBzdWJQYXRocy5wdXNoKCBsYXN0UGF0aCApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHN1YlBhdGhzKTtcclxuXHJcbiAgICAgICAgcmV0dXJuXHRzdWJQYXRocztcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdG9TaGFwZXNOb0hvbGVzKCBpblN1YnBhdGhzICkge1xyXG5cclxuICAgICAgICB2YXIgc2hhcGVzID0gW107XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGluU3VicGF0aHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciB0bXBQYXRoID0gaW5TdWJwYXRoc1sgaSBdO1xyXG5cclxuICAgICAgICAgICAgdmFyIHRtcFNoYXBlID0gbmV3IFRIUkVFLlNoYXBlKCk7XHJcbiAgICAgICAgICAgIHRtcFNoYXBlLmFjdGlvbnMgPSB0bXBQYXRoLmFjdGlvbnM7XHJcbiAgICAgICAgICAgIHRtcFNoYXBlLmN1cnZlcyA9IHRtcFBhdGguY3VydmVzO1xyXG5cclxuICAgICAgICAgICAgc2hhcGVzLnB1c2goIHRtcFNoYXBlICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcInNoYXBlXCIsIHNoYXBlcyk7XHJcblxyXG4gICAgICAgIHJldHVybiBzaGFwZXM7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzUG9pbnRJbnNpZGVQb2x5Z29uKCBpblB0LCBpblBvbHlnb24gKSB7XHJcblxyXG4gICAgICAgIHZhciBwb2x5TGVuID0gaW5Qb2x5Z29uLmxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gaW5QdCBvbiBwb2x5Z29uIGNvbnRvdXIgPT4gaW1tZWRpYXRlIHN1Y2Nlc3MgICAgb3JcclxuICAgICAgICAvLyB0b2dnbGluZyBvZiBpbnNpZGUvb3V0c2lkZSBhdCBldmVyeSBzaW5nbGUhIGludGVyc2VjdGlvbiBwb2ludCBvZiBhbiBlZGdlXHJcbiAgICAgICAgLy8gIHdpdGggdGhlIGhvcml6b250YWwgbGluZSB0aHJvdWdoIGluUHQsIGxlZnQgb2YgaW5QdFxyXG4gICAgICAgIC8vICBub3QgY291bnRpbmcgbG93ZXJZIGVuZHBvaW50cyBvZiBlZGdlcyBhbmQgd2hvbGUgZWRnZXMgb24gdGhhdCBsaW5lXHJcbiAgICAgICAgdmFyIGluc2lkZSA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAoIHZhciBwID0gcG9seUxlbiAtIDEsIHEgPSAwOyBxIDwgcG9seUxlbjsgcCA9IHEgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgZWRnZUxvd1B0ICA9IGluUG9seWdvblsgcCBdO1xyXG4gICAgICAgICAgICB2YXIgZWRnZUhpZ2hQdCA9IGluUG9seWdvblsgcSBdO1xyXG5cclxuICAgICAgICAgICAgdmFyIGVkZ2VEeCA9IGVkZ2VIaWdoUHQueCAtIGVkZ2VMb3dQdC54O1xyXG4gICAgICAgICAgICB2YXIgZWRnZUR5ID0gZWRnZUhpZ2hQdC55IC0gZWRnZUxvd1B0Lnk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIE1hdGguYWJzKCBlZGdlRHkgKSA+IE51bWJlci5FUFNJTE9OICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG5vdCBwYXJhbGxlbFxyXG4gICAgICAgICAgICAgICAgaWYgKCBlZGdlRHkgPCAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBlZGdlTG93UHQgID0gaW5Qb2x5Z29uWyBxIF07IGVkZ2VEeCA9IC0gZWRnZUR4O1xyXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VIaWdoUHQgPSBpblBvbHlnb25bIHAgXTsgZWRnZUR5ID0gLSBlZGdlRHk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCAoIGluUHQueSA8IGVkZ2VMb3dQdC55ICkgfHwgKCBpblB0LnkgPiBlZGdlSGlnaFB0LnkgKSApIFx0XHRjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGluUHQueSA9PT0gZWRnZUxvd1B0LnkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggaW5QdC54ID09PSBlZGdlTG93UHQueCApXHRcdHJldHVyblx0dHJ1ZTtcdFx0Ly8gaW5QdCBpcyBvbiBjb250b3VyID9cclxuICAgICAgICAgICAgICAgICAgICAvLyBjb250aW51ZTtcdFx0XHRcdC8vIG5vIGludGVyc2VjdGlvbiBvciBlZGdlTG93UHQgPT4gZG9lc24ndCBjb3VudCAhISFcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGVycEVkZ2UgPSBlZGdlRHkgKiAoIGluUHQueCAtIGVkZ2VMb3dQdC54ICkgLSBlZGdlRHggKiAoIGluUHQueSAtIGVkZ2VMb3dQdC55ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBwZXJwRWRnZSA9PT0gMCApXHRcdFx0XHRyZXR1cm5cdHRydWU7XHRcdC8vIGluUHQgaXMgb24gY29udG91ciA/XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBwZXJwRWRnZSA8IDAgKSBcdFx0XHRcdGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGluc2lkZSA9ICEgaW5zaWRlO1x0XHQvLyB0cnVlIGludGVyc2VjdGlvbiBsZWZ0IG9mIGluUHRcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHBhcmFsbGVsIG9yIGNvbGxpbmVhclxyXG4gICAgICAgICAgICAgICAgaWYgKCBpblB0LnkgIT09IGVkZ2VMb3dQdC55ICkgXHRcdGNvbnRpbnVlO1x0XHRcdC8vIHBhcmFsbGVsXHJcbiAgICAgICAgICAgICAgICAvLyBlZGdlIGxpZXMgb24gdGhlIHNhbWUgaG9yaXpvbnRhbCBsaW5lIGFzIGluUHRcclxuICAgICAgICAgICAgICAgIGlmICggKCAoIGVkZ2VIaWdoUHQueCA8PSBpblB0LnggKSAmJiAoIGluUHQueCA8PSBlZGdlTG93UHQueCApICkgfHxcclxuICAgICAgICAgICAgICAgICAgICAoICggZWRnZUxvd1B0LnggPD0gaW5QdC54ICkgJiYgKCBpblB0LnggPD0gZWRnZUhpZ2hQdC54ICkgKSApXHRcdHJldHVyblx0dHJ1ZTtcdC8vIGluUHQ6IFBvaW50IG9uIGNvbnRvdXIgIVxyXG4gICAgICAgICAgICAgICAgLy8gY29udGludWU7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuXHRpbnNpZGU7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHZhciBpc0Nsb2NrV2lzZSA9IFRIUkVFLlNoYXBlVXRpbHMuaXNDbG9ja1dpc2U7XHJcblxyXG4gICAgdmFyIHN1YlBhdGhzID0gZXh0cmFjdFN1YnBhdGhzKCB0aGlzLmFjdGlvbnMgKTtcclxuICAgIGlmICggc3ViUGF0aHMubGVuZ3RoID09PSAwICkgcmV0dXJuIFtdO1xyXG5cclxuICAgIGlmICggbm9Ib2xlcyA9PT0gdHJ1ZSApXHRyZXR1cm5cdHRvU2hhcGVzTm9Ib2xlcyggc3ViUGF0aHMgKTtcclxuXHJcblxyXG4gICAgdmFyIHNvbGlkLCB0bXBQYXRoLCB0bXBTaGFwZSwgc2hhcGVzID0gW107XHJcblxyXG4gICAgaWYgKCBzdWJQYXRocy5sZW5ndGggPT09IDEgKSB7XHJcblxyXG4gICAgICAgIHRtcFBhdGggPSBzdWJQYXRoc1sgMCBdO1xyXG4gICAgICAgIHRtcFNoYXBlID0gbmV3IFRIUkVFLlNoYXBlKCk7XHJcbiAgICAgICAgdG1wU2hhcGUuYWN0aW9ucyA9IHRtcFBhdGguYWN0aW9ucztcclxuICAgICAgICB0bXBTaGFwZS5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcclxuICAgICAgICBzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcclxuICAgICAgICByZXR1cm4gc2hhcGVzO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB2YXIgaG9sZXNGaXJzdCA9ICEgaXNDbG9ja1dpc2UoIHN1YlBhdGhzWyAwIF0uZ2V0UG9pbnRzKCkgKTtcclxuICAgIGhvbGVzRmlyc3QgPSBpc0NDVyA/ICEgaG9sZXNGaXJzdCA6IGhvbGVzRmlyc3Q7XHJcblxyXG4gICAgLy8gY29uc29sZS5sb2coXCJIb2xlcyBmaXJzdFwiLCBob2xlc0ZpcnN0KTtcclxuXHJcbiAgICB2YXIgYmV0dGVyU2hhcGVIb2xlcyA9IFtdO1xyXG4gICAgdmFyIG5ld1NoYXBlcyA9IFtdO1xyXG4gICAgdmFyIG5ld1NoYXBlSG9sZXMgPSBbXTtcclxuICAgIHZhciBtYWluSWR4ID0gMDtcclxuICAgIHZhciB0bXBQb2ludHM7XHJcblxyXG4gICAgbmV3U2hhcGVzWyBtYWluSWR4IF0gPSB1bmRlZmluZWQ7XHJcbiAgICBuZXdTaGFwZUhvbGVzWyBtYWluSWR4IF0gPSBbXTtcclxuXHJcbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBzdWJQYXRocy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICB0bXBQYXRoID0gc3ViUGF0aHNbIGkgXTtcclxuICAgICAgICB0bXBQb2ludHMgPSB0bXBQYXRoLmdldFBvaW50cygpO1xyXG4gICAgICAgIHNvbGlkID0gaXNDbG9ja1dpc2UoIHRtcFBvaW50cyApO1xyXG4gICAgICAgIHNvbGlkID0gaXNDQ1cgPyAhIHNvbGlkIDogc29saWQ7XHJcblxyXG4gICAgICAgIGlmICggc29saWQgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoICggISBob2xlc0ZpcnN0ICkgJiYgKCBuZXdTaGFwZXNbIG1haW5JZHggXSApIClcdG1haW5JZHggKys7XHJcblxyXG4gICAgICAgICAgICBuZXdTaGFwZXNbIG1haW5JZHggXSA9IHsgczogbmV3IFRIUkVFLlNoYXBlKCksIHA6IHRtcFBvaW50cyB9O1xyXG4gICAgICAgICAgICBuZXdTaGFwZXNbIG1haW5JZHggXS5zLmFjdGlvbnMgPSB0bXBQYXRoLmFjdGlvbnM7XHJcbiAgICAgICAgICAgIG5ld1NoYXBlc1sgbWFpbklkeCBdLnMuY3VydmVzID0gdG1wUGF0aC5jdXJ2ZXM7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGhvbGVzRmlyc3QgKVx0bWFpbklkeCArKztcclxuICAgICAgICAgICAgbmV3U2hhcGVIb2xlc1sgbWFpbklkeCBdID0gW107XHJcblxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjdycsIGkpO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgbmV3U2hhcGVIb2xlc1sgbWFpbklkeCBdLnB1c2goIHsgaDogdG1wUGF0aCwgcDogdG1wUG9pbnRzWyAwIF0gfSApO1xyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnY2N3JywgaSk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gb25seSBIb2xlcz8gLT4gcHJvYmFibHkgYWxsIFNoYXBlcyB3aXRoIHdyb25nIG9yaWVudGF0aW9uXHJcbiAgICBpZiAoICEgbmV3U2hhcGVzWyAwIF0gKVx0cmV0dXJuXHR0b1NoYXBlc05vSG9sZXMoIHN1YlBhdGhzICk7XHJcblxyXG5cclxuICAgIGlmICggbmV3U2hhcGVzLmxlbmd0aCA+IDEgKSB7XHJcblxyXG4gICAgICAgIHZhciBhbWJpZ3VvdXMgPSBmYWxzZTtcclxuICAgICAgICB2YXIgdG9DaGFuZ2UgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIHNJZHggPSAwLCBzTGVuID0gbmV3U2hhcGVzLmxlbmd0aDsgc0lkeCA8IHNMZW47IHNJZHggKysgKSB7XHJcblxyXG4gICAgICAgICAgICBiZXR0ZXJTaGFwZUhvbGVzWyBzSWR4IF0gPSBbXTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKCB2YXIgc0lkeCA9IDAsIHNMZW4gPSBuZXdTaGFwZXMubGVuZ3RoOyBzSWR4IDwgc0xlbjsgc0lkeCArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBzaG8gPSBuZXdTaGFwZUhvbGVzWyBzSWR4IF07XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaElkeCA9IDA7IGhJZHggPCBzaG8ubGVuZ3RoOyBoSWR4ICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBobyA9IHNob1sgaElkeCBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGhvbGVfdW5hc3NpZ25lZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIHMySWR4ID0gMDsgczJJZHggPCBuZXdTaGFwZXMubGVuZ3RoOyBzMklkeCArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpc1BvaW50SW5zaWRlUG9seWdvbiggaG8ucCwgbmV3U2hhcGVzWyBzMklkeCBdLnAgKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc0lkeCAhPT0gczJJZHggKVx0dG9DaGFuZ2UucHVzaCggeyBmcm9tczogc0lkeCwgdG9zOiBzMklkeCwgaG9sZTogaElkeCB9ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaG9sZV91bmFzc2lnbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGVfdW5hc3NpZ25lZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmV0dGVyU2hhcGVIb2xlc1sgczJJZHggXS5wdXNoKCBobyApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbWJpZ3VvdXMgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCBob2xlX3VuYXNzaWduZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJldHRlclNoYXBlSG9sZXNbIHNJZHggXS5wdXNoKCBobyApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiYW1iaWd1b3VzOiBcIiwgYW1iaWd1b3VzKTtcclxuICAgICAgICBpZiAoIHRvQ2hhbmdlLmxlbmd0aCA+IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInRvIGNoYW5nZTogXCIsIHRvQ2hhbmdlKTtcclxuICAgICAgICAgICAgaWYgKCAhIGFtYmlndW91cyApXHRuZXdTaGFwZUhvbGVzID0gYmV0dGVyU2hhcGVIb2xlcztcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICB2YXIgdG1wSG9sZXM7XHJcblxyXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IG5ld1NoYXBlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgdG1wU2hhcGUgPSBuZXdTaGFwZXNbIGkgXS5zO1xyXG4gICAgICAgIHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xyXG4gICAgICAgIHRtcEhvbGVzID0gbmV3U2hhcGVIb2xlc1sgaSBdO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gdG1wSG9sZXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG4gICAgICAgICAgICB0bXBTaGFwZS5ob2xlcy5wdXNoKCB0bXBIb2xlc1sgaiBdLmggKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvL2NvbnNvbGUubG9nKFwic2hhcGVcIiwgc2hhcGVzKTtcclxuXHJcbiAgICByZXR1cm4gc2hhcGVzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9jb3JlL1NoYXBlLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKiBEZWZpbmVzIGEgMmQgc2hhcGUgcGxhbmUgdXNpbmcgcGF0aHMuXHJcbiAqKi9cclxuXHJcbi8vIFNURVAgMSBDcmVhdGUgYSBwYXRoLlxyXG4vLyBTVEVQIDIgVHVybiBwYXRoIGludG8gc2hhcGUuXHJcbi8vIFNURVAgMyBFeHRydWRlR2VvbWV0cnkgdGFrZXMgaW4gU2hhcGUvU2hhcGVzXHJcbi8vIFNURVAgM2EgLSBFeHRyYWN0IHBvaW50cyBmcm9tIGVhY2ggc2hhcGUsIHR1cm4gdG8gdmVydGljZXNcclxuLy8gU1RFUCAzYiAtIFRyaWFuZ3VsYXRlIGVhY2ggc2hhcGUsIGFkZCBmYWNlcy5cclxuXHJcblRIUkVFLlNoYXBlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIFRIUkVFLlBhdGguYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xyXG5cclxuICAgIHRoaXMuaG9sZXMgPSBbXTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TaGFwZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5QYXRoLnByb3RvdHlwZSApO1xyXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TaGFwZTtcclxuXHJcbi8vIENvbnZlbmllbmNlIG1ldGhvZCB0byByZXR1cm4gRXh0cnVkZUdlb21ldHJ5XHJcblxyXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZXh0cnVkZSA9IGZ1bmN0aW9uICggb3B0aW9ucyApIHtcclxuXHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeSggdGhpcywgb3B0aW9ucyApO1xyXG5cclxufTtcclxuXHJcbi8vIENvbnZlbmllbmNlIG1ldGhvZCB0byByZXR1cm4gU2hhcGVHZW9tZXRyeVxyXG5cclxuVEhSRUUuU2hhcGUucHJvdG90eXBlLm1ha2VHZW9tZXRyeSA9IGZ1bmN0aW9uICggb3B0aW9ucyApIHtcclxuXHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLlNoYXBlR2VvbWV0cnkoIHRoaXMsIG9wdGlvbnMgKTtcclxuXHJcbn07XHJcblxyXG4vLyBHZXQgcG9pbnRzIG9mIGhvbGVzXHJcblxyXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZ2V0UG9pbnRzSG9sZXMgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcclxuXHJcbiAgICB2YXIgaG9sZXNQdHMgPSBbXTtcclxuXHJcbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIGhvbGVzUHRzWyBpIF0gPSB0aGlzLmhvbGVzWyBpIF0uZ2V0UG9pbnRzKCBkaXZpc2lvbnMgKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGhvbGVzUHRzO1xyXG5cclxufTtcclxuXHJcblxyXG4vLyBHZXQgcG9pbnRzIG9mIHNoYXBlIGFuZCBob2xlcyAoa2V5cG9pbnRzIGJhc2VkIG9uIHNlZ21lbnRzIHBhcmFtZXRlcilcclxuXHJcblRIUkVFLlNoYXBlLnByb3RvdHlwZS5leHRyYWN0QWxsUG9pbnRzID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuXHJcbiAgICAgICAgc2hhcGU6IHRoaXMuZ2V0UG9pbnRzKCBkaXZpc2lvbnMgKSxcclxuICAgICAgICBob2xlczogdGhpcy5nZXRQb2ludHNIb2xlcyggZGl2aXNpb25zIClcclxuXHJcbiAgICB9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNoYXBlLnByb3RvdHlwZS5leHRyYWN0UG9pbnRzID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuZXh0cmFjdEFsbFBvaW50cyggZGl2aXNpb25zICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU2hhcGUuVXRpbHMgPSBUSFJFRS5TaGFwZVV0aWxzOyAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9MaW5lQ3VydmUuanNcclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0TGluZVxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5USFJFRS5MaW5lQ3VydmUgPSBmdW5jdGlvbiAoIHYxLCB2MiApIHtcclxuXHJcbiAgICB0aGlzLnYxID0gdjE7XHJcbiAgICB0aGlzLnYyID0gdjI7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xyXG5USFJFRS5MaW5lQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGluZUN1cnZlO1xyXG5cclxuVEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcclxuXHJcbiAgICB2YXIgcG9pbnQgPSB0aGlzLnYyLmNsb25lKCkuc3ViKCB0aGlzLnYxICk7XHJcbiAgICBwb2ludC5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy52MSApO1xyXG5cclxuICAgIHJldHVybiBwb2ludDtcclxuXHJcbn07XHJcblxyXG4vLyBMaW5lIGN1cnZlIGlzIGxpbmVhciwgc28gd2UgY2FuIG92ZXJ3cml0ZSBkZWZhdWx0IGdldFBvaW50QXRcclxuXHJcblRIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnRBdCA9IGZ1bmN0aW9uICggdSApIHtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5nZXRQb2ludCggdSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uKCB0ICkge1xyXG5cclxuICAgIHZhciB0YW5nZW50ID0gdGhpcy52Mi5jbG9uZSgpLnN1YiggdGhpcy52MSApO1xyXG5cclxuICAgIHJldHVybiB0YW5nZW50Lm5vcm1hbGl6ZSgpO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvUXVhZHJhdGljQmV6aWVyQ3VydmUuanNcclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0UXVhZHJhdGljIEJlemllciBjdXJ2ZVxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5cclxuVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUgPSBmdW5jdGlvbiAoIHYwLCB2MSwgdjIgKSB7XHJcblxyXG4gICAgdGhpcy52MCA9IHYwO1xyXG4gICAgdGhpcy52MSA9IHYxO1xyXG4gICAgdGhpcy52MiA9IHYyO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xyXG5USFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZTtcclxuXHJcblxyXG5USFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG4gICAgdmFyIGIyID0gVEhSRUUuU2hhcGVVdGlscy5iMjtcclxuXHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoXHJcbiAgICAgICAgYjIoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLnggKSxcclxuICAgICAgICBiMiggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSApXHJcbiAgICApO1xyXG5cclxufTtcclxuXHJcblxyXG5USFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uKCB0ICkge1xyXG5cclxuICAgIHZhciB0YW5nZW50UXVhZHJhdGljQmV6aWVyID0gVEhSRUUuQ3VydmVVdGlscy50YW5nZW50UXVhZHJhdGljQmV6aWVyO1xyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMihcclxuICAgICAgICB0YW5nZW50UXVhZHJhdGljQmV6aWVyKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54ICksXHJcbiAgICAgICAgdGFuZ2VudFF1YWRyYXRpY0JlemllciggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSApXHJcbiAgICApLm5vcm1hbGl6ZSgpO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvQ3ViaWNCZXppZXJDdXJ2ZS5qc1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRDdWJpYyBCZXppZXIgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZSA9IGZ1bmN0aW9uICggdjAsIHYxLCB2MiwgdjMgKSB7XHJcblxyXG4gICAgdGhpcy52MCA9IHYwO1xyXG4gICAgdGhpcy52MSA9IHYxO1xyXG4gICAgdGhpcy52MiA9IHYyO1xyXG4gICAgdGhpcy52MyA9IHYzO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XHJcblRIUkVFLkN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZTtcclxuXHJcblRIUkVFLkN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuICAgIHZhciBiMyA9IFRIUkVFLlNoYXBlVXRpbHMuYjM7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKFxyXG4gICAgICAgIGIzKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54LCB0aGlzLnYzLnggKSxcclxuICAgICAgICBiMyggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSwgdGhpcy52My55IClcclxuICAgICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uKCB0ICkge1xyXG5cclxuICAgIHZhciB0YW5nZW50Q3ViaWNCZXppZXIgPSBUSFJFRS5DdXJ2ZVV0aWxzLnRhbmdlbnRDdWJpY0JlemllcjtcclxuXHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoXHJcbiAgICAgICAgdGFuZ2VudEN1YmljQmV6aWVyKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54LCB0aGlzLnYzLnggKSxcclxuICAgICAgICB0YW5nZW50Q3ViaWNCZXppZXIoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnksIHRoaXMudjMueSApXHJcbiAgICApLm5vcm1hbGl6ZSgpO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvU3BsaW5lQ3VydmUuanNcclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0U3BsaW5lIGN1cnZlXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblRIUkVFLlNwbGluZUN1cnZlID0gZnVuY3Rpb24gKCBwb2ludHMgLyogYXJyYXkgb2YgVmVjdG9yMiAqLyApIHtcclxuXHJcbiAgICB0aGlzLnBvaW50cyA9ICggcG9pbnRzID09IHVuZGVmaW5lZCApID8gW10gOiBwb2ludHM7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU3BsaW5lQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XHJcblRIUkVFLlNwbGluZUN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwbGluZUN1cnZlO1xyXG5cclxuVEhSRUUuU3BsaW5lQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcclxuICAgIHZhciBwb2ludCA9ICggcG9pbnRzLmxlbmd0aCAtIDEgKSAqIHQ7XHJcblxyXG4gICAgdmFyIGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcclxuICAgIHZhciB3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xyXG5cclxuICAgIHZhciBwb2ludDAgPSBwb2ludHNbIGludFBvaW50ID09PSAwID8gaW50UG9pbnQgOiBpbnRQb2ludCAtIDEgXTtcclxuICAgIHZhciBwb2ludDEgPSBwb2ludHNbIGludFBvaW50IF07XHJcbiAgICB2YXIgcG9pbnQyID0gcG9pbnRzWyBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAyID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDEgXTtcclxuICAgIHZhciBwb2ludDMgPSBwb2ludHNbIGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDMgPyBwb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMiBdO1xyXG5cclxuICAgIHZhciBpbnRlcnBvbGF0ZSA9IFRIUkVFLkN1cnZlVXRpbHMuaW50ZXJwb2xhdGU7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKFxyXG4gICAgICAgIGludGVycG9sYXRlKCBwb2ludDAueCwgcG9pbnQxLngsIHBvaW50Mi54LCBwb2ludDMueCwgd2VpZ2h0ICksXHJcbiAgICAgICAgaW50ZXJwb2xhdGUoIHBvaW50MC55LCBwb2ludDEueSwgcG9pbnQyLnksIHBvaW50My55LCB3ZWlnaHQgKVxyXG4gICAgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0VsbGlwc2VDdXJ2ZS5qc1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRFbGxpcHNlIGN1cnZlXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblRIUkVFLkVsbGlwc2VDdXJ2ZSA9IGZ1bmN0aW9uICggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKSB7XHJcblxyXG4gICAgdGhpcy5hWCA9IGFYO1xyXG4gICAgdGhpcy5hWSA9IGFZO1xyXG5cclxuICAgIHRoaXMueFJhZGl1cyA9IHhSYWRpdXM7XHJcbiAgICB0aGlzLnlSYWRpdXMgPSB5UmFkaXVzO1xyXG5cclxuICAgIHRoaXMuYVN0YXJ0QW5nbGUgPSBhU3RhcnRBbmdsZTtcclxuICAgIHRoaXMuYUVuZEFuZ2xlID0gYUVuZEFuZ2xlO1xyXG5cclxuICAgIHRoaXMuYUNsb2Nrd2lzZSA9IGFDbG9ja3dpc2U7XHJcblxyXG4gICAgdGhpcy5hUm90YXRpb24gPSBhUm90YXRpb24gfHwgMDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5FbGxpcHNlQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XHJcblRIUkVFLkVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5FbGxpcHNlQ3VydmU7XHJcblxyXG5USFJFRS5FbGxpcHNlQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuICAgIHZhciBkZWx0YUFuZ2xlID0gdGhpcy5hRW5kQW5nbGUgLSB0aGlzLmFTdGFydEFuZ2xlO1xyXG5cclxuICAgIGlmICggZGVsdGFBbmdsZSA8IDAgKSBkZWx0YUFuZ2xlICs9IE1hdGguUEkgKiAyO1xyXG4gICAgaWYgKCBkZWx0YUFuZ2xlID4gTWF0aC5QSSAqIDIgKSBkZWx0YUFuZ2xlIC09IE1hdGguUEkgKiAyO1xyXG5cclxuICAgIHZhciBhbmdsZTtcclxuXHJcbiAgICBpZiAoIHRoaXMuYUNsb2Nrd2lzZSA9PT0gdHJ1ZSApIHtcclxuXHJcbiAgICAgICAgYW5nbGUgPSB0aGlzLmFFbmRBbmdsZSArICggMSAtIHQgKSAqICggTWF0aC5QSSAqIDIgLSBkZWx0YUFuZ2xlICk7XHJcblxyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgYW5nbGUgPSB0aGlzLmFTdGFydEFuZ2xlICsgdCAqIGRlbHRhQW5nbGU7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHZhciB4ID0gdGhpcy5hWCArIHRoaXMueFJhZGl1cyAqIE1hdGguY29zKCBhbmdsZSApO1xyXG4gICAgdmFyIHkgPSB0aGlzLmFZICsgdGhpcy55UmFkaXVzICogTWF0aC5zaW4oIGFuZ2xlICk7XHJcblxyXG4gICAgaWYgKCB0aGlzLmFSb3RhdGlvbiAhPT0gMCApIHtcclxuXHJcbiAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKCB0aGlzLmFSb3RhdGlvbiApO1xyXG4gICAgICAgIHZhciBzaW4gPSBNYXRoLnNpbiggdGhpcy5hUm90YXRpb24gKTtcclxuXHJcbiAgICAgICAgdmFyIHR4ID0geCwgdHkgPSB5O1xyXG5cclxuICAgICAgICAvLyBSb3RhdGUgdGhlIHBvaW50IGFib3V0IHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2UuXHJcbiAgICAgICAgeCA9ICggdHggLSB0aGlzLmFYICkgKiBjb3MgLSAoIHR5IC0gdGhpcy5hWSApICogc2luICsgdGhpcy5hWDtcclxuICAgICAgICB5ID0gKCB0eCAtIHRoaXMuYVggKSAqIHNpbiArICggdHkgLSB0aGlzLmFZICkgKiBjb3MgKyB0aGlzLmFZO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoIHgsIHkgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0FyY0N1cnZlLmpzXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdEFyYyBjdXJ2ZVxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5USFJFRS5BcmNDdXJ2ZSA9IGZ1bmN0aW9uICggYVgsIGFZLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xyXG5cclxuICAgIFRIUkVFLkVsbGlwc2VDdXJ2ZS5jYWxsKCB0aGlzLCBhWCwgYVksIGFSYWRpdXMsIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BcmNDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5FbGxpcHNlQ3VydmUucHJvdG90eXBlICk7XHJcblRIUkVFLkFyY0N1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkFyY0N1cnZlO1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9MaW5lQ3VydmUzLmpzXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdExpbmUzRFxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5USFJFRS5MaW5lQ3VydmUzID0gVEhSRUUuQ3VydmUuY3JlYXRlKFxyXG5cclxuICAgIGZ1bmN0aW9uICggdjEsIHYyICkge1xyXG5cclxuICAgICAgICB0aGlzLnYxID0gdjE7XHJcbiAgICAgICAgdGhpcy52MiA9IHYyO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuICAgICAgICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgdmVjdG9yLnN1YlZlY3RvcnMoIHRoaXMudjIsIHRoaXMudjEgKTsgLy8gZGlmZlxyXG4gICAgICAgIHZlY3Rvci5tdWx0aXBseVNjYWxhciggdCApO1xyXG4gICAgICAgIHZlY3Rvci5hZGQoIHRoaXMudjEgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHZlY3RvcjtcclxuXHJcbiAgICB9XHJcblxyXG4pO1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9RdWFkcmF0aWNCZXppZXJDdXJ2ZTMuanNcclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0UXVhZHJhdGljIEJlemllciAzRCBjdXJ2ZVxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5USFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXHJcblxyXG4gICAgZnVuY3Rpb24gKCB2MCwgdjEsIHYyICkge1xyXG5cclxuICAgICAgICB0aGlzLnYwID0gdjA7XHJcbiAgICAgICAgdGhpcy52MSA9IHYxO1xyXG4gICAgICAgIHRoaXMudjIgPSB2MjtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGZ1bmN0aW9uICggdCApIHtcclxuXHJcbiAgICAgICAgdmFyIGIyID0gVEhSRUUuU2hhcGVVdGlscy5iMjtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKFxyXG4gICAgICAgICAgICBiMiggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCApLFxyXG4gICAgICAgICAgICBiMiggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSApLFxyXG4gICAgICAgICAgICBiMiggdCwgdGhpcy52MC56LCB0aGlzLnYxLnosIHRoaXMudjIueiApXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICB9XHJcblxyXG4pO1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9DdWJpY0JlemllckN1cnZlMy5qc1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRDdWJpYyBCZXppZXIgM0QgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXHJcblxyXG4gICAgZnVuY3Rpb24gKCB2MCwgdjEsIHYyLCB2MyApIHtcclxuXHJcbiAgICAgICAgdGhpcy52MCA9IHYwO1xyXG4gICAgICAgIHRoaXMudjEgPSB2MTtcclxuICAgICAgICB0aGlzLnYyID0gdjI7XHJcbiAgICAgICAgdGhpcy52MyA9IHYzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuICAgICAgICB2YXIgYjMgPSBUSFJFRS5TaGFwZVV0aWxzLmIzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoXHJcbiAgICAgICAgICAgIGIzKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54LCB0aGlzLnYzLnggKSxcclxuICAgICAgICAgICAgYjMoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnksIHRoaXMudjMueSApLFxyXG4gICAgICAgICAgICBiMyggdCwgdGhpcy52MC56LCB0aGlzLnYxLnosIHRoaXMudjIueiwgdGhpcy52My56IClcclxuICAgICAgICApO1xyXG5cclxuICAgIH1cclxuXHJcbik7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL1NwbGluZUN1cnZlMy5qc1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRTcGxpbmUgM0QgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuXHJcblRIUkVFLlNwbGluZUN1cnZlMyA9IFRIUkVFLkN1cnZlLmNyZWF0ZShcclxuXHJcbiAgICBmdW5jdGlvbiAoIHBvaW50cyAvKiBhcnJheSBvZiBWZWN0b3IzICovICkge1xyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5TcGxpbmVDdXJ2ZTMgd2lsbCBiZSBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFRIUkVFLkNhdG11bGxSb21DdXJ2ZTMnICk7XHJcbiAgICAgICAgdGhpcy5wb2ludHMgPSAoIHBvaW50cyA9PSB1bmRlZmluZWQgKSA/IFtdIDogcG9pbnRzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XHJcbiAgICAgICAgdmFyIHBvaW50ID0gKCBwb2ludHMubGVuZ3RoIC0gMSApICogdDtcclxuXHJcbiAgICAgICAgdmFyIGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcclxuICAgICAgICB2YXIgd2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcclxuXHJcbiAgICAgICAgdmFyIHBvaW50MCA9IHBvaW50c1sgaW50UG9pbnQgPT0gMCA/IGludFBvaW50IDogaW50UG9pbnQgLSAxIF07XHJcbiAgICAgICAgdmFyIHBvaW50MSA9IHBvaW50c1sgaW50UG9pbnQgXTtcclxuICAgICAgICB2YXIgcG9pbnQyID0gcG9pbnRzWyBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAyID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDEgXTtcclxuICAgICAgICB2YXIgcG9pbnQzID0gcG9pbnRzWyBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAzID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDIgXTtcclxuXHJcbiAgICAgICAgdmFyIGludGVycG9sYXRlID0gVEhSRUUuQ3VydmVVdGlscy5pbnRlcnBvbGF0ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKFxyXG4gICAgICAgICAgICBpbnRlcnBvbGF0ZSggcG9pbnQwLngsIHBvaW50MS54LCBwb2ludDIueCwgcG9pbnQzLngsIHdlaWdodCApLFxyXG4gICAgICAgICAgICBpbnRlcnBvbGF0ZSggcG9pbnQwLnksIHBvaW50MS55LCBwb2ludDIueSwgcG9pbnQzLnksIHdlaWdodCApLFxyXG4gICAgICAgICAgICBpbnRlcnBvbGF0ZSggcG9pbnQwLnosIHBvaW50MS56LCBwb2ludDIueiwgcG9pbnQzLnosIHdlaWdodCApXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICB9XHJcblxyXG4pO1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9DYXRtdWxsUm9tQ3VydmUzLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciB6ejg1IGh0dHBzOi8vZ2l0aHViLmNvbS96ejg1XHJcbiAqXHJcbiAqIENlbnRyaXBldGFsIENhdG11bGxSb20gQ3VydmUgLSB3aGljaCBpcyB1c2VmdWwgZm9yIGF2b2lkaW5nXHJcbiAqIGN1c3BzIGFuZCBzZWxmLWludGVyc2VjdGlvbnMgaW4gbm9uLXVuaWZvcm0gY2F0bXVsbCByb20gY3VydmVzLlxyXG4gKiBodHRwOi8vd3d3LmNlbXl1a3NlbC5jb20vcmVzZWFyY2gvY2F0bXVsbHJvbV9wYXJhbS9jYXRtdWxscm9tLnBkZlxyXG4gKlxyXG4gKiBjdXJ2ZS50eXBlIGFjY2VwdHMgY2VudHJpcGV0YWwoZGVmYXVsdCksIGNob3JkYWwgYW5kIGNhdG11bGxyb21cclxuICogY3VydmUudGVuc2lvbiBpcyB1c2VkIGZvciBjYXRtdWxscm9tIHdoaWNoIGRlZmF1bHRzIHRvIDAuNVxyXG4gKi9cclxuXHJcblRIUkVFLkNhdG11bGxSb21DdXJ2ZTMgPSAoIGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhclxyXG4gICAgICAgIHRtcCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcbiAgICAgICAgcHggPSBuZXcgQ3ViaWNQb2x5KCksXHJcbiAgICAgICAgcHkgPSBuZXcgQ3ViaWNQb2x5KCksXHJcbiAgICAgICAgcHogPSBuZXcgQ3ViaWNQb2x5KCk7XHJcblxyXG4gICAgLypcclxuICAgICBCYXNlZCBvbiBhbiBvcHRpbWl6ZWQgYysrIHNvbHV0aW9uIGluXHJcbiAgICAgLSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzk0ODk3MzYvY2F0bXVsbC1yb20tY3VydmUtd2l0aC1uby1jdXNwcy1hbmQtbm8tc2VsZi1pbnRlcnNlY3Rpb25zL1xyXG4gICAgIC0gaHR0cDovL2lkZW9uZS5jb20vTm9FYlZNXHJcblxyXG4gICAgIFRoaXMgQ3ViaWNQb2x5IGNsYXNzIGNvdWxkIGJlIHVzZWQgZm9yIHJldXNpbmcgc29tZSB2YXJpYWJsZXMgYW5kIGNhbGN1bGF0aW9ucyxcclxuICAgICBidXQgZm9yIHRocmVlLmpzIGN1cnZlIHVzZSwgaXQgY291bGQgYmUgcG9zc2libGUgaW5saW5lZCBhbmQgZmxhdHRlbiBpbnRvIGEgc2luZ2xlIGZ1bmN0aW9uIGNhbGxcclxuICAgICB3aGljaCBjYW4gYmUgcGxhY2VkIGluIEN1cnZlVXRpbHMuXHJcbiAgICAgKi9cclxuXHJcbiAgICBmdW5jdGlvbiBDdWJpY1BvbHkoKSB7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBDb21wdXRlIGNvZWZmaWNpZW50cyBmb3IgYSBjdWJpYyBwb2x5bm9taWFsXHJcbiAgICAgKiAgIHAocykgPSBjMCArIGMxKnMgKyBjMipzXjIgKyBjMypzXjNcclxuICAgICAqIHN1Y2ggdGhhdFxyXG4gICAgICogICBwKDApID0geDAsIHAoMSkgPSB4MVxyXG4gICAgICogIGFuZFxyXG4gICAgICogICBwJygwKSA9IHQwLCBwJygxKSA9IHQxLlxyXG4gICAgICovXHJcbiAgICBDdWJpY1BvbHkucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiggeDAsIHgxLCB0MCwgdDEgKSB7XHJcblxyXG4gICAgICAgIHRoaXMuYzAgPSB4MDtcclxuICAgICAgICB0aGlzLmMxID0gdDA7XHJcbiAgICAgICAgdGhpcy5jMiA9IC0gMyAqIHgwICsgMyAqIHgxIC0gMiAqIHQwIC0gdDE7XHJcbiAgICAgICAgdGhpcy5jMyA9IDIgKiB4MCAtIDIgKiB4MSArIHQwICsgdDE7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBDdWJpY1BvbHkucHJvdG90eXBlLmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSA9IGZ1bmN0aW9uKCB4MCwgeDEsIHgyLCB4MywgZHQwLCBkdDEsIGR0MiApIHtcclxuXHJcbiAgICAgICAgLy8gY29tcHV0ZSB0YW5nZW50cyB3aGVuIHBhcmFtZXRlcml6ZWQgaW4gW3QxLHQyXVxyXG4gICAgICAgIHZhciB0MSA9ICggeDEgLSB4MCApIC8gZHQwIC0gKCB4MiAtIHgwICkgLyAoIGR0MCArIGR0MSApICsgKCB4MiAtIHgxICkgLyBkdDE7XHJcbiAgICAgICAgdmFyIHQyID0gKCB4MiAtIHgxICkgLyBkdDEgLSAoIHgzIC0geDEgKSAvICggZHQxICsgZHQyICkgKyAoIHgzIC0geDIgKSAvIGR0MjtcclxuXHJcbiAgICAgICAgLy8gcmVzY2FsZSB0YW5nZW50cyBmb3IgcGFyYW1ldHJpemF0aW9uIGluIFswLDFdXHJcbiAgICAgICAgdDEgKj0gZHQxO1xyXG4gICAgICAgIHQyICo9IGR0MTtcclxuXHJcbiAgICAgICAgLy8gaW5pdEN1YmljUG9seVxyXG4gICAgICAgIHRoaXMuaW5pdCggeDEsIHgyLCB0MSwgdDIgKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIHN0YW5kYXJkIENhdG11bGwtUm9tIHNwbGluZTogaW50ZXJwb2xhdGUgYmV0d2VlbiB4MSBhbmQgeDIgd2l0aCBwcmV2aW91cy9mb2xsb3dpbmcgcG9pbnRzIHgxL3g0XHJcbiAgICBDdWJpY1BvbHkucHJvdG90eXBlLmluaXRDYXRtdWxsUm9tID0gZnVuY3Rpb24oIHgwLCB4MSwgeDIsIHgzLCB0ZW5zaW9uICkge1xyXG5cclxuICAgICAgICB0aGlzLmluaXQoIHgxLCB4MiwgdGVuc2lvbiAqICggeDIgLSB4MCApLCB0ZW5zaW9uICogKCB4MyAtIHgxICkgKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIEN1YmljUG9seS5wcm90b3R5cGUuY2FsYyA9IGZ1bmN0aW9uKCB0ICkge1xyXG5cclxuICAgICAgICB2YXIgdDIgPSB0ICogdDtcclxuICAgICAgICB2YXIgdDMgPSB0MiAqIHQ7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYzAgKyB0aGlzLmMxICogdCArIHRoaXMuYzIgKiB0MiArIHRoaXMuYzMgKiB0MztcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFN1YmNsYXNzIFRocmVlLmpzIGN1cnZlXHJcbiAgICByZXR1cm4gVEhSRUUuQ3VydmUuY3JlYXRlKFxyXG5cclxuICAgICAgICBmdW5jdGlvbiAoIHAgLyogYXJyYXkgb2YgVmVjdG9yMyAqLyApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucG9pbnRzID0gcCB8fCBbXTtcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzLFxyXG4gICAgICAgICAgICAgICAgcG9pbnQsIGludFBvaW50LCB3ZWlnaHQsIGw7XHJcblxyXG4gICAgICAgICAgICBsID0gcG9pbnRzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIGlmICggbCA8IDIgKSBjb25zb2xlLmxvZyggJ2R1aCwgeW91IG5lZWQgYXQgbGVhc3QgMiBwb2ludHMnICk7XHJcblxyXG4gICAgICAgICAgICBwb2ludCA9ICggbCAtIDEgKSAqIHQ7XHJcbiAgICAgICAgICAgIGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcclxuICAgICAgICAgICAgd2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcclxuXHJcbiAgICAgICAgICAgIGlmICggd2VpZ2h0ID09PSAwICYmIGludFBvaW50ID09PSBsIC0gMSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpbnRQb2ludCA9IGwgLSAyO1xyXG4gICAgICAgICAgICAgICAgd2VpZ2h0ID0gMTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBwMCwgcDEsIHAyLCBwMztcclxuXHJcbiAgICAgICAgICAgIGlmICggaW50UG9pbnQgPT09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gZXh0cmFwb2xhdGUgZmlyc3QgcG9pbnRcclxuICAgICAgICAgICAgICAgIHRtcC5zdWJWZWN0b3JzKCBwb2ludHNbIDAgXSwgcG9pbnRzWyAxIF0gKS5hZGQoIHBvaW50c1sgMCBdICk7XHJcbiAgICAgICAgICAgICAgICBwMCA9IHRtcDtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcDAgPSBwb2ludHNbIGludFBvaW50IC0gMSBdO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcDEgPSBwb2ludHNbIGludFBvaW50IF07XHJcbiAgICAgICAgICAgIHAyID0gcG9pbnRzWyBpbnRQb2ludCArIDEgXTtcclxuXHJcbiAgICAgICAgICAgIGlmICggaW50UG9pbnQgKyAyIDwgbCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBwMyA9IHBvaW50c1sgaW50UG9pbnQgKyAyIF1cclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gZXh0cmFwb2xhdGUgbGFzdCBwb2ludFxyXG4gICAgICAgICAgICAgICAgdG1wLnN1YlZlY3RvcnMoIHBvaW50c1sgbCAtIDEgXSwgcG9pbnRzWyBsIC0gMiBdICkuYWRkKCBwb2ludHNbIGwgLSAyIF0gKTtcclxuICAgICAgICAgICAgICAgIHAzID0gdG1wO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCB0aGlzLnR5cGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLnR5cGUgPT09ICdjZW50cmlwZXRhbCcgfHwgdGhpcy50eXBlID09PSAnY2hvcmRhbCcgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaW5pdCBDZW50cmlwZXRhbCAvIENob3JkYWwgQ2F0bXVsbC1Sb21cclxuICAgICAgICAgICAgICAgIHZhciBwb3cgPSB0aGlzLnR5cGUgPT09ICdjaG9yZGFsJyA/IDAuNSA6IDAuMjU7XHJcbiAgICAgICAgICAgICAgICB2YXIgZHQwID0gTWF0aC5wb3coIHAwLmRpc3RhbmNlVG9TcXVhcmVkKCBwMSApLCBwb3cgKTtcclxuICAgICAgICAgICAgICAgIHZhciBkdDEgPSBNYXRoLnBvdyggcDEuZGlzdGFuY2VUb1NxdWFyZWQoIHAyICksIHBvdyApO1xyXG4gICAgICAgICAgICAgICAgdmFyIGR0MiA9IE1hdGgucG93KCBwMi5kaXN0YW5jZVRvU3F1YXJlZCggcDMgKSwgcG93ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gc2FmZXR5IGNoZWNrIGZvciByZXBlYXRlZCBwb2ludHNcclxuICAgICAgICAgICAgICAgIGlmICggZHQxIDwgMWUtNCApIGR0MSA9IDEuMDtcclxuICAgICAgICAgICAgICAgIGlmICggZHQwIDwgMWUtNCApIGR0MCA9IGR0MTtcclxuICAgICAgICAgICAgICAgIGlmICggZHQyIDwgMWUtNCApIGR0MiA9IGR0MTtcclxuXHJcbiAgICAgICAgICAgICAgICBweC5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oIHAwLngsIHAxLngsIHAyLngsIHAzLngsIGR0MCwgZHQxLCBkdDIgKTtcclxuICAgICAgICAgICAgICAgIHB5LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSggcDAueSwgcDEueSwgcDIueSwgcDMueSwgZHQwLCBkdDEsIGR0MiApO1xyXG4gICAgICAgICAgICAgICAgcHouaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tKCBwMC56LCBwMS56LCBwMi56LCBwMy56LCBkdDAsIGR0MSwgZHQyICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCB0aGlzLnR5cGUgPT09ICdjYXRtdWxscm9tJyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdGVuc2lvbiA9IHRoaXMudGVuc2lvbiAhPT0gdW5kZWZpbmVkID8gdGhpcy50ZW5zaW9uIDogMC41O1xyXG4gICAgICAgICAgICAgICAgcHguaW5pdENhdG11bGxSb20oIHAwLngsIHAxLngsIHAyLngsIHAzLngsIHRlbnNpb24gKTtcclxuICAgICAgICAgICAgICAgIHB5LmluaXRDYXRtdWxsUm9tKCBwMC55LCBwMS55LCBwMi55LCBwMy55LCB0ZW5zaW9uICk7XHJcbiAgICAgICAgICAgICAgICBwei5pbml0Q2F0bXVsbFJvbSggcDAueiwgcDEueiwgcDIueiwgcDMueiwgdGVuc2lvbiApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHYgPSBuZXcgVEhSRUUuVmVjdG9yMyhcclxuICAgICAgICAgICAgICAgIHB4LmNhbGMoIHdlaWdodCApLFxyXG4gICAgICAgICAgICAgICAgcHkuY2FsYyggd2VpZ2h0ICksXHJcbiAgICAgICAgICAgICAgICBwei5jYWxjKCB3ZWlnaHQgKVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHY7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICApO1xyXG5cclxufSApKCk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0Nsb3NlZFNwbGluZUN1cnZlMy5qc1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRDbG9zZWQgU3BsaW5lIDNEIGN1cnZlXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblxyXG5USFJFRS5DbG9zZWRTcGxpbmVDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXHJcblxyXG4gICAgZnVuY3Rpb24gKCBwb2ludHMgLyogYXJyYXkgb2YgVmVjdG9yMyAqLyApIHtcclxuXHJcbiAgICAgICAgdGhpcy5wb2ludHMgPSAoIHBvaW50cyA9PSB1bmRlZmluZWQgKSA/IFtdIDogcG9pbnRzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XHJcbiAgICAgICAgdmFyIHBvaW50ID0gKCBwb2ludHMubGVuZ3RoIC0gMCApICogdDsgLy8gVGhpcyBuZWVkcyB0byBiZSBmcm9tIDAtbGVuZ3RoICsxXHJcblxyXG4gICAgICAgIHZhciBpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XHJcbiAgICAgICAgdmFyIHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XHJcblxyXG4gICAgICAgIGludFBvaW50ICs9IGludFBvaW50ID4gMCA/IDAgOiAoIE1hdGguZmxvb3IoIE1hdGguYWJzKCBpbnRQb2ludCApIC8gcG9pbnRzLmxlbmd0aCApICsgMSApICogcG9pbnRzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgdmFyIHBvaW50MCA9IHBvaW50c1sgKCBpbnRQb2ludCAtIDEgKSAlIHBvaW50cy5sZW5ndGggXTtcclxuICAgICAgICB2YXIgcG9pbnQxID0gcG9pbnRzWyAoIGludFBvaW50ICAgICApICUgcG9pbnRzLmxlbmd0aCBdO1xyXG4gICAgICAgIHZhciBwb2ludDIgPSBwb2ludHNbICggaW50UG9pbnQgKyAxICkgJSBwb2ludHMubGVuZ3RoIF07XHJcbiAgICAgICAgdmFyIHBvaW50MyA9IHBvaW50c1sgKCBpbnRQb2ludCArIDIgKSAlIHBvaW50cy5sZW5ndGggXTtcclxuXHJcbiAgICAgICAgdmFyIGludGVycG9sYXRlID0gVEhSRUUuQ3VydmVVdGlscy5pbnRlcnBvbGF0ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKFxyXG4gICAgICAgICAgICBpbnRlcnBvbGF0ZSggcG9pbnQwLngsIHBvaW50MS54LCBwb2ludDIueCwgcG9pbnQzLngsIHdlaWdodCApLFxyXG4gICAgICAgICAgICBpbnRlcnBvbGF0ZSggcG9pbnQwLnksIHBvaW50MS55LCBwb2ludDIueSwgcG9pbnQzLnksIHdlaWdodCApLFxyXG4gICAgICAgICAgICBpbnRlcnBvbGF0ZSggcG9pbnQwLnosIHBvaW50MS56LCBwb2ludDIueiwgcG9pbnQzLnosIHdlaWdodCApXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICB9XHJcblxyXG4pO1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvQm94R2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBiYXNlZCBvbiBodHRwOi8vcGFwZXJ2aXNpb24zZC5nb29nbGVjb2RlLmNvbS9zdm4vdHJ1bmsvYXMzL3RydW5rL3NyYy9vcmcvcGFwZXJ2aXNpb24zZC9vYmplY3RzL3ByaW1pdGl2ZXMvQ3ViZS5hc1xyXG4gKi9cclxuXHJcblRIUkVFLkJveEdlb21ldHJ5ID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIGRlcHRoU2VnbWVudHMgKSB7XHJcblxyXG4gICAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdCb3hHZW9tZXRyeSc7XHJcblxyXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xyXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICBkZXB0aDogZGVwdGgsXHJcbiAgICAgICAgd2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcclxuICAgICAgICBoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXHJcbiAgICAgICAgZGVwdGhTZWdtZW50czogZGVwdGhTZWdtZW50c1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLndpZHRoU2VnbWVudHMgPSB3aWR0aFNlZ21lbnRzIHx8IDE7XHJcbiAgICB0aGlzLmhlaWdodFNlZ21lbnRzID0gaGVpZ2h0U2VnbWVudHMgfHwgMTtcclxuICAgIHRoaXMuZGVwdGhTZWdtZW50cyA9IGRlcHRoU2VnbWVudHMgfHwgMTtcclxuXHJcbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuICAgIHZhciB3aWR0aF9oYWxmID0gd2lkdGggLyAyO1xyXG4gICAgdmFyIGhlaWdodF9oYWxmID0gaGVpZ2h0IC8gMjtcclxuICAgIHZhciBkZXB0aF9oYWxmID0gZGVwdGggLyAyO1xyXG5cclxuICAgIGJ1aWxkUGxhbmUoICd6JywgJ3knLCAtIDEsIC0gMSwgZGVwdGgsIGhlaWdodCwgd2lkdGhfaGFsZiwgMCApOyAvLyBweFxyXG4gICAgYnVpbGRQbGFuZSggJ3onLCAneScsICAgMSwgLSAxLCBkZXB0aCwgaGVpZ2h0LCAtIHdpZHRoX2hhbGYsIDEgKTsgLy8gbnhcclxuICAgIGJ1aWxkUGxhbmUoICd4JywgJ3onLCAgIDEsICAgMSwgd2lkdGgsIGRlcHRoLCBoZWlnaHRfaGFsZiwgMiApOyAvLyBweVxyXG4gICAgYnVpbGRQbGFuZSggJ3gnLCAneicsICAgMSwgLSAxLCB3aWR0aCwgZGVwdGgsIC0gaGVpZ2h0X2hhbGYsIDMgKTsgLy8gbnlcclxuICAgIGJ1aWxkUGxhbmUoICd4JywgJ3knLCAgIDEsIC0gMSwgd2lkdGgsIGhlaWdodCwgZGVwdGhfaGFsZiwgNCApOyAvLyBwelxyXG4gICAgYnVpbGRQbGFuZSggJ3gnLCAneScsIC0gMSwgLSAxLCB3aWR0aCwgaGVpZ2h0LCAtIGRlcHRoX2hhbGYsIDUgKTsgLy8gbnpcclxuXHJcbiAgICBmdW5jdGlvbiBidWlsZFBsYW5lKCB1LCB2LCB1ZGlyLCB2ZGlyLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgbWF0ZXJpYWxJbmRleCApIHtcclxuXHJcbiAgICAgICAgdmFyIHcsIGl4LCBpeSxcclxuICAgICAgICAgICAgZ3JpZFggPSBzY29wZS53aWR0aFNlZ21lbnRzLFxyXG4gICAgICAgICAgICBncmlkWSA9IHNjb3BlLmhlaWdodFNlZ21lbnRzLFxyXG4gICAgICAgICAgICB3aWR0aF9oYWxmID0gd2lkdGggLyAyLFxyXG4gICAgICAgICAgICBoZWlnaHRfaGFsZiA9IGhlaWdodCAvIDIsXHJcbiAgICAgICAgICAgIG9mZnNldCA9IHNjb3BlLnZlcnRpY2VzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgaWYgKCAoIHUgPT09ICd4JyAmJiB2ID09PSAneScgKSB8fCAoIHUgPT09ICd5JyAmJiB2ID09PSAneCcgKSApIHtcclxuXHJcbiAgICAgICAgICAgIHcgPSAneic7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoICggdSA9PT0gJ3gnICYmIHYgPT09ICd6JyApIHx8ICggdSA9PT0gJ3onICYmIHYgPT09ICd4JyApICkge1xyXG5cclxuICAgICAgICAgICAgdyA9ICd5JztcclxuICAgICAgICAgICAgZ3JpZFkgPSBzY29wZS5kZXB0aFNlZ21lbnRzO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCAoIHUgPT09ICd6JyAmJiB2ID09PSAneScgKSB8fCAoIHUgPT09ICd5JyAmJiB2ID09PSAneicgKSApIHtcclxuXHJcbiAgICAgICAgICAgIHcgPSAneCc7XHJcbiAgICAgICAgICAgIGdyaWRYID0gc2NvcGUuZGVwdGhTZWdtZW50cztcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZ3JpZFgxID0gZ3JpZFggKyAxLFxyXG4gICAgICAgICAgICBncmlkWTEgPSBncmlkWSArIDEsXHJcbiAgICAgICAgICAgIHNlZ21lbnRfd2lkdGggPSB3aWR0aCAvIGdyaWRYLFxyXG4gICAgICAgICAgICBzZWdtZW50X2hlaWdodCA9IGhlaWdodCAvIGdyaWRZLFxyXG4gICAgICAgICAgICBub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICBub3JtYWxbIHcgXSA9IGRlcHRoID4gMCA/IDEgOiAtIDE7XHJcblxyXG4gICAgICAgIGZvciAoIGl5ID0gMDsgaXkgPCBncmlkWTE7IGl5ICsrICkge1xyXG5cclxuICAgICAgICAgICAgZm9yICggaXggPSAwOyBpeCA8IGdyaWRYMTsgaXggKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgICAgICAgICB2ZWN0b3JbIHUgXSA9ICggaXggKiBzZWdtZW50X3dpZHRoIC0gd2lkdGhfaGFsZiApICogdWRpcjtcclxuICAgICAgICAgICAgICAgIHZlY3RvclsgdiBdID0gKCBpeSAqIHNlZ21lbnRfaGVpZ2h0IC0gaGVpZ2h0X2hhbGYgKSAqIHZkaXI7XHJcbiAgICAgICAgICAgICAgICB2ZWN0b3JbIHcgXSA9IGRlcHRoO1xyXG5cclxuICAgICAgICAgICAgICAgIHNjb3BlLnZlcnRpY2VzLnB1c2goIHZlY3RvciApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoIGl5ID0gMDsgaXkgPCBncmlkWTsgaXkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCBpeCA9IDA7IGl4IDwgZ3JpZFg7IGl4ICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBhID0gaXggKyBncmlkWDEgKiBpeTtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gaXggKyBncmlkWDEgKiAoIGl5ICsgMSApO1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogKCBpeSArIDEgKTtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gKCBpeCArIDEgKSArIGdyaWRYMSAqIGl5O1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB1dmEgPSBuZXcgVEhSRUUuVmVjdG9yMiggaXggLyBncmlkWCwgMSAtIGl5IC8gZ3JpZFkgKTtcclxuICAgICAgICAgICAgICAgIHZhciB1dmIgPSBuZXcgVEhSRUUuVmVjdG9yMiggaXggLyBncmlkWCwgMSAtICggaXkgKyAxICkgLyBncmlkWSApO1xyXG4gICAgICAgICAgICAgICAgdmFyIHV2YyA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGl4ICsgMSApIC8gZ3JpZFgsIDEgLSAoIGl5ICsgMSApIC8gZ3JpZFkgKTtcclxuICAgICAgICAgICAgICAgIHZhciB1dmQgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpeCArIDEgKSAvIGdyaWRYLCAxIC0gaXkgLyBncmlkWSApO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCBhICsgb2Zmc2V0LCBiICsgb2Zmc2V0LCBkICsgb2Zmc2V0ICk7XHJcbiAgICAgICAgICAgICAgICBmYWNlLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcclxuICAgICAgICAgICAgICAgIGZhY2UudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCksIG5vcm1hbC5jbG9uZSgpICk7XHJcbiAgICAgICAgICAgICAgICBmYWNlLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xyXG5cclxuICAgICAgICAgICAgICAgIHNjb3BlLmZhY2VzLnB1c2goIGZhY2UgKTtcclxuICAgICAgICAgICAgICAgIHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2YSwgdXZiLCB1dmQgXSApO1xyXG5cclxuICAgICAgICAgICAgICAgIGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIGIgKyBvZmZzZXQsIGMgKyBvZmZzZXQsIGQgKyBvZmZzZXQgKTtcclxuICAgICAgICAgICAgICAgIGZhY2Uubm9ybWFsLmNvcHkoIG5vcm1hbCApO1xyXG4gICAgICAgICAgICAgICAgZmFjZS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbC5jbG9uZSgpLCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCkgKTtcclxuICAgICAgICAgICAgICAgIGZhY2UubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXg7XHJcblxyXG4gICAgICAgICAgICAgICAgc2NvcGUuZmFjZXMucHVzaCggZmFjZSApO1xyXG4gICAgICAgICAgICAgICAgc2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZiLmNsb25lKCksIHV2YywgdXZkLmNsb25lKCkgXSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkJveEdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5Cb3hHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Cb3hHZW9tZXRyeTtcclxuXHJcblRIUkVFLkJveEdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcclxuXHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLkJveEdlb21ldHJ5KFxyXG4gICAgICAgIHBhcmFtZXRlcnMud2lkdGgsXHJcbiAgICAgICAgcGFyYW1ldGVycy5oZWlnaHQsXHJcbiAgICAgICAgcGFyYW1ldGVycy5kZXB0aCxcclxuICAgICAgICBwYXJhbWV0ZXJzLndpZHRoU2VnbWVudHMsXHJcbiAgICAgICAgcGFyYW1ldGVycy5oZWlnaHRTZWdtZW50cyxcclxuICAgICAgICBwYXJhbWV0ZXJzLmRlcHRoU2VnbWVudHNcclxuICAgICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ3ViZUdlb21ldHJ5ID0gVEhSRUUuQm94R2VvbWV0cnk7IC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9DaXJjbGVHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgaHVnaGVzXHJcbiAqL1xyXG5cclxuVEhSRUUuQ2lyY2xlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgc2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xyXG5cclxuICAgIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnQ2lyY2xlR2VvbWV0cnknO1xyXG5cclxuICAgIHRoaXMucGFyYW1ldGVycyA9IHtcclxuICAgICAgICByYWRpdXM6IHJhZGl1cyxcclxuICAgICAgICBzZWdtZW50czogc2VnbWVudHMsXHJcbiAgICAgICAgdGhldGFTdGFydDogdGhldGFTdGFydCxcclxuICAgICAgICB0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBUSFJFRS5DaXJjbGVCdWZmZXJHZW9tZXRyeSggcmFkaXVzLCBzZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkNpcmNsZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5DaXJjbGVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DaXJjbGVHZW9tZXRyeTtcclxuXHJcblRIUkVFLkNpcmNsZUdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcclxuXHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLkNpcmNsZUdlb21ldHJ5KFxyXG4gICAgICAgIHBhcmFtZXRlcnMucmFkaXVzLFxyXG4gICAgICAgIHBhcmFtZXRlcnMuc2VnbWVudHMsXHJcbiAgICAgICAgcGFyYW1ldGVycy50aGV0YVN0YXJ0LFxyXG4gICAgICAgIHBhcmFtZXRlcnMudGhldGFMZW5ndGhcclxuICAgICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvQ2lyY2xlQnVmZmVyR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcclxuICovXHJcblxyXG5USFJFRS5DaXJjbGVCdWZmZXJHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCBzZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XHJcblxyXG4gICAgVEhSRUUuQnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdDaXJjbGVCdWZmZXJHZW9tZXRyeSc7XHJcblxyXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xyXG4gICAgICAgIHJhZGl1czogcmFkaXVzLFxyXG4gICAgICAgIHNlZ21lbnRzOiBzZWdtZW50cyxcclxuICAgICAgICB0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxyXG4gICAgICAgIHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxyXG4gICAgfTtcclxuXHJcbiAgICByYWRpdXMgPSByYWRpdXMgfHwgNTA7XHJcbiAgICBzZWdtZW50cyA9IHNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBNYXRoLm1heCggMywgc2VnbWVudHMgKSA6IDg7XHJcblxyXG4gICAgdGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xyXG4gICAgdGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiBNYXRoLlBJICogMjtcclxuXHJcbiAgICB2YXIgdmVydGljZXMgPSBzZWdtZW50cyArIDI7XHJcblxyXG4gICAgdmFyIHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRpY2VzICogMyApO1xyXG4gICAgdmFyIG5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0aWNlcyAqIDMgKTtcclxuICAgIHZhciB1dnMgPSBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0aWNlcyAqIDIgKTtcclxuXHJcbiAgICAvLyBjZW50ZXIgZGF0YSBpcyBhbHJlYWR5IHplcm8sIGJ1dCBuZWVkIHRvIHNldCBhIGZldyBleHRyYXNcclxuICAgIG5vcm1hbHNbIDIgXSA9IDEuMDtcclxuICAgIHV2c1sgMCBdID0gMC41O1xyXG4gICAgdXZzWyAxIF0gPSAwLjU7XHJcblxyXG4gICAgZm9yICggdmFyIHMgPSAwLCBpID0gMywgaWkgPSAyIDsgcyA8PSBzZWdtZW50czsgcyArKywgaSArPSAzLCBpaSArPSAyICkge1xyXG5cclxuICAgICAgICB2YXIgc2VnbWVudCA9IHRoZXRhU3RhcnQgKyBzIC8gc2VnbWVudHMgKiB0aGV0YUxlbmd0aDtcclxuXHJcbiAgICAgICAgcG9zaXRpb25zWyBpIF0gPSByYWRpdXMgKiBNYXRoLmNvcyggc2VnbWVudCApO1xyXG4gICAgICAgIHBvc2l0aW9uc1sgaSArIDEgXSA9IHJhZGl1cyAqIE1hdGguc2luKCBzZWdtZW50ICk7XHJcblxyXG4gICAgICAgIG5vcm1hbHNbIGkgKyAyIF0gPSAxOyAvLyBub3JtYWwgelxyXG5cclxuICAgICAgICB1dnNbIGlpIF0gPSAoIHBvc2l0aW9uc1sgaSBdIC8gcmFkaXVzICsgMSApIC8gMjtcclxuICAgICAgICB1dnNbIGlpICsgMSBdID0gKCBwb3NpdGlvbnNbIGkgKyAxIF0gLyByYWRpdXMgKyAxICkgLyAyO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB2YXIgaW5kaWNlcyA9IFtdO1xyXG5cclxuICAgIGZvciAoIHZhciBpID0gMTsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcclxuXHJcbiAgICAgICAgaW5kaWNlcy5wdXNoKCBpLCBpICsgMSwgMCApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNldEluZGV4KCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgVWludDE2QXJyYXkoIGluZGljZXMgKSwgMSApICk7XHJcbiAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zLCAzICkgKTtcclxuICAgIHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XHJcbiAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcclxuXHJcbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggbmV3IFRIUkVFLlZlY3RvcjMoKSwgcmFkaXVzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ2lyY2xlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLkNpcmNsZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkNpcmNsZUJ1ZmZlckdlb21ldHJ5O1xyXG5cclxuVEhSRUUuQ2lyY2xlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuQ2lyY2xlQnVmZmVyR2VvbWV0cnkoXHJcbiAgICAgICAgcGFyYW1ldGVycy5yYWRpdXMsXHJcbiAgICAgICAgcGFyYW1ldGVycy5zZWdtZW50cyxcclxuICAgICAgICBwYXJhbWV0ZXJzLnRoZXRhU3RhcnQsXHJcbiAgICAgICAgcGFyYW1ldGVycy50aGV0YUxlbmd0aFxyXG4gICAgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9DeWxpbmRlckdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5DeWxpbmRlckdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXNUb3AsIHJhZGl1c0JvdHRvbSwgaGVpZ2h0LCByYWRpYWxTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIG9wZW5FbmRlZCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XHJcblxyXG4gICAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdDeWxpbmRlckdlb21ldHJ5JztcclxuXHJcbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgcmFkaXVzVG9wOiByYWRpdXNUb3AsXHJcbiAgICAgICAgcmFkaXVzQm90dG9tOiByYWRpdXNCb3R0b20sXHJcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgcmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxyXG4gICAgICAgIGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcclxuICAgICAgICBvcGVuRW5kZWQ6IG9wZW5FbmRlZCxcclxuICAgICAgICB0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxyXG4gICAgICAgIHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxyXG4gICAgfTtcclxuXHJcbiAgICByYWRpdXNUb3AgPSByYWRpdXNUb3AgIT09IHVuZGVmaW5lZCA/IHJhZGl1c1RvcCA6IDIwO1xyXG4gICAgcmFkaXVzQm90dG9tID0gcmFkaXVzQm90dG9tICE9PSB1bmRlZmluZWQgPyByYWRpdXNCb3R0b20gOiAyMDtcclxuICAgIGhlaWdodCA9IGhlaWdodCAhPT0gdW5kZWZpbmVkID8gaGVpZ2h0IDogMTAwO1xyXG5cclxuICAgIHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgODtcclxuICAgIGhlaWdodFNlZ21lbnRzID0gaGVpZ2h0U2VnbWVudHMgfHwgMTtcclxuXHJcbiAgICBvcGVuRW5kZWQgPSBvcGVuRW5kZWQgIT09IHVuZGVmaW5lZCA/IG9wZW5FbmRlZCA6IGZhbHNlO1xyXG4gICAgdGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xyXG4gICAgdGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiAyICogTWF0aC5QSTtcclxuXHJcbiAgICB2YXIgaGVpZ2h0SGFsZiA9IGhlaWdodCAvIDI7XHJcblxyXG4gICAgdmFyIHgsIHksIHZlcnRpY2VzID0gW10sIHV2cyA9IFtdO1xyXG5cclxuICAgIGZvciAoIHkgPSAwOyB5IDw9IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xyXG5cclxuICAgICAgICB2YXIgdmVydGljZXNSb3cgPSBbXTtcclxuICAgICAgICB2YXIgdXZzUm93ID0gW107XHJcblxyXG4gICAgICAgIHZhciB2ID0geSAvIGhlaWdodFNlZ21lbnRzO1xyXG4gICAgICAgIHZhciByYWRpdXMgPSB2ICogKCByYWRpdXNCb3R0b20gLSByYWRpdXNUb3AgKSArIHJhZGl1c1RvcDtcclxuXHJcbiAgICAgICAgZm9yICggeCA9IDA7IHggPD0gcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgdSA9IHggLyByYWRpYWxTZWdtZW50cztcclxuXHJcbiAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgICAgICB2ZXJ0ZXgueCA9IHJhZGl1cyAqIE1hdGguc2luKCB1ICogdGhldGFMZW5ndGggKyB0aGV0YVN0YXJ0ICk7XHJcbiAgICAgICAgICAgIHZlcnRleC55ID0gLSB2ICogaGVpZ2h0ICsgaGVpZ2h0SGFsZjtcclxuICAgICAgICAgICAgdmVydGV4LnogPSByYWRpdXMgKiBNYXRoLmNvcyggdSAqIHRoZXRhTGVuZ3RoICsgdGhldGFTdGFydCApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcclxuXHJcbiAgICAgICAgICAgIHZlcnRpY2VzUm93LnB1c2goIHRoaXMudmVydGljZXMubGVuZ3RoIC0gMSApO1xyXG4gICAgICAgICAgICB1dnNSb3cucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHUsIDEgLSB2ICkgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1JvdyApO1xyXG4gICAgICAgIHV2cy5wdXNoKCB1dnNSb3cgKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHRhblRoZXRhID0gKCByYWRpdXNCb3R0b20gLSByYWRpdXNUb3AgKSAvIGhlaWdodDtcclxuICAgIHZhciBuYSwgbmI7XHJcblxyXG4gICAgZm9yICggeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgeCArKyApIHtcclxuXHJcbiAgICAgICAgaWYgKCByYWRpdXNUb3AgIT09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICBuYSA9IHRoaXMudmVydGljZXNbIHZlcnRpY2VzWyAwIF1bIHggXSBdLmNsb25lKCk7XHJcbiAgICAgICAgICAgIG5iID0gdGhpcy52ZXJ0aWNlc1sgdmVydGljZXNbIDAgXVsgeCArIDEgXSBdLmNsb25lKCk7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICBuYSA9IHRoaXMudmVydGljZXNbIHZlcnRpY2VzWyAxIF1bIHggXSBdLmNsb25lKCk7XHJcbiAgICAgICAgICAgIG5iID0gdGhpcy52ZXJ0aWNlc1sgdmVydGljZXNbIDEgXVsgeCArIDEgXSBdLmNsb25lKCk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbmEuc2V0WSggTWF0aC5zcXJ0KCBuYS54ICogbmEueCArIG5hLnogKiBuYS56ICkgKiB0YW5UaGV0YSApLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIG5iLnNldFkoIE1hdGguc3FydCggbmIueCAqIG5iLnggKyBuYi56ICogbmIueiApICogdGFuVGhldGEgKS5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAgICAgZm9yICggeSA9IDA7IHkgPCBoZWlnaHRTZWdtZW50czsgeSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciB2MSA9IHZlcnRpY2VzWyB5IF1bIHggXTtcclxuICAgICAgICAgICAgdmFyIHYyID0gdmVydGljZXNbIHkgKyAxIF1bIHggXTtcclxuICAgICAgICAgICAgdmFyIHYzID0gdmVydGljZXNbIHkgKyAxIF1bIHggKyAxIF07XHJcbiAgICAgICAgICAgIHZhciB2NCA9IHZlcnRpY2VzWyB5IF1bIHggKyAxIF07XHJcblxyXG4gICAgICAgICAgICB2YXIgbjEgPSBuYS5jbG9uZSgpO1xyXG4gICAgICAgICAgICB2YXIgbjIgPSBuYS5jbG9uZSgpO1xyXG4gICAgICAgICAgICB2YXIgbjMgPSBuYi5jbG9uZSgpO1xyXG4gICAgICAgICAgICB2YXIgbjQgPSBuYi5jbG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHV2MSA9IHV2c1sgeSBdWyB4IF0uY2xvbmUoKTtcclxuICAgICAgICAgICAgdmFyIHV2MiA9IHV2c1sgeSArIDEgXVsgeCBdLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHZhciB1djMgPSB1dnNbIHkgKyAxIF1bIHggKyAxIF0uY2xvbmUoKTtcclxuICAgICAgICAgICAgdmFyIHV2NCA9IHV2c1sgeSBdWyB4ICsgMSBdLmNsb25lKCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2NCwgWyBuMSwgbjIsIG40IF0gKSApO1xyXG4gICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2MSwgdXYyLCB1djQgXSApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYyLCB2MywgdjQsIFsgbjIuY2xvbmUoKSwgbjMsIG40LmNsb25lKCkgXSApICk7XHJcbiAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYyLmNsb25lKCksIHV2MywgdXY0LmNsb25lKCkgXSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vIHRvcCBjYXBcclxuXHJcbiAgICBpZiAoIG9wZW5FbmRlZCA9PT0gZmFsc2UgJiYgcmFkaXVzVG9wID4gMCApIHtcclxuXHJcbiAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgaGVpZ2h0SGFsZiwgMCApICk7XHJcblxyXG4gICAgICAgIGZvciAoIHggPSAwOyB4IDwgcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgdjEgPSB2ZXJ0aWNlc1sgMCBdWyB4IF07XHJcbiAgICAgICAgICAgIHZhciB2MiA9IHZlcnRpY2VzWyAwIF1bIHggKyAxIF07XHJcbiAgICAgICAgICAgIHZhciB2MyA9IHRoaXMudmVydGljZXMubGVuZ3RoIC0gMTtcclxuXHJcbiAgICAgICAgICAgIHZhciBuMSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XHJcbiAgICAgICAgICAgIHZhciBuMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XHJcbiAgICAgICAgICAgIHZhciBuMyA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdXYxID0gdXZzWyAwIF1bIHggXS5jbG9uZSgpO1xyXG4gICAgICAgICAgICB2YXIgdXYyID0gdXZzWyAwIF1bIHggKyAxIF0uY2xvbmUoKTtcclxuICAgICAgICAgICAgdmFyIHV2MyA9IG5ldyBUSFJFRS5WZWN0b3IyKCB1djIueCwgMCApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MiwgdjMsIFsgbjEsIG4yLCBuMyBdLCB1bmRlZmluZWQsIDEgKSApO1xyXG4gICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2MSwgdXYyLCB1djMgXSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vIGJvdHRvbSBjYXBcclxuXHJcbiAgICBpZiAoIG9wZW5FbmRlZCA9PT0gZmFsc2UgJiYgcmFkaXVzQm90dG9tID4gMCApIHtcclxuXHJcbiAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLSBoZWlnaHRIYWxmLCAwICkgKTtcclxuXHJcbiAgICAgICAgZm9yICggeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgeCArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciB2MSA9IHZlcnRpY2VzWyBoZWlnaHRTZWdtZW50cyBdWyB4ICsgMSBdO1xyXG4gICAgICAgICAgICB2YXIgdjIgPSB2ZXJ0aWNlc1sgaGVpZ2h0U2VnbWVudHMgXVsgeCBdO1xyXG4gICAgICAgICAgICB2YXIgdjMgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIDE7XHJcblxyXG4gICAgICAgICAgICB2YXIgbjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLSAxLCAwICk7XHJcbiAgICAgICAgICAgIHZhciBuMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtIDEsIDAgKTtcclxuICAgICAgICAgICAgdmFyIG4zID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0gMSwgMCApO1xyXG5cclxuICAgICAgICAgICAgdmFyIHV2MSA9IHV2c1sgaGVpZ2h0U2VnbWVudHMgXVsgeCArIDEgXS5jbG9uZSgpO1xyXG4gICAgICAgICAgICB2YXIgdXYyID0gdXZzWyBoZWlnaHRTZWdtZW50cyBdWyB4IF0uY2xvbmUoKTtcclxuICAgICAgICAgICAgdmFyIHV2MyA9IG5ldyBUSFJFRS5WZWN0b3IyKCB1djIueCwgMSApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MiwgdjMsIFsgbjEsIG4yLCBuMyBdLCB1bmRlZmluZWQsIDIgKSApO1xyXG4gICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2MSwgdXYyLCB1djMgXSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DeWxpbmRlckdlb21ldHJ5O1xyXG5cclxuVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5DeWxpbmRlckdlb21ldHJ5KFxyXG4gICAgICAgIHBhcmFtZXRlcnMucmFkaXVzVG9wLFxyXG4gICAgICAgIHBhcmFtZXRlcnMucmFkaXVzQm90dG9tLFxyXG4gICAgICAgIHBhcmFtZXRlcnMuaGVpZ2h0LFxyXG4gICAgICAgIHBhcmFtZXRlcnMucmFkaWFsU2VnbWVudHMsXHJcbiAgICAgICAgcGFyYW1ldGVycy5oZWlnaHRTZWdtZW50cyxcclxuICAgICAgICBwYXJhbWV0ZXJzLm9wZW5FbmRlZCxcclxuICAgICAgICBwYXJhbWV0ZXJzLnRoZXRhU3RhcnQsXHJcbiAgICAgICAgcGFyYW1ldGVycy50aGV0YUxlbmd0aFxyXG4gICAgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9FZGdlc0dlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqL1xyXG5cclxuVEhSRUUuRWRnZXNHZW9tZXRyeSA9IGZ1bmN0aW9uICggZ2VvbWV0cnksIHRocmVzaG9sZEFuZ2xlICkge1xyXG5cclxuICAgIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICB0aHJlc2hvbGRBbmdsZSA9ICggdGhyZXNob2xkQW5nbGUgIT09IHVuZGVmaW5lZCApID8gdGhyZXNob2xkQW5nbGUgOiAxO1xyXG5cclxuICAgIHZhciB0aHJlc2hvbGREb3QgPSBNYXRoLmNvcyggVEhSRUUuTWF0aC5kZWdUb1JhZCggdGhyZXNob2xkQW5nbGUgKSApO1xyXG5cclxuICAgIHZhciBlZGdlID0gWyAwLCAwIF0sIGhhc2ggPSB7fTtcclxuXHJcbiAgICBmdW5jdGlvbiBzb3J0RnVuY3Rpb24oIGEsIGIgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBhIC0gYjtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGtleXMgPSBbICdhJywgJ2InLCAnYycgXTtcclxuXHJcbiAgICB2YXIgZ2VvbWV0cnkyO1xyXG5cclxuICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcbiAgICAgICAgZ2VvbWV0cnkyID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcbiAgICAgICAgZ2VvbWV0cnkyLmZyb21CdWZmZXJHZW9tZXRyeSggZ2VvbWV0cnkgKTtcclxuXHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICBnZW9tZXRyeTIgPSBnZW9tZXRyeS5jbG9uZSgpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBnZW9tZXRyeTIubWVyZ2VWZXJ0aWNlcygpO1xyXG4gICAgZ2VvbWV0cnkyLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cclxuICAgIHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5Mi52ZXJ0aWNlcztcclxuICAgIHZhciBmYWNlcyA9IGdlb21ldHJ5Mi5mYWNlcztcclxuXHJcbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICB2YXIgZmFjZSA9IGZhY2VzWyBpIF07XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IDM7IGogKysgKSB7XHJcblxyXG4gICAgICAgICAgICBlZGdlWyAwIF0gPSBmYWNlWyBrZXlzWyBqIF0gXTtcclxuICAgICAgICAgICAgZWRnZVsgMSBdID0gZmFjZVsga2V5c1sgKCBqICsgMSApICUgMyBdIF07XHJcbiAgICAgICAgICAgIGVkZ2Uuc29ydCggc29ydEZ1bmN0aW9uICk7XHJcblxyXG4gICAgICAgICAgICB2YXIga2V5ID0gZWRnZS50b1N0cmluZygpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBoYXNoWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGhhc2hbIGtleSBdID0geyB2ZXJ0MTogZWRnZVsgMCBdLCB2ZXJ0MjogZWRnZVsgMSBdLCBmYWNlMTogaSwgZmFjZTI6IHVuZGVmaW5lZCB9O1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICBoYXNoWyBrZXkgXS5mYWNlMiA9IGk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNvb3JkcyA9IFtdO1xyXG5cclxuICAgIGZvciAoIHZhciBrZXkgaW4gaGFzaCApIHtcclxuXHJcbiAgICAgICAgdmFyIGggPSBoYXNoWyBrZXkgXTtcclxuXHJcbiAgICAgICAgaWYgKCBoLmZhY2UyID09PSB1bmRlZmluZWQgfHwgZmFjZXNbIGguZmFjZTEgXS5ub3JtYWwuZG90KCBmYWNlc1sgaC5mYWNlMiBdLm5vcm1hbCApIDw9IHRocmVzaG9sZERvdCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlc1sgaC52ZXJ0MSBdO1xyXG4gICAgICAgICAgICBjb29yZHMucHVzaCggdmVydGV4LnggKTtcclxuICAgICAgICAgICAgY29vcmRzLnB1c2goIHZlcnRleC55ICk7XHJcbiAgICAgICAgICAgIGNvb3Jkcy5wdXNoKCB2ZXJ0ZXgueiApO1xyXG5cclxuICAgICAgICAgICAgdmVydGV4ID0gdmVydGljZXNbIGgudmVydDIgXTtcclxuICAgICAgICAgICAgY29vcmRzLnB1c2goIHZlcnRleC54ICk7XHJcbiAgICAgICAgICAgIGNvb3Jkcy5wdXNoKCB2ZXJ0ZXgueSApO1xyXG4gICAgICAgICAgICBjb29yZHMucHVzaCggdmVydGV4LnogKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggY29vcmRzICksIDMgKSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkVkZ2VzR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLkVkZ2VzR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRWRnZXNHZW9tZXRyeTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0V4dHJ1ZGVHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICpcclxuICogQ3JlYXRlcyBleHRydWRlZCBnZW9tZXRyeSBmcm9tIGEgcGF0aCBzaGFwZS5cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICpcclxuICogIGN1cnZlU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZXNcclxuICogIHN0ZXBzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBmb3Igei1zaWRlIGV4dHJ1c2lvbnMgLyB1c2VkIGZvciBzdWJkaXZpZGluZyBzZWdtZW50cyBvZiBleHRydWRlIHNwbGluZSB0b29cclxuICogIGFtb3VudDogPGludD4sIC8vIERlcHRoIHRvIGV4dHJ1ZGUgdGhlIHNoYXBlXHJcbiAqXHJcbiAqICBiZXZlbEVuYWJsZWQ6IDxib29sPiwgLy8gdHVybiBvbiBiZXZlbFxyXG4gKiAgYmV2ZWxUaGlja25lc3M6IDxmbG9hdD4sIC8vIGhvdyBkZWVwIGludG8gdGhlIG9yaWdpbmFsIHNoYXBlIGJldmVsIGdvZXNcclxuICogIGJldmVsU2l6ZTogPGZsb2F0PiwgLy8gaG93IGZhciBmcm9tIHNoYXBlIG91dGxpbmUgaXMgYmV2ZWxcclxuICogIGJldmVsU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgYmV2ZWwgbGF5ZXJzXHJcbiAqXHJcbiAqICBleHRydWRlUGF0aDogPFRIUkVFLkN1cnZlUGF0aD4gLy8gM2Qgc3BsaW5lIHBhdGggdG8gZXh0cnVkZSBzaGFwZSBhbG9uZy4gKGNyZWF0ZXMgRnJhbWVzIGlmIC5mcmFtZXMgYXJlbid0IGRlZmluZWQpXHJcbiAqICBmcmFtZXM6IDxUSFJFRS5UdWJlR2VvbWV0cnkuRnJlbmV0RnJhbWVzPiAvLyBjb250YWluaW5nIGFycmF5cyBvZiB0YW5nZW50cywgbm9ybWFscywgYmlub3JtYWxzXHJcbiAqXHJcbiAqICB1dkdlbmVyYXRvcjogPE9iamVjdD4gLy8gb2JqZWN0IHRoYXQgcHJvdmlkZXMgVVYgZ2VuZXJhdG9yIGZ1bmN0aW9uc1xyXG4gKlxyXG4gKiB9XHJcbiAqKi9cclxuXHJcblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeSA9IGZ1bmN0aW9uICggc2hhcGVzLCBvcHRpb25zICkge1xyXG5cclxuICAgIGlmICggdHlwZW9mKCBzaGFwZXMgKSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcclxuXHJcbiAgICAgICAgc2hhcGVzID0gW107XHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ0V4dHJ1ZGVHZW9tZXRyeSc7XHJcblxyXG4gICAgc2hhcGVzID0gQXJyYXkuaXNBcnJheSggc2hhcGVzICkgPyBzaGFwZXMgOiBbIHNoYXBlcyBdO1xyXG5cclxuICAgIHRoaXMuYWRkU2hhcGVMaXN0KCBzaGFwZXMsIG9wdGlvbnMgKTtcclxuXHJcbiAgICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cclxuICAgIC8vIGNhbid0IHJlYWxseSB1c2UgYXV0b21hdGljIHZlcnRleCBub3JtYWxzXHJcbiAgICAvLyBhcyB0aGVuIGZyb250IGFuZCBiYWNrIHNpZGVzIGdldCBzbW9vdGhlZCB0b29cclxuICAgIC8vIHNob3VsZCBkbyBzZXBhcmF0ZSBzbW9vdGhpbmcganVzdCBmb3Igc2lkZXNcclxuXHJcbiAgICAvL3RoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcclxuXHJcbiAgICAvL2NvbnNvbGUubG9nKCBcInRvb2tcIiwgKCBEYXRlLm5vdygpIC0gc3RhcnRUaW1lICkgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5FeHRydWRlR2VvbWV0cnk7XHJcblxyXG5USFJFRS5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlTGlzdCA9IGZ1bmN0aW9uICggc2hhcGVzLCBvcHRpb25zICkge1xyXG5cclxuICAgIHZhciBzbCA9IHNoYXBlcy5sZW5ndGg7XHJcblxyXG4gICAgZm9yICggdmFyIHMgPSAwOyBzIDwgc2w7IHMgKysgKSB7XHJcblxyXG4gICAgICAgIHZhciBzaGFwZSA9IHNoYXBlc1sgcyBdO1xyXG4gICAgICAgIHRoaXMuYWRkU2hhcGUoIHNoYXBlLCBvcHRpb25zICk7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGUgPSBmdW5jdGlvbiAoIHNoYXBlLCBvcHRpb25zICkge1xyXG5cclxuICAgIHZhciBhbW91bnQgPSBvcHRpb25zLmFtb3VudCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbW91bnQgOiAxMDA7XHJcblxyXG4gICAgdmFyIGJldmVsVGhpY2tuZXNzID0gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyA6IDY7IC8vIDEwXHJcbiAgICB2YXIgYmV2ZWxTaXplID0gb3B0aW9ucy5iZXZlbFNpemUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxTaXplIDogYmV2ZWxUaGlja25lc3MgLSAyOyAvLyA4XHJcbiAgICB2YXIgYmV2ZWxTZWdtZW50cyA9IG9wdGlvbnMuYmV2ZWxTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFNlZ21lbnRzIDogMztcclxuXHJcbiAgICB2YXIgYmV2ZWxFbmFibGVkID0gb3B0aW9ucy5iZXZlbEVuYWJsZWQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxFbmFibGVkIDogdHJ1ZTsgLy8gZmFsc2VcclxuXHJcbiAgICB2YXIgY3VydmVTZWdtZW50cyA9IG9wdGlvbnMuY3VydmVTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzIDogMTI7XHJcblxyXG4gICAgdmFyIHN0ZXBzID0gb3B0aW9ucy5zdGVwcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdGVwcyA6IDE7XHJcblxyXG4gICAgdmFyIGV4dHJ1ZGVQYXRoID0gb3B0aW9ucy5leHRydWRlUGF0aDtcclxuICAgIHZhciBleHRydWRlUHRzLCBleHRydWRlQnlQYXRoID0gZmFsc2U7XHJcblxyXG4gICAgLy8gVXNlIGRlZmF1bHQgV29ybGRVVkdlbmVyYXRvciBpZiBubyBVViBnZW5lcmF0b3JzIGFyZSBzcGVjaWZpZWQuXHJcbiAgICB2YXIgdXZnZW4gPSBvcHRpb25zLlVWR2VuZXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLlVWR2VuZXJhdG9yIDogVEhSRUUuRXh0cnVkZUdlb21ldHJ5LldvcmxkVVZHZW5lcmF0b3I7XHJcblxyXG4gICAgdmFyIHNwbGluZVR1YmUsIGJpbm9ybWFsLCBub3JtYWwsIHBvc2l0aW9uMjtcclxuICAgIGlmICggZXh0cnVkZVBhdGggKSB7XHJcblxyXG4gICAgICAgIGV4dHJ1ZGVQdHMgPSBleHRydWRlUGF0aC5nZXRTcGFjZWRQb2ludHMoIHN0ZXBzICk7XHJcblxyXG4gICAgICAgIGV4dHJ1ZGVCeVBhdGggPSB0cnVlO1xyXG4gICAgICAgIGJldmVsRW5hYmxlZCA9IGZhbHNlOyAvLyBiZXZlbHMgbm90IHN1cHBvcnRlZCBmb3IgcGF0aCBleHRydXNpb25cclxuXHJcbiAgICAgICAgLy8gU0VUVVAgVE5CIHZhcmlhYmxlc1xyXG5cclxuICAgICAgICAvLyBSZXVzZSBUTkIgZnJvbSBUdWJlR2VvbXRyeSBmb3Igbm93LlxyXG4gICAgICAgIC8vIFRPRE8xIC0gaGF2ZSBhIC5pc0Nsb3NlZCBpbiBzcGxpbmU/XHJcblxyXG4gICAgICAgIHNwbGluZVR1YmUgPSBvcHRpb25zLmZyYW1lcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5mcmFtZXMgOiBuZXcgVEhSRUUuVHViZUdlb21ldHJ5LkZyZW5ldEZyYW1lcyggZXh0cnVkZVBhdGgsIHN0ZXBzLCBmYWxzZSApO1xyXG5cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhzcGxpbmVUdWJlLCAnc3BsaW5lVHViZScsIHNwbGluZVR1YmUubm9ybWFscy5sZW5ndGgsICdzdGVwcycsIHN0ZXBzLCAnZXh0cnVkZVB0cycsIGV4dHJ1ZGVQdHMubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgYmlub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgIG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgcG9zaXRpb24yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2FmZWd1YXJkcyBpZiBiZXZlbHMgYXJlIG5vdCBlbmFibGVkXHJcblxyXG4gICAgaWYgKCAhIGJldmVsRW5hYmxlZCApIHtcclxuXHJcbiAgICAgICAgYmV2ZWxTZWdtZW50cyA9IDA7XHJcbiAgICAgICAgYmV2ZWxUaGlja25lc3MgPSAwO1xyXG4gICAgICAgIGJldmVsU2l6ZSA9IDA7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vIFZhcmlhYmxlcyBpbml0aWFsaXphdGlvblxyXG5cclxuICAgIHZhciBhaG9sZSwgaCwgaGw7IC8vIGxvb3Bpbmcgb2YgaG9sZXNcclxuICAgIHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG4gICAgdmFyIHNoYXBlc09mZnNldCA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xyXG5cclxuICAgIHZhciBzaGFwZVBvaW50cyA9IHNoYXBlLmV4dHJhY3RQb2ludHMoIGN1cnZlU2VnbWVudHMgKTtcclxuXHJcbiAgICB2YXIgdmVydGljZXMgPSBzaGFwZVBvaW50cy5zaGFwZTtcclxuICAgIHZhciBob2xlcyA9IHNoYXBlUG9pbnRzLmhvbGVzO1xyXG5cclxuICAgIHZhciByZXZlcnNlID0gISBUSFJFRS5TaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKCB2ZXJ0aWNlcyApO1xyXG5cclxuICAgIGlmICggcmV2ZXJzZSApIHtcclxuXHJcbiAgICAgICAgdmVydGljZXMgPSB2ZXJ0aWNlcy5yZXZlcnNlKCk7XHJcblxyXG4gICAgICAgIC8vIE1heWJlIHdlIHNob3VsZCBhbHNvIGNoZWNrIGlmIGhvbGVzIGFyZSBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLCBqdXN0IHRvIGJlIHNhZmUgLi4uXHJcblxyXG4gICAgICAgIGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xyXG5cclxuICAgICAgICAgICAgYWhvbGUgPSBob2xlc1sgaCBdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBUSFJFRS5TaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKCBhaG9sZSApICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGhvbGVzWyBoIF0gPSBhaG9sZS5yZXZlcnNlKCk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV2ZXJzZSA9IGZhbHNlOyAvLyBJZiB2ZXJ0aWNlcyBhcmUgaW4gb3JkZXIgbm93LCB3ZSBzaG91bGRuJ3QgbmVlZCB0byB3b3JyeSBhYm91dCB0aGVtIGFnYWluIChob3BlZnVsbHkpIVxyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgdmFyIGZhY2VzID0gVEhSRUUuU2hhcGVVdGlscy50cmlhbmd1bGF0ZVNoYXBlKCB2ZXJ0aWNlcywgaG9sZXMgKTtcclxuXHJcbiAgICAvKiBWZXJ0aWNlcyAqL1xyXG5cclxuICAgIHZhciBjb250b3VyID0gdmVydGljZXM7IC8vIHZlcnRpY2VzIGhhcyBhbGwgcG9pbnRzIGJ1dCBjb250b3VyIGhhcyBvbmx5IHBvaW50cyBvZiBjaXJjdW1mZXJlbmNlXHJcblxyXG4gICAgZm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XHJcblxyXG4gICAgICAgIGFob2xlID0gaG9sZXNbIGggXTtcclxuXHJcbiAgICAgICAgdmVydGljZXMgPSB2ZXJ0aWNlcy5jb25jYXQoIGFob2xlICk7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBzY2FsZVB0MiAoIHB0LCB2ZWMsIHNpemUgKSB7XHJcblxyXG4gICAgICAgIGlmICggISB2ZWMgKSBjb25zb2xlLmVycm9yKCBcIlRIUkVFLkV4dHJ1ZGVHZW9tZXRyeTogdmVjIGRvZXMgbm90IGV4aXN0XCIgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHZlYy5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKCBzaXplICkuYWRkKCBwdCApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB2YXIgYiwgYnMsIHQsIHosXHJcbiAgICAgICAgdmVydCwgdmxlbiA9IHZlcnRpY2VzLmxlbmd0aCxcclxuICAgICAgICBmYWNlLCBmbGVuID0gZmFjZXMubGVuZ3RoO1xyXG5cclxuXHJcbiAgICAvLyBGaW5kIGRpcmVjdGlvbnMgZm9yIHBvaW50IG1vdmVtZW50XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGdldEJldmVsVmVjKCBpblB0LCBpblByZXYsIGluTmV4dCApIHtcclxuXHJcbiAgICAgICAgLy8gY29tcHV0ZXMgZm9yIGluUHQgdGhlIGNvcnJlc3BvbmRpbmcgcG9pbnQgaW5QdCcgb24gYSBuZXcgY29udG91clxyXG4gICAgICAgIC8vICAgc2hpZnRlZCBieSAxIHVuaXQgKGxlbmd0aCBvZiBub3JtYWxpemVkIHZlY3RvcikgdG8gdGhlIGxlZnRcclxuICAgICAgICAvLyBpZiB3ZSB3YWxrIGFsb25nIGNvbnRvdXIgY2xvY2t3aXNlLCB0aGlzIG5ldyBjb250b3VyIGlzIG91dHNpZGUgdGhlIG9sZCBvbmVcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIGluUHQnIGlzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byBsaW5lcyBwYXJhbGxlbCB0byB0aGUgdHdvXHJcbiAgICAgICAgLy8gIGFkamFjZW50IGVkZ2VzIG9mIGluUHQgYXQgYSBkaXN0YW5jZSBvZiAxIHVuaXQgb24gdGhlIGxlZnQgc2lkZS5cclxuXHJcbiAgICAgICAgdmFyIHZfdHJhbnNfeCwgdl90cmFuc195LCBzaHJpbmtfYnkgPSAxO1x0XHQvLyByZXN1bHRpbmcgdHJhbnNsYXRpb24gdmVjdG9yIGZvciBpblB0XHJcblxyXG4gICAgICAgIC8vIGdvb2QgcmVhZGluZyBmb3IgZ2VvbWV0cnkgYWxnb3JpdGhtcyAoaGVyZTogbGluZS1saW5lIGludGVyc2VjdGlvbilcclxuICAgICAgICAvLyBodHRwOi8vZ2VvbWFsZ29yaXRobXMuY29tL2EwNS1faW50ZXJzZWN0LTEuaHRtbFxyXG5cclxuICAgICAgICB2YXIgdl9wcmV2X3ggPSBpblB0LnggLSBpblByZXYueCwgdl9wcmV2X3kgPSBpblB0LnkgLSBpblByZXYueTtcclxuICAgICAgICB2YXIgdl9uZXh0X3ggPSBpbk5leHQueCAtIGluUHQueCwgdl9uZXh0X3kgPSBpbk5leHQueSAtIGluUHQueTtcclxuXHJcbiAgICAgICAgdmFyIHZfcHJldl9sZW5zcSA9ICggdl9wcmV2X3ggKiB2X3ByZXZfeCArIHZfcHJldl95ICogdl9wcmV2X3kgKTtcclxuXHJcbiAgICAgICAgLy8gY2hlY2sgZm9yIGNvbGxpbmVhciBlZGdlc1xyXG4gICAgICAgIHZhciBjb2xsaW5lYXIwID0gKCB2X3ByZXZfeCAqIHZfbmV4dF95IC0gdl9wcmV2X3kgKiB2X25leHRfeCApO1xyXG5cclxuICAgICAgICBpZiAoIE1hdGguYWJzKCBjb2xsaW5lYXIwICkgPiBOdW1iZXIuRVBTSUxPTiApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIG5vdCBjb2xsaW5lYXJcclxuXHJcbiAgICAgICAgICAgIC8vIGxlbmd0aCBvZiB2ZWN0b3JzIGZvciBub3JtYWxpemluZ1xyXG5cclxuICAgICAgICAgICAgdmFyIHZfcHJldl9sZW4gPSBNYXRoLnNxcnQoIHZfcHJldl9sZW5zcSApO1xyXG4gICAgICAgICAgICB2YXIgdl9uZXh0X2xlbiA9IE1hdGguc3FydCggdl9uZXh0X3ggKiB2X25leHRfeCArIHZfbmV4dF95ICogdl9uZXh0X3kgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHNoaWZ0IGFkamFjZW50IHBvaW50cyBieSB1bml0IHZlY3RvcnMgdG8gdGhlIGxlZnRcclxuXHJcbiAgICAgICAgICAgIHZhciBwdFByZXZTaGlmdF94ID0gKCBpblByZXYueCAtIHZfcHJldl95IC8gdl9wcmV2X2xlbiApO1xyXG4gICAgICAgICAgICB2YXIgcHRQcmV2U2hpZnRfeSA9ICggaW5QcmV2LnkgKyB2X3ByZXZfeCAvIHZfcHJldl9sZW4gKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBwdE5leHRTaGlmdF94ID0gKCBpbk5leHQueCAtIHZfbmV4dF95IC8gdl9uZXh0X2xlbiApO1xyXG4gICAgICAgICAgICB2YXIgcHROZXh0U2hpZnRfeSA9ICggaW5OZXh0LnkgKyB2X25leHRfeCAvIHZfbmV4dF9sZW4gKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHNjYWxpbmcgZmFjdG9yIGZvciB2X3ByZXYgdG8gaW50ZXJzZWN0aW9uIHBvaW50XHJcblxyXG4gICAgICAgICAgICB2YXIgc2YgPSAoICAoIHB0TmV4dFNoaWZ0X3ggLSBwdFByZXZTaGlmdF94ICkgKiB2X25leHRfeSAtXHJcbiAgICAgICAgICAgICAgICAoIHB0TmV4dFNoaWZ0X3kgLSBwdFByZXZTaGlmdF95ICkgKiB2X25leHRfeCAgICApIC9cclxuICAgICAgICAgICAgICAgICggdl9wcmV2X3ggKiB2X25leHRfeSAtIHZfcHJldl95ICogdl9uZXh0X3ggKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHZlY3RvciBmcm9tIGluUHQgdG8gaW50ZXJzZWN0aW9uIHBvaW50XHJcblxyXG4gICAgICAgICAgICB2X3RyYW5zX3ggPSAoIHB0UHJldlNoaWZ0X3ggKyB2X3ByZXZfeCAqIHNmIC0gaW5QdC54ICk7XHJcbiAgICAgICAgICAgIHZfdHJhbnNfeSA9ICggcHRQcmV2U2hpZnRfeSArIHZfcHJldl95ICogc2YgLSBpblB0LnkgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIERvbid0IG5vcm1hbGl6ZSEsIG90aGVyd2lzZSBzaGFycCBjb3JuZXJzIGJlY29tZSB1Z2x5XHJcbiAgICAgICAgICAgIC8vICBidXQgcHJldmVudCBjcmF6eSBzcGlrZXNcclxuICAgICAgICAgICAgdmFyIHZfdHJhbnNfbGVuc3EgPSAoIHZfdHJhbnNfeCAqIHZfdHJhbnNfeCArIHZfdHJhbnNfeSAqIHZfdHJhbnNfeSApO1xyXG4gICAgICAgICAgICBpZiAoIHZfdHJhbnNfbGVuc3EgPD0gMiApIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm5cdG5ldyBUSFJFRS5WZWN0b3IyKCB2X3RyYW5zX3gsIHZfdHJhbnNfeSApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICBzaHJpbmtfYnkgPSBNYXRoLnNxcnQoIHZfdHJhbnNfbGVuc3EgLyAyICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAvLyBoYW5kbGUgc3BlY2lhbCBjYXNlIG9mIGNvbGxpbmVhciBlZGdlc1xyXG5cclxuICAgICAgICAgICAgdmFyIGRpcmVjdGlvbl9lcSA9IGZhbHNlO1x0XHQvLyBhc3N1bWVzOiBvcHBvc2l0ZVxyXG4gICAgICAgICAgICBpZiAoIHZfcHJldl94ID4gTnVtYmVyLkVQU0lMT04gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCB2X25leHRfeCA+IE51bWJlci5FUFNJTE9OICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb25fZXEgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCB2X3ByZXZfeCA8IC0gTnVtYmVyLkVQU0lMT04gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggdl9uZXh0X3ggPCAtIE51bWJlci5FUFNJTE9OICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uX2VxID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggTWF0aC5zaWduKCB2X3ByZXZfeSApID09PSBNYXRoLnNpZ24oIHZfbmV4dF95ICkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb25fZXEgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBkaXJlY3Rpb25fZXEgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJXYXJuaW5nOiBsaW5lcyBhcmUgYSBzdHJhaWdodCBzZXF1ZW5jZVwiKTtcclxuICAgICAgICAgICAgICAgIHZfdHJhbnNfeCA9IC0gdl9wcmV2X3k7XHJcbiAgICAgICAgICAgICAgICB2X3RyYW5zX3kgPSAgdl9wcmV2X3g7XHJcbiAgICAgICAgICAgICAgICBzaHJpbmtfYnkgPSBNYXRoLnNxcnQoIHZfcHJldl9sZW5zcSApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIldhcm5pbmc6IGxpbmVzIGFyZSBhIHN0cmFpZ2h0IHNwaWtlXCIpO1xyXG4gICAgICAgICAgICAgICAgdl90cmFuc194ID0gdl9wcmV2X3g7XHJcbiAgICAgICAgICAgICAgICB2X3RyYW5zX3kgPSB2X3ByZXZfeTtcclxuICAgICAgICAgICAgICAgIHNocmlua19ieSA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxIC8gMiApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVyblx0bmV3IFRIUkVFLlZlY3RvcjIoIHZfdHJhbnNfeCAvIHNocmlua19ieSwgdl90cmFuc195IC8gc2hyaW5rX2J5ICk7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICB2YXIgY29udG91ck1vdmVtZW50cyA9IFtdO1xyXG5cclxuICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBjb250b3VyLmxlbmd0aCwgaiA9IGlsIC0gMSwgayA9IGkgKyAxOyBpIDwgaWw7IGkgKyssIGogKyssIGsgKysgKSB7XHJcblxyXG4gICAgICAgIGlmICggaiA9PT0gaWwgKSBqID0gMDtcclxuICAgICAgICBpZiAoIGsgPT09IGlsICkgayA9IDA7XHJcblxyXG4gICAgICAgIC8vICAoaiktLS0oaSktLS0oaylcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnaSxqLGsnLCBpLCBqICwgaylcclxuXHJcbiAgICAgICAgY29udG91ck1vdmVtZW50c1sgaSBdID0gZ2V0QmV2ZWxWZWMoIGNvbnRvdXJbIGkgXSwgY29udG91clsgaiBdLCBjb250b3VyWyBrIF0gKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGhvbGVzTW92ZW1lbnRzID0gW10sIG9uZUhvbGVNb3ZlbWVudHMsIHZlcnRpY2VzTW92ZW1lbnRzID0gY29udG91ck1vdmVtZW50cy5jb25jYXQoKTtcclxuXHJcbiAgICBmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcclxuXHJcbiAgICAgICAgYWhvbGUgPSBob2xlc1sgaCBdO1xyXG5cclxuICAgICAgICBvbmVIb2xlTW92ZW1lbnRzID0gW107XHJcblxyXG4gICAgICAgIGZvciAoIGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aCwgaiA9IGlsIC0gMSwgayA9IGkgKyAxOyBpIDwgaWw7IGkgKyssIGogKyssIGsgKysgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGogPT09IGlsICkgaiA9IDA7XHJcbiAgICAgICAgICAgIGlmICggayA9PT0gaWwgKSBrID0gMDtcclxuXHJcbiAgICAgICAgICAgIC8vICAoaiktLS0oaSktLS0oaylcclxuICAgICAgICAgICAgb25lSG9sZU1vdmVtZW50c1sgaSBdID0gZ2V0QmV2ZWxWZWMoIGFob2xlWyBpIF0sIGFob2xlWyBqIF0sIGFob2xlWyBrIF0gKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBob2xlc01vdmVtZW50cy5wdXNoKCBvbmVIb2xlTW92ZW1lbnRzICk7XHJcbiAgICAgICAgdmVydGljZXNNb3ZlbWVudHMgPSB2ZXJ0aWNlc01vdmVtZW50cy5jb25jYXQoIG9uZUhvbGVNb3ZlbWVudHMgKTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIExvb3AgYmV2ZWxTZWdtZW50cywgMSBmb3IgdGhlIGZyb250LCAxIGZvciB0aGUgYmFja1xyXG5cclxuICAgIGZvciAoIGIgPSAwOyBiIDwgYmV2ZWxTZWdtZW50czsgYiArKyApIHtcclxuXHJcbiAgICAgICAgLy9mb3IgKCBiID0gYmV2ZWxTZWdtZW50czsgYiA+IDA7IGIgLS0gKSB7XHJcblxyXG4gICAgICAgIHQgPSBiIC8gYmV2ZWxTZWdtZW50cztcclxuICAgICAgICB6ID0gYmV2ZWxUaGlja25lc3MgKiAoIDEgLSB0ICk7XHJcblxyXG4gICAgICAgIC8veiA9IGJldmVsVGhpY2tuZXNzICogdDtcclxuICAgICAgICBicyA9IGJldmVsU2l6ZSAqICggTWF0aC5zaW4gKCB0ICogTWF0aC5QSSAvIDIgKSApOyAvLyBjdXJ2ZWRcclxuICAgICAgICAvL2JzID0gYmV2ZWxTaXplICogdDsgLy8gbGluZWFyXHJcblxyXG4gICAgICAgIC8vIGNvbnRyYWN0IHNoYXBlXHJcblxyXG4gICAgICAgIGZvciAoIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2ZXJ0ID0gc2NhbGVQdDIoIGNvbnRvdXJbIGkgXSwgY29udG91ck1vdmVtZW50c1sgaSBdLCBicyApO1xyXG5cclxuICAgICAgICAgICAgdiggdmVydC54LCB2ZXJ0LnksICAtIHogKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBleHBhbmQgaG9sZXNcclxuXHJcbiAgICAgICAgZm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XHJcblxyXG4gICAgICAgICAgICBhaG9sZSA9IGhvbGVzWyBoIF07XHJcbiAgICAgICAgICAgIG9uZUhvbGVNb3ZlbWVudHMgPSBob2xlc01vdmVtZW50c1sgaCBdO1xyXG5cclxuICAgICAgICAgICAgZm9yICggaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmVydCA9IHNjYWxlUHQyKCBhaG9sZVsgaSBdLCBvbmVIb2xlTW92ZW1lbnRzWyBpIF0sIGJzICk7XHJcblxyXG4gICAgICAgICAgICAgICAgdiggdmVydC54LCB2ZXJ0LnksICAtIHogKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBicyA9IGJldmVsU2l6ZTtcclxuXHJcbiAgICAvLyBCYWNrIGZhY2luZyB2ZXJ0aWNlc1xyXG5cclxuICAgIGZvciAoIGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcclxuXHJcbiAgICAgICAgdmVydCA9IGJldmVsRW5hYmxlZCA/IHNjYWxlUHQyKCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc01vdmVtZW50c1sgaSBdLCBicyApIDogdmVydGljZXNbIGkgXTtcclxuXHJcbiAgICAgICAgaWYgKCAhIGV4dHJ1ZGVCeVBhdGggKSB7XHJcblxyXG4gICAgICAgICAgICB2KCB2ZXJ0LngsIHZlcnQueSwgMCApO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgLy8gdiggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyAwIF0ueSwgZXh0cnVkZVB0c1sgMCBdLnggKTtcclxuXHJcbiAgICAgICAgICAgIG5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLm5vcm1hbHNbIDAgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnggKTtcclxuICAgICAgICAgICAgYmlub3JtYWwuY29weSggc3BsaW5lVHViZS5iaW5vcm1hbHNbIDAgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnkgKTtcclxuXHJcbiAgICAgICAgICAgIHBvc2l0aW9uMi5jb3B5KCBleHRydWRlUHRzWyAwIF0gKS5hZGQoIG5vcm1hbCApLmFkZCggYmlub3JtYWwgKTtcclxuXHJcbiAgICAgICAgICAgIHYoIHBvc2l0aW9uMi54LCBwb3NpdGlvbjIueSwgcG9zaXRpb24yLnogKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgc3RlcHBlZCB2ZXJ0aWNlcy4uLlxyXG4gICAgLy8gSW5jbHVkaW5nIGZyb250IGZhY2luZyB2ZXJ0aWNlc1xyXG5cclxuICAgIHZhciBzO1xyXG5cclxuICAgIGZvciAoIHMgPSAxOyBzIDw9IHN0ZXBzOyBzICsrICkge1xyXG5cclxuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IHZsZW47IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2ZXJ0ID0gYmV2ZWxFbmFibGVkID8gc2NhbGVQdDIoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzTW92ZW1lbnRzWyBpIF0sIGJzICkgOiB2ZXJ0aWNlc1sgaSBdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCAhIGV4dHJ1ZGVCeVBhdGggKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdiggdmVydC54LCB2ZXJ0LnksIGFtb3VudCAvIHN0ZXBzICogcyApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIHMgLSAxIF0ueSwgZXh0cnVkZVB0c1sgcyAtIDEgXS54ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgbm9ybWFsLmNvcHkoIHNwbGluZVR1YmUubm9ybWFsc1sgcyBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueCApO1xyXG4gICAgICAgICAgICAgICAgYmlub3JtYWwuY29weSggc3BsaW5lVHViZS5iaW5vcm1hbHNbIHMgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjIuY29weSggZXh0cnVkZVB0c1sgcyBdICkuYWRkKCBub3JtYWwgKS5hZGQoIGJpbm9ybWFsICk7XHJcblxyXG4gICAgICAgICAgICAgICAgdiggcG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueiApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBBZGQgYmV2ZWwgc2VnbWVudHMgcGxhbmVzXHJcblxyXG4gICAgLy9mb3IgKCBiID0gMTsgYiA8PSBiZXZlbFNlZ21lbnRzOyBiICsrICkge1xyXG4gICAgZm9yICggYiA9IGJldmVsU2VnbWVudHMgLSAxOyBiID49IDA7IGIgLS0gKSB7XHJcblxyXG4gICAgICAgIHQgPSBiIC8gYmV2ZWxTZWdtZW50cztcclxuICAgICAgICB6ID0gYmV2ZWxUaGlja25lc3MgKiAoIDEgLSB0ICk7XHJcbiAgICAgICAgLy9icyA9IGJldmVsU2l6ZSAqICggMS1NYXRoLnNpbiAoICggMSAtIHQgKSAqIE1hdGguUEkvMiApICk7XHJcbiAgICAgICAgYnMgPSBiZXZlbFNpemUgKiBNYXRoLnNpbiAoIHQgKiBNYXRoLlBJIC8gMiApO1xyXG5cclxuICAgICAgICAvLyBjb250cmFjdCBzaGFwZVxyXG5cclxuICAgICAgICBmb3IgKCBpID0gMCwgaWwgPSBjb250b3VyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmVydCA9IHNjYWxlUHQyKCBjb250b3VyWyBpIF0sIGNvbnRvdXJNb3ZlbWVudHNbIGkgXSwgYnMgKTtcclxuICAgICAgICAgICAgdiggdmVydC54LCB2ZXJ0LnksICBhbW91bnQgKyB6ICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gZXhwYW5kIGhvbGVzXHJcblxyXG4gICAgICAgIGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xyXG5cclxuICAgICAgICAgICAgYWhvbGUgPSBob2xlc1sgaCBdO1xyXG4gICAgICAgICAgICBvbmVIb2xlTW92ZW1lbnRzID0gaG9sZXNNb3ZlbWVudHNbIGggXTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZlcnQgPSBzY2FsZVB0MiggYWhvbGVbIGkgXSwgb25lSG9sZU1vdmVtZW50c1sgaSBdLCBicyApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggISBleHRydWRlQnlQYXRoICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2KCB2ZXJ0LngsIHZlcnQueSwgIGFtb3VudCArIHogKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIHN0ZXBzIC0gMSBdLnksIGV4dHJ1ZGVQdHNbIHN0ZXBzIC0gMSBdLnggKyB6ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qIEZhY2VzICovXHJcblxyXG4gICAgLy8gVG9wIGFuZCBib3R0b20gZmFjZXNcclxuXHJcbiAgICBidWlsZExpZEZhY2VzKCk7XHJcblxyXG4gICAgLy8gU2lkZXMgZmFjZXNcclxuXHJcbiAgICBidWlsZFNpZGVGYWNlcygpO1xyXG5cclxuXHJcbiAgICAvLy8vLyAgSW50ZXJuYWwgZnVuY3Rpb25zXHJcblxyXG4gICAgZnVuY3Rpb24gYnVpbGRMaWRGYWNlcygpIHtcclxuXHJcbiAgICAgICAgaWYgKCBiZXZlbEVuYWJsZWQgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSAwOyAvLyBzdGVwcyArIDFcclxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHZsZW4gKiBsYXllcjtcclxuXHJcbiAgICAgICAgICAgIC8vIEJvdHRvbSBmYWNlc1xyXG5cclxuICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGZhY2UgPSBmYWNlc1sgaSBdO1xyXG4gICAgICAgICAgICAgICAgZjMoIGZhY2VbIDIgXSArIG9mZnNldCwgZmFjZVsgMSBdICsgb2Zmc2V0LCBmYWNlWyAwIF0gKyBvZmZzZXQgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxheWVyID0gc3RlcHMgKyBiZXZlbFNlZ21lbnRzICogMjtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gdmxlbiAqIGxheWVyO1xyXG5cclxuICAgICAgICAgICAgLy8gVG9wIGZhY2VzXHJcblxyXG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZmFjZSA9IGZhY2VzWyBpIF07XHJcbiAgICAgICAgICAgICAgICBmMyggZmFjZVsgMCBdICsgb2Zmc2V0LCBmYWNlWyAxIF0gKyBvZmZzZXQsIGZhY2VbIDIgXSArIG9mZnNldCApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgLy8gQm90dG9tIGZhY2VzXHJcblxyXG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZmFjZSA9IGZhY2VzWyBpIF07XHJcbiAgICAgICAgICAgICAgICBmMyggZmFjZVsgMiBdLCBmYWNlWyAxIF0sIGZhY2VbIDAgXSApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVG9wIGZhY2VzXHJcblxyXG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZmFjZSA9IGZhY2VzWyBpIF07XHJcbiAgICAgICAgICAgICAgICBmMyggZmFjZVsgMCBdICsgdmxlbiAqIHN0ZXBzLCBmYWNlWyAxIF0gKyB2bGVuICogc3RlcHMsIGZhY2VbIDIgXSArIHZsZW4gKiBzdGVwcyApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vIENyZWF0ZSBmYWNlcyBmb3IgdGhlIHotc2lkZXMgb2YgdGhlIHNoYXBlXHJcblxyXG4gICAgZnVuY3Rpb24gYnVpbGRTaWRlRmFjZXMoKSB7XHJcblxyXG4gICAgICAgIHZhciBsYXllcm9mZnNldCA9IDA7XHJcbiAgICAgICAgc2lkZXdhbGxzKCBjb250b3VyLCBsYXllcm9mZnNldCApO1xyXG4gICAgICAgIGxheWVyb2Zmc2V0ICs9IGNvbnRvdXIubGVuZ3RoO1xyXG5cclxuICAgICAgICBmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcclxuXHJcbiAgICAgICAgICAgIGFob2xlID0gaG9sZXNbIGggXTtcclxuICAgICAgICAgICAgc2lkZXdhbGxzKCBhaG9sZSwgbGF5ZXJvZmZzZXQgKTtcclxuXHJcbiAgICAgICAgICAgIC8vLCB0cnVlXHJcbiAgICAgICAgICAgIGxheWVyb2Zmc2V0ICs9IGFob2xlLmxlbmd0aDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzaWRld2FsbHMoIGNvbnRvdXIsIGxheWVyb2Zmc2V0ICkge1xyXG5cclxuICAgICAgICB2YXIgaiwgaztcclxuICAgICAgICBpID0gY29udG91ci5sZW5ndGg7XHJcblxyXG4gICAgICAgIHdoaWxlICggLS0gaSA+PSAwICkge1xyXG5cclxuICAgICAgICAgICAgaiA9IGk7XHJcbiAgICAgICAgICAgIGsgPSBpIC0gMTtcclxuICAgICAgICAgICAgaWYgKCBrIDwgMCApIGsgPSBjb250b3VyLmxlbmd0aCAtIDE7XHJcblxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdiJywgaSxqLCBpLTEsIGssdmVydGljZXMubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBzID0gMCwgc2wgPSBzdGVwcyAgKyBiZXZlbFNlZ21lbnRzICogMjtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHMgPSAwOyBzIDwgc2w7IHMgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHNsZW4xID0gdmxlbiAqIHM7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2xlbjIgPSB2bGVuICogKCBzICsgMSApO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBhID0gbGF5ZXJvZmZzZXQgKyBqICsgc2xlbjEsXHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IGxheWVyb2Zmc2V0ICsgayArIHNsZW4xLFxyXG4gICAgICAgICAgICAgICAgICAgIGMgPSBsYXllcm9mZnNldCArIGsgKyBzbGVuMixcclxuICAgICAgICAgICAgICAgICAgICBkID0gbGF5ZXJvZmZzZXQgKyBqICsgc2xlbjI7XHJcblxyXG4gICAgICAgICAgICAgICAgZjQoIGEsIGIsIGMsIGQsIGNvbnRvdXIsIHMsIHNsLCBqLCBrICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIHYoIHgsIHksIHogKSB7XHJcblxyXG4gICAgICAgIHNjb3BlLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCB4LCB5LCB6ICkgKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZjMoIGEsIGIsIGMgKSB7XHJcblxyXG4gICAgICAgIGEgKz0gc2hhcGVzT2Zmc2V0O1xyXG4gICAgICAgIGIgKz0gc2hhcGVzT2Zmc2V0O1xyXG4gICAgICAgIGMgKz0gc2hhcGVzT2Zmc2V0O1xyXG5cclxuICAgICAgICBzY29wZS5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMsIG51bGwsIG51bGwsIDAgKSApO1xyXG5cclxuICAgICAgICB2YXIgdXZzID0gdXZnZW4uZ2VuZXJhdGVUb3BVViggc2NvcGUsIGEsIGIsIGMgKTtcclxuXHJcbiAgICAgICAgc2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIHV2cyApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBmNCggYSwgYiwgYywgZCwgd2FsbENvbnRvdXIsIHN0ZXBJbmRleCwgc3RlcHNMZW5ndGgsIGNvbnRvdXJJbmRleDEsIGNvbnRvdXJJbmRleDIgKSB7XHJcblxyXG4gICAgICAgIGEgKz0gc2hhcGVzT2Zmc2V0O1xyXG4gICAgICAgIGIgKz0gc2hhcGVzT2Zmc2V0O1xyXG4gICAgICAgIGMgKz0gc2hhcGVzT2Zmc2V0O1xyXG4gICAgICAgIGQgKz0gc2hhcGVzT2Zmc2V0O1xyXG5cclxuICAgICAgICBzY29wZS5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGQsIG51bGwsIG51bGwsIDEgKSApO1xyXG4gICAgICAgIHNjb3BlLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYiwgYywgZCwgbnVsbCwgbnVsbCwgMSApICk7XHJcblxyXG4gICAgICAgIHZhciB1dnMgPSB1dmdlbi5nZW5lcmF0ZVNpZGVXYWxsVVYoIHNjb3BlLCBhLCBiLCBjLCBkICk7XHJcblxyXG4gICAgICAgIHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2c1sgMCBdLCB1dnNbIDEgXSwgdXZzWyAzIF0gXSApO1xyXG4gICAgICAgIHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2c1sgMSBdLCB1dnNbIDIgXSwgdXZzWyAzIF0gXSApO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5FeHRydWRlR2VvbWV0cnkuV29ybGRVVkdlbmVyYXRvciA9IHtcclxuXHJcbiAgICBnZW5lcmF0ZVRvcFVWOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBpbmRleEEsIGluZGV4QiwgaW5kZXhDICkge1xyXG5cclxuICAgICAgICB2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcclxuXHJcbiAgICAgICAgdmFyIGEgPSB2ZXJ0aWNlc1sgaW5kZXhBIF07XHJcbiAgICAgICAgdmFyIGIgPSB2ZXJ0aWNlc1sgaW5kZXhCIF07XHJcbiAgICAgICAgdmFyIGMgPSB2ZXJ0aWNlc1sgaW5kZXhDIF07XHJcblxyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBhLngsIGEueSApLFxyXG4gICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYi54LCBiLnkgKSxcclxuICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGMueCwgYy55IClcclxuICAgICAgICBdO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2VuZXJhdGVTaWRlV2FsbFVWOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBpbmRleEEsIGluZGV4QiwgaW5kZXhDLCBpbmRleEQgKSB7XHJcblxyXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cclxuICAgICAgICB2YXIgYSA9IHZlcnRpY2VzWyBpbmRleEEgXTtcclxuICAgICAgICB2YXIgYiA9IHZlcnRpY2VzWyBpbmRleEIgXTtcclxuICAgICAgICB2YXIgYyA9IHZlcnRpY2VzWyBpbmRleEMgXTtcclxuICAgICAgICB2YXIgZCA9IHZlcnRpY2VzWyBpbmRleEQgXTtcclxuXHJcbiAgICAgICAgaWYgKCBNYXRoLmFicyggYS55IC0gYi55ICkgPCAwLjAxICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBhLngsIDEgLSBhLnogKSxcclxuICAgICAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBiLngsIDEgLSBiLnogKSxcclxuICAgICAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBjLngsIDEgLSBjLnogKSxcclxuICAgICAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBkLngsIDEgLSBkLnogKVxyXG4gICAgICAgICAgICBdO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBhLnksIDEgLSBhLnogKSxcclxuICAgICAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBiLnksIDEgLSBiLnogKSxcclxuICAgICAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBjLnksIDEgLSBjLnogKSxcclxuICAgICAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBkLnksIDEgLSBkLnogKVxyXG4gICAgICAgICAgICBdO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvU2hhcGVHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igam9ub2JyMSAvIGh0dHA6Ly9qb25vYnIxLmNvbVxyXG4gKlxyXG4gKiBDcmVhdGVzIGEgb25lLXNpZGVkIHBvbHlnb25hbCBnZW9tZXRyeSBmcm9tIGEgcGF0aCBzaGFwZS4gU2ltaWxhciB0b1xyXG4gKiBFeHRydWRlR2VvbWV0cnkuXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqXHJcbiAqXHRjdXJ2ZVNlZ21lbnRzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgY3VydmVzLiBOT1QgVVNFRCBBVCBUSEUgTU9NRU5ULlxyXG4gKlxyXG4gKlx0bWF0ZXJpYWw6IDxpbnQ+IC8vIG1hdGVyaWFsIGluZGV4IGZvciBmcm9udCBhbmQgYmFjayBmYWNlc1xyXG4gKlx0dXZHZW5lcmF0b3I6IDxPYmplY3Q+IC8vIG9iamVjdCB0aGF0IHByb3ZpZGVzIFVWIGdlbmVyYXRvciBmdW5jdGlvbnNcclxuICpcclxuICogfVxyXG4gKiovXHJcblxyXG5USFJFRS5TaGFwZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCBzaGFwZXMsIG9wdGlvbnMgKSB7XHJcblxyXG4gICAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdTaGFwZUdlb21ldHJ5JztcclxuXHJcbiAgICBpZiAoIEFycmF5LmlzQXJyYXkoIHNoYXBlcyApID09PSBmYWxzZSApIHNoYXBlcyA9IFsgc2hhcGVzIF07XHJcblxyXG4gICAgdGhpcy5hZGRTaGFwZUxpc3QoIHNoYXBlcywgb3B0aW9ucyApO1xyXG5cclxuICAgIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU2hhcGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuU2hhcGVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TaGFwZUdlb21ldHJ5O1xyXG5cclxuLyoqXHJcbiAqIEFkZCBhbiBhcnJheSBvZiBzaGFwZXMgdG8gVEhSRUUuU2hhcGVHZW9tZXRyeS5cclxuICovXHJcblRIUkVFLlNoYXBlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlTGlzdCA9IGZ1bmN0aW9uICggc2hhcGVzLCBvcHRpb25zICkge1xyXG5cclxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICB0aGlzLmFkZFNoYXBlKCBzaGFwZXNbIGkgXSwgb3B0aW9ucyApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBhIHNoYXBlIHRvIFRIUkVFLlNoYXBlR2VvbWV0cnksIGJhc2VkIG9uIFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5cclxuICovXHJcblRIUkVFLlNoYXBlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24gKCBzaGFwZSwgb3B0aW9ucyApIHtcclxuXHJcbiAgICBpZiAoIG9wdGlvbnMgPT09IHVuZGVmaW5lZCApIG9wdGlvbnMgPSB7fTtcclxuICAgIHZhciBjdXJ2ZVNlZ21lbnRzID0gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmN1cnZlU2VnbWVudHMgOiAxMjtcclxuXHJcbiAgICB2YXIgbWF0ZXJpYWwgPSBvcHRpb25zLm1hdGVyaWFsO1xyXG4gICAgdmFyIHV2Z2VuID0gb3B0aW9ucy5VVkdlbmVyYXRvciA9PT0gdW5kZWZpbmVkID8gVEhSRUUuRXh0cnVkZUdlb21ldHJ5LldvcmxkVVZHZW5lcmF0b3IgOiBvcHRpb25zLlVWR2VuZXJhdG9yO1xyXG5cclxuICAgIC8vXHJcblxyXG4gICAgdmFyIGksIGwsIGhvbGU7XHJcblxyXG4gICAgdmFyIHNoYXBlc09mZnNldCA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xyXG4gICAgdmFyIHNoYXBlUG9pbnRzID0gc2hhcGUuZXh0cmFjdFBvaW50cyggY3VydmVTZWdtZW50cyApO1xyXG5cclxuICAgIHZhciB2ZXJ0aWNlcyA9IHNoYXBlUG9pbnRzLnNoYXBlO1xyXG4gICAgdmFyIGhvbGVzID0gc2hhcGVQb2ludHMuaG9sZXM7XHJcblxyXG4gICAgdmFyIHJldmVyc2UgPSAhIFRIUkVFLlNoYXBlVXRpbHMuaXNDbG9ja1dpc2UoIHZlcnRpY2VzICk7XHJcblxyXG4gICAgaWYgKCByZXZlcnNlICkge1xyXG5cclxuICAgICAgICB2ZXJ0aWNlcyA9IHZlcnRpY2VzLnJldmVyc2UoKTtcclxuXHJcbiAgICAgICAgLy8gTWF5YmUgd2Ugc2hvdWxkIGFsc28gY2hlY2sgaWYgaG9sZXMgYXJlIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24sIGp1c3QgdG8gYmUgc2FmZS4uLlxyXG5cclxuICAgICAgICBmb3IgKCBpID0gMCwgbCA9IGhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICBob2xlID0gaG9sZXNbIGkgXTtcclxuXHJcbiAgICAgICAgICAgIGlmICggVEhSRUUuU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSggaG9sZSApICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGhvbGVzWyBpIF0gPSBob2xlLnJldmVyc2UoKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXZlcnNlID0gZmFsc2U7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHZhciBmYWNlcyA9IFRIUkVFLlNoYXBlVXRpbHMudHJpYW5ndWxhdGVTaGFwZSggdmVydGljZXMsIGhvbGVzICk7XHJcblxyXG4gICAgLy8gVmVydGljZXNcclxuXHJcbiAgICBmb3IgKCBpID0gMCwgbCA9IGhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIGhvbGUgPSBob2xlc1sgaSBdO1xyXG4gICAgICAgIHZlcnRpY2VzID0gdmVydGljZXMuY29uY2F0KCBob2xlICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vXHJcblxyXG4gICAgdmFyIHZlcnQsIHZsZW4gPSB2ZXJ0aWNlcy5sZW5ndGg7XHJcbiAgICB2YXIgZmFjZSwgZmxlbiA9IGZhY2VzLmxlbmd0aDtcclxuXHJcbiAgICBmb3IgKCBpID0gMDsgaSA8IHZsZW47IGkgKysgKSB7XHJcblxyXG4gICAgICAgIHZlcnQgPSB2ZXJ0aWNlc1sgaSBdO1xyXG5cclxuICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCB2ZXJ0LngsIHZlcnQueSwgMCApICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcclxuXHJcbiAgICAgICAgZmFjZSA9IGZhY2VzWyBpIF07XHJcblxyXG4gICAgICAgIHZhciBhID0gZmFjZVsgMCBdICsgc2hhcGVzT2Zmc2V0O1xyXG4gICAgICAgIHZhciBiID0gZmFjZVsgMSBdICsgc2hhcGVzT2Zmc2V0O1xyXG4gICAgICAgIHZhciBjID0gZmFjZVsgMiBdICsgc2hhcGVzT2Zmc2V0O1xyXG5cclxuICAgICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgYywgbnVsbCwgbnVsbCwgbWF0ZXJpYWwgKSApO1xyXG4gICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIHV2Z2VuLmdlbmVyYXRlVG9wVVYoIHRoaXMsIGEsIGIsIGMgKSApO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9MYXRoZUdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhc3Ryb2R1ZCAvIGh0dHA6Ly9hc3Ryb2R1ZC5pc2dyZWF0Lm9yZy9cclxuICogQGF1dGhvciB6ejg1IC8gaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG4gKi9cclxuXHJcbi8vIHBvaW50cyAtIHRvIGNyZWF0ZSBhIGNsb3NlZCB0b3J1cywgb25lIG11c3QgdXNlIGEgc2V0IG9mIHBvaW50cyBcclxuLy8gICAgbGlrZSBzbzogWyBhLCBiLCBjLCBkLCBhIF0sIHNlZSBmaXJzdCBpcyB0aGUgc2FtZSBhcyBsYXN0LlxyXG4vLyBzZWdtZW50cyAtIHRoZSBudW1iZXIgb2YgY2lyY3VtZmVyZW5jZSBzZWdtZW50cyB0byBjcmVhdGVcclxuLy8gcGhpU3RhcnQgLSB0aGUgc3RhcnRpbmcgcmFkaWFuXHJcbi8vIHBoaUxlbmd0aCAtIHRoZSByYWRpYW4gKDAgdG8gMipQSSkgcmFuZ2Ugb2YgdGhlIGxhdGhlZCBzZWN0aW9uXHJcbi8vICAgIDIqcGkgaXMgYSBjbG9zZWQgbGF0aGUsIGxlc3MgdGhhbiAyUEkgaXMgYSBwb3J0aW9uLlxyXG5cclxuVEhSRUUuTGF0aGVHZW9tZXRyeSA9IGZ1bmN0aW9uICggcG9pbnRzLCBzZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCApIHtcclxuXHJcbiAgICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ0xhdGhlR2VvbWV0cnknO1xyXG5cclxuICAgIHRoaXMucGFyYW1ldGVycyA9IHtcclxuICAgICAgICBwb2ludHM6IHBvaW50cyxcclxuICAgICAgICBzZWdtZW50czogc2VnbWVudHMsXHJcbiAgICAgICAgcGhpU3RhcnQ6IHBoaVN0YXJ0LFxyXG4gICAgICAgIHBoaUxlbmd0aDogcGhpTGVuZ3RoXHJcbiAgICB9O1xyXG5cclxuICAgIHNlZ21lbnRzID0gc2VnbWVudHMgfHwgMTI7XHJcbiAgICBwaGlTdGFydCA9IHBoaVN0YXJ0IHx8IDA7XHJcbiAgICBwaGlMZW5ndGggPSBwaGlMZW5ndGggfHwgMiAqIE1hdGguUEk7XHJcblxyXG4gICAgdmFyIGludmVyc2VQb2ludExlbmd0aCA9IDEuMCAvICggcG9pbnRzLmxlbmd0aCAtIDEgKTtcclxuICAgIHZhciBpbnZlcnNlU2VnbWVudHMgPSAxLjAgLyBzZWdtZW50cztcclxuXHJcbiAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gc2VnbWVudHM7IGkgPD0gaWw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIHZhciBwaGkgPSBwaGlTdGFydCArIGkgKiBpbnZlcnNlU2VnbWVudHMgKiBwaGlMZW5ndGg7XHJcblxyXG4gICAgICAgIHZhciBjID0gTWF0aC5jb3MoIHBoaSApLFxyXG4gICAgICAgICAgICBzID0gTWF0aC5zaW4oIHBoaSApO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gcG9pbnRzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHB0ID0gcG9pbnRzWyBqIF07XHJcblxyXG4gICAgICAgICAgICB2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgICAgIHZlcnRleC54ID0gYyAqIHB0LnggLSBzICogcHQueTtcclxuICAgICAgICAgICAgdmVydGV4LnkgPSBzICogcHQueCArIGMgKiBwdC55O1xyXG4gICAgICAgICAgICB2ZXJ0ZXgueiA9IHB0Lno7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHZhciBucCA9IHBvaW50cy5sZW5ndGg7XHJcblxyXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHNlZ21lbnRzOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBwb2ludHMubGVuZ3RoIC0gMTsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGJhc2UgPSBqICsgbnAgKiBpO1xyXG4gICAgICAgICAgICB2YXIgYSA9IGJhc2U7XHJcbiAgICAgICAgICAgIHZhciBiID0gYmFzZSArIG5wO1xyXG4gICAgICAgICAgICB2YXIgYyA9IGJhc2UgKyAxICsgbnA7XHJcbiAgICAgICAgICAgIHZhciBkID0gYmFzZSArIDE7XHJcblxyXG4gICAgICAgICAgICB2YXIgdTAgPSBpICogaW52ZXJzZVNlZ21lbnRzO1xyXG4gICAgICAgICAgICB2YXIgdjAgPSBqICogaW52ZXJzZVBvaW50TGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgdTEgPSB1MCArIGludmVyc2VTZWdtZW50cztcclxuICAgICAgICAgICAgdmFyIHYxID0gdjAgKyBpbnZlcnNlUG9pbnRMZW5ndGg7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCApICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbXHJcblxyXG4gICAgICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIHUwLCB2MCApLFxyXG4gICAgICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIHUxLCB2MCApLFxyXG4gICAgICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIHUwLCB2MSApXHJcblxyXG4gICAgICAgICAgICBdICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYiwgYywgZCApICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbXHJcblxyXG4gICAgICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIHUxLCB2MCApLFxyXG4gICAgICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIHUxLCB2MSApLFxyXG4gICAgICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIHUwLCB2MSApXHJcblxyXG4gICAgICAgICAgICBdICk7XHJcblxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xyXG4gICAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuICAgIHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5MYXRoZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5MYXRoZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxhdGhlR2VvbWV0cnk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9QbGFuZUdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogYmFzZWQgb24gaHR0cDovL3BhcGVydmlzaW9uM2QuZ29vZ2xlY29kZS5jb20vc3ZuL3RydW5rL2FzMy90cnVuay9zcmMvb3JnL3BhcGVydmlzaW9uM2Qvb2JqZWN0cy9wcmltaXRpdmVzL1BsYW5lLmFzXHJcbiAqL1xyXG5cclxuVEhSRUUuUGxhbmVHZW9tZXRyeSA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMgKSB7XHJcblxyXG4gICAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdQbGFuZUdlb21ldHJ5JztcclxuXHJcbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgIHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXHJcbiAgICAgICAgaGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgVEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeSggd2lkdGgsIGhlaWdodCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMgKSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBsYW5lR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLlBsYW5lR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUGxhbmVHZW9tZXRyeTtcclxuXHJcblRIUkVFLlBsYW5lR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuUGxhbmVHZW9tZXRyeShcclxuICAgICAgICBwYXJhbWV0ZXJzLndpZHRoLFxyXG4gICAgICAgIHBhcmFtZXRlcnMuaGVpZ2h0LFxyXG4gICAgICAgIHBhcmFtZXRlcnMud2lkdGhTZWdtZW50cyxcclxuICAgICAgICBwYXJhbWV0ZXJzLmhlaWdodFNlZ21lbnRzXHJcbiAgICApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1BsYW5lQnVmZmVyR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBiYXNlZCBvbiBodHRwOi8vcGFwZXJ2aXNpb24zZC5nb29nbGVjb2RlLmNvbS9zdm4vdHJ1bmsvYXMzL3RydW5rL3NyYy9vcmcvcGFwZXJ2aXNpb24zZC9vYmplY3RzL3ByaW1pdGl2ZXMvUGxhbmUuYXNcclxuICovXHJcblxyXG5USFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5ID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cyApIHtcclxuXHJcbiAgICBUSFJFRS5CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ1BsYW5lQnVmZmVyR2VvbWV0cnknO1xyXG5cclxuICAgIHRoaXMucGFyYW1ldGVycyA9IHtcclxuICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgd2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcclxuICAgICAgICBoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHNcclxuICAgIH07XHJcblxyXG4gICAgdmFyIHdpZHRoX2hhbGYgPSB3aWR0aCAvIDI7XHJcbiAgICB2YXIgaGVpZ2h0X2hhbGYgPSBoZWlnaHQgLyAyO1xyXG5cclxuICAgIHZhciBncmlkWCA9IE1hdGguZmxvb3IoIHdpZHRoU2VnbWVudHMgKSB8fCAxO1xyXG4gICAgdmFyIGdyaWRZID0gTWF0aC5mbG9vciggaGVpZ2h0U2VnbWVudHMgKSB8fCAxO1xyXG5cclxuICAgIHZhciBncmlkWDEgPSBncmlkWCArIDE7XHJcbiAgICB2YXIgZ3JpZFkxID0gZ3JpZFkgKyAxO1xyXG5cclxuICAgIHZhciBzZWdtZW50X3dpZHRoID0gd2lkdGggLyBncmlkWDtcclxuICAgIHZhciBzZWdtZW50X2hlaWdodCA9IGhlaWdodCAvIGdyaWRZO1xyXG5cclxuICAgIHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdyaWRYMSAqIGdyaWRZMSAqIDMgKTtcclxuICAgIHZhciBub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheSggZ3JpZFgxICogZ3JpZFkxICogMyApO1xyXG4gICAgdmFyIHV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdyaWRYMSAqIGdyaWRZMSAqIDIgKTtcclxuXHJcbiAgICB2YXIgb2Zmc2V0ID0gMDtcclxuICAgIHZhciBvZmZzZXQyID0gMDtcclxuXHJcbiAgICBmb3IgKCB2YXIgaXkgPSAwOyBpeSA8IGdyaWRZMTsgaXkgKysgKSB7XHJcblxyXG4gICAgICAgIHZhciB5ID0gaXkgKiBzZWdtZW50X2hlaWdodCAtIGhlaWdodF9oYWxmO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaXggPSAwOyBpeCA8IGdyaWRYMTsgaXggKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgeCA9IGl4ICogc2VnbWVudF93aWR0aCAtIHdpZHRoX2hhbGY7XHJcblxyXG4gICAgICAgICAgICB2ZXJ0aWNlc1sgb2Zmc2V0IF0gPSB4O1xyXG4gICAgICAgICAgICB2ZXJ0aWNlc1sgb2Zmc2V0ICsgMSBdID0gLSB5O1xyXG5cclxuICAgICAgICAgICAgbm9ybWFsc1sgb2Zmc2V0ICsgMiBdID0gMTtcclxuXHJcbiAgICAgICAgICAgIHV2c1sgb2Zmc2V0MiBdID0gaXggLyBncmlkWDtcclxuICAgICAgICAgICAgdXZzWyBvZmZzZXQyICsgMSBdID0gMSAtICggaXkgLyBncmlkWSApO1xyXG5cclxuICAgICAgICAgICAgb2Zmc2V0ICs9IDM7XHJcbiAgICAgICAgICAgIG9mZnNldDIgKz0gMjtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBvZmZzZXQgPSAwO1xyXG5cclxuICAgIHZhciBpbmRpY2VzID0gbmV3ICggKCB2ZXJ0aWNlcy5sZW5ndGggLyAzICkgPiA2NTUzNSA/IFVpbnQzMkFycmF5IDogVWludDE2QXJyYXkgKSggZ3JpZFggKiBncmlkWSAqIDYgKTtcclxuXHJcbiAgICBmb3IgKCB2YXIgaXkgPSAwOyBpeSA8IGdyaWRZOyBpeSArKyApIHtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGl4ID0gMDsgaXggPCBncmlkWDsgaXggKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYSA9IGl4ICsgZ3JpZFgxICogaXk7XHJcbiAgICAgICAgICAgIHZhciBiID0gaXggKyBncmlkWDEgKiAoIGl5ICsgMSApO1xyXG4gICAgICAgICAgICB2YXIgYyA9ICggaXggKyAxICkgKyBncmlkWDEgKiAoIGl5ICsgMSApO1xyXG4gICAgICAgICAgICB2YXIgZCA9ICggaXggKyAxICkgKyBncmlkWDEgKiBpeTtcclxuXHJcbiAgICAgICAgICAgIGluZGljZXNbIG9mZnNldCBdID0gYTtcclxuICAgICAgICAgICAgaW5kaWNlc1sgb2Zmc2V0ICsgMSBdID0gYjtcclxuICAgICAgICAgICAgaW5kaWNlc1sgb2Zmc2V0ICsgMiBdID0gZDtcclxuXHJcbiAgICAgICAgICAgIGluZGljZXNbIG9mZnNldCArIDMgXSA9IGI7XHJcbiAgICAgICAgICAgIGluZGljZXNbIG9mZnNldCArIDQgXSA9IGM7XHJcbiAgICAgICAgICAgIGluZGljZXNbIG9mZnNldCArIDUgXSA9IGQ7XHJcblxyXG4gICAgICAgICAgICBvZmZzZXQgKz0gNjtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNldEluZGV4KCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBpbmRpY2VzLCAxICkgKTtcclxuICAgIHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XHJcbiAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xyXG4gICAgdGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5O1xyXG5cclxuVEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5KFxyXG4gICAgICAgIHBhcmFtZXRlcnMud2lkdGgsXHJcbiAgICAgICAgcGFyYW1ldGVycy5oZWlnaHQsXHJcbiAgICAgICAgcGFyYW1ldGVycy53aWR0aFNlZ21lbnRzLFxyXG4gICAgICAgIHBhcmFtZXRlcnMuaGVpZ2h0U2VnbWVudHNcclxuICAgICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvUmluZ0dlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBLYWxlYiBNdXJwaHlcclxuICovXHJcblxyXG5USFJFRS5SaW5nR2VvbWV0cnkgPSBmdW5jdGlvbiAoIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgdGhldGFTZWdtZW50cywgcGhpU2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xyXG5cclxuICAgIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnUmluZ0dlb21ldHJ5JztcclxuXHJcbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgaW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzLFxyXG4gICAgICAgIG91dGVyUmFkaXVzOiBvdXRlclJhZGl1cyxcclxuICAgICAgICB0aGV0YVNlZ21lbnRzOiB0aGV0YVNlZ21lbnRzLFxyXG4gICAgICAgIHBoaVNlZ21lbnRzOiBwaGlTZWdtZW50cyxcclxuICAgICAgICB0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxyXG4gICAgICAgIHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxyXG4gICAgfTtcclxuXHJcbiAgICBpbm5lclJhZGl1cyA9IGlubmVyUmFkaXVzIHx8IDA7XHJcbiAgICBvdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzIHx8IDUwO1xyXG5cclxuICAgIHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcclxuICAgIHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogTWF0aC5QSSAqIDI7XHJcblxyXG4gICAgdGhldGFTZWdtZW50cyA9IHRoZXRhU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IE1hdGgubWF4KCAzLCB0aGV0YVNlZ21lbnRzICkgOiA4O1xyXG4gICAgcGhpU2VnbWVudHMgPSBwaGlTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gTWF0aC5tYXgoIDEsIHBoaVNlZ21lbnRzICkgOiA4O1xyXG5cclxuICAgIHZhciBpLCBvLCB1dnMgPSBbXSwgcmFkaXVzID0gaW5uZXJSYWRpdXMsIHJhZGl1c1N0ZXAgPSAoICggb3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cyApIC8gcGhpU2VnbWVudHMgKTtcclxuXHJcbiAgICBmb3IgKCBpID0gMDsgaSA8IHBoaVNlZ21lbnRzICsgMTsgaSArKyApIHtcclxuXHJcbiAgICAgICAgLy8gY29uY2VudHJpYyBjaXJjbGVzIGluc2lkZSByaW5nXHJcblxyXG4gICAgICAgIGZvciAoIG8gPSAwOyBvIDwgdGhldGFTZWdtZW50cyArIDE7IG8gKysgKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBudW1iZXIgb2Ygc2VnbWVudHMgcGVyIGNpcmNsZVxyXG5cclxuICAgICAgICAgICAgdmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gdGhldGFTdGFydCArIG8gLyB0aGV0YVNlZ21lbnRzICogdGhldGFMZW5ndGg7XHJcbiAgICAgICAgICAgIHZlcnRleC54ID0gcmFkaXVzICogTWF0aC5jb3MoIHNlZ21lbnQgKTtcclxuICAgICAgICAgICAgdmVydGV4LnkgPSByYWRpdXMgKiBNYXRoLnNpbiggc2VnbWVudCApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcclxuICAgICAgICAgICAgdXZzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCAoIHZlcnRleC54IC8gb3V0ZXJSYWRpdXMgKyAxICkgLyAyLCAoIHZlcnRleC55IC8gb3V0ZXJSYWRpdXMgKyAxICkgLyAyICkgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByYWRpdXMgKz0gcmFkaXVzU3RlcDtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG4gPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApO1xyXG5cclxuICAgIGZvciAoIGkgPSAwOyBpIDwgcGhpU2VnbWVudHM7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIC8vIGNvbmNlbnRyaWMgY2lyY2xlcyBpbnNpZGUgcmluZ1xyXG5cclxuICAgICAgICB2YXIgdGhldGFTZWdtZW50ID0gaSAqICggdGhldGFTZWdtZW50cyArIDEgKTtcclxuXHJcbiAgICAgICAgZm9yICggbyA9IDA7IG8gPCB0aGV0YVNlZ21lbnRzIDsgbyArKyApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIG51bWJlciBvZiBzZWdtZW50cyBwZXIgY2lyY2xlXHJcblxyXG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IG8gKyB0aGV0YVNlZ21lbnQ7XHJcblxyXG4gICAgICAgICAgICB2YXIgdjEgPSBzZWdtZW50O1xyXG4gICAgICAgICAgICB2YXIgdjIgPSBzZWdtZW50ICsgdGhldGFTZWdtZW50cyArIDE7XHJcbiAgICAgICAgICAgIHZhciB2MyA9IHNlZ21lbnQgKyB0aGV0YVNlZ21lbnRzICsgMjtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHYzLCBbIG4uY2xvbmUoKSwgbi5jbG9uZSgpLCBuLmNsb25lKCkgXSApICk7XHJcbiAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyB2MSBdLmNsb25lKCksIHV2c1sgdjIgXS5jbG9uZSgpLCB1dnNbIHYzIF0uY2xvbmUoKSBdICk7XHJcblxyXG4gICAgICAgICAgICB2MSA9IHNlZ21lbnQ7XHJcbiAgICAgICAgICAgIHYyID0gc2VnbWVudCArIHRoZXRhU2VnbWVudHMgKyAyO1xyXG4gICAgICAgICAgICB2MyA9IHNlZ21lbnQgKyAxO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MiwgdjMsIFsgbi5jbG9uZSgpLCBuLmNsb25lKCksIG4uY2xvbmUoKSBdICkgKTtcclxuICAgICAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIHYxIF0uY2xvbmUoKSwgdXZzWyB2MiBdLmNsb25lKCksIHV2c1sgdjMgXS5jbG9uZSgpIF0gKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cclxuICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCBuZXcgVEhSRUUuVmVjdG9yMygpLCByYWRpdXMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5SaW5nR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLlJpbmdHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5SaW5nR2VvbWV0cnk7XHJcblxyXG5USFJFRS5SaW5nR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuUmluZ0dlb21ldHJ5KFxyXG4gICAgICAgIHBhcmFtZXRlcnMuaW5uZXJSYWRpdXMsXHJcbiAgICAgICAgcGFyYW1ldGVycy5vdXRlclJhZGl1cyxcclxuICAgICAgICBwYXJhbWV0ZXJzLnRoZXRhU2VnbWVudHMsXHJcbiAgICAgICAgcGFyYW1ldGVycy5waGlTZWdtZW50cyxcclxuICAgICAgICBwYXJhbWV0ZXJzLnRoZXRhU3RhcnQsXHJcbiAgICAgICAgcGFyYW1ldGVycy50aGV0YUxlbmd0aFxyXG4gICAgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9TcGhlcmVHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU3BoZXJlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGgsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xyXG5cclxuICAgIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnU3BoZXJlR2VvbWV0cnknO1xyXG5cclxuICAgIHRoaXMucGFyYW1ldGVycyA9IHtcclxuICAgICAgICByYWRpdXM6IHJhZGl1cyxcclxuICAgICAgICB3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxyXG4gICAgICAgIGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcclxuICAgICAgICBwaGlTdGFydDogcGhpU3RhcnQsXHJcbiAgICAgICAgcGhpTGVuZ3RoOiBwaGlMZW5ndGgsXHJcbiAgICAgICAgdGhldGFTdGFydDogdGhldGFTdGFydCxcclxuICAgICAgICB0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBUSFJFRS5TcGhlcmVCdWZmZXJHZW9tZXRyeSggcmFkaXVzLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNwaGVyZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5TcGhlcmVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TcGhlcmVHZW9tZXRyeTtcclxuXHJcblRIUkVFLlNwaGVyZUdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcclxuXHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KFxyXG4gICAgICAgIHBhcmFtZXRlcnMucmFkaXVzLFxyXG4gICAgICAgIHBhcmFtZXRlcnMud2lkdGhTZWdtZW50cyxcclxuICAgICAgICBwYXJhbWV0ZXJzLmhlaWdodFNlZ21lbnRzLFxyXG4gICAgICAgIHBhcmFtZXRlcnMucGhpU3RhcnQsXHJcbiAgICAgICAgcGFyYW1ldGVycy5waGlMZW5ndGgsXHJcbiAgICAgICAgcGFyYW1ldGVycy50aGV0YVN0YXJ0LFxyXG4gICAgICAgIHBhcmFtZXRlcnMudGhldGFMZW5ndGhcclxuICAgICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvU3BoZXJlQnVmZmVyR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcclxuICogYmFzZWQgb24gVEhSRUUuU3BoZXJlR2VvbWV0cnlcclxuICovXHJcblxyXG5USFJFRS5TcGhlcmVCdWZmZXJHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XHJcblxyXG4gICAgVEhSRUUuQnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdTcGhlcmVCdWZmZXJHZW9tZXRyeSc7XHJcblxyXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xyXG4gICAgICAgIHJhZGl1czogcmFkaXVzLFxyXG4gICAgICAgIHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXHJcbiAgICAgICAgaGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxyXG4gICAgICAgIHBoaVN0YXJ0OiBwaGlTdGFydCxcclxuICAgICAgICBwaGlMZW5ndGg6IHBoaUxlbmd0aCxcclxuICAgICAgICB0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxyXG4gICAgICAgIHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxyXG4gICAgfTtcclxuXHJcbiAgICByYWRpdXMgPSByYWRpdXMgfHwgNTA7XHJcblxyXG4gICAgd2lkdGhTZWdtZW50cyA9IE1hdGgubWF4KCAzLCBNYXRoLmZsb29yKCB3aWR0aFNlZ21lbnRzICkgfHwgOCApO1xyXG4gICAgaGVpZ2h0U2VnbWVudHMgPSBNYXRoLm1heCggMiwgTWF0aC5mbG9vciggaGVpZ2h0U2VnbWVudHMgKSB8fCA2ICk7XHJcblxyXG4gICAgcGhpU3RhcnQgPSBwaGlTdGFydCAhPT0gdW5kZWZpbmVkID8gcGhpU3RhcnQgOiAwO1xyXG4gICAgcGhpTGVuZ3RoID0gcGhpTGVuZ3RoICE9PSB1bmRlZmluZWQgPyBwaGlMZW5ndGggOiBNYXRoLlBJICogMjtcclxuXHJcbiAgICB0aGV0YVN0YXJ0ID0gdGhldGFTdGFydCAhPT0gdW5kZWZpbmVkID8gdGhldGFTdGFydCA6IDA7XHJcbiAgICB0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IE1hdGguUEk7XHJcblxyXG4gICAgdmFyIHRoZXRhRW5kID0gdGhldGFTdGFydCArIHRoZXRhTGVuZ3RoO1xyXG5cclxuICAgIHZhciB2ZXJ0ZXhDb3VudCA9ICggKCB3aWR0aFNlZ21lbnRzICsgMSApICogKCBoZWlnaHRTZWdtZW50cyArIDEgKSApO1xyXG5cclxuICAgIHZhciBwb3NpdGlvbnMgPSBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0ZXhDb3VudCAqIDMgKSwgMyApO1xyXG4gICAgdmFyIG5vcm1hbHMgPSBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0ZXhDb3VudCAqIDMgKSwgMyApO1xyXG4gICAgdmFyIHV2cyA9IG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRleENvdW50ICogMiApLCAyICk7XHJcblxyXG4gICAgdmFyIGluZGV4ID0gMCwgdmVydGljZXMgPSBbXSwgbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICBmb3IgKCB2YXIgeSA9IDA7IHkgPD0gaGVpZ2h0U2VnbWVudHM7IHkgKysgKSB7XHJcblxyXG4gICAgICAgIHZhciB2ZXJ0aWNlc1JvdyA9IFtdO1xyXG5cclxuICAgICAgICB2YXIgdiA9IHkgLyBoZWlnaHRTZWdtZW50cztcclxuXHJcbiAgICAgICAgZm9yICggdmFyIHggPSAwOyB4IDw9IHdpZHRoU2VnbWVudHM7IHggKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgdSA9IHggLyB3aWR0aFNlZ21lbnRzO1xyXG5cclxuICAgICAgICAgICAgdmFyIHB4ID0gLSByYWRpdXMgKiBNYXRoLmNvcyggcGhpU3RhcnQgKyB1ICogcGhpTGVuZ3RoICkgKiBNYXRoLnNpbiggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApO1xyXG4gICAgICAgICAgICB2YXIgcHkgPSByYWRpdXMgKiBNYXRoLmNvcyggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApO1xyXG4gICAgICAgICAgICB2YXIgcHogPSByYWRpdXMgKiBNYXRoLnNpbiggcGhpU3RhcnQgKyB1ICogcGhpTGVuZ3RoICkgKiBNYXRoLnNpbiggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApO1xyXG5cclxuICAgICAgICAgICAgbm9ybWFsLnNldCggcHgsIHB5LCBweiApLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICAgICAgcG9zaXRpb25zLnNldFhZWiggaW5kZXgsIHB4LCBweSwgcHogKTtcclxuICAgICAgICAgICAgbm9ybWFscy5zZXRYWVooIGluZGV4LCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XHJcbiAgICAgICAgICAgIHV2cy5zZXRYWSggaW5kZXgsIHUsIDEgLSB2ICk7XHJcblxyXG4gICAgICAgICAgICB2ZXJ0aWNlc1Jvdy5wdXNoKCBpbmRleCApO1xyXG5cclxuICAgICAgICAgICAgaW5kZXggKys7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmVydGljZXMucHVzaCggdmVydGljZXNSb3cgKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGluZGljZXMgPSBbXTtcclxuXHJcbiAgICBmb3IgKCB2YXIgeSA9IDA7IHkgPCBoZWlnaHRTZWdtZW50czsgeSArKyApIHtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIHggPSAwOyB4IDwgd2lkdGhTZWdtZW50czsgeCArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciB2MSA9IHZlcnRpY2VzWyB5IF1bIHggKyAxIF07XHJcbiAgICAgICAgICAgIHZhciB2MiA9IHZlcnRpY2VzWyB5IF1bIHggXTtcclxuICAgICAgICAgICAgdmFyIHYzID0gdmVydGljZXNbIHkgKyAxIF1bIHggXTtcclxuICAgICAgICAgICAgdmFyIHY0ID0gdmVydGljZXNbIHkgKyAxIF1bIHggKyAxIF07XHJcblxyXG4gICAgICAgICAgICBpZiAoIHkgIT09IDAgfHwgdGhldGFTdGFydCA+IDAgKSBpbmRpY2VzLnB1c2goIHYxLCB2MiwgdjQgKTtcclxuICAgICAgICAgICAgaWYgKCB5ICE9PSBoZWlnaHRTZWdtZW50cyAtIDEgfHwgdGhldGFFbmQgPCBNYXRoLlBJICkgaW5kaWNlcy5wdXNoKCB2MiwgdjMsIHY0ICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zZXRJbmRleCggbmV3ICggcG9zaXRpb25zLmNvdW50ID4gNjU1MzUgPyBUSFJFRS5VaW50MzJBdHRyaWJ1dGUgOiBUSFJFRS5VaW50MTZBdHRyaWJ1dGUgKSggaW5kaWNlcywgMSApICk7XHJcbiAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zaXRpb25zICk7XHJcbiAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5vcm1hbHMgKTtcclxuICAgIHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCB1dnMgKTtcclxuXHJcbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggbmV3IFRIUkVFLlZlY3RvcjMoKSwgcmFkaXVzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5O1xyXG5cclxuVEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnkoXHJcbiAgICAgICAgcGFyYW1ldGVycy5yYWRpdXMsXHJcbiAgICAgICAgcGFyYW1ldGVycy53aWR0aFNlZ21lbnRzLFxyXG4gICAgICAgIHBhcmFtZXRlcnMuaGVpZ2h0U2VnbWVudHMsXHJcbiAgICAgICAgcGFyYW1ldGVycy5waGlTdGFydCxcclxuICAgICAgICBwYXJhbWV0ZXJzLnBoaUxlbmd0aCxcclxuICAgICAgICBwYXJhbWV0ZXJzLnRoZXRhU3RhcnQsXHJcbiAgICAgICAgcGFyYW1ldGVycy50aGV0YUxlbmd0aFxyXG4gICAgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9Ub3J1c0dlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBvb3Ntb3hpZWNvZGVcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogYmFzZWQgb24gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2F3YXkzZC9zb3VyY2UvYnJvd3NlL3RydW5rL2ZwMTAvQXdheTNETGl0ZS9zcmMvYXdheTNkbGl0ZS9wcmltaXRpdmVzL1RvcnVzLmFzP3I9Mjg4OFxyXG4gKi9cclxuXHJcblRIUkVFLlRvcnVzR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgdHViZSwgcmFkaWFsU2VnbWVudHMsIHR1YnVsYXJTZWdtZW50cywgYXJjICkge1xyXG5cclxuICAgIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnVG9ydXNHZW9tZXRyeSc7XHJcblxyXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xyXG4gICAgICAgIHJhZGl1czogcmFkaXVzLFxyXG4gICAgICAgIHR1YmU6IHR1YmUsXHJcbiAgICAgICAgcmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxyXG4gICAgICAgIHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxyXG4gICAgICAgIGFyYzogYXJjXHJcbiAgICB9O1xyXG5cclxuICAgIHJhZGl1cyA9IHJhZGl1cyB8fCAxMDA7XHJcbiAgICB0dWJlID0gdHViZSB8fCA0MDtcclxuICAgIHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgODtcclxuICAgIHR1YnVsYXJTZWdtZW50cyA9IHR1YnVsYXJTZWdtZW50cyB8fCA2O1xyXG4gICAgYXJjID0gYXJjIHx8IE1hdGguUEkgKiAyO1xyXG5cclxuICAgIHZhciBjZW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCB1dnMgPSBbXSwgbm9ybWFscyA9IFtdO1xyXG5cclxuICAgIGZvciAoIHZhciBqID0gMDsgaiA8PSByYWRpYWxTZWdtZW50czsgaiArKyApIHtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDw9IHR1YnVsYXJTZWdtZW50czsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciB1ID0gaSAvIHR1YnVsYXJTZWdtZW50cyAqIGFyYztcclxuICAgICAgICAgICAgdmFyIHYgPSBqIC8gcmFkaWFsU2VnbWVudHMgKiBNYXRoLlBJICogMjtcclxuXHJcbiAgICAgICAgICAgIGNlbnRlci54ID0gcmFkaXVzICogTWF0aC5jb3MoIHUgKTtcclxuICAgICAgICAgICAgY2VudGVyLnkgPSByYWRpdXMgKiBNYXRoLnNpbiggdSApO1xyXG5cclxuICAgICAgICAgICAgdmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgICAgIHZlcnRleC54ID0gKCByYWRpdXMgKyB0dWJlICogTWF0aC5jb3MoIHYgKSApICogTWF0aC5jb3MoIHUgKTtcclxuICAgICAgICAgICAgdmVydGV4LnkgPSAoIHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLnNpbiggdSApO1xyXG4gICAgICAgICAgICB2ZXJ0ZXgueiA9IHR1YmUgKiBNYXRoLnNpbiggdiApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcclxuXHJcbiAgICAgICAgICAgIHV2cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggaSAvIHR1YnVsYXJTZWdtZW50cywgaiAvIHJhZGlhbFNlZ21lbnRzICkgKTtcclxuICAgICAgICAgICAgbm9ybWFscy5wdXNoKCB2ZXJ0ZXguY2xvbmUoKS5zdWIoIGNlbnRlciApLm5vcm1hbGl6ZSgpICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZm9yICggdmFyIGogPSAxOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDE7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGEgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqIGogKyBpIC0gMTtcclxuICAgICAgICAgICAgdmFyIGIgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqICggaiAtIDEgKSArIGkgLSAxO1xyXG4gICAgICAgICAgICB2YXIgYyA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaTtcclxuICAgICAgICAgICAgdmFyIGQgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqIGogKyBpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGQsIFsgbm9ybWFsc1sgYSBdLmNsb25lKCksIG5vcm1hbHNbIGIgXS5jbG9uZSgpLCBub3JtYWxzWyBkIF0uY2xvbmUoKSBdICk7XHJcbiAgICAgICAgICAgIHRoaXMuZmFjZXMucHVzaCggZmFjZSApO1xyXG4gICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2c1sgYSBdLmNsb25lKCksIHV2c1sgYiBdLmNsb25lKCksIHV2c1sgZCBdLmNsb25lKCkgXSApO1xyXG5cclxuICAgICAgICAgICAgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggYiwgYywgZCwgWyBub3JtYWxzWyBiIF0uY2xvbmUoKSwgbm9ybWFsc1sgYyBdLmNsb25lKCksIG5vcm1hbHNbIGQgXS5jbG9uZSgpIF0gKTtcclxuICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKCBmYWNlICk7XHJcbiAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyBiIF0uY2xvbmUoKSwgdXZzWyBjIF0uY2xvbmUoKSwgdXZzWyBkIF0uY2xvbmUoKSBdICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Ub3J1c0dlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5Ub3J1c0dlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlRvcnVzR2VvbWV0cnk7XHJcblxyXG5USFJFRS5Ub3J1c0dlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcclxuXHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLlRvcnVzR2VvbWV0cnkoXHJcbiAgICAgICAgcGFyYW1ldGVycy5yYWRpdXMsXHJcbiAgICAgICAgcGFyYW1ldGVycy50dWJlLFxyXG4gICAgICAgIHBhcmFtZXRlcnMucmFkaWFsU2VnbWVudHMsXHJcbiAgICAgICAgcGFyYW1ldGVycy50dWJ1bGFyU2VnbWVudHMsXHJcbiAgICAgICAgcGFyYW1ldGVycy5hcmNcclxuICAgICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvVG9ydXNLbm90R2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG9vc21veGllY29kZVxyXG4gKiBiYXNlZCBvbiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvYXdheTNkL3NvdXJjZS9icm93c2UvdHJ1bmsvZnAxMC9Bd2F5M0Qvc3JjL2F3YXkzZC9wcmltaXRpdmVzL1RvcnVzS25vdC5hcz9zcGVjPXN2bjI0NzMmcj0yNDczXHJcbiAqL1xyXG5cclxuVEhSRUUuVG9ydXNLbm90R2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgdHViZSwgcmFkaWFsU2VnbWVudHMsIHR1YnVsYXJTZWdtZW50cywgcCwgcSwgaGVpZ2h0U2NhbGUgKSB7XHJcblxyXG4gICAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdUb3J1c0tub3RHZW9tZXRyeSc7XHJcblxyXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xyXG4gICAgICAgIHJhZGl1czogcmFkaXVzLFxyXG4gICAgICAgIHR1YmU6IHR1YmUsXHJcbiAgICAgICAgcmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxyXG4gICAgICAgIHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxyXG4gICAgICAgIHA6IHAsXHJcbiAgICAgICAgcTogcSxcclxuICAgICAgICBoZWlnaHRTY2FsZTogaGVpZ2h0U2NhbGVcclxuICAgIH07XHJcblxyXG4gICAgcmFkaXVzID0gcmFkaXVzIHx8IDEwMDtcclxuICAgIHR1YmUgPSB0dWJlIHx8IDQwO1xyXG4gICAgcmFkaWFsU2VnbWVudHMgPSByYWRpYWxTZWdtZW50cyB8fCA2NDtcclxuICAgIHR1YnVsYXJTZWdtZW50cyA9IHR1YnVsYXJTZWdtZW50cyB8fCA4O1xyXG4gICAgcCA9IHAgfHwgMjtcclxuICAgIHEgPSBxIHx8IDM7XHJcbiAgICBoZWlnaHRTY2FsZSA9IGhlaWdodFNjYWxlIHx8IDE7XHJcblxyXG4gICAgdmFyIGdyaWQgPSBuZXcgQXJyYXkoIHJhZGlhbFNlZ21lbnRzICk7XHJcbiAgICB2YXIgdGFuZyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICB2YXIgbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICB2YXIgYml0YW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHJhZGlhbFNlZ21lbnRzOyArKyBpICkge1xyXG5cclxuICAgICAgICBncmlkWyBpIF0gPSBuZXcgQXJyYXkoIHR1YnVsYXJTZWdtZW50cyApO1xyXG4gICAgICAgIHZhciB1ID0gaSAvIHJhZGlhbFNlZ21lbnRzICogMiAqIHAgKiBNYXRoLlBJO1xyXG4gICAgICAgIHZhciBwMSA9IGdldFBvcyggdSwgcSwgcCwgcmFkaXVzLCBoZWlnaHRTY2FsZSApO1xyXG4gICAgICAgIHZhciBwMiA9IGdldFBvcyggdSArIDAuMDEsIHEsIHAsIHJhZGl1cywgaGVpZ2h0U2NhbGUgKTtcclxuICAgICAgICB0YW5nLnN1YlZlY3RvcnMoIHAyLCBwMSApO1xyXG4gICAgICAgIG4uYWRkVmVjdG9ycyggcDIsIHAxICk7XHJcblxyXG4gICAgICAgIGJpdGFuLmNyb3NzVmVjdG9ycyggdGFuZywgbiApO1xyXG4gICAgICAgIG4uY3Jvc3NWZWN0b3JzKCBiaXRhbiwgdGFuZyApO1xyXG4gICAgICAgIGJpdGFuLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIG4ubm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IHR1YnVsYXJTZWdtZW50czsgKysgaiApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciB2ID0gaiAvIHR1YnVsYXJTZWdtZW50cyAqIDIgKiBNYXRoLlBJO1xyXG4gICAgICAgICAgICB2YXIgY3ggPSAtIHR1YmUgKiBNYXRoLmNvcyggdiApOyAvLyBUT0RPOiBIYWNrOiBOZWdhdGluZyBpdCBzbyBpdCBmYWNlcyBvdXRzaWRlLlxyXG4gICAgICAgICAgICB2YXIgY3kgPSB0dWJlICogTWF0aC5zaW4oIHYgKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBwb3MgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgICAgICBwb3MueCA9IHAxLnggKyBjeCAqIG4ueCArIGN5ICogYml0YW4ueDtcclxuICAgICAgICAgICAgcG9zLnkgPSBwMS55ICsgY3ggKiBuLnkgKyBjeSAqIGJpdGFuLnk7XHJcbiAgICAgICAgICAgIHBvcy56ID0gcDEueiArIGN4ICogbi56ICsgY3kgKiBiaXRhbi56O1xyXG5cclxuICAgICAgICAgICAgZ3JpZFsgaSBdWyBqIF0gPSB0aGlzLnZlcnRpY2VzLnB1c2goIHBvcyApIC0gMTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCByYWRpYWxTZWdtZW50czsgKysgaSApIHtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwgdHVidWxhclNlZ21lbnRzOyArKyBqICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGlwID0gKCBpICsgMSApICUgcmFkaWFsU2VnbWVudHM7XHJcbiAgICAgICAgICAgIHZhciBqcCA9ICggaiArIDEgKSAlIHR1YnVsYXJTZWdtZW50cztcclxuXHJcbiAgICAgICAgICAgIHZhciBhID0gZ3JpZFsgaSBdWyBqIF07XHJcbiAgICAgICAgICAgIHZhciBiID0gZ3JpZFsgaXAgXVsgaiBdO1xyXG4gICAgICAgICAgICB2YXIgYyA9IGdyaWRbIGlwIF1bIGpwIF07XHJcbiAgICAgICAgICAgIHZhciBkID0gZ3JpZFsgaSBdWyBqcCBdO1xyXG5cclxuICAgICAgICAgICAgdmFyIHV2YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBpIC8gcmFkaWFsU2VnbWVudHMsIGogLyB0dWJ1bGFyU2VnbWVudHMgKTtcclxuICAgICAgICAgICAgdmFyIHV2YiA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGkgKyAxICkgLyByYWRpYWxTZWdtZW50cywgaiAvIHR1YnVsYXJTZWdtZW50cyApO1xyXG4gICAgICAgICAgICB2YXIgdXZjID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaSArIDEgKSAvIHJhZGlhbFNlZ21lbnRzLCAoIGogKyAxICkgLyB0dWJ1bGFyU2VnbWVudHMgKTtcclxuICAgICAgICAgICAgdmFyIHV2ZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCBpIC8gcmFkaWFsU2VnbWVudHMsICggaiArIDEgKSAvIHR1YnVsYXJTZWdtZW50cyApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGQgKSApO1xyXG4gICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2YSwgdXZiLCB1dmQgXSApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQgKSApO1xyXG4gICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2Yi5jbG9uZSgpLCB1dmMsIHV2ZC5jbG9uZSgpIF0gKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG4gICAgdGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldFBvcyggdSwgaW5fcSwgaW5fcCwgcmFkaXVzLCBoZWlnaHRTY2FsZSApIHtcclxuXHJcbiAgICAgICAgdmFyIGN1ID0gTWF0aC5jb3MoIHUgKTtcclxuICAgICAgICB2YXIgc3UgPSBNYXRoLnNpbiggdSApO1xyXG4gICAgICAgIHZhciBxdU92ZXJQID0gaW5fcSAvIGluX3AgKiB1O1xyXG4gICAgICAgIHZhciBjcyA9IE1hdGguY29zKCBxdU92ZXJQICk7XHJcblxyXG4gICAgICAgIHZhciB0eCA9IHJhZGl1cyAqICggMiArIGNzICkgKiAwLjUgKiBjdTtcclxuICAgICAgICB2YXIgdHkgPSByYWRpdXMgKiAoIDIgKyBjcyApICogc3UgKiAwLjU7XHJcbiAgICAgICAgdmFyIHR6ID0gaGVpZ2h0U2NhbGUgKiByYWRpdXMgKiBNYXRoLnNpbiggcXVPdmVyUCApICogMC41O1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoIHR4LCB0eSwgdHogKTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVG9ydXNLbm90R2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLlRvcnVzS25vdEdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlRvcnVzS25vdEdlb21ldHJ5O1xyXG5cclxuVEhSRUUuVG9ydXNLbm90R2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuVG9ydXNLbm90R2VvbWV0cnkoXHJcbiAgICAgICAgcGFyYW1ldGVycy5yYWRpdXMsXHJcbiAgICAgICAgcGFyYW1ldGVycy50dWJlLFxyXG4gICAgICAgIHBhcmFtZXRlcnMucmFkaWFsU2VnbWVudHMsXHJcbiAgICAgICAgcGFyYW1ldGVycy50dWJ1bGFyU2VnbWVudHMsXHJcbiAgICAgICAgcGFyYW1ldGVycy5wLFxyXG4gICAgICAgIHBhcmFtZXRlcnMucSxcclxuICAgICAgICBwYXJhbWV0ZXJzLmhlaWdodFNjYWxlXHJcbiAgICApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1R1YmVHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcclxuICogQGF1dGhvciBtaW5pbmdvbGQgLyBodHRwczovL2dpdGh1Yi5jb20vbWluaW5nb2xkXHJcbiAqIEBhdXRob3Igam9ub2JyMSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9qb25vYnIxXHJcbiAqXHJcbiAqIE1vZGlmaWVkIGZyb20gdGhlIFRvcnVzS25vdEdlb21ldHJ5IGJ5IEBvb3Ntb3hpZWNvZGVcclxuICpcclxuICogQ3JlYXRlcyBhIHR1YmUgd2hpY2ggZXh0cnVkZXMgYWxvbmcgYSAzZCBzcGxpbmVcclxuICpcclxuICogVXNlcyBwYXJhbGxlbCB0cmFuc3BvcnQgZnJhbWVzIGFzIGRlc2NyaWJlZCBpblxyXG4gKiBodHRwOi8vd3d3LmNzLmluZGlhbmEuZWR1L3B1Yi90ZWNocmVwb3J0cy9UUjQyNS5wZGZcclxuICovXHJcblxyXG5USFJFRS5UdWJlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHBhdGgsIHNlZ21lbnRzLCByYWRpdXMsIHJhZGlhbFNlZ21lbnRzLCBjbG9zZWQsIHRhcGVyICkge1xyXG5cclxuICAgIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnVHViZUdlb21ldHJ5JztcclxuXHJcbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgcGF0aDogcGF0aCxcclxuICAgICAgICBzZWdtZW50czogc2VnbWVudHMsXHJcbiAgICAgICAgcmFkaXVzOiByYWRpdXMsXHJcbiAgICAgICAgcmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxyXG4gICAgICAgIGNsb3NlZDogY2xvc2VkLFxyXG4gICAgICAgIHRhcGVyOiB0YXBlclxyXG4gICAgfTtcclxuXHJcbiAgICBzZWdtZW50cyA9IHNlZ21lbnRzIHx8IDY0O1xyXG4gICAgcmFkaXVzID0gcmFkaXVzIHx8IDE7XHJcbiAgICByYWRpYWxTZWdtZW50cyA9IHJhZGlhbFNlZ21lbnRzIHx8IDg7XHJcbiAgICBjbG9zZWQgPSBjbG9zZWQgfHwgZmFsc2U7XHJcbiAgICB0YXBlciA9IHRhcGVyIHx8IFRIUkVFLlR1YmVHZW9tZXRyeS5Ob1RhcGVyO1xyXG5cclxuICAgIHZhciBncmlkID0gW107XHJcblxyXG4gICAgdmFyIHNjb3BlID0gdGhpcyxcclxuXHJcbiAgICAgICAgdGFuZ2VudCxcclxuICAgICAgICBub3JtYWwsXHJcbiAgICAgICAgYmlub3JtYWwsXHJcblxyXG4gICAgICAgIG51bXBvaW50cyA9IHNlZ21lbnRzICsgMSxcclxuXHJcbiAgICAgICAgdSwgdiwgcixcclxuXHJcbiAgICAgICAgY3gsIGN5LFxyXG4gICAgICAgIHBvcywgcG9zMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcbiAgICAgICAgaSwgaixcclxuICAgICAgICBpcCwganAsXHJcbiAgICAgICAgYSwgYiwgYywgZCxcclxuICAgICAgICB1dmEsIHV2YiwgdXZjLCB1dmQ7XHJcblxyXG4gICAgdmFyIGZyYW1lcyA9IG5ldyBUSFJFRS5UdWJlR2VvbWV0cnkuRnJlbmV0RnJhbWVzKCBwYXRoLCBzZWdtZW50cywgY2xvc2VkICksXHJcbiAgICAgICAgdGFuZ2VudHMgPSBmcmFtZXMudGFuZ2VudHMsXHJcbiAgICAgICAgbm9ybWFscyA9IGZyYW1lcy5ub3JtYWxzLFxyXG4gICAgICAgIGJpbm9ybWFscyA9IGZyYW1lcy5iaW5vcm1hbHM7XHJcblxyXG4gICAgLy8gcHJveHkgaW50ZXJuYWxzXHJcbiAgICB0aGlzLnRhbmdlbnRzID0gdGFuZ2VudHM7XHJcbiAgICB0aGlzLm5vcm1hbHMgPSBub3JtYWxzO1xyXG4gICAgdGhpcy5iaW5vcm1hbHMgPSBiaW5vcm1hbHM7XHJcblxyXG4gICAgZnVuY3Rpb24gdmVydCggeCwgeSwgeiApIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHNjb3BlLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCB4LCB5LCB6ICkgKSAtIDE7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vIGNvbnN0cnVjdCB0aGUgZ3JpZFxyXG5cclxuICAgIGZvciAoIGkgPSAwOyBpIDwgbnVtcG9pbnRzOyBpICsrICkge1xyXG5cclxuICAgICAgICBncmlkWyBpIF0gPSBbXTtcclxuXHJcbiAgICAgICAgdSA9IGkgLyAoIG51bXBvaW50cyAtIDEgKTtcclxuXHJcbiAgICAgICAgcG9zID0gcGF0aC5nZXRQb2ludEF0KCB1ICk7XHJcblxyXG4gICAgICAgIHRhbmdlbnQgPSB0YW5nZW50c1sgaSBdO1xyXG4gICAgICAgIG5vcm1hbCA9IG5vcm1hbHNbIGkgXTtcclxuICAgICAgICBiaW5vcm1hbCA9IGJpbm9ybWFsc1sgaSBdO1xyXG5cclxuICAgICAgICByID0gcmFkaXVzICogdGFwZXIoIHUgKTtcclxuXHJcbiAgICAgICAgZm9yICggaiA9IDA7IGogPCByYWRpYWxTZWdtZW50czsgaiArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHYgPSBqIC8gcmFkaWFsU2VnbWVudHMgKiAyICogTWF0aC5QSTtcclxuXHJcbiAgICAgICAgICAgIGN4ID0gLSByICogTWF0aC5jb3MoIHYgKTsgLy8gVE9ETzogSGFjazogTmVnYXRpbmcgaXQgc28gaXQgZmFjZXMgb3V0c2lkZS5cclxuICAgICAgICAgICAgY3kgPSByICogTWF0aC5zaW4oIHYgKTtcclxuXHJcbiAgICAgICAgICAgIHBvczIuY29weSggcG9zICk7XHJcbiAgICAgICAgICAgIHBvczIueCArPSBjeCAqIG5vcm1hbC54ICsgY3kgKiBiaW5vcm1hbC54O1xyXG4gICAgICAgICAgICBwb3MyLnkgKz0gY3ggKiBub3JtYWwueSArIGN5ICogYmlub3JtYWwueTtcclxuICAgICAgICAgICAgcG9zMi56ICs9IGN4ICogbm9ybWFsLnogKyBjeSAqIGJpbm9ybWFsLno7XHJcblxyXG4gICAgICAgICAgICBncmlkWyBpIF1bIGogXSA9IHZlcnQoIHBvczIueCwgcG9zMi55LCBwb3MyLnogKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gY29uc3RydWN0IHRoZSBtZXNoXHJcblxyXG4gICAgZm9yICggaSA9IDA7IGkgPCBzZWdtZW50czsgaSArKyApIHtcclxuXHJcbiAgICAgICAgZm9yICggaiA9IDA7IGogPCByYWRpYWxTZWdtZW50czsgaiArKyApIHtcclxuXHJcbiAgICAgICAgICAgIGlwID0gKCBjbG9zZWQgKSA/ICggaSArIDEgKSAlIHNlZ21lbnRzIDogaSArIDE7XHJcbiAgICAgICAgICAgIGpwID0gKCBqICsgMSApICUgcmFkaWFsU2VnbWVudHM7XHJcblxyXG4gICAgICAgICAgICBhID0gZ3JpZFsgaSBdWyBqIF07XHRcdC8vICoqKiBOT1QgTkVDRVNTQVJJTFkgUExBTkFSICEgKioqXHJcbiAgICAgICAgICAgIGIgPSBncmlkWyBpcCBdWyBqIF07XHJcbiAgICAgICAgICAgIGMgPSBncmlkWyBpcCBdWyBqcCBdO1xyXG4gICAgICAgICAgICBkID0gZ3JpZFsgaSBdWyBqcCBdO1xyXG5cclxuICAgICAgICAgICAgdXZhID0gbmV3IFRIUkVFLlZlY3RvcjIoIGkgLyBzZWdtZW50cywgaiAvIHJhZGlhbFNlZ21lbnRzICk7XHJcbiAgICAgICAgICAgIHV2YiA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGkgKyAxICkgLyBzZWdtZW50cywgaiAvIHJhZGlhbFNlZ21lbnRzICk7XHJcbiAgICAgICAgICAgIHV2YyA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGkgKyAxICkgLyBzZWdtZW50cywgKCBqICsgMSApIC8gcmFkaWFsU2VnbWVudHMgKTtcclxuICAgICAgICAgICAgdXZkID0gbmV3IFRIUkVFLlZlY3RvcjIoIGkgLyBzZWdtZW50cywgKCBqICsgMSApIC8gcmFkaWFsU2VnbWVudHMgKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBkICkgKTtcclxuICAgICAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dmEsIHV2YiwgdXZkIF0gKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkICkgKTtcclxuICAgICAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dmIuY2xvbmUoKSwgdXZjLCB1dmQuY2xvbmUoKSBdICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuICAgIHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5UdWJlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLlR1YmVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5UdWJlR2VvbWV0cnk7XHJcblRIUkVFLlR1YmVHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMucGFyYW1ldGVycy5wYXRoLFxyXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5zZWdtZW50cywgdGhpcy5wYXJhbWV0ZXJzLnJhZGl1cywgdGhpcy5wYXJhbWV0ZXJzLnJhZGlhbFNlZ21lbnRzLFxyXG4gICAgICAgIHRoaXMucGFyYW1ldGVycy5jbG9zZWQsIHRoaXMucGFyYW1ldGVycy50YXBlclxyXG4gICAgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5UdWJlR2VvbWV0cnkuTm9UYXBlciA9IGZ1bmN0aW9uICggdSApIHtcclxuXHJcbiAgICByZXR1cm4gMTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5UdWJlR2VvbWV0cnkuU2ludXNvaWRhbFRhcGVyID0gZnVuY3Rpb24gKCB1ICkge1xyXG5cclxuICAgIHJldHVybiBNYXRoLnNpbiggTWF0aC5QSSAqIHUgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGb3IgY29tcHV0aW5nIG9mIEZyZW5ldCBmcmFtZXMsIGV4cG9zaW5nIHRoZSB0YW5nZW50cywgbm9ybWFscyBhbmQgYmlub3JtYWxzIHRoZSBzcGxpbmVcclxuVEhSRUUuVHViZUdlb21ldHJ5LkZyZW5ldEZyYW1lcyA9IGZ1bmN0aW9uICggcGF0aCwgc2VnbWVudHMsIGNsb3NlZCApIHtcclxuXHJcbiAgICB2YXJcdG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblxyXG4gICAgICAgIHRhbmdlbnRzID0gW10sXHJcbiAgICAgICAgbm9ybWFscyA9IFtdLFxyXG4gICAgICAgIGJpbm9ybWFscyA9IFtdLFxyXG5cclxuICAgICAgICB2ZWMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG4gICAgICAgIG1hdCA9IG5ldyBUSFJFRS5NYXRyaXg0KCksXHJcblxyXG4gICAgICAgIG51bXBvaW50cyA9IHNlZ21lbnRzICsgMSxcclxuICAgICAgICB0aGV0YSxcclxuICAgICAgICBzbWFsbGVzdCxcclxuXHJcbiAgICAgICAgdHgsIHR5LCB0eixcclxuICAgICAgICBpLCB1O1xyXG5cclxuXHJcbiAgICAvLyBleHBvc2UgaW50ZXJuYWxzXHJcbiAgICB0aGlzLnRhbmdlbnRzID0gdGFuZ2VudHM7XHJcbiAgICB0aGlzLm5vcm1hbHMgPSBub3JtYWxzO1xyXG4gICAgdGhpcy5iaW5vcm1hbHMgPSBiaW5vcm1hbHM7XHJcblxyXG4gICAgLy8gY29tcHV0ZSB0aGUgdGFuZ2VudCB2ZWN0b3JzIGZvciBlYWNoIHNlZ21lbnQgb24gdGhlIHBhdGhcclxuXHJcbiAgICBmb3IgKCBpID0gMDsgaSA8IG51bXBvaW50czsgaSArKyApIHtcclxuXHJcbiAgICAgICAgdSA9IGkgLyAoIG51bXBvaW50cyAtIDEgKTtcclxuXHJcbiAgICAgICAgdGFuZ2VudHNbIGkgXSA9IHBhdGguZ2V0VGFuZ2VudEF0KCB1ICk7XHJcbiAgICAgICAgdGFuZ2VudHNbIGkgXS5ub3JtYWxpemUoKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgaW5pdGlhbE5vcm1hbDMoKTtcclxuXHJcbiAgICAvKlxyXG4gICAgIGZ1bmN0aW9uIGluaXRpYWxOb3JtYWwxKGxhc3RCaW5vcm1hbCkge1xyXG4gICAgIC8vIGZpeGVkIHN0YXJ0IGJpbm9ybWFsLiBIYXMgZGFuZ2VycyBvZiAwIHZlY3RvcnNcclxuICAgICBub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgIGJpbm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICBpZiAobGFzdEJpbm9ybWFsPT09dW5kZWZpbmVkKSBsYXN0Qmlub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApO1xyXG4gICAgIG5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIGxhc3RCaW5vcm1hbCwgdGFuZ2VudHNbIDAgXSApLm5vcm1hbGl6ZSgpO1xyXG4gICAgIGJpbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICkubm9ybWFsaXplKCk7XHJcbiAgICAgfVxyXG5cclxuICAgICBmdW5jdGlvbiBpbml0aWFsTm9ybWFsMigpIHtcclxuXHJcbiAgICAgLy8gVGhpcyB1c2VzIHRoZSBGcmVuZXQtU2VycmV0IGZvcm11bGEgZm9yIGRlcml2aW5nIGJpbm9ybWFsXHJcbiAgICAgdmFyIHQyID0gcGF0aC5nZXRUYW5nZW50QXQoIGVwc2lsb24gKTtcclxuXHJcbiAgICAgbm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKS5zdWJWZWN0b3JzKCB0MiwgdGFuZ2VudHNbIDAgXSApLm5vcm1hbGl6ZSgpO1xyXG4gICAgIGJpbm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIG5vcm1hbHNbIDAgXSApO1xyXG5cclxuICAgICBub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCBiaW5vcm1hbHNbIDAgXSwgdGFuZ2VudHNbIDAgXSApLm5vcm1hbGl6ZSgpOyAvLyBsYXN0IGJpbm9ybWFsIHggdGFuZ2VudFxyXG4gICAgIGJpbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICkubm9ybWFsaXplKCk7XHJcblxyXG4gICAgIH1cclxuICAgICAqL1xyXG5cclxuICAgIGZ1bmN0aW9uIGluaXRpYWxOb3JtYWwzKCkge1xyXG5cclxuICAgICAgICAvLyBzZWxlY3QgYW4gaW5pdGlhbCBub3JtYWwgdmVjdG9yIHBlcnBlbmRpY3VsYXIgdG8gdGhlIGZpcnN0IHRhbmdlbnQgdmVjdG9yLFxyXG4gICAgICAgIC8vIGFuZCBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzbWFsbGVzdCB0YW5nZW50IHh5eiBjb21wb25lbnRcclxuXHJcbiAgICAgICAgbm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICBiaW5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgc21hbGxlc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIHR4ID0gTWF0aC5hYnMoIHRhbmdlbnRzWyAwIF0ueCApO1xyXG4gICAgICAgIHR5ID0gTWF0aC5hYnMoIHRhbmdlbnRzWyAwIF0ueSApO1xyXG4gICAgICAgIHR6ID0gTWF0aC5hYnMoIHRhbmdlbnRzWyAwIF0ueiApO1xyXG5cclxuICAgICAgICBpZiAoIHR4IDw9IHNtYWxsZXN0ICkge1xyXG5cclxuICAgICAgICAgICAgc21hbGxlc3QgPSB0eDtcclxuICAgICAgICAgICAgbm9ybWFsLnNldCggMSwgMCwgMCApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggdHkgPD0gc21hbGxlc3QgKSB7XHJcblxyXG4gICAgICAgICAgICBzbWFsbGVzdCA9IHR5O1xyXG4gICAgICAgICAgICBub3JtYWwuc2V0KCAwLCAxLCAwICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCB0eiA8PSBzbWFsbGVzdCApIHtcclxuXHJcbiAgICAgICAgICAgIG5vcm1hbC5zZXQoIDAsIDAsIDEgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2ZWMuY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWwgKS5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAgICAgbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgdmVjICk7XHJcbiAgICAgICAgYmlub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWxzWyAwIF0gKTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIGNvbXB1dGUgdGhlIHNsb3dseS12YXJ5aW5nIG5vcm1hbCBhbmQgYmlub3JtYWwgdmVjdG9ycyBmb3IgZWFjaCBzZWdtZW50IG9uIHRoZSBwYXRoXHJcblxyXG4gICAgZm9yICggaSA9IDE7IGkgPCBudW1wb2ludHM7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIG5vcm1hbHNbIGkgXSA9IG5vcm1hbHNbIGkgLSAxIF0uY2xvbmUoKTtcclxuXHJcbiAgICAgICAgYmlub3JtYWxzWyBpIF0gPSBiaW5vcm1hbHNbIGkgLSAxIF0uY2xvbmUoKTtcclxuXHJcbiAgICAgICAgdmVjLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGkgLSAxIF0sIHRhbmdlbnRzWyBpIF0gKTtcclxuXHJcbiAgICAgICAgaWYgKCB2ZWMubGVuZ3RoKCkgPiBOdW1iZXIuRVBTSUxPTiApIHtcclxuXHJcbiAgICAgICAgICAgIHZlYy5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAgICAgICAgIHRoZXRhID0gTWF0aC5hY29zKCBUSFJFRS5NYXRoLmNsYW1wKCB0YW5nZW50c1sgaSAtIDEgXS5kb3QoIHRhbmdlbnRzWyBpIF0gKSwgLSAxLCAxICkgKTsgLy8gY2xhbXAgZm9yIGZsb2F0aW5nIHB0IGVycm9yc1xyXG5cclxuICAgICAgICAgICAgbm9ybWFsc1sgaSBdLmFwcGx5TWF0cml4NCggbWF0Lm1ha2VSb3RhdGlvbkF4aXMoIHZlYywgdGhldGEgKSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGJpbm9ybWFsc1sgaSBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGkgXSwgbm9ybWFsc1sgaSBdICk7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBpZiB0aGUgY3VydmUgaXMgY2xvc2VkLCBwb3N0cHJvY2VzcyB0aGUgdmVjdG9ycyBzbyB0aGUgZmlyc3QgYW5kIGxhc3Qgbm9ybWFsIHZlY3RvcnMgYXJlIHRoZSBzYW1lXHJcblxyXG4gICAgaWYgKCBjbG9zZWQgKSB7XHJcblxyXG4gICAgICAgIHRoZXRhID0gTWF0aC5hY29zKCBUSFJFRS5NYXRoLmNsYW1wKCBub3JtYWxzWyAwIF0uZG90KCBub3JtYWxzWyBudW1wb2ludHMgLSAxIF0gKSwgLSAxLCAxICkgKTtcclxuICAgICAgICB0aGV0YSAvPSAoIG51bXBvaW50cyAtIDEgKTtcclxuXHJcbiAgICAgICAgaWYgKCB0YW5nZW50c1sgMCBdLmRvdCggdmVjLmNyb3NzVmVjdG9ycyggbm9ybWFsc1sgMCBdLCBub3JtYWxzWyBudW1wb2ludHMgLSAxIF0gKSApID4gMCApIHtcclxuXHJcbiAgICAgICAgICAgIHRoZXRhID0gLSB0aGV0YTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKCBpID0gMTsgaSA8IG51bXBvaW50czsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIHR3aXN0IGEgbGl0dGxlLi4uXHJcbiAgICAgICAgICAgIG5vcm1hbHNbIGkgXS5hcHBseU1hdHJpeDQoIG1hdC5tYWtlUm90YXRpb25BeGlzKCB0YW5nZW50c1sgaSBdLCB0aGV0YSAqIGkgKSApO1xyXG4gICAgICAgICAgICBiaW5vcm1hbHNbIGkgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIF0sIG5vcm1hbHNbIGkgXSApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1BvbHloZWRyb25HZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgY2xvY2t3b3JrZ2VlayAvIGh0dHBzOi8vZ2l0aHViLmNvbS9jbG9ja3dvcmtnZWVrXHJcbiAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqL1xyXG5cclxuVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5ID0gZnVuY3Rpb24gKCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKSB7XHJcblxyXG4gICAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdQb2x5aGVkcm9uR2VvbWV0cnknO1xyXG5cclxuICAgIHRoaXMucGFyYW1ldGVycyA9IHtcclxuICAgICAgICB2ZXJ0aWNlczogdmVydGljZXMsXHJcbiAgICAgICAgaW5kaWNlczogaW5kaWNlcyxcclxuICAgICAgICByYWRpdXM6IHJhZGl1cyxcclxuICAgICAgICBkZXRhaWw6IGRldGFpbFxyXG4gICAgfTtcclxuXHJcbiAgICByYWRpdXMgPSByYWRpdXMgfHwgMTtcclxuICAgIGRldGFpbCA9IGRldGFpbCB8fCAwO1xyXG5cclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuXHJcbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBsOyBpICs9IDMgKSB7XHJcblxyXG4gICAgICAgIHByZXBhcmUoIG5ldyBUSFJFRS5WZWN0b3IzKCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc1sgaSArIDEgXSwgdmVydGljZXNbIGkgKyAyIF0gKSApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB2YXIgcCA9IHRoaXMudmVydGljZXM7XHJcblxyXG4gICAgdmFyIGZhY2VzID0gW107XHJcblxyXG4gICAgZm9yICggdmFyIGkgPSAwLCBqID0gMCwgbCA9IGluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArPSAzLCBqICsrICkge1xyXG5cclxuICAgICAgICB2YXIgdjEgPSBwWyBpbmRpY2VzWyBpIF0gXTtcclxuICAgICAgICB2YXIgdjIgPSBwWyBpbmRpY2VzWyBpICsgMSBdIF07XHJcbiAgICAgICAgdmFyIHYzID0gcFsgaW5kaWNlc1sgaSArIDIgXSBdO1xyXG5cclxuICAgICAgICBmYWNlc1sgaiBdID0gbmV3IFRIUkVFLkZhY2UzKCB2MS5pbmRleCwgdjIuaW5kZXgsIHYzLmluZGV4LCBbIHYxLmNsb25lKCksIHYyLmNsb25lKCksIHYzLmNsb25lKCkgXSwgdW5kZWZpbmVkLCBqICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHZhciBjZW50cm9pZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgc3ViZGl2aWRlKCBmYWNlc1sgaSBdLCBkZXRhaWwgKTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gZmFjZSBzdHJhZGRsZXMgdGhlIHNlYW1cclxuXHJcbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICB2YXIgdXZzID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF1bIGkgXTtcclxuXHJcbiAgICAgICAgdmFyIHgwID0gdXZzWyAwIF0ueDtcclxuICAgICAgICB2YXIgeDEgPSB1dnNbIDEgXS54O1xyXG4gICAgICAgIHZhciB4MiA9IHV2c1sgMiBdLng7XHJcblxyXG4gICAgICAgIHZhciBtYXggPSBNYXRoLm1heCggeDAsIHgxLCB4MiApO1xyXG4gICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbiggeDAsIHgxLCB4MiApO1xyXG5cclxuICAgICAgICBpZiAoIG1heCA+IDAuOSAmJiBtaW4gPCAwLjEgKSB7XHJcblxyXG4gICAgICAgICAgICAvLyAwLjkgaXMgc29tZXdoYXQgYXJiaXRyYXJ5XHJcblxyXG4gICAgICAgICAgICBpZiAoIHgwIDwgMC4yICkgdXZzWyAwIF0ueCArPSAxO1xyXG4gICAgICAgICAgICBpZiAoIHgxIDwgMC4yICkgdXZzWyAxIF0ueCArPSAxO1xyXG4gICAgICAgICAgICBpZiAoIHgyIDwgMC4yICkgdXZzWyAyIF0ueCArPSAxO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBBcHBseSByYWRpdXNcclxuXHJcbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIHRoaXMudmVydGljZXNbIGkgXS5tdWx0aXBseVNjYWxhciggcmFkaXVzICk7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBNZXJnZSB2ZXJ0aWNlc1xyXG5cclxuICAgIHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xyXG5cclxuICAgIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcblxyXG4gICAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoIG5ldyBUSFJFRS5WZWN0b3IzKCksIHJhZGl1cyApO1xyXG5cclxuXHJcbiAgICAvLyBQcm9qZWN0IHZlY3RvciBvbnRvIHNwaGVyZSdzIHN1cmZhY2VcclxuXHJcbiAgICBmdW5jdGlvbiBwcmVwYXJlKCB2ZWN0b3IgKSB7XHJcblxyXG4gICAgICAgIHZhciB2ZXJ0ZXggPSB2ZWN0b3Iubm9ybWFsaXplKCkuY2xvbmUoKTtcclxuICAgICAgICB2ZXJ0ZXguaW5kZXggPSB0aGF0LnZlcnRpY2VzLnB1c2goIHZlcnRleCApIC0gMTtcclxuXHJcbiAgICAgICAgLy8gVGV4dHVyZSBjb29yZHMgYXJlIGVxdWl2YWxlbnQgdG8gbWFwIGNvb3JkcywgY2FsY3VsYXRlIGFuZ2xlIGFuZCBjb252ZXJ0IHRvIGZyYWN0aW9uIG9mIGEgY2lyY2xlLlxyXG5cclxuICAgICAgICB2YXIgdSA9IGF6aW11dGgoIHZlY3RvciApIC8gMiAvIE1hdGguUEkgKyAwLjU7XHJcbiAgICAgICAgdmFyIHYgPSBpbmNsaW5hdGlvbiggdmVjdG9yICkgLyBNYXRoLlBJICsgMC41O1xyXG4gICAgICAgIHZlcnRleC51diA9IG5ldyBUSFJFRS5WZWN0b3IyKCB1LCAxIC0gdiApO1xyXG5cclxuICAgICAgICByZXR1cm4gdmVydGV4O1xyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gQXBwcm94aW1hdGUgYSBjdXJ2ZWQgZmFjZSB3aXRoIHJlY3Vyc2l2ZWx5IHN1Yi1kaXZpZGVkIHRyaWFuZ2xlcy5cclxuXHJcbiAgICBmdW5jdGlvbiBtYWtlKCB2MSwgdjIsIHYzLCBtYXRlcmlhbEluZGV4ICkge1xyXG5cclxuICAgICAgICB2YXIgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggdjEuaW5kZXgsIHYyLmluZGV4LCB2My5pbmRleCwgWyB2MS5jbG9uZSgpLCB2Mi5jbG9uZSgpLCB2My5jbG9uZSgpIF0sIHVuZGVmaW5lZCwgbWF0ZXJpYWxJbmRleCApO1xyXG4gICAgICAgIHRoYXQuZmFjZXMucHVzaCggZmFjZSApO1xyXG5cclxuICAgICAgICBjZW50cm9pZC5jb3B5KCB2MSApLmFkZCggdjIgKS5hZGQoIHYzICkuZGl2aWRlU2NhbGFyKCAzICk7XHJcblxyXG4gICAgICAgIHZhciBhemkgPSBhemltdXRoKCBjZW50cm9pZCApO1xyXG5cclxuICAgICAgICB0aGF0LmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbXHJcbiAgICAgICAgICAgIGNvcnJlY3RVViggdjEudXYsIHYxLCBhemkgKSxcclxuICAgICAgICAgICAgY29ycmVjdFVWKCB2Mi51diwgdjIsIGF6aSApLFxyXG4gICAgICAgICAgICBjb3JyZWN0VVYoIHYzLnV2LCB2MywgYXppIClcclxuICAgICAgICBdICk7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBBbmFseXRpY2FsbHkgc3ViZGl2aWRlIGEgZmFjZSB0byB0aGUgcmVxdWlyZWQgZGV0YWlsIGxldmVsLlxyXG5cclxuICAgIGZ1bmN0aW9uIHN1YmRpdmlkZSggZmFjZSwgZGV0YWlsICkge1xyXG5cclxuICAgICAgICB2YXIgY29scyA9IE1hdGgucG93KCAyLCBkZXRhaWwgKTtcclxuICAgICAgICB2YXIgYSA9IHByZXBhcmUoIHRoYXQudmVydGljZXNbIGZhY2UuYSBdICk7XHJcbiAgICAgICAgdmFyIGIgPSBwcmVwYXJlKCB0aGF0LnZlcnRpY2VzWyBmYWNlLmIgXSApO1xyXG4gICAgICAgIHZhciBjID0gcHJlcGFyZSggdGhhdC52ZXJ0aWNlc1sgZmFjZS5jIF0gKTtcclxuICAgICAgICB2YXIgdiA9IFtdO1xyXG5cclxuICAgICAgICB2YXIgbWF0ZXJpYWxJbmRleCA9IGZhY2UubWF0ZXJpYWxJbmRleDtcclxuXHJcbiAgICAgICAgLy8gQ29uc3RydWN0IGFsbCBvZiB0aGUgdmVydGljZXMgZm9yIHRoaXMgc3ViZGl2aXNpb24uXHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPD0gY29sczsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIHZbIGkgXSA9IFtdO1xyXG5cclxuICAgICAgICAgICAgdmFyIGFqID0gcHJlcGFyZSggYS5jbG9uZSgpLmxlcnAoIGMsIGkgLyBjb2xzICkgKTtcclxuICAgICAgICAgICAgdmFyIGJqID0gcHJlcGFyZSggYi5jbG9uZSgpLmxlcnAoIGMsIGkgLyBjb2xzICkgKTtcclxuICAgICAgICAgICAgdmFyIHJvd3MgPSBjb2xzIC0gaTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8PSByb3dzOyBqICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggaiA9PT0gMCAmJiBpID09PSBjb2xzICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2WyBpIF1bIGogXSA9IGFqO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZbIGkgXVsgaiBdID0gcHJlcGFyZSggYWouY2xvbmUoKS5sZXJwKCBiaiwgaiAvIHJvd3MgKSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb25zdHJ1Y3QgYWxsIG9mIHRoZSBmYWNlcy5cclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgY29scyA7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCAyICogKCBjb2xzIC0gaSApIC0gMTsgaiArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgayA9IE1hdGguZmxvb3IoIGogLyAyICk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBqICUgMiA9PT0gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbWFrZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgdlsgaSBdWyBrICsgMSBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2WyBpICsgMSBdWyBrIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZbIGkgXVsgayBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbEluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBtYWtlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2WyBpIF1bIGsgKyAxIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZbIGkgKyAxIF1bIGsgKyAxIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZbIGkgKyAxIF1bIGsgXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxJbmRleFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBBbmdsZSBhcm91bmQgdGhlIFkgYXhpcywgY291bnRlci1jbG9ja3dpc2Ugd2hlbiBsb29raW5nIGZyb20gYWJvdmUuXHJcblxyXG4gICAgZnVuY3Rpb24gYXppbXV0aCggdmVjdG9yICkge1xyXG5cclxuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMiggdmVjdG9yLnosIC0gdmVjdG9yLnggKTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIEFuZ2xlIGFib3ZlIHRoZSBYWiBwbGFuZS5cclxuXHJcbiAgICBmdW5jdGlvbiBpbmNsaW5hdGlvbiggdmVjdG9yICkge1xyXG5cclxuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMiggLSB2ZWN0b3IueSwgTWF0aC5zcXJ0KCAoIHZlY3Rvci54ICogdmVjdG9yLnggKSArICggdmVjdG9yLnogKiB2ZWN0b3IueiApICkgKTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIFRleHR1cmUgZml4aW5nIGhlbHBlci4gU3BoZXJlcyBoYXZlIHNvbWUgb2RkIGJlaGF2aW91cnMuXHJcblxyXG4gICAgZnVuY3Rpb24gY29ycmVjdFVWKCB1diwgdmVjdG9yLCBhemltdXRoICkge1xyXG5cclxuICAgICAgICBpZiAoICggYXppbXV0aCA8IDAgKSAmJiAoIHV2LnggPT09IDEgKSApIHV2ID0gbmV3IFRIUkVFLlZlY3RvcjIoIHV2LnggLSAxLCB1di55ICk7XHJcbiAgICAgICAgaWYgKCAoIHZlY3Rvci54ID09PSAwICkgJiYgKCB2ZWN0b3IueiA9PT0gMCApICkgdXYgPSBuZXcgVEhSRUUuVmVjdG9yMiggYXppbXV0aCAvIDIgLyBNYXRoLlBJICsgMC41LCB1di55ICk7XHJcbiAgICAgICAgcmV0dXJuIHV2LmNsb25lKCk7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbn07XHJcblxyXG5USFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnk7XHJcblxyXG5USFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5KFxyXG4gICAgICAgIHBhcmFtZXRlcnMudmVydGljZXMsXHJcbiAgICAgICAgcGFyYW1ldGVycy5pbmRpY2VzLFxyXG4gICAgICAgIHBhcmFtZXRlcnMucmFkaXVzLFxyXG4gICAgICAgIHBhcmFtZXRlcnMuZGV0YWlsXHJcbiAgICApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0RvZGVjYWhlZHJvbkdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBBYmUgUGF6b3MgLyBodHRwczovL2hhbW9pZC5jb21cclxuICovXHJcblxyXG5USFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCBkZXRhaWwgKSB7XHJcblxyXG4gICAgdmFyIHQgPSAoIDEgKyBNYXRoLnNxcnQoIDUgKSApIC8gMjtcclxuICAgIHZhciByID0gMSAvIHQ7XHJcblxyXG4gICAgdmFyIHZlcnRpY2VzID0gW1xyXG5cclxuICAgICAgICAvLyAo77+9MSwg77+9MSwg77+9MSlcclxuICAgICAgICAtIDEsIC0gMSwgLSAxLCAgICAtIDEsIC0gMSwgIDEsXHJcbiAgICAgICAgLSAxLCAgMSwgLSAxLCAgICAtIDEsICAxLCAgMSxcclxuICAgICAgICAxLCAtIDEsIC0gMSwgICAgIDEsIC0gMSwgIDEsXHJcbiAgICAgICAgMSwgIDEsIC0gMSwgICAgIDEsICAxLCAgMSxcclxuXHJcbiAgICAgICAgLy8gKDAsIO+/vTEvPywg77+9PylcclxuICAgICAgICAwLCAtIHIsIC0gdCwgICAgIDAsIC0gciwgIHQsXHJcbiAgICAgICAgMCwgIHIsIC0gdCwgICAgIDAsICByLCAgdCxcclxuXHJcbiAgICAgICAgLy8gKO+/vTEvPywg77+9PywgMClcclxuICAgICAgICAtIHIsIC0gdCwgIDAsICAgIC0gciwgIHQsICAwLFxyXG4gICAgICAgIHIsIC0gdCwgIDAsICAgICByLCAgdCwgIDAsXHJcblxyXG4gICAgICAgIC8vICjvv70/LCAwLCDvv70xLz8pXHJcbiAgICAgICAgLSB0LCAgMCwgLSByLCAgICAgdCwgIDAsIC0gcixcclxuICAgICAgICAtIHQsICAwLCAgciwgICAgIHQsICAwLCAgclxyXG4gICAgXTtcclxuXHJcbiAgICB2YXIgaW5kaWNlcyA9IFtcclxuICAgICAgICAzLCAxMSwgIDcsICAgICAgMywgIDcsIDE1LCAgICAgIDMsIDE1LCAxMyxcclxuICAgICAgICA3LCAxOSwgMTcsICAgICAgNywgMTcsICA2LCAgICAgIDcsICA2LCAxNSxcclxuICAgICAgICAxNywgIDQsICA4LCAgICAgMTcsICA4LCAxMCwgICAgIDE3LCAxMCwgIDYsXHJcbiAgICAgICAgOCwgIDAsIDE2LCAgICAgIDgsIDE2LCAgMiwgICAgICA4LCAgMiwgMTAsXHJcbiAgICAgICAgMCwgMTIsICAxLCAgICAgIDAsICAxLCAxOCwgICAgICAwLCAxOCwgMTYsXHJcbiAgICAgICAgNiwgMTAsICAyLCAgICAgIDYsICAyLCAxMywgICAgICA2LCAxMywgMTUsXHJcbiAgICAgICAgMiwgMTYsIDE4LCAgICAgIDIsIDE4LCAgMywgICAgICAyLCAgMywgMTMsXHJcbiAgICAgICAgMTgsICAxLCAgOSwgICAgIDE4LCAgOSwgMTEsICAgICAxOCwgMTEsICAzLFxyXG4gICAgICAgIDQsIDE0LCAxMiwgICAgICA0LCAxMiwgIDAsICAgICAgNCwgIDAsICA4LFxyXG4gICAgICAgIDExLCAgOSwgIDUsICAgICAxMSwgIDUsIDE5LCAgICAgMTEsIDE5LCAgNyxcclxuICAgICAgICAxOSwgIDUsIDE0LCAgICAgMTksIDE0LCAgNCwgICAgIDE5LCAgNCwgMTcsXHJcbiAgICAgICAgMSwgMTIsIDE0LCAgICAgIDEsIDE0LCAgNSwgICAgICAxLCAgNSwgIDlcclxuICAgIF07XHJcblxyXG4gICAgVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdEb2RlY2FoZWRyb25HZW9tZXRyeSc7XHJcblxyXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xyXG4gICAgICAgIHJhZGl1czogcmFkaXVzLFxyXG4gICAgICAgIGRldGFpbDogZGV0YWlsXHJcbiAgICB9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLkRvZGVjYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuRG9kZWNhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRG9kZWNhaGVkcm9uR2VvbWV0cnk7XHJcblxyXG5USFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeShcclxuICAgICAgICBwYXJhbWV0ZXJzLnJhZGl1cyxcclxuICAgICAgICBwYXJhbWV0ZXJzLmRldGFpbFxyXG4gICAgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9JY29zYWhlZHJvbkdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxyXG4gKi9cclxuXHJcblRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgZGV0YWlsICkge1xyXG5cclxuICAgIHZhciB0ID0gKCAxICsgTWF0aC5zcXJ0KCA1ICkgKSAvIDI7XHJcblxyXG4gICAgdmFyIHZlcnRpY2VzID0gW1xyXG4gICAgICAgIC0gMSwgIHQsICAwLCAgICAxLCAgdCwgIDAsICAgLSAxLCAtIHQsICAwLCAgICAxLCAtIHQsICAwLFxyXG4gICAgICAgIDAsIC0gMSwgIHQsICAgIDAsICAxLCAgdCwgICAgMCwgLSAxLCAtIHQsICAgIDAsICAxLCAtIHQsXHJcbiAgICAgICAgdCwgIDAsIC0gMSwgICAgdCwgIDAsICAxLCAgIC0gdCwgIDAsIC0gMSwgICAtIHQsICAwLCAgMVxyXG4gICAgXTtcclxuXHJcbiAgICB2YXIgaW5kaWNlcyA9IFtcclxuICAgICAgICAwLCAxMSwgIDUsICAgIDAsICA1LCAgMSwgICAgMCwgIDEsICA3LCAgICAwLCAgNywgMTAsICAgIDAsIDEwLCAxMSxcclxuICAgICAgICAxLCAgNSwgIDksICAgIDUsIDExLCAgNCwgICAxMSwgMTAsICAyLCAgIDEwLCAgNywgIDYsICAgIDcsICAxLCAgOCxcclxuICAgICAgICAzLCAgOSwgIDQsICAgIDMsICA0LCAgMiwgICAgMywgIDIsICA2LCAgICAzLCAgNiwgIDgsICAgIDMsICA4LCAgOSxcclxuICAgICAgICA0LCAgOSwgIDUsICAgIDIsICA0LCAxMSwgICAgNiwgIDIsIDEwLCAgICA4LCAgNiwgIDcsICAgIDksICA4LCAgMVxyXG4gICAgXTtcclxuXHJcbiAgICBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkuY2FsbCggdGhpcywgdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ0ljb3NhaGVkcm9uR2VvbWV0cnknO1xyXG5cclxuICAgIHRoaXMucGFyYW1ldGVycyA9IHtcclxuICAgICAgICByYWRpdXM6IHJhZGl1cyxcclxuICAgICAgICBkZXRhaWw6IGRldGFpbFxyXG4gICAgfTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5O1xyXG5cclxuVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5KFxyXG4gICAgICAgIHBhcmFtZXRlcnMucmFkaXVzLFxyXG4gICAgICAgIHBhcmFtZXRlcnMuZGV0YWlsXHJcbiAgICApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL09jdGFoZWRyb25HZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcclxuICovXHJcblxyXG5USFJFRS5PY3RhaGVkcm9uR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgZGV0YWlsICkge1xyXG5cclxuICAgIHZhciB2ZXJ0aWNlcyA9IFtcclxuICAgICAgICAxLCAwLCAwLCAgIC0gMSwgMCwgMCwgICAgMCwgMSwgMCwgICAgMCwgLSAxLCAwLCAgICAwLCAwLCAxLCAgICAwLCAwLCAtIDFcclxuICAgIF07XHJcblxyXG4gICAgdmFyIGluZGljZXMgPSBbXHJcbiAgICAgICAgMCwgMiwgNCwgICAgMCwgNCwgMywgICAgMCwgMywgNSwgICAgMCwgNSwgMiwgICAgMSwgMiwgNSwgICAgMSwgNSwgMywgICAgMSwgMywgNCwgICAgMSwgNCwgMlxyXG4gICAgXTtcclxuXHJcbiAgICBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkuY2FsbCggdGhpcywgdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ09jdGFoZWRyb25HZW9tZXRyeSc7XHJcblxyXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xyXG4gICAgICAgIHJhZGl1czogcmFkaXVzLFxyXG4gICAgICAgIGRldGFpbDogZGV0YWlsXHJcbiAgICB9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLk9jdGFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLk9jdGFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5PY3RhaGVkcm9uR2VvbWV0cnk7XHJcblxyXG5USFJFRS5PY3RhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5KFxyXG4gICAgICAgIHBhcmFtZXRlcnMucmFkaXVzLFxyXG4gICAgICAgIHBhcmFtZXRlcnMuZGV0YWlsXHJcbiAgICApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1RldHJhaGVkcm9uR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIHRpbW90aHlwcmF0bGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL3RpbW90aHlwcmF0bGV5XHJcbiAqL1xyXG5cclxuVEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCBkZXRhaWwgKSB7XHJcblxyXG4gICAgdmFyIHZlcnRpY2VzID0gW1xyXG4gICAgICAgIDEsICAxLCAgMSwgICAtIDEsIC0gMSwgIDEsICAgLSAxLCAgMSwgLSAxLCAgICAxLCAtIDEsIC0gMVxyXG4gICAgXTtcclxuXHJcbiAgICB2YXIgaW5kaWNlcyA9IFtcclxuICAgICAgICAyLCAgMSwgIDAsICAgIDAsICAzLCAgMiwgICAgMSwgIDMsICAwLCAgICAyLCAgMywgIDFcclxuICAgIF07XHJcblxyXG4gICAgVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xyXG5cclxuICAgIHRoaXMudHlwZSA9ICdUZXRyYWhlZHJvbkdlb21ldHJ5JztcclxuXHJcbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgcmFkaXVzOiByYWRpdXMsXHJcbiAgICAgICAgZGV0YWlsOiBkZXRhaWxcclxuICAgIH07XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeTtcclxuXHJcblRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xyXG5cclxuICAgIHJldHVybiBuZXcgVEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeShcclxuICAgICAgICBwYXJhbWV0ZXJzLnJhZGl1cyxcclxuICAgICAgICBwYXJhbWV0ZXJzLmRldGFpbFxyXG4gICAgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9QYXJhbWV0cmljR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwczovL2dpdGh1Yi5jb20veno4NVxyXG4gKiBQYXJhbWV0cmljIFN1cmZhY2VzIEdlb21ldHJ5XHJcbiAqIGJhc2VkIG9uIHRoZSBicmlsbGlhbnQgYXJ0aWNsZSBieSBAcHJpZGVvdXQgaHR0cDovL3ByaWRlb3V0Lm5ldC9ibG9nLz9wPTQ0XHJcbiAqXHJcbiAqIG5ldyBUSFJFRS5QYXJhbWV0cmljR2VvbWV0cnkoIHBhcmFtZXRyaWNGdW5jdGlvbiwgdVNlZ21lbnRzLCB5U2VnZW1lbnRzICk7XHJcbiAqXHJcbiAqL1xyXG5cclxuVEhSRUUuUGFyYW1ldHJpY0dlb21ldHJ5ID0gZnVuY3Rpb24gKCBmdW5jLCBzbGljZXMsIHN0YWNrcyApIHtcclxuXHJcbiAgICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gJ1BhcmFtZXRyaWNHZW9tZXRyeSc7XHJcblxyXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xyXG4gICAgICAgIGZ1bmM6IGZ1bmMsXHJcbiAgICAgICAgc2xpY2VzOiBzbGljZXMsXHJcbiAgICAgICAgc3RhY2tzOiBzdGFja3NcclxuICAgIH07XHJcblxyXG4gICAgdmFyIHZlcnRzID0gdGhpcy52ZXJ0aWNlcztcclxuICAgIHZhciBmYWNlcyA9IHRoaXMuZmFjZXM7XHJcbiAgICB2YXIgdXZzID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF07XHJcblxyXG4gICAgdmFyIGksIGosIHA7XHJcbiAgICB2YXIgdSwgdjtcclxuXHJcbiAgICB2YXIgc2xpY2VDb3VudCA9IHNsaWNlcyArIDE7XHJcblxyXG4gICAgZm9yICggaSA9IDA7IGkgPD0gc3RhY2tzOyBpICsrICkge1xyXG5cclxuICAgICAgICB2ID0gaSAvIHN0YWNrcztcclxuXHJcbiAgICAgICAgZm9yICggaiA9IDA7IGogPD0gc2xpY2VzOyBqICsrICkge1xyXG5cclxuICAgICAgICAgICAgdSA9IGogLyBzbGljZXM7XHJcblxyXG4gICAgICAgICAgICBwID0gZnVuYyggdSwgdiApO1xyXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKCBwICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGEsIGIsIGMsIGQ7XHJcbiAgICB2YXIgdXZhLCB1dmIsIHV2YywgdXZkO1xyXG5cclxuICAgIGZvciAoIGkgPSAwOyBpIDwgc3RhY2tzOyBpICsrICkge1xyXG5cclxuICAgICAgICBmb3IgKCBqID0gMDsgaiA8IHNsaWNlczsgaiArKyApIHtcclxuXHJcbiAgICAgICAgICAgIGEgPSBpICogc2xpY2VDb3VudCArIGo7XHJcbiAgICAgICAgICAgIGIgPSBpICogc2xpY2VDb3VudCArIGogKyAxO1xyXG4gICAgICAgICAgICBjID0gKCBpICsgMSApICogc2xpY2VDb3VudCArIGogKyAxO1xyXG4gICAgICAgICAgICBkID0gKCBpICsgMSApICogc2xpY2VDb3VudCArIGo7XHJcblxyXG4gICAgICAgICAgICB1dmEgPSBuZXcgVEhSRUUuVmVjdG9yMiggaiAvIHNsaWNlcywgaSAvIHN0YWNrcyApO1xyXG4gICAgICAgICAgICB1dmIgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBqICsgMSApIC8gc2xpY2VzLCBpIC8gc3RhY2tzICk7XHJcbiAgICAgICAgICAgIHV2YyA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGogKyAxICkgLyBzbGljZXMsICggaSArIDEgKSAvIHN0YWNrcyApO1xyXG4gICAgICAgICAgICB1dmQgPSBuZXcgVEhSRUUuVmVjdG9yMiggaiAvIHNsaWNlcywgKCBpICsgMSApIC8gc3RhY2tzICk7XHJcblxyXG4gICAgICAgICAgICBmYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGQgKSApO1xyXG4gICAgICAgICAgICB1dnMucHVzaCggWyB1dmEsIHV2YiwgdXZkIF0gKTtcclxuXHJcbiAgICAgICAgICAgIGZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYiwgYywgZCApICk7XHJcbiAgICAgICAgICAgIHV2cy5wdXNoKCBbIHV2Yi5jbG9uZSgpLCB1dmMsIHV2ZC5jbG9uZSgpIF0gKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBjb25zb2xlLmxvZyh0aGlzKTtcclxuXHJcbiAgICAvLyBtYWdpYyBidWxsZXRcclxuICAgIC8vIHZhciBkaWZmID0gdGhpcy5tZXJnZVZlcnRpY2VzKCk7XHJcbiAgICAvLyBjb25zb2xlLmxvZygncmVtb3ZlZCAnLCBkaWZmLCAnIHZlcnRpY2VzIGJ5IG1lcmdpbmcnKTtcclxuXHJcbiAgICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG4gICAgdGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBhcmFtZXRyaWNHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuUGFyYW1ldHJpY0dlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBhcmFtZXRyaWNHZW9tZXRyeTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1dpcmVmcmFtZUdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5XaXJlZnJhbWVHZW9tZXRyeSA9IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XHJcblxyXG4gICAgVEhSRUUuQnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHZhciBlZGdlID0gWyAwLCAwIF0sIGhhc2ggPSB7fTtcclxuXHJcbiAgICBmdW5jdGlvbiBzb3J0RnVuY3Rpb24oIGEsIGIgKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBhIC0gYjtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGtleXMgPSBbICdhJywgJ2InLCAnYycgXTtcclxuXHJcbiAgICBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XHJcblxyXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xyXG4gICAgICAgIHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xyXG4gICAgICAgIHZhciBudW1FZGdlcyA9IDA7XHJcblxyXG4gICAgICAgIC8vIGFsbG9jYXRlIG1heGltYWwgc2l6ZVxyXG4gICAgICAgIHZhciBlZGdlcyA9IG5ldyBVaW50MzJBcnJheSggNiAqIGZhY2VzLmxlbmd0aCApO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwgMzsgaiArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBlZGdlWyAwIF0gPSBmYWNlWyBrZXlzWyBqIF0gXTtcclxuICAgICAgICAgICAgICAgIGVkZ2VbIDEgXSA9IGZhY2VbIGtleXNbICggaiArIDEgKSAlIDMgXSBdO1xyXG4gICAgICAgICAgICAgICAgZWRnZS5zb3J0KCBzb3J0RnVuY3Rpb24gKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gZWRnZS50b1N0cmluZygpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggaGFzaFsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZWRnZXNbIDIgKiBudW1FZGdlcyBdID0gZWRnZVsgMCBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VzWyAyICogbnVtRWRnZXMgKyAxIF0gPSBlZGdlWyAxIF07XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzaFsga2V5IF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIG51bUVkZ2VzICsrO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgY29vcmRzID0gbmV3IEZsb2F0MzJBcnJheSggbnVtRWRnZXMgKiAyICogMyApO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBudW1FZGdlczsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCAyOyBqICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlc1sgZWRnZXMgWyAyICogaSArIGogXSBdO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IDYgKiBpICsgMyAqIGo7XHJcbiAgICAgICAgICAgICAgICBjb29yZHNbIGluZGV4ICsgMCBdID0gdmVydGV4Lng7XHJcbiAgICAgICAgICAgICAgICBjb29yZHNbIGluZGV4ICsgMSBdID0gdmVydGV4Lnk7XHJcbiAgICAgICAgICAgICAgICBjb29yZHNbIGluZGV4ICsgMiBdID0gdmVydGV4Lno7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGNvb3JkcywgMyApICk7XHJcblxyXG4gICAgfSBlbHNlIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcbiAgICAgICAgaWYgKCBnZW9tZXRyeS5pbmRleCAhPT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIEluZGV4ZWQgQnVmZmVyR2VvbWV0cnlcclxuXHJcbiAgICAgICAgICAgIHZhciBpbmRpY2VzID0gZ2VvbWV0cnkuaW5kZXguYXJyYXk7XHJcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XHJcbiAgICAgICAgICAgIHZhciBkcmF3Y2FsbHMgPSBnZW9tZXRyeS5kcmF3Y2FsbHM7XHJcbiAgICAgICAgICAgIHZhciBudW1FZGdlcyA9IDA7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGRyYXdjYWxscy5sZW5ndGggPT09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkuYWRkR3JvdXAoIDAsIGluZGljZXMubGVuZ3RoICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBhbGxvY2F0ZSBtYXhpbWFsIHNpemVcclxuICAgICAgICAgICAgdmFyIGVkZ2VzID0gbmV3IFVpbnQzMkFycmF5KCAyICogaW5kaWNlcy5sZW5ndGggKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBvID0gMCwgb2wgPSBkcmF3Y2FsbHMubGVuZ3RoOyBvIDwgb2w7ICsrIG8gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGRyYXdjYWxsID0gZHJhd2NhbGxzWyBvIF07XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gZHJhd2NhbGwuc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgY291bnQgPSBkcmF3Y2FsbC5jb3VudDtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IHN0YXJ0LCBpbCA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbDsgaSArPSAzICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCAzOyBqICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWRnZVsgMCBdID0gaW5kaWNlc1sgaSArIGogXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWRnZVsgMSBdID0gaW5kaWNlc1sgaSArICggaiArIDEgKSAlIDMgXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWRnZS5zb3J0KCBzb3J0RnVuY3Rpb24gKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBlZGdlLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGhhc2hbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRnZXNbIDIgKiBudW1FZGdlcyBdID0gZWRnZVsgMCBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRnZXNbIDIgKiBudW1FZGdlcyArIDEgXSA9IGVkZ2VbIDEgXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc2hbIGtleSBdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bUVkZ2VzICsrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGNvb3JkcyA9IG5ldyBGbG9hdDMyQXJyYXkoIG51bUVkZ2VzICogMiAqIDMgKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IG51bUVkZ2VzOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCAyOyBqICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSA2ICogaSArIDMgKiBqO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleDIgPSBlZGdlc1sgMiAqIGkgKyBqIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkc1sgaW5kZXggKyAwIF0gPSB2ZXJ0aWNlcy5nZXRYKCBpbmRleDIgKTtcclxuICAgICAgICAgICAgICAgICAgICBjb29yZHNbIGluZGV4ICsgMSBdID0gdmVydGljZXMuZ2V0WSggaW5kZXgyICk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzWyBpbmRleCArIDIgXSA9IHZlcnRpY2VzLmdldFooIGluZGV4MiApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb29yZHMsIDMgKSApO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgLy8gbm9uLWluZGV4ZWQgQnVmZmVyR2VvbWV0cnlcclxuXHJcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcbiAgICAgICAgICAgIHZhciBudW1FZGdlcyA9IHZlcnRpY2VzLmxlbmd0aCAvIDM7XHJcbiAgICAgICAgICAgIHZhciBudW1UcmlzID0gbnVtRWRnZXMgLyAzO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNvb3JkcyA9IG5ldyBGbG9hdDMyQXJyYXkoIG51bUVkZ2VzICogMiAqIDMgKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IG51bVRyaXM7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IDM7IGogKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IDE4ICogaSArIDYgKiBqO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXgxID0gOSAqIGkgKyAzICogajtcclxuICAgICAgICAgICAgICAgICAgICBjb29yZHNbIGluZGV4ICsgMCBdID0gdmVydGljZXNbIGluZGV4MSBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkc1sgaW5kZXggKyAxIF0gPSB2ZXJ0aWNlc1sgaW5kZXgxICsgMSBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkc1sgaW5kZXggKyAyIF0gPSB2ZXJ0aWNlc1sgaW5kZXgxICsgMiBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXgyID0gOSAqIGkgKyAzICogKCAoIGogKyAxICkgJSAzICk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzWyBpbmRleCArIDMgXSA9IHZlcnRpY2VzWyBpbmRleDIgXTtcclxuICAgICAgICAgICAgICAgICAgICBjb29yZHNbIGluZGV4ICsgNCBdID0gdmVydGljZXNbIGluZGV4MiArIDEgXTtcclxuICAgICAgICAgICAgICAgICAgICBjb29yZHNbIGluZGV4ICsgNSBdID0gdmVydGljZXNbIGluZGV4MiArIDIgXTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggY29vcmRzLCAzICkgKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5XaXJlZnJhbWVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuV2lyZWZyYW1lR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuV2lyZWZyYW1lR2VvbWV0cnk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9BeGlzSGVscGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBzcm91Y2hlcmF5IC8gaHR0cDovL3Nyb3VjaGVyYXkub3JnL1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkF4aXNIZWxwZXIgPSBmdW5jdGlvbiAoIHNpemUgKSB7XHJcblxyXG4gICAgc2l6ZSA9IHNpemUgfHwgMTtcclxuXHJcbiAgICB2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXHJcbiAgICAgICAgMCwgMCwgMCwgIHNpemUsIDAsIDAsXHJcbiAgICAgICAgMCwgMCwgMCwgIDAsIHNpemUsIDAsXHJcbiAgICAgICAgMCwgMCwgMCwgIDAsIDAsIHNpemVcclxuICAgIF0gKTtcclxuXHJcbiAgICB2YXIgY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheSggW1xyXG4gICAgICAgIDEsIDAsIDAsICAxLCAwLjYsIDAsXHJcbiAgICAgICAgMCwgMSwgMCwgIDAuNiwgMSwgMCxcclxuICAgICAgICAwLCAwLCAxLCAgMCwgMC42LCAxXHJcbiAgICBdICk7XHJcblxyXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XHJcbiAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcclxuICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcclxuXHJcbiAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgdmVydGV4Q29sb3JzOiBUSFJFRS5WZXJ0ZXhDb2xvcnMgfSApO1xyXG5cclxuICAgIFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BeGlzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcclxuVEhSRUUuQXhpc0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5BeGlzSGVscGVyO1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvQXJyb3dIZWxwZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL2dpdGh1Yi5jb20veno4NVxyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXHJcbiAqXHJcbiAqIENyZWF0ZXMgYW4gYXJyb3cgZm9yIHZpc3VhbGl6aW5nIGRpcmVjdGlvbnNcclxuICpcclxuICogUGFyYW1ldGVyczpcclxuICogIGRpciAtIFZlY3RvcjNcclxuICogIG9yaWdpbiAtIFZlY3RvcjNcclxuICogIGxlbmd0aCAtIE51bWJlclxyXG4gKiAgY29sb3IgLSBjb2xvciBpbiBoZXggdmFsdWVcclxuICogIGhlYWRMZW5ndGggLSBOdW1iZXJcclxuICogIGhlYWRXaWR0aCAtIE51bWJlclxyXG4gKi9cclxuXHJcblRIUkVFLkFycm93SGVscGVyID0gKCBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIGxpbmVHZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG4gICAgbGluZUdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAwICksIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICkgKTtcclxuXHJcbiAgICB2YXIgY29uZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoIDAsIDAuNSwgMSwgNSwgMSApO1xyXG4gICAgY29uZUdlb21ldHJ5LnRyYW5zbGF0ZSggMCwgLSAwLjUsIDAgKTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gQXJyb3dIZWxwZXIoIGRpciwgb3JpZ2luLCBsZW5ndGgsIGNvbG9yLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKSB7XHJcblxyXG4gICAgICAgIC8vIGRpciBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcclxuXHJcbiAgICAgICAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuICAgICAgICBpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSBjb2xvciA9IDB4ZmZmZjAwO1xyXG4gICAgICAgIGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSAxO1xyXG4gICAgICAgIGlmICggaGVhZExlbmd0aCA9PT0gdW5kZWZpbmVkICkgaGVhZExlbmd0aCA9IDAuMiAqIGxlbmd0aDtcclxuICAgICAgICBpZiAoIGhlYWRXaWR0aCA9PT0gdW5kZWZpbmVkICkgaGVhZFdpZHRoID0gMC4yICogaGVhZExlbmd0aDtcclxuXHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbi5jb3B5KCBvcmlnaW4gKTtcclxuXHJcbiAgICAgICAgaWYgKCBoZWFkTGVuZ3RoIDwgbGVuZ3RoICkge1xyXG4gICAgICAgICAgICB0aGlzLmxpbmUgPSBuZXcgVEhSRUUuTGluZSggbGluZUdlb21ldHJ5LCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSApO1xyXG4gICAgICAgICAgICB0aGlzLmxpbmUubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmFkZCggdGhpcy5saW5lICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmNvbmUgPSBuZXcgVEhSRUUuTWVzaCggY29uZUdlb21ldHJ5LCBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSApO1xyXG4gICAgICAgIHRoaXMuY29uZS5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5hZGQoIHRoaXMuY29uZSApO1xyXG5cclxuICAgICAgICB0aGlzLnNldERpcmVjdGlvbiggZGlyICk7XHJcbiAgICAgICAgdGhpcy5zZXRMZW5ndGgoIGxlbmd0aCwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICk7XHJcblxyXG4gICAgfVxyXG5cclxufSgpICk7XHJcblxyXG5USFJFRS5BcnJvd0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuQXJyb3dIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQXJyb3dIZWxwZXI7XHJcblxyXG5USFJFRS5BcnJvd0hlbHBlci5wcm90b3R5cGUuc2V0RGlyZWN0aW9uID0gKCBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIGF4aXMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgdmFyIHJhZGlhbnM7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNldERpcmVjdGlvbiggZGlyICkge1xyXG5cclxuICAgICAgICAvLyBkaXIgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXHJcblxyXG4gICAgICAgIGlmICggZGlyLnkgPiAwLjk5OTk5ICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5xdWF0ZXJuaW9uLnNldCggMCwgMCwgMCwgMSApO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCBkaXIueSA8IC0gMC45OTk5OSApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucXVhdGVybmlvbi5zZXQoIDEsIDAsIDAsIDAgKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIGF4aXMuc2V0KCBkaXIueiwgMCwgLSBkaXIueCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICAgICAgcmFkaWFucyA9IE1hdGguYWNvcyggZGlyLnkgKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCByYWRpYW5zICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxufSgpICk7XHJcblxyXG5USFJFRS5BcnJvd0hlbHBlci5wcm90b3R5cGUuc2V0TGVuZ3RoID0gZnVuY3Rpb24gKCBsZW5ndGgsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCApIHtcclxuXHJcbiAgICBpZiAoIGhlYWRMZW5ndGggPT09IHVuZGVmaW5lZCApIGhlYWRMZW5ndGggPSAwLjIgKiBsZW5ndGg7XHJcbiAgICBpZiAoIGhlYWRXaWR0aCA9PT0gdW5kZWZpbmVkICkgaGVhZFdpZHRoID0gMC4yICogaGVhZExlbmd0aDtcclxuXHJcbiAgICBpZiAoIGhlYWRMZW5ndGggPCBsZW5ndGggKXtcclxuICAgICAgICB0aGlzLmxpbmUuc2NhbGUuc2V0KCAxLCBsZW5ndGggLSBoZWFkTGVuZ3RoLCAxICk7XHJcbiAgICAgICAgdGhpcy5saW5lLnVwZGF0ZU1hdHJpeCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY29uZS5zY2FsZS5zZXQoIGhlYWRXaWR0aCwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICk7XHJcbiAgICB0aGlzLmNvbmUucG9zaXRpb24ueSA9IGxlbmd0aDtcclxuICAgIHRoaXMuY29uZS51cGRhdGVNYXRyaXgoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BcnJvd0hlbHBlci5wcm90b3R5cGUuc2V0Q29sb3IgPSBmdW5jdGlvbiAoIGNvbG9yICkge1xyXG5cclxuICAgIGlmICggdGhpcy5saW5lICE9PSB1bmRlZmluZWQgKSB0aGlzLmxpbmUubWF0ZXJpYWwuY29sb3Iuc2V0KCBjb2xvciApO1xyXG4gICAgdGhpcy5jb25lLm1hdGVyaWFsLmNvbG9yLnNldCggY29sb3IgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9Cb3hIZWxwZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkJveEhlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuICAgIHZhciBpbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDAsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDQsIDAsIDQsIDEsIDUsIDIsIDYsIDMsIDcgXSApO1xyXG4gICAgdmFyIHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoIDggKiAzICk7XHJcblxyXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XHJcbiAgICBnZW9tZXRyeS5zZXRJbmRleCggbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggaW5kaWNlcywgMSApICk7XHJcbiAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApICk7XHJcblxyXG4gICAgVEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IDB4ZmZmZjAwIH0gKSApO1xyXG5cclxuICAgIGlmICggb2JqZWN0ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlKCBvYmplY3QgKTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQm94SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcclxuVEhSRUUuQm94SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkJveEhlbHBlcjtcclxuXHJcblRIUkVFLkJveEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gKCBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIGJveCA9IG5ldyBUSFJFRS5Cb3gzKCk7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuICAgICAgICBib3guc2V0RnJvbU9iamVjdCggb2JqZWN0ICk7XHJcblxyXG4gICAgICAgIGlmICggYm94LmVtcHR5KCkgKSByZXR1cm47XHJcblxyXG4gICAgICAgIHZhciBtaW4gPSBib3gubWluO1xyXG4gICAgICAgIHZhciBtYXggPSBib3gubWF4O1xyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICA1X19fXzRcclxuICAgICAgICAgMS9fX18wL3xcclxuICAgICAgICAgfCA2X198XzdcclxuICAgICAgICAgMi9fX18zL1xyXG5cclxuICAgICAgICAgMDogbWF4LngsIG1heC55LCBtYXguelxyXG4gICAgICAgICAxOiBtaW4ueCwgbWF4LnksIG1heC56XHJcbiAgICAgICAgIDI6IG1pbi54LCBtaW4ueSwgbWF4LnpcclxuICAgICAgICAgMzogbWF4LngsIG1pbi55LCBtYXguelxyXG4gICAgICAgICA0OiBtYXgueCwgbWF4LnksIG1pbi56XHJcbiAgICAgICAgIDU6IG1pbi54LCBtYXgueSwgbWluLnpcclxuICAgICAgICAgNjogbWluLngsIG1pbi55LCBtaW4uelxyXG4gICAgICAgICA3OiBtYXgueCwgbWluLnksIG1pbi56XHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuICAgICAgICB2YXIgYXJyYXkgPSBwb3NpdGlvbi5hcnJheTtcclxuXHJcbiAgICAgICAgYXJyYXlbICAwIF0gPSBtYXgueDsgYXJyYXlbICAxIF0gPSBtYXgueTsgYXJyYXlbICAyIF0gPSBtYXguejtcclxuICAgICAgICBhcnJheVsgIDMgXSA9IG1pbi54OyBhcnJheVsgIDQgXSA9IG1heC55OyBhcnJheVsgIDUgXSA9IG1heC56O1xyXG4gICAgICAgIGFycmF5WyAgNiBdID0gbWluLng7IGFycmF5WyAgNyBdID0gbWluLnk7IGFycmF5WyAgOCBdID0gbWF4Lno7XHJcbiAgICAgICAgYXJyYXlbICA5IF0gPSBtYXgueDsgYXJyYXlbIDEwIF0gPSBtaW4ueTsgYXJyYXlbIDExIF0gPSBtYXguejtcclxuICAgICAgICBhcnJheVsgMTIgXSA9IG1heC54OyBhcnJheVsgMTMgXSA9IG1heC55OyBhcnJheVsgMTQgXSA9IG1pbi56O1xyXG4gICAgICAgIGFycmF5WyAxNSBdID0gbWluLng7IGFycmF5WyAxNiBdID0gbWF4Lnk7IGFycmF5WyAxNyBdID0gbWluLno7XHJcbiAgICAgICAgYXJyYXlbIDE4IF0gPSBtaW4ueDsgYXJyYXlbIDE5IF0gPSBtaW4ueTsgYXJyYXlbIDIwIF0gPSBtaW4uejtcclxuICAgICAgICBhcnJheVsgMjEgXSA9IG1heC54OyBhcnJheVsgMjIgXSA9IG1pbi55OyBhcnJheVsgMjMgXSA9IG1pbi56O1xyXG5cclxuICAgICAgICBwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMuZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG4gICAgfVxyXG5cclxufSApKCk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9Cb3VuZGluZ0JveEhlbHBlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKi9cclxuXHJcbi8vIGEgaGVscGVyIHRvIHNob3cgdGhlIHdvcmxkLWF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggZm9yIGFuIG9iamVjdFxyXG5cclxuVEhSRUUuQm91bmRpbmdCb3hIZWxwZXIgPSBmdW5jdGlvbiAoIG9iamVjdCwgaGV4ICkge1xyXG5cclxuICAgIHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ODg4ODg4O1xyXG5cclxuICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG5cclxuICAgIHRoaXMuYm94ID0gbmV3IFRIUkVFLkJveDMoKTtcclxuXHJcbiAgICBUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSggMSwgMSwgMSApLCBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yLCB3aXJlZnJhbWU6IHRydWUgfSApICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQm91bmRpbmdCb3hIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWVzaC5wcm90b3R5cGUgKTtcclxuVEhSRUUuQm91bmRpbmdCb3hIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQm91bmRpbmdCb3hIZWxwZXI7XHJcblxyXG5USFJFRS5Cb3VuZGluZ0JveEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHRoaXMuYm94LnNldEZyb21PYmplY3QoIHRoaXMub2JqZWN0ICk7XHJcblxyXG4gICAgdGhpcy5ib3guc2l6ZSggdGhpcy5zY2FsZSApO1xyXG5cclxuICAgIHRoaXMuYm94LmNlbnRlciggdGhpcy5wb3NpdGlvbiApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0NhbWVyYUhlbHBlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqXHQtIHNob3dzIGZydXN0dW0sIGxpbmUgb2Ygc2lnaHQgYW5kIHVwIG9mIHRoZSBjYW1lcmFcclxuICpcdC0gc3VpdGFibGUgZm9yIGZhc3QgdXBkYXRlc1xyXG4gKiBcdC0gYmFzZWQgb24gZnJ1c3R1bSB2aXN1YWxpemF0aW9uIGluIGxpZ2h0Z2wuanMgc2hhZG93bWFwIGV4YW1wbGVcclxuICpcdFx0aHR0cDovL2V2YW53LmdpdGh1Yi5jb20vbGlnaHRnbC5qcy90ZXN0cy9zaGFkb3dtYXAuaHRtbFxyXG4gKi9cclxuXHJcblRIUkVFLkNhbWVyYUhlbHBlciA9IGZ1bmN0aW9uICggY2FtZXJhICkge1xyXG5cclxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG4gICAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiAweGZmZmZmZiwgdmVydGV4Q29sb3JzOiBUSFJFRS5GYWNlQ29sb3JzIH0gKTtcclxuXHJcbiAgICB2YXIgcG9pbnRNYXAgPSB7fTtcclxuXHJcbiAgICAvLyBjb2xvcnNcclxuXHJcbiAgICB2YXIgaGV4RnJ1c3R1bSA9IDB4ZmZhYTAwO1xyXG4gICAgdmFyIGhleENvbmUgPSAweGZmMDAwMDtcclxuICAgIHZhciBoZXhVcCA9IDB4MDBhYWZmO1xyXG4gICAgdmFyIGhleFRhcmdldCA9IDB4ZmZmZmZmO1xyXG4gICAgdmFyIGhleENyb3NzID0gMHgzMzMzMzM7XHJcblxyXG4gICAgLy8gbmVhclxyXG5cclxuICAgIGFkZExpbmUoIFwibjFcIiwgXCJuMlwiLCBoZXhGcnVzdHVtICk7XHJcbiAgICBhZGRMaW5lKCBcIm4yXCIsIFwibjRcIiwgaGV4RnJ1c3R1bSApO1xyXG4gICAgYWRkTGluZSggXCJuNFwiLCBcIm4zXCIsIGhleEZydXN0dW0gKTtcclxuICAgIGFkZExpbmUoIFwibjNcIiwgXCJuMVwiLCBoZXhGcnVzdHVtICk7XHJcblxyXG4gICAgLy8gZmFyXHJcblxyXG4gICAgYWRkTGluZSggXCJmMVwiLCBcImYyXCIsIGhleEZydXN0dW0gKTtcclxuICAgIGFkZExpbmUoIFwiZjJcIiwgXCJmNFwiLCBoZXhGcnVzdHVtICk7XHJcbiAgICBhZGRMaW5lKCBcImY0XCIsIFwiZjNcIiwgaGV4RnJ1c3R1bSApO1xyXG4gICAgYWRkTGluZSggXCJmM1wiLCBcImYxXCIsIGhleEZydXN0dW0gKTtcclxuXHJcbiAgICAvLyBzaWRlc1xyXG5cclxuICAgIGFkZExpbmUoIFwibjFcIiwgXCJmMVwiLCBoZXhGcnVzdHVtICk7XHJcbiAgICBhZGRMaW5lKCBcIm4yXCIsIFwiZjJcIiwgaGV4RnJ1c3R1bSApO1xyXG4gICAgYWRkTGluZSggXCJuM1wiLCBcImYzXCIsIGhleEZydXN0dW0gKTtcclxuICAgIGFkZExpbmUoIFwibjRcIiwgXCJmNFwiLCBoZXhGcnVzdHVtICk7XHJcblxyXG4gICAgLy8gY29uZVxyXG5cclxuICAgIGFkZExpbmUoIFwicFwiLCBcIm4xXCIsIGhleENvbmUgKTtcclxuICAgIGFkZExpbmUoIFwicFwiLCBcIm4yXCIsIGhleENvbmUgKTtcclxuICAgIGFkZExpbmUoIFwicFwiLCBcIm4zXCIsIGhleENvbmUgKTtcclxuICAgIGFkZExpbmUoIFwicFwiLCBcIm40XCIsIGhleENvbmUgKTtcclxuXHJcbiAgICAvLyB1cFxyXG5cclxuICAgIGFkZExpbmUoIFwidTFcIiwgXCJ1MlwiLCBoZXhVcCApO1xyXG4gICAgYWRkTGluZSggXCJ1MlwiLCBcInUzXCIsIGhleFVwICk7XHJcbiAgICBhZGRMaW5lKCBcInUzXCIsIFwidTFcIiwgaGV4VXAgKTtcclxuXHJcbiAgICAvLyB0YXJnZXRcclxuXHJcbiAgICBhZGRMaW5lKCBcImNcIiwgXCJ0XCIsIGhleFRhcmdldCApO1xyXG4gICAgYWRkTGluZSggXCJwXCIsIFwiY1wiLCBoZXhDcm9zcyApO1xyXG5cclxuICAgIC8vIGNyb3NzXHJcblxyXG4gICAgYWRkTGluZSggXCJjbjFcIiwgXCJjbjJcIiwgaGV4Q3Jvc3MgKTtcclxuICAgIGFkZExpbmUoIFwiY24zXCIsIFwiY240XCIsIGhleENyb3NzICk7XHJcblxyXG4gICAgYWRkTGluZSggXCJjZjFcIiwgXCJjZjJcIiwgaGV4Q3Jvc3MgKTtcclxuICAgIGFkZExpbmUoIFwiY2YzXCIsIFwiY2Y0XCIsIGhleENyb3NzICk7XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkTGluZSggYSwgYiwgaGV4ICkge1xyXG5cclxuICAgICAgICBhZGRQb2ludCggYSwgaGV4ICk7XHJcbiAgICAgICAgYWRkUG9pbnQoIGIsIGhleCApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRQb2ludCggaWQsIGhleCApIHtcclxuXHJcbiAgICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoKSApO1xyXG4gICAgICAgIGdlb21ldHJ5LmNvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIGhleCApICk7XHJcblxyXG4gICAgICAgIGlmICggcG9pbnRNYXBbIGlkIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcbiAgICAgICAgICAgIHBvaW50TWFwWyBpZCBdID0gW107XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcG9pbnRNYXBbIGlkIF0ucHVzaCggZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoIC0gMSApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG4gICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XHJcbiAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcblxyXG4gICAgdGhpcy5tYXRyaXggPSBjYW1lcmEubWF0cml4V29ybGQ7XHJcbiAgICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLnBvaW50TWFwID0gcG9pbnRNYXA7XHJcblxyXG4gICAgdGhpcy51cGRhdGUoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DYW1lcmFIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xyXG5USFJFRS5DYW1lcmFIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ2FtZXJhSGVscGVyO1xyXG5cclxuVEhSRUUuQ2FtZXJhSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIGdlb21ldHJ5LCBwb2ludE1hcDtcclxuXHJcbiAgICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgIHZhciBjYW1lcmEgPSBuZXcgVEhSRUUuQ2FtZXJhKCk7XHJcblxyXG4gICAgZnVuY3Rpb24gc2V0UG9pbnQoIHBvaW50LCB4LCB5LCB6ICkge1xyXG5cclxuICAgICAgICB2ZWN0b3Iuc2V0KCB4LCB5LCB6ICkudW5wcm9qZWN0KCBjYW1lcmEgKTtcclxuXHJcbiAgICAgICAgdmFyIHBvaW50cyA9IHBvaW50TWFwWyBwb2ludCBdO1xyXG5cclxuICAgICAgICBpZiAoIHBvaW50cyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlc1sgcG9pbnRzWyBpIF0gXS5jb3B5KCB2ZWN0b3IgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XHJcbiAgICAgICAgcG9pbnRNYXAgPSB0aGlzLnBvaW50TWFwO1xyXG5cclxuICAgICAgICB2YXIgdyA9IDEsIGggPSAxO1xyXG5cclxuICAgICAgICAvLyB3ZSBuZWVkIGp1c3QgY2FtZXJhIHByb2plY3Rpb24gbWF0cml4XHJcbiAgICAgICAgLy8gd29ybGQgbWF0cml4IG11c3QgYmUgaWRlbnRpdHlcclxuXHJcbiAgICAgICAgY2FtZXJhLnByb2plY3Rpb25NYXRyaXguY29weSggdGhpcy5jYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xyXG5cclxuICAgICAgICAvLyBjZW50ZXIgLyB0YXJnZXRcclxuXHJcbiAgICAgICAgc2V0UG9pbnQoIFwiY1wiLCAwLCAwLCAtIDEgKTtcclxuICAgICAgICBzZXRQb2ludCggXCJ0XCIsIDAsIDAsICAxICk7XHJcblxyXG4gICAgICAgIC8vIG5lYXJcclxuXHJcbiAgICAgICAgc2V0UG9pbnQoIFwibjFcIiwgLSB3LCAtIGgsIC0gMSApO1xyXG4gICAgICAgIHNldFBvaW50KCBcIm4yXCIsICAgdywgLSBoLCAtIDEgKTtcclxuICAgICAgICBzZXRQb2ludCggXCJuM1wiLCAtIHcsICAgaCwgLSAxICk7XHJcbiAgICAgICAgc2V0UG9pbnQoIFwibjRcIiwgICB3LCAgIGgsIC0gMSApO1xyXG5cclxuICAgICAgICAvLyBmYXJcclxuXHJcbiAgICAgICAgc2V0UG9pbnQoIFwiZjFcIiwgLSB3LCAtIGgsIDEgKTtcclxuICAgICAgICBzZXRQb2ludCggXCJmMlwiLCAgIHcsIC0gaCwgMSApO1xyXG4gICAgICAgIHNldFBvaW50KCBcImYzXCIsIC0gdywgICBoLCAxICk7XHJcbiAgICAgICAgc2V0UG9pbnQoIFwiZjRcIiwgICB3LCAgIGgsIDEgKTtcclxuXHJcbiAgICAgICAgLy8gdXBcclxuXHJcbiAgICAgICAgc2V0UG9pbnQoIFwidTFcIiwgICB3ICogMC43LCBoICogMS4xLCAtIDEgKTtcclxuICAgICAgICBzZXRQb2ludCggXCJ1MlwiLCAtIHcgKiAwLjcsIGggKiAxLjEsIC0gMSApO1xyXG4gICAgICAgIHNldFBvaW50KCBcInUzXCIsICAgICAgICAgMCwgaCAqIDIsICAgLSAxICk7XHJcblxyXG4gICAgICAgIC8vIGNyb3NzXHJcblxyXG4gICAgICAgIHNldFBvaW50KCBcImNmMVwiLCAtIHcsICAgMCwgMSApO1xyXG4gICAgICAgIHNldFBvaW50KCBcImNmMlwiLCAgIHcsICAgMCwgMSApO1xyXG4gICAgICAgIHNldFBvaW50KCBcImNmM1wiLCAgIDAsIC0gaCwgMSApO1xyXG4gICAgICAgIHNldFBvaW50KCBcImNmNFwiLCAgIDAsICAgaCwgMSApO1xyXG5cclxuICAgICAgICBzZXRQb2ludCggXCJjbjFcIiwgLSB3LCAgIDAsIC0gMSApO1xyXG4gICAgICAgIHNldFBvaW50KCBcImNuMlwiLCAgIHcsICAgMCwgLSAxICk7XHJcbiAgICAgICAgc2V0UG9pbnQoIFwiY24zXCIsICAgMCwgLSBoLCAtIDEgKTtcclxuICAgICAgICBzZXRQb2ludCggXCJjbjRcIiwgICAwLCAgIGgsIC0gMSApO1xyXG5cclxuICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxuICAgIH07XHJcblxyXG59KCk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9EaXJlY3Rpb25hbExpZ2h0SGVscGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqL1xyXG5cclxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlciA9IGZ1bmN0aW9uICggbGlnaHQsIHNpemUgKSB7XHJcblxyXG4gICAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHRoaXMubGlnaHQgPSBsaWdodDtcclxuICAgIHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcclxuXHJcbiAgICB0aGlzLm1hdHJpeCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xyXG4gICAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG4gICAgc2l6ZSA9IHNpemUgfHwgMTtcclxuXHJcbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goXHJcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoIC0gc2l6ZSwgICBzaXplLCAwICksXHJcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoICAgc2l6ZSwgICBzaXplLCAwICksXHJcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoICAgc2l6ZSwgLSBzaXplLCAwICksXHJcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoIC0gc2l6ZSwgLSBzaXplLCAwICksXHJcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoIC0gc2l6ZSwgICBzaXplLCAwIClcclxuICAgICk7XHJcblxyXG4gICAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGZvZzogZmFsc2UgfSApO1xyXG4gICAgbWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xyXG5cclxuICAgIHRoaXMubGlnaHRQbGFuZSA9IG5ldyBUSFJFRS5MaW5lKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuICAgIHRoaXMuYWRkKCB0aGlzLmxpZ2h0UGxhbmUgKTtcclxuXHJcbiAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG4gICAgZ2VvbWV0cnkudmVydGljZXMucHVzaChcclxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKClcclxuICAgICk7XHJcblxyXG4gICAgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgZm9nOiBmYWxzZSB9ICk7XHJcbiAgICBtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XHJcblxyXG4gICAgdGhpcy50YXJnZXRMaW5lID0gbmV3IFRIUkVFLkxpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG4gICAgdGhpcy5hZGQoIHRoaXMudGFyZ2V0TGluZSApO1xyXG5cclxuICAgIHRoaXMudXBkYXRlKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyO1xyXG5cclxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB0aGlzLmxpZ2h0UGxhbmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG4gICAgdGhpcy5saWdodFBsYW5lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcclxuICAgIHRoaXMudGFyZ2V0TGluZS5nZW9tZXRyeS5kaXNwb3NlKCk7XHJcbiAgICB0aGlzLnRhcmdldExpbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgdmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgIHZhciB2MyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdjEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkICk7XHJcbiAgICAgICAgdjIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xyXG4gICAgICAgIHYzLnN1YlZlY3RvcnMoIHYyLCB2MSApO1xyXG5cclxuICAgICAgICB0aGlzLmxpZ2h0UGxhbmUubG9va0F0KCB2MyApO1xyXG4gICAgICAgIHRoaXMubGlnaHRQbGFuZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XHJcblxyXG4gICAgICAgIHRoaXMudGFyZ2V0TGluZS5nZW9tZXRyeS52ZXJ0aWNlc1sgMSBdLmNvcHkoIHYzICk7XHJcbiAgICAgICAgdGhpcy50YXJnZXRMaW5lLmdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy50YXJnZXRMaW5lLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHRQbGFuZS5tYXRlcmlhbC5jb2xvciApO1xyXG5cclxuICAgIH07XHJcblxyXG59KCk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9FZGdlc0hlbHBlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKiBAcGFyYW0gb2JqZWN0IFRIUkVFLk1lc2ggd2hvc2UgZ2VvbWV0cnkgd2lsbCBiZSB1c2VkXHJcbiAqIEBwYXJhbSBoZXggbGluZSBjb2xvclxyXG4gKiBAcGFyYW0gdGhyZXNob2xkQW5nbGUgdGhlIG1pbmltdW0gYW5nbGUgKGluIGRlZ3JlZXMpLFxyXG4gKiBiZXR3ZWVuIHRoZSBmYWNlIG5vcm1hbHMgb2YgYWRqYWNlbnQgZmFjZXMsXHJcbiAqIHRoYXQgaXMgcmVxdWlyZWQgdG8gcmVuZGVyIGFuIGVkZ2UuIEEgdmFsdWUgb2YgMTAgbWVhbnNcclxuICogYW4gZWRnZSBpcyBvbmx5IHJlbmRlcmVkIGlmIHRoZSBhbmdsZSBpcyBhdCBsZWFzdCAxMCBkZWdyZWVzLlxyXG4gKi9cclxuXHJcblRIUkVFLkVkZ2VzSGVscGVyID0gZnVuY3Rpb24gKCBvYmplY3QsIGhleCwgdGhyZXNob2xkQW5nbGUgKSB7XHJcblxyXG4gICAgdmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHhmZmZmZmY7XHJcblxyXG4gICAgVEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIG5ldyBUSFJFRS5FZGdlc0dlb21ldHJ5KCBvYmplY3QuZ2VvbWV0cnksIHRocmVzaG9sZEFuZ2xlICksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IgfSApICk7XHJcblxyXG4gICAgdGhpcy5tYXRyaXggPSBvYmplY3QubWF0cml4V29ybGQ7XHJcbiAgICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5FZGdlc0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XHJcblRIUkVFLkVkZ2VzSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkVkZ2VzSGVscGVyO1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvRmFjZU5vcm1hbHNIZWxwZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICovXHJcblxyXG5USFJFRS5GYWNlTm9ybWFsc0hlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0LCBzaXplLCBoZXgsIGxpbmV3aWR0aCApIHtcclxuXHJcbiAgICAvLyBGYWNlTm9ybWFsc0hlbHBlciBvbmx5IHN1cHBvcnRzIFRIUkVFLkdlb21ldHJ5XHJcblxyXG4gICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XHJcblxyXG4gICAgdGhpcy5zaXplID0gKCBzaXplICE9PSB1bmRlZmluZWQgKSA/IHNpemUgOiAxO1xyXG5cclxuICAgIHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ZmZmZjAwO1xyXG5cclxuICAgIHZhciB3aWR0aCA9ICggbGluZXdpZHRoICE9PSB1bmRlZmluZWQgKSA/IGxpbmV3aWR0aCA6IDE7XHJcblxyXG4gICAgLy9cclxuXHJcbiAgICB2YXIgbk5vcm1hbHMgPSAwO1xyXG5cclxuICAgIHZhciBvYmpHZW9tZXRyeSA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuICAgIGlmICggb2JqR2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcclxuXHJcbiAgICAgICAgbk5vcm1hbHMgPSBvYmpHZW9tZXRyeS5mYWNlcy5sZW5ndGg7XHJcblxyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuRmFjZU5vcm1hbHNIZWxwZXI6IG9ubHkgVEhSRUUuR2VvbWV0cnkgaXMgc3VwcG9ydGVkLiBVc2UgVEhSRUUuVmVydGV4Tm9ybWFsc0hlbHBlciwgaW5zdGVhZC4nICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vXHJcblxyXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XHJcblxyXG4gICAgdmFyIHBvc2l0aW9ucyA9IG5ldyBUSFJFRS5GbG9hdDMyQXR0cmlidXRlKCBuTm9ybWFscyAqIDIgKiAzLCAzICk7XHJcblxyXG4gICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBwb3NpdGlvbnMgKTtcclxuXHJcbiAgICBUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IsIGxpbmV3aWR0aDogd2lkdGggfSApICk7XHJcblxyXG4gICAgLy9cclxuXHJcbiAgICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuICAgIHRoaXMudXBkYXRlKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRmFjZU5vcm1hbHNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xyXG5USFJFRS5GYWNlTm9ybWFsc0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5GYWNlTm9ybWFsc0hlbHBlcjtcclxuXHJcblRIUkVFLkZhY2VOb3JtYWxzSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgdmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgIHZhciBub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XHJcblxyXG4gICAgICAgIHRoaXMub2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XHJcblxyXG4gICAgICAgIG5vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG4gICAgICAgIHZhciBtYXRyaXhXb3JsZCA9IHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkO1xyXG5cclxuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XHJcblxyXG4gICAgICAgIC8vXHJcblxyXG4gICAgICAgIHZhciBvYmpHZW9tZXRyeSA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuICAgICAgICB2YXIgdmVydGljZXMgPSBvYmpHZW9tZXRyeS52ZXJ0aWNlcztcclxuXHJcbiAgICAgICAgdmFyIGZhY2VzID0gb2JqR2VvbWV0cnkuZmFjZXM7XHJcblxyXG4gICAgICAgIHZhciBpZHggPSAwO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cclxuICAgICAgICAgICAgdmFyIG5vcm1hbCA9IGZhY2Uubm9ybWFsO1xyXG5cclxuICAgICAgICAgICAgdjEuY29weSggdmVydGljZXNbIGZhY2UuYSBdIClcclxuICAgICAgICAgICAgICAgIC5hZGQoIHZlcnRpY2VzWyBmYWNlLmIgXSApXHJcbiAgICAgICAgICAgICAgICAuYWRkKCB2ZXJ0aWNlc1sgZmFjZS5jIF0gKVxyXG4gICAgICAgICAgICAgICAgLmRpdmlkZVNjYWxhciggMyApXHJcbiAgICAgICAgICAgICAgICAuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xyXG5cclxuICAgICAgICAgICAgdjIuY29weSggbm9ybWFsICkuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggdGhpcy5zaXplICkuYWRkKCB2MSApO1xyXG5cclxuICAgICAgICAgICAgcG9zaXRpb24uc2V0WFlaKCBpZHgsIHYxLngsIHYxLnksIHYxLnogKTtcclxuXHJcbiAgICAgICAgICAgIGlkeCA9IGlkeCArIDE7XHJcblxyXG4gICAgICAgICAgICBwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjIueCwgdjIueSwgdjIueiApO1xyXG5cclxuICAgICAgICAgICAgaWR4ID0gaWR4ICsgMTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH1cclxuXHJcbn0oKSApO1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvR3JpZEhlbHBlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuR3JpZEhlbHBlciA9IGZ1bmN0aW9uICggc2l6ZSwgc3RlcCApIHtcclxuXHJcbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuICAgIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLlZlcnRleENvbG9ycyB9ICk7XHJcblxyXG4gICAgdGhpcy5jb2xvcjEgPSBuZXcgVEhSRUUuQ29sb3IoIDB4NDQ0NDQ0ICk7XHJcbiAgICB0aGlzLmNvbG9yMiA9IG5ldyBUSFJFRS5Db2xvciggMHg4ODg4ODggKTtcclxuXHJcbiAgICBmb3IgKCB2YXIgaSA9IC0gc2l6ZTsgaSA8PSBzaXplOyBpICs9IHN0ZXAgKSB7XHJcblxyXG4gICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goXHJcbiAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCAtIHNpemUsIDAsIGkgKSwgbmV3IFRIUkVFLlZlY3RvcjMoIHNpemUsIDAsIGkgKSxcclxuICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoIGksIDAsIC0gc2l6ZSApLCBuZXcgVEhSRUUuVmVjdG9yMyggaSwgMCwgc2l6ZSApXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgdmFyIGNvbG9yID0gaSA9PT0gMCA/IHRoaXMuY29sb3IxIDogdGhpcy5jb2xvcjI7XHJcblxyXG4gICAgICAgIGdlb21ldHJ5LmNvbG9ycy5wdXNoKCBjb2xvciwgY29sb3IsIGNvbG9yLCBjb2xvciApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuR3JpZEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XHJcblRIUkVFLkdyaWRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuR3JpZEhlbHBlcjtcclxuXHJcblRIUkVFLkdyaWRIZWxwZXIucHJvdG90eXBlLnNldENvbG9ycyA9IGZ1bmN0aW9uKCBjb2xvckNlbnRlckxpbmUsIGNvbG9yR3JpZCApIHtcclxuXHJcbiAgICB0aGlzLmNvbG9yMS5zZXQoIGNvbG9yQ2VudGVyTGluZSApO1xyXG4gICAgdGhpcy5jb2xvcjIuc2V0KCBjb2xvckdyaWQgKTtcclxuXHJcbiAgICB0aGlzLmdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0hlbWlzcGhlcmVMaWdodEhlbHBlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyID0gZnVuY3Rpb24gKCBsaWdodCwgc3BoZXJlU2l6ZSApIHtcclxuXHJcbiAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy5saWdodCA9IGxpZ2h0O1xyXG4gICAgdGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xyXG5cclxuICAgIHRoaXMubWF0cml4ID0gbGlnaHQubWF0cml4V29ybGQ7XHJcbiAgICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLmNvbG9ycyA9IFsgbmV3IFRIUkVFLkNvbG9yKCksIG5ldyBUSFJFRS5Db2xvcigpIF07XHJcblxyXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KCBzcGhlcmVTaXplLCA0LCAyICk7XHJcbiAgICBnZW9tZXRyeS5yb3RhdGVYKCAtIE1hdGguUEkgLyAyICk7XHJcblxyXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IDg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgZ2VvbWV0cnkuZmFjZXNbIGkgXS5jb2xvciA9IHRoaXMuY29sb3JzWyBpIDwgNCA/IDAgOiAxIF07XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLkZhY2VDb2xvcnMsIHdpcmVmcmFtZTogdHJ1ZSB9ICk7XHJcblxyXG4gICAgdGhpcy5saWdodFNwaGVyZSA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuICAgIHRoaXMuYWRkKCB0aGlzLmxpZ2h0U3BoZXJlICk7XHJcblxyXG4gICAgdGhpcy51cGRhdGUoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5IZW1pc3BoZXJlTGlnaHRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5IZW1pc3BoZXJlTGlnaHRIZWxwZXI7XHJcblxyXG5USFJFRS5IZW1pc3BoZXJlTGlnaHRIZWxwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdGhpcy5saWdodFNwaGVyZS5nZW9tZXRyeS5kaXNwb3NlKCk7XHJcbiAgICB0aGlzLmxpZ2h0U3BoZXJlLm1hdGVyaWFsLmRpc3Bvc2UoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5IZW1pc3BoZXJlTGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0aGlzLmNvbG9yc1sgMCBdLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcclxuICAgICAgICB0aGlzLmNvbG9yc1sgMSBdLmNvcHkoIHRoaXMubGlnaHQuZ3JvdW5kQ29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcclxuXHJcbiAgICAgICAgdGhpcy5saWdodFNwaGVyZS5sb29rQXQoIHZlY3Rvci5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKS5uZWdhdGUoKSApO1xyXG4gICAgICAgIHRoaXMubGlnaHRTcGhlcmUuZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG4gICAgfVxyXG5cclxufSgpO1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvUG9pbnRMaWdodEhlbHBlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuUG9pbnRMaWdodEhlbHBlciA9IGZ1bmN0aW9uICggbGlnaHQsIHNwaGVyZVNpemUgKSB7XHJcblxyXG4gICAgdGhpcy5saWdodCA9IGxpZ2h0O1xyXG4gICAgdGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xyXG5cclxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSggc3BoZXJlU2l6ZSwgNCwgMiApO1xyXG4gICAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IHdpcmVmcmFtZTogdHJ1ZSwgZm9nOiBmYWxzZSB9ICk7XHJcbiAgICBtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XHJcblxyXG4gICAgVEhSRUUuTWVzaC5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcbiAgICB0aGlzLm1hdHJpeCA9IHRoaXMubGlnaHQubWF0cml4V29ybGQ7XHJcbiAgICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcbiAgICAvKlxyXG4gICAgIHZhciBkaXN0YW5jZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkoIDEsIDIgKTtcclxuICAgICB2YXIgZGlzdGFuY2VNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogaGV4Q29sb3IsIGZvZzogZmFsc2UsIHdpcmVmcmFtZTogdHJ1ZSwgb3BhY2l0eTogMC4xLCB0cmFuc3BhcmVudDogdHJ1ZSB9ICk7XHJcblxyXG4gICAgIHRoaXMubGlnaHRTcGhlcmUgPSBuZXcgVEhSRUUuTWVzaCggYnVsYkdlb21ldHJ5LCBidWxiTWF0ZXJpYWwgKTtcclxuICAgICB0aGlzLmxpZ2h0RGlzdGFuY2UgPSBuZXcgVEhSRUUuTWVzaCggZGlzdGFuY2VHZW9tZXRyeSwgZGlzdGFuY2VNYXRlcmlhbCApO1xyXG5cclxuICAgICB2YXIgZCA9IGxpZ2h0LmRpc3RhbmNlO1xyXG5cclxuICAgICBpZiAoIGQgPT09IDAuMCApIHtcclxuXHJcbiAgICAgdGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSBmYWxzZTtcclxuXHJcbiAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgdGhpcy5saWdodERpc3RhbmNlLnNjYWxlLnNldCggZCwgZCwgZCApO1xyXG5cclxuICAgICB9XHJcblxyXG4gICAgIHRoaXMuYWRkKCB0aGlzLmxpZ2h0RGlzdGFuY2UgKTtcclxuICAgICAqL1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBvaW50TGlnaHRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWVzaC5wcm90b3R5cGUgKTtcclxuVEhSRUUuUG9pbnRMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Qb2ludExpZ2h0SGVscGVyO1xyXG5cclxuVEhSRUUuUG9pbnRMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcclxuICAgIHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBvaW50TGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB0aGlzLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcclxuXHJcbiAgICAvKlxyXG4gICAgIHZhciBkID0gdGhpcy5saWdodC5kaXN0YW5jZTtcclxuXHJcbiAgICAgaWYgKCBkID09PSAwLjAgKSB7XHJcblxyXG4gICAgIHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gZmFsc2U7XHJcblxyXG4gICAgIH0gZWxzZSB7XHJcblxyXG4gICAgIHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gdHJ1ZTtcclxuICAgICB0aGlzLmxpZ2h0RGlzdGFuY2Uuc2NhbGUuc2V0KCBkLCBkLCBkICk7XHJcblxyXG4gICAgIH1cclxuICAgICAqL1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL1NrZWxldG9uSGVscGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBTZWFuIEdyaWZmaW4gLyBodHRwOi8vdHdpdHRlci5jb20vc2dyaWZcclxuICogQGF1dGhvciBNaWNoYWVsIEd1ZXJyZXJvIC8gaHR0cDovL3JlYWxpdHltZWx0ZG93bi5jb21cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXHJcbiAqL1xyXG5cclxuVEhSRUUuU2tlbGV0b25IZWxwZXIgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcbiAgICB0aGlzLmJvbmVzID0gdGhpcy5nZXRCb25lTGlzdCggb2JqZWN0ICk7XHJcblxyXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcblxyXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5ib25lcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIHZhciBib25lID0gdGhpcy5ib25lc1sgaSBdO1xyXG5cclxuICAgICAgICBpZiAoIGJvbmUucGFyZW50IGluc3RhbmNlb2YgVEhSRUUuQm9uZSApIHtcclxuXHJcbiAgICAgICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCkgKTtcclxuICAgICAgICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoKSApO1xyXG4gICAgICAgICAgICBnZW9tZXRyeS5jb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCAwLCAwLCAxICkgKTtcclxuICAgICAgICAgICAgZ2VvbWV0cnkuY29sb3JzLnB1c2goIG5ldyBUSFJFRS5Db2xvciggMCwgMSwgMCApICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZ2VvbWV0cnkuZHluYW1pYyA9IHRydWU7XHJcblxyXG4gICAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogVEhSRUUuVmVydGV4Q29sb3JzLCBkZXB0aFRlc3Q6IGZhbHNlLCBkZXB0aFdyaXRlOiBmYWxzZSwgdHJhbnNwYXJlbnQ6IHRydWUgfSApO1xyXG5cclxuICAgIFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcbiAgICB0aGlzLnJvb3QgPSBvYmplY3Q7XHJcblxyXG4gICAgdGhpcy5tYXRyaXggPSBvYmplY3QubWF0cml4V29ybGQ7XHJcbiAgICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG5cclxufTtcclxuXHJcblxyXG5USFJFRS5Ta2VsZXRvbkhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XHJcblRIUkVFLlNrZWxldG9uSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNrZWxldG9uSGVscGVyO1xyXG5cclxuVEhSRUUuU2tlbGV0b25IZWxwZXIucHJvdG90eXBlLmdldEJvbmVMaXN0ID0gZnVuY3Rpb24oIG9iamVjdCApIHtcclxuXHJcbiAgICB2YXIgYm9uZUxpc3QgPSBbXTtcclxuXHJcbiAgICBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkJvbmUgKSB7XHJcblxyXG4gICAgICAgIGJvbmVMaXN0LnB1c2goIG9iamVjdCApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBvYmplY3QuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xyXG5cclxuICAgICAgICBib25lTGlzdC5wdXNoLmFwcGx5KCBib25lTGlzdCwgdGhpcy5nZXRCb25lTGlzdCggb2JqZWN0LmNoaWxkcmVuWyBpIF0gKSApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYm9uZUxpc3Q7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU2tlbGV0b25IZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xyXG5cclxuICAgIHZhciBtYXRyaXhXb3JsZEludiA9IG5ldyBUSFJFRS5NYXRyaXg0KCkuZ2V0SW52ZXJzZSggdGhpcy5yb290Lm1hdHJpeFdvcmxkICk7XHJcblxyXG4gICAgdmFyIGJvbmVNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuICAgIHZhciBqID0gMDtcclxuXHJcbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmJvbmVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgdmFyIGJvbmUgPSB0aGlzLmJvbmVzWyBpIF07XHJcblxyXG4gICAgICAgIGlmICggYm9uZS5wYXJlbnQgaW5zdGFuY2VvZiBUSFJFRS5Cb25lICkge1xyXG5cclxuICAgICAgICAgICAgYm9uZU1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXhXb3JsZEludiwgYm9uZS5tYXRyaXhXb3JsZCApO1xyXG4gICAgICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlc1sgaiBdLnNldEZyb21NYXRyaXhQb3NpdGlvbiggYm9uZU1hdHJpeCApO1xyXG5cclxuICAgICAgICAgICAgYm9uZU1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXhXb3JsZEludiwgYm9uZS5wYXJlbnQubWF0cml4V29ybGQgKTtcclxuICAgICAgICAgICAgZ2VvbWV0cnkudmVydGljZXNbIGogKyAxIF0uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBib25lTWF0cml4ICk7XHJcblxyXG4gICAgICAgICAgICBqICs9IDI7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHJcbiAgICBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9TcG90TGlnaHRIZWxwZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICovXHJcblxyXG5USFJFRS5TcG90TGlnaHRIZWxwZXIgPSBmdW5jdGlvbiAoIGxpZ2h0ICkge1xyXG5cclxuICAgIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICB0aGlzLmxpZ2h0ID0gbGlnaHQ7XHJcbiAgICB0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblxyXG4gICAgdGhpcy5tYXRyaXggPSBsaWdodC5tYXRyaXhXb3JsZDtcclxuICAgIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5DeWxpbmRlckdlb21ldHJ5KCAwLCAxLCAxLCA4LCAxLCB0cnVlICk7XHJcblxyXG4gICAgZ2VvbWV0cnkudHJhbnNsYXRlKCAwLCAtIDAuNSwgMCApO1xyXG4gICAgZ2VvbWV0cnkucm90YXRlWCggLSBNYXRoLlBJIC8gMiApO1xyXG5cclxuICAgIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyB3aXJlZnJhbWU6IHRydWUsIGZvZzogZmFsc2UgfSApO1xyXG5cclxuICAgIHRoaXMuY29uZSA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuICAgIHRoaXMuYWRkKCB0aGlzLmNvbmUgKTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuU3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwb3RMaWdodEhlbHBlcjtcclxuXHJcblRIUkVFLlNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB0aGlzLmNvbmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG4gICAgdGhpcy5jb25lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TcG90TGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgIHZhciB2ZWN0b3IyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgY29uZUxlbmd0aCA9IHRoaXMubGlnaHQuZGlzdGFuY2UgPyB0aGlzLmxpZ2h0LmRpc3RhbmNlIDogMTAwMDA7XHJcbiAgICAgICAgdmFyIGNvbmVXaWR0aCA9IGNvbmVMZW5ndGggKiBNYXRoLnRhbiggdGhpcy5saWdodC5hbmdsZSApO1xyXG5cclxuICAgICAgICB0aGlzLmNvbmUuc2NhbGUuc2V0KCBjb25lV2lkdGgsIGNvbmVXaWR0aCwgY29uZUxlbmd0aCApO1xyXG5cclxuICAgICAgICB2ZWN0b3Iuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkICk7XHJcbiAgICAgICAgdmVjdG9yMi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG4gICAgICAgIHRoaXMuY29uZS5sb29rQXQoIHZlY3RvcjIuc3ViKCB2ZWN0b3IgKSApO1xyXG5cclxuICAgICAgICB0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xyXG5cclxuICAgIH07XHJcblxyXG59KCk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9WZXJ0ZXhOb3JtYWxzSGVscGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqL1xyXG5cclxuVEhSRUUuVmVydGV4Tm9ybWFsc0hlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0LCBzaXplLCBoZXgsIGxpbmV3aWR0aCApIHtcclxuXHJcbiAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuXHJcbiAgICB0aGlzLnNpemUgPSAoIHNpemUgIT09IHVuZGVmaW5lZCApID8gc2l6ZSA6IDE7XHJcblxyXG4gICAgdmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHhmZjAwMDA7XHJcblxyXG4gICAgdmFyIHdpZHRoID0gKCBsaW5ld2lkdGggIT09IHVuZGVmaW5lZCApID8gbGluZXdpZHRoIDogMTtcclxuXHJcbiAgICAvL1xyXG5cclxuICAgIHZhciBuTm9ybWFscyA9IDA7XHJcblxyXG4gICAgdmFyIG9iakdlb21ldHJ5ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnk7XHJcblxyXG4gICAgaWYgKCBvYmpHZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xyXG5cclxuICAgICAgICBuTm9ybWFscyA9IG9iakdlb21ldHJ5LmZhY2VzLmxlbmd0aCAqIDM7XHJcblxyXG4gICAgfSBlbHNlIGlmICggb2JqR2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcbiAgICAgICAgbk5vcm1hbHMgPSBvYmpHZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbC5jb3VudFxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvL1xyXG5cclxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xyXG5cclxuICAgIHZhciBwb3NpdGlvbnMgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggbk5vcm1hbHMgKiAyICogMywgMyApO1xyXG5cclxuICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zaXRpb25zICk7XHJcblxyXG4gICAgVEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yLCBsaW5ld2lkdGg6IHdpZHRoIH0gKSApO1xyXG5cclxuICAgIC8vXHJcblxyXG4gICAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy51cGRhdGUoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcclxuVEhSRUUuVmVydGV4Tm9ybWFsc0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyO1xyXG5cclxuVEhSRUUuVmVydGV4Tm9ybWFsc0hlbHBlci5wcm90b3R5cGUudXBkYXRlID0gKCBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgIHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICB2YXIgbm9ybWFsTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xyXG5cclxuICAgICAgICB2YXIga2V5cyA9IFsgJ2EnLCAnYicsICdjJyBdO1xyXG5cclxuICAgICAgICB0aGlzLm9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xyXG5cclxuICAgICAgICBub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCB0aGlzLm9iamVjdC5tYXRyaXhXb3JsZCApO1xyXG5cclxuICAgICAgICB2YXIgbWF0cml4V29ybGQgPSB0aGlzLm9iamVjdC5tYXRyaXhXb3JsZDtcclxuXHJcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cclxuICAgICAgICAvL1xyXG5cclxuICAgICAgICB2YXIgb2JqR2VvbWV0cnkgPSB0aGlzLm9iamVjdC5nZW9tZXRyeTtcclxuXHJcbiAgICAgICAgaWYgKCBvYmpHZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gb2JqR2VvbWV0cnkudmVydGljZXM7XHJcblxyXG4gICAgICAgICAgICB2YXIgZmFjZXMgPSBvYmpHZW9tZXRyeS5mYWNlcztcclxuXHJcbiAgICAgICAgICAgIHZhciBpZHggPSAwO1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZmFjZSA9IGZhY2VzWyBpIF07XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnRleCA9IHZlcnRpY2VzWyBmYWNlWyBrZXlzWyBqIF0gXSBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbm9ybWFsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzWyBqIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHYxLmNvcHkoIHZlcnRleCApLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdjIuY29weSggbm9ybWFsICkuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggdGhpcy5zaXplICkuYWRkKCB2MSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjEueCwgdjEueSwgdjEueiApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZHggPSBpZHggKyAxO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjIueCwgdjIueSwgdjIueiApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZHggPSBpZHggKyAxO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICggb2JqR2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBvYmpQb3MgPSBvYmpHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cclxuICAgICAgICAgICAgdmFyIG9iak5vcm0gPSBvYmpHZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbDtcclxuXHJcbiAgICAgICAgICAgIHZhciBpZHggPSAwO1xyXG5cclxuICAgICAgICAgICAgLy8gZm9yIHNpbXBsaWNpdHksIGlnbm9yZSBpbmRleCBhbmQgZHJhd2NhbGxzLCBhbmQgcmVuZGVyIGV2ZXJ5IG5vcm1hbFxyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IG9ialBvcy5jb3VudDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHYxLnNldCggb2JqUG9zLmdldFgoIGogKSwgb2JqUG9zLmdldFkoIGogKSwgb2JqUG9zLmdldFooIGogKSApLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2Mi5zZXQoIG9iak5vcm0uZ2V0WCggaiApLCBvYmpOb3JtLmdldFkoIGogKSwgb2JqTm9ybS5nZXRaKCBqICkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2Mi5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCB0aGlzLnNpemUgKS5hZGQoIHYxICk7XHJcblxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb24uc2V0WFlaKCBpZHgsIHYxLngsIHYxLnksIHYxLnogKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZHggPSBpZHggKyAxO1xyXG5cclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLnNldFhZWiggaWR4LCB2Mi54LCB2Mi55LCB2Mi56ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWR4ID0gaWR4ICsgMTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH1cclxuXHJcbn0oKSApO1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvV2lyZWZyYW1lSGVscGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5XaXJlZnJhbWVIZWxwZXIgPSBmdW5jdGlvbiAoIG9iamVjdCwgaGV4ICkge1xyXG5cclxuICAgIHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ZmZmZmZmO1xyXG5cclxuICAgIFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBuZXcgVEhSRUUuV2lyZWZyYW1lR2VvbWV0cnkoIG9iamVjdC5nZW9tZXRyeSApLCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSApO1xyXG5cclxuICAgIHRoaXMubWF0cml4ID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xyXG4gICAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuV2lyZWZyYW1lSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcclxuVEhSRUUuV2lyZWZyYW1lSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLldpcmVmcmFtZUhlbHBlcjtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9vYmplY3RzL0ltbWVkaWF0ZVJlbmRlck9iamVjdC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0ID0gZnVuY3Rpb24gKCBtYXRlcmlhbCApIHtcclxuXHJcbiAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG4gICAgdGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsO1xyXG4gICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHJlbmRlckNhbGxiYWNrICkge307XHJcblxyXG59O1xyXG5cclxuVEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5USFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL29iamVjdHMvTW9ycGhCbGVuZE1lc2guanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLk1vcnBoQmxlbmRNZXNoID0gZnVuY3Rpb24oIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcclxuXHJcbiAgICBUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxuICAgIHRoaXMuYW5pbWF0aW9uc01hcCA9IHt9O1xyXG4gICAgdGhpcy5hbmltYXRpb25zTGlzdCA9IFtdO1xyXG5cclxuICAgIC8vIHByZXBhcmUgZGVmYXVsdCBhbmltYXRpb25cclxuICAgIC8vIChhbGwgZnJhbWVzIHBsYXllZCB0b2dldGhlciBpbiAxIHNlY29uZClcclxuXHJcbiAgICB2YXIgbnVtRnJhbWVzID0gdGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoO1xyXG5cclxuICAgIHZhciBuYW1lID0gXCJfX2RlZmF1bHRcIjtcclxuXHJcbiAgICB2YXIgc3RhcnRGcmFtZSA9IDA7XHJcbiAgICB2YXIgZW5kRnJhbWUgPSBudW1GcmFtZXMgLSAxO1xyXG5cclxuICAgIHZhciBmcHMgPSBudW1GcmFtZXMgLyAxO1xyXG5cclxuICAgIHRoaXMuY3JlYXRlQW5pbWF0aW9uKCBuYW1lLCBzdGFydEZyYW1lLCBlbmRGcmFtZSwgZnBzICk7XHJcbiAgICB0aGlzLnNldEFuaW1hdGlvbldlaWdodCggbmFtZSwgMSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1lc2gucHJvdG90eXBlICk7XHJcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk1vcnBoQmxlbmRNZXNoO1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLmNyZWF0ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uICggbmFtZSwgc3RhcnQsIGVuZCwgZnBzICkge1xyXG5cclxuICAgIHZhciBhbmltYXRpb24gPSB7XHJcblxyXG4gICAgICAgIHN0YXJ0OiBzdGFydCxcclxuICAgICAgICBlbmQ6IGVuZCxcclxuXHJcbiAgICAgICAgbGVuZ3RoOiBlbmQgLSBzdGFydCArIDEsXHJcblxyXG4gICAgICAgIGZwczogZnBzLFxyXG4gICAgICAgIGR1cmF0aW9uOiAoIGVuZCAtIHN0YXJ0ICkgLyBmcHMsXHJcblxyXG4gICAgICAgIGxhc3RGcmFtZTogMCxcclxuICAgICAgICBjdXJyZW50RnJhbWU6IDAsXHJcblxyXG4gICAgICAgIGFjdGl2ZTogZmFsc2UsXHJcblxyXG4gICAgICAgIHRpbWU6IDAsXHJcbiAgICAgICAgZGlyZWN0aW9uOiAxLFxyXG4gICAgICAgIHdlaWdodDogMSxcclxuXHJcbiAgICAgICAgZGlyZWN0aW9uQmFja3dhcmRzOiBmYWxzZSxcclxuICAgICAgICBtaXJyb3JlZExvb3A6IGZhbHNlXHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXSA9IGFuaW1hdGlvbjtcclxuICAgIHRoaXMuYW5pbWF0aW9uc0xpc3QucHVzaCggYW5pbWF0aW9uICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLmF1dG9DcmVhdGVBbmltYXRpb25zID0gZnVuY3Rpb24gKCBmcHMgKSB7XHJcblxyXG4gICAgdmFyIHBhdHRlcm4gPSAvKFthLXpdKylfPyhcXGQrKS87XHJcblxyXG4gICAgdmFyIGZpcnN0QW5pbWF0aW9uLCBmcmFtZVJhbmdlcyA9IHt9O1xyXG5cclxuICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XHJcblxyXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgdmFyIG1vcnBoID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF07XHJcbiAgICAgICAgdmFyIGNodW5rcyA9IG1vcnBoLm5hbWUubWF0Y2goIHBhdHRlcm4gKTtcclxuXHJcbiAgICAgICAgaWYgKCBjaHVua3MgJiYgY2h1bmtzLmxlbmd0aCA+IDEgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbmFtZSA9IGNodW5rc1sgMSBdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCAhIGZyYW1lUmFuZ2VzWyBuYW1lIF0gKSBmcmFtZVJhbmdlc1sgbmFtZSBdID0geyBzdGFydDogSW5maW5pdHksIGVuZDogLSBJbmZpbml0eSB9O1xyXG5cclxuICAgICAgICAgICAgdmFyIHJhbmdlID0gZnJhbWVSYW5nZXNbIG5hbWUgXTtcclxuXHJcbiAgICAgICAgICAgIGlmICggaSA8IHJhbmdlLnN0YXJ0ICkgcmFuZ2Uuc3RhcnQgPSBpO1xyXG4gICAgICAgICAgICBpZiAoIGkgPiByYW5nZS5lbmQgKSByYW5nZS5lbmQgPSBpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCAhIGZpcnN0QW5pbWF0aW9uICkgZmlyc3RBbmltYXRpb24gPSBuYW1lO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZvciAoIHZhciBuYW1lIGluIGZyYW1lUmFuZ2VzICkge1xyXG5cclxuICAgICAgICB2YXIgcmFuZ2UgPSBmcmFtZVJhbmdlc1sgbmFtZSBdO1xyXG4gICAgICAgIHRoaXMuY3JlYXRlQW5pbWF0aW9uKCBuYW1lLCByYW5nZS5zdGFydCwgcmFuZ2UuZW5kLCBmcHMgKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5maXJzdEFuaW1hdGlvbiA9IGZpcnN0QW5pbWF0aW9uO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25EaXJlY3Rpb25Gb3J3YXJkID0gZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcbiAgICBpZiAoIGFuaW1hdGlvbiApIHtcclxuXHJcbiAgICAgICAgYW5pbWF0aW9uLmRpcmVjdGlvbiA9IDE7XHJcbiAgICAgICAgYW5pbWF0aW9uLmRpcmVjdGlvbkJhY2t3YXJkcyA9IGZhbHNlO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uRGlyZWN0aW9uQmFja3dhcmQgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG4gICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuICAgIGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuICAgICAgICBhbmltYXRpb24uZGlyZWN0aW9uID0gLSAxO1xyXG4gICAgICAgIGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSB0cnVlO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uRlBTID0gZnVuY3Rpb24gKCBuYW1lLCBmcHMgKSB7XHJcblxyXG4gICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuICAgIGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuICAgICAgICBhbmltYXRpb24uZnBzID0gZnBzO1xyXG4gICAgICAgIGFuaW1hdGlvbi5kdXJhdGlvbiA9ICggYW5pbWF0aW9uLmVuZCAtIGFuaW1hdGlvbi5zdGFydCApIC8gYW5pbWF0aW9uLmZwcztcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkR1cmF0aW9uID0gZnVuY3Rpb24gKCBuYW1lLCBkdXJhdGlvbiApIHtcclxuXHJcbiAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG4gICAgaWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG4gICAgICAgIGFuaW1hdGlvbi5kdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG4gICAgICAgIGFuaW1hdGlvbi5mcHMgPSAoIGFuaW1hdGlvbi5lbmQgLSBhbmltYXRpb24uc3RhcnQgKSAvIGFuaW1hdGlvbi5kdXJhdGlvbjtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbldlaWdodCA9IGZ1bmN0aW9uICggbmFtZSwgd2VpZ2h0ICkge1xyXG5cclxuICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcbiAgICBpZiAoIGFuaW1hdGlvbiApIHtcclxuXHJcbiAgICAgICAgYW5pbWF0aW9uLndlaWdodCA9IHdlaWdodDtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvblRpbWUgPSBmdW5jdGlvbiAoIG5hbWUsIHRpbWUgKSB7XHJcblxyXG4gICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuICAgIGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuICAgICAgICBhbmltYXRpb24udGltZSA9IHRpbWU7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5nZXRBbmltYXRpb25UaW1lID0gZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuICAgIHZhciB0aW1lID0gMDtcclxuXHJcbiAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG4gICAgaWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG4gICAgICAgIHRpbWUgPSBhbmltYXRpb24udGltZTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRpbWU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLmdldEFuaW1hdGlvbkR1cmF0aW9uID0gZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuICAgIHZhciBkdXJhdGlvbiA9IC0gMTtcclxuXHJcbiAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG4gICAgaWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG4gICAgICAgIGR1cmF0aW9uID0gYW5pbWF0aW9uLmR1cmF0aW9uO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZHVyYXRpb247XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnBsYXlBbmltYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG4gICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuICAgIGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuICAgICAgICBhbmltYXRpb24udGltZSA9IDA7XHJcbiAgICAgICAgYW5pbWF0aW9uLmFjdGl2ZSA9IHRydWU7XHJcblxyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCBcIlRIUkVFLk1vcnBoQmxlbmRNZXNoOiBhbmltYXRpb25bXCIgKyBuYW1lICsgXCJdIHVuZGVmaW5lZCBpbiAucGxheUFuaW1hdGlvbigpXCIgKTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnN0b3BBbmltYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG4gICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuICAgIGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuICAgICAgICBhbmltYXRpb24uYWN0aXZlID0gZmFsc2U7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoIGRlbHRhICkge1xyXG5cclxuICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB0aGlzLmFuaW1hdGlvbnNMaXN0Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuICAgICAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTGlzdFsgaSBdO1xyXG5cclxuICAgICAgICBpZiAoICEgYW5pbWF0aW9uLmFjdGl2ZSApIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICB2YXIgZnJhbWVUaW1lID0gYW5pbWF0aW9uLmR1cmF0aW9uIC8gYW5pbWF0aW9uLmxlbmd0aDtcclxuXHJcbiAgICAgICAgYW5pbWF0aW9uLnRpbWUgKz0gYW5pbWF0aW9uLmRpcmVjdGlvbiAqIGRlbHRhO1xyXG5cclxuICAgICAgICBpZiAoIGFuaW1hdGlvbi5taXJyb3JlZExvb3AgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGFuaW1hdGlvbi50aW1lID4gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IGFuaW1hdGlvbi50aW1lIDwgMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb24uZGlyZWN0aW9uICo9IC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGFuaW1hdGlvbi50aW1lID4gYW5pbWF0aW9uLmR1cmF0aW9uICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24udGltZSA9IGFuaW1hdGlvbi5kdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24uZGlyZWN0aW9uQmFja3dhcmRzID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBhbmltYXRpb24udGltZSA8IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi50aW1lID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24uZGlyZWN0aW9uQmFja3dhcmRzID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgYW5pbWF0aW9uLnRpbWUgPSBhbmltYXRpb24udGltZSAlIGFuaW1hdGlvbi5kdXJhdGlvbjtcclxuXHJcbiAgICAgICAgICAgIGlmICggYW5pbWF0aW9uLnRpbWUgPCAwICkgYW5pbWF0aW9uLnRpbWUgKz0gYW5pbWF0aW9uLmR1cmF0aW9uO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBrZXlmcmFtZSA9IGFuaW1hdGlvbi5zdGFydCArIFRIUkVFLk1hdGguY2xhbXAoIE1hdGguZmxvb3IoIGFuaW1hdGlvbi50aW1lIC8gZnJhbWVUaW1lICksIDAsIGFuaW1hdGlvbi5sZW5ndGggLSAxICk7XHJcbiAgICAgICAgdmFyIHdlaWdodCA9IGFuaW1hdGlvbi53ZWlnaHQ7XHJcblxyXG4gICAgICAgIGlmICgga2V5ZnJhbWUgIT09IGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgYW5pbWF0aW9uLmxhc3RGcmFtZSBdID0gMDtcclxuICAgICAgICAgICAgdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgXSA9IDEgKiB3ZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sga2V5ZnJhbWUgXSA9IDA7XHJcblxyXG4gICAgICAgICAgICBhbmltYXRpb24ubGFzdEZyYW1lID0gYW5pbWF0aW9uLmN1cnJlbnRGcmFtZTtcclxuICAgICAgICAgICAgYW5pbWF0aW9uLmN1cnJlbnRGcmFtZSA9IGtleWZyYW1lO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBtaXggPSAoIGFuaW1hdGlvbi50aW1lICUgZnJhbWVUaW1lICkgLyBmcmFtZVRpbWU7XHJcblxyXG4gICAgICAgIGlmICggYW5pbWF0aW9uLmRpcmVjdGlvbkJhY2t3YXJkcyApIG1peCA9IDEgLSBtaXg7XHJcblxyXG4gICAgICAgIGlmICggYW5pbWF0aW9uLmN1cnJlbnRGcmFtZSAhPT0gYW5pbWF0aW9uLmxhc3RGcmFtZSApIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24uY3VycmVudEZyYW1lIF0gPSBtaXggKiB3ZWlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24ubGFzdEZyYW1lIF0gPSAoIDEgLSBtaXggKSAqIHdlaWdodDtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24uY3VycmVudEZyYW1lIF0gPSB3ZWlnaHQ7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKlxyXG4gKiBGb3IgY3JlYXRpbmcgM0QgdGV4dCBnZW9tZXRyeSBpbiB0aHJlZS5qc1xyXG4gKlxyXG4gKiBUZXh0ID0gM0QgVGV4dFxyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKiAgc2l6ZTogXHRcdFx0PGZsb2F0PiwgXHQvLyBzaXplIG9mIHRoZSB0ZXh0XHJcbiAqICBoZWlnaHQ6IFx0XHQ8ZmxvYXQ+LCBcdC8vIHRoaWNrbmVzcyB0byBleHRydWRlIHRleHRcclxuICogIGN1cnZlU2VnbWVudHM6IFx0PGludD4sXHRcdC8vIG51bWJlciBvZiBwb2ludHMgb24gdGhlIGN1cnZlc1xyXG4gKlxyXG4gKiAgZm9udDogXHRcdFx0PHN0cmluZz4sXHRcdC8vIGZvbnQgbmFtZVxyXG4gKiAgd2VpZ2h0OiBcdFx0PHN0cmluZz4sXHRcdC8vIGZvbnQgd2VpZ2h0IChub3JtYWwsIGJvbGQpXHJcbiAqICBzdHlsZTogXHRcdFx0PHN0cmluZz4sXHRcdC8vIGZvbnQgc3R5bGUgIChub3JtYWwsIGl0YWxpY3MpXHJcbiAqXHJcbiAqICBiZXZlbEVuYWJsZWQ6XHQ8Ym9vbD4sXHRcdFx0Ly8gdHVybiBvbiBiZXZlbFxyXG4gKiAgYmV2ZWxUaGlja25lc3M6IDxmbG9hdD4sIFx0XHQvLyBob3cgZGVlcCBpbnRvIHRleHQgYmV2ZWwgZ29lc1xyXG4gKiAgYmV2ZWxTaXplOlx0XHQ8ZmxvYXQ+LCBcdFx0Ly8gaG93IGZhciBmcm9tIHRleHQgb3V0bGluZSBpcyBiZXZlbFxyXG4gKiAgfVxyXG4gKlxyXG4gKi9cclxuXHJcbi8qXHRVc2FnZSBFeGFtcGxlc1xyXG5cclxuIC8vIFRleHRHZW9tZXRyeSB3cmFwcGVyXHJcblxyXG4gdmFyIHRleHQzZCA9IG5ldyBUZXh0R2VvbWV0cnkoIHRleHQsIG9wdGlvbnMgKTtcclxuXHJcbiAvLyBDb21wbGV0ZSBtYW5uZXJcclxuXHJcbiB2YXIgdGV4dFNoYXBlcyA9IFRIUkVFLkZvbnRVdGlscy5nZW5lcmF0ZVNoYXBlcyggdGV4dCwgb3B0aW9ucyApO1xyXG4gdmFyIHRleHQzZCA9IG5ldyBFeHRydWRlR2VvbWV0cnkoIHRleHRTaGFwZXMsIG9wdGlvbnMgKTtcclxuXHJcbiAqL1xyXG5cclxuVEhSRUUuVGV4dEdlb21ldHJ5ID0gZnVuY3Rpb24gKCB0ZXh0LCBwYXJhbWV0ZXJzICkge1xyXG5cclxuICAgIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xyXG5cclxuICAgIHZhciB0ZXh0U2hhcGVzID0gVEhSRUUuRm9udFV0aWxzLmdlbmVyYXRlU2hhcGVzKCB0ZXh0LCBwYXJhbWV0ZXJzICk7XHJcblxyXG4gICAgLy8gdHJhbnNsYXRlIHBhcmFtZXRlcnMgdG8gRXh0cnVkZUdlb21ldHJ5IEFQSVxyXG5cclxuICAgIHBhcmFtZXRlcnMuYW1vdW50ID0gcGFyYW1ldGVycy5oZWlnaHQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuaGVpZ2h0IDogNTA7XHJcblxyXG4gICAgLy8gZGVmYXVsdHNcclxuXHJcbiAgICBpZiAoIHBhcmFtZXRlcnMuYmV2ZWxUaGlja25lc3MgPT09IHVuZGVmaW5lZCApIHBhcmFtZXRlcnMuYmV2ZWxUaGlja25lc3MgPSAxMDtcclxuICAgIGlmICggcGFyYW1ldGVycy5iZXZlbFNpemUgPT09IHVuZGVmaW5lZCApIHBhcmFtZXRlcnMuYmV2ZWxTaXplID0gODtcclxuICAgIGlmICggcGFyYW1ldGVycy5iZXZlbEVuYWJsZWQgPT09IHVuZGVmaW5lZCApIHBhcmFtZXRlcnMuYmV2ZWxFbmFibGVkID0gZmFsc2U7XHJcblxyXG4gICAgVEhSRUUuRXh0cnVkZUdlb21ldHJ5LmNhbGwoIHRoaXMsIHRleHRTaGFwZXMsIHBhcmFtZXRlcnMgKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAnVGV4dEdlb21ldHJ5JztcclxuXHJcbn07XHJcblxyXG5USFJFRS5UZXh0R2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5UZXh0R2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuVGV4dEdlb21ldHJ5O1xyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICogRm9yIFRleHQgb3BlcmF0aW9ucyBpbiB0aHJlZS5qcyAoU2VlIFRleHRHZW9tZXRyeSlcclxuICpcclxuICogSXQgdXNlcyB0ZWNobmlxdWVzIHVzZWQgaW46XHJcbiAqXHJcbiAqXHRUcmlhbmd1bGF0aW9uIHBvcnRlZCBmcm9tIEFTM1xyXG4gKlx0XHRTaW1wbGUgUG9seWdvbiBUcmlhbmd1bGF0aW9uXHJcbiAqXHRcdGh0dHA6Ly9hY3Rpb25zbmlwcGV0LmNvbS8/cD0xNDYyXHJcbiAqXHJcbiAqIFx0QSBNZXRob2QgdG8gdHJpYW5ndWxhdGUgc2hhcGVzIHdpdGggaG9sZXNcclxuICpcdFx0aHR0cDovL3d3dy5zYWtyaS5uZXQvYmxvZy8yMDA5LzA2LzEyL2FuLWFwcHJvYWNoLXRvLXRyaWFuZ3VsYXRpbmctcG9seWdvbnMtd2l0aC1ob2xlcy9cclxuICpcclxuICovXHJcblxyXG5USFJFRS5Gb250VXRpbHMgPSB7XHJcblxyXG4gICAgZmFjZXM6IHt9LFxyXG5cclxuICAgIC8vIEp1c3QgZm9yIG5vdy4gZmFjZVt3ZWlnaHRdW3N0eWxlXVxyXG5cclxuICAgIGZhY2U6ICdoZWx2ZXRpa2VyJyxcclxuICAgIHdlaWdodDogJ25vcm1hbCcsXHJcbiAgICBzdHlsZTogJ25vcm1hbCcsXHJcbiAgICBzaXplOiAxNTAsXHJcbiAgICBkaXZpc2lvbnM6IDEwLFxyXG5cclxuICAgIGdldEZhY2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZhY2VzWyB0aGlzLmZhY2UudG9Mb3dlckNhc2UoKSBdWyB0aGlzLndlaWdodCBdWyB0aGlzLnN0eWxlIF07XHJcblxyXG4gICAgICAgIH0gY2F0Y2ggKCBlICkge1xyXG5cclxuICAgICAgICAgICAgdGhyb3cgXCJUaGUgZm9udCBcIiArIHRoaXMuZmFjZSArIFwiIHdpdGggXCIgKyB0aGlzLndlaWdodCArIFwiIHdlaWdodCBhbmQgXCIgKyB0aGlzLnN0eWxlICsgXCIgc3R5bGUgaXMgbWlzc2luZy5cIlxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBsb2FkRmFjZTogZnVuY3Rpb24gKCBkYXRhICkge1xyXG5cclxuICAgICAgICB2YXIgZmFtaWx5ID0gZGF0YS5mYW1pbHlOYW1lLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAgIHZhciBUaHJlZUZvbnQgPSB0aGlzO1xyXG5cclxuICAgICAgICBUaHJlZUZvbnQuZmFjZXNbIGZhbWlseSBdID0gVGhyZWVGb250LmZhY2VzWyBmYW1pbHkgXSB8fCB7fTtcclxuXHJcbiAgICAgICAgVGhyZWVGb250LmZhY2VzWyBmYW1pbHkgXVsgZGF0YS5jc3NGb250V2VpZ2h0IF0gPSBUaHJlZUZvbnQuZmFjZXNbIGZhbWlseSBdWyBkYXRhLmNzc0ZvbnRXZWlnaHQgXSB8fCB7fTtcclxuICAgICAgICBUaHJlZUZvbnQuZmFjZXNbIGZhbWlseSBdWyBkYXRhLmNzc0ZvbnRXZWlnaHQgXVsgZGF0YS5jc3NGb250U3R5bGUgXSA9IGRhdGE7XHJcblxyXG4gICAgICAgIFRocmVlRm9udC5mYWNlc1sgZmFtaWx5IF1bIGRhdGEuY3NzRm9udFdlaWdodCBdWyBkYXRhLmNzc0ZvbnRTdHlsZSBdID0gZGF0YTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBkcmF3VGV4dDogZnVuY3Rpb24gKCB0ZXh0ICkge1xyXG5cclxuICAgICAgICAvLyBSZW5kZXJUZXh0XHJcblxyXG4gICAgICAgIHZhciBpLFxyXG4gICAgICAgICAgICBmYWNlID0gdGhpcy5nZXRGYWNlKCksXHJcbiAgICAgICAgICAgIHNjYWxlID0gdGhpcy5zaXplIC8gZmFjZS5yZXNvbHV0aW9uLFxyXG4gICAgICAgICAgICBvZmZzZXQgPSAwLFxyXG4gICAgICAgICAgICBjaGFycyA9IFN0cmluZyggdGV4dCApLnNwbGl0KCAnJyApLFxyXG4gICAgICAgICAgICBsZW5ndGggPSBjaGFycy5sZW5ndGg7XHJcblxyXG4gICAgICAgIHZhciBmb250UGF0aHMgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgcGF0aCA9IG5ldyBUSFJFRS5QYXRoKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmV0ID0gdGhpcy5leHRyYWN0R2x5cGhQb2ludHMoIGNoYXJzWyBpIF0sIGZhY2UsIHNjYWxlLCBvZmZzZXQsIHBhdGggKTtcclxuICAgICAgICAgICAgb2Zmc2V0ICs9IHJldC5vZmZzZXQ7XHJcblxyXG4gICAgICAgICAgICBmb250UGF0aHMucHVzaCggcmV0LnBhdGggKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBnZXQgdGhlIHdpZHRoXHJcblxyXG4gICAgICAgIHZhciB3aWR0aCA9IG9mZnNldCAvIDI7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBmb3IgKCBwID0gMDsgcCA8IGFsbFB0cy5sZW5ndGg7IHArKyApIHtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFx0YWxsUHRzWyBwIF0ueCAtPSB3aWR0aDtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIH1cclxuXHJcbiAgICAgICAgLy92YXIgZXh0cmFjdCA9IHRoaXMuZXh0cmFjdFBvaW50cyggYWxsUHRzLCBjaGFyYWN0ZXJQdHMgKTtcclxuICAgICAgICAvL2V4dHJhY3QuY29udG91ciA9IGFsbFB0cztcclxuXHJcbiAgICAgICAgLy9leHRyYWN0LnBhdGhzID0gZm9udFBhdGhzO1xyXG4gICAgICAgIC8vZXh0cmFjdC5vZmZzZXQgPSB3aWR0aDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHsgcGF0aHM6IGZvbnRQYXRocywgb2Zmc2V0OiB3aWR0aCB9O1xyXG5cclxuICAgIH0sXHJcblxyXG5cclxuXHJcblxyXG4gICAgZXh0cmFjdEdseXBoUG9pbnRzOiBmdW5jdGlvbiAoIGMsIGZhY2UsIHNjYWxlLCBvZmZzZXQsIHBhdGggKSB7XHJcblxyXG4gICAgICAgIHZhciBwdHMgPSBbXTtcclxuXHJcbiAgICAgICAgdmFyIGIyID0gVEhSRUUuU2hhcGVVdGlscy5iMjtcclxuICAgICAgICB2YXIgYjMgPSBUSFJFRS5TaGFwZVV0aWxzLmIzO1xyXG5cclxuICAgICAgICB2YXIgaSwgaTIsIGRpdmlzaW9ucyxcclxuICAgICAgICAgICAgb3V0bGluZSwgYWN0aW9uLCBsZW5ndGgsXHJcbiAgICAgICAgICAgIHNjYWxlWCwgc2NhbGVZLFxyXG4gICAgICAgICAgICB4LCB5LCBjcHgsIGNweSwgY3B4MCwgY3B5MCwgY3B4MSwgY3B5MSwgY3B4MiwgY3B5MixcclxuICAgICAgICAgICAgbGFzdGUsXHJcbiAgICAgICAgICAgIGdseXBoID0gZmFjZS5nbHlwaHNbIGMgXSB8fCBmYWNlLmdseXBoc1sgJz8nIF07XHJcblxyXG4gICAgICAgIGlmICggISBnbHlwaCApIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKCBnbHlwaC5vICkge1xyXG5cclxuICAgICAgICAgICAgb3V0bGluZSA9IGdseXBoLl9jYWNoZWRPdXRsaW5lIHx8ICggZ2x5cGguX2NhY2hlZE91dGxpbmUgPSBnbHlwaC5vLnNwbGl0KCAnICcgKSApO1xyXG4gICAgICAgICAgICBsZW5ndGggPSBvdXRsaW5lLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIHNjYWxlWCA9IHNjYWxlO1xyXG4gICAgICAgICAgICBzY2FsZVkgPSBzY2FsZTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgbGVuZ3RoOyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSBvdXRsaW5lWyBpICsrIF07XHJcblxyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyggYWN0aW9uICk7XHJcblxyXG4gICAgICAgICAgICAgICAgc3dpdGNoICggYWN0aW9uICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtJzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgVG9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZVggKyBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZVk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLm1vdmVUbyggeCwgeSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMaW5lIFRvXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGVYICsgb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGVZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmxpbmVUbyggeCwgeSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncSc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBRdWFkcmF0aWNDdXJ2ZVRvXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggID0gb3V0bGluZVsgaSArKyBdICogc2NhbGVYICsgb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgID0gb3V0bGluZVsgaSArKyBdICogc2NhbGVZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHgxID0gb3V0bGluZVsgaSArKyBdICogc2NhbGVYICsgb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkxID0gb3V0bGluZVsgaSArKyBdICogc2NhbGVZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKCBjcHgxLCBjcHkxLCBjcHgsIGNweSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdGUgPSBwdHNbIHB0cy5sZW5ndGggLSAxIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGxhc3RlICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNweDAgPSBsYXN0ZS54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3B5MCA9IGxhc3RlLnk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggaTIgPSAxLCBkaXZpc2lvbnMgPSB0aGlzLmRpdmlzaW9uczsgaTIgPD0gZGl2aXNpb25zOyBpMiArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBpMiAvIGRpdmlzaW9ucztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiMiggdCwgY3B4MCwgY3B4MSwgY3B4ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYjIoIHQsIGNweTAsIGNweTEsIGNweSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdiJzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEN1YmljIEJlemllciBDdXJ2ZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlWCArIG9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4MSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlWCArIG9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B5MSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4MiA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlWCArIG9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B5MiA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlWTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYmV6aWVyQ3VydmVUbyggY3B4MSwgY3B5MSwgY3B4MiwgY3B5MiwgY3B4LCBjcHkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RlID0gcHRzWyBwdHMubGVuZ3RoIC0gMSBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBsYXN0ZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcHgwID0gbGFzdGUueDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNweTAgPSBsYXN0ZS55O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGkyID0gMSwgZGl2aXNpb25zID0gdGhpcy5kaXZpc2lvbnM7IGkyIDw9IGRpdmlzaW9uczsgaTIgKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gaTIgLyBkaXZpc2lvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYjMoIHQsIGNweDAsIGNweDEsIGNweDIsIGNweCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIzKCB0LCBjcHkwLCBjcHkxLCBjcHkyLCBjcHkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgICByZXR1cm4geyBvZmZzZXQ6IGdseXBoLmhhICogc2NhbGUsIHBhdGg6IHBhdGggfTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLkZvbnRVdGlscy5nZW5lcmF0ZVNoYXBlcyA9IGZ1bmN0aW9uICggdGV4dCwgcGFyYW1ldGVycyApIHtcclxuXHJcbiAgICAvLyBQYXJhbWV0ZXJzXHJcblxyXG4gICAgcGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XHJcblxyXG4gICAgdmFyIHNpemUgPSBwYXJhbWV0ZXJzLnNpemUgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuc2l6ZSA6IDEwMDtcclxuICAgIHZhciBjdXJ2ZVNlZ21lbnRzID0gcGFyYW1ldGVycy5jdXJ2ZVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmN1cnZlU2VnbWVudHMgOiA0O1xyXG5cclxuICAgIHZhciBmb250ID0gcGFyYW1ldGVycy5mb250ICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmZvbnQgOiAnaGVsdmV0aWtlcic7XHJcbiAgICB2YXIgd2VpZ2h0ID0gcGFyYW1ldGVycy53ZWlnaHQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMud2VpZ2h0IDogJ25vcm1hbCc7XHJcbiAgICB2YXIgc3R5bGUgPSBwYXJhbWV0ZXJzLnN0eWxlICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnN0eWxlIDogJ25vcm1hbCc7XHJcblxyXG4gICAgVEhSRUUuRm9udFV0aWxzLnNpemUgPSBzaXplO1xyXG4gICAgVEhSRUUuRm9udFV0aWxzLmRpdmlzaW9ucyA9IGN1cnZlU2VnbWVudHM7XHJcblxyXG4gICAgVEhSRUUuRm9udFV0aWxzLmZhY2UgPSBmb250O1xyXG4gICAgVEhSRUUuRm9udFV0aWxzLndlaWdodCA9IHdlaWdodDtcclxuICAgIFRIUkVFLkZvbnRVdGlscy5zdHlsZSA9IHN0eWxlO1xyXG5cclxuICAgIC8vIEdldCBhIEZvbnQgZGF0YSBqc29uIG9iamVjdFxyXG5cclxuICAgIHZhciBkYXRhID0gVEhSRUUuRm9udFV0aWxzLmRyYXdUZXh0KCB0ZXh0ICk7XHJcblxyXG4gICAgdmFyIHBhdGhzID0gZGF0YS5wYXRocztcclxuICAgIHZhciBzaGFwZXMgPSBbXTtcclxuXHJcbiAgICBmb3IgKCB2YXIgcCA9IDAsIHBsID0gcGF0aHMubGVuZ3RoOyBwIDwgcGw7IHAgKysgKSB7XHJcblxyXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KCBzaGFwZXMsIHBhdGhzWyBwIF0udG9TaGFwZXMoKSApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc2hhcGVzO1xyXG5cclxufTtcclxuXHJcbi8vIFRvIHVzZSB0aGUgdHlwZWZhY2UuanMgZmFjZSBmaWxlcywgaG9vayB1cCB0aGUgQVBJXHJcblxyXG5USFJFRS50eXBlZmFjZV9qcyA9IHsgZmFjZXM6IFRIUkVFLkZvbnRVdGlscy5mYWNlcywgbG9hZEZhY2U6IFRIUkVFLkZvbnRVdGlscy5sb2FkRmFjZSB9O1xyXG5pZiAoIHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyApIHNlbGYuX3R5cGVmYWNlX2pzID0gVEhSRUUudHlwZWZhY2VfanM7XHJcblxyXG5cclxuXHJcblxyXG4vLyBGcm9tIGdpdGh1YiByZXBvc2l0b3J5IGF0IHRocmVlLmpzXFxleGFtcGxlc1xcZm9udHNoZWx2ZXRpa2VyX3JlZ3VsYXIudHlwZWZhY2UuanNcclxuaWYgKF90eXBlZmFjZV9qcyAmJiBfdHlwZWZhY2VfanMubG9hZEZhY2UpIF90eXBlZmFjZV9qcy5sb2FkRmFjZSh7XCJnbHlwaHNcIjp7XCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo3MTIsXCJoYVwiOjgxNSxcIm9cIjpcIm0gMzU2IC0yNSBxIDk2IDg4IDE5MiAtMjUgcSAwIDM2OCAwIDIwMSBxIDkyIDY0MiAwIDUzMyBxIDM1NiA3NjEgMTkyIDc2MSBxIDYxNyA2NDQgNTE3IDc2MSBxIDcxMiAzNjggNzEyIDUzMyBxIDYxOSA5MSA3MTIgMjAxIHEgMzU2IC0yNSA1MjAgLTI1IG0gMzU2IDg1IHEgNTI3IDE3NSA0NjUgODUgcSA1ODMgMzY5IDU4MyAyNTUgcSA1MjggNTYyIDU4MyA0ODQgcSAzNTYgNjUxIDQ2NiA2NTEgcSAxODkgNTYwIDI1MCA2NTEgcSAxMzUgMzY5IDEzNSA0ODEgcSAxODcgMTc3IDEzNSAyNTcgcSAzNTYgODUgMjUwIDg1IFwifSxcIlNcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjc4OCxcImhhXCI6ODkwLFwib1wiOlwibSA3ODggMjkxIHEgNjYyIDU0IDc4OCAxNDQgcSAzOTcgLTI2IDU1MCAtMjYgcSAxMTYgNjggMjI2IC0yNiBxIDAgMzM3IDAgMTY4IGwgMTMxIDMzNyBxIDIwMCAxNTIgMTMxIDIyMCBxIDM4NCA4NSAyNjkgODUgcSA1NTcgMTI5IDQ3OSA4NSBxIDY1MCAyNzAgNjUwIDE4MyBxIDQ5MCA0MjkgNjUwIDM3OSBxIDE5NCA1MTMgMzQxIDQ3MCBxIDMzIDczOSAzMyA1ODQgcSAxNDIgOTY0IDMzIDg4MSBxIDM4OCAxMDQxIDI0MiAxMDQxIHEgNjQ0IDk1NyA1NDMgMTA0MSBxIDc1NiA3MTYgNzU2IDg2NyBsIDYyNSA3MTYgcSA1NjEgODc0IDYyNSA4MTYgcSAzOTUgOTMzIDQ5NyA5MzMgcSAyNDMgODkxIDMwOSA5MzMgcSAxNjQgNzU5IDE2NCA4NDEgcSAzMjUgNjA5IDE2NCA2NTYgcSA2MjUgNTI2IDQ3NSA1NjggcSA3ODggMjkxIDc4OCA0NTQgXCJ9LFwi77+9XCI6e1wieF9taW5cIjozNDMsXCJ4X21heFwiOjQ0OSxcImhhXCI6NzkyLFwib1wiOlwibSA0NDkgNDYyIGwgMzQzIDQ2MiBsIDM0MyA5ODYgbCA0NDkgOTg2IGwgNDQ5IDQ2MiBtIDQ0OSAtMjQyIGwgMzQzIC0yNDIgbCAzNDMgMjgwIGwgNDQ5IDI4MCBsIDQ0OSAtMjQyIFwifSxcIi9cIjp7XCJ4X21pblwiOjE4My4yNSxcInhfbWF4XCI6NjA4LjMyODEyNSxcImhhXCI6NzkyLFwib1wiOlwibSA2MDggMTA0MSBsIDI2NiAtMTI5IGwgMTgzIC0xMjkgbCA1MjAgMTA0MSBsIDYwOCAxMDQxIFwifSxcIj9cIjp7XCJ4X21pblwiOi0wLjQzNzUsXCJ4X21heFwiOjc3Ny40NTMxMjUsXCJoYVwiOjgzOSxcIm9cIjpcIm0gNzc3IDg5MyBsIDQ1OCA4OTMgbCA0NTggMCBsIDMxOSAwIGwgMzE5IDg5MiBsIDAgODkyIGwgMCAxMDEzIGwgNzc3IDEwMTMgbCA3NzcgODkzIFwifSxcInlcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjY4NC43ODEyNSxcImhhXCI6NzcxLFwib1wiOlwibSA2ODQgNzM4IGwgMzg4IC04MyBxIDMxMSAtMjE2IDM1NiAtMTY3IHEgMTczIC0yNzkgMjUyIC0yNzkgcSA5NyAtMjY2IDEzMyAtMjc5IGwgOTcgLTE0OSBxIDEzMiAtMTU1IDEwOSAtMTUxIHEgMTY4IC0xNjAgMTU1IC0xNjAgcSAyNDAgLTExNCAyMTMgLTE2MCBxIDI3NCAtMjYgMjQ4IC05OCBsIDAgNzM4IGwgMTM3IDczNyBsIDM0MSAxMzkgbCA1NDggNzM3IGwgNjg0IDczOCBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo4MDMsXCJoYVwiOjkxNyxcIm9cIjpcIm0gODAzIDAgbCA2NjcgMCBsIDY2NyA4ODYgbCAxNDAgODg2IGwgMTQwIDAgbCAwIDAgbCAwIDEwMTIgbCA4MDMgMTAxMiBsIDgwMyAwIFwifSxcIj9cIjp7XCJ4X21pblwiOi0xMTEsXCJ4X21heFwiOjMzOSxcImhhXCI6MzYxLFwib1wiOlwibSAzMzkgODAwIGwgMjI5IDgwMCBsIDIyOSA5MjUgbCAzMzkgOTI1IGwgMzM5IDgwMCBtIC0xIDgwMCBsIC0xMTEgODAwIGwgLTExMSA5MjUgbCAtMSA5MjUgbCAtMSA4MDAgbSAyODQgMyBxIDIzMyAtMTAgMjU4IC01IHEgMTgyIC0xNSAyMDcgLTE1IHEgODUgMjYgMTE5IC0xNSBxIDQyIDIwMCA0MiA3OSBsIDQyIDczNyBsIDE2NyA3MzcgbCAxNjggMjE1IHEgMTcyIDE0MSAxNjggMTU3IHEgMjI2IDEwMSAxODMgMTAxIHEgMjQ4IDEwMyAyMzkgMTAxIHEgMjg0IDExMiAyNTcgMTA0IGwgMjg0IDMgbSAzMDIgMTA0MCBsIDExMyA4MTkgbCAzMCA4MTkgbCAxNjUgMTA0MCBsIDMwMiAxMDQwIFwifSxcImdcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjY4NixcImhhXCI6ODM4LFwib1wiOlwibSA2ODYgMzQgcSA1ODYgLTIxMyA2ODYgLTEyMSBxIDMzMSAtMzA2IDQ4NyAtMzA2IHEgMTMxIC0yNTIgMjE2IC0zMDYgcSAzMSAtODQgMzEgLTE5MCBsIDE1NSAtODQgcSAyMjggLTE3NCAxNjYgLTEzOCBxIDM0NSAtMjA3IDI4NCAtMjA3IHEgNTE0IC0xMDkgNDU0IC0yMDcgcSA1NjQgODkgNTY0IC0yNyBxIDQ2MSA2IDUyMSAzNiBxIDMzNSAtMjMgNDAxIC0yMyBxIDg4IDEwMCAxODQgLTIzIHEgMCAzNzAgMCAyMTUgcSA4NyA2MzQgMCA1MjIgcSAzMzAgNzU4IDE4MyA3NTggcSA0NTcgNzI4IDM5OCA3NTggcSA1NjQgNjQ0IDUxNSA2OTkgbCA1NjQgNzM3IGwgNjg2IDczNyBsIDY4NiAzNCBtIDU4MiAzNjcgcSA1MjkgNTYwIDU4MiA0ODEgcSAzNTggNjUyIDQ2OCA2NTIgcSAxODkgNTYxIDI1MCA2NTIgcSAxMzUgMzY5IDEzNSA0ODIgcSAxODkgMTc2IDEzNSAyNTUgcSAzNjEgODUgMjUxIDg1IHEgNTI5IDE3NiA0NjggODUgcSA1ODIgMzY3IDU4MiAyNTUgXCJ9LFwi77+9XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo0NDIsXCJoYVwiOjUzOSxcIm9cIjpcIm0gNDQyIDM4MyBsIDAgMzgzIHEgOTEgNTY2IDAgNDkyIHEgMjYwIDY2OCAxNzYgNjE3IHEgMzU0IDc5OCAzNTQgNzI3IHEgMzE1IDg3NSAzNTQgODQ1IHEgMjI3IDkwNSAyNzcgOTA1IHEgMTM2IDg2OSAxNzMgOTA1IHEgOTkgNzYxIDk5IDgzMyBsIDE0IDc2MSBxIDgyIDkyMiAxNCA4NjQgcSAyMzIgOTc0IDE0MSA5NzQgcSAzNzkgOTI2IDMxNiA5NzQgcSA0NDIgNzk3IDQ0MiA4NzggcSAzNTEgNjM1IDQ0MiA3MDQgcSAxODMgNTM5IDMyMSA2MTEgcSA5MiA0NTUgOTIgNDkxIGwgNDQyIDQ1NSBsIDQ0MiAzODMgXCJ9LFwi77+9XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo3MDUuNTYyNSxcImhhXCI6ODAzLFwib1wiOlwibSA3MDUgMzM0IGwgMCAzMzQgbCAwIDQxMCBsIDcwNSA0MTAgbCA3MDUgMzM0IFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjgxOS41NjI1LFwiaGFcIjo4OTMsXCJvXCI6XCJtIDgxOSAwIGwgNjUwIDAgbCAyOTQgNTA5IGwgMTM5IDM1NiBsIDEzOSAwIGwgMCAwIGwgMCAxMDEzIGwgMTM5IDEwMTMgbCAxMzkgNTI2IGwgNjI2IDEwMTMgbCA4MDkgMTAxMyBsIDM5NSA2MDAgbCA4MTkgMCBcIn0sXCLvv71cIjp7XCJ4X21pblwiOi00Ni4yNjU2MjUsXCJ4X21heFwiOjM5MixcImhhXCI6NTEzLFwib1wiOlwibSAzOTIgNjUxIGwgMjU5IDY1MSBsIDc5IC0yNzkgbCAtNDYgLTI3OCBsIDEzNCA2NTEgbCAxNCA2NTEgbCAxNCA3NTEgbCAxMzUgNzUxIHEgMTUxIDk0OCAxMzUgOTAwIHEgMzA0IDEwNDEgMTg1IDEwNDEgcSAzMzQgMTA0MCAzMTkgMTA0MSBxIDM5MiAxMDM0IDM0OCAxMDM5IGwgMzkyIDkyMiBxIDMzNyA5MzEgMzYwIDkzMSBxIDI3MSA4ODMgMjg3IDkzMSBxIDI2MCA3OTMgMjYwIDg1MyBsIDI2MCA3NTEgbCAzOTIgNzUxIGwgMzkyIDY1MSBcIn0sXCJlXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo3MTQsXCJoYVwiOjgxMyxcIm9cIjpcIm0gNzE0IDMyNiBsIDE0MCAzMjYgcSAyMDAgMTU3IDE0MCAyMjcgcSAzNTkgODcgMjYwIDg3IHEgNDg4IDEzMCA0MzEgODcgcSA1NjEgMjQ1IDU0NSAxNzQgbCA2OTcgMjQ1IHEgNTc3IDQ4IDY3MCAxMjMgcSAzNTggLTI2IDQ4NCAtMjYgcSA5NyA4NSAxOTUgLTI2IHEgMCAzNjMgMCAxOTcgcSA5NCA2NDIgMCA1MjkgcSAzNTggNzY1IDE5NSA3NjUgcSA2MjYgNjI3IDUyOSA3NjUgcSA3MTQgMzI2IDcxNCA1MDMgbSA1NzYgNDI5IHEgNTA3IDU4MyA1NjQgNTIyIHEgMzU1IDY1MCA0NDUgNjUwIHEgMjA2IDU4MyAyNjYgNjUwIHEgMTQwIDQyOSAxNTIgNTIyIGwgNTc2IDQyOSBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo3MTIsXCJoYVwiOjgxNSxcIm9cIjpcIm0gMzU2IC0yNSBxIDk0IDkxIDE5NCAtMjUgcSAwIDM2OCAwIDIwMiBxIDkyIDY0MiAwIDUzMyBxIDM1NiA3NjEgMTkyIDc2MSBxIDYxNyA2NDQgNTE3IDc2MSBxIDcxMiAzNjggNzEyIDUzMyBxIDYxOSA5MSA3MTIgMjAxIHEgMzU2IC0yNSA1MjAgLTI1IG0gMzU2IDg1IHEgNTI3IDE3NSA0NjUgODUgcSA1ODMgMzY5IDU4MyAyNTUgcSA1MjggNTYyIDU4MyA0ODQgcSAzNTYgNjUxIDQ2NiA2NTEgcSAxODkgNTYwIDI1MCA2NTEgcSAxMzUgMzY5IDEzNSA0ODEgcSAxODcgMTc3IDEzNSAyNTcgcSAzNTYgODUgMjUwIDg1IG0gNTc2IDEwNDAgbCAzODcgODE5IGwgMzAzIDgxOSBsIDQzOCAxMDQwIGwgNTc2IDEwNDAgXCJ9LFwiSlwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NTg4LFwiaGFcIjo2OTksXCJvXCI6XCJtIDU4OCAyNzkgcSAyODcgLTI2IDU4OCAtMjYgcSA1OCA3MyAxMjYgLTI2IHEgMCAzMjcgMCAxNTggbCAxMzMgMzI3IHEgMTYwIDE3MiAxMzMgMjI3IHEgMjg4IDk2IDE5OCA5NiBxIDQyNiAxNzEgMzkxIDk2IHEgNDQ5IDMzNiA0NDkgMjE5IGwgNDQ5IDEwMTMgbCA1ODggMTAxMyBsIDU4OCAyNzkgXCJ9LFwi77+9XCI6e1wieF9taW5cIjotMSxcInhfbWF4XCI6NTAzLFwiaGFcIjo2MDEsXCJvXCI6XCJtIDUwMyAzMDIgbCAyODAgMTM2IGwgMjgxIDI1NiBsIDQyOSAzNzMgbCAyODEgNDg2IGwgMjgwIDYwOCBsIDUwMyA0NDAgbCA1MDMgMzAyIG0gMjIxIDMwMiBsIDAgMTM2IGwgMCAyNTUgbCAxNDUgMzcyIGwgMCA0ODYgbCAtMSA2MDggbCAyMjEgNDQwIGwgMjIxIDMwMiBcIn0sXCLvv71cIjp7XCJ4X21pblwiOi0zLFwieF9tYXhcIjoxMDA4LFwiaGFcIjoxMTA2LFwib1wiOlwibSA1MDIgLTcgcSAxMjMgMTUxIDI2MyAtNyBxIC0zIDUwMSAtMyAyOTQgcSAxMjMgODUxIC0zIDcwNiBxIDUwMiAxMDExIDI2MyAxMDExIHEgODgxIDg1MSA3MzkgMTAxMSBxIDEwMDggNTAxIDEwMDggNzA4IHEgODgzIDE1MSAxMDA4IDI5MiBxIDUwMiAtNyA3NDQgLTcgbSA1MDIgNjAgcSA4MzAgMTk3IDcwOSA2MCBxIDk0MCA1MDEgOTQwIDMyMiBxIDgzMSA4MDUgOTQwIDY4MSBxIDUwMiA5NDQgNzA5IDk0NCBxIDE3NCA4MDUgMjk2IDk0NCBxIDY1IDUwMSA2NSA2ODAgcSAxNzMgMTk3IDY1IDMyMCBxIDUwMiA2MCAyOTQgNjAgbSA3NDEgMzk0IHEgNjYxIDI0NiA3MzEgMzAyIHEgNDk2IDE5MCA1OTEgMTkwIHEgMjk0IDI4NSAzNjkgMTkwIHEgMjI4IDQ5NyAyMjggMzcwIHEgMjk1IDcxNCAyMjggNjI1IHEgNDk5IDgxMyAzNzAgODEzIHEgNjU2IDc2MiA1ODggODEzIHEgNzMzIDYyNSA3MjQgNzExIGwgNjM0IDYyNSBxIDU4OSA3MDQgNjI5IDY3MyBxIDQ5OCA3MzUgNTUwIDczNSBxIDM3NyA2NjYgNDIxIDczNSBxIDMzNCA1MDQgMzM0IDU5NyBxIDM3NCAzNDAgMzM0IDQwOCBxIDQ5MCAyNzIgNDE1IDI3MiBxIDU4OSAzMDQgNTQ5IDI3MiBxIDYzOCAzOTQgNjI4IDMzNyBsIDc0MSAzOTQgXCJ9LFwiP1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6OTIyLFwiaGFcIjoxMDMwLFwib1wiOlwibSA2ODcgMTA0MCBsIDQ5OCA4MTkgbCA0MTUgODE5IGwgNTQ5IDEwNDAgbCA2ODcgMTA0MCBtIDkyMiAzMzkgcSA4NTYgOTcgOTIyIDIwMyBxIDY1MCAtMjYgNzgwIC0yNiBxIDUzOCA5IDU4NyAtMjYgcSA0NjEgMTAzIDQ4OSA0NCBxIDM4NyAxMiA0MzYgNDYgcSAyNzcgLTIyIDMzOSAtMjIgcSA2OSA5NyAxNDcgLTIyIHEgMCAzMzggMCAyMDIgcSA0NSA1NTEgMCA0NDQgcSAxNjEgNzM3IDg0IDY0MyBsIDMwMiA3MzcgcSAxNzUgNTUyIDIxOSA2NDcgcSAxMjQgMzM2IDEyNCA0NDYgcSAxNTUgMTc5IDEyNCAyNDggcSAyNzUgODggMTk3IDg4IHEgMzc1IDE2MyAzNDEgODggcSA0MDAgMjk0IDQwMCAyMTkgbCA0MDAgNTcyIGwgNTI0IDU3MiBsIDUyNCAyOTQgcSA1NjEgMTM1IDUyNCAxOTIgcSA2NDMgODggNTkxIDg4IHEgNzYyIDE4MiA3MTkgODggcSA3OTcgMzQxIDc5NyAyNTcgcSA3NDUgNTU1IDc5NyA0NTAgcSA2MTkgNzM3IDcwNSA2MzcgbCA3NjAgNzM3IHEgODc0IDU1MSA4MzUgNjQwIHEgOTIyIDMzOSA5MjIgNDQ0IFwifSxcIl5cIjp7XCJ4X21pblwiOjE5My4wNjI1LFwieF9tYXhcIjo1OTguNjA5Mzc1LFwiaGFcIjo3OTIsXCJvXCI6XCJtIDU5OCA3NzIgbCA1MTUgNzcyIGwgMzk1IDkzMSBsIDI3NyA3NzIgbCAxOTMgNzcyIGwgMzI2IDEwMTMgbCA0NjIgMTAxMyBsIDU5OCA3NzIgXCJ9LFwi77+9XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo1MDcuMjAzMTI1LFwiaGFcIjo2MDQsXCJvXCI6XCJtIDUwNiAxMzYgbCAyODQgMzAyIGwgMjg0IDQ0MCBsIDUwNiA2MDggbCA1MDcgNDg1IGwgMzYwIDM3MSBsIDUwNiAyNTUgbCA1MDYgMTM2IG0gMjIyIDEzNiBsIDAgMzAyIGwgMCA0NDAgbCAyMjIgNjA4IGwgMjIxIDQ4NiBsIDczIDM3MyBsIDIyMiAyNTYgbCAyMjIgMTM2IFwifSxcIkRcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjgyOCxcImhhXCI6OTM1LFwib1wiOlwibSAzODkgMTAxMyBxIDcxNCA4NjcgNTkzIDEwMTMgcSA4MjggNTIxIDgyOCA3MjkgcSA3MTIgMTYxIDgyOCAzMDkgcSAzODIgMCA1ODcgMCBsIDAgMCBsIDAgMTAxMyBsIDM4OSAxMDEzIG0gMzc2IDEyNCBxIDYwNyAyNDcgNTIzIDEyNCBxIDY4MSA1MTAgNjgxIDM1NSBxIDYwNyA3NzEgNjgxIDY2MiBxIDM3NiA4OTYgNTIyIDg5NiBsIDEzOSA4OTYgbCAxMzkgMTI0IGwgMzc2IDEyNCBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjoxNDIsXCJoYVwiOjIzOSxcIm9cIjpcIm0gMTQyIDU4NSBsIDAgNTg1IGwgMCA3MzggbCAxNDIgNzM4IGwgMTQyIDU4NSBcIn0sXCLvv71cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjQ3LFwiaGFcIjoxMjUsXCJvXCI6XCJtIDQ3IDMgcSAzNyAtNyA0NyAtNyBxIDI4IDAgMzAgLTcgcSAzOSAtNCAzMiAtNCBxIDQ1IDMgNDUgLTEgbCAzNyAwIHEgMjggOSAyOCAwIHEgMzkgMTkgMjggMTkgbCA0NyAxNiBsIDQ3IDE5IGwgNDcgMyBtIDM3IDEgcSA0NCA4IDQ0IDEgcSAzNyAxNiA0NCAxNiBxIDMwIDggMzAgMTYgcSAzNyAxIDMwIDEgbSAyNiAxIGwgMjMgMjIgbCAxNCAwIGwgMyAyMiBsIDMgMyBsIDAgMjUgbCAxMyAxIGwgMjIgMjUgbCAyNiAxIFwifSxcIndcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjEwMDkuNzE4NzUsXCJoYVwiOjExMDAsXCJvXCI6XCJtIDEwMDkgNzM4IGwgNzgzIDAgbCA2NTggMCBsIDUwMSA1NjcgbCAzNDUgMCBsIDIyMiAwIGwgMCA3MzggbCAxMzAgNzM4IGwgMjg0IDE3NCBsIDQzMiA3MzcgbCA1NzYgNzM4IGwgNzIxIDE3MyBsIDg4MSA3MzcgbCAxMDA5IDczOCBcIn0sXCIkXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo3MDAsXCJoYVwiOjc5MyxcIm9cIjpcIm0gNjY0IDcxNyBsIDU0MiA3MTcgcSA0OTAgODI1IDUzMSA3ODUgcSAzODEgODcyIDQ1MCA4NjUgbCAzODEgNTUxIHEgNjIwIDQ0NiA1NDAgNTIyIHEgNzAwIDI0MSA3MDAgMzcwIHEgNjE4IDQ1IDcwMCAxMTYgcSAzODEgLTI1IDUzNiAtMjUgbCAzODEgLTE1MiBsIDMwNyAtMTUyIGwgMzA3IC0yNSBxIDgxIDYyIDE2MiAtMjUgcSAwIDI5NyAwIDE0OSBsIDEyNCAyOTcgcSAxNjkgMTQ2IDEyNCAyMDQgcSAzMDcgODEgMjE1IDg5IGwgMzA3IDQ0MSBxIDgwIDUzNiAxNDggNDY5IHEgMTMgNzI1IDEzIDYwMyBxIDk2IDkxMCAxMyA4MzkgcSAzMDcgOTgyIDE4MCA5ODIgbCAzMDcgMTA3NyBsIDM4MSAxMDc3IGwgMzgxIDk4MiBxIDU3NCA5MTcgNDk0IDk4MiBxIDY2NCA3MTcgNjY0IDg0NSBtIDMwNyA1NjUgbCAzMDcgODcyIHEgMTg3IDgzMSAyMzMgODcyIHEgMTQyIDcyNCAxNDIgNzkxIHEgMTgwIDYxOCAxNDIgNjU2IHEgMzA3IDU2NSAyMTggNTgwIG0gMzgxIDc2IHEgNTYyIDIzNyA1NjIgOTYgcSA1MTcgMzYxIDU2MiAzMTMgcSAzODEgNDIzIDQ3MiA0MDkgbCAzODEgNzYgXCJ9LFwiXFxcXFwiOntcInhfbWluXCI6LTAuMDE1NjI1LFwieF9tYXhcIjo0MjUuMDYyNSxcImhhXCI6NTIyLFwib1wiOlwibSA0MjUgLTEyOSBsIDMzNyAtMTI5IGwgMCAxMDQxIGwgODMgMTA0MSBsIDQyNSAtMTI5IFwifSxcIu+/vVwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6Njk3LjIxODc1LFwiaGFcIjo3NDcsXCJvXCI6XCJtIDY5NyAtNCBxIDYyOSAtMTQgNjU4IC0xNCBxIDQ5OCA5NyA1MTMgLTE0IHEgNDIyIDkgNDcwIDQxIHEgMzEzIC0yMyAzNzQgLTIzIHEgMjA3IDQgMjU4IC0yMyBxIDExOSA4MSAxNTYgMzIgbCAxMTkgLTI3OCBsIDAgLTI3OCBsIDAgNzM4IGwgMTI0IDczOCBsIDEyNCAzNDMgcSAxNjUgMTczIDEyNCAyNDYgcSAzMDggODMgMjE2IDgzIHEgNDUyIDE3OCA0MDIgODMgcSA0OTMgMzU5IDQ5MyAyNTUgbCA0OTMgNzM4IGwgNjE3IDczOCBsIDYxNyAyMTQgcSA2MjMgMTM2IDYxNyAxNjAgcSA2NzMgOTIgNjM3IDkyIHEgNjk3IDk2IDY4NCA5MiBsIDY5NyAtNCBcIn0sXCI/XCI6e1wieF9taW5cIjo0MixcInhfbWF4XCI6MTgxLFwiaGFcIjoyOTcsXCJvXCI6XCJtIDE4MSAwIGwgNDIgMCBsIDQyIDEwMTMgbCAxODEgMTAxMyBsIDE4MSAwIFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjExNDQuNSxcImhhXCI6MTIxNCxcIm9cIjpcIm0gMTE0NCAxMDEyIGwgODA3IDQxNiBsIDgwNyAwIGwgNjY3IDAgbCA2NjcgNDE2IGwgMzI1IDEwMTIgbCA0NjUgMTAxMiBsIDczNiA1MzMgbCAxMDA0IDEwMTIgbCAxMTQ0IDEwMTIgbSAyNzcgMTA0MCBsIDgzIDc5OSBsIDAgNzk5IGwgMTQwIDEwNDAgbCAyNzcgMTA0MCBcIn0sXCLvv71cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjEzOSxcImhhXCI6MjM2LFwib1wiOlwibSAxMzkgODUxIHEgMTAyIDczNyAxMzkgNzg0IHEgMCA2NjkgNjUgNjkwIGwgMCA3MzQgcSA1OSA3ODcgNDIgNzQxIHEgNzIgODczIDcyIDgyMSBsIDAgODczIGwgMCAxMDEzIGwgMTM5IDEwMTMgbCAxMzkgODUxIFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjgwMSxcImhhXCI6OTE1LFwib1wiOlwibSA4MDEgMCBsIDY1MSAwIGwgMTMxIDgyMiBsIDEzMSAwIGwgMCAwIGwgMCAxMDEzIGwgMTUxIDEwMTMgbCA2NzAgMTkxIGwgNjcwIDEwMTMgbCA4MDEgMTAxMyBsIDgwMSAwIFwifSxcIi1cIjp7XCJ4X21pblwiOjguNzE4NzUsXCJ4X21heFwiOjM1MC4zOTA2MjUsXCJoYVwiOjQ3OCxcIm9cIjpcIm0gMzUwIDMxNyBsIDggMzE3IGwgOCA0MjggbCAzNTAgNDI4IGwgMzUwIDMxNyBcIn0sXCJRXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo5NjgsXCJoYVwiOjEwNzIsXCJvXCI6XCJtIDk1NCA1IGwgODg3IC03OSBsIDc0NCAzNSBxIDYyMiAtMTEgNjg3IDIgcSA0ODMgLTI2IDU1NiAtMjYgcSAxMjcgMTMwIDI2MiAtMjYgcSAwIDUwNCAwIDI3OSBxIDEyNyA4ODAgMCA3MjggcSA0ODQgMTA0MSAyNjIgMTA0MSBxIDg0MSA4ODQgNzA4IDEwNDEgcSA5NjggNTA3IDk2OCA3MzUgcSA5MzMgMjkzIDk2OCAzOTggcSA4MzIgMTA0IDg5OSAxODggbCA5NTQgNSBtIDcyMyAxOTEgcSA4MDIgMzMwIDc3NyAyNDggcSA4MjggNDk5IDgyOCA0MTIgcSA3NDQgNzkwIDgyOCA2NzMgcSA0ODMgOTIyIDY1MCA5MjIgcSAyMjggNzkxIDMyMiA5MjIgcSAxNDIgNTA1IDE0MiA2NzMgcSAyMjcgMjIxIDE0MiAzMzcgcSA0ODcgOTEgMzIzIDkxIHEgNjMyIDEyMyA1NjYgOTEgbCA1MjAgMjE1IGwgNTg3IDMwMSBsIDcyMyAxOTEgXCJ9LFwiP1wiOntcInhfbWluXCI6MSxcInhfbWF4XCI6Njc2LjI4MTI1LFwiaGFcIjo3NDAsXCJvXCI6XCJtIDY3NiA0NjAgbCA1NTEgNDYwIHEgNDk4IDU5NSA1NDIgNTQ2IHEgMzY1IDY1MSA0NDggNjUxIHEgMTk5IDU3OCAyNjMgNjUxIHEgMTM2IDQwMSAxMzYgNTA1IHEgMjY2IDE3OCAxMzYgMjQxIHEgNTA4IDEwNiAzODcgMTQyIHEgNjQwIC01MCA2NDAgNjIgcSA2MjUgLTE1OCA2NDAgLTEwNSBxIDU4MyAtMjc4IDYxMSAtMjExIGwgNDY1IC0yNzggcSA0OTggLTE4MiA0OTAgLTIxMSBxIDUxNSAtODAgNTE1IC0xMjYgcSAzODEgMTIgNTE1IC0xNSBxIDEzNCA5MSAxOTcgNTEgcSAxIDM4OCAxIDE3OSBxIDEwMCA2NTEgMSA1NDIgcSAzNTQgNzYxIDE5OSA3NjEgcSA1ODcgNjgwIDQ5OCA3NjEgcSA2NzYgNDYwIDY3NiA1OTkgXCJ9LFwiTVwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6OTU0LFwiaGFcIjoxMDY3LFwib1wiOlwibSA5NTQgMCBsIDgxOSAwIGwgODE5IDg2OSBsIDUzNyAwIGwgNDA1IDAgbCAxMjggODY2IGwgMTI4IDAgbCAwIDAgbCAwIDEwMTMgbCAyMDAgMTAxMyBsIDQ3MiAxNjAgbCA3NTcgMTAxMyBsIDk1NCAxMDEzIGwgOTU0IDAgXCJ9LFwiP1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6MTAwNixcImhhXCI6MTA5NCxcIm9cIjpcIm0gMTAwNiA2NzggcSA5MTQgMzE5IDEwMDYgNDI5IHEgNTcxIDIwMCA4MTQgMjAwIGwgNTcxIDAgbCA0MzMgMCBsIDQzMyAyMDAgcSA5MiAzMTkgMTk0IDIwMCBxIDAgNjc4IDAgNDI5IGwgMCAxMDEzIGwgMTM5IDEwMTMgbCAxMzkgNjc5IHEgMTkxIDQxNyAxMzkgNDkyIHEgNDMzIDMyNiAyNTUgMzI2IGwgNDMzIDEwMTMgbCA1NzEgMTAxMyBsIDU3MSAzMjYgbCA1ODAgMzI2IHEgODEzIDQyMyA3NDcgMzI2IHEgODY4IDY3OSA4NjggNTAyIGwgODY4IDEwMTMgbCAxMDA2IDEwMTMgbCAxMDA2IDY3OCBcIn0sXCJDXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo4ODYsXCJoYVwiOjk0NCxcIm9cIjpcIm0gODg2IDM3OSBxIDc2MCA4NyA4ODYgMjAxIHEgNDU1IC0yNiA2MzQgLTI2IHEgMTEyIDEzNiAyMzYgLTI2IHEgMCA1MDkgMCAyODMgcSAxMTggODgyIDAgNzM3IHEgNDY5IDEwNDEgMjQ1IDEwNDEgcSA3NDggOTU1IDYzMCAxMDQxIHEgODc5IDcwOCA4NzkgODU5IGwgNzQ1IDcwOCBxIDY0OSA4NjIgNzI0IDgwNSBxIDQ3MyA5MjAgNTczIDkyMCBxIDIxOSA3OTEgMzEyIDkyMCBxIDEzNiA1MDkgMTM2IDY3NSBxIDIxNyAyMjkgMTM2IDM0NCBxIDQ3MCA5OSAzMTEgOTkgcSA2NzIgMTc5IDU5MSA5OSBxIDc1MyAzNzkgNzUzIDI1OSBsIDg4NiAzNzkgXCJ9LFwiIVwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6MTM4LFwiaGFcIjoyMzYsXCJvXCI6XCJtIDEzOCA2ODQgcSAxMTYgNDA5IDEzOCA2MjkgcSAxMDUgMjQ0IDEwNSAyOTkgbCAzMyAyNDQgcSAxNiA0NjUgMzMgMzEzIHEgMCA2ODQgMCA2MTYgbCAwIDEwMTMgbCAxMzggMTAxMyBsIDEzOCA2ODQgbSAxMzggMCBsIDAgMCBsIDAgMTUxIGwgMTM4IDE1MSBsIDEzOCAwIFwifSxcIntcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjQ4MC41NjI1LFwiaGFcIjo1NzgsXCJvXCI6XCJtIDQ4MCAtMjg2IHEgMjM3IC0yMTMgMzAzIC0yODYgcSAxODcgLTQ1IDE4NyAtMTU5IHEgMTk0IDQ4IDE4NyAtMTUgcSAyMDEgMTQxIDIwMSAxMTIgcSAxNjQgMjY0IDIwMSAyMjUgcSAwIDMxNCAxMTggMzE0IGwgMCA0MTcgcSAxNjQgNDcxIDExOSA0MTcgcSAyMDEgNjA1IDIwMSA1MTQgcSAxOTkgNjY1IDIwMSA2NDQgcSAxOTMgNzcyIDE5MyA3NjkgcSAyNDEgOTQxIDE5MyA4ODcgcSA0ODAgMTAxNSAzMDggMTAxNSBsIDQ4MCA5MTUgcSAzMzYgODY2IDM3NSA5MTUgcSAzMDYgNzQyIDMwNiA4MjggcSAzMTAgNjYyIDMwNiA3MTcgcSAzMTQgNTc3IDMxNCA2MDYgcSAyODggNDUyIDMxNCA1MDAgcSAxNzYgMzY1IDI1NiAzOTEgcSAyODkgMjc1IDI1NyAzMzcgcSAzMTQgMTQzIDMxNCAyMjYgcSAzMTMgODQgMzE0IDEwNyBxIDMxMCAtMTEgMzEwIC01IHEgMzM5IC0xMzEgMzEwIC05NCBxIDQ4MCAtMTgyIDM3NyAtMTgyIGwgNDgwIC0yODYgXCJ9LFwiWFwiOntcInhfbWluXCI6LTAuMDE1NjI1LFwieF9tYXhcIjo4NTQuMTU2MjUsXCJoYVwiOjk0MCxcIm9cIjpcIm0gODU0IDAgbCA2ODMgMCBsIDQyMyA0MDkgbCAxNjYgMCBsIDAgMCBsIDM0NyA1MTkgbCAxOCAxMDEzIGwgMTg2IDEwMTMgbCA0MjggNjM3IGwgNjc1IDEwMTMgbCA4MzYgMTAxMyBsIDUwNCA1MjAgbCA4NTQgMCBcIn0sXCIjXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo5NjMuODkwNjI1LFwiaGFcIjoxMDYxLFwib1wiOlwibSA5NjMgNjkwIGwgOTI3IDU5MCBsIDcxOSA1OTAgbCA2NTUgNDEwIGwgODc2IDQxMCBsIDg0MCAzMTAgbCA2MTggMzEwIGwgNTA4IC0zIGwgMzkzIC0yIGwgNTA2IDMwOSBsIDMyOSAzMTAgbCAyMTUgLTIgbCAxMDIgLTMgbCAyMTIgMzEwIGwgMCAzMTAgbCAzNiA0MTAgbCAyNDggNDA5IGwgMzEyIDU5MCBsIDg2IDU5MCBsIDEyMCA2OTAgbCAzNDcgNjkwIGwgNDU5IDEwMDYgbCA1NzMgMTAwNiBsIDQ2MiA2OTAgbCA2NDAgNjkwIGwgNzUxIDEwMDYgbCA4NjUgMTAwNiBsIDc1NCA2OTAgbCA5NjMgNjkwIG0gNjA2IDU5MCBsIDQyNSA1OTAgbCAzNjIgNDEwIGwgNTQzIDQxMCBsIDYwNiA1OTAgXCJ9LFwiP1wiOntcInhfbWluXCI6NDIsXCJ4X21heFwiOjI4NCxcImhhXCI6MzYxLFwib1wiOlwibSAyODQgMyBxIDIzMyAtMTAgMjU4IC01IHEgMTgyIC0xNSAyMDcgLTE1IHEgODUgMjYgMTE5IC0xNSBxIDQyIDIwMCA0MiA3OSBsIDQyIDczOCBsIDE2NyA3MzggbCAxNjggMjE1IHEgMTcyIDE0MSAxNjggMTU3IHEgMjI2IDEwMSAxODMgMTAxIHEgMjQ4IDEwMyAyMzkgMTAxIHEgMjg0IDExMiAyNTcgMTA0IGwgMjg0IDMgXCJ9LFwiP1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6OTA2Ljk1MzEyNSxcImhhXCI6OTgyLFwib1wiOlwibSAyODMgMTA0MCBsIDg4IDc5OSBsIDUgNzk5IGwgMTQ1IDEwNDAgbCAyODMgMTA0MCBtIDkwNiAwIGwgNzU2IDAgbCA2NTAgMzAzIGwgMjUxIDMwMyBsIDE0MyAwIGwgMCAwIGwgMzc2IDEwMTIgbCA1MjkgMTAxMiBsIDkwNiAwIG0gNjA5IDQyMSBsIDQ1MiA4NjYgbCAyOTMgNDIxIGwgNjA5IDQyMSBcIn0sXCIpXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjozMTgsXCJoYVwiOjQxNSxcIm9cIjpcIm0gMzE4IDM2NSBxIDI1NyAyNSAzMTggMTkxIHEgODcgLTI5MCAxOTcgLTE0MSBsIDAgLTI5MCBxIDE0MCAyMSA5MyAtMTI4IHEgMTkzIDM2MCAxOTMgMTg5IHEgMTQxIDcwNCAxOTMgNTM3IHEgMCAxMDI0IDk3IDg1MCBsIDg3IDEwMjQgcSAyNTcgNzA2IDE5NyA4NzEgcSAzMTggMzY1IDMxOCA1NDIgXCJ9LFwiP1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NjM0LjcxODc1LFwiaGFcIjo3MTQsXCJvXCI6XCJtIDYzNCAyMzQgcSA1MjcgMzggNjM0IDExMCBxIDMwMCAtMjUgNDMzIC0yNSBxIDk4IDI5IDE4MyAtMjUgcSAwIDIwNCAwIDkzIHEgMzcgMzE0IDAgMjY1IHEgMTI4IDM5MCA2NyAzNTMgcSA1NiA0NjAgODIgNDE5IHEgMjYgNTU1IDI2IDUwNSBxIDExNCA3MTIgMjYgNjU0IHEgMjk1IDc2MyAxOTEgNzYzIHEgNDk5IDcwMCA0MTYgNzYzIHEgNTg5IDUxNSA1ODkgNjMxIGwgNDc4IDUxNSBxIDQxOSA2MTggNDY0IDU4MCBxIDMwNyA2NTcgMzc0IDY1NyBxIDIwNyA2MzAgMjUzIDY1NyBxIDE1MSA1NDcgMTUxIDU5OCBxIDIzOCA0NDUgMTUxIDQ2OSBxIDM4OSA0MzQgMjgwIDQzNCBsIDM4OSAzMzEgbCAzNDkgMzMxIHEgMjA2IDMxNSAyNTUgMzMxIHEgMTI1IDIxMCAxMjUgMjg3IHEgMTgzIDEwNyAxMjUgMTQ1IHEgMzAyIDc2IDIzMyA3NiBxIDQzNiAxMTcgMzc5IDc2IHEgNTA5IDIzNCA0OTMgMTU5IGwgNjM0IDIzNCBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo5NTIuNzgxMjUsXCJoYVwiOjEwMjgsXCJvXCI6XCJtIDk1MiAwIGwgMCAwIGwgNDAwIDEwMTMgbCA1NTEgMTAxMyBsIDk1MiAwIG0gNzYyIDEyNCBsIDQ3NiA4NjcgbCAxODcgMTI0IGwgNzYyIDEyNCBcIn0sXCJ9XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo0ODEsXCJoYVwiOjU3OCxcIm9cIjpcIm0gNDgxIDMxNCBxIDMxOCAyNjIgMzY0IDMxNCBxIDI4MiAxMzYgMjgyIDIyMiBxIDI4NCA2NSAyODIgOTcgcSAyOTMgLTU4IDI5MyAtNDggcSAyNDEgLTIxNyAyOTMgLTE2NiBxIDAgLTI4NiAxNzQgLTI4NiBsIDAgLTE4MiBxIDE0MyAtMTMwIDEwNSAtMTgyIHEgMTcxIC0yIDE3MSAtOTMgcSAxNjggODEgMTcxIDIyIHEgMTY1IDE0NCAxNjUgMTQwIHEgMTg4IDI3NSAxNjUgMjI5IHEgMzA2IDM2NSAyMjAgMzM5IHEgMTkxIDQ1NSAyMjQgMzkxIHEgMTY1IDU4OCAxNjUgNTA1IHEgMTY4IDY4MSAxNjUgNjI0IHEgMTcxIDc0MiAxNzEgNzM3IHEgMTQxIDg2NSAxNzEgODI3IHEgMCA5MTUgMTAyIDkxNSBsIDAgMTAxNSBxIDI0MyA5NDIgMTc2IDEwMTUgcSAyOTMgNzczIDI5MyA4ODggcSAyODcgNjc1IDI5MyA3NDEgcSAyODIgNTkwIDI4MiA2MDggcSAzMTggNDY2IDI4MiA1MDUgcSA0ODEgNDE3IDM2NCA0MTcgbCA0ODEgMzE0IFwifSxcIu+/vVwiOntcInhfbWluXCI6LTMsXCJ4X21heFwiOjE2NzIsXCJoYVwiOjE4MjEsXCJvXCI6XCJtIDg0NiAwIHEgNjY0IDc2IDczMiAwIHEgNjAzIDI0NCA2MDMgMTQ1IHEgNjYyIDQxMiA2MDMgMzQ0IHEgODQ2IDQ4OSA3MjkgNDg5IHEgMTAyNyA0MTIgOTU5IDQ4OSBxIDEwODkgMjQ0IDEwODkgMzQzIHEgMTAyOSA3NiAxMDg5IDE0NCBxIDg0NiAwIDk2MiAwIG0gODQ1IDEwMyBxIDk0NSAxNDMgOTEwIDEwMyBxIDk4MSAyNDMgOTgxIDE4NCBxIDk0NyAzNDAgOTgxIDMwMSBxIDg0NSAzODUgOTEwIDM4NSBxIDc0NSAzNDIgNzgyIDM4NSBxIDcwOSAyNDMgNzA5IDMwMCBxIDc0MiAxNDcgNzA5IDE4NiBxIDg0NSAxMDMgNzgxIDEwMyBtIDg4OCA5ODYgbCAyODQgLTI1IGwgMTk5IC0yNSBsIDgwMyA5ODYgbCA4ODggOTg2IG0gMjQxIDQ2OCBxIDU4IDU0NSAxMjYgNDY4IHEgLTMgNzE1IC0zIDYxNSBxIDU2IDg4MSAtMyA4MTMgcSAyMzggOTU4IDEyNCA5NTggcSA0MjEgODgxIDM1MyA5NTggcSA0ODMgNzEyIDQ4MyA4MTMgcSA0MjMgNTQ0IDQ4MyA2MTIgcSAyNDEgNDY4IDM1NiA0NjggbSAyNDEgODU1IHEgMTM3IDgxMSAxNzUgODU1IHEgMTAwIDcxMCAxMDAgNzY4IHEgMTM2IDYxMiAxMDAgNjUzIHEgMjQwIDU3MiAxNzIgNTcyIHEgMzQ0IDYxNCAzMDYgNTcyIHEgMzgyIDcxMyAzODIgNjU2IHEgMzQ3IDgxMCAzODIgNzcxIHEgMjQxIDg1NSAzMDggODU1IG0gMTQyOCAwIHEgMTI0NiA3NiAxMzE0IDAgcSAxMTg1IDI0NCAxMTg1IDE0NSBxIDEyNDQgNDEyIDExODUgMzQ0IHEgMTQyOCA0ODkgMTMxMSA0ODkgcSAxNjEwIDQxMiAxNTQyIDQ4OSBxIDE2NzIgMjQ0IDE2NzIgMzQzIHEgMTYxMiA3NiAxNjcyIDE0NCBxIDE0MjggMCAxNTQ1IDAgbSAxNDI3IDEwMyBxIDE1MjggMTQzIDE0OTIgMTAzIHEgMTU2NCAyNDMgMTU2NCAxODQgcSAxNTMwIDM0MCAxNTY0IDMwMSBxIDE0MjcgMzg1IDE0OTIgMzg1IHEgMTMyNyAzNDIgMTM2NCAzODUgcSAxMjkxIDI0MyAxMjkxIDMwMCBxIDEzMjQgMTQ3IDEyOTEgMTg2IHEgMTQyNyAxMDMgMTM2MyAxMDMgXCJ9LFwiYVwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6Njk4LjYwOTM3NSxcImhhXCI6Nzk0LFwib1wiOlwibSA2OTggMCBxIDY2MSAtMTIgNjc5IC03IHEgNjE1IC0xNyA2NDMgLTE3IHEgNTM2IDEyIDU2NCAtMTcgcSA1MDAgOTYgNTA4IDQxIHEgMzg0IDYgNDU2IDM3IHEgMjM2IC0yNSAzMTIgLTI1IHEgNjUgMzEgMTMwIC0yNSBxIDAgMTk0IDAgODggcSAxMTggMzkwIDAgMzM0IHEgMzI4IDQzNSAxODAgNDIwIHEgNDg4IDQ4MyA0NzYgNDUxIHEgNDk1IDUyMyA0OTUgNTA0IHEgNDQyIDYxOSA0OTUgNTg0IHEgMzI1IDY1NCAzODkgNjU0IHEgMjA5IDYxNyAyNTcgNjU0IHEgMTUyIDUxMyAxNjEgNTgwIGwgMzMgNTEzIHEgMTIzIDcwNSAzMyA2MzMgcSAzMzIgNzcyIDIwNyA3NzIgcSA1MjggNzEyIDQ0OCA3NzIgcSA2MTcgNTMxIDYxNyA2NDUgbCA2MTcgMTYzIHEgNjI0IDEwOCA2MTcgMTI2IHEgNjY0IDkwIDYzMiA5MCBsIDY5OCA5NCBsIDY5OCAwIG0gNDkxIDI2MiBsIDQ5MSAzNzIgcSAyNzIgMzI5IDM1MCAzNDcgcSAxMjggMjAxIDEyOCAyOTQgcSAxNjYgMTEzIDEyOCAxNDQgcSAyNjQgODMgMjA1IDgzIHEgNDE0IDEzMCAzNDYgODMgcSA0OTEgMjYyIDQ5MSAxODMgXCJ9LFwi77+9XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo5NDEuNjcxODc1LFwiaGFcIjoxMDM5LFwib1wiOlwibSA5NDEgMzM0IGwgMCAzMzQgbCAwIDQxMCBsIDk0MSA0MTAgbCA5NDEgMzM0IFwifSxcIj1cIjp7XCJ4X21pblwiOjguNzE4NzUsXCJ4X21heFwiOjc4MC45NTMxMjUsXCJoYVwiOjc5MixcIm9cIjpcIm0gNzgwIDUxMCBsIDggNTEwIGwgOCA2MDYgbCA3ODAgNjA2IGwgNzgwIDUxMCBtIDc4MCAyMzUgbCA4IDIzNSBsIDggMzMyIGwgNzgwIDMzMiBsIDc4MCAyMzUgXCJ9LFwiTlwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6ODAxLFwiaGFcIjo5MTQsXCJvXCI6XCJtIDgwMSAwIGwgNjUxIDAgbCAxMzEgODIzIGwgMTMxIDAgbCAwIDAgbCAwIDEwMTMgbCAxNTEgMTAxMyBsIDY3MCAxOTMgbCA2NzAgMTAxMyBsIDgwMSAxMDEzIGwgODAxIDAgXCJ9LFwiP1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NzEyLFwiaGFcIjo3OTcsXCJvXCI6XCJtIDcxMiAzNjkgcSA2MjAgOTQgNzEyIDIwNyBxIDM2MiAtMjYgNTIxIC0yNiBxIDIzMCAyIDI5MiAtMjYgcSAxMTkgODMgMTY3IDMwIGwgMTE5IC0yNzggbCAwIC0yNzggbCAwIDM2MiBxIDkxIDY0MyAwIDUzMSBxIDM1NSA3NjQgMTkwIDc2NCBxIDYxNyA2NDcgNTE3IDc2NCBxIDcxMiAzNjkgNzEyIDUzNiBtIDU4MyAzNjYgcSA1MzAgNTU5IDU4MyA0ODAgcSAzNTkgNjUxIDQ2OSA2NTEgcSAxOTAgNTYyIDI1MiA2NTEgcSAxMzUgMzcwIDEzNSA0ODMgcSAxODkgMTc2IDEzNSAyNTcgcSAzNTkgODUgMjUwIDg1IHEgNTI4IDE3NSA0NjYgODUgcSA1ODMgMzY2IDU4MyAyNTQgXCJ9LFwiMlwiOntcInhfbWluXCI6NTksXCJ4X21heFwiOjczMSxcImhhXCI6NzkyLFwib1wiOlwibSA3MzEgMCBsIDU5IDAgcSAxOTcgMzE0IDU5IDE4OCBxIDQ1NyA0ODcgMTk5IDMxNSBxIDU5OCA2OTEgNTk4IDU4MCBxIDU0MyA4MTkgNTk4IDc3MiBxIDQxMSA4NjcgNDg4IDg2NyBxIDI3MiA4MTEgMzI4IDg2NyBxIDIwOSA2MzAgMjA5IDc0NyBsIDgxIDYzMCBxIDE4MiA5MDEgODEgODA1IHEgNDA4IDk4NiAyNzEgOTg2IHEgNjI5IDkwOSA1MzYgOTg2IHEgNzMxIDY5NCA3MzEgODI2IHEgNjEzIDQ0OSA3MzEgNTQxIHEgMzc4IDMxNiA0OTUgMzgzIHEgMjAxIDEyMiAyMzUgMjM0IGwgNzMxIDEyMiBsIDczMSAwIFwifSxcIu+/vVwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6OTQxLjY3MTg3NSxcImhhXCI6OTM4LFwib1wiOlwibSA5NDEgMTAzMyBsIDAgMTAzMyBsIDAgMTEwOSBsIDk0MSAxMTA5IGwgOTQxIDEwMzMgXCJ9LFwiWlwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6Nzc5LFwiaGFcIjo4NDksXCJvXCI6XCJtIDc3OSAwIGwgMCAwIGwgMCAxMTMgbCA2MjEgODk2IGwgNDAgODk2IGwgNDAgMTAxMyBsIDc3OSAxMDEzIGwgNzc4IDg4NyBsIDE3MSAxMjQgbCA3NzkgMTI0IGwgNzc5IDAgXCJ9LFwidVwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NjE3LFwiaGFcIjo3MjksXCJvXCI6XCJtIDYxNyAwIGwgNDk5IDAgbCA0OTkgMTEwIHEgMzkxIDEwIDQ2MCA0NSBxIDI0NiAtMjUgMzIyIC0yNSBxIDYxIDU4IDEyNyAtMjUgcSAwIDI1OCAwIDEzNiBsIDAgNzM4IGwgMTI1IDczOCBsIDEyNSAyODQgcSAxNTYgMTQ4IDEyNSAyMDIgcSAyNzMgODIgMTk3IDgyIHEgNDMzIDE2NSAzNjkgODIgcSA0OTMgMzQwIDQ5MyAyNDMgbCA0OTMgNzM4IGwgNjE3IDczOCBsIDYxNyAwIFwifSxcImtcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjYxMi40ODQzNzUsXCJoYVwiOjY5NyxcIm9cIjpcIm0gNjEyIDczOCBsIDMzOCA0NjUgbCA2MDggMCBsIDQ2OSAwIGwgMjUxIDM4MiBsIDEyMSAyNTEgbCAxMjEgMCBsIDAgMCBsIDAgMTAxMyBsIDEyMSAxMDEzIGwgMTIxIDQwMiBsIDQ1NiA3MzggbCA2MTIgNzM4IFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjgwMyxcImhhXCI6OTE3LFwib1wiOlwibSA4MDMgMCBsIDY2NyAwIGwgNjY3IDQ3NSBsIDE0MCA0NzUgbCAxNDAgMCBsIDAgMCBsIDAgMTAxMyBsIDE0MCAxMDEzIGwgMTQwIDU5OSBsIDY2NyA1OTkgbCA2NjcgMTAxMyBsIDgwMyAxMDEzIGwgODAzIDAgXCJ9LFwiP1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6OTA2Ljk1MzEyNSxcImhhXCI6OTg1LFwib1wiOlwibSA5MDYgMCBsIDc1NiAwIGwgNjUwIDMwMyBsIDI1MSAzMDMgbCAxNDMgMCBsIDAgMCBsIDM3NiAxMDEzIGwgNTI5IDEwMTMgbCA5MDYgMCBtIDYwOSA0MjEgbCA0NTIgODY2IGwgMjkzIDQyMSBsIDYwOSA0MjEgXCJ9LFwic1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NjA0LFwiaGFcIjo2OTcsXCJvXCI6XCJtIDYwNCAyMTcgcSA1MDEgMzYgNjA0IDEwNCBxIDI5MiAtMjMgNDExIC0yMyBxIDg2IDQzIDE2NiAtMjMgcSAwIDIzOCAwIDExNCBsIDEyMSAyMzcgcSAxNzUgMTIyIDEyMSAxNjQgcSAzMDAgODUgMjIzIDg1IHEgNDE1IDExMiAzNjMgODUgcSA0NzkgMjA3IDQ3OSAxNDcgcSAzNjEgMzA5IDQ3OSAyNzYgcSAxNDAgMzcyIDE0MSAzNzAgcSAyMSA1NDQgMjEgNDI2IHEgMTExIDcwOCAyMSA2NDcgcSAyOTggNzYxIDE5MCA3NjEgcSA0OTIgNzA1IDQxMyA3NjEgcSA1ODMgNTMxIDU4MyA2NDMgbCA0NjIgNTMxIHEgNDEyIDYyNSA0NjIgNTk0IHEgMjk4IDY1NyAzNjMgNjU3IHEgMTk5IDYzNiAyNDIgNjU3IHEgMTQzIDU1OCAxNDMgNjA4IHEgMjYyIDQ1NCAxNDMgNDg2IHEgNDg0IDM5NCA0NzkgMzk3IHEgNjA0IDIxNyA2MDQgMzQxIFwifSxcIkJcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjc3OCxcImhhXCI6ODc2LFwib1wiOlwibSA1ODAgNTQ2IHEgNzI0IDQ2OSA2NzAgNTM1IHEgNzc4IDMxMSA3NzggNDAzIHEgNjczIDgzIDc3OCAxNzEgcSA0MzIgMCA1NzUgMCBsIDAgMCBsIDAgMTAxMyBsIDQxMSAxMDEzIHEgNjI5IDk1NyA1NDEgMTAxMyBxIDczMiA3NjggNzMyIDg5MiBxIDY5MSA2MzMgNzMyIDY5MyBxIDU4MCA1NDYgNjUwIDU3MiBtIDM5MyA4OTkgbCAxMzkgODk5IGwgMTM5IDU4OCBsIDM3OSA1ODggcSA1MjEgNjI0IDQ2MiA1ODggcSA1OTIgNzQ0IDU5MiA2NjcgcSA1MzEgODU5IDU5MiA4MTkgcSAzOTMgODk5IDQ3MSA4OTkgbSA0MTkgMTI0IHEgNTY2IDE2OSA1MDQgMTI0IHEgNjM1IDMwMyA2MzUgMjE5IHEgNTU5IDQzNiA2MzUgMzg5IHEgNDAyIDQ3NyA0OTQgNDc3IGwgMTM5IDQ3NyBsIDEzOSAxMjQgbCA0MTkgMTI0IFwifSxcIu+/vVwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NjE0LFwiaGFcIjo3MDgsXCJvXCI6XCJtIDE0MiAwIGwgMCAwIGwgMCAxNTEgbCAxNDIgMTUxIGwgMTQyIDAgbSAzNzggMCBsIDIzNiAwIGwgMjM2IDE1MSBsIDM3OCAxNTEgbCAzNzggMCBtIDYxNCAwIGwgNDcyIDAgbCA0NzIgMTUxIGwgNjE0IDE1MSBsIDYxNCAwIFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjYwNyxcImhhXCI6NzA0LFwib1wiOlwibSA2MDcgNzc3IHEgNTQzIDU5OSA2MDcgNjc0IHEgNDIyIDQ3NCA0ODIgNTM3IHEgMzU3IDI3MiAzNTcgMzkxIGwgMjM2IDI3MiBxIDI5NyA0ODcgMjM2IDM5NSBxIDQxMSA2MTkgMjk4IDQ5MCBxIDQ3NCA3NjIgNDc0IDY5MSBxIDQyMiA4ODUgNDc0IDgzOCBxIDMwMSA5MzMgMzcxIDkzMyBxIDE3OSA4ODAgMjI4IDkzMyBxIDEyNCA3MDYgMTI0IDgxOSBsIDAgNzA2IHEgOTQgOTYzIDAgODcyIHEgMzAyIDEwNDQgMTc3IDEwNDQgcSA1MTEgOTczIDQyMyAxMDQ0IHEgNjA3IDc3NyA2MDcgODk1IG0gMzcwIDAgbCAyMzAgMCBsIDIzMCAxNTEgbCAzNzAgMTUxIGwgMzcwIDAgXCJ9LFwiSFwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6ODAzLFwiaGFcIjo5MTUsXCJvXCI6XCJtIDgwMyAwIGwgNjY3IDAgbCA2NjcgNDc1IGwgMTQwIDQ3NSBsIDE0MCAwIGwgMCAwIGwgMCAxMDEzIGwgMTQwIDEwMTMgbCAxNDAgNTk5IGwgNjY3IDU5OSBsIDY2NyAxMDEzIGwgODAzIDEwMTMgbCA4MDMgMCBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo2NzUsXCJoYVwiOjc2MSxcIm9cIjpcIm0gNjc1IDczOCBsIDQwNCAwIGwgMjcyIDAgbCAwIDczOCBsIDEzMyA3MzggbCAzNDAgMTQ3IGwgNTQxIDczOCBsIDY3NSA3MzggXCJ9LFwiY1wiOntcInhfbWluXCI6MSxcInhfbWF4XCI6NzAxLjM5MDYyNSxcImhhXCI6Nzc1LFwib1wiOlwibSA3MDEgMjY0IHEgNTg0IDUzIDY4MSAxMzMgcSAzNTMgLTI2IDQ4NyAtMjYgcSA5MSA5MSAxODggLTI2IHEgMSAzNzAgMSAyMDEgcSA5MiA2NDUgMSA1MzcgcSAzNTMgNzYxIDE5MCA3NjEgcSA1NzIgNjg4IDQ3OSA3NjEgcSA2OTAgNDkzIDY2NiA2MTUgbCA1NTYgNDkzIHEgNDg3IDYwNiA1NDUgNTYyIHEgMzU2IDY1MCA0MjggNjUwIHEgMTg2IDU2MyAyNDYgNjUwIHEgMTM0IDM3MiAxMzQgNDg3IHEgMTg4IDE3OSAxMzQgMjU4IHEgMzU5IDg4IDI1MCA4OCBxIDQ5MiAxMzYgNDM3IDg4IHEgNTY2IDI2NCA1NDggMTg1IGwgNzAxIDI2NCBcIn0sXCLvv71cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjU2Ni42NzE4NzUsXCJoYVwiOjY3OCxcIm9cIjpcIm0gMjEgODkyIGwgNTIgODkyIGwgOTggNzYxIGwgMTQ1IDg5MiBsIDE3NiA4OTIgbCAxNzggNzQxIGwgMTU3IDc0MSBsIDE1NyA4NjcgbCAxMDggNzQxIGwgODggNzQxIGwgNDAgODcxIGwgNDAgNzQxIGwgMjEgNzQxIGwgMjEgODkyIG0gMzA4IDg1NCBsIDMwOCA3MzEgcSAyNTIgNjkxIDMwOCA2OTEgcSAyMjcgNjkxIDI0MCA2OTEgcSAyMDcgNjk2IDIxMyA2OTUgbCAyMDcgNzEyIGwgMjUzIDcwNiBxIDI4OCA3MzMgMjg4IDcwNiBsIDI4OCA3NjMgcSAyNDQgNzQxIDI3OSA3NDEgcSAxOTMgNzk3IDE5MyA3NDEgcSAyNjEgODYwIDE5MyA4NjAgcSAyODcgODYwIDI3MyA4NjAgcSAzMDggODU0IDMwMiA4NTUgbSAyODggODQyIGwgMjYzIDg0MyBxIDIxMyA3OTYgMjEzIDg0MyBxIDI0OCA3NTYgMjEzIDc1NiBxIDI4OCA3OTYgMjg4IDc1NiBsIDI4OCA4NDIgbSA1NjYgOTg4IGwgNTAyIDk4OCBsIDUwMiAtMSBsIDQzOSAtMSBsIDQzOSA5ODggbCAzMTcgOTg4IGwgMzE3IC0xIGwgMjUyIC0xIGwgMjUyIDYwMiBxIDgxIDY1MyAxNTUgNjAyIHEgMCA4MDUgMCA3MTEgcSAxMDEgOTg5IDAgOTE4IHEgMzA5IDEwNTMgMTk0IDEwNTMgbCA1NjYgMTA1MyBsIDU2NiA5ODggXCJ9LFwiP1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NjYwLFwiaGFcIjo3NDUsXCJvXCI6XCJtIDQ3MSA1NTAgcSA2MTAgNDUwIDU2MSA1MjIgcSA2NjAgMjgwIDY2MCAzNzggcSA1NzggNjQgNjYwIDE1MSBxIDM2NyAtMjIgNDk3IC0yMiBxIDIzOSA1IDI5OSAtMjIgcSAxMjYgODIgMTc4IDMyIGwgMTI2IC0yNzggbCAwIC0yNzggbCAwIDU5MyBxIDU0IDkwMyAwIDgwMSBxIDMxOCAxMDQyIDEyNyAxMDQyIHEgNTE5IDk2NCA0MzYgMTA0MiBxIDYwMyA3NzEgNjAzIDg4NyBxIDU2NyA2NDQgNjAzIDcwMSBxIDQ3MSA1NTAgNTMyIDU4NiBtIDMzNyA3OSBxIDQ3NiAxMzggNDE4IDc5IHEgNTM1IDI3OSA1MzUgMTk4IHEgNDI3IDQzNyA1MzUgMzg2IHEgMjI2IDQ3NyAzNDQgNDc3IGwgMjI2IDU4MyBxIDM5OCA2MjAgMzI5IDU4MyBxIDQ4NiA3NjIgNDg2IDY2OCBxIDQzNSA4ODQgNDg2IDgzMyBxIDMxMiA5MzUgMzg0IDkzNSBxIDE2OSA4NjEgMjE5IDkzNSBxIDEyNiA2OTggMTI2IDc5NyBsIDEyNiAzNjIgcSAxNzAgMTY5IDEyNiAyNDIgcSAzMzcgNzkgMjI0IDc5IFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjk1NCxcImhhXCI6MTA2OCxcIm9cIjpcIm0gOTU0IDAgbCA4MTkgMCBsIDgxOSA4NjggbCA1MzcgMCBsIDQwNSAwIGwgMTI4IDg2NSBsIDEyOCAwIGwgMCAwIGwgMCAxMDEzIGwgMTk5IDEwMTMgbCA0NzIgMTU4IGwgNzU4IDEwMTMgbCA5NTQgMTAxMyBsIDk1NCAwIFwifSxcIj9cIjp7XCJ4X21pblwiOjAuMTA5Mzc1LFwieF9tYXhcIjoxMTIwLFwiaGFcIjoxMjE3LFwib1wiOlwibSAxMTIwIDUwNSBxIDk5NCAxMzIgMTEyMCAyODIgcSA2NDIgLTI5IDg2MSAtMjkgcSAyOTAgMTMwIDQyMiAtMjkgcSAxNjcgNTA1IDE2NyAyODAgcSAyOTQgODgzIDE2NyA3MzAgcSA2NTAgMTA0NiA0MzAgMTA0NiBxIDk5OSA4ODIgODY4IDEwNDYgcSAxMTIwIDUwNSAxMTIwIDczMCBtIDk3NyA1MDQgcSA4OTYgNzg0IDk3NyA2NjkgcSA2NDQgOTE1IDgwNCA5MTUgcSAzOTEgNzg1IDQ4NCA5MTUgcSAzMDcgNTA0IDMwNyA2NjkgcSAzOTEgMjI0IDMwNyAzMzkgcSA2NDQgOTUgNDg2IDk1IHEgODk0IDIyNCA4MDMgOTUgcSA5NzcgNTA0IDk3NyAzMzkgbSAyNzcgMTA0MCBsIDgzIDc5OSBsIDAgNzk5IGwgMTQwIDEwNDAgbCAyNzcgMTA0MCBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjoxMTU4LFwiaGFcIjoxMjc1LFwib1wiOlwibSAxMTU4IDAgbCAxMDIyIDAgbCAxMDIyIDQ3NSBsIDQ5NiA0NzUgbCA0OTYgMCBsIDM1NiAwIGwgMzU2IDEwMTIgbCA0OTYgMTAxMiBsIDQ5NiA1OTkgbCAxMDIyIDU5OSBsIDEwMjIgMTAxMiBsIDExNTggMTAxMiBsIDExNTggMCBtIDI3NyAxMDQwIGwgODMgNzk5IGwgMCA3OTkgbCAxNDAgMTA0MCBsIDI3NyAxMDQwIFwifSxcIu+/vVwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NjYzLjg5MDYyNSxcImhhXCI6Nzc1LFwib1wiOlwibSA2NjMgNTI5IHEgNTY2IDI5MyA2NjMgMzkxIHEgMzMxIDE5NiA0NjkgMTk2IHEgOTcgMjk0IDE5NCAxOTYgcSAwIDUyOSAwIDM5MyBxIDk2IDc2MyAwIDY2NSBxIDMzMSA4NjEgMTkzIDg2MSBxIDU2NiA3NjMgNDY5IDg2MSBxIDY2MyA1MjkgNjYzIDY2NSBcIn0sXCLvv71cIjp7XCJ4X21pblwiOjAuMTg3NSxcInhfbWF4XCI6ODE5LjU0Njg3NSxcImhhXCI6ODg2LFwib1wiOlwibSA1NjMgNTYxIGwgNjk3IDU2MSBsIDY5NiA0ODcgbCA1MjAgNDg3IGwgNDgyIDQxNiBsIDQ4MiAzODAgbCA2OTcgMzgwIGwgNjk1IDMwOCBsIDQ4MiAzMDggbCA0ODIgMCBsIDM0MiAwIGwgMzQyIDMwOCBsIDEyNSAzMDggbCAxMjUgMzgwIGwgMzQyIDM4MCBsIDM0MiA0MTcgbCAzMDMgNDg3IGwgMTI1IDQ4NyBsIDEyNSA1NjEgbCAyNTggNTYxIGwgMCAxMDEzIGwgMTQwIDEwMTMgbCA0MTEgNTMzIGwgNjc5IDEwMTMgbCA4MTkgMTAxMyBsIDU2MyA1NjEgXCJ9LFwiKFwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6MzE4LjA2MjUsXCJoYVwiOjQxNSxcIm9cIjpcIm0gMzE4IC0yOTAgbCAyMzAgLTI5MCBxIDYxIDIzIDEyMiAtMTQyIHEgMCAzNjUgMCAxOTAgcSA2MiA3MTIgMCA1NDAgcSAyMzAgMTAyNCAxMTkgODY5IGwgMzE4IDEwMjQgcSAxNzUgNzA1IDIxOSA4NTMgcSAxMjUgMzYwIDEyNSA1NDIgcSAxNzYgMjIgMTI1IDE4NyBxIDMxOCAtMjkwIDIyMyAtMTI3IFwifSxcIlVcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjc5NixcImhhXCI6OTA0LFwib1wiOlwibSA3OTYgMzkzIHEgNjgxIDkzIDc5NiAyMTIgcSAzODYgLTI1IDU2NiAtMjUgcSAxMDEgOTUgMjA4IC0yNSBxIDAgMzkzIDAgMjExIGwgMCAxMDEzIGwgMTM4IDEwMTMgbCAxMzggMzkxIHEgMjA0IDE5MSAxMzggMjcwIHEgMzk0IDEwNyAyNzYgMTA3IHEgNTg2IDE5MSA1MTIgMTA3IHEgNjU2IDM5MSA2NTYgMjcwIGwgNjU2IDEwMTMgbCA3OTYgMTAxMyBsIDc5NiAzOTMgXCJ9LFwiP1wiOntcInhfbWluXCI6MC41LFwieF9tYXhcIjo3NDQuOTUzMTI1LFwiaGFcIjo4MjIsXCJvXCI6XCJtIDc0NCA3MzcgbCA0NjMgNTQgbCA0NjMgLTI3OCBsIDMzOCAtMjc4IGwgMzM4IDU0IGwgMTU0IDQ5NSBxIDEwNCA1OTcgMTI0IDU2OSBxIDEzIDY1MSA2NyA2NTEgbCAwIDY1MSBsIDAgNzUxIGwgMzkgNzUzIHEgMTY4IDcxMSAxMjEgNzUzIHEgMjQyIDU5NCAyMDcgNjc2IGwgNDAzIDIwOCBsIDYxNyA3MzcgbCA3NDQgNzM3IFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjc2NS41NjI1LFwiaGFcIjo4MDksXCJvXCI6XCJtIDc2NSAtNCBxIDY5OCAtMTQgNzI2IC0xNCBxIDU2NCA5NyA1ODYgLTE0IHEgNDY2IDcgNTI1IDQwIHEgMzM3IC0yNiA0MDcgLTI2IHEgODggOTggMTg2IC0yNiBxIDAgMzY5IDAgMjEyIHEgODggNjM3IDAgNTI1IHEgMzM3IDc2MCAxODQgNzYwIHEgNDY1IDcyOCA0MDcgNzYwIHEgNTYzIDYzNyA1MjQgNjk2IGwgNTYzIDczOSBsIDY4NSA3MzkgbCA2ODUgMjIyIHEgNjkzIDE0MSA2ODUgMTY4IHEgNzQ4IDk0IDcwOCA5NCBxIDc2NSA5NiA3NjAgOTQgbCA3NjUgLTQgbSA1ODQgMzcxIHEgNTMxIDU2MiA1ODQgNDg1IHEgMzYwIDY1MyA0NzAgNjUzIHEgMTkyIDU2NiAyNTQgNjUzIHEgMTM1IDM3OSAxMzUgNDg5IHEgMTg2IDE4MSAxMzUgMjYxIHEgMzU4IDg0IDI0NyA4NCBxIDUyOCAxNzYgNDY1IDg0IHEgNTg0IDM3MSA1ODQgMjYwIFwifSxcIkZcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjY4My4zMjgxMjUsXCJoYVwiOjcxNyxcIm9cIjpcIm0gNjgzIDg4OCBsIDE0MCA4ODggbCAxNDAgNTgzIGwgNjEzIDU4MyBsIDYxMyA0NTggbCAxNDAgNDU4IGwgMTQwIDAgbCAwIDAgbCAwIDEwMTMgbCA2ODMgMTAxMyBsIDY4MyA4ODggXCJ9LFwi77+9XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo3MDUuNTYyNSxcImhhXCI6ODAzLFwib1wiOlwibSA3MDUgMzM0IGwgMCAzMzQgbCAwIDQxMCBsIDcwNSA0MTAgbCA3MDUgMzM0IFwifSxcIjpcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjE0MixcImhhXCI6MjM5LFwib1wiOlwibSAxNDIgNTg1IGwgMCA1ODUgbCAwIDczOCBsIDE0MiA3MzggbCAxNDIgNTg1IG0gMTQyIDAgbCAwIDAgbCAwIDE1MSBsIDE0MiAxNTEgbCAxNDIgMCBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo4NTQuMTcxODc1LFwiaGFcIjo5MzUsXCJvXCI6XCJtIDg1NCAwIGwgNjgzIDAgbCA0MjMgNDA5IGwgMTY2IDAgbCAwIDAgbCAzNDcgNTE5IGwgMTggMTAxMyBsIDE4NiAxMDEzIGwgNDI3IDYzNyBsIDY3NSAxMDEzIGwgODM2IDEwMTMgbCA1MDQgNTIxIGwgODU0IDAgXCJ9LFwiKlwiOntcInhfbWluXCI6MTE2LFwieF9tYXhcIjo2NzQsXCJoYVwiOjc5MixcIm9cIjpcIm0gNjc0IDc2OCBsIDQ3NSA3MTMgbCA2MTAgNTQ0IGwgNTE3IDQ3NyBsIDM5NCA2NTIgbCAyNzIgNDc4IGwgMTc4IDU0NCBsIDMxNCA3MTMgbCAxMTYgNzY2IGwgMTUzIDg3NiBsIDM0MSA4MTIgbCAzNDIgMTAxMyBsIDQ0NiAxMDEzIGwgNDQ2IDgxMSBsIDYzNSA4NzQgbCA2NzQgNzY4IFwifSxcIu+/vVwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6Nzc3LFwiaGFcIjo4MzUsXCJvXCI6XCJtIDQ1OCA4MDQgbCA3NzcgODA0IGwgNzc3IDY4MyBsIDQ1OCA2ODMgbCA0NTggMCBsIDMxOSAwIGwgMzE5IDY4MSBsIDAgNjgzIGwgMCA4MDQgbCAzMTkgODA0IGwgMzE5IDEwMTUgbCA0NTggMTAxMyBsIDQ1OCA4MDQgXCJ9LFwi77+9XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjozNDcsXCJoYVwiOjQ0NCxcIm9cIjpcIm0gMTczIDgwMiBxIDQzIDg1NiA5MSA4MDIgcSAwIDk3NyAwIDkwNSBxIDQ1IDExMDEgMCAxMDQ5IHEgMTczIDExNTMgOTAgMTE1MyBxIDMwMyAxMDk4IDI1NSAxMTUzIHEgMzQ3IDk3NyAzNDcgMTA0OSBxIDMwMyA4NTYgMzQ3IDkwNSBxIDE3MyA4MDIgMjU2IDgwMiBtIDE3MyA4ODQgcSAyMzggOTEwIDIxNCA4ODQgcSAyNjIgOTczIDI2MiA5MzcgcSAyMzkgMTAzOCAyNjIgMTAxMiBxIDE3MyAxMDY0IDIxNyAxMDY0IHEgMTA4IDEwMzcgMTMyIDEwNjQgcSA4NSA5NzMgODUgMTAxMCBxIDEwOCA5MTAgODUgOTM3IHEgMTczIDg4NCAxMzIgODg0IFwifSxcIlZcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjg2Mi43MTg3NSxcImhhXCI6OTQwLFwib1wiOlwibSA4NjIgMTAxMyBsIDUwNSAwIGwgMzYxIDAgbCAwIDEwMTMgbCAxNDMgMTAxMyBsIDQzNCAxNjUgbCA3MTggMTAxMiBsIDg2MiAxMDEzIFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjczNC43MTg3NSxcImhhXCI6NzYzLFwib1wiOlwibSA3MjMgODg5IGwgOSA4ODkgbCA5IDEwMTMgbCA3MjMgMTAxMyBsIDcyMyA4ODkgbSA2NzMgNDYzIGwgNjEgNDYzIGwgNjEgNTg5IGwgNjczIDU4OSBsIDY3MyA0NjMgbSA3MzQgMCBsIDAgMCBsIDAgMTI0IGwgNzM0IDEyNCBsIDczNCAwIFwifSxcIu+/vVwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6MCxcImhhXCI6ODUzfSxcIj9cIjp7XCJ4X21pblwiOjAuMzI4MTI1LFwieF9tYXhcIjo4MTkuNTE1NjI1LFwiaGFcIjo4ODksXCJvXCI6XCJtIDU4OCAxMDQ2IGwgNDYwIDEwNDYgbCA0NjAgMTE4OSBsIDU4OCAxMTg5IGwgNTg4IDEwNDYgbSAzNjAgMTA0NiBsIDIzMiAxMDQ2IGwgMjMyIDExODkgbCAzNjAgMTE4OSBsIDM2MCAxMDQ2IG0gODE5IDEwMTIgbCA0ODIgNDE2IGwgNDgyIDAgbCAzNDIgMCBsIDM0MiA0MTYgbCAwIDEwMTIgbCAxNDAgMTAxMiBsIDQxMSA1MzMgbCA2NzkgMTAxMiBsIDgxOSAxMDEyIFwifSxcIjBcIjp7XCJ4X21pblwiOjczLFwieF9tYXhcIjo3MTUsXCJoYVwiOjc5MixcIm9cIjpcIm0gMzk0IC0yOSBxIDE1MyAxMjkgMjQyIC0yOSBxIDczIDQ3OSA3MyAyNzIgcSAxNTIgODI5IDczIDY4NyBxIDM5NCA5ODkgMjQxIDk4OSBxIDYzNCA4MjkgNTQ1IDk4OSBxIDcxNSA0NzkgNzE1IDY4NCBxIDYzNSAxMjkgNzE1IDI3MCBxIDM5NCAtMjkgNTQ2IC0yOSBtIDM5NCA4OSBxIDU0NiAyMTEgNDg5IDg5IHEgNTk4IDQ3OSA1OTggMzIyIHEgNTQ4IDc0OCA1OTggNjQwIHEgMzk0IDg3MSA0OTEgODcxIHEgMjQxIDc0OCAyOTggODcxIHEgMTkwIDQ3OSAxOTAgNjM3IHEgMjM5IDIxMSAxOTAgMzE5IHEgMzk0IDg5IDI5NiA4OSBcIn0sXCLvv71cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjM0NyxcImhhXCI6NDU0LFwib1wiOlwibSAxMzkgODUxIHEgMTAyIDczNyAxMzkgNzg0IHEgMCA2NjkgNjUgNjkwIGwgMCA3MzQgcSA1OSA3ODcgNDIgNzQxIHEgNzIgODczIDcyIDgyMSBsIDAgODczIGwgMCAxMDEzIGwgMTM5IDEwMTMgbCAxMzkgODUxIG0gMzQ3IDg1MSBxIDMxMCA3MzcgMzQ3IDc4NCBxIDIwOCA2NjkgMjczIDY5MCBsIDIwOCA3MzQgcSAyNjcgNzg3IDI1MCA3NDEgcSAyODAgODczIDI4MCA4MjEgbCAyMDggODczIGwgMjA4IDEwMTMgbCAzNDcgMTAxMyBsIDM0NyA4NTEgXCJ9LFwiQFwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6MTI2MCxcImhhXCI6MTM1NyxcIm9cIjpcIm0gMTA5OCAtNDUgcSA4NzcgLTE2MCAxMDAxIC0xMTcgcSA2MzMgLTIwMyA3NTIgLTIwMyBxIDE1NSAtMjkgMzI3IC0yMDMgcSAwIDM2MCAwIDEyNyBxIDE3NiA4MDIgMCA2MTYgcSA2ODcgMTAwOCAzNzIgMTAwOCBxIDExMjMgODU0IDk2OSAxMDA4IHEgMTI2MCA1MTcgMTI2MCA3MTggcSAxMTU1IDIxNiAxMjYwIDM0MSBxIDg2OCA4MiAxMDQ0IDgyIHEgNzcyIDEwNiA4MDEgODIgcSA3MzcgMjAyIDczNyAxMzUgcSA2NDcgMTEzIDcwMCAxNDQgcSA1MjcgODIgNTk0IDgyIHEgMzY3IDE0NyA0MjAgODIgcSAzMTQgMzEyIDMxNCAyMTIgcSA0MDEgNTY1IDMxNCA0NTIgcSA2MzkgNjkwIDQ5OCA2OTAgcSA4MTAgNTg4IDc2MCA2OTAgbCA4NDkgNjY4IGwgOTM4IDY2OCBxIDg3NyA0NDEgOTAwIDUzMiBxIDgzMyAyMjYgODMzIDI2OCBxIDg1MyAxODIgODMzIDE5OCBxIDkwMiAxNjcgODczIDE2NyBxIDEwODggMjcyIDEwMTIgMTY3IHEgMTE1OSA1MTIgMTE1OSAzNzIgcSAxMDUxIDc5MyAxMTU5IDY4MSBxIDY4NyA5MjUgOTI1IDkyNSBxIDI0OCA3NDcgNDE1IDkyNSBxIDk3IDM2MSA5NyA1ODYgcSAyMjYgMjYgOTcgMTU5IHEgNjI3IC0xMjIgMzcwIC0xMjIgcSA4NTYgLTg3IDczNyAtMTIyIHEgMTA2MSA4IDk3NiAtNTMgbCAxMDk4IC00NSBtIDc4NiA0ODggcSA3MzggNTgwIDc3NyA1NDUgcSA2NDMgNjE1IDcwMCA2MTUgcSA0ODMgNTE3IDU0OCA2MTUgcSA0MjUgMzIyIDQyNSA0MzAgcSA0NTcgMjAzIDQyNSAyNTAgcSA1NTIgMTU2IDQ5MCAxNTYgcSA3MjIgMjczIDY2NSAxNTYgcSA3ODYgNDg4IDczOCAzMDkgXCJ9LFwiP1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NDk5LFwiaGFcIjo2MTMsXCJvXCI6XCJtIDI3NyAxMDQwIGwgODMgNzk5IGwgMCA3OTkgbCAxNDAgMTA0MCBsIDI3NyAxMDQwIG0gNDk5IDAgbCAzNjAgMCBsIDM2MCAxMDEyIGwgNDk5IDEwMTIgbCA0OTkgMCBcIn0sXCJpXCI6e1wieF9taW5cIjoxNCxcInhfbWF4XCI6MTM2LFwiaGFcIjoyNzUsXCJvXCI6XCJtIDEzNiA4NzMgbCAxNCA4NzMgbCAxNCAxMDEzIGwgMTM2IDEwMTMgbCAxMzYgODczIG0gMTM2IDAgbCAxNCAwIGwgMTQgNzM3IGwgMTM2IDczNyBsIDEzNiAwIFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjc3OCxcImhhXCI6ODc3LFwib1wiOlwibSA1ODAgNTQ1IHEgNzI0IDQ2OCA2NzEgNTM0IHEgNzc4IDMxMCA3NzggNDAyIHEgNjczIDgzIDc3OCAxNzAgcSA0MzIgMCA1NzUgMCBsIDAgMCBsIDAgMTAxMyBsIDQxMSAxMDEzIHEgNjI5IDk1NyA1NDEgMTAxMyBxIDczMiA3NjggNzMyIDg5MSBxIDY5MSA2MzIgNzMyIDY5MiBxIDU4MCA1NDUgNjUwIDU3MSBtIDM5MyA4OTkgbCAxMzkgODk5IGwgMTM5IDU4NyBsIDM3OSA1ODcgcSA1MjEgNjIzIDQ2MiA1ODcgcSA1OTIgNzQ0IDU5MiA2NjYgcSA1MzEgODU5IDU5MiA4MTkgcSAzOTMgODk5IDQ3MSA4OTkgbSA0MTkgMTI0IHEgNTY2IDE2OSA1MDQgMTI0IHEgNjM1IDMwMiA2MzUgMjE5IHEgNTU5IDQzNSA2MzUgMzg4IHEgNDAyIDQ3NiA0OTQgNDc2IGwgMTM5IDQ3NiBsIDEzOSAxMjQgbCA0MTkgMTI0IFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjYxNyxcImhhXCI6NzI1LFwib1wiOlwibSA2MTcgMzUyIHEgNTQwIDk0IDYxNyAxOTkgcSAzMDggLTI0IDQ1NSAtMjQgcSA3NiA5NCAxNjEgLTI0IHEgMCAzNTIgMCAxOTkgbCAwIDczOSBsIDEyNiA3MzkgbCAxMjYgMzU1IHEgMTY5IDE4NSAxMjYgMjU3IHEgMzEyIDk4IDIyMCA5OCBxIDQ1MSAxODUgNDAyIDk4IHEgNDkyIDM1NSA0OTIgMjU3IGwgNDkyIDczOSBsIDYxNyA3MzkgbCA2MTcgMzUyIFwifSxcIl1cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjI3NSxcImhhXCI6MzcyLFwib1wiOlwibSAyNzUgLTI4MSBsIDAgLTI4MSBsIDAgLTE4NyBsIDE1MSAtMTg3IGwgMTUxIDkyMCBsIDAgOTIwIGwgMCAxMDEzIGwgMjc1IDEwMTMgbCAyNzUgLTI4MSBcIn0sXCJtXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjoxMDE5LFwiaGFcIjoxMTI4LFwib1wiOlwibSAxMDE5IDAgbCA4OTcgMCBsIDg5NyA0NTQgcSA4NjAgNTkxIDg5NyA1MzYgcSA3MzkgNjYwIDgxNiA2NjAgcSA2MTMgNTg2IDY1OSA2NjAgcSA1NzMgNDM2IDU3MyA1MjIgbCA1NzMgMCBsIDQ0NyAwIGwgNDQ3IDQ1NSBxIDQxMiA1OTEgNDQ3IDUzNSBxIDI5NCA2NTcgMzcyIDY1NyBxIDE2NSA1ODYgMjEzIDY1NyBxIDEyMiA0MzcgMTIyIDUyMSBsIDEyMiAwIGwgMCAwIGwgMCA3MzggbCAxMTcgNzM4IGwgMTE3IDY0MCBxIDIwMiA3MzAgMTUwIDY5NyBxIDMxNiA3NjMgMjU0IDc2MyBxIDQzNyA3MzAgMzgxIDc2MyBxIDUyNSA2NDIgNDk0IDY5NyBxIDYyMSA3MzEgNTU5IDcwMCBxIDc1MyA3NjMgNjgyIDc2MyBxIDk0MyA2OTQgODY3IDc2MyBxIDEwMTkgNTEyIDEwMTkgNjI1IGwgMTAxOSAwIFwifSxcIj9cIjp7XCJ4X21pblwiOjguMzI4MTI1LFwieF9tYXhcIjo3ODAuNTYyNSxcImhhXCI6ODE1LFwib1wiOlwibSA3ODAgLTI3OCBxIDcxNSAtMjk0IDc0NyAtMjk0IHEgNjE2IC0yNTcgNjYzIC0yOTQgcSA1NDggLTE3NSA1NzYgLTIyNyBsIDM3OSAxMzMgbCAxNDMgLTI3NyBsIDkgLTI3NyBsIDMxMyAyNTQgbCAxNjMgNTIyIHEgMTI3IDU4NiAxMzEgNTgwIHEgMzYgNjQwIDkxIDY0MCBxIDggNjM3IDI3IDY0MCBsIDggNzUyIGwgNTIgNzU3IHEgMTYyIDcxOSAxMTMgNzU3IHEgMjM2IDYyNyAyMDAgNjkwIGwgMzgzIDM3MiBsIDU5NCA3MzcgbCA3MjYgNzM3IGwgNDQ4IDI1MCBsIDYyNSAtNjkgcSA2NzAgLTE1MyA2NDcgLTExMCBxIDc0MyAtMTg4IDY5NSAtMTg4IHEgNzgwIC0xODQgNzU5IC0xODggbCA3ODAgLTI3OCBcIn0sXCI4XCI6e1wieF9taW5cIjo1NSxcInhfbWF4XCI6NzM2LFwiaGFcIjo3OTIsXCJvXCI6XCJtIDU3MSA1MjcgcSA2OTQgNDI0IDY1MiA0OTEgcSA3MzYgMjgwIDczNiAzNTggcSA2NDggNzEgNzM2IDE1OCBxIDM5NSAtMjYgNTUxIC0yNiBxIDE0MiA2OSAyMzggLTI2IHEgNTUgMjc5IDU1IDE1NyBxIDk2IDQyNSA1NSAzNTkgcSAyMjAgNTI3IDEzOCA0OTEgcSAxMjAgNjE1IDE1MyA1NjIgcSA4OCA3MjYgODggNjY4IHEgMTcxIDkwNCA4OCA4MjcgcSAzOTUgOTg2IDI2MSA5ODYgcSA2MTggOTA1IDUyOSA5ODYgcSA3MDIgNzI3IDcwMiA4MzAgcSA2NzAgNjE2IDcwMiA2NjcgcSA1NzEgNTI3IDYzOCA1NjUgbSAzOTQgNTY1IHEgNTE5IDYxMCA0NzUgNTY1IHEgNTYzIDcxNyA1NjMgNjU1IHEgNTIxIDgyMyA1NjMgNzgxIHEgMzkyIDg3MiA0NzQgODcyIHEgMjY1IDgyNCAzMTIgODcyIHEgMjI0IDcyMCAyMjQgNzgzIHEgMjY1IDYxMyAyMjQgNjU2IHEgMzk0IDU2NSAzMTIgNTY1IG0gMzk1IDkxIHEgNTQ1IDE1MCA0ODggOTEgcSA1OTcgMjgwIDU5NyAyMDQgcSA1NDYgNDA4IDU5NyAzNTUgcSAzOTUgNDY1IDQ5MiA0NjUgcSAyNDQgNDA4IDI5OSA0NjUgcSAxOTQgMjgwIDE5NCAzNTYgcSAyNDQgMTUwIDE5NCAyMDMgcSAzOTUgOTEgMjk5IDkxIFwifSxcIj9cIjp7XCJ4X21pblwiOjQyLFwieF9tYXhcIjozMjYuNzE4NzUsXCJoYVwiOjM2MSxcIm9cIjpcIm0gMjg0IDMgcSAyMzMgLTEwIDI1OCAtNSBxIDE4MiAtMTUgMjA3IC0xNSBxIDg1IDI2IDExOSAtMTUgcSA0MiAyMDAgNDIgNzkgbCA0MiA3MzcgbCAxNjcgNzM3IGwgMTY4IDIxNSBxIDE3MiAxNDEgMTY4IDE1NyBxIDIyNiAxMDEgMTgzIDEwMSBxIDI0OCAxMDIgMjM5IDEwMSBxIDI4NCAxMTIgMjU3IDEwNCBsIDI4NCAzIG0gMzI2IDEwNDAgbCAxMzcgODE5IGwgNTQgODE5IGwgMTg5IDEwNDAgbCAzMjYgMTA0MCBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo3NzkuMTcxODc1LFwiaGFcIjo4NTAsXCJvXCI6XCJtIDc3OSAwIGwgMCAwIGwgMCAxMTMgbCA2MjAgODk2IGwgNDAgODk2IGwgNDAgMTAxMyBsIDc3OSAxMDEzIGwgNzc5IDg4NyBsIDE3MCAxMjQgbCA3NzkgMTI0IGwgNzc5IDAgXCJ9LFwiUlwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NzgxLjk1MzEyNSxcImhhXCI6OTA3LFwib1wiOlwibSA3ODEgMCBsIDYyMyAwIHEgNTg3IDI0MiA1OTAgNTIgcSA0MDcgNDMzIDU4NSA0MzMgbCAxMzggNDMzIGwgMTM4IDAgbCAwIDAgbCAwIDEwMTMgbCAzOTYgMTAxMyBxIDYzNiA5NDYgNTM5IDEwMTMgcSA3NDkgNzMxIDc0OSA4NjggcSA3MTEgNTk3IDc0OSA2NTkgcSA2MDggNTAyIDY3NCA1MzQgcSA3MTggMzcwIDY5NiA0NzQgcSA3MjkgMjA3IDcyMiAzNTIgcSA3ODEgMjYgNzM2IDYyIGwgNzgxIDAgbSAzNzMgNTUxIHEgNTMzIDU5NCA0NjUgNTUxIHEgNjE0IDczMSA2MTQgNjQ1IHEgNTMyIDg1OSA2MTQgODE1IHEgMzczIDg5NiA0NjUgODk2IGwgMTM4IDg5NiBsIDEzOCA1NTEgbCAzNzMgNTUxIFwifSxcIm9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjcxMyxcImhhXCI6ODIxLFwib1wiOlwibSAzNTcgLTI1IHEgOTQgOTEgMTk0IC0yNSBxIDAgMzY4IDAgMjAyIHEgOTMgNjQyIDAgNTMzIHEgMzU3IDc2MSAxOTMgNzYxIHEgNjE4IDY0NCA1MTggNzYxIHEgNzEzIDM2OCA3MTMgNTMzIHEgNjE5IDkxIDcxMyAyMDEgcSAzNTcgLTI1IDUyMSAtMjUgbSAzNTcgODUgcSA1MjggMTc1IDQ2NSA4NSBxIDU4NCAzNjkgNTg0IDI1NSBxIDUyOSA1NjIgNTg0IDQ4NCBxIDM1NyA2NTEgNDY3IDY1MSBxIDE4OSA1NjAgMjUwIDY1MSBxIDEzNSAzNjkgMTM1IDQ4MSBxIDE4NyAxNzcgMTM1IDI1NyBxIDM1NyA4NSAyNTAgODUgXCJ9LFwiNVwiOntcInhfbWluXCI6NTQuMTcxODc1LFwieF9tYXhcIjo3MzgsXCJoYVwiOjc5MixcIm9cIjpcIm0gNzM4IDMxNCBxIDYyNiA2MCA3MzggMTUzIHEgMzgyIC0yMyA1MjYgLTIzIHEgMTU1IDQ3IDI0OCAtMjMgcSA1NCAyNTYgNTQgMTI1IGwgMTgzIDI1NiBxIDI1OSAxMzIgMjA0IDE3NCBxIDM4MiA5MSAzMTQgOTEgcSA1MzMgMTQ5IDQ3MSA5MSBxIDYwMiAzMTQgNjAyIDIxMyBxIDUzOCA0NjkgNjAyIDQxMSBxIDM4NiA1MjggNDc1IDUyOCBxIDI4NCA1MDYgMzMyIDUyOCBxIDE5NyA0MzkgMjM3IDQ4NCBsIDgxIDQzOSBsIDE1OSA5NTggbCA2ODQgOTU4IGwgNjg0IDg0MCBsIDI1NCA4NDAgbCAyMTQgNTc5IHEgMzA2IDYyNyAyNTggNjEyIHEgNDA3IDY0MyAzNTQgNjQzIHEgNjM2IDU1MiA1NDAgNjQzIHEgNzM4IDMxNCA3MzggNDU3IFwifSxcIjdcIjp7XCJ4X21pblwiOjU4LjcxODc1LFwieF9tYXhcIjo3MzAuOTUzMTI1LFwiaGFcIjo3OTIsXCJvXCI6XCJtIDczMCA4MzkgcSA0NjkgNDQ4IDU2MCA2NDEgcSAzMzUgMCAzNzggMjU1IGwgMTkyIDAgcSAzMjggNDQxIDIzNSAyNTIgcSA1OTMgODMwIDQyMSA2MzAgbCA1OCA4MzAgbCA1OCA5NTggbCA3MzAgOTU4IGwgNzMwIDgzOSBcIn0sXCJLXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo4MTkuNDY4NzUsXCJoYVwiOjkwNixcIm9cIjpcIm0gODE5IDAgbCA2NDkgMCBsIDI5NCA1MDkgbCAxMzkgMzU1IGwgMTM5IDAgbCAwIDAgbCAwIDEwMTMgbCAxMzkgMTAxMyBsIDEzOSA1MjYgbCA2MjYgMTAxMyBsIDgwOSAxMDEzIGwgMzk1IDYwMCBsIDgxOSAwIFwifSxcIixcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjE0MixcImhhXCI6MjM5LFwib1wiOlwibSAxNDIgLTEyIHEgMTA1IC0xMzIgMTQyIC04MiBxIDAgLTIwNSA2OCAtMTgyIGwgMCAtMTM4IHEgNTcgLTgyIDQwIC0xMjQgcSA3MCAwIDcwIC01MSBsIDAgMCBsIDAgMTUxIGwgMTQyIDE1MSBsIDE0MiAtMTIgXCJ9LFwiZFwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NjgzLFwiaGFcIjo3OTYsXCJvXCI6XCJtIDY4MyAwIGwgNTY0IDAgbCA1NjQgOTMgcSA0NTYgNiA1MTYgMzggcSAzMjcgLTI1IDM5NSAtMjUgcSA4NyAxMDAgMTgxIC0yNSBxIDAgMzY1IDAgMjE1IHEgOTAgNjM5IDAgNTI1IHEgMzQzIDc2MyAxODcgNzYzIHEgNTY0IDY0NyA0ODYgNzYzIGwgNTY0IDEwMTMgbCA2ODMgMTAxMyBsIDY4MyAwIG0gNTgyIDM3MyBxIDUyOSA1NjIgNTgyIDQ4NCBxIDM2MSA2NTMgNDY4IDY1MyBxIDE5MCA1NjEgMjUzIDY1MyBxIDEzNSAzNjUgMTM1IDQ3OSBxIDE4OSAxNzUgMTM1IDI1NCBxIDM1OCA4NSAyNTEgODUgcSA1MjkgMTc4IDQ2OCA4NSBxIDU4MiAzNzMgNTgyIDI1OCBcIn0sXCLvv71cIjp7XCJ4X21pblwiOi0xMDksXCJ4X21heFwiOjI0NyxcImhhXCI6MjMyLFwib1wiOlwibSAyNDcgMTA0NiBsIDExOSAxMDQ2IGwgMTE5IDExODkgbCAyNDcgMTE4OSBsIDI0NyAxMDQ2IG0gMTkgMTA0NiBsIC0xMDkgMTA0NiBsIC0xMDkgMTE4OSBsIDE5IDExODkgbCAxOSAxMDQ2IFwifSxcIkVcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjczNi4xMDkzNzUsXCJoYVwiOjc4OSxcIm9cIjpcIm0gNzM2IDAgbCAwIDAgbCAwIDEwMTMgbCA3MjUgMTAxMyBsIDcyNSA4ODkgbCAxMzkgODg5IGwgMTM5IDU4NSBsIDY3NyA1ODUgbCA2NzcgNDY3IGwgMTM5IDQ2NyBsIDEzOSAxMjUgbCA3MzYgMTI1IGwgNzM2IDAgXCJ9LFwiWVwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6ODIwLFwiaGFcIjo4ODYsXCJvXCI6XCJtIDgyMCAxMDEzIGwgNDgyIDQxNiBsIDQ4MiAwIGwgMzQyIDAgbCAzNDIgNDE2IGwgMCAxMDEzIGwgMTQwIDEwMTMgbCA0MTEgNTM0IGwgNjc5IDEwMTIgbCA4MjAgMTAxMyBcIn0sXCJcXFwiXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjoyOTksXCJoYVwiOjM5NixcIm9cIjpcIm0gMjk5IDYwNiBsIDIwMyA2MDYgbCAyMDMgOTg4IGwgMjk5IDk4OCBsIDI5OSA2MDYgbSA5NiA2MDYgbCAwIDYwNiBsIDAgOTg4IGwgOTYgOTg4IGwgOTYgNjA2IFwifSxcIu+/vVwiOntcInhfbWluXCI6MTcuOTg0Mzc1LFwieF9tYXhcIjo3NzMuNjA5Mzc1LFwiaGFcIjo3OTIsXCJvXCI6XCJtIDc3MyA0MCBsIDE4IDM3NiBsIDE3IDQ2NSBsIDc3MyA3OTkgbCA3NzMgNjkyIGwgMTU5IDQyMCBsIDc3MyAxNDkgbCA3NzMgNDAgXCJ9LFwi77+9XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjozNjQsXCJoYVwiOjQ2NyxcIm9cIjpcIm0gMTQxIC0xMiBxIDEwNCAtMTMyIDE0MSAtODIgcSAwIC0yMDUgNjcgLTE4MiBsIDAgLTEzOCBxIDU2IC04MiA0MCAtMTI0IHEgNjkgMCA2OSAtNTEgbCAwIDAgbCAwIDE1MSBsIDE0MSAxNTEgbCAxNDEgLTEyIG0gMzY0IC0xMiBxIDMyNyAtMTMyIDM2NCAtODIgcSAyMjIgLTIwNSAyOTAgLTE4MiBsIDIyMiAtMTM4IHEgMjc5IC04MiAyNjIgLTEyNCBxIDI5MiAwIDI5MiAtNTEgbCAyMjIgMCBsIDIyMiAxNTEgbCAzNjQgMTUxIGwgMzY0IC0xMiBcIn0sXCI/XCI6e1wieF9taW5cIjoxLFwieF9tYXhcIjo3MTAsXCJoYVwiOjgxMCxcIm9cIjpcIm0gNzEwIDM2MCBxIDYxNiA4NyA3MTAgMTk2IHEgMzU2IC0yOCA1MTggLTI4IHEgOTkgODIgMTk3IC0yOCBxIDEgMzU2IDEgMTkyIHEgMTAwIDYwNiAxIDUwOSBxIDM1NSA3MDMgMTk5IDcwMyBxIDE4MCA4MjkgMjg4IDc1NCBxIDcwIDkwMyAxMjQgODY2IGwgNzAgMTAxMiBsIDY0MyAxMDEyIGwgNjQzIDkwMSBsIDI1OCA5MDEgcSA0NjIgNzYzIDQyMiA3OTQgcSA2MzYgNTkyIDU3NyA2NzcgcSA3MTAgMzYwIDcxMCA0ODUgbSA1ODQgMzY1IHEgNTUyIDUwMSA1ODQgNDQ3IHEgNDUxIDYwMiA1MjEgNTU1IHEgMzcyIDYxMSA0MTEgNjExIHEgMTk3IDU0MSAyNTggNjExIHEgMTM2IDM1NSAxMzYgNDcyIHEgMTkwIDE3MSAxMzYgMjQ1IHEgMzU4IDg1IDI1MiA4NSBxIDUyOCAxNzMgNDY1IDg1IHEgNTg0IDM2NSA1ODQgMjUyIFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjYzNC43MTg3NSxcImhhXCI6NzE0LFwib1wiOlwibSA2MzQgMjM0IHEgNTI3IDM4IDYzNCAxMTAgcSAzMDAgLTI1IDQzMyAtMjUgcSA5OCAyOSAxODMgLTI1IHEgMCAyMDQgMCA5MyBxIDM3IDMxMyAwIDI2NSBxIDEyOCAzOTAgNjcgMzUyIHEgNTYgNDU5IDgyIDQxOSBxIDI2IDU1NSAyNiA1MDUgcSAxMTQgNzEyIDI2IDY1NCBxIDI5NSA3NjMgMTkxIDc2MyBxIDQ5OSA3MDAgNDE2IDc2MyBxIDU4OSA1MTUgNTg5IDYzMSBsIDQ3OCA1MTUgcSA0MTkgNjE4IDQ2NCA1ODAgcSAzMDcgNjU3IDM3NCA2NTcgcSAyMDcgNjMwIDI1MyA2NTcgcSAxNTEgNTQ3IDE1MSA1OTggcSAyMzggNDQ1IDE1MSA0NjkgcSAzODkgNDM0IDI4MCA0MzQgbCAzODkgMzMxIGwgMzQ5IDMzMSBxIDIwNiAzMTUgMjU1IDMzMSBxIDEyNSAyMTAgMTI1IDI4NyBxIDE4MyAxMDcgMTI1IDE0NSBxIDMwMiA3NiAyMzMgNzYgcSA0MzYgMTE3IDM3OSA3NiBxIDUwOSAyMzQgNDkzIDE1OSBsIDYzNCAyMzQgbSA1MjAgMTA0MCBsIDMzMSA4MTkgbCAyNDggODE5IGwgMzgzIDEwNDAgbCA1MjAgMTA0MCBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo5MjIsXCJoYVwiOjEwMzEsXCJvXCI6XCJtIDkyMiAzMzkgcSA4NTYgOTcgOTIyIDIwMyBxIDY1MCAtMjYgNzgwIC0yNiBxIDUzOCA5IDU4NyAtMjYgcSA0NjEgMTAzIDQ4OSA0NCBxIDM4NyAxMiA0MzYgNDYgcSAyNzcgLTIyIDMzOSAtMjIgcSA2OSA5NyAxNDcgLTIyIHEgMCAzMzkgMCAyMDMgcSA0NSA1NTEgMCA0NDQgcSAxNjEgNzM4IDg0IDY0MyBsIDMwMiA3MzggcSAxNzUgNTUzIDIxOSA2NDcgcSAxMjQgMzM2IDEyNCA0NDYgcSAxNTUgMTc5IDEyNCAyNDkgcSAyNzUgODggMTk3IDg4IHEgMzc1IDE2MyAzNDEgODggcSA0MDAgMjk0IDQwMCAyMTkgbCA0MDAgNTcyIGwgNTI0IDU3MiBsIDUyNCAyOTQgcSA1NjEgMTM1IDUyNCAxOTIgcSA2NDMgODggNTkxIDg4IHEgNzYyIDE4MiA3MTkgODggcSA3OTcgMzQyIDc5NyAyNTcgcSA3NDUgNTU2IDc5NyA0NTAgcSA2MTkgNzM4IDcwNSA2MzggbCA3NjAgNzM4IHEgODc0IDU1MSA4MzUgNjQwIHEgOTIyIDMzOSA5MjIgNDQ0IFwifSxcIu+/vVwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6OTYsXCJoYVwiOjI1MSxcIm9cIjpcIm0gOTYgNjA2IGwgMCA2MDYgbCAwIDk4OCBsIDk2IDk4OCBsIDk2IDYwNiBcIn0sXCLvv71cIjp7XCJ4X21pblwiOjExLFwieF9tYXhcIjo3ODEsXCJoYVwiOjc5MixcIm9cIjpcIm0gNzgxIDQ5MCBsIDQ0NiA0OTAgbCA0NDYgMjU1IGwgMzQ5IDI1NSBsIDM0OSA0OTAgbCAxMSA0OTAgbCAxMSA1ODYgbCAzNDkgNTg2IGwgMzQ5IDgxOSBsIDQ0NiA4MTkgbCA0NDYgNTg2IGwgNzgxIDU4NiBsIDc4MSA0OTAgbSA3ODEgMjEgbCAxMSAyMSBsIDExIDExNSBsIDc4MSAxMTUgbCA3ODEgMjEgXCJ9LFwifFwiOntcInhfbWluXCI6MzQzLFwieF9tYXhcIjo0NDksXCJoYVwiOjc5MixcIm9cIjpcIm0gNDQ5IDQ2MiBsIDM0MyA0NjIgbCAzNDMgOTg2IGwgNDQ5IDk4NiBsIDQ0OSA0NjIgbSA0NDkgLTI0MiBsIDM0MyAtMjQyIGwgMzQzIDI4MCBsIDQ0OSAyODAgbCA0NDkgLTI0MiBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo2MTcsXCJoYVwiOjcyNSxcIm9cIjpcIm0gNDgyIDgwMCBsIDM3MiA4MDAgbCAzNzIgOTI1IGwgNDgyIDkyNSBsIDQ4MiA4MDAgbSAyMzkgODAwIGwgMTI5IDgwMCBsIDEyOSA5MjUgbCAyMzkgOTI1IGwgMjM5IDgwMCBtIDYxNyAzNTIgcSA1NDAgOTMgNjE3IDE5OSBxIDMwOCAtMjQgNDU1IC0yNCBxIDc2IDkzIDE2MSAtMjQgcSAwIDM1MiAwIDE5OSBsIDAgNzM4IGwgMTI2IDczOCBsIDEyNiAzNTQgcSAxNjkgMTg1IDEyNiAyNTcgcSAzMTIgOTggMjIwIDk4IHEgNDUxIDE4NSA0MDIgOTggcSA0OTIgMzU0IDQ5MiAyNTcgbCA0OTIgNzM4IGwgNjE3IDczOCBsIDYxNyAzNTIgXCJ9LFwi77+9XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo1OTMsXCJoYVwiOjY5MCxcIm9cIjpcIm0gNTkzIDQyNSBxIDU1NCAzMTIgNTkzIDM2OSBxIDQ2NyAyMzMgNTE2IDI1NCBxIDUzNyA4MyA1MzcgMTcyIHEgNDU5IC03NCA1MzcgLTEyIHEgMjg4IC0xMzMgMzg3IC0xMzMgcSAxMTUgLTY5IDE4NCAtMTMzIHEgNDcgOTYgNDcgLTYgbCAxNjYgOTYgcSAxOTkgNyAxNjYgNDAgcSAyODggLTI2IDIzMiAtMjYgcSAzNzEgLTUgMzMyIC0yNiBxIDQyMCA2MCA0MjAgMjEgcSAzMTEgMjAxIDQyMCAxMzkgcSAxMDggMzA5IDIxMCAyNTUgcSAwIDQ5MCAwIDM4MyBxIDMzIDYwMiAwIDU1MSBxIDEyNCA2ODcgNjYgNjU0IHEgNzUgNzQzIDkzIDcxMiBxIDU4IDgxMiA1OCA3NzMgcSAxMzMgOTg0IDU4IDkyMCBxIDMwMCAxMDQzIDIwMSAxMDQzIHEgNDU4IDk4NyAzOTQgMTA0MyBxIDUyOSA4MTQgNTI5IDkyNSBsIDQxMSA4MTQgcSAzNzAgOTA4IDQwNCA4NzcgcSAyODkgOTM5IDMzNiA5MzkgcSAyMTMgOTExIDI0NiA5MzkgcSAxODAgODQxIDE4MCA4ODMgcSAyODYgNzIwIDE4MCA3NzkgcSA0ODQgNjEyIDQ4MCA2MTUgcSA1OTMgNDI1IDU5MyA1MzQgbSA0NjcgNDA5IHEgMzU1IDU0NCA0NjcgNDczIHEgMTk2IDYzMCAyMjggNjEyIHEgMTQ2IDU4NyAxNjIgNjA5IHEgMTI0IDUyNSAxMjQgNTU4IHEgMjM5IDM4NyAxMjQgNDYyIHEgMzk4IDI5OCAzNjkgMzE1IHEgNDQ4IDM0NSA0MjkgMzE2IHEgNDY3IDQwOSA0NjcgMzc1IFwifSxcImJcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjY4NSxcImhhXCI6NzgzLFwib1wiOlwibSA2ODUgMzcyIHEgNTk3IDk5IDY4NSAyMTMgcSAzNDcgLTI1IDUwMSAtMjUgcSAyMTkgNSAyNzcgLTI1IHEgMTIxIDkzIDE2MSAzNiBsIDEyMSAwIGwgMCAwIGwgMCAxMDEzIGwgMTIxIDEwMTMgbCAxMjEgNjM0IHEgMjE0IDcyMyAxNTcgNjkyIHEgMzQxIDc1NCAyNzIgNzU0IHEgNTkxIDYzNyA0OTMgNzU0IHEgNjg1IDM3MiA2ODUgNTI2IG0gNTU0IDM1NiBxIDQ5OSA1NTAgNTU0IDQ3MCBxIDMyOCA2NDQgNDM3IDY0NCBxIDE2MiA1NTYgMjIzIDY0NCBxIDEwOCAzNjkgMTA4IDQ3OCBxIDE2MCAxNzYgMTA4IDI1NiBxIDMzMCA4MyAyMjEgODMgcSA0OTggMTY5IDQzNSA4MyBxIDU1NCAzNTYgNTU0IDI0NSBcIn0sXCJxXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo2ODMsXCJoYVwiOjg3NixcIm9cIjpcIm0gNjgzIC0yNzggbCA1NjQgLTI3OCBsIDU2NCA5NyBxIDQ3NCA4IDUzMyAzOSBxIDM0NSAtMjMgNDE1IC0yMyBxIDkxIDkzIDE4OCAtMjMgcSAwIDM2NCAwIDIwMyBxIDg3IDYzNSAwIDUyMiBxIDMzNyA3NjAgMTg0IDc2MCBxIDQ2NiA3MjcgNDA4IDc2MCBxIDU2NCA2MzcgNTIzIDY5NSBsIDU2NCA3MzcgbCA2ODMgNzM3IGwgNjgzIC0yNzggbSA1ODIgMzc1IHEgNTI3IDU2NCA1ODIgNDg4IHEgMzU4IDY1MiA0NjYgNjUyIHEgMTkwIDU2NSAyNTMgNjUyIHEgMTM1IDM3NyAxMzUgNDg4IHEgMTg5IDE3OSAxMzUgMjYxIHEgMzYxIDg0IDI1MSA4NCBxIDUzMCAxNzkgNDY5IDg0IHEgNTgyIDM3NSA1ODIgMjYwIFwifSxcIj9cIjp7XCJ4X21pblwiOi0wLjE3MTg3NSxcInhfbWF4XCI6OTY5LjU2MjUsXCJoYVwiOjEwNjgsXCJvXCI6XCJtIDk2OSAwIGwgNTU1IDAgbCA1NTUgMTIzIHEgNzQ0IDMwOCA2NzUgMTk0IHEgODE0IDU1OCA4MTQgNDIzIHEgNzI2IDgxMiA4MTQgNzA5IHEgNDg0IDkyMiA2MzMgOTIyIHEgMjQ0IDgyMCAzMzQgOTIyIHEgMTU0IDU2NyAxNTQgNzE5IHEgMjIzIDMxNiAxNTQgNDMzIHEgNDEyIDEyMyAyOTIgMTk5IGwgNDEyIDAgbCAwIDAgbCAwIDEyNCBsIDIxNyAxMjQgcSA2OCAzMjcgMTIyIDIxMCBxIDE1IDU3MiAxNSA0NDQgcSAxNDQgOTExIDE1IDc4MSBxIDQ4NCAxMDQxIDI3NCAxMDQxIHEgODIyIDkwOSA2OTEgMTA0MSBxIDk1MyA1NjkgOTUzIDc3NyBxIDg5OSAzMjYgOTUzIDQ0MyBxIDc1MCAxMjQgODQ2IDIxMCBsIDk2OSAxMjQgbCA5NjkgMCBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo2MTcsXCJoYVwiOjcyNSxcIm9cIjpcIm0gNjE3IDM1MiBxIDU0MCA5MyA2MTcgMTk5IHEgMzA4IC0yNCA0NTUgLTI0IHEgNzYgOTMgMTYxIC0yNCBxIDAgMzUyIDAgMTk5IGwgMCA3MzggbCAxMjYgNzM4IGwgMTI2IDM1NCBxIDE2OSAxODUgMTI2IDI1NyBxIDMxMiA5OCAyMjAgOTggcSA0NTEgMTg1IDQwMiA5OCBxIDQ5MiAzNTQgNDkyIDI1NyBsIDQ5MiA3MzggbCA2MTcgNzM4IGwgNjE3IDM1MiBtIDUzNSAxMDQwIGwgMzQ2IDgxOSBsIDI2MiA4MTkgbCAzOTcgMTA0MCBsIDUzNSAxMDQwIFwifSxcInpcIjp7XCJ4X21pblwiOi0wLjAxNTYyNSxcInhfbWF4XCI6NjEzLjg5MDYyNSxcImhhXCI6Njk3LFwib1wiOlwibSA2MTMgMCBsIDAgMCBsIDAgMTAwIGwgNDMzIDYzMCBsIDIwIDYzMCBsIDIwIDczOCBsIDU5NCA3MzggbCA1OTMgNjM2IGwgMTYzIDExMCBsIDYxMyAxMTAgbCA2MTMgMCBcIn0sXCLvv71cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjg5NCxcImhhXCI6MTAwMCxcIm9cIjpcIm0gMzg5IDk1MSBsIDIyOSA5NTEgbCAyMjkgNTAzIGwgMTYwIDUwMyBsIDE2MCA5NTEgbCAwIDk1MSBsIDAgMTAxMSBsIDM4OSAxMDExIGwgMzg5IDk1MSBtIDg5NCA1MDMgbCA4MjcgNTAzIGwgODI3IDkzOSBsIDY4NSA1MDMgbCA2MjAgNTAzIGwgNDgxIDkzNyBsIDQ4MSA1MDMgbCA0MTcgNTAzIGwgNDE3IDEwMTEgbCA1MTcgMTAxMSBsIDY1MyA1ODAgbCA3OTYgMTAxMCBsIDg5NCAxMDExIGwgODk0IDUwMyBcIn0sXCI/XCI6e1wieF9taW5cIjowLjc4MTI1LFwieF9tYXhcIjo2OTcsXCJoYVwiOjgxMCxcIm9cIjpcIm0gNjk3IC0yNzggbCA1NzIgLTI3OCBsIDU3MiA0NTQgcSA1NDAgNTg3IDU3MiA1MzYgcSA0MjUgNjUwIDUwMSA2NTAgcSAyNzEgNTc5IDMzNyA2NTAgcSAyMDYgNDIwIDIwNiA1MDkgbCAyMDYgMCBsIDgxIDAgbCA4MSA0ODkgcSA3MyA1ODggODEgNTYyIHEgMCA2NDQgNTYgNjQ0IGwgMCA3NDEgcSA2OCA3NTUgMzggNzU1IHEgMTU4IDcyMSAxMjQgNzU1IHEgMjAwIDYzMCAxOTMgNjg3IHEgMjk3IDcyNiAyMzQgNjkyIHEgNDM0IDc2MSAzNTkgNzYxIHEgNjIwIDY5MiA1NDQgNzYxIHEgNjk3IDUxNiA2OTcgNjI0IGwgNjk3IC0yNzggbSA0NzkgMTA0MCBsIDI5MCA4MTkgbCAyMDcgODE5IGwgMzQxIDEwNDAgbCA0NzkgMTA0MCBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo5NjAsXCJoYVwiOjEwNTYsXCJvXCI6XCJtIDk2MCA1MDcgcSA4MzMgMTI5IDk2MCAyODAgcSA0NzYgLTMyIDY5OCAtMzIgcSAxMjMgMTI5IDI1NSAtMzIgcSAwIDUwNyAwIDI4MCBxIDEyMyA4ODMgMCA3MzIgcSA0NzYgMTA0NSAyNTUgMTA0NSBxIDgzMiA4ODMgNjk2IDEwNDUgcSA5NjAgNTA3IDk2MCA3MzIgbSA4MTcgNTAwIHEgNzMzIDc4OSA4MTcgNjY5IHEgNDc2IDkyNCA2MzkgOTI0IHEgMjIzIDc5MiAzMTcgOTI0IHEgMTQyIDUwNyAxNDIgNjc1IHEgMjIyIDIyMiAxNDIgMzM5IHEgNDc2IDg5IDMxNSA4OSBxIDczMCAyMTggNjM2IDg5IHEgODE3IDUwMCA4MTcgMzM0IG0gNzE2IDQ0OSBsIDI0MyA0NDkgbCAyNDMgNTcxIGwgNzE2IDU3MSBsIDcxNiA0NDkgXCJ9LFwi77+9XCI6e1wieF9taW5cIjotMyxcInhfbWF4XCI6MTAwOCxcImhhXCI6MTEwNixcIm9cIjpcIm0gNTAzIDUzMiBxIDYxNCA1NjIgNTY2IDUzMiBxIDY3MiA2NTggNjcyIDU5OCBxIDYxNCA3NDcgNjcyIDcxNiBxIDUwMyA3NzIgNTY5IDc3MiBsIDMzOCA3NzIgbCAzMzggNTMyIGwgNTAzIDUzMiBtIDUwMiAtNyBxIDEyMyAxNTEgMjYzIC03IHEgLTMgNTAxIC0zIDI5NCBxIDEyMyA4NTEgLTMgNzA2IHEgNTAyIDEwMTEgMjYzIDEwMTEgcSA4ODEgODUxIDczOSAxMDExIHEgMTAwOCA1MDEgMTAwOCA3MDggcSA4ODMgMTUxIDEwMDggMjkyIHEgNTAyIC03IDc0NCAtNyBtIDUwMiA2MCBxIDgzMCAxOTcgNzA5IDYwIHEgOTQwIDUwMSA5NDAgMzIyIHEgODMxIDgwNSA5NDAgNjgxIHEgNTAyIDk0NCA3MDkgOTQ0IHEgMTc0IDgwNSAyOTYgOTQ0IHEgNjUgNTAxIDY1IDY4MCBxIDE3MyAxOTcgNjUgMzIwIHEgNTAyIDYwIDI5NCA2MCBtIDc4OCAxNDYgbCA2NzggMTQ2IHEgNjUzIDMxNiA2NTUgMTgzIHEgNTI3IDQ0OSA2NTIgNDQ5IGwgMzM4IDQ0OSBsIDMzOCAxNDYgbCAyNDEgMTQ2IGwgMjQxIDg1NCBsIDUxOCA4NTQgcSA2ODggODA4IDYyMSA4NTQgcSA3NjYgNjU4IDc2NiA3NTUgcSA3MzkgNTYzIDc2NiA2MDcgcSA2NjggNDk3IDcxMyA1MTkgcSA3NTEgMzMxIDc0NyA0NzIgcSA3ODggMTY0IDc1NiAxOTAgbCA3ODggMTQ2IFwifSxcIn5cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjgzMyxcImhhXCI6OTMxLFwib1wiOlwibSA4MzMgOTU4IHEgNzc4IDc1MyA4MzMgODMxIHEgNTk0IDY2NSA3MTYgNjY1IHEgNDAyIDc2MSA1MDIgNjY1IHEgMjQwIDg1NyAzMDIgODU3IHEgMTMxIDc5NSAxNjYgODU3IHEgMTA0IDY2NSAxMDQgNzQ1IGwgMCA2NjUgcSA1NCA4NjcgMCA3ODkgcSAyMzcgOTU4IDExNiA5NTggcSA0MjkgODYxIDMzMSA5NTggcSA1OTQgNzY1IDUyNyA3NjUgcSA3MDQgODI3IDY3MCA3NjUgcSA3MjkgOTU4IDcyOSA4NzQgbCA4MzMgOTU4IFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjczNi4yMTg3NSxcImhhXCI6Nzc4LFwib1wiOlwibSA3MzYgMCBsIDAgMCBsIDAgMTAxMyBsIDcyNSAxMDEzIGwgNzI1IDg4OSBsIDEzOSA4ODkgbCAxMzkgNTg1IGwgNjc3IDU4NSBsIDY3NyA0NjcgbCAxMzkgNDY3IGwgMTM5IDEyNSBsIDczNiAxMjUgbCA3MzYgMCBcIn0sXCLvv71cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjQ1MCxcImhhXCI6NTQ3LFwib1wiOlwibSA0NTAgNTUyIHEgMzc5IDQxMyA0NTAgNDY0IHEgMjIwIDM2NiAzMTMgMzY2IHEgNjkgNDE0IDEzMCAzNjYgcSAwIDU2NyAwIDQ3MCBsIDg1IDU2NyBxIDEyNiA0NzAgODUgNTA0IHEgMjI1IDQzNyAxNjggNDM3IHEgMzIwIDQ2NyAyODAgNDM3IHEgMzYwIDU1MiAzNjAgNDk4IHEgMzE4IDYzMiAzNjAgNjA4IHEgMjEzIDY1NyAyNzYgNjU3IHEgMTk1IDY1NyAyMDMgNjU3IHEgMTc2IDY1NyAxODEgNjU3IGwgMTc2IDcyMiBxIDI3OSA3MzMgMjQ5IDcyMiBxIDMzNCA4MTUgMzM0IDc1MiBxIDMwMCA4ODEgMzM0IDg1NiBxIDIyMCA5MDcgMjY3IDkwNyBxIDEzMyA4NzUgMTY5IDkwNyBxIDk3IDc4MSA5NyA4NDQgbCAxNSA3ODEgcSA3OCA5MjYgMTUgODc1IHEgMjIwIDk3MiAxMzUgOTcyIHEgMzY0IDkzMCAzMDMgOTcyIHEgNDI2IDgxNyA0MjYgODg4IHEgMzQ0IDY5NyA0MjYgNzMzIHEgNDIxIDY0MiAzOTIgNjgxIHEgNDUwIDU1MiA0NTAgNjAzIFwifSxcIltcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjI3My42MDkzNzUsXCJoYVwiOjM3MSxcIm9cIjpcIm0gMjczIC0yODEgbCAwIC0yODEgbCAwIDEwMTMgbCAyNzMgMTAxMyBsIDI3MyA5MjAgbCAxMjQgOTIwIGwgMTI0IC0xODcgbCAyNzMgLTE4NyBsIDI3MyAtMjgxIFwifSxcIkxcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjY0NS44MjgxMjUsXCJoYVwiOjY5NixcIm9cIjpcIm0gNjQ1IDAgbCAwIDAgbCAwIDEwMTMgbCAxNDAgMTAxMyBsIDE0MCAxMjYgbCA2NDUgMTI2IGwgNjQ1IDAgXCJ9LFwiP1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6ODAzLjM5MDYyNSxcImhhXCI6ODk0LFwib1wiOlwibSA4MDMgNjI4IGwgNjMzIDYyOCBxIDcxMyAzNjggNzEzIDUxMiBxIDYxOCA5MyA3MTMgMjA0IHEgMzU3IC0yNSA1MTggLTI1IHEgOTQgOTEgMTk0IC0yNSBxIDAgMzY4IDAgMjAxIHEgOTQgNjQ0IDAgNTMzIHEgMzU2IDc2MSAxOTQgNzYxIHEgNDgxIDc1MCAzOTggNzYxIHEgNjA4IDczOSA1NjQgNzM5IGwgODAzIDczOSBsIDgwMyA2MjggbSAzNjAgODUgcSA1MjkgMTgwIDQ2NyA4NSBxIDU4NCAzNzQgNTg0IDI2MiBxIDUyNyA1NjYgNTg0IDQ5MCBxIDM1MiA2NTEgNDYzIDY1MSBxIDE4NyA1NTkgMjQ3IDY1MSBxIDEzNSAzNjggMTM1IDQ3OCBxIDE4OSAxNzUgMTM1IDI1NCBxIDM2MCA4NSAyNTEgODUgXCJ9LFwiP1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NTczLFwiaGFcIjo2NDIsXCJvXCI6XCJtIDU3MyAtNDAgcSA1NTMgLTE2MiA1NzMgLTk3IHEgNTEwIC0yNzggNTQzIC0xOTMgbCA0MDAgLTI3OCBxIDQ0MSAtMTg3IDQyOCAtMjE5IHEgNDYyIC05MCA0NjIgLTEzMiBxIDM3OCAtMTQgNDYyIC0xNCBxIDEwOCA0NSAxOTcgLTE0IHEgMCAyOTAgMCAxMTcgcSAxMDggNjMxIDAgNDYyIHEgMzUzIDkwMSAxOTQgNzY3IGwgNTUgOTAxIGwgNTUgMTAxMiBsIDU2MSAxMDEyIGwgNTYxIDkyNCBxIDI2MSA2NjkgMzgyIDgzMSBxIDEyOCAzMDEgMTI4IDQ4OSBxIDI0MyAxMTcgMTI4IDE0OSBxIDQ1OCA5OCAzNTAgMTA4IHEgNTczIC00MCA1NzMgODAgXCJ9LFwiP1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6Njc0LFwiaGFcIjo3NzgsXCJvXCI6XCJtIDY3NCA0OTYgcSA2MDEgMTYwIDY3NCAzMDQgcSAzMzYgLTI2IDUwOCAtMjYgcSA3MyAxNTMgMTY1IC0yNiBxIDAgNDg1IDAgMjk2IHEgNzIgODQwIDAgNjgzIHEgMzQzIDEwNDUgMTY2IDEwNDUgcSA2MDUgODQ0IDUxNiAxMDQ1IHEgNjc0IDQ5NiA2NzQgNjkyIG0gNTQ2IDU3OSBxIDQ5OCA3OTggNTQ2IDY5MSBxIDMzNiA5MzUgNDM3IDkzNSBxIDE3OCA3OTggMjM3IDkzNSBxIDEyNiA1NzkgMTM3IDcwMSBsIDU0NiA1NzkgbSA1NDYgNDc1IGwgMTI2IDQ3NSBxIDE3MCAyMzMgMTI2IDM0OCBxIDMzOCA4MCAyMzAgODAgcSA1MDQgMjMzIDQ0NyA4MCBxIDU0NiA0NzUgNTQ2IDM0NiBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo5NTgsXCJoYVwiOjEwNTQsXCJvXCI6XCJtIDQ4NSAxMDQyIHEgODM0IDg4MyA3MDMgMTA0MiBxIDk1OCA1MTEgOTU4IDczNSBxIDgzNCAxMzYgOTU4IDI4NyBxIDQ4MSAtMjYgNzAxIC0yNiBxIDEyNiAxMzAgMjYxIC0yNiBxIDAgNTA0IDAgMjc5IHEgMTI3IDg4MCAwIDcyOSBxIDQ4NSAxMDQyIDI2MyAxMDQyIG0gNDgwIDk4IHEgNzMxIDIyNSA2MzggOTggcSA4MTUgNTA0IDgxNSAzNDAgcSA3MzMgNzgzIDgxNSA2NzAgcSA0ODAgOTEzIDY0MCA5MTMgcSAyMjYgNzg1IDMyMSA5MTMgcSAxNDIgNTA0IDE0MiA2NzEgcSAyMjYgMjI0IDE0MiAzMzkgcSA0ODAgOTggMzE5IDk4IFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjcwNS4yODEyNSxcImhhXCI6NzQ5LFwib1wiOlwibSA3MDUgODg2IGwgMTQwIDg4NiBsIDE0MCAwIGwgMCAwIGwgMCAxMDEyIGwgNzA1IDEwMTIgbCA3MDUgODg2IFwifSxcIiBcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjAsXCJoYVwiOjM3NX0sXCIlXCI6e1wieF9taW5cIjotMyxcInhfbWF4XCI6MTA4OSxcImhhXCI6MTE4NixcIm9cIjpcIm0gODQ1IDAgcSA2NjMgNzYgNzMxIDAgcSA2MDIgMjQ0IDYwMiAxNDUgcSA2NjEgNDEyIDYwMiAzNDQgcSA4NDUgNDg5IDcyOCA0ODkgcSAxMDI3IDQxMiA5NTkgNDg5IHEgMTA4OSAyNDQgMTA4OSAzNDMgcSAxMDI5IDc2IDEwODkgMTQ0IHEgODQ1IDAgOTYyIDAgbSA4NDQgMTAzIHEgOTQ1IDE0MyA5MDkgMTAzIHEgOTgxIDI0MyA5ODEgMTg0IHEgOTQ3IDM0MCA5ODEgMzAxIHEgODQ0IDM4NSA5MDkgMzg1IHEgNzQ0IDM0MiA3ODEgMzg1IHEgNzA4IDI0MyA3MDggMzAwIHEgNzQxIDE0NyA3MDggMTg2IHEgODQ0IDEwMyA3ODAgMTAzIG0gODg4IDk4NiBsIDI4NCAtMjUgbCAxOTkgLTI1IGwgODAzIDk4NiBsIDg4OCA5ODYgbSAyNDEgNDY4IHEgNTggNTQ1IDEyNiA0NjggcSAtMyA3MTUgLTMgNjE1IHEgNTYgODgxIC0zIDgxMyBxIDIzOCA5NTggMTI0IDk1OCBxIDQyMSA4ODEgMzUzIDk1OCBxIDQ4MyA3MTIgNDgzIDgxMyBxIDQyMyA1NDQgNDgzIDYxMiBxIDI0MSA0NjggMzU2IDQ2OCBtIDI0MSA4NTUgcSAxMzcgODExIDE3NSA4NTUgcSAxMDAgNzEwIDEwMCA3NjggcSAxMzYgNjEyIDEwMCA2NTMgcSAyNDAgNTcyIDE3MiA1NzIgcSAzNDQgNjE0IDMwNiA1NzIgcSAzODIgNzEzIDM4MiA2NTYgcSAzNDcgODEwIDM4MiA3NzEgcSAyNDEgODU1IDMwOCA4NTUgXCJ9LFwiUFwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NzI2LFwiaGFcIjo4MDYsXCJvXCI6XCJtIDQyNCAxMDEzIHEgNjQwIDkzMSA1NTUgMTAxMyBxIDcyNiA3MTkgNzI2IDg1MCBxIDYzNyA1MDYgNzI2IDU4NyBxIDQxMyA0MjYgNTQ4IDQyNiBsIDE0MCA0MjYgbCAxNDAgMCBsIDAgMCBsIDAgMTAxMyBsIDQyNCAxMDEzIG0gMzc5IDg4OSBsIDE0MCA4ODkgbCAxNDAgNTQ4IGwgMzcyIDU0OCBxIDUyMiA1ODkgNDU5IDU0OCBxIDU5MyA3MjAgNTkzIDYzNyBxIDUyOCA4NDUgNTkzIDgwMSBxIDM3OSA4ODkgNDYzIDg4OSBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjoxMDc4LjIxODc1LFwiaGFcIjoxMTE4LFwib1wiOlwibSAxMDc4IDAgbCAzNDIgMCBsIDM0MiAxMDEzIGwgMTA2NyAxMDEzIGwgMTA2NyA4ODkgbCA0ODEgODg5IGwgNDgxIDU4NSBsIDEwMTkgNTg1IGwgMTAxOSA0NjcgbCA0ODEgNDY3IGwgNDgxIDEyNSBsIDEwNzggMTI1IGwgMTA3OCAwIG0gMjc3IDEwNDAgbCA4MyA3OTkgbCAwIDc5OSBsIDE0MCAxMDQwIGwgMjc3IDEwNDAgXCJ9LFwiP1wiOntcInhfbWluXCI6MC4xMjUsXCJ4X21heFwiOjExMzYuNTQ2ODc1LFwiaGFcIjoxMjM1LFwib1wiOlwibSAxMTM2IDAgbCA3MjIgMCBsIDcyMiAxMjMgcSA5MTEgMzA5IDg0MiAxOTQgcSA5ODEgNTU4IDk4MSA0MjMgcSA4OTMgODEzIDk4MSA3MTAgcSA2NTEgOTIzIDgwMCA5MjMgcSA0MTEgODIxIDUwMSA5MjMgcSAzMjEgNTY4IDMyMSA3MjAgcSAzOTAgMzE2IDMyMSA0MzMgcSA1NzkgMTIzIDQ1OSAyMDAgbCA1NzkgMCBsIDE2NiAwIGwgMTY2IDEyNCBsIDM4NCAxMjQgcSAyMzUgMzI3IDI4OSAyMTAgcSAxODIgNTcyIDE4MiA0NDQgcSAzMTEgOTEyIDE4MiA3ODIgcSA2NTEgMTA0MiA0NDEgMTA0MiBxIDk4OSA5MTAgODU4IDEwNDIgcSAxMTIwIDU2OSAxMTIwIDc3OCBxIDEwNjYgMzI2IDExMjAgNDQzIHEgOTE3IDEyNCAxMDEzIDIxMCBsIDExMzYgMTI0IGwgMTEzNiAwIG0gMjc3IDEwNDAgbCA4MyA4MDAgbCAwIDgwMCBsIDE0MCAxMDQxIGwgMjc3IDEwNDAgXCJ9LFwiX1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NzA1LjU2MjUsXCJoYVwiOjgwMyxcIm9cIjpcIm0gNzA1IC0zMzQgbCAwIC0zMzQgbCAwIC0yMzQgbCA3MDUgLTIzNCBsIDcwNSAtMzM0IFwifSxcIj9cIjp7XCJ4X21pblwiOi0xMTAsXCJ4X21heFwiOjI0NixcImhhXCI6Mjc1LFwib1wiOlwibSAyNDYgMTA0NiBsIDExOCAxMDQ2IGwgMTE4IDExODkgbCAyNDYgMTE4OSBsIDI0NiAxMDQ2IG0gMTggMTA0NiBsIC0xMTAgMTA0NiBsIC0xMTAgMTE4OSBsIDE4IDExODkgbCAxOCAxMDQ2IG0gMTM2IDAgbCAwIDAgbCAwIDEwMTIgbCAxMzYgMTAxMiBsIDEzNiAwIFwifSxcIitcIjp7XCJ4X21pblwiOjIzLFwieF9tYXhcIjo3NjgsXCJoYVwiOjc5MixcIm9cIjpcIm0gNzY4IDM3MiBsIDQ0NCAzNzIgbCA0NDQgMCBsIDM0NyAwIGwgMzQ3IDM3MiBsIDIzIDM3MiBsIDIzIDQ2OCBsIDM0NyA0NjggbCAzNDcgODQwIGwgNDQ0IDg0MCBsIDQ0NCA0NjggbCA3NjggNDY4IGwgNzY4IDM3MiBcIn0sXCLvv71cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjEwNTAsXCJoYVwiOjExNDksXCJvXCI6XCJtIDEwNTAgMCBsIDYyNSAwIHEgNzEyIDE3OCA2MjUgMTA4IHEgODc4IDI3NyA3MjIgMTg3IHEgOTY3IDM4NSA5NjcgMzI4IHEgOTMyIDQ1NiA5NjcgNDI5IHEgODUwIDQ4NCA4OTcgNDg0IHEgNzU5IDQ1MCA3OTggNDg0IHEgNzIxIDM1MiA3MjEgNDE2IGwgNjQwIDM1MiBxIDcwNiA1MDIgNjQwIDQ0OCBxIDg1MSA1NTEgNzY2IDU1MSBxIDk4NyA1MDkgOTMxIDU1MSBxIDEwNTAgMzg1IDEwNTAgNDYyIHEgOTc2IDI1MSAxMDUwIDMwMSBxIDgyOSAxNzkgOTAyIDIxNSBxIDcxNyA2OCA3NDAgMTMzIGwgMTA1MCA2OCBsIDEwNTAgMCBtIDgzNCA5ODUgbCAyMTUgLTI4IGwgMTMwIC0yOCBsIDc1MCA5ODQgbCA4MzQgOTg1IG0gMjI0IDQyMiBsIDE0MiA0MjIgbCAxNDIgODExIGwgMCA4MTEgbCAwIDg2NyBxIDEwNCA4ODkgNjIgODY3IHEgMTY0IDk3MyAxNTcgOTE2IGwgMjI0IDk3MyBsIDIyNCA0MjIgXCJ9LFwiP1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NzIwLFwiaGFcIjo3ODMsXCJvXCI6XCJtIDQyNCAxMDEzIHEgNjM3IDkzMyA1NTQgMTAxMyBxIDcyMCA3MjMgNzIwIDg1MyBxIDYzMyA1MDggNzIwIDU5MSBxIDQxMyA0MjYgNTQ2IDQyNiBsIDE0MCA0MjYgbCAxNDAgMCBsIDAgMCBsIDAgMTAxMyBsIDQyNCAxMDEzIG0gMzc4IDg4OSBsIDE0MCA4ODkgbCAxNDAgNTQ4IGwgMzcxIDU0OCBxIDUyMSA1ODkgNDU4IDU0OCBxIDU5MiA3MjAgNTkyIDYzNyBxIDUyNyA4NDUgNTkyIDgwMSBxIDM3OCA4ODkgNDYzIDg4OSBcIn0sXCInXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjoxMzksXCJoYVwiOjIzNixcIm9cIjpcIm0gMTM5IDg1MSBxIDEwMiA3MzcgMTM5IDc4NCBxIDAgNjY5IDY1IDY5MCBsIDAgNzM0IHEgNTkgNzg3IDQyIDc0MSBxIDcyIDg3MyA3MiA4MjEgbCAwIDg3MyBsIDAgMTAxMyBsIDEzOSAxMDEzIGwgMTM5IDg1MSBcIn0sXCLvv71cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjM1MCxcImhhXCI6Mzk3LFwib1wiOlwibSAzNTAgNjI1IHEgMzA3IDYxNiAzMjggNjE2IHEgMjY2IDYzMSAyODEgNjE2IHEgMjQ3IDY3MyAyNTEgNjQ1IHEgMTkwIDYyOCAyMjUgNjQ0IHEgMTE2IDYxMyAxNTYgNjEzIHEgMzIgNjQxIDY0IDYxMyBxIDAgNzIyIDAgNjY5IHEgNzIgODI2IDAgODAwIHEgMjQ3IDg2NiAxNTkgODQ2IGwgMjQ3IDg4NyBxIDIyMCA5MzQgMjQ3IDkxNiBxIDE2MiA5NTMgMTk0IDk1MyBxIDEwNCA5MzQgMTI5IDk1MyBxIDc2IDg4MiA4MCA5MTUgbCAxNiA4ODIgcSA2MCA5NzYgMTYgOTQxIHEgMTY2IDEwMTEgMTA0IDEwMTEgcSAyNjYgOTc5IDIyNCAxMDExIHEgMzA4IDg5MSAzMDggOTQ4IGwgMzA4IDcwNiBxIDMxMSA2NzkgMzA4IDY4OCBxIDMzMSA2NzAgMzE1IDY3MCBsIDM1MCA2NzIgbCAzNTAgNjI1IG0gMjQ3IDc1NyBsIDI0NyA4MTEgcSAxMzYgNzkwIDE3NSA3OTggcSA2NCA3MjYgNjQgNzczIHEgODMgNjgyIDY0IDY5NyBxIDEzMiA2NjcgMTAzIDY2NyBxIDIwNyA2OTAgMTc0IDY2NyBxIDI0NyA3NTcgMjQ3IDcxOCBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo0NTAsXCJoYVwiOjU1MyxcIm9cIjpcIm0gNDUwIDgwMCBsIDM0MCA4MDAgbCAzNDAgOTI1IGwgNDUwIDkyNSBsIDQ1MCA4MDAgbSA0MDYgMTA0MCBsIDIxMiA4MDAgbCAxMjkgODAwIGwgMjY5IDEwNDAgbCA0MDYgMTA0MCBtIDExMCA4MDAgbCAwIDgwMCBsIDAgOTI1IGwgMTEwIDkyNSBsIDExMCA4MDAgXCJ9LFwiVFwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6Nzc3LFwiaGFcIjo4MzUsXCJvXCI6XCJtIDc3NyA4OTQgbCA0NTggODk0IGwgNDU4IDAgbCAzMTkgMCBsIDMxOSA4OTQgbCAwIDg5NCBsIDAgMTAxMyBsIDc3NyAxMDEzIGwgNzc3IDg5NCBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo5MTUsXCJoYVwiOjk5NyxcIm9cIjpcIm0gNTI3IDAgbCAzODkgMCBsIDM4OSAxMjIgcSAxMTAgMjMxIDIyMCAxMjIgcSAwIDUwOSAwIDM0MCBxIDExMCA3ODUgMCA2NzcgcSAzODkgODkzIDIyMCA4OTMgbCAzODkgMTAxMyBsIDUyNyAxMDEzIGwgNTI3IDg5MyBxIDgwNCA3ODYgNjkzIDg5MyBxIDkxNSA1MDkgOTE1IDY3OSBxIDgwNSAyMzEgOTE1IDM0MSBxIDUyNyAxMjIgNjk2IDEyMiBsIDUyNyAwIG0gNTI3IDIyNiBxIDcxMiAzMTAgNjQxIDIyNiBxIDc3OSA1MDcgNzc5IDM4OSBxIDcxMiA3MDUgNzc5IDYyNyBxIDUyNyA3ODcgNjQxIDc4NyBsIDUyNyAyMjYgbSAzODkgMjI2IGwgMzg5IDc4NyBxIDIwNSA2OTggMjc1IDc3NSBxIDEzNiA1MDUgMTM2IDYyMCBxIDIwNiAzMDggMTM2IDM5MSBxIDM4OSAyMjYgMjc2IDIyNiBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjowLFwiaGFcIjo2OTR9LFwialwiOntcInhfbWluXCI6LTc3Ljc4MTI1LFwieF9tYXhcIjoxNjcsXCJoYVwiOjM0OSxcIm9cIjpcIm0gMTY3IDg3MSBsIDQyIDg3MSBsIDQyIDEwMTMgbCAxNjcgMTAxMyBsIDE2NyA4NzEgbSAxNjcgLTgwIHEgMTIxIC0yMzEgMTY3IC0xODQgcSAtMjYgLTI3OCA3NiAtMjc4IGwgLTc3IC0yNzggbCAtNzcgLTE2NCBsIC00MSAtMTY0IHEgMjYgLTE0MyAxMSAtMTY0IHEgNDIgLTY1IDQyIC0xMjIgbCA0MiA3MzcgbCAxNjcgNzM3IGwgMTY3IC04MCBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo3NTYuOTUzMTI1LFwiaGFcIjo4MTksXCJvXCI6XCJtIDc1NiAwIGwgMCAwIGwgMCAxMDcgbCAzOTUgNTIzIGwgMjIgOTA0IGwgMjIgMTAxMyBsIDc0NSAxMDEzIGwgNzQ1IDg4OSBsIDIwOSA4ODkgbCA1NjYgNTIzIGwgMTg3IDEyNSBsIDc1NiAxMjUgbCA3NTYgMCBcIn0sXCIxXCI6e1wieF9taW5cIjoyMTUuNjcxODc1LFwieF9tYXhcIjo1NzQsXCJoYVwiOjc5MixcIm9cIjpcIm0gNTc0IDAgbCA0NDIgMCBsIDQ0MiA2OTcgbCAyMTUgNjk3IGwgMjE1IDc5NiBxIDM4NiA4MzMgMzMwIDc5NiBxIDQ3NSA5ODYgNDQ3IDg3NSBsIDU3NCA5ODYgbCA1NzQgMCBcIn0sXCLvv71cIjp7XCJ4X21pblwiOjE4LjA2MjUsXCJ4X21heFwiOjc3NCxcImhhXCI6NzkyLFwib1wiOlwibSA3NzQgMzc2IGwgMTggNDAgbCAxOCAxNDkgbCA2MzEgNDIxIGwgMTggNjkyIGwgMTggNzk5IGwgNzc0IDQ2NSBsIDc3NCAzNzYgXCJ9LFwiPFwiOntcInhfbWluXCI6MTcuOTg0Mzc1LFwieF9tYXhcIjo3NzMuNjA5Mzc1LFwiaGFcIjo3OTIsXCJvXCI6XCJtIDc3MyA0MCBsIDE4IDM3NiBsIDE3IDQ2NSBsIDc3MyA3OTkgbCA3NzMgNjkyIGwgMTU5IDQyMCBsIDc3MyAxNDkgbCA3NzMgNDAgXCJ9LFwi77+9XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo3MDQuNDg0Mzc1LFwiaGFcIjo4MDEsXCJvXCI6XCJtIDcwNCA0MSBxIDYyMyAtMTAgNjY0IDUgcSA1NDMgLTI2IDU4MyAtMjYgcSAzNTkgMTUgNTAxIC0yNiBxIDI0MyAzNiAyODggMzYgcSAxNTggMjMgMTk3IDM2IHEgNzMgLTIxIDExOSAxMCBsIDYgNzYgcSAxMjUgMTk1IDkwIDE1MCBxIDE3NSAzMzEgMTc1IDI2MiBxIDE0NyA0NDMgMTc1IDM4MyBsIDAgNDQzIGwgMCA1MTIgbCAxMDggNTEyIHEgNDMgNzM0IDQzIDYyMyBxIDEyMCA5MjkgNDMgODU0IHEgMzU4IDEwMTAgMjA0IDEwMTAgcSA1NzkgOTM2IDQ4NyAxMDEwIHEgNjc4IDcyOSA2NzggODU3IGwgNjc4IDY4NCBsIDU1MiA2ODQgcSA1MDQgODM4IDU1MiA3ODAgcSAzNjIgODk2IDQ1NyA4OTYgcSAyMTYgODUyIDI2MyA4OTYgcSAxNzYgNzQ3IDE3NiA4MTUgcSAxOTkgNjI3IDE3NiA2OTcgcSAyNDggNTEyIDIxNyA1NzQgbCA0NjggNTEyIGwgNDY4IDQ0MyBsIDI3OSA0NDMgcSAyOTcgMzU2IDI5NyAzOTggcSAyMzAgMTk0IDI5NyAyNzkgcSAxNTMgMTA3IDIxMSAxNzAgcSAyMjcgMTMzIDE5MCAxMjUgcSAyOTMgMTQyIDI2NCAxNDIgcSA0MTAgMTE5IDMzOSAxNDIgcSA1MTYgOTYgNDgyIDk2IHEgNTc5IDEwNSA1NTAgOTYgcSA2NDggMTQyIDYwOCAxMTUgbCA3MDQgNDEgXCJ9LFwidFwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6MzY3LFwiaGFcIjo0NTgsXCJvXCI6XCJtIDM2NyAwIHEgMzEyIC01IDMzOSAtMiBxIDI2MiAtOCAyODQgLTggcSAxNDUgMjggMTgzIC04IHEgMTA4IDE0MyAxMDggNjQgbCAxMDggNjM4IGwgMCA2MzggbCAwIDczOCBsIDEwOCA3MzggbCAxMDggOTQ0IGwgMjMyIDk0NCBsIDIzMiA3MzggbCAzNjcgNzM4IGwgMzY3IDYzOCBsIDIzMiA2MzggbCAyMzIgMTg1IHEgMjQ4IDEyMSAyMzIgMTQwIHEgMzA3IDEwMiAyNjQgMTAyIHEgMzQ1IDEwNCAzMzAgMTAyIHEgMzY3IDEwNyAzNjAgMTA3IGwgMzY3IDAgXCJ9LFwi77+9XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo3MDYsXCJoYVwiOjgwMyxcIm9cIjpcIm0gNzA2IDQxMSBsIDcwNiAxNTggbCA2MzAgMTU4IGwgNjMwIDMzNSBsIDAgMzM1IGwgMCA0MTEgbCA3MDYgNDExIFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjc1MCxcImhhXCI6ODAzLFwib1wiOlwibSA3NTAgLTcgcSA2NzkgLTE1IDcxNiAtMTUgcSA1MzggNTkgNTkxIC0xNSBxIDQ2NiAyMTQgNTEyIDk3IGwgMzM2IDU1MSBsIDEyNiAwIGwgMCAwIGwgMjcwIDcwNSBxIDIyMyA4MzcgMjQ3IDc3MCBxIDExNiA4OTkgMTkwIDg5OSBxIDkwIDg5OCAxMDAgODk5IGwgOTAgMTAwNCBxIDE1MiAxMDExIDEyNSAxMDExIHEgMjk4IDkzOCAyNDQgMTAxMSBxIDM3MyA3ODMgMzI2IDkwMSBsIDYwNSAxOTIgcSA2NDkgMTE1IDYyOSAxMzYgcSA3MTYgOTUgNjY5IDk1IGwgNzM2IDk1IHEgNzUwIDk3IDc0NSA5NyBsIDc1MCAtNyBcIn0sXCJXXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjoxMjYzLjg5MDYyNSxcImhhXCI6MTM1MSxcIm9cIjpcIm0gMTI2MyAxMDEzIGwgOTk1IDAgbCA4NTkgMCBsIDYyNyA4MzcgbCA0MDUgMCBsIDI2NSAwIGwgMCAxMDEzIGwgMTM2IDEwMTMgbCAzNDIgMjAyIGwgNTU2IDEwMTMgbCA3MDEgMTAxMyBsIDkyMSAyMDcgbCAxMTMzIDEwMTIgbCAxMjYzIDEwMTMgXCJ9LFwiPlwiOntcInhfbWluXCI6MTguMDYyNSxcInhfbWF4XCI6Nzc0LFwiaGFcIjo3OTIsXCJvXCI6XCJtIDc3NCAzNzYgbCAxOCA0MCBsIDE4IDE0OSBsIDYzMSA0MjEgbCAxOCA2OTIgbCAxOCA3OTkgbCA3NzQgNDY1IGwgNzc0IDM3NiBcIn0sXCJ2XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo2NzUuMTU2MjUsXCJoYVwiOjc2MSxcIm9cIjpcIm0gNjc1IDczOCBsIDQwNCAwIGwgMjcyIDAgbCAwIDczOCBsIDEzMyA3MzcgbCAzNDAgMTQ3IGwgNTQxIDczNyBsIDY3NSA3MzggXCJ9LFwiP1wiOntcInhfbWluXCI6MC4yODEyNSxcInhfbWF4XCI6NjQ0LjUsXCJoYVwiOjcwMyxcIm9cIjpcIm0gNjQ0IDYyOCBsIDM4MiA2MjggbCAzODIgMTc5IHEgMzg4IDEyMCAzODIgMTM3IHEgNDM2IDkxIDQwMSA5MSBxIDQ3NCA5NCA0NDcgOTEgcSA1MDQgOTcgNTAxIDk3IGwgNTA0IDAgcSA0NTQgLTkgNDgyIC01IHEgNDAxIC0xNCA0MjYgLTE0IHEgMjc4IDY3IDMwOCAtMTQgcSAyNjAgMjMzIDI2MCAxMTggbCAyNjAgNjI4IGwgMCA2MjggbCAwIDczOSBsIDY0NCA3MzkgbCA2NDQgNjI4IFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjYyNC45Mzc1LFwiaGFcIjo2OTksXCJvXCI6XCJtIDYyNCAtMzcgcSA2MDggLTE1MyA2MjQgLTk2IHEgNTYzIC0yNzggNTkzIC0yMTEgbCA0NTQgLTI3OCBxIDQ5MSAtMTgzIDQ4NiAtMjAwIHEgNTExIC04MyA1MTEgLTEyNiBxIDQ4NCAtMjMgNTExIC00NCBxIDM3MCAxIDQ1MiAxIHEgMzIzIDAgMzU0IDEgcSAyODMgLTEgMjkzIC0xIHEgODQgNzYgMTY5IC0xIHEgMCAyNjYgMCAxNTQgcSA1NiA0MzEgMCAzNTggcSAxOTcgNTM4IDEwOCA0OTggcSA5NCA2MTMgMTM0IDU2MiBxIDU0IDczMCA1NCA2NjUgcSA3NyA4MjMgNTQgNzgwIHEgMTQzIDkwMSAxMDEgODY3IGwgMjcgOTAxIGwgMjcgMTAxMiBsIDU3NiAxMDEyIGwgNTc2IDkwMSBsIDM4MCA5MDEgcSAyNDQgODYzIDMwMyA5MDEgcSAxNzggNzQ1IDE3OCA4MjAgcSAzMTIgNjAwIDE3OCA2MzYgcSA1MzIgNTgyIDM4MCA1ODIgbCA1MzIgNDc5IHEgMjc2IDQ1NSAzNjEgNDc5IHEgMTE4IDI4MSAxMTggNDEwIHEgMTY1IDE3MyAxMTggMjE3IHEgMjc0IDEyMCAyMDggMTMzIHEgNDk0IDEwMSAzODQgMTEwIHEgNjI0IC0zNyA2MjQgNzYgXCJ9LFwiJlwiOntcInhfbWluXCI6LTMsXCJ4X21heFwiOjg5NC4yNSxcImhhXCI6OTkyLFwib1wiOlwibSA4OTQgMCBsIDcyNSAwIGwgNjI0IDEyMyBxIDQ3MSAwIDU1MyA0MCBxIDMwNiAtNDEgMzkwIC00MSBxIDE2OCAtNyAyMzEgLTQxIHEgNjIgOTIgMTA1IDI2IHEgMTQgMTg3IDMxIDEzOSBxIC0zIDI3NiAtMyAyMzUgcSA1NSA0MzMgLTMgMzU4IHEgMjQ4IDU4MSAxMTQgNTA4IHEgMTcwIDY4OSAxOTYgNjQwIHEgMTM3IDgxNyAxMzcgNzUxIHEgMjE0IDk4NSAxMzcgOTIyIHEgMzg0IDEwNDEgMjg0IDEwNDEgcSA1NDggOTg4IDQ4MyAxMDQxIHEgNjIyIDgyNCA2MjIgOTI4IHEgNTYzIDY2NiA2MjIgNzM5IHEgNDMxIDU1NiA1MTYgNjA4IGwgNjIxIDMyNiBxIDY0OSA0MDcgNjM5IDM2MSBxIDY2MyA0OTMgNjUzIDQyNiBsIDc4MSA0OTMgcSA3MDMgMjI5IDc4MSAzNTIgbCA4OTQgMCBtIDUwNCA4MTggcSA0NjggOTA4IDUwNCA4NzcgcSAzODQgOTQwIDQzMyA5NDAgcSAyOTMgOTA3IDMzMSA5NDAgcSAyNTUgODE4IDI1NSA4NzUgcSAyODkgNzE0IDI1NSA3NjcgcSAzNjMgNjI4IDMxMyA2NzggcSA0NzcgNzI5IDQ0NiA2ODIgcSA1MDQgODE4IDUwNCA3NzEgbSA1NTYgMjA5IGwgMzE0IDQ5OSBxIDE3OSAzOTUgMjIzIDQ0OSBxIDEzNSAyODMgMTM1IDM0MSBxIDE0NiAyMjIgMTM1IDI1MyBxIDE4MyAxNTggMTU4IDE5MiBxIDMzMyA4MCAyNDEgODAgcSA1NTYgMjA5IDQ0OCA4MCBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo4NjIuNSxcImhhXCI6OTQyLFwib1wiOlwibSA4NjIgMCBsIDcxOSAwIGwgNDI2IDg0NyBsIDE0MyAwIGwgMCAwIGwgMzU2IDEwMTMgbCA1MDEgMTAxMyBsIDg2MiAwIFwifSxcIklcIjp7XCJ4X21pblwiOjQxLFwieF9tYXhcIjoxODAsXCJoYVwiOjI5MyxcIm9cIjpcIm0gMTgwIDAgbCA0MSAwIGwgNDEgMTAxMyBsIDE4MCAxMDEzIGwgMTgwIDAgXCJ9LFwiR1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6OTIxLFwiaGFcIjoxMDExLFwib1wiOlwibSA5MjEgMCBsIDgzMiAwIGwgODAxIDEzNiBxIDY1NSAxNSA3NDEgNTggcSA0NzAgLTI4IDU2OCAtMjggcSAxMjYgMTMzIDI1OSAtMjggcSAwIDQ5OSAwIDI4NCBxIDEyNSA4ODEgMCA3MzEgcSA0ODYgMTA0MyAyNTkgMTA0MyBxIDc2MyA5NTcgNjQ3IDEwNDMgcSA5MDUgNzA5IDg5MCA4NjQgbCA3NzIgNzA5IHEgNjY4IDg2NiA3NDcgODA3IHEgNDg2IDkyNiA1ODkgOTI2IHEgMjI4IDc5NSAzMjIgOTI2IHEgMTQyIDUwNyAxNDIgNjc3IHEgMjI4IDIyNCAxNDIgMzQyIHEgNDgzIDk0IDMyMyA5NCBxIDcxMiAxOTUgNjI1IDk0IHEgNzk2IDQzNSA3OTYgMjkxIGwgNDc3IDQzNSBsIDQ3NyA1NDkgbCA5MjEgNTQ5IGwgOTIxIDAgXCJ9LFwiP1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NjE3LFwiaGFcIjo3MjUsXCJvXCI6XCJtIDUyNCA4MDAgbCA0MTQgODAwIGwgNDE0IDkyNSBsIDUyNCA5MjUgbCA1MjQgODAwIG0gMTgzIDgwMCBsIDczIDgwMCBsIDczIDkyNSBsIDE4MyA5MjUgbCAxODMgODAwIG0gNjE3IDM1MiBxIDU0MCA5MyA2MTcgMTk5IHEgMzA4IC0yNCA0NTUgLTI0IHEgNzYgOTMgMTYxIC0yNCBxIDAgMzUyIDAgMTk5IGwgMCA3MzggbCAxMjYgNzM4IGwgMTI2IDM1NCBxIDE2OSAxODUgMTI2IDI1NyBxIDMxMiA5OCAyMjAgOTggcSA0NTEgMTg1IDQwMiA5OCBxIDQ5MiAzNTQgNDkyIDI1NyBsIDQ5MiA3MzggbCA2MTcgNzM4IGwgNjE3IDM1MiBtIDQ4OSAxMDQwIGwgMzAwIDgxOSBsIDIxNiA4MTkgbCAzNTEgMTA0MCBsIDQ4OSAxMDQwIFwifSxcImBcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjEzOC44OTA2MjUsXCJoYVwiOjIzNixcIm9cIjpcIm0gMTM4IDY5OSBsIDAgNjk5IGwgMCA4NjEgcSAzNiA5NzQgMCA5MjkgcSAxMzggMTA0MSA3MiAxMDIwIGwgMTM4IDk3NyBxIDgyIDkzMSA5NSA5NjkgcSA2OSA4MzkgNjkgODkzIGwgMTM4IDgzOSBsIDEzOCA2OTkgXCJ9LFwi77+9XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjoxNDIsXCJoYVwiOjIzOSxcIm9cIjpcIm0gMTQyIDU4NSBsIDAgNTg1IGwgMCA3MzggbCAxNDIgNzM4IGwgMTQyIDU4NSBcIn0sXCI/XCI6e1wieF9taW5cIjowLjMyODEyNSxcInhfbWF4XCI6ODE5LjUxNTYyNSxcImhhXCI6ODg5LFwib1wiOlwibSA4MTkgMTAxMyBsIDQ4MiA0MTYgbCA0ODIgMCBsIDM0MiAwIGwgMzQyIDQxNiBsIDAgMTAxMyBsIDE0MCAxMDEzIGwgNDExIDUzMyBsIDY3OSAxMDEzIGwgODE5IDEwMTMgXCJ9LFwiclwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6MzU1LjU2MjUsXCJoYVwiOjQzMixcIm9cIjpcIm0gMzU1IDYyMSBsIDM0MyA2MjEgcSAxNzkgNTY5IDIzNiA2MjEgcSAxMjIgNDExIDEyMiA1MTggbCAxMjIgMCBsIDAgMCBsIDAgNzM3IGwgMTE3IDczNyBsIDExNyA2MDQgcSAyMDQgNzE5IDE0NiA2ODYgcSAzNTUgNzUzIDI2MiA3NTMgbCAzNTUgNjIxIFwifSxcInhcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjY3NSxcImhhXCI6NzY0LFwib1wiOlwibSA2NzUgMCBsIDUyNSAwIGwgMzMxIDI4NiBsIDE0NCAwIGwgMCAwIGwgMjU2IDM3OSBsIDEyIDczOCBsIDE1NyA3MzcgbCAzMzYgNDczIGwgNTE2IDczOCBsIDY2MSA3MzggbCA0MTIgMzgwIGwgNjc1IDAgXCJ9LFwiP1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6Njk2LjYwOTM3NSxcImhhXCI6NzQ3LFwib1wiOlwibSA2OTYgLTQgcSA2MjggLTE0IDY1NyAtMTQgcSA0OTggOTcgNTEzIC0xNCBxIDQyMiA4IDQ3MCA0MSBxIDMxMyAtMjQgMzc0IC0yNCBxIDIwNyAzIDI1OCAtMjQgcSAxMjAgODAgMTU3IDMxIGwgMTIwIC0yNzggbCAwIC0yNzggbCAwIDczOCBsIDEyNCA3MzggbCAxMjQgMzQzIHEgMTY1IDE3MiAxMjQgMjQ2IHEgMzA4IDgyIDIxNiA4MiBxIDQ1MSAxNzcgNDAyIDgyIHEgNDkyIDM1OCA0OTIgMjU0IGwgNDkyIDczOCBsIDYxNiA3MzggbCA2MTYgMjE0IHEgNjIzIDEzNiA2MTYgMTYwIHEgNjczIDkyIDYzNiA5MiBxIDY5NiA5NSA2ODQgOTIgbCA2OTYgLTQgXCJ9LFwiaFwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NjE1LFwiaGFcIjo3MjQsXCJvXCI6XCJtIDYxNSA0NzIgbCA2MTUgMCBsIDQ5MCAwIGwgNDkwIDQ1NCBxIDQ1NiA1OTAgNDkwIDUzNSBxIDMzOCA2NTQgNDE2IDY1NCBxIDE4NiA1ODggMjUxIDY1NCBxIDEyMiA0MzYgMTIyIDUyMiBsIDEyMiAwIGwgMCAwIGwgMCAxMDEzIGwgMTIyIDEwMTMgbCAxMjIgNjMzIHEgMjE4IDcyNyAxNDkgNjk0IHEgMzYyIDc2MCAyODcgNzYwIHEgNTUyIDY3NiA0ODQgNzYwIHEgNjE1IDQ3MiA2MTUgNjAwIFwifSxcIi5cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjE0MixcImhhXCI6MjM5LFwib1wiOlwibSAxNDIgMCBsIDAgMCBsIDAgMTUxIGwgMTQyIDE1MSBsIDE0MiAwIFwifSxcIj9cIjp7XCJ4X21pblwiOi0yLFwieF9tYXhcIjo4NzgsXCJoYVwiOjk3NCxcIm9cIjpcIm0gNDk2IC0yNzkgbCAzNzggLTI3OSBsIDM3OCAtMTcgcSAxMDEgODggMjA0IC0xNyBxIC0yIDM2NyAtMiAxOTQgcSA2OCA2MjYgLTIgNTEwIHEgMjgzIDc1OCAxNTEgNzU4IGwgMjgzIDY0NiBxIDE2NyA1MzcgMjA5IDYyNiBxIDEzMyAzNzMgMTMzIDQ2MiBxIDE5MiAxNzcgMTMzIDI1NCBxIDM3OCA5MyAyNTkgOTMgbCAzNzggNzU4IHEgNDQ1IDc2NCA0MjYgNzYzIHEgNDc2IDc2NSA0NjQgNzY1IHEgNzY1IDY1OSA2NTMgNzY1IHEgODc4IDM3NyA4NzggNTUzIHEgNzcxIDk2IDg3OCAyMDkgcSA0OTYgLTE3IDY2NSAtMTcgbCA0OTYgLTI3OSBtIDQ5NiA5MyBsIDUxNCA5MyBxIDY4NyAxODMgNjIzIDkzIHEgNzQ2IDM4MCA3NDYgMjY1IHEgNjkxIDU2OSA3NDYgNDkxIHEgNTIyIDY1OCA2MjkgNjU4IGwgNDk2IDY1NiBsIDQ5NiA5MyBcIn0sXCI7XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjoxNDIsXCJoYVwiOjIzOSxcIm9cIjpcIm0gMTQyIDU4NSBsIDAgNTg1IGwgMCA3MzggbCAxNDIgNzM4IGwgMTQyIDU4NSBtIDE0MiAtMTIgcSAxMDUgLTEzMiAxNDIgLTgyIHEgMCAtMjA2IDY4IC0xODIgbCAwIC0xMzggcSA1OCAtODIgNDMgLTEyMyBxIDY4IDAgNjggLTU2IGwgMCAwIGwgMCAxNTEgbCAxNDIgMTUxIGwgMTQyIC0xMiBcIn0sXCJmXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjozNzgsXCJoYVwiOjQ3MixcIm9cIjpcIm0gMzc4IDYzOCBsIDI0NiA2MzggbCAyNDYgMCBsIDEyMSAwIGwgMTIxIDYzOCBsIDAgNjM4IGwgMCA3MzggbCAxMjEgNzM4IHEgMTM3IDkzNSAxMjEgODg3IHEgMjkwIDEwMjggMTcxIDEwMjggcSAzMjAgMTAyNyAzMDUgMTAyOCBxIDM3OCAxMDIxIDMzNCAxMDI2IGwgMzc4IDkwOCBxIDMyMyA5MTggMzQ2IDkxOCBxIDI1NyA4NzAgMjczIDkxOCBxIDI0NiA3ODAgMjQ2IDg0MCBsIDI0NiA3MzggbCAzNzggNzM4IGwgMzc4IDYzOCBcIn0sXCLvv71cIjp7XCJ4X21pblwiOjEsXCJ4X21heFwiOjM0OC4yMTg3NSxcImhhXCI6NDU0LFwib1wiOlwibSAxNDAgNjcwIGwgMSA2NzAgbCAxIDgzMCBxIDM3IDk0MyAxIDg5NyBxIDE0MCAxMDExIDc0IDk5MCBsIDE0MCA5NDcgcSA4MiA5MDAgOTcgOTQwIHEgNjggODEwIDY4IDg2MSBsIDE0MCA4MTAgbCAxNDAgNjcwIG0gMzQ4IDY3MCBsIDIwOSA2NzAgbCAyMDkgODMwIHEgMjQ1IDk0MyAyMDkgODk3IHEgMzQ4IDEwMTEgMjgyIDk5MCBsIDM0OCA5NDcgcSAyOTAgOTAwIDMwNSA5NDAgcSAyNzYgODEwIDI3NiA4NjEgbCAzNDggODEwIGwgMzQ4IDY3MCBcIn0sXCJBXCI6e1wieF9taW5cIjowLjAzMTI1LFwieF9tYXhcIjo5MDYuOTUzMTI1LFwiaGFcIjoxMDA4LFwib1wiOlwibSA5MDYgMCBsIDc1NiAwIGwgNjQ4IDMwMyBsIDI1MSAzMDMgbCAxNDIgMCBsIDAgMCBsIDM3NiAxMDEzIGwgNTI5IDEwMTMgbCA5MDYgMCBtIDYxMCA0MjEgbCA0NTIgODY3IGwgMjkzIDQyMSBsIDYxMCA0MjEgXCJ9LFwiNlwiOntcInhfbWluXCI6NTMsXCJ4X21heFwiOjczOSxcImhhXCI6NzkyLFwib1wiOlwibSA3MzkgMzEyIHEgNjMzIDYyIDczOSAxNjIgcSA0MDAgLTMxIDUzNCAtMzEgcSAxNjIgNzggMjU3IC0zMSBxIDUzIDQzOSA1MyAyMDYgcSAxNzggODU5IDUzIDcxMiBxIDQ0MSA5ODYgMjg0IDk4NiBxIDY0MyA5MTIgNTU5IDk4NiBxIDczMiA3MTMgNzMyIDgzMyBsIDYwMSA3MTMgcSA1NDQgODMwIDU5NCA3ODYgcSA0MjYgODc1IDQ5NCA4NzUgcSAyNjggNzkzIDMzMSA4NzUgcSAxOTMgNTE3IDE5MyA2OTcgcSAzMDEgNTk3IDI0MCA1NzAgcSA0MjcgNjI0IDM2MiA2MjQgcSA2NDMgNTQwIDU1MiA2MjQgcSA3MzkgMzEyIDczOSA0NTEgbSA2MDMgMjk4IHEgNTQwIDQ2MSA2MDMgNDAwIHEgNDA0IDUxNiA0ODQgNTE2IHEgMjY4IDQ2MSAzMjMgNTE2IHEgMjA3IDMwMCAyMDcgNDAxIHEgMjY5IDEzNyAyMDcgMTk4IHEgNDA1IDgzIDMyNSA4MyBxIDU0MSAxMzcgNDg2IDgzIHEgNjAzIDI5OCA2MDMgMTk3IFwifSxcIu+/vVwiOntcInhfbWluXCI6MSxcInhfbWF4XCI6MTM5Ljg5MDYyNSxcImhhXCI6MjM2LFwib1wiOlwibSAxMzkgNjcwIGwgMSA2NzAgbCAxIDgzMCBxIDM3IDk0MyAxIDg5NyBxIDEzOSAxMDExIDc0IDk5MCBsIDEzOSA5NDcgcSA4MiA5MDAgOTcgOTQwIHEgNjggODEwIDY4IDg2MSBsIDEzOSA4MTAgbCAxMzkgNjcwIFwifSxcIj9cIjp7XCJ4X21pblwiOi03MCxcInhfbWF4XCI6MjgzLFwiaGFcIjozNjEsXCJvXCI6XCJtIDI4MyA4MDAgbCAxNzMgODAwIGwgMTczIDkyNSBsIDI4MyA5MjUgbCAyODMgODAwIG0gNDAgODAwIGwgLTcwIDgwMCBsIC03MCA5MjUgbCA0MCA5MjUgbCA0MCA4MDAgbSAyODMgMyBxIDIzMiAtMTAgMjU3IC01IHEgMTgxIC0xNSAyMDYgLTE1IHEgODQgMjYgMTE4IC0xNSBxIDQxIDIwMCA0MSA3OSBsIDQxIDczNyBsIDE2NiA3MzcgbCAxNjcgMjE1IHEgMTcxIDE0MSAxNjcgMTU3IHEgMjI1IDEwMSAxODIgMTAxIHEgMjQ3IDEwMyAyMzggMTAxIHEgMjgzIDExMiAyNTYgMTA0IGwgMjgzIDMgXCJ9LFwiP1wiOntcInhfbWluXCI6LTAuMjE4NzUsXCJ4X21heFwiOjc3My4yMTg3NSxcImhhXCI6ODU3LFwib1wiOlwibSA3NzMgLTcgbCA3MDcgLTExIHEgNTc1IDQwIDYwNyAtMTEgcSA1NTIgMTc0IDU1MiA3NyBsIDU1MiAyMjYgbCA1NTIgNjI2IGwgMjIyIDYyNiBsIDIyMiAwIGwgOTcgMCBsIDk3IDYyNiBsIDAgNjI2IGwgMCA3MzcgbCA3NzMgNzM3IGwgNzczIDYyNiBsIDY3NiA2MjYgbCA2NzYgMTcxIHEgNjk1IDEwMyA2NzYgMTE3IHEgNzczIDkwIDcxNCA5MCBsIDc3MyAtNyBcIn0sXCI/XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo3NjUuNTYyNSxcImhhXCI6ODA5LFwib1wiOlwibSA3NjUgLTQgcSA2OTggLTE0IDcyNiAtMTQgcSA1NjQgOTcgNTg2IC0xNCBxIDQ2NiA3IDUyNSA0MCBxIDMzNyAtMjYgNDA3IC0yNiBxIDg4IDk4IDE4NiAtMjYgcSAwIDM2OSAwIDIxMiBxIDg4IDYzNyAwIDUyNSBxIDMzNyA3NjAgMTg0IDc2MCBxIDQ2NSA3MjcgNDA3IDc2MCBxIDU2MyA2MzcgNTI0IDY5NSBsIDU2MyA3MzggbCA2ODUgNzM4IGwgNjg1IDIyMiBxIDY5MyAxNDEgNjg1IDE2OCBxIDc0OCA5NCA3MDggOTQgcSA3NjUgOTUgNzYwIDk0IGwgNzY1IC00IG0gNTg0IDM3MSBxIDUzMSA1NjIgNTg0IDQ4NSBxIDM2MCA2NTMgNDcwIDY1MyBxIDE5MiA1NjYgMjU0IDY1MyBxIDEzNSAzNzkgMTM1IDQ4OSBxIDE4NiAxODEgMTM1IDI2MSBxIDM1OCA4NCAyNDcgODQgcSA1MjggMTc2IDQ2NSA4NCBxIDU4NCAzNzEgNTg0IDI2MCBtIDYwNCAxMDQwIGwgNDE1IDgxOSBsIDMzMiA4MTkgbCA0NjYgMTA0MCBsIDYwNCAxMDQwIFwifSxcIk9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjk1OCxcImhhXCI6MTA1NyxcIm9cIjpcIm0gNDg1IDEwNDEgcSA4MzQgODgyIDcwMiAxMDQxIHEgOTU4IDUxMiA5NTggNzM0IHEgODM0IDEzNiA5NTggMjg3IHEgNDgxIC0yNiA3MDIgLTI2IHEgMTI2IDEzMCAyNjEgLTI2IHEgMCA1MDQgMCAyNzkgcSAxMjcgODgwIDAgNzI4IHEgNDg1IDEwNDEgMjYzIDEwNDEgbSA0ODAgOTggcSA3MzEgMjI1IDYzOCA5OCBxIDgxNSA1MDQgODE1IDM0MCBxIDczMyA3ODMgODE1IDY2OSBxIDQ4MCA5MTIgNjQwIDkxMiBxIDIyNiA3ODQgMzIxIDkxMiBxIDE0MiA1MDQgMTQyIDY3MCBxIDIyNiAyMjQgMTQyIDMzOSBxIDQ4MCA5OCAzMTkgOTggXCJ9LFwiblwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NjE1LFwiaGFcIjo3MjQsXCJvXCI6XCJtIDYxNSA0NjMgbCA2MTUgMCBsIDQ5MCAwIGwgNDkwIDQ1NCBxIDQ1MyA1OTIgNDkwIDUzNyBxIDMzMSA2NTYgNDEwIDY1NiBxIDE3OCA1ODUgMjQwIDY1NiBxIDExNyA0MjEgMTE3IDUxNCBsIDExNyAwIGwgMCAwIGwgMCA3MzggbCAxMTcgNzM4IGwgMTE3IDYzMCBxIDIxOCA3MjggMTUwIDY5MyBxIDM1OSA3NjQgMjg2IDc2NCBxIDU1MiA2NzUgNDg0IDc2NCBxIDYxNSA0NjMgNjE1IDU5MyBcIn0sXCIzXCI6e1wieF9taW5cIjo1NCxcInhfbWF4XCI6NzM3LFwiaGFcIjo3OTIsXCJvXCI6XCJtIDczNyAyODQgcSA2MzUgNTUgNzM3IDE0MSBxIDM5OSAtMjUgNTQxIC0yNSBxIDE1NiA1MiAyNDggLTI1IHEgNTQgMzA4IDU0IDE0MCBsIDE4NSAzMDggcSAyNDUgMTQ3IDE4NSAyMDIgcSAzOTUgOTYgMzAyIDk2IHEgNTM5IDE0MCA0ODQgOTYgcSA2MDIgMjgwIDYwMiAxOTAgcSA1MTAgNDI5IDYwMiAzOTAgcSAzMjQgNDU0IDQ1MSA0NTQgbCAzMjQgNTY1IHEgNDg3IDU4NCA0NDEgNTY1IHEgNTY1IDcxOSA1NjUgNjE3IHEgNTE1IDgzNSA1NjUgNzkxIHEgMzk1IDg3OSA0NjYgODc5IHEgMjU1IDgyNCAzMDcgODc5IHEgMjAzIDY2MSAyMDMgNzY5IGwgNzggNjYxIHEgMTY2IDkwOSA3OCA4MjIgcSAzODcgOTkyIDI1MCA5OTIgcSA2MDMgOTIxIDUxMyA5OTIgcSA3MDEgNzIzIDcwMSA4NDQgcSA2NjkgNjA3IDcwMSA2NTYgcSA1NzggNTI0IDYzNyA1NTggcSA2OTYgNDM0IDY1NSA0OTkgcSA3MzcgMjg0IDczNyAzNjkgXCJ9LFwiOVwiOntcInhfbWluXCI6NTMsXCJ4X21heFwiOjczOSxcImhhXCI6NzkyLFwib1wiOlwibSA3MzkgNTI0IHEgNjE5IDk0IDczOSAyNDEgcSAzNjIgLTMyIDUxNiAtMzIgcSAxNTAgNDcgMjQyIC0zMiBxIDU5IDI0NCA1OSAxMjYgbCAxOTEgMjQ0IHEgMjQ2IDEyOSAxOTEgMTc2IHEgMzczIDgyIDMwMSA4MiBxIDUyNiAxNjEgNDY2IDgyIHEgNTk3IDQ0MCA1OTcgMjU1IHEgMzYzIDMzNCA1MDEgMzM0IHEgMTMwIDQzMiAyMTYgMzM0IHEgNTMgNjUwIDUzIDUyMSBxIDEzNCA4ODAgNTMgNzg2IHEgMzgzIDk4NiAyMjYgOTg2IHEgNjU5IDg0MSA1NjYgOTg2IHEgNzM5IDUyNCA3MzkgNzE5IG0gMzg4IDQ0OSBxIDUzNSA1MTQgNDgwIDQ0OSBxIDU4NSA2NTggNTg1IDU3MyBxIDUzNSA4MDUgNTg1IDc0NCBxIDM4OCA4NzMgNDgwIDg3MyBxIDI0MiA4MDkgMjk0IDg3MyBxIDE5MSA2NTggMTkxIDc0NSBxIDIzOSA1MTQgMTkxIDU3MiBxIDM4OCA0NDkgMjkyIDQ0OSBcIn0sXCJsXCI6e1wieF9taW5cIjo0MSxcInhfbWF4XCI6MTY2LFwiaGFcIjoyNzksXCJvXCI6XCJtIDE2NiAwIGwgNDEgMCBsIDQxIDEwMTMgbCAxNjYgMTAxMyBsIDE2NiAwIFwifSxcIu+/vVwiOntcInhfbWluXCI6NDAuMDkzNzUsXCJ4X21heFwiOjcyOC43OTY4NzUsXCJoYVwiOjgyNSxcIm9cIjpcIm0gNzI4IDMwNCBsIDY0OSAyMjQgbCA1MTIgMzYzIHEgMzgzIDMzMSA0NTggMzMxIHEgMjU2IDM2MyAzMTAgMzMxIGwgMTE5IDIyNCBsIDQwIDMwNCBsIDE3NyA0NDEgcSAxNTAgNTUzIDE1MCA0OTMgcSAxODQgNjczIDE1MCA2MjEgbCA0MCA4MTggbCAxMTkgODk4IGwgMjY3IDc0OSBxIDMyMSA3NjYgMjkxIDc1OSBxIDM4NCA3NzMgMzUxIDc3MyBxIDQ0NyA3NjYgNDE3IDc3MyBxIDUwMSA3NDkgNDc3IDc1OSBsIDY0OSA4OTggbCA3MjggODE4IGwgNTg1IDY3NSBxIDYxMiA2MTggNjA0IDY0OCBxIDYyMSA1NTMgNjIxIDU4NyBxIDU5MSA0NDEgNjIxIDQ5MSBsIDcyOCAzMDQgbSAzODQgNjgyIHEgMjgwIDY0MyAzMTggNjgyIHEgMjQzIDU1MSAyNDMgNjA0IHEgMjc5IDQ2MSAyNDMgNDk5IHEgMzgzIDQyMyAzMTYgNDIzIHEgNDg3IDQ2MSA0NDkgNDIzIHEgNTI1IDU1MyA1MjUgNTAwIHEgNDkwIDY0MSA1MjUgNjA1IHEgMzg0IDY4MiA0NTEgNjgyIFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjYzMi4zMjgxMjUsXCJoYVwiOjY3OSxcIm9cIjpcIm0gNjMyIDAgbCA0ODIgMCBsIDIyNSAzODQgbCAxMjQgMjg4IGwgMTI0IDAgbCAwIDAgbCAwIDczOCBsIDEyNCA3MzggbCAxMjQgNDQ2IGwgNDMzIDczOCBsIDU5NiA3MzggbCAzMTIgNDY2IGwgNjMyIDAgXCJ9LFwiNFwiOntcInhfbWluXCI6NDgsXCJ4X21heFwiOjc0Mi40NTMxMjUsXCJoYVwiOjc5MixcIm9cIjpcIm0gNzQyIDI0MyBsIDYwMiAyNDMgbCA2MDIgMCBsIDQ3NiAwIGwgNDc2IDI0MyBsIDQ4IDI0MyBsIDQ4IDM2OCBsIDQ3NiA5NTggbCA2MDIgOTU4IGwgNjAyIDM1NCBsIDc0MiAzNTQgbCA3NDIgMjQzIG0gNDc2IDM1NCBsIDQ3NiA3OTIgbCAxNjIgMzU0IGwgNDc2IDM1NCBcIn0sXCJwXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo2ODUsXCJoYVwiOjc4NixcIm9cIjpcIm0gNjg1IDM2NCBxIDU5OCA5NiA2ODUgMjA1IHEgMzUwIC0yMyA1MDQgLTIzIHEgMTIxIDg5IDIwNSAtMjMgbCAxMjEgLTI3OCBsIDAgLTI3OCBsIDAgNzM4IGwgMTIxIDczOCBsIDEyMSA2MzMgcSAyMjAgNzI2IDE1OSA2OTEgcSAzNTEgNzYxIDI4MCA3NjEgcSA1OTggNjM2IDUwNCA3NjEgcSA2ODUgMzY0IDY4NSA1MjIgbSA1NTcgMzcxIHEgNTAxIDU2MCA1NTcgNDgxIHEgMzMwIDY1MSA0MzcgNjUxIHEgMTYyIDU1OSAyMjMgNjUxIHEgMTA4IDM2NiAxMDggNDc5IHEgMTYyIDE3NyAxMDggMjU0IHEgMzMzIDg3IDIyNCA4NyBxIDUwMiAxNzggNDQxIDg3IHEgNTU3IDM3MSA1NTcgMjU4IFwifSxcIu+/vVwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6Nzc3LFwiaGFcIjo4MzUsXCJvXCI6XCJtIDQ1OCAyMzggbCA0NTggMCBsIDMxOSAwIGwgMzE5IDIzOCBsIDAgMjM4IGwgMCAzNjAgbCAzMTkgMzYwIGwgMzE5IDY4MSBsIDAgNjgzIGwgMCA4MDQgbCAzMTkgODA0IGwgMzE5IDEwMTUgbCA0NTggMTAxMyBsIDQ1OCA4MDQgbCA3NzcgODA0IGwgNzc3IDY4MyBsIDQ1OCA2ODMgbCA0NTggMzYwIGwgNzc3IDM2MCBsIDc3NyAyMzggbCA0NTggMjM4IFwifSxcIj9cIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjgwOCxcImhhXCI6OTA3LFwib1wiOlwibSA0NjUgLTI3OCBsIDM0MSAtMjc4IGwgMzQxIC0xNSBxIDg3IDEwMiAxODAgLTE1IHEgMCAzNzggMCAyMTAgbCAwIDczOSBsIDEzMyA3MzkgbCAxMzMgMzc5IHEgMTgyIDE5NSAxMzMgMjc1IHEgMzQxIDk4IDI0MiA5OCBsIDM0MSA5MjIgbCA0NjUgOTIyIGwgNDY1IDk4IHEgNjIzIDE5NSA1NjMgOTggcSA2NzUgMzgyIDY3NSAyNzggbCA2NzUgNzQyIGwgODA4IDc0MiBsIDgwOCAzODEgcSA3MjAgMTA0IDgwOCAyMTMgcSA0NjYgLTEzIDYyNyAtMTMgbCA0NjUgLTI3OCBcIn0sXCI/XCI6e1wieF9taW5cIjowLjc4MTI1LFwieF9tYXhcIjo2OTcsXCJoYVwiOjgxMCxcIm9cIjpcIm0gNjk3IC0yNzggbCA1NzIgLTI3OCBsIDU3MiA0NTQgcSA1NDAgNTg3IDU3MiA1MzYgcSA0MjUgNjUwIDUwMSA2NTAgcSAyNzEgNTc5IDMzNyA2NTAgcSAyMDYgNDIwIDIwNiA1MDkgbCAyMDYgMCBsIDgxIDAgbCA4MSA0ODkgcSA3MyA1ODggODEgNTYyIHEgMCA2NDQgNTYgNjQ0IGwgMCA3NDEgcSA2OCA3NTUgMzggNzU1IHEgMTU4IDcyMCAxMjQgNzU1IHEgMjAwIDYzMCAxOTMgNjg2IHEgMjk3IDcyNiAyMzQgNjkyIHEgNDM0IDc2MSAzNTkgNzYxIHEgNjIwIDY5MiA1NDQgNzYxIHEgNjk3IDUxNiA2OTcgNjI0IGwgNjk3IC0yNzggXCJ9fSxcImNzc0ZvbnRXZWlnaHRcIjpcIm5vcm1hbFwiLFwiYXNjZW5kZXJcIjoxMTg5LFwidW5kZXJsaW5lUG9zaXRpb25cIjotMTAwLFwiY3NzRm9udFN0eWxlXCI6XCJub3JtYWxcIixcImJvdW5kaW5nQm94XCI6e1wieU1pblwiOi0zMzQsXCJ4TWluXCI6LTExMSxcInlNYXhcIjoxMTg5LFwieE1heFwiOjE2NzJ9LFwicmVzb2x1dGlvblwiOjEwMDAsXCJvcmlnaW5hbF9mb250X2luZm9ybWF0aW9uXCI6e1wicG9zdHNjcmlwdF9uYW1lXCI6XCJIZWx2ZXRpa2VyLVJlZ3VsYXJcIixcInZlcnNpb25fc3RyaW5nXCI6XCJWZXJzaW9uIDEuMDAgMjAwNCBpbml0aWFsIHJlbGVhc2VcIixcInZlbmRvcl91cmxcIjpcImh0dHA6Ly93d3cubWFnZW50YS5nci9cIixcImZ1bGxfZm9udF9uYW1lXCI6XCJIZWx2ZXRpa2VyXCIsXCJmb250X2ZhbWlseV9uYW1lXCI6XCJIZWx2ZXRpa2VyXCIsXCJjb3B5cmlnaHRcIjpcIkNvcHlyaWdodCAoYykgP2FnZW50YSBsdGQsIDIwMDRcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcInRyYWRlbWFya1wiOlwiXCIsXCJkZXNpZ25lclwiOlwiXCIsXCJkZXNpZ25lcl91cmxcIjpcIlwiLFwidW5pcXVlX2ZvbnRfaWRlbnRpZmllclwiOlwiP2FnZW50YSBsdGQ6SGVsdmV0aWtlcjoyMi0xMC0xMDRcIixcImxpY2Vuc2VfdXJsXCI6XCJodHRwOi8vd3d3LmVsbGFrLmdyL2ZvbnRzL01nT3Blbi9saWNlbnNlLmh0bWxcIixcImxpY2Vuc2VfZGVzY3JpcHRpb25cIjpcIkNvcHlyaWdodCAoYykgMjAwNCBieSBNQUdFTlRBIEx0ZC4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cXHJcXG5cXHJcXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoZSBmb250cyBhY2NvbXBhbnlpbmcgdGhpcyBsaWNlbnNlIChcXFwiRm9udHNcXFwiKSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXFxcIkZvbnQgU29mdHdhcmVcXFwiKSwgdG8gcmVwcm9kdWNlIGFuZCBkaXN0cmlidXRlIHRoZSBGb250IFNvZnR3YXJlLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBGb250IFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgRm9udCBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOiBcXHJcXG5cXHJcXG5UaGUgYWJvdmUgY29weXJpZ2h0IGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb2Ygb25lIG9yIG1vcmUgb2YgdGhlIEZvbnQgU29mdHdhcmUgdHlwZWZhY2VzLlxcclxcblxcclxcblRoZSBGb250IFNvZnR3YXJlIG1heSBiZSBtb2RpZmllZCwgYWx0ZXJlZCwgb3IgYWRkZWQgdG8sIGFuZCBpbiBwYXJ0aWN1bGFyIHRoZSBkZXNpZ25zIG9mIGdseXBocyBvciBjaGFyYWN0ZXJzIGluIHRoZSBGb250cyBtYXkgYmUgbW9kaWZpZWQgYW5kIGFkZGl0aW9uYWwgZ2x5cGhzIG9yIGNoYXJhY3RlcnMgbWF5IGJlIGFkZGVkIHRvIHRoZSBGb250cywgb25seSBpZiB0aGUgZm9udHMgYXJlIHJlbmFtZWQgdG8gbmFtZXMgbm90IGNvbnRhaW5pbmcgdGhlIHdvcmQgXFxcIk1nT3BlblxcXCIsIG9yIGlmIHRoZSBtb2RpZmljYXRpb25zIGFyZSBhY2NlcHRlZCBmb3IgaW5jbHVzaW9uIGluIHRoZSBGb250IFNvZnR3YXJlIGl0c2VsZiBieSB0aGUgZWFjaCBhcHBvaW50ZWQgQWRtaW5pc3RyYXRvci5cXHJcXG5cXHJcXG5UaGlzIExpY2Vuc2UgYmVjb21lcyBudWxsIGFuZCB2b2lkIHRvIHRoZSBleHRlbnQgYXBwbGljYWJsZSB0byBGb250cyBvciBGb250IFNvZnR3YXJlIHRoYXQgaGFzIGJlZW4gbW9kaWZpZWQgYW5kIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBcXFwiTWdPcGVuXFxcIiBuYW1lLlxcclxcblxcclxcblRoZSBGb250IFNvZnR3YXJlIG1heSBiZSBzb2xkIGFzIHBhcnQgb2YgYSBsYXJnZXIgc29mdHdhcmUgcGFja2FnZSBidXQgbm8gY29weSBvZiBvbmUgb3IgbW9yZSBvZiB0aGUgRm9udCBTb2Z0d2FyZSB0eXBlZmFjZXMgbWF5IGJlIHNvbGQgYnkgaXRzZWxmLiBcXHJcXG5cXHJcXG5USEUgRk9OVCBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcXFwiQVMgSVNcXFwiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gQU5ZIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5UIE9GIENPUFlSSUdIVCwgUEFURU5ULCBUUkFERU1BUkssIE9SIE9USEVSIFJJR0hULiBJTiBOTyBFVkVOVCBTSEFMTCBNQUdFTlRBIE9SIFBFUlNPTlMgT1IgQk9ESUVTIElOIENIQVJHRSBPRiBBRE1JTklTVFJBVElPTiBBTkQgTUFJTlRFTkFOQ0UgT0YgVEhFIEZPTlQgU09GVFdBUkUgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBJTkNMVURJTkcgQU5ZIEdFTkVSQUwsIFNQRUNJQUwsIElORElSRUNULCBJTkNJREVOVEFMLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgVEhFIFVTRSBPUiBJTkFCSUxJVFkgVE8gVVNFIFRIRSBGT05UIFNPRlRXQVJFIE9SIEZST00gT1RIRVIgREVBTElOR1MgSU4gVEhFIEZPTlQgU09GVFdBUkUuXCIsXCJtYW51ZmFjdHVyZXJfbmFtZVwiOlwiP2FnZW50YSBsdGRcIixcImZvbnRfc3ViX2ZhbWlseV9uYW1lXCI6XCJSZWd1bGFyXCJ9LFwiZGVzY2VuZGVyXCI6LTMzNCxcImZhbWlseU5hbWVcIjpcIkhlbHZldGlrZXJcIixcImxpbmVIZWlnaHRcIjoxNTIyLFwidW5kZXJsaW5lVGhpY2tuZXNzXCI6NTB9KTsiXX0=
